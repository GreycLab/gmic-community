#@gmic
#----------------------------------------------------------------------
#
#  File        : iain_fergusson.gmic   <-- Put your filename here.
#                ( G'MIC commands file )
#
#  Description : External Filters by Iain Fergusson.
#
#  Location    : If you are using the G'MIC plug-in for GIMP, and made
#                a filter update via Internet, a copy of this file
#                should be located in the folder :
#
#                  $HOME/.gmic_def.xxxx    (on Unix-based OS).
#                  %APPDATA/gmic_def.xxxx  (on Windows-based OS).
#
#  Copyright   : Iain Fergusson
#                ( http://iainfergusson.co.nz)
#
#  License     : Attribution-NonCommercial-ShareAlike 3.0 New Zealand
#     http://creativecommons.org/licenses/by-nc-sa/3.0/nz/
#
#----------------------------------------------------------------------
#@gui _<b>Colors</b>

####################################
#          Saturation EQ           #
####################################
#@gui Saturation EQ : Saturation_EQ_p, Saturation_EQ_p
#@gui : note = note{"<b>Lightness</b>"}
#@gui : Black = float(0,-128,128)
#@gui : Near Black = float(0,-128,128)
#@gui : Dark Grey= float(0,-128,128)
#@gui : Mid-Dark Grey = float(0,-128,128)
#@gui : Middle Grey = float(0,-128,128)
#@gui : Mid-Light Grey= float(0,-128,128)
#@gui : Light Grey = float(0,-128,128)
#@gui : Highlights= float(0,-128,128)
#@gui : White= float(0,-128,128)
#@gui : sep = separator()
#@gui : note = note{"<b>Hue</b>"}
#@gui : 0 = float(0,-128,128)
#@gui : 45 = float(0,-128,128)
#@gui : 90= float(0,-128,128)
#@gui : 135 = float(0,-128,128)
#@gui : 180 = float(0,-128,128)
#@gui : 225= float(0,-128,128)
#@gui : 270 = float(0,-128,128)
#@gui : 315= float(0,-128,128)
#@gui : 360= float(0,-128,128)
#@gui : Rotate Hue Bands= float (0,-45,45)
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note{"This filter allows you to adjust the Saturation based on the Lightness or Hue of the pixel. The <i>Rotate Hue Bands</i> control allows you shift the hue that each band controls by 45 degrees."}
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
variance_noise :
  u {${-std_noise}^2}

Saturation_EQ_p:
  repeat $! l[$>]
    apply_parallel_overlap "Saturation_EQ ${1-19}",
  endl done

Saturation_EQ:
  repeat $! l[$>] split_opacity l[0]
    to_rgb rgb2hsl8
    split[-1] c
    +apply_curve[2] .5,0,{128+$1},31,{128+$2},63,{128+$3},95,{128+$4},128,{128+$5},160,{128+$6},192,{128+$7},224,{128+$8},255,{128+$9}
    ++[0] {((($19/360)*255))*-1}
    mod[-1] 255
    apply_curve[-1] .5,0,{128+$10},31,{128+$11},63,{128+$12},95,{128+$13},128,{128+$14},160,{128+$15},192,{128+$16},224,{128+$17},255,{128+$18}
    sub[-1,-2] 128
    add[-1,-2]
    mul[-1] 2
    add[1,3]
    c[1] 0,255
    append c
    hsl82rgb
  endl a c endl done

####################################
#           CMYK Tone              #
####################################
#@gui CMYK Tone : iain_cmyk_tone_p, iain_cmyk_tone_p
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust cyans</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)

#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust Magentas</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)

#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust Yellows</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)

#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Cyan = int(0,-255,255)
#@gui : Some Cyan = int(0,-255,255)
#@gui : Little Cyan = int(0,-255,255)
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Magenta = int(0,-255,255)
#@gui : Some Magenta = int(0,-255,255)
#@gui : Little Magenta = int(0,-255,255)
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Yellow = int(0,-255,255)
#@gui : Some Yellow = int(0,-255,255)
#@gui : Little Yellow = int(0,-255,255)
#@gui : note = note{"<b>Adjust Key</b> for pixels that have:"}
#@gui : A Lot of Key = int(0,-255,255)
#@gui : Some Key = int(0,-255,255)
#@gui : Little Key = int(0,-255,255)

#@gui : sep = separator()
#@gui : note = note{"Strength of effect for Saturation level:"}
#@gui : None  = int(255,0,255)
#@gui : Little  = int(255,0,255)
#@gui : Some = int(255,0,255)
#@gui : Much  = int(255,0,255)
#@gui : Most  = int(255,0,255)
#@gui : sep = separator()
#@gui : Output = choice(0,"Perserve Luminance","Clip CMYK","Clip RGB","Scale CMYK","Scale RGB")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
iain_cmyk_tone_p:
  apply_parallel_overlap "iain_cmyk_tone ${1--2}",0,${-1}

iain_cmyk_tone:
  repeat $! l[$>] split_opacity l[0]
    rgb2cmyk
    +split c
    +apply_curve[1] 0,0,$1,128,$2,255,$3
    +apply_curve[2] 0,0,$4,128,$5,255,$6
    +apply_curve[3] 0,0,$7,128,$8,255,$9
    +apply_curve[4] 0,0,$10,128,$11,255,$12
    add[-1,-2,-3,-4]

    +apply_curve[1] 0,0,$13,128,$14,255,$15
    +apply_curve[2] 0,0,$16,128,$17,255,$18
    +apply_curve[3] 0,0,$19,128,$20,255,$21
    +apply_curve[4] 0,0,$22,128,$23,255,$24
    add[-1,-2,-3,-4]

    +apply_curve[1] 0,0,$25,128,$26,255,$27
    +apply_curve[2] 0,0,$28,128,$29,255,$30
    +apply_curve[3] 0,0,$31,128,$32,255,$33
    +apply_curve[4] 0,0,$34,128,$35,255,$36
    add[-1,-2,-3,-4]

    +apply_curve[1] 0,0,$37,128,$38,255,$39
    +apply_curve[2] 0,0,$40,128,$41,255,$42
    +apply_curve[3] 0,0,$43,128,$44,255,$45
    +apply_curve[4] 0,0,$46,128,$47,255,$48
    add[-1,-2,-3,-4]
    add[1,5]
    add[2,5]
    add[3,5]
    add[4,5]

    a[-1,-2,-3,-4] c
    +sub[0,1]
    +cmyk2rgb[0] rgb2hsv[-1] split[-1] c remove[-1,-3] mul[-1] 255
    apply_curve[-1] 0,0,$49,64,$50,128,$51,192,$52,255,$53
    compose_multiply[-1,-2]
    +sub[0,-1]

    if $54==0
      cmyk2rgb
      luminance[0]
      +luminance[-1]
      compose_grainextract[-1,-2]
      compose_grainmerge[0,-1]
      keep[0]
    endif
    if $54==1
      keep[-1]
      c 0,255
      cmyk2rgb
    endif
    if $54==2
      keep[-1]
      cmyk2rgb
      c 0,255
    endif
    if $54==3
      keep[-1]
      n 0,255
      cmyk2rgb
    endif
    if $54==4
      keep[-1]
      cmyk2rgb
      n 0,255
    endif
  endl a c endl done

####################################
#             RGB Tone             #
####################################
#@gui RGB Tone: iain_rgb_tone, iain_rgb_tone
#@gui : note = note{"<b>Adjust Reds</b> for pixels that have:"}
#@gui : Little Red = float(0,-255,255)
#@gui : Some Red = float(0,-255,255)
#@gui : Much Red = float(0,-255,255)
#@gui : note = note{"<b>Adjust Reds</b> for pixels that have:"}
#@gui : Little Green = float(0,-255,255)
#@gui : Some Green = float(0,-255,255)
#@gui : Much Green = float(0,-255,255)
#@gui : note = note{"<b>Adjust Reds</b> for pixels that have:"}
#@gui : Little Blue = float(0,-255,255)
#@gui : Some Blue = float(0,-255,255)
#@gui : Much Blue = float(0,-255,255)
#@gui : sep = separator(xx)
#@gui : note = note{"<b>Adjust Greens</b> for pixels that have:"}
#@gui : Little Red = float(0,-255,255)
#@gui : Some Red = float(0,-255,255)
#@gui : Much Red = float(0,-255,255)
#@gui : note = note{"<b>Adjust Greens</b> for pixels that have:"}
#@gui : Little Green = float(0,-255,255)
#@gui : Some Green = float(0,-255,255)
#@gui : Much Green = float(0,-255,255)
#@gui : note = note{"<b>Adjust Greens</b> for pixels that have:"}
#@gui : Little Blue = float(0,-255,255)
#@gui : Some Blue = float(0,-255,255)
#@gui : Much Blue = float(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"<b>Adjust Blues</b> for pixels that have:"}
#@gui : Little Red = float(0,-255,255)
#@gui : Some Red = float(0,-255,255)
#@gui : Much Red = float(0,-255,255)
#@gui : note = note{"<b>Adjust Blues</b> for pixels that have:"}
#@gui : Little Green = float(0,-255,255)
#@gui : Some Green = float(0,-255,255)
#@gui : Much Green = float(0,-255,255)
#@gui : note = note{"<b>Adjust Blues</b> for pixels that have:"}
#@gui : Little Blue = float(0,-255,255)
#@gui : Some Blue = float(0,-255,255)
#@gui : Much Blue = float(0,-255,255)
#@gui : sep = separator()
#@gui : note = note{"Strength of effect for Saturation level:"}
#@gui : None  = float(255,0,255)
#@gui : Little  = float(255,0,255)
#@gui : Some = float(255,0,255)
#@gui : Much  = float(255,0,255)
#@gui : Most  = float(255,0,255)
#@gui : sep = separator()
#@gui : Output = choice(0,"Perserve Luminance","Clip","Scale")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
iain_rgb_tone:
  repeat $! l[$>] split_opacity l[0]
    to_rgb
    +split c
    +apply_curve[1] 0,0,$1,128,$2,255,$3
    +apply_curve[2] 0,0,$4,128,$5,255,$6
    +apply_curve[3] 0,0,$7,128,$8,255,$9
    add[-1,-2,-3]

    +apply_curve[1] 0,0,$10,128,$11,255,$12
    +apply_curve[2] 0,0,$13,128,$14,255,$15
    +apply_curve[3] 0,0,$16,128,$17,255,$18
    add[-1,-2,-3]

    +apply_curve[1] 0,0,$19,128,$20,255,$21
    +apply_curve[2] 0,0,$22,128,$23,255,$24
    +apply_curve[3] 0,0,$25,128,$26,255,$27
    add[-1,-2,-3]
    add[1,4]
    add[2,4]
    add[3,4]

    a[-1,-2,-3] c
    +sub[0,1]
    +rgb2hsv[0] split[-1] c remove[-1,-3] mul[-1] 255
    apply_curve[-1] 0,0,$28,64,$29,128,$30,192,$31,255,$32
    compose_multiply[-1,-2]
    +sub[0,-1]

    if $33==0
      luminance[0]
      +luminance[-1]
      compose_grainextract[-1,-2]
      compose_grainmerge[0,-1]
      keep[0]
    endif
    if $33==1
      keep[-1]
      c 0,255
     endif
     if $33==2
       keep[-1]
       n 0,255
     endif
   endl a c endl done

####################################
#             Tone presets         #
####################################
#@gui Tone Presets : iain_tone_presets_p, iain_tone_presets_p
#@gui : Preset = choice("Whiter Whites","Warm Vintage","Magenta-Yellow","Velvetia","Seventies Magazine","Faded Print","Expired 69","Modern Film")
#@gui : Strength  = float (100,-200,200)
#@gui : Scale Output  = bool (0)
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
iain_tone_presets_p:
  repeat $! l[$>]
    apply_parallel_overlap "iain_tone_presets ${1--2}",0,${-1}
  endl done

iain_tone_presets:
  repeat $! l[$>] split_opacity l[0]
     # Whiter whites
    if $1==0
      +iain_rgb_tone 00,10,00,00,00,00,00,00,00,00,00,00,00,10,00,00,00,00,00,20,00,00,20,00,00,00,00,255,0,0,0,0,0
    endif

    # Warm Vintage
    if $1==1
      +iain_cmyk_tone 00,00,00,00,00,00,-8,-20,00,00,00,-49,00,00,00,00,00,00,00,-25,00,00,17,0,00,00,00,00,00,00,35,-25,17,8,26,31,00,00,00,00,17,00,-9,-31,29,00,00,-9,188,255,181,133,72,1
    endif

    # Magenta-Yellow
    if $1==2
      +iain_cmyk_tone 00,-38,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,-164,88,255,00,00,00,00,00,00,00,00,00,65,33,-15,00,00,00,00,00,00,00,00,00,00,00,-25,128,92,62,45,38,1
    endif

    # Velvetia
    if $1==3
      +iain_cmyk_tone -25,50,00,25,00,00,25,00,00,00,00,00,025,25,00,-50,00,00,25,00,00,00,00,00,025,00,00,25,00,00,-50,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,36,178,255,169,94,2
    endif

    # Seventies Magazine
    if $1==4
      +iain_cmyk_tone 25,-50,00,-25,00,00,-25,00,00,00,00,00,-025,-25,00,50,00,00,-25,00,00,00,00,00,-025,00,00,-25,00,00,50,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,00,17,120,240,255,255,4
    endif

    # Faded Print
    if $1==5
      +iain_cmyk_tone 000,00,00,00,00,00,00,00,00,00,00,-60,000,00,00,00,00,00,00,00,00,-22,40,161,000,00,00,0,00,00,00,00,28,33,33,16,00,00,00,00,00,00,00,00,00,77,-8,-80,255,255,255,255,255,0
    endif

    # Expired 69
    if $1==6
      +iain_cmyk_tone 000,00,00,00,00,00,00,00,00,00,00,00,000,00,00,00,00,00,00,00,00,07,-20,-33,000,00,00,00,00,00,00,00,00,48,-65,-77,000,00,00,00,00,00,00,00,00,45,45,00,255,255,255,255,255,0,0
    endif

    # Modern Film
    if $1==7
      +iain_cmyk_tone 000,20,00,00,08,00,00,00,00,00,-23,00,000,-13,00,0,17,00,00,00,00,-1,29,00,000,00,00,00,00,-12,00,00,00,19,68,18,000,00,00,00,00,00,00,00,00,-5,55,-15,128,255,255,255,255,0,0
    endif

    +sub[0,1]
    mul[-1] {{$2/100}*-1}
    +[0,-1]
    keep[0]
    if $3==0
      c 0,255
    else
      n 0,255
    endif
  endl a c endl done

##############################
#     Hue Lighten/darken     #
##############################
#@gui Hue Lighten/Darken: iain_hue_light_dark_p, iain_hue_light_dark_p
#@gui : Red = float(0,-255,255)
#@gui : 2 = float(0,-255,255)
#@gui : 3 = float(0,-255,255)
#@gui : Yellow = float(0,-255,255)
#@gui : 5 = float(0,-255,255)
#@gui : 6 = float(0,-255,255)
#@gui : Green = float(0,-255,255)
#@gui : 8= float(0,-255,255)
#@gui : Cyan = float(0,-255,255)
#@gui : 10 = float(0,-255,255)
#@gui : 11 = float(0,-255,255)
#@gui : Blue = float(0,-255,255)
#@gui : 13 = float(0,-255,255)
#@gui : 14 = float(0,-255,255)
#@gui : Magenta = float(0,-255,255)
#@gui : 16 = float(0,-255,255)
#@gui : 17 = float(0,-255,255)
#@gui : 18 = float(0,-255,255)
#@gui : sep = separator()
#@gui : Global = float(0,-255,255)
#@gui : HSL = bool (0)
#@gui : sep = separator()
#@gui : Sat Top = float(255,0,255)
#@gui : Sat Bottom = float(100,0,255)
#@gui : Value Top = float(255,0,255)
#@gui : Value Bottom = float(0,0,255)
#@gui : sep = separator()
#@gui : B&W = bool (0)
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")
iain_hue_light_dark_p:
  repeat $! l[$>]
    apply_parallel_overlap "iain_hue_light_dark ${1--2}",0,${-1}
  endl done

iain_hue_light_dark:
  repeat $! l[$>] split_opacity l[0]
    +l[0]
      to_rgb
      if $20==0
        rgb2hsv8
      else
        rgb2hsl8
      endif
      s c
      +apply_curve[0] 0,0,{128+$1},16,{128+$2},30,{128+$3},42,{128+$4},60,{128+$5},75,{128+$6},85,{128+$7},105,{128+$8},127,{128+$9},135,{128+$10},150,{128+$11},170,{128+$12},180,{128+$13},195,{128+$14},213,{128+$15},225,{128+$16},240,{128+$17},255,{128+$18}
      sub[-1] 128

      add[-1] $19
      add[-1,-2]
      a c
      if $20==0
        hsv82rgb
      else
        hsl82rgb
      endif
    endl
    +rgb2hsv[0]
    s[-1] c
    keep[0,1,-1,-2]
    mul[-1,-2] 255
    apply_curve[-2] 0,0,0,$22,0,$21,255,255,255
    apply_curve[-1] 0,0,0,$24,0,$23,255,255,255
    mul[-1] [-2]
    div[-1] 255
    remove[-2]
    c[-1] 0,255
    a[1,2] c
    blend[0,1] alpha
    if $25==1
      to_gray
    endif
  endl a c endl done

#@gui _<b>Details</b>

#@gui Pyramid Processing: iain_pyramid_processing,iain_pyramid_processing(0)
#@gui : 1 Levels = int(4,1,6)
#@gui : 2 Noise = float(50,1,100)
#@gui : 3 Mix = float(.5,0,1)
#@gui : Type = choice(0,"Mix","Add")
#@gui : Channels = choice(0,"Lightness","Luma","RGB")
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. 20 Aug 2019 - Update</small>")
#@gui : note = note(" <small>14 June 2017 - First release</small>")
iain_pyramid_processing:
  repeat $! l[$>]
    remove_opacity
    if $5==0
      colorspace="lab_l"
    elif $5==1
      colorspace="ycbcr_y"
    elif $5==2
      colorspace="rgb"
    endif

    ac[0] "
      +l
        dilate=1
        blur=1
        mix=$3
        noise=$2
        levels=$1
        size={3^$levels}
        cropwidth={w}
        cropheight={h}
        resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

        repeat $levels # number of pyramid levels.
          l[-1]
            +resize[0] 33.33333%,33.33333%,{d},{s},2
            +iain_resize_x3[-1]
            blur[-1] 1
            sub[0,-1]
          endl
        done
        repeat $!-1
          l[{$>}]
            +abs
            max={iM}
            dilate[-1] $dilate
            blur[-1] $blur
            max[-1] 0.00000000000000001
            +fill[-1] $max
            div[-1] [-2]
            cut[-1] -1000000000,$noise
            mul[0,-1]
            k[0]
          endl
        done
        to_rgb
        repeat $!-1
          iain_resize_x3[-1]
          blur[-1] 1
          add[-1,-2]
        done
        crop 0,0,{$cropwidth-1},{$cropheight-1} # crop to original
        replace_nan 0
        replace_inf 255
        n 0,255
      endl
      if $4
        sub[-1] {-1,ia}
        mul[-1] $mix
        add
        c 0,255
      else
        mul[0] {1-$mix}
        mul[1] $mix
        add
      endif
      c 0,255",$colorspace
endl done

#@gui Constrained Sharpen: iain_constrained_sharpen, iain_constrained_sharpen(0)
#@gui : Sharpen Radius = float(.75,0,10)
#@gui : Amount = float(2,0,10)
#@gui : Threshold = float(1,0,50)
#@gui : Constraint Radius = int(5,0,10)
#@gui : Overshoot = float(0,0,50)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator()

#@gui : note = note("Sharpens image but restricts pixels values to local minimum and maximum values to significantly reduce halos.")
#@gui : note = note("<b>Sharpen Radius</b>, <b>Amount</b> and <b>Threshold</b> are the normal unsharp controls.)
#@gui : note = note("A high <b>Amount</b> will produce aliasing")
#@gui : note = note("<b>Constraint Radius</b> sets the radius to find the local minimum and maximum.)
#@gui : note = note("<b>Overshoot</b> sets how far the sharpening is allowed to go past the local minimum and maximum values.)

#@gui : note = note("Author : <i>Iain Fergusson</i>. release: 2 August 2016 update: 25 August 2018")
iain_constrained_sharpen:
  repeat $! l[$>]
    nm=${-gui_layer_name}
    sharp_radius=$1
    amount=$2
    threshold=$3
    constrant_radius=$4
    overshoot=$5
    channels=$6
    value_action=$7

    apply_channels "
      sharp_radius=$1
      amount=$2
      threshold=$3
      constrant_radius=$4
      overshoot=$5
      +dilate_oct[0] $constrant_radius
      +erode_oct[0] $constrant_radius
      unsharp[0] $sharp_radius,$amount,$threshold
      add[1] $overshoot
      sub[2] $overshoot
      blend[0,1] darken,1,0
      blend[0,1] lighten,1,0
      blend alpha,1,0",$channels,$value_action

    nm name($nm)
  endl done

####################################
#         Texture Enhance          #
####################################
#@gui Texture Enhance : iain_texture_enhance_p, iain_texture_enhance_p_preview(0)
#@gui : Radius = int (2,2,11)
#@gui : Strength = float (2,0,10)
#@gui : Reduce Halos = float (30,0,255)
#@gui : Reduce Noise = float (0,0,255)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(0,"Auto","Off")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update: 4 March 2014 - Added parallel processing option</small>")

#@gui : note = note("<small>Update: 4 March 2013 - Different halo protection method, added option to reduce noise, faster.</small>")
iain_texture_enhance_p:
  apply_parallel_overlap "iain_texture_enhance ${1--2}",{$1*2},$-2

iain_texture_enhance_p_preview :
  gui_split_preview "iain_texture_enhance_p ${1--2}",$-1

iain_texture_enhance:
  tic
  ac "
  if $1%2!=0
   +erode_circ[0] $1  dilate_circ[-1] $1
   +dilate_circ[0] $1  erode_circ[-1] $1
  else
   +erode_oct[0] $1  dilate_oct[-1] $1
   +dilate_oct[0] $1  erode_oct[-1] $1
  endif
  sub[1] [0]
  sub[2] [0]
  add[1] [2]
  remove[2]
  mul[1] $2
  +abs[1]
  pt1={min(0,($4-10))}
  apply_curve[-1] 0,0,0,$pt1,0,{$4+1},1,255,1
  (0.0579710145,0.1304347826,0.0579710145;0.1304347826,0.2463768116,0.1304347826;0.0579710145,0.1304347826,0.0579710145)
  convolve[-2] [-1]
  remove[-1]
  mul[1] [2]
  c[1] {$3*-1},$3
  sub[0] [1]
  keep[0]",$5
  c 0,255
  toc

iain_texture_enhance_preview :
  gui_split_preview "iain_texture_enhance ${1--2}",$-1

####################################
#             Make Up              #
####################################
#@gui Make Up: make_up, make_up_preview(0)
#@gui : Space = float(15,1,40)
#@gui : Value = float(4,0,30)
#@gui : Fast = bool(0)
#@gui : Limit Hue Range = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.  - Update: 1 March 2013: Fixed resizing issue, some memory useage improvements, and added more options.</small>")
makeup_full:
  to_rgb
  sub[-1] 128 *[-1] .5 +[-1] 128
  split c
  name[0] red
  name[1] green
  name[2] blue

  sub[green] [red]
  bilateral[green] $1,$2
  add[green] [red]

  sub[blue] [red]
  bilateral[blue] $1,$2
  add[blue] [red]

  append[0,1,2] c
  -[-1] 128 *[-1] 2 +[-1] 128
  c 0,255

make_up:

  # change size to even values
  cropwidth={w}
  cropheight={h}
  resize[0] {w+(2-w%2)},{h+(2-h%2)},1,{s},0,1
  width={w}
  height={h}
  if $3==1
    +resize 50%,50%,1,3,5
    +makeup_full[1] {$1/2},$2
    +resize[1] 200%,200%,1,3,5
    +compose_grainextract[0,3]
    resize[2] {w},{h},1,3,5
    +compose_grainmerge[2,4]
    keep[0,-1]
  else
   if $4==1
     +makeup_full[0] $1,$2
   else
     makeup_full[0] $1,$2
   endif
  endif

  # Hue
  if $4==1
    +rgb2hsl8[1]
    split[-1] c remove[-1,-2]
    +[-1] 128
    mod[-1] 255
    apply_curve[-1] 0,0,0,130,0,136,255,155,255,160,0,255,0
    median[-1] 3
    +edges[1] 10% n[-1] 0,1
    mul[-1,-2]
    a[1,2] c
    blend[0,1] alpha
  else
    keep[-1]
  endif
  crop 0,0,{$cropwidth-1},{$cropheight-1}

make_up_preview:
  gui_split_preview "make_up ${1--2}",$-1

#@gui _<b>Repair</b>

#@gui Iain Noise Reduction 2019 : iain_nr_2019,iain_nr_2019_preview(0)
## #@gui : note = note("Adjust guide")
#@gui : Gamma = float (1,.05,2)
#@gui : Shadows = float (0,-1,1)
#@gui : Light = float (0,-1,1)
#@gui : Mid Offset = float (0,-0.5,0.5)
#@gui : Desaturate = float(0.5,0,1)
#@gui : Guide mix = float (1,0,1)
#@gui : Soften Guide = bool (0)
## #@gui : note = note("denoise")
#@gui : Fine = float (5,0,30)
#@gui : Mid = float (3,0,30)
#@gui : Large = float (0,0,30)
#@gui : Lookup = int (3,1,7)
## #@gui : note = note("recover")
#@gui : Recovery = choice (0,"no recovery","fast recovery","slow recovery","guide recovery")
#@gui : Recover = float (.5,0,2)

#@gui : Preview shows = choice (4,"Noise","Fine Noise","Mid Noise","Large Noise","Output")
#@gui : Preview Tones map = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - completely re-written Dec 2019")
#@gui : note = note("previous update 10 Jan 2013")
iain_nr_2019_preview:
  remove_opacity
  images={$!}

  gamma=$1
  shadows=$2
  light=$3
  mid_offset=$4
  desaturate=$5
  guide_mix=$6
  soften_guide=$7
  fine=$8
  mid=$9
  large=$10
  lookup=$11
  recovery_choice=$12
  recovery_amount=$13
  preview_shows=$14
  preview_tones_map=$15

  if $images>2
    gui_warning_preview "Too many input images detected. This filter requires 1 or 2 images as input."
    quit
  endif

  if $12==3" && "$images==1
    gui_warning_preview "No guide image detected. Guided Recovery requires two images, please set 'input layers' to 'active and below' or equivilent. The top layer should be the noisy version of the image and the bottom layer should be a denoised version"
    quit
  endif

  if $images==1
    [0]
  endif

  if $preview_tones_map
    +l[-1]
      mid_tone_offset={$mid_offset/-5}
      luminance
      add {$mid_tone_offset*255}
      resize 25%,25%,100%,100%,2
      median 5
      line  0,0,0,100%,1,128
      line  0,0,100%,0,1,128
      line  0,100%,100%,100%,1,128
      line  100%,0,100%,100%,1,128
      +gt[0] 85
      +gt[0] 170
      laplacian[1,2]
      l[1]
      +gt[0] 0
      lt[0] 0
      replace[0] 1,100
      replace[1] 1,1
      max[0,1]
      endl
      l[2]
      +gt[0] 0
      lt[0] 0
      replace[0] 1,255
      replace[1] 1,150
      max[0,1]
      endl
      max[-1,-2]
      +neq[-1] 0
      replace[-1] 1,255
      append[-1,-2] c
      scale2x[-1]
      scale2x[-1]
      k[-1]
    endl
  endif

  l[0,1]
    if $preview_shows==0
      fine=$fine
      mid=$mid
      large=$large
      +iain_nr_2019 $gamma,$shadows,$light,$mid_offset,$desaturate,$guide_mix,$soften_guide,$fine,$mid,$large,$lookup,$recovery_choice,$recovery_amount,$preview_shows,$preview_tones_map
      k[0,-1]
      sub
      noise_amp={_round((128/(max(abs(im),iM))),0.1)}
      mul $noise_amp
      add 128
      c 0,255
   elif $preview_shows==1
      fine=$fine
      mid=0
      large=0
      +iain_nr_2019 $gamma,$shadows,$light,$mid_offset,$desaturate,$guide_mix,$soften_guide,$fine,$mid,$large,$lookup,$recovery_choice,$recovery_amount,$preview_shows,$preview_tones_map
      k[0,-1]
      sub
      noise_amp={_round((128/(max(abs(im),iM))),0.1)}
      mul $noise_amp
      add 128
      c 0,255
    elif $preview_shows==2
      fine=0
      mid=$mid
      large=0
      +iain_nr_2019 $gamma,$shadows,$light,$mid_offset,$desaturate,$guide_mix,$soften_guide,$fine,$mid,$large,$lookup,$recovery_choice,$recovery_amount,$preview_shows,$preview_tones_map
      k[0,-1]
      sub
      noise_amp={_round((128/(max(abs(im),iM))),0.1)}
      mul $noise_amp
      add 128
      c 0,255
    elif $preview_shows==3
      fine=0
      mid=0
      large=$large
      +iain_nr_2019 $gamma,$shadows,$light,$mid_offset,$desaturate,$guide_mix,$soften_guide,$fine,$mid,$large,$lookup,$recovery_choice,$recovery_amount,$preview_shows,$preview_tones_map
      k[0,-1]
      sub
      noise_amp={_round((128/(max(abs(im),iM))),0.1)}
      mul $noise_amp
      add 128
      c 0,255
    elif $preview_shows==4
      iain_nr_2019 $gamma,$shadows,$light,$mid_offset,$desaturate,$guide_mix,$soften_guide,$fine,$mid,$large,$lookup,$recovery_choice,$recovery_amount,$preview_shows,$preview_tones_map
    endif
  endl

  blend alpha

  text_size=13

  if $images==1
    guide="Internal Guide"
    bg_colour=255
    text_colour=0
  else
    guide="External Guide"
    bg_colour=0
    text_colour=255
  endif

  box_size=100%

  rectangle 0,0,$box_size,20,0.5,$bg_colour
  text $guide,0.1~,4,$text_size,1,$text_colour

  if $14!=4

    rectangle {(w/2)-127*($noise_amp/2)},{h-20},{(w/2)+127*($noise_amp/2)},100%,0.5,$bg_colour

    text Noise\ amplified\ $noise_amp\ times,0.5~,{h-16},$text_size,1,$text_colour

  endif

  guide_recovery=0
  if $recovery_choice==0
    do_recovery=0
  elif $recovery_choice==1
    do_recovery=1
    slow=0
    recover_text="Fast Recovery"
  elif $recovery_choice==2
    do_recovery=1
    slow=1
    recover_text="Slow Recovery"
  elif $recovery_choice==3
    do_recovery=1
    slow=1
    guide_recovery=1
    recover_text="Guide Recovery"
  endif

  if $recovery_choice!=0
    text $recover_text,0.9~,4,$text_size,1,$text_colour
  endif

# # # # # # # # # # # #
 # # # # # # # # # # #
# # # # # # # # # # # #

iain_nr_2019:
  images={$!}
  if $images>2
    quit
  endif

  gamma=$1
  shadow=$2
  light=$3
  mid_tone_offset={$4/5}
  chroma=$5
  external_guide_strength=$6
  soften_guide=$7
  fine=$8
  mid={$9/3}
  large={$10/9}

  patch_size=3
  patch_size_b=3

  lookup_size={($11*2)+1}
  mid_lookup_size={($11*2)+1}
  large_lookup_size={($11*2)+1}

  smoothness_fine=0
  smoothness=0
  fast_approx=0
  std_deviation_s=10
  recovery_choice=$12
  recover=$13

  guide_recovery=0
  slow=0

  if $recovery_choice==0
    do_recovery=0
  elif $recovery_choice==1
    do_recovery=1
  elif $recovery_choice==2
    do_recovery=1
    slow=1
  elif $recovery_choice==3
    do_recovery=1
    slow=1
    guide_recovery=1
  endif

  remove_opacity

  colours={s}
  external_guide=1

  if $!==1
    [0]
    external_guide=0
  endif
  if $guide_recovery==0

 if $external_guide_strength<1
 [0]
 mul[1] $external_guide_strength
 mul[2] {1-$external_guide_strength}
 add[1,2]
 endif
 l[-1]
 #process guide image
  # adjust chroma to increase chroma denoising.
  # Use faster approximation of Ycbcr.
  if $colours!=1
  if $chroma>0
  redmul=.299
  greenmul=.587
  bluemul=.114
  +split[0] c
  mul[1] $redmul mul[2] $greenmul mul[3] $bluemul
  add[1-3]
  if $chroma==1 # if chroma equals one just keep the lumanance image else desaturate image by scaling the chroma channels
  keep[1]
  else

  split[0] c name[0] red name[1] green name[2] blue name[3] luma

  +sub[blue] [luma] name[-1] cb
  +sub[red] [luma] name[-1] cr
  keep[luma,cb,cr]

  # adjust chroma
  mul[cb,cr] {1-$chroma}

  +add[cb] [luma] name[-1] blueout
  +add[cr] [luma] name[-1] redout

  remove[1,2]

  +mul[redout] $redmul +mul[blueout] $bluemul
  sub[luma] [-1] sub[luma] [-2]
  div[luma] $greenmul
  remove[-1,-2]
  move[2] 0
  append c
  endif
  endif
  endif
 # adjust gamma and curves to target different ranges for noise reducation
 sub 127
 div 128

 if $gamma!=1
  add 1
  pow $gamma
  sub 1
  endif

 sub $mid_tone_offset
 +c[0] 0,100
 c[0] -100,0

 l[0]
  if $shadow>0
   fill i+($shadow*abs(i)*0.75)^2
  elif $shadow<0
   fill i-(abs(i)^3)*(abs($shadow))
  endif
 endl
 l[1]
  if $light>0
   div[0] {(2^$gamma)-1}
   fill i-($light*abs(i)*0.75)^2
   mul[0] {(2^$gamma)-1}
  elif $light<0
   div[0] {(2^$gamma)-1}
   fill i+(abs(i)^3)*(abs($light))
   mul[0] {(2^$gamma)-1}
  endif
 endl

 add
 add $mid_tone_offset
 mul 128
 add 127

 if $soften_guide # slight blur on guide image to reduce impact of impulse noise
   l[0]
   (0,0.2,0;0.2,0.2,0.2;0,0.2,0)
   convolve[0] [1]
   rm[1]
  endl
 endif

 endl

 # denoise

 +l[0,1]
 levels=2
 size={3^$levels}
 cropwidth={w}
 cropheight={h}

 if $colours>1 to_rgb endif
 resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

  if $fine>0 # do fine noise reduction
   denoise[0] [1],$std_deviation_s,$fine,$patch_size,$lookup_size,$smoothness_fine,$fast_approx
  endif

  +resize[0,1] 33.33333%,33.33333%,{d},{s},2  # downsample for mid range denoising
  rm[1]
  +iain_resize_x3[-2]  # upscale with original pixels aligned at centre of 3x3 blocks
  blur[-1] 1
  sub[0,-1]

  if $mid>0
  denoise[1] [2],$std_deviation_s,$mid,$patch_size,$mid_lookup_size,$smoothness_fine,$fast_approx
  endif

  l[1,2]
  +resize[0,1] 33.33333%,33.33333%,{-1,d},{-1,s},2 # downsample for large range denoising
  rm[1]
  +iain_resize_x3[-2]
  blur[-1] 1
  sub[0,-1]
   if $large>0
   denoise[1] [2],$std_deviation_s,$large,$patch_size,$large_lookup_size,$smoothness_fine,$fast_approx
   endif
  endl
 rm[-1]
 repeat 2 # redbuild image from multiple scales
  iain_resize_x3[-1]
  blur[-1] 1
  add[-1,-2]
 done
 crop 0,0,{$cropwidth-1},{$cropheight-1} # crop to original
 c 0,255
 endl
rm[1]
endif

# recover detials

 if $do_recovery
sub[0] [1] # get differnce between noisy and clean image
 if $colours!=1
 l[0] split c mul[0] 0.2126 mul[1] 0.7125 mul[2] 0.0722 add endl # luminance
 endif
 # high pass filter
 +blur[0] 10
 sub[0] [-1]
 rm[-1]

 # normalise noise levels across image
 +abs[0]
 noise={-1,ia}
 blur[-1] 3
 bilateral[-1] [1],20,$noise # spatially average noise estimates based on image structure
 blur[-1] 2
 fill[-1] 5/i
 mul[0] [-1] # multiply differnce image to do normalsation

 l[0]
  add 128
  resize[0] {w+256},{h+256},1,1,0,2,0.5,0.5
   if $slow
   iain_fft_denoise_stack[0] {2-$recover},0.5
   else
   iain_fft_denoise[0] {2-$recover},0.5
   endif
  crop[0] 128,128,{w-129},{h-129}
  sub 128
  +blur 10
  sub
 endl

div[0] [-1]
rm[-1]
if $colours>1 to_rgb[0] endif
add
else
k[-1]
endif
c 0,255

## time=$|
## name name($time)

## #@gui iain_fft_denoise_stack: iain_fft_denoise_stack,iain_fft_denoise_stack(0)
## #@gui : threshold = float (1,0,5)
## #@gui : threshold = float (.5,0,5)

iain_fft_denoise_stack:

resize {w+128},{h+128},1,1,0,2,0.5,0.5 # add buffer at edges

# set hand crafted offsets

offset1x=24
offset1y=4
offset2x=-10
offset2y=21
offset3x=27
offset3y=27
offset4x=6
offset4y=38

+shift[0] $offset1x,$offset1y,0,0
+shift[0] $offset2x,$offset2y,0,0
+shift[0] $offset3x,$offset3y,0,0
+shift[0] $offset4x,$offset4y,0,0

# denoise each offset image
iain_fft_denoise[0] $1,$2
iain_fft_denoise[1] $1,$2
iain_fft_denoise[2] $1,$2
iain_fft_denoise[3] $1,$2
iain_fft_denoise[4] $1,$2
shift[1] {$offset1x*-1},{$offset1y*-1},0,0
shift[2] {$offset2x*-1},{$offset2y*-1},0,0
shift[3] {$offset3x*-1},{$offset3y*-1},0,0
shift[4] {$offset4x*-1},{$offset4y*-1},0,0

blend_median

crop 64,64,{w-65},{h-65} # crop to original size
#########

iain_fft_denoise:
luminance

cropwidth={w}
cropheight={h}

size={64} # tile size
resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

tilew={w/64}
tileh={h/64}

split_tiles $tilew,$tileh
apply_parallel "
fftpolar
append z
k[0]
"
+blend_median # find median fft of all tiles to use as threshold

mul[-1] $1 # scale median fft threshold
repeat $!-1
 l[$>,-1]
  split z
  +circle[0] 50%,50%,1,1,0 # set low frequenices to 0 to so they don't affect the blur

  blur[-1] 1 # blur fft

  # IIRC find fft bins to apply noise reduction to
  mul[-1] {$1*$2}
  lt[-1] [2]
  circle[-1] 50%,50%,1,1,0 # remove low frequenices
  mul[-1] [2]

  sub[0] [-1] # subtract median fft (noise estimate) from current tile
  c[0] 0,1e31
  k[0,1,2,3]
  append[0,1] z
  append[1,2] z
 endl
done
rm[-1]
apply_parallel "
split z
ifftpolar
"

append_tiles $tilew,$tileh
c 0,255
crop 0,0,{$cropwidth-1},{$cropheight-1}

#######################################
#          Iain's fast denoise         #
#######################################
#@gui Iain's Fast Denoise : iain_fast_denoise_p,iain_fast_denoise_p_preview(0)
#@gui : Luma = float(0,0,3)
#@gui : Chroma = float(0,0,3)

#@gui : Gamma = float (1,.5,3)
#@gui : Despeckle = float(0,0,1)
#@gui : Dither Output= bool(0)
## #@gui : Luma 2 scale= float(.9,0,2)
## #@gui : Luma 3 scale= float(.65,0,2)
## #@gui : Luma 4 scale= float(.44,0,2)
#@gui : Preview Shows= choice (0,"Normal Output","Luma Noise",  "Chroma Noise")
#@gui : sep = separator ()
#@gui : Parallel Processing = choice(1,"Off","Auto")
#@gui : sep = separator()
#@gui : note = note("This noise reduction filter is designed for speed, and some quality has been sacrificed.")
#@gui : sep = separator ()
#@gui : note = note("<small>Author: Iain Fergusson</small>")
#@gui : note = note("<small>Update 28 March 2015 - increased parallel overlap to remove artefacts</small>")
#@gui : note = note("<small>Update 26 Oct 2013 - parallel processing</small>")
#@gui : note = note("<small>Released 22 Feb 2013</small>")
iain_fast_denoise_p:
tic
if $7
apply_parallel_overlap "iain_fast_denoise ${1--1}",128,0
else
iain_fast_denoise ${1--1}
endif
toc

iain_fast_denoise:
repeat $! l[$>] nm={0,n} split_opacity l[0]
fastluma1={$1*5000}
fastluma2={$fastluma1*.9}
fastluma3={$fastluma1*.65}
fastluma4={$fastluma1*.44}
fastchroma1={$2*5000}
fastchroma2=$fastchroma1
fastchroma3={$fastchroma2/2}
fastchroma4={$fastchroma3/2}

despeckle_threshold={($4/25)*100000}
if $3!=1
scale={255*1000}
ex={$3}
pt1x={$scale*0.025}
pt2x={$scale*0.05}
pt3x={$scale*0.075}
pt4x={$scale*0.1}
pt5x={$scale*0.125}
pt6x={$scale*0.15}
pt7x={$scale*0.175}
pt8x={$scale*0.2}
pt9x={$scale*0.225}
pt10x={$scale*0.25}
pt11x={$scale*0.275}
pt12x={$scale*0.3}
pt13x={$scale*0.325}
pt14x={$scale*0.35}
pt15x={$scale*0.375}
pt16x={$scale*0.4}
pt17x={$scale*0.425}
pt18x={$scale*0.45}
pt19x={$scale*0.475}
pt20x={$scale*0.5}
pt21x={$scale*0.525}
pt22x={$scale*0.55}
pt23x={$scale*0.575}
pt24x={$scale*0.6}
pt25x={$scale*0.625}
pt26x={$scale*0.65}
pt27x={$scale*0.675}
pt28x={$scale*0.7}
pt29x={$scale*0.725}
pt30x={$scale*0.75}
pt31x={$scale*0.775}
pt32x={$scale*0.8}
pt33x={$scale*0.825}
pt34x={$scale*0.85}
pt35x={$scale*0.875}
pt36x={$scale*0.9}
pt37x={$scale*0.925}
pt38x={$scale*0.95}
pt39x={$scale*0.975}
pt40x={$scale*1}

pt1y={(0.025^$ex)*$scale}
pt2y={(0.05^$ex)*$scale}
pt3y={(0.075^$ex)*$scale}
pt4y={(0.1^$ex)*$scale}
pt5y={(0.125^$ex)*$scale}
pt6y={(0.15^$ex)*$scale}
pt7y={(0.175^$ex)*$scale}
pt8y={(0.2^$ex)*$scale}
pt9y={(0.225^$ex)*$scale}
pt10y={(0.25^$ex)*$scale}
pt11y={(0.275^$ex)*$scale}
pt12y={(0.3^$ex)*$scale}
pt13y={(0.325^$ex)*$scale}
pt14y={(0.35^$ex)*$scale}
pt15y={(0.375^$ex)*$scale}
pt16y={(0.4^$ex)*$scale}
pt17y={(0.425^$ex)*$scale}
pt18y={(0.45^$ex)*$scale}
pt19y={(0.475^$ex)*$scale}
pt20y={(0.5^$ex)*$scale}
pt21y={(0.525^$ex)*$scale}
pt22y={(0.55^$ex)*$scale}
pt23y={(0.575^$ex)*$scale}
pt24y={(0.6^$ex)*$scale}
pt25y={(0.625^$ex)*$scale}
pt26y={(0.65^$ex)*$scale}
pt27y={(0.675^$ex)*$scale}
pt28y={(0.7^$ex)*$scale}
pt29y={(0.725^$ex)*$scale}
pt30y={(0.75^$ex)*$scale}
pt31y={(0.775^$ex)*$scale}
pt32y={(0.8^$ex)*$scale}
pt33y={(0.825^$ex)*$scale}
pt34y={(0.85^$ex)*$scale}
pt35y={(0.875^$ex)*$scale}
pt36y={(0.9^$ex)*$scale}
pt37y={(0.925^$ex)*$scale}
pt38y={(0.95^$ex)*$scale}
pt39y={(0.975^$ex)*$scale}
pt40y={(1^$ex)*$scale}
endif
interpolation=1
tic
to_rgb
mul[0] 1000
if $3!=1
apply_curve[0] 0,0,0,$pt1x,$pt1y,$pt2x,$pt2y,$pt3x,$pt3y,$pt4x,$pt4y,$pt5x,$pt5y,$pt6x,$pt6y,$pt7x,$pt7y,$pt8x,$pt8y,$pt9x,$pt9y,$pt10x,$pt10y,$pt11x,$pt11y,$pt12x,$pt12y,$pt13x,$pt13y,$pt14x,$pt14y,$pt15x,$pt15y,$pt16x,$pt16y,$pt17x,$pt17y,$pt18x,$pt18y,$pt19x,$pt19y,$pt20x,$pt20y,$pt21x,$pt21y,$pt22x,$pt22y,$pt23x,$pt23y,$pt24x,$pt24y,$pt25x,$pt25y,$pt26x,$pt26y,$pt27x,$pt27y,$pt28x,$pt28y,$pt29x,$pt29y,$pt30x,$pt30y,$pt31x,$pt31y,$pt32x,$pt32y,$pt33x,$pt33y,$pt34x,$pt34y,$pt35x,$pt35y,$pt36x,$pt36y,$pt37x,$pt37y,$pt38x,$pt38y,$pt39x,$pt39y,$pt40x,$pt40y
## mul[0] 0.001
endif
redmul=.299
greenmul=.587
bluemul=.114

to_rgb[0]
+split[0] c
mul[1] $redmul
mul[2] $greenmul
mul[3] $bluemul
add[1-3]

split[0] c
name[0] red
name[1] green
name[2] blue
name[3] luma

+sub[blue] [luma]
name[-1] cb
+sub[red] [luma]
name[-1] cr
keep[luma,cb,cr]
if $despeckle_threshold>0
iain_fast_despeckle[0] {1-$despeckle_threshold}
endif
if $1>0
iain_fast_denoise_main[0] {$fastluma1},{$fastluma2},{$fastluma3},{$fastluma4},$interpolation
endif
if $2>0
iain_fast_denoise_main[1] {$fastchroma1},{$fastchroma2},{$fastchroma3},{$fastchroma4},$interpolation
iain_fast_denoise_main[2] {$fastchroma1},{$fastchroma2},{$fastchroma3},{$fastchroma4},$interpolation
endif
## append c
## iain_ycbcr2rgb
## apply_gamma 1.3

name[0] luma
name[1] cb
name[2] cr

+add[cb] [luma]
name[-1] blueout
+add[cr] [luma]
name[-1] redout

remove[1,2]

+mul[redout] $redmul
+mul[blueout] $bluemul
sub[luma] [-1]
sub[luma] [-2]
div[luma] $greenmul
remove[-1,-2]
move[2] 0
## text $greenmul,0,0,25,1,255
append c
## ## dither
if $5==1
100%,100%,1,1,0
noise[-1] 0.7,0
+laplacian[0]
threshold[-1] 4
dilate[-1] 3
mul[-1] -1
add[-1] 1

mul[-2] [-1]
remove[-1]
add

endif
if $3!=1
scale={255*1000}
ex={1/$3}
pt1y={(0.025^$ex)*$scale}
pt2y={(0.05^$ex)*$scale}
pt3y={(0.075^$ex)*$scale}
pt4y={(0.1^$ex)*$scale}
pt5y={(0.125^$ex)*$scale}
pt6y={(0.15^$ex)*$scale}
pt7y={(0.175^$ex)*$scale}
pt8y={(0.2^$ex)*$scale}
pt9y={(0.225^$ex)*$scale}
pt10y={(0.25^$ex)*$scale}
pt11y={(0.275^$ex)*$scale}
pt12y={(0.3^$ex)*$scale}
pt13y={(0.325^$ex)*$scale}
pt14y={(0.35^$ex)*$scale}
pt15y={(0.375^$ex)*$scale}
pt16y={(0.4^$ex)*$scale}
pt17y={(0.425^$ex)*$scale}
pt18y={(0.45^$ex)*$scale}
pt19y={(0.475^$ex)*$scale}
pt20y={(0.5^$ex)*$scale}
pt21y={(0.525^$ex)*$scale}
pt22y={(0.55^$ex)*$scale}
pt23y={(0.575^$ex)*$scale}
pt24y={(0.6^$ex)*$scale}
pt25y={(0.625^$ex)*$scale}
pt26y={(0.65^$ex)*$scale}
pt27y={(0.675^$ex)*$scale}
pt28y={(0.7^$ex)*$scale}
pt29y={(0.725^$ex)*$scale}
pt30y={(0.75^$ex)*$scale}
pt31y={(0.775^$ex)*$scale}
pt32y={(0.8^$ex)*$scale}
pt33y={(0.825^$ex)*$scale}
pt34y={(0.85^$ex)*$scale}
pt35y={(0.875^$ex)*$scale}
pt36y={(0.9^$ex)*$scale}
pt37y={(0.925^$ex)*$scale}
pt38y={(0.95^$ex)*$scale}
pt39y={(0.975^$ex)*$scale}
pt40y={(1^$ex)*$scale}

## mul[0] 1000
apply_curve[0] 0,0,0,$pt1x,$pt1y,$pt2x,$pt2y,$pt3x,$pt3y,$pt4x,$pt4y,$pt5x,$pt5y,$pt6x,$pt6y,$pt7x,$pt7y,$pt8x,$pt8y,$pt9x,$pt9y,$pt10x,$pt10y,$pt11x,$pt11y,$pt12x,$pt12y,$pt13x,$pt13y,$pt14x,$pt14y,$pt15x,$pt15y,$pt16x,$pt16y,$pt17x,$pt17y,$pt18x,$pt18y,$pt19x,$pt19y,$pt20x,$pt20y,$pt21x,$pt21y,$pt22x,$pt22y,$pt23x,$pt23y,$pt24x,$pt24y,$pt25x,$pt25y,$pt26x,$pt26y,$pt27x,$pt27y,$pt28x,$pt28y,$pt29x,$pt29y,$pt30x,$pt30y,$pt31x,$pt31y,$pt32x,$pt32y,$pt33x,$pt33y,$pt34x,$pt34y,$pt35x,$pt35y,$pt36x,$pt36y,$pt37x,$pt37y,$pt38x,$pt38y,$pt39x,$pt39y,$pt40x,$pt40y
endif
mul[0] 0.001
c 0,255
toc

endl a c nm $nm endl done

fastblur:
repeat $!
l[$<]
(0.0579710145,0.1304347826,0.0579710145;0.1304347826,0.2463768116,0.1304347826;0.0579710145,0.1304347826,0.0579710145)
convolve[0] [1]
remove[-1]
endl
done
iain_fast_despeckle:
(0,0.2,0;0.2,0.2,0.2;0,0.2,0)
+convolve[0] [1]
+sub[-1] [0]
abs[-1]
+convolve[-1] [1]
sub[-1] [-2]
abs[-1]
keep[0,2,-1]
threshold[-1] $1
mul[-1] 255
append[1,2] c
blend alpha

iain_fast_denoise_main:
cropwidth={w}
cropheight={h}
resize[0] {w+(8-w%8)},{h+(8-h%8)},1,{s},0,1
width={w}
height={h}

+resize[0] 50%,50%,{d},{s},2
+resize[1] $width,$height,{d},{s},$5
fastblur[-1]
sub[0] [2]
remove[2]

+resize[1] 50%,50%,{d},{s},2
+resize[2] {$width/2},{$height/2},{d},{s},$5
fastblur[-1]
sub[1] [3]
remove[3]

+resize[2] 50%,50%,{d},{s},2
+resize[3] {$width/4},{$height/4},{d},{s},$5
fastblur[-1]
sub[2] [4]
remove[4]

+resize[3] 50%,50%,{d},{s},2
+resize[4] {$width/8},{$height/8},{d},{s},$5
fastblur[-1]
sub[3] [5]
remove[5]

rmsthresh[0] $1
rmsthresh[1] $2
rmsthresh[2] $3
rmsthresh[3] $4

resize[-1] {3,w},{3,h},{d},{s},$5
fastblur[-1]
add[-2] [-1]
remove[-1]
resize[-1] {2,w},{2,h},{d},{s},$5
fastblur[-1]
add[-2] [-1]
remove[-1]
resize[-1] {1,w},{1,h},{d},{s},$5
fastblur[-1]
add[-2] [-1]
remove[-1]

resize[-1] {0,w},{0,h},{d},{s},$5
fastblur[-1]
add[-2] [-1]
remove[-1]
crop 0,0,{$cropwidth-1},{$cropheight-1}
## n 0,255

rmsthresh:
+abs[0]
fastblur[1]

## median[1] 3
threshold[1] {$1}
fastblur[1]
mul[0] [1]
keep[0]

iain_fast_denoise_p_preview:

if $-2==0 ## Normal Preview
iain_fast_denoise ${1--3}
endif
if $-2==1 ## Luma Noise Preview
+iain_fast_denoise_p $1,0,1,$4,0,0,$7
compose_grainextract
sub 128
mul 3
add 128
endif
if $-2==2 ## Chroma Noise Preview
+iain_fast_denoise_p 0,$2,1,$4,0,0,$7
compose_grainextract
sub 128
mul 3
add 128
endif
#######################################
#          Iain's Noise Reduction            #
#######################################


####################################
#         Banding Denoise          #
####################################

#@gui Banding Denoise: banding_denoise, banding_denoise_preview(0)
#@gui : V Cutoff = float(5,0,50)
#@gui : H Cutoff = float(5,0,50)
#@gui : Space = float(5,0,20)
#@gui : Value = float(10,0,100)
#@gui : Show Difference = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
banding_denoise:

repeat 2 +bilateral[-1] $3,$4 keep[0,-1] done
+compose_grainextract[0,1]

fftpolar[-1]
polygon[-2] 4,0,{(h/2)+1},{50-$1}%,{(h/2)+1},{50-$1}%,{(h/2)-1},0,{(h/2)-1}
polygon[-2] 4,{50+$1}%,{(h/2)+1},{w},{(h/2)+1},{w},{(h/2)-1},{50+$1}%,{(h/2)-1}
polygon[-2] 4,{(w/2)+1},0,{(w/2)+1},{50-$2}%,{(w/2)-1},{50-$2}%,{(w/2)-1},0
polygon[-2] 4,{(w/2)-1},{h},{(w/2)+1},{h},{(w/2)+1},{50+$2}%,{(w/2)-1},{50+$2}%

ifftpolar[-1,-2]
compose_grainmerge[1,2]
keep[-1]

banding_denoise_preview:

if $5==0
 banding_denoise ${1--1}
else
 +banding_denoise ${1--1}
 compose_grainextract[0,1]
 -[-1] 128 *[-1] 5 +[-1] 128
endif

################# Filter End ###############


#######################################
#          Pixel Denoise              #
#######################################

#@gui Pixel Denoise: iain_pixel_denoise_p, iain_pixel_denoise_p_preview(0)
#@gui : Method = choice(2,"Old Method - slowest","Hybrid Median - medium speed softest output","Morphological - fastest sharpest output")
#@gui : sep = separator()
#@gui : Iterations = int(1,1,10)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator()
#@gui : Preview Shows = choice(0,"Output","Difference")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(1,"Off","Auto")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. </small>")
#@gui : note = note("<small>Update - 1 July 2014 - Added much faster Morphological method. Note: The iteration setting is ignored for this method. There is no change to the output for iterations greater than one.</small>")
#@gui : note = note("<small>Update - 1 December 2013 - Fixed some bugs.</small>")
#@gui : note = note("<small>Update - 20 October 2013 - Parallel Processing</small>")
#@gui : note = note("<small>Update - 8 March 2013 - Incorperated Hybrid Median into this filter and added a choice between the old method and hybrid median</small>")


createbc:
(0.5,0.5,0;0,0,0;0,0,0) # AA
(0.5,0,0.5;0,0,0;0,0,0) # AB
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]
createbd:
(0.5,0,0;0,0,0.5;0,0,0) # AC
(0.5,0,0;0,0,0;0,0,0.5) # AD
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbe:
(0.5,0,0;0,0,0;0,0.5,0) # AE
(0.5,0,0;0,0,0;0.5,0,0) # AF
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbf:
(0.5,0,0;0.5,0,0;0,0,0) # AG
(0,0.5,0.5;0,0,0;0,0,0) # AH
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbg:
(0,0.5,0;0,0,0.5;0,0,0) # AI
(0,0.5,0;0,0,0;0,0,0.5) # AJ
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbh:
(0,0.5,0;0,0,0;0,0.5,0) # AK
(0,0.5,0;0,0,0;0.5,0,0) # AL
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbi:
(0,0.5,0;0.5,0,0;0,0,0) # AM
(0,0,0.5;0,0,0.5;0,0,0) # AN
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbj:
(0,0,0.5;0,0,0;0,0,0.5) # AO
(0,0,0.5;0,0,0;0,0.5,0) # AP
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbk:
(0,0,0.5;0,0,0;0.5,0,0) # AQ
(0,0,0.5;0.5,0,0;0,0,0) # AR
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbl:
(0,0,0;0,0,0.5;0,0,0.5) # AS
(0,0,0;0,0,0.5;0,0.5,0) # AT
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbm:
(0,0,0;0,0,0.5;0.5,0,0) # AU
(0,0,0;0.5,0,0.5;0,0,0) # AV
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbn:
(0,0,0;0,0,0;0,0.5,0.5) # AW
(0,0,0;0,0,0;0.5,0,0.5) # AX
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbo:
(0,0,0;0.5,0,0;0,0,0.5) # AY
(0,0,0;0,0,0;0.5,0.5,0) # AZ
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

createbp:
(0,0,0;0.5,0,0;0,0.5,0) # BA
(0,0,0;0.5,0,0;0.5,0,0) # BB
+convolve[0] [1]
+convolve[0] [2]
keep[0,-1,-2]
iain_median_3_stack[0,1,2]
keep[-1]

################### Layer 2 ##################

createbq:
+createbc[0]
+createbd[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbr:
+createbe[0]
+createbf[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbs:
+createbg[0]
+createbh[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbt:
+createbi[0]
+createbj[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbu:
+createbk[0]
+createbl[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbv:
+createbm[0]
+createbn[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbw:
+createbo[0]
+createbp[0]
iain_median_3_stack[0,1,2]
keep[-1]
#################################Layer 3 ####################
createbx:
+createbq[0]
+createbr[0]
iain_median_3_stack[0,1,2]
keep[-1]
createby:
+createbs[0]
+createbt[0]
iain_median_3_stack[0,1,2]
keep[-1]
createbz:
+createbu[0]
+createbv[0]
iain_median_3_stack[0,1,2]
keep[-1]
#################################Layer 4 ####################
createca:
+createbx[0]
+createby[0]
iain_median_3_stack[0,1,2]
keep[-1]
createcb:
+createbz[0]
+createbw[0]
iain_median_3_stack[0,1,2]
keep[-1]

megaclean:

+createca[0]
+createcb[0]
iain_median_3_stack[0,1,2]
keep[-1]

cross:
+shift[0] 0,1,0,0,2
+shift[0] 0,-1,0,0,2
+shift[0] 1,0,0,0,2
+shift[0] -1,0,0,0,2
iain_median_5_stack

ex:
+shift[0] 1,1,0,0,2
+shift[0] 1,-1,0,0,2
+shift[0] -1,-1,0,0,2
+shift[0] -1,1,0,0,2
iain_median_5_stack

hybrid_median:
ac "
repeat $1
+cross[0]
+ex[0]
iain_median_3_stack[0,1,2]
done
",$2

iain_hybrid_median:
repeat $1
+cross[0]
+ex[0]
iain_median_3_stack[0,1,2]
done

iain_pixel_denoise:
if $1==0
ac "
repeat $2
megaclean
done
",$3
elif $1==1
hybrid_median[0] $2,$3
elif $2==1
+l[0]
(1,1,1;1,0,1;1,1,1)
dilate[0] [1]
rm[1]
endl
+l[0]
(1,1,1;1,0,1;1,1,1)
erode[0] [1]
rm[1]
endl
min[0,1]
max[0,1]
endif

iain_pixel_denoise_p:
if $5 # parallel processing
 if $1==0
  ac "
  repeat $2
  apply_parallel_overlap \"megaclean \",4,0
  done
  ",$3
 elif $1==1
  ac "
  apply_parallel_overlap \"iain_hybrid_median[0] $2\",4,0
  ",$3
 elif $1==2
 ac "
  apply_parallel_overlap \"

  +l[0]
  (1,1,1;1,0,1;1,1,1)
  dilate[0] [1]
  rm[1]
  endl
  +l[0]
  (1,1,1;1,0,1;1,1,1)
  erode[0] [1]
  rm[1]
  endl
  min[0,1]
  max[0,1]

   \",4,0
  ",$3
 endif

else
 if $1==0
  ac "
  repeat $2
  megaclean
  done
  ",$3
 elif $1==1
  ac "
  iain_hybrid_median_p[0] $2
  ",$3
 elif $1==2
  ac "

  +l[0]
  (1,1,1;1,0,1;1,1,1)
  dilate[0] [1]
  rm[1]
  endl
  +l[0]
  (1,1,1;1,0,1;1,1,1)
  erode[0] [1]
  rm[1]
  endl
  min[0,1]
  max[0,1]

  ",$3
 endif

endif
time=$|
iain_pixel_denoise_p_preview:
if $4==0
iain_pixel_denoise_p ${1--1}
endif
if $4==1
+iain_pixel_denoise_p ${1--1}
sub[0] [1]
keep[0]
n 0,255
endif

##################### Filter End ########################

#######################################
#      Recursive Median         #
#######################################

#@gui Recursive Median: iain_recursive_median_p, iain_recursive_median_p_preview(0)

#@gui : Median Radius = int(3,1,20)
#@gui : Repeats = int(1,1,20)
#@gui : Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator()
#@gui : Preview Shows = choice("Output","Difference")
#@gui : sep = separator()
#@gui : Parallel Processing = choice(1,"Off","Auto")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")
#@gui : note = note("<small>Update - 25 October 2013 - Parallel Processing was not working properly, fixed now.
#@gui : note = note("<small>Update - 20 October 2013 - Parallel Processing and Control Layout</small>")
iain_recursive_median_p:
if $5
ac "
apply_parallel_overlap \"
repeat $2 median $1 done
\",{$1*2},0
",$3,0
else
ac "
repeat $2 median $1 done
",$3,0
endif

recursive_median:
ac "repeat $3 median $1 done",$2,0

iain_recursive_median_p_preview:
if $-2==0
iain_recursive_median_p $1,$2,$3,$4,$5
endif
if $-2==1
remove_opacity
+iain_recursive_median_p $1,$2,$3,$4,$5
sub[0] [1]
keep[0]
mul 2
add 128
endif

##################### Filter End ########################
####################################
#      Local Similarity Mask       #
####################################
#@gui Local Similarity Mask: local_similarity_mask, local_similarity_mask(1)
#@gui : note = note("Select pixels at")
#@gui : Center (%) = point(50,50,0,1)
#@gui : note = note("With similarity")
#@gui : Keep = int (50,0,255)
#@gui : Reject  = int (128,0,255)
#@gui : note = note("On these channels")
#@gui : Channel(s) = choice(4,"RGB","Red","Green","Blue","Luminance","a-component","b-component","Hue","Saturation","Value","Lightness","[Cyan]MYK","C[Magenta]YK","CM[Yellow]K","CMY[Key]")
#@gui : Steps = int (10,2,100)
#@gui : sep = separator()
#@gui : note = note("This filter creates a mask based on pixels that are close to, and similar to, the selected pixel.")
#@gui : sep = separator()
#@gui : note = note("Author : <i>Iain Fergusson</i>. Update 12 September 2018: Added interactive point and <b>Steps</b> control")
local_similarity_mask:
repeat $! l[$>]
nm=${-gui_layer_name}
x_location=$1
y_location=$2
keep=$3
reject=$4
colour_channel=$5
if $6==0
steps=100
elif $6==1
steps=25
elif $6>1
steps={min($6,($reject-$keep))}
endif


to_rgb
if $colour_channel!=0

 if $colour_channel==1  channels 0 endif
 if $colour_channel==2  channels 1 endif
 if $colour_channel==3  channels 2 endif
 if $colour_channel==4 luminance endif
 if $colour_channel==5 rgb2lab[0] channels 1 endif
 if $colour_channel==6 rgb2lab[0] channels 2 endif
 if $colour_channel==7 rgb2hsv[0] channels 0 endif
 if $colour_channel==8 rgb2hsv[0] channels 1 endif
 if $colour_channel==9 rgb2hsv[0] channels 2 endif
 if $colour_channel==10 rgb2hsl[0] channels 2 endif
 if $colour_channel==11 rgb2cmyk[0] channels 0 endif
 if $colour_channel==12 rgb2cmyk[0] channels 1 endif
 if $colour_channel==13 rgb2cmyk[0] channels 2 endif
 if $colour_channel==14 rgb2cmyk[0] channels 3 endif

endif

n 0,255

mul[0] 0.9
{w},{h},1,1,0

step_size={($reject-$keep)/$steps}

repeat $steps
+flood[0] $x_location%,$y_location%,0,{$keep+($>*$step_size)},0,1,255 threshold[-1] 99%
add[-1,-2]
done
keep[-1]
n 0,255
nm name($nm)
endl done

################# Filter End ###############
#@gui _<b>Testing</b>

#@gui Iain Fergusson

#@gui Iain's Noise Reduction old: iain_iains_nr,iain_iains_nr_preview(0)
#@gui : 1 Luma NR = float (3,0,20)
#@gui : 2 Chroma NR = float (3,0,20)
#@gui : 3 Despeckle = int (1,0,4)
#@gui : note = note("       <small>Adjust noise reduction by tone</small>")
#@gui : 4 Highlights = float (0,-50000,50000)
#@gui : 5 Shadows = float (0,-32000,32000)
#@gui : sep = separator ()
#@gui : note = note("<b>Recover Details</b>")
#@gui : 6 Recover Details = choice (0,"Do not Recover Details","Recover Details", "Recover Details as separate layer")
#@gui : 7 Recovery Amount = float(1,.1,10)
#@gui : note = note("       <small>Adjust detial recovery by size</small>")
#@gui : 8 Adjust Fine Details = float (0,-500,500)
#@gui : 9 Adjust Medium Details = float (0,-500,500)
#@gui : 10 Adjust Large Details = float (0,-500,500)
#@gui : 11 Detail Emphasis = float (1.35,1,4)
#@gui : sep = separator ()
#@gui : 12 Sharpen Edges = float (0,0,4)
#@gui : note = note("<b>Preview options</b>")
#@gui : 13 Preview Shows= choice (0,"Normal Output","Luma Noise",  "Chroma Noise","Details")
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 10 Jan 2013")
iain_iains_nr:
repeat $! l[$>] nm={0,n} split_opacity l[0]
lnr=$1
cnr=$2
despek=$3
highs=$4
shadow=$5
recovery_choice=$6
detail_recovery={5000-($7*500)}
fast=1
fine_det=$8
med_det=$9
large_det=$10
det_emphasis=$11
sharp=$12
to_rgb
apply_gamma {1/1.3} ## apply pre-gamma curve to help equalise image noise in different tones
mul 900    ## increase range of number before curve to prevent posterisation
apply_curve 1,0,0,32000,{32000-$shadow},160000,{160000-$shadow},256000,{256000-$highs-$shadow} ## apply user curve to adjust for nois ein shadows and highlights
div 2000 ## undo pre-curve multiplication and reduce image brightness
iain_rgb2ycbcr ## convert to my approximation of YCBCR colour space
split c ## split colour channels so noise reduction can be applied to Luma and Chroma seperatly
if $lnr>0 ## IF Luma NR is 0 no need to do it
 if $recovery_choice==0 ## do not recover details
  iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0  ## apply luma NR
  unsharp[0] .7,$sharp,0  ##sharpen edges
 endif
 if $recovery_choice==1 ## Recover details and merge with origianl
  +iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
  +sub[0] [-1]
  add[-1] {128}
  remove[0]
  unsharp[2] .7,$sharp,0
  resize[-1] {w+48},{h+48},{d},{s},0,0,0,0 ## add image border to allow tile offsets with artefacts
  resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
  rectangle[-1] 0,0,100%,48,1,128 ## set border to mid grey
  rectangle[-1] 0,0,48,100%,1,128
  rectangle[-1] 0,100%,100%,{h-48},1,128
  rectangle[-1] {w-48},100%,100%,0,1,128
  iains_nr_fft_tile3[-1] {$detail_recovery},48,0,$fine_det,$med_det,$large_det,1,3 ## recover details
  crop[-1] 48,48,{w-49},{h-49}
  sub[-1] {128}
  mul[-1] $det_emphasis  ## increase detail contrast
  add[2] [-1]
  remove[-1]
  move[-1] 0
 endif
  if $recovery_choice==2 ## Recover details as separate layer
  +iains_nr_patchb[0] 10,$lnr,3,3,0,$fast,1,$despek,.5,.4,.2,0,1,1,2,0
  +sub[0] [-1]
  add[-1] {128}
  remove[0]
  unsharp[2] .7,$sharp,0
  resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
  resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
  rectangle[-1] 0,0,100%,48,1,128
  rectangle[-1] 0,0,48,100%,1,128
  rectangle[-1] 0,100%,100%,{h-48},1,128
  rectangle[-1] {w-48},100%,100%,0,1,128
  iains_nr_fft_tile3[-1] {$detail_recovery},48,0,$fine_det,$med_det,$large_det,1,3
  crop[-1] 48,48,{w-49},{h-49}
  sub[-1] 128
  mul[-1] $det_emphasis
  add[-1] 128
  move[-2] 0
 endif

endif
if $cnr>0 ## If Chroma NR is greater than 0 do chroma NR
add[1,2] 300
iains_nr_patchb[1] 10,$cnr,3,3,0,1,1,4,.5,.4,.2,0,1,1,2,0
iains_nr_patchb[2] 10,$cnr,3,3,0,1,1,4,.5,.4,.2,0,1,1,2,0
sub[1,2] 300
endif

append[0,1,2] c ## recombine colour channels
iain_ycbcr2rgb[0] ## convert back to rgb
mul[0] 2000 ## boost brightness and scale befreo applying curve
apply_curve[0] 1,0,0,{32000-$shadow},32000,{160000-$shadow},160000,{256000-$highs-$shadow},256000 ## undo user curve
div[0] 900 ## restore image to normal range
apply_gamma[0] 1.3 ## undo previous gamma adjustment
c 0,255
endl a c nm $nm endl done
iains_nr_med3stack16:
blend_median

iains_nr_med5stack16:
blend_median

iains_nr_fft_tile3_fft:

+fftpolar[0]
100%,100%,1,1,1
ellipse[-1] 50%,50%,50%,50%,0,1,$4
ellipse[-1] 50%,50%,15%,15%,0,1,$5
ellipse[-1] 50%,50%,5%,5%,0,1,$6
+add[1] [-1]
threshold[-1] $1
set[-1] 1,50%,50%
mul[1] [-1]
+ifftpolar[1,2]
remove[0,1,2]
keep[-1]

iains_nr_fft_tile3_clean:

tc={round(w/$2)} tr={round(h/$2)}
split_tiles $tc,$tr
repeat $! local[$>]
iains_nr_fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
endlocal done
append_tiles $tc,$tr
c 0,255

iains_nr_fft_tile3:

## fft_tile3_fft  $1,$2,$3,$4,$5,$6
+resize[0] {w+$2},{h+$2},1,1,0,1,1,1
resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,$2,{w-$2-1},{h-$2-1}

if $8>2
#right a bit

push={round($2*1.5)}
pull={$2-$push}

+resize[0] {w+$push},{h+$2},1,1,0,1,1,1
resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}

## Down a bit

+resize[0] {w+$2},{h+$push},1,1,0,1,1,1
resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
endif
if $8>1
#diagonal 1

dia1={round($2/3)}
dia2={$2-$dia1}

+resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}

#diagonal 2

+resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
iains_nr_fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
endif
remove[0]
if $8==3
blend_median
endif
if $8==2
blend_median
endif

iains_nr_patchb_smoothing:
repeat $7 denoise $1,$2,$3,$4,$5,$6 done
## c 0,255

iains_nr_patchb_2:
+resize[0] 50%,50%,1,{s},2   ## create smaller image
+iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8   ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]
iains_nr_patchb_3:
+resize[0] 25%,25%,1,{s},2   ## create smaller image
+iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8    ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]

iains_nr_patchb_4:
+resize[0] 12.5%,12.5%,1,{s},2   ## create smaller image
+iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8   ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]

iains_nr_patchb_5:
+resize[0] 6.125%,6.125%,1,{s},2   ## create smaller image
+iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8    ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]

iains_nr_patchb:

apply_gamma {1/$14}
 if $8==1
 hybrid_median[-1] 1,0,0
 endif
 if $8==2
 hybrid_median[-1] 3,0,0
 endif
 if $8==3
 median[-1] 3
 endif
 if $8==4
 median[-1] 3
 median[-1] 3
 median[-1] 3
 endif
repeat $15
 if $8<4
  if $13==1
  iains_nr_patchb_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
  endif
 endif
iains_nr_patchb_2 $1,{$2*$9},$3,$4,$5,$6,$7,$8
iains_nr_patchb_3 $1,{$2*$10},$3,$4,$5,$6,$7,$8
iains_nr_patchb_4 $1,{$2*$11},$3,$4,$5,$6,$7,$8
iains_nr_patchb_5 $1,{$2*$12},$3,$4,$5,$6,$7,$8

done
apply_gamma $14

iain_rgb2ycbcr:
redmul=.299
greenmul=.587
bluemul=.114

to_rgb[0]
+split[0] c
mul[1] $redmul
mul[2] $greenmul
mul[3] $bluemul
add[1-3]

split[0] c
name[0] red
name[1] green
name[2] blue
name[3] luma

+sub[blue] [luma]
name[-1] cb
+sub[red] [luma]
name[-1] cr
keep[luma,cb,cr]
append[luma,cb,cr] c

iain_ycbcr2rgb:
redmul=.299
greenmul=.587
bluemul=.114

split c
name[0] luma
name[1] cb
name[2] cr

+add[cb] [luma]
name[-1] blueout
+add[cr] [luma]
name[-1] redout

remove[1,2]

+mul[redout] $redmul
+mul[blueout] $bluemul
sub[luma] [-1]
sub[luma] [-2]
div[luma] $greenmul
remove[-1,-2]
move[2] 0
## text $greenmul,0,0,25,1,255
append c
## n 0,255

iain_iains_nr_preview:
if $-1==0 ## Normal Preview
iain_iains_nr ${1--2}
endif
if $-1==1 ## Luma Noise Preview
+iain_iains_nr $1,0,$3,$4,$5,$6,$7,$8,$9,$10,1.3,0
compose_grainextract
sub 128
mul 3
add 128
endif
if $-1==2 ## Chroma Noise Preview
+iain_iains_nr 0,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,0
compose_grainextract
sub 128
mul 3
add 128
endif
if $-1==3 ## Details Preview
iain_iains_nr $1,$2,$3,$4,$5,2,$7,$8,$9,$10,$11,0
keep[-1]
sub 128
mul 3
add 128
endif

#@gui Auto WB by hue variance: iain_auto_wb,iain_auto_wb_preview(1)
#@gui : note = note{"Restrict analysis to this box"}
#@gui : Corner 1 = point(5,5,0,1,255,255,255,128,10)
#@gui : Corner 2 = point(95,95,0,1,255,255,255,128,10)
#@gui : sep = separator()
#@gui : Normalise = bool(1)
#@gui : Negative = bool(0)
#@gui : sep = separator()
#@gui : note = note{"This filter finds the white balance of the image by maxiumising the variation of hues. The area for analysis should contain a range of hues. Do not try to select a neutral grey area."}
iain_auto_wb_preview:
iain_auto_wb[0] $1,$2,$3,$4,$5,$6
rectangle[0] $1%,$2%,$3%,$4%,1,0xffff,255

iain_auto_wb:
repeat $! l[$>]
remove_opacity
norm_out=$5
repeats=15
display_text=0
rm_outliers=1
max_pixels={2^16}

lower_limit=5
upper_limit=200
+l[0] #reduce number of pixels to analyse

 target_pixel_number={2^16}
 crop $1%,$2%,$3%,$4%
 +l[0] split c max endl

 fill[-1] if(i<$lower_limit||i>$upper_limit,0,1)
 good_pixels={-1,is}
 pixel_retention_ratio={$good_pixels/{wh}}
 scale_factor={sqrt((($target_pixel_number/$pixel_retention_ratio)/{wh}))}

 if $scale_factor<1
 resize {w*$scale_factor},{h*$scale_factor},100%,100%,2
 endif

 gt[-1] 0
 add[0] 1
 mul[0] [-1]
 sub[0] 1
 rm[-1]
 split c
 unroll[0] x
 unroll[1] x
 unroll[2] x
 discard[0,1,2] x,-1
 append[0,1,2] c

  +to_rgb[-1]
   l[-1] #sort by colour numnber
     split c
     bsl[1] 8
     bsl[2] 16
     add
   endl

  reverse
  append y
  sort +,x
  discard x
  rows 1
 append c

endl

#find base hue variation
 +l[1]
   rgb2hsv channels 0 +add[-1] 180 mod[-1] 360
   hv_old={min({0,iv},{1,iv})}
  rm
 endl
hv_old_b=$hv_old
hv_new_A_plus_B_plus=0
hv_new_A_plus_B_minus=0
hv_new_A_minus_B_plus=0
hv_new_A_minus_B_minus=0
shift_a=0
shift_b=0
step_size=3

repeat $repeats
shift_a_top=$shift_a

# test A+step and B+step

 +l[1]

  iain_rgb_mix_wb[0] {$shift_a+$step_size},{$shift_b+$step_size}
   rgb2hsv channels 0  +add[-1] 180 mod[-1] 360
   hv_new_A_plus_B_plus={min({0,iv},{1,iv})}
  rm
 endl

# test A+step and B-step

 +l[1]
  iain_rgb_mix_wb[0] {$shift_a+$step_size},{$shift_b-$step_size}
   rgb2hsv channels 0  +add[-1] 180 mod[-1] 360
   hv_new_A_plus_B_minus={min({0,iv},{1,iv})}
  rm
 endl

# test A-step and B+step

 +l[1]
  iain_rgb_mix_wb[0] {$shift_a-$step_size},{$shift_b+$step_size}
   rgb2hsv channels 0  +add[-1] 180 mod[-1] 360
   hv_new_A_minus_B_plus={min({0,iv},{1,iv})}
  rm
 endl

# test A-step and B-step

 +l[1]
  iain_rgb_mix_wb[0] {$shift_a-$step_size},{$shift_b-$step_size}
   rgb2hsv channels 0  +add[-1] 180 mod[-1] 360
   hv_new_A_minus_B_minus={min({0,iv},{1,iv})}
  rm
 endl
hv_max={max($hv_old,$hv_new_A_plus_B_plus,$hv_new_A_plus_B_minus,$hv_new_A_minus_B_plus,$hv_new_A_minus_B_minus)}

if $hv_old==$hv_max

# keep old

elif $hv_new_A_plus_B_plus==$hv_max

shift_a={$shift_a+$step_size}
shift_b={$shift_b+$step_size}
hv_old=$hv_new_A_plus_B_plus

elif $hv_new_A_plus_B_minus==$hv_max

shift_a={$shift_a+$step_size}
shift_b={$shift_b-$step_size}
hv_old=$hv_new_A_plus_B_minus

elif $hv_new_A_minus_B_plus==$hv_max

shift_a={$shift_a-$step_size}
shift_b={$shift_b+$step_size}
hv_old=$hv_new_A_minus_B_plus

elif $hv_new_A_minus_B_minus==$hv_max

shift_a={$shift_a-$step_size}
shift_b={$shift_b-$step_size}
hv_old=$hv_new_A_minus_B_minus

endif

  step_size={$step_size/2}

  red_mul={round((2^$shift_a),0.1,0)}
  blue_mul={round((2^$shift_b),0.1,0)}

done

iain_rgb_mix_wb[0] $shift_a,$shift_b
k[0]

if $norm_out
n 0,255
endif
c 0,255
if $6
negate
endif

endl
done
iain_rgb_mix_wb:
remove_opacity
split c
mul[0] {2^$1}
mul[2] {2^$2}
append c
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#@gui 2D_scopes: iain_2d_scopes,iain_2d_scopes(1)
#@gui : Y axis = choice (1,"Yuv","yUv","yuV","Hsv","hSv","hsV","Lab","lAb","laB","lCh","lcH","Cmyk","cMyk","cmYk","cmyK","Rgb","rGb","rgB")
#@gui : X axis = choice (2,"Yuv","yUv","yuV","Hsv","hSv","hsV","Lab","lAb","laB","lCh","lcH","Cmyk","cMyk","cmYk","cmyK","Rgb","rGb","rgB")
#@gui : Type = Choice(2,"Dots","Circles","Circles scaled by Luma","Heat map")
#@gui : Colour bits = int(6,1,8)
#@gui : Plot size = int(512,64,1024)
#@gui : Max samples = int(2048,16,4096)
#@gui : Chart elements = choice(1,"no info","axes","underlay")
#@gui : Generate test colours = bool (0)
#@gui : Mirror Y axis = bool (0)
#@gui : Mirror X axis = bool (0)
#@gui : Rotate = choice (0,"0","90","180","270")
iain_2d_scopes:
repeat $! l[$>]
remove_opacity

y_axis=$1
x_axis=$2
plot_type=$3
resolution=$4
plot_size=$5
max_samples=$6

chart_type=$7
test_pattern=$8

mirror_y=$9
mirror_x=$10

rotate_deg={$11*90}
if $plot_type==3
remove_duplicates=0
else
remove_duplicates=1
endif

luma_sort=1

# generate test pattern

if $test_pattern
rm
cube_d={2^$resolution}
$cube_d,$cube_d,$cube_d
to_rgb
split c
fill[0] x
fill[1] y
fill[2] z
n 0,255
append c
split z
append_tiles 0,0
 split y
 append x

endif
split y
append x

if w>$max_samples
resize $max_samples,1
endif
# bit depth reducation, remove duplicates colours, sort by luma
 bsr[0] {8-$resolution}

if $remove_duplicates

 +to_rgb[-1]
  l[-1] #sort by colour numnber
    split c
    bsl[1] 8
    bsl[2] 16
    add
  endl

 reverse
 append y
 sort +,x
 discard x
 rows 1
endif

if $luma_sort
 +luminance[-1]
 ## +norm[-1]
 ## +l[-1] split c max endl
 reverse
 append y
 sort +,x
 rows 1
endif
bsl {8-$resolution} # scale back to better range

# X-axis

+l[0]
 if $x_axis==0
  rgb2yuv8[0]
  channels[0] 0
 elif $x_axis==1
  rgb2yuv8[0]
  channels[0] 1
 elif $x_axis==2
  rgb2yuv8[0]
  channels[0] 2
 elif $x_axis==3
  rgb2hsv8[0]
  channels[0] 0
 elif $x_axis==4
  rgb2hsv8[0]
  channels[0] 1
 elif $x_axis==5
  rgb2hsv8[0]
  channels[0] 2
 elif $x_axis==6
  rgb2lab8[0]
  channels[0] 0
 elif $x_axis==7
  rgb2lab8[0]
  channels[0] 1
 elif $x_axis==8
  rgb2lab8[0]
  channels[0] 2

 elif $x_axis==9
  rgb2lch8[0]
  channels[0] 1

 elif $x_axis==10
  rgb2lch8[0]
  channels[0] 2
 elif $x_axis==11
  rgb2cmyk[0]
  channels[0] 0
 elif $x_axis==12
  rgb2cmyk[0]
  channels[0] 1
 elif $x_axis==13
  rgb2cmyk[0]
  channels[0] 2
 elif $x_axis==14
  rgb2cmyk[0]
  channels[0] 3

 elif $x_axis==15
  channels[0] 0
 elif $x_axis==16
  channels[0] 1
 elif $x_axis==17
  channels[0] 2
 endif

endl

+l[0]
 if $y_axis==0
  rgb2yuv8[0]
  channels[0] 0
 elif $y_axis==1
  rgb2yuv8[0]
  channels[0] 1
 elif $y_axis==2
  rgb2yuv8[0]
  channels[0] 2
 elif $y_axis==3
  rgb2hsv8[0]
  channels[0] 0
 elif $y_axis==4
  rgb2hsv8[0]
  channels[0] 1
 elif $y_axis==5
  rgb2hsv8[0]
  channels[0] 2
 elif $y_axis==6
  rgb2lab8[0]
  channels[0] 0
 elif $y_axis==7
  rgb2lab8[0]
  channels[0] 1
 elif $y_axis==8
  rgb2lab8[0]
  channels[0] 2

 elif $y_axis==9
  rgb2lch8[0]
  channels[0] 1

 elif $y_axis==10
  rgb2lch8[0]
  channels[0] 2

 elif $y_axis==11
  rgb2cmyk[0]
  channels[0] 0
 elif $y_axis==12
  rgb2cmyk[0]
  channels[0] 1
 elif $y_axis==13
  rgb2cmyk[0]
  channels[0] 2
 elif $y_axis==14
  rgb2cmyk[0]
  channels[0] 3

 elif $y_axis==15
  channels[0] 0
 elif $y_axis==16
  channels[0] 1
 elif $y_axis==17
  channels[0] 2
 endif

endl
 mul[-1,-2] {$plot_size/256} # scale values to plot dimensions

    $plot_size,$plot_size,1,1,0
    to_rgb[-1]
    fill[-1] -1
    repeat {0,w}

     # plot type
      if $plot_type==0
       point[-1] {1,i($>)},{2,i($>)},0,1,{0,i($>,0,0,0)},{0,i($>,0,0,1)},{0,i($>,0,0,2)}
      elif $plot_type==1

       circle[-1] {1,i($>)},{2,i($>)},0.3%,1,{0,i($>,0,0,0)},{0,i($>,0,0,1)},{0,i($>,0,0,2)}
      elif $plot_type==2

       circle_size={max({$<*(1/{0,w})},0.15)}

       circle[-1] {1,i($>)},{2,i($>)},$circle_size%,1,{0,i($>,0,0,0)},{0,i($>,0,0,1)},{0,i($>,0,0,2)}

      elif $plot_type==3

       l[0]
       rgb2hsv split c fill[-1] 1 append c hsv2rgb
       endl

       circle_size={1}

       circle[-1] {1,i($>)},{2,i($>)},$circle_size%,0.1,{0,i($>,0,0,0)},{0,i($>,0,0,1)},{0,i($>,0,0,2)}
      endif
    done
k[-1]
if $chart_type!=0

100%,100%,1,1
fill[-1] x
   n[-1] 0,255
 l[-1]
  if $x_axis==0
  +fill[0] {255/2}
  +fill[0] {255/2}
  append c
  yuv82rgb
 elif $x_axis==1
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 2
  append c
  yuv82rgb
 elif $x_axis==2
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 3
  append c
  yuv82rgb

 elif $x_axis==3
  +fill[0] {255}
  +fill[0] {255}
  append c
  hsv82rgb
 elif $x_axis==4
  +fill[0] {255}
  +fill[0] {255}
  move[0] 2
  append c
  hsv82rgb
 elif $x_axis==5
  +fill[0] {0}
  +fill[0] {0}
  move[0] 3
  append c
  hsv82rgb

 elif $x_axis==6
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 1
  append c
  lab82rgb
 elif $x_axis==7
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 2
  append c
  lab82rgb
 elif $x_axis==8
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 3
  append c
  lab82rgb

 elif $x_axis==9
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 2
  append c
  lch82rgb

 elif $x_axis==10
  +fill[0] 180
  +fill[0] 128
  move[0] 3
  append c
  lch82rgb
 elif $x_axis==11
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 1
  append c
  cmyk2rgb
 elif $x_axis==12
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 2
  append c
  cmyk2rgb
 elif $x_axis==13
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 3
  append c
  cmyk2rgb
 elif $x_axis==14
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 4
  append c
  cmyk2rgb

 elif $x_axis==15
  +fill[0] {0}
  +fill[0] {0}
  move[0] 1
  append c
 elif $x_axis==16
  +fill[0] {0}
  +fill[0] {0}
  move[0] 2
  append c
 elif $x_axis==17
  +fill[0] {0}
  +fill[0] {0}
  move[0] 3
  append c
 endif
 endl

100%,100%,1,1
fill[-1] y
   n[-1] 0,255
 l[-1]
  if $y_axis==0
  +fill[0] {255/2}
  +fill[0] {255/2}
  append c
  yuv82rgb
 elif $y_axis==1
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 2
  append c
  yuv82rgb
 elif $y_axis==2
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 3
  append c
  yuv82rgb

 elif $y_axis==3
  +fill[0] {255}
  +fill[0] {255}
  append c
  hsv82rgb
 elif $y_axis==4
  +fill[0] {255}
  +fill[0] {255}
  move[0] 2
  append c
  hsv82rgb
 elif $y_axis==5
  +fill[0] {0}
  +fill[0] {0}
  move[0] 3
  append c
  hsv82rgb

 elif $y_axis==6
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 1
  append c
  lab82rgb
 elif $y_axis==7
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 2
  append c
  lab82rgb
 elif $y_axis==8
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 3
  append c
  lab82rgb

 elif $y_axis==9
  +fill[0] {255/2}
  +fill[0] {255/2}
  move[0] 2
  append c
  lch82rgb

 elif $y_axis==10
  +fill[0] 180
  +fill[0] 128
  move[0] 3
  append c
  lch82rgb
 elif $y_axis==11
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 1
  append c
  cmyk2rgb
 elif $y_axis==12
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 2
  append c
  cmyk2rgb
 elif $y_axis==13
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 3
  append c
  cmyk2rgb
 elif $y_axis==14
  +fill[0] {0}
  +fill[0] {0}
  +fill[0] {0}
  move[0] 4
  append c
  cmyk2rgb

 elif $y_axis==15
  +fill[0] {0}
  +fill[0] {0}
  move[0] 1
  append c
 elif $y_axis==16
  +fill[0] {0}
  +fill[0] {0}
  move[0] 2
  append c
 elif $y_axis==17
  +fill[0] {0}
  +fill[0] {0}
  move[0] 3
  append c
 endif
 endl
if $chart_type==1

100%,100%
100%,100%
linethick[-1] 50%,0,50%,100%,{$plot_size*.01},1,1
linethick[-2] 0%,50%,100%,50%,{$plot_size*.01},1,1
mul[1,3]
mul[2,3]

 endif
blend[-1,-2] average

if $chart_type==1
l[-1]
+l[0] split c max endl
gt[-1] 0
replace[-1] 1,128
laplacian[-1]
abs
max
endl

endif
+eq[0] -1
l[-1] split c min  erode_circ {round($plot_size*.1)} blur {$plot_size*.025} endl

mul[-1,-2]


endif

max

if $mirror_y
mirror y
endif
if $mirror_x
mirror x
endif

rotate $rotate_deg

  endl done

#@gui Split Detials [Orientation] : iain_split_orientation,iain_split_orientation_preview(0)
#@gui : Center (%) = point(75,50,0,1)
#@gui : Angle range = int (45,1,90)
#@gui : Residual size = float (10,0,50)
#@gui : Snap to angle = int (5,0,45)
#@gui : Angle transition = int (5,0,45)
#@gui : Preview line only = bool(0)
#@gui : Top Layer = choice(0,"Isolate orientation","Remove orientation")
#@gui : Output = choice(1,"Isolated/Removed only","Isolated/Removed & Residual","Residual only")
iain_split_orientation_preview:
if $7
iain_draw_angle $1,$2,$5
else
iain_split_orientation $1,$2,$3,$4,$5,$6,$7,$8,$9
## image_statistics
iain_draw_angle $1,$2,$5
endif

iain_split_orientation:
residual=$4
snap=$5
cutoff_steepness=$6

x_point={($1-50)/100}
y_point={($2-50)/100}
angle_rad={-1*(atan($x_point/$y_point))}
if $8
angle_rad={$angle_rad+(pi/2)}
endif
angle_deg={$angle_rad/pi*180}
angle_deg_snap={round(($angle_deg+180),$snap)-180}
angle_rad_snap={$angle_deg_snap/180*pi}

radians={$angle_rad_snap+(pi/2)}
width={($3/180)*pi}
if $8
width={((180-$3)/180)*pi}
endif
remove_opacity
+blur[0] $residual
sub[0] [-1]
100%,100%
  fill[-1] ($radians+atan((0.5-(x/w))/(0.5-(y/h)))-$width/2)%pi
  low_angle={pi-$width}
  high_angle={pi+$width}
  fill[-1] if($high_angle>i&&i>$low_angle,1,0)
  radians=$radians+($width)

+fftpolar[0]
blur_angular[2] $cutoff_steepness
c[2] 0,1

## circle[2] 50%,50%,3,1,1
mul[3] [2]
rm[2]
ifftpolar[-1,-2]
sub[0] [-1]
add[0,1]
reverse

if $9==0
k[0]
add[0] 128
elif $9==1
add[0] 128
nm[0] "mode(grainmerge), name"
elif $9==2
k[1]
endif

iain_draw_angle:

repeat $!
l[$<]
snap=$3
## channels 0

+l[0]
remove_opacity
fill 0
x_point={($1-50)/100}
y_point={($2-50)/100}

angle_rad={-1*(atan($x_point/$y_point))}
angle_deg={$angle_rad/pi*180}
angle_deg_snap={round(($angle_deg+180),$snap)-180}
angle_rad_snap={$angle_deg_snap/180*pi}
if (sin($angle_rad))==0 angle_rad=0$angle_rad+.0001 endif
if (cos($angle_rad))==0 angle_rad=0$angle_rad+.0001 endif
hypotenuse_x={$x_point/(sin($angle_rad))}
hypotenuse_y={$y_point/(cos($angle_rad))}
line_x={((sin($angle_rad)*$hypotenuse_x)+0.5)*w}
line_y={((cos($angle_rad)*$hypotenuse_y)+0.5)*h}
line_x_snap={((sin($angle_rad_snap)*($hypotenuse_x))+0.5)*w}
line_y_snap={((cos($angle_rad_snap)*($hypotenuse_y))+0.5)*h}
text_hyp_x={$hypotenuse_x+(sign($hypotenuse_x)*0.05)}
text_hyp_y={$hypotenuse_y+(sign($hypotenuse_y)*0.05)}
text_x={((sin($angle_rad_snap)*($text_hyp_x))+0.5)*w}
text_y={((cos($angle_rad_snap)*($text_hyp_y))+0.5)*h}
poly_hyp_x={sign($hypotenuse_x)}
poly_hyp_y={sign($hypotenuse_y)}
poly_x1={((sin($angle_rad_snap)*($poly_hyp_x))+0.5)*w}
poly_y1={((cos($angle_rad_snap)*($poly_hyp_y))+0.5)*h}
poly_x2={((sin($angle_rad)*($poly_hyp_x))+0.5)*w}
poly_y2={((cos($angle_rad)*($poly_hyp_y))+0.5)*h}

100%,100%,1,1,0
rm[0]
circle[-1] 50%,50%,{abs($hypotenuse_x)*w},1,255,255,255,255
circle[-1] 50%,50%,{(abs($hypotenuse_x)*w)-2},1,0,0,0,255
100%,100%,1,1,0
polygon[-1] 3,50%,50%,$poly_x1,$poly_y1,$poly_x2,$poly_y2,1,1
mul[-1] [-2]
rm[-2]
[-1]
+iain_draw_conical_lines[-1] 6,3
mul[-1,-3]
mul[-1] {80/255}
to_rgb[-2]
append[-1,-2] c
100%,100%,1,1,0
linethick[-1] 50%,50%,$line_x,$line_y,2,1,255
linethick[-1] 50%,50%,$line_x_snap,$line_y_snap,2,1,255
+iain_draw_radial_lines[-1] 8,4
mul[-1,-2]
100%,100%,1,1,0
linethick[-1] 50%,50%,$line_x,$line_y,2,1,80
linethick[-1] 50%,50%,$line_x_snap,$line_y_snap,2,1,160
to_rgb[-2]
append[-1,-2] c

max

text[-1] {round($angle_deg_snap,1)},$text_x,$text_y,17,1,255

endl
blend alpha
endl
done

iain_draw_conical_lines:
100%,100%,1,1
rm[0]

radians=0
width=0
  fill[0] ($radians+atan((0.5-(x/w))/(0.5-(y/h)))-$width/2)/pi*360
mod $1
lt $2

iain_draw_radial_lines:
100%,100%,1,1
rm[0]
set 1,50%,50%
distance 1
mod $1
lt $2


#@gui Subtract Cast: iain_sub_cast,iain_sub_cast(0)
#@gui : noise reduction = float (5,0,10)
#@gui : black level = float (20,0,128)
#@gui : white level = float (250,128,255)
iain_sub_cast:
repeat $! l[$>]
srgb2rgb
+median[0] 3
bilateral[0] [1],10,$1
rm[1]
+resize[0] 10%,10%,100%,100%,2
dilate[1] 21
split[1] c
fill[1] {1,ia}
fill[2] {2,ia}
fill[3] {3,ia}
append[1,2,3] c
resize[1] [0]
sub[0] [1]
k[0]
n[0] 0,255
c[0] $2,$3
n 0,255
rgb2srgb
nm name($nm)
endl done
#@gui Anisotropic_tutorial: iain_smooth_tutorial,iain_smooth_tutorial(0)
#@gui : Amplitude = float (1000,0,2000)
#@gui : sep = separator ()
#@gui : note = note("Edge Sensitivity")
#@gui : Sharpness  = float (0.5,0,2)
#@gui : sep = separator ()
#@gui : note = note("Directionality")
#@gui : Anisotropy = float (1,0,1)
#@gui : sep = separator ()
#@gui : note = note("Swirl")
#@gui : Gradient Smoothness = float (0.6,0,20)
#@gui : sep = separator ()
#@gui : note = note("Align")
#@gui : Tensor Smoothness = float (1.1,0,20)
#@gui : sep = separator()
#@gui : Show Tensor Field = choice (0,"hidden","overlay","exclusive")
#@gui : Show Gradient Blur = bool(0)

# Compute diffusion tensors for image$?, with sharpness $1, anisotropy $2, alpha $3 and sigma $4

iain_smooth_tutorial:
amplitude=$1
sharpness=$2
anisotropy=$3
gradient_smoothness=$4
tensor_smoothness=$5
quiver=$6

remove_opacity
+l[0] # quiver
p1={if(0,0.5,1)*max($sharpness,1e-2)}
p2={$p1/(1e-7+1-$anisotropy)}
b $gradient_smoothness n 0,255 structuretensors 0 b $tensor_smoothness

eigen max.. 0
if s==2 s.. c +[-3,-2] +.. 1 +^.. -$p1 ^... -$p2 a[-3,-1] c
else s.. c +[-4--2] +.. 1 +^.. -$p1 r. 100%,100%,100%,2 ^... -$p2 a[-3,-1] c
fi
+l #quiver
l[-1]
split[-1] c
+abs[0]
fill[0] acos(i)
add[0] {pi/2}
mod[0] {pi}
fill[0] cos(i)
rm[1]
+fill[0] 0
append c
endl
l[-2]
split c
add
pow $sharpness #add 0.1 c[0] 0.06,255
endl
to_rgb
mul
resize[0] 400%,400%
100%,100%,1,1,255
+quiver[1] [0],24,3,0,1
k[-1]
resize 25%,25%,100%,100%,2
endl
l[-3]
split[0] c
fill[0] 0
c[1] 1,10
append[0,1] c
endl
l[-2,-3]
eigen2tensor
endl
smooth[-1] [-2],5
rm[-2]
luminance
negate
[0]
blur[-1] 3
max[-1] 0.1
fill[-1] 10/i
mul[0] [1]
negate
n 0,255
c 120,255
n 0,255
k[0]
endl

if $7
blur[0] $gradient_smoothness
n[0] 0,255
else
smooth[0] $amplitude,$sharpness,$anisotropy,$gradient_smoothness,$tensor_smoothness
endif

if $quiver==1
ac[0] " sub 128 mul 0.5 add 128",ycbcr_y
n[1] 0,1
mul
elif $quiver==2
k[1]
else
k[0]
endif
c 0,255

#@gui Iain Denoise 2019 beta3 : iain_denoise_2019_beta3,iain_denoise_2019_beta3_preview(0)
## #@gui : note = note("Adjust guide")
#@gui : Gamma = float (1,.05,2)
#@gui : Shadows = float (0,-1,1)
#@gui : Light = float (0,-1,1)
#@gui : Mid Offset = float (0,-0.5,0.5)
#@gui : Desaturate = float(0.5,0,1)
#@gui : Guide mix = float (1,0,1)
#@gui : Soften Guide = bool (0)
## #@gui : soften = float (5,0,30)
## #@gui : note = note("denoise")
#@gui : Fine = float (5,0,30)
#@gui : Mid = float (3,0,30)
#@gui : Large = float (0,0,30)
#@gui : Lookup = int (3,1,7)
## #@gui : note = note("recover")
#@gui : Recovery = choice (0,"no recovery","fast recovery","slow recovery","guide recovery")
#@gui : Recover = float (.5,0,2)

#@gui : Preview shows = choice (4,"Noise","Fine Noise","Mid Noise","Large Noise","Output")
#@gui : Preview Tones map = bool (0)

iain_denoise_2019_beta3_preview:
images={$!}

if $images>2
k[0]
fill 128
text "too many input images",12,12,50,1,0
text "too many input images",10,10,50,1,255
quit
endif

if $images==1
[0]
endif
if $15
+l[-1]
mid_tone_offset={$4/-5}
luminance
add {$mid_tone_offset*255}
resize 25%,25%,100%,100%,2
median 5
line  0,0,0,100%,1,128
line  0,0,100%,0,1,128
line  0,100%,100%,100%,1,128
line  100%,0,100%,100%,1,128
## blur 2
+gt[0] 85
+gt[0] 170
laplacian[1,2]
l[1]
+gt[0] 0
lt[0] 0
replace[0] 1,100
replace[1] 1,1
max[0,1]
endl
l[2]
+gt[0] 0
lt[0] 0
replace[0] 1,255
replace[1] 1,150
max[0,1]
endl
max[-1,-2]
+neq[-1] 0
replace[-1] 1,255
append[-1,-2] c
scale2x[-1]
scale2x[-1]
k[-1]

endl

endif


l[0,1]

if $14==0
fine=$8
mid=$9
large=$10
+iain_denoise_2019_beta3 $1,$2,$3,$4,$5,$6,$7,$fine,$mid,$large,$11,$12,$13,$14,$15
k[0,-1]
sub
noise_amp={_round((128/(max(abs(im),iM))),0.1)}
mul $noise_amp
add 128
c 0,255
elif $14==1
fine=$8
mid=0
large=0
+iain_denoise_2019_beta3 $1,$2,$3,$4,$5,$6,$7,$fine,$mid,$large,$11,$12,$13,$14,$15$15
k[0,-1]
sub
noise_amp={_round((128/(max(abs(im),iM))),0.1)}
mul $noise_amp
add 128
c 0,255

elif $14==2
fine=0
mid=$9
large=0
+iain_denoise_2019_beta3 $1,$2,$3,$4,$5,$6,$7,$fine,$mid,$large,$11,$12,$13,$14,$15
k[0,-1]
sub
noise_amp={_round((128/(max(abs(im),iM))),0.1)}
mul $noise_amp
add 128
c 0,255
elif $14==3
fine=0
mid=0
large=$10
+iain_denoise_2019_beta3 $1,$2,$3,$4,$5,$6,$7,$fine,$mid,$large,$11,$12,$13,$14,$15
k[0,-1]
sub
noise_amp={_round((128/(max(abs(im),iM))),0.1)}
mul $noise_amp
add 128
c 0,255
elif $14==4
iain_denoise_2019_beta3 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15
endif

endl
blend alpha

text_size=13

 if $images==1
 guide="Internal Guide"
 bg_colour=255
 text_colour=0
 else
 guide="External Guide"
 bg_colour=0
 text_colour=255
  endif

 if $14!=4
box_size=100%
else
box_size=100%
endif

rectangle 0,0,$box_size,20,0.5,$bg_colour
text $guide,0.1~,4,$text_size,1,$text_colour
 if $14!=4

 rectangle {(w/2)-127*($noise_amp/2)},{h-20},{(w/2)+127*($noise_amp/2)},100%,0.5,$bg_colour
text Noise\ amplified\ $noise_amp\ times,0.5~,{h-16},$text_size,1,$text_colour

endif

guide_recovery=0
if $12==0
do_recovery=0
elif $12==1
do_recovery=1
slow=0
recover_text="Fast Recovery"
elif $12==2
do_recovery=1
slow=1
recover_text="Slow Recovery"
elif $12==3
do_recovery=1
slow=1
guide_recovery=1
recover_text="Guide Recovery"
endif
 if $12!=0
text $recover_text,0.9~,4,$text_size,1,$text_colour
endif
## if $images==1

 ## if $14<4
 ##
 ## endif
## elif $images==2
## text "external guide",10,10,16,1,0
## endif


# # # # #

iain_denoise_2019_beta3:
images={$!}
if $images>2
quit
endif

gamma=$1
shadow=$2
light=$3
mid_tone_offset={$4/5}
chroma=$5
external_guide_strength=$6
soften_guide=$7
fine=$8
mid={$9/3}
large={$10/9}
patch_size=3
patch_size_b=3
lookup_size={($11*2)+1}
mid_lookup_size=$11
large_lookup_size=$11
smoothness_fine=0
smoothness=0
fast_approx=0
std_deviation_s=10

recover=$13
guide_recovery=0
slow=0
if $12==0
do_recovery=0
elif $12==1
do_recovery=1
elif $12==2
do_recovery=1
slow=1
elif $12==3
do_recovery=1
slow=1
guide_recovery=1
endif


remove_opacity

external_guide=1
if $!==1
[0]
external_guide=0
endif
if $guide_recovery==0

 if $external_guide_strength<1
 [0]
 mul[1] $external_guide_strength
 mul[2] {1-$external_guide_strength}
 add[1,2]
 endif
 l[-1]
 #process guide image
  # adjust chroma to increase chroma denoising.
  # Use faster approximation of Ycbcr.

  if $chroma>0
  redmul=.299
  greenmul=.587
  bluemul=.114
  +split[0] c
  mul[1] $redmul mul[2] $greenmul mul[3] $bluemul
  add[1-3]
  if $chroma==1 # if chroma equals one just keep the lumanance image else desaturate image by scaling the chroma channels
  keep[1]
  else

  split[0] c name[0] red name[1] green name[2] blue name[3] luma

  +sub[blue] [luma] name[-1] cb
  +sub[red] [luma] name[-1] cr
  keep[luma,cb,cr]

  # adjust chroma
  mul[cb,cr] {1-$chroma}

  +add[cb] [luma] name[-1] blueout
  +add[cr] [luma] name[-1] redout

  remove[1,2]

  +mul[redout] $redmul +mul[blueout] $bluemul
  sub[luma] [-1] sub[luma] [-2]
  div[luma] $greenmul
  remove[-1,-2]
  move[2] 0
  append c
  endif
  endif

 # adjust gamma and curves to target different ranges for noise reducation
 sub 127
 div 128
 if $gamma!=1
 add 1
 pow $gamma
 sub 1

 endif
 sub $mid_tone_offset
 +c[0] 0,100
 c[0] -100,0
 l[0]
 if $shadow>0
 fill i+($shadow*abs(i)*0.75)^2
 elif $shadow<0
 fill i-(abs(i)^3)*(abs($shadow))
 endif
 endl
 l[1]
 if $light>0
 div[0] {(2^$gamma)-1}
 fill i-($light*abs(i)*0.75)^2
 mul[0] {(2^$gamma)-1}
 elif $light<0
 div[0] {(2^$gamma)-1}
 fill i+(abs(i)^3)*(abs($light))
 mul[0] {(2^$gamma)-1}
 endif
 endl
 add
  add $mid_tone_offset
 mul 128
 add 127


 if $soften_guide

 l[0]
 (0,0.2,0;0.2,0.2,0.2;0,0.2,0)
 convolve[0] [1]
 rm[1]
 endl
 endif
 endl
 #denoise

 +l[0,1]
 levels=2
 size={3^$levels}
 cropwidth={w}
 cropheight={h}

 to_rgb
 resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

  if $fine>0
  denoise[0] [1],$std_deviation_s,$fine,$patch_size,$lookup_size,$smoothness_fine,$fast_approx
  endif
 +resize[0,1] 33.33333%,33.33333%,{d},{s},2
 rm[1]
 +iain_resize_x3[-2]
 blur[-1] 1
 sub[0,-1]
  if $mid>0
  denoise[1] [2],$std_deviation_s,$mid,$patch_size,$mid_lookup_size,$smoothness_fine,$fast_approx
  endif
  l[1,2]
  +resize[0,1] 33.33333%,33.33333%,{-1,d},{-1,s},2
  rm[1]
  +iain_resize_x3[-2]
  blur[-1] 1
  sub[0,-1]
   if $large>0
   denoise[1] [2],$std_deviation_s,$large,$patch_size,$large_lookup_size,$smoothness_fine,$fast_approx
   endif
  endl
 rm[-1]
 repeat 2
 iain_resize_x3[-1]
 blur[-1] 1
 add[-1,-2]
 done
 crop 0,0,{$cropwidth-1},{$cropheight-1} # crop to original
 c 0,255
 endl
rm[1]
endif

# recover

 if $do_recovery
sub[0] [1]
 ## l[0]
 l[0] split c mul[0] 0.2126 mul[1] 0.7125 mul[2] 0.0722 add endl
 +blur[0] 10
 sub[0] [-1]
 rm[-1]
 +abs[0]
 noise={-1,ia}
 blur[-1] 3
 bilateral[-1] [1],20,$noise
 blur[-1] 2
 fill[-1] 5/i
 mul[0] [-1]
 l[0]
  add 128
  resize[0] {w+256},{h+256},1,1,0,2,0.5,0.5
   if $slow
   iain_tiletest4_stack[0] {2-$recover},0.5
   else
   iain_tiletest4[0] {2-$recover},0.5
   endif
  crop[0] 128,128,{w-129},{h-129}
  sub 128
  +blur 10
  sub
 endl

div[0] [-1]
rm[-1]
to_rgb[0]
add
else
k[-1]
endif
c 0,255

time=$|
name name($time)

iain_resize_x3:
resize[0] {(w*3)-2},{(h*3)-2},{d},{s},5,0
resize[0] {w+2},{h+2},{d},{s},0,1,0.5,0.5

## #@gui iain_tiletest4_stack: iain_tiletest4_stack,iain_tiletest4_stack(0)
## #@gui : threshold = float (1,0,5)
## #@gui : threshold = float (.5,0,5)
iain_tiletest4_stack:
resize {w+128},{h+128},1,1,0,2,0.5,0.5
offset1x=24
offset1y=4
offset2x=-10
offset2y=21
offset3x=27
offset3y=27
offset4x=6
offset4y=38
+shift[0] $offset1x,$offset1y,0,0
+shift[0] $offset2x,$offset2y,0,0
+shift[0] $offset3x,$offset3y,0,0
+shift[0] $offset4x,$offset4y,0,0

iain_tiletest4[0] $1,$2
iain_tiletest4[1] $1,$2
iain_tiletest4[2] $1,$2
iain_tiletest4[3] $1,$2
iain_tiletest4[4] $1,$2
shift[1] {$offset1x*-1},{$offset1y*-1},0,0
shift[2] {$offset2x*-1},{$offset2y*-1},0,0
shift[3] {$offset3x*-1},{$offset3y*-1},0,0
shift[4] {$offset4x*-1},{$offset4y*-1},0,0

blend_median

crop 64,64,{w-65},{h-65}

# #@gui iain_nr_2019: iain_nr_2019,iain_nr_2019(0)

# #@gui : HF recover = float(1,0,2)
# #@gui : MF Smooth = float(2,0,10)
# #@gui : LF Smooth = float(0,0,10)
# #@gui : chroma = float(.3,0,1)
# #@gui : Recovery amount = float(1,0,2)
# #@gui : gamma = float(1.5,0,2)
# iain_nr_2019:
# remove_opacity

# detail_recovery={2-$5}
# gamma=$6
# chroma={1-$4}
# size={3^3}
# cropwidth={w}
# cropheight={h}

# resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

# repeat 3
# l[-1]

 # if $>==0 strength=$1 patch_smooth=1 elif $>==1 strength=$2 patch_smooth=0 elif $>==2 strength=$3 patch_smooth=0 endif
 # patch_smooth=0
# ## +guided[0] [1],3,{$strength^1.5}
# ## +bilateral[0] [1],3,$strength
# if $>==0
# +median[0] 5
# else
# ## +denoise[0] 10,$strength,3,7,$patch_smooth,1
 # +l[0]
 # blur 0.5
 # rgb2lab
 # split c
 # mul[1,2] $chroma
 # append c
 # lab2rgb
 # apply_gamma {1/$gamma}
 # endl
# +bilateral[0] [-1],3,$strength
# rm[-2]
# ## ## k[0,-1]
# endif
# sub[0] [1]
# ## if $5>0
 # l[0]
# l[0]  split c mul[0] 0.2126 mul[1] 0.7125 mul[2] 0.0722 add endl
 # +abs[-1]
  # blur[-1] 5
 # max[-1] 0.00001
 # fill[-1] 5/i
 # mul[0] [-1]
  # l[0]
   # add 128
   # resize[0] {w+256},{h+256},1,1,0,2,0.5,0.5
   # if $>==0
# iain_tiletest4[0] {2-$1},0.5
# else
   # iain_tiletest4[0] $detail_recovery,0.5
   # endif
   # crop[0] 128,128,{w-129},{h-129}
   # sub 128
   # +blur 10
   # sub
  # endl
 # div[0] [-1]
 # rm[-1]

# endl
# ## to_rgb
# reverse
 # add
 # ## else k[-1]
 # ## endif


# l[-1]
# +resize[0] 33.33333%,33.33333%,{d},{s},2

# +l[-1]
# resize[0] {(w*3)-2},{(h*3)-2},{d},{s},5,0
# resize[0] {w+2},{h+2},{d},{s},0,1,0.5,0.5
# endl
# blur[-1] 1
# sub[0,-1]
# endl
# endl
# done

# repeat $!-1

# l[-1]
# resize[0] {(w*3)-2},{(h*3)-2},{d},{s},5,0
# resize[0] {w+2},{h+2},{d},{s},0,1,0.5,0.5
# endl
# blur[-1] 1
# add[-1,-2]
# done
# c 0,255
 # crop 0,0,{$cropwidth-1},{$cropheight-1} # crop to original
# ## apply_gamma $gamma

 # time=$|
# name. name($time)

iain_tiletest4:
remove_opacity
luminance

cropwidth={w}
cropheight={h}

size={64}
resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1
tilew={w/64}
tileh={h/64}
split_tiles $tilew,$tileh
apply_parallel "
fftpolar
append z
k[0]
"
+blend_median

mul[-1] $1
## circle[-1] 50%,50%,1,1,1
repeat $!-1
l[$>,-1]

split z
+circle[0] 50%,50%,1,1,0
blur[-1] 1
mul[-1] {$1*$2}
lt[-1] [2]
circle[-1] 50%,50%,1,1,0
mul[-1] [2]
sub[0] [-1]
c[0] 0,999999999999999
k[0,1,2,3]
append[0,1] z
append[1,2] z
endl
done
rm[-1]
apply_parallel "
split z
ifftpolar
"
append_tiles $tilew,$tileh
c 0,255
crop 0,0,{$cropwidth-1},{$cropheight-1}


#@gui PNG Processing: iain_png_processing,iain_png_processing(0)
#@gui : Number of Colours = int (4,2,256)
#@gui : Refine Palette = bool(0)
#@gui : Dither Pattern = choice(0,"Lines","Checkerboard","Diffusion","None")
#@gui : sep = separator ()
#@gui : Pre Smooth = bool(0)
#@gui : Smooth Radius = float(3,0,20)
#@gui : Smooth Amount = float(3,0,20)
#@gui : sep = separator ()
#@gui : Pre-Sharpen (Constrained) = bool(0)
#@gui : Sharpen Radius = float(.75,0,10)
#@gui : Amount = float(2,0,10)
#@gui : Threshold = float(1,0,50)
#@gui : Constraint Radius = int(5,0,10)
#@gui : Overshoot = float(0,0,50)
#@gui : sep = separator ()
#@gui : Post Median = bool(0)
#@gui : Median Radius = int (1,1,10)
#@gui : Median Repeats = int (1,1,5)
#@gui : sep = separator ()
#@gui : note = note("This filter provides tools to improve the compressabilty or visual quality when creating an indexed image.)
#@gui : note = note("Author : <i>Iain Fergusson</i>. release: 9 September 2018 )

iain_png_processing:
repeat $! l[$>]
nm=${-gui_layer_name}
dither_pattern=$3
do_smooth=$4
smooth_radius=$5
smooth_amount=$6
do_sharp=$7
sharp_radius=$8
sharp_amount=$9
sharp_threshold=$10
constrant_radius=$11
overshoot=$12
do_median=$13
median_radius=$14
median_repeat=$15
remove_opacity
if $do_smooth
bilateral[0] $smooth_radius,$smooth_amount
endif

if $do_sharp
iain_constrained_sharpen[0] $sharp_radius,$sharp_amount,$sharp_threshold,$constrant_radius,$overshoot,0,1
endif
+colormap $1,$2,1
if $dither_pattern==2
+index[0] [1],1,0
elif $dither_pattern!=2
+index[0] [1],0,0
endif
+map[-1] [-2]

 if $dither_pattern<=1
 +sub[0] [-1]
 abs[-1]
 +add[0] [4]
 +sub[0] [4]
 index[-1] [1],0,0
 index[-2] [1],0,0
  l[-1,-2]
   if $dither_pattern==1
   (0,255;255,0)
   elif $dither_pattern==0
   (0;255)
   endif
  resize_as_image[-1] [0],0,2
  channels[-1] 0
  append[-1,-2] c
  blend alpha
  endl
  if $do_median
   repeat $median_repeat
   l[-1]
    repeat ($median_radius*2)+1
    amount={$>-$median_radius}
     if $amount!=0
     +shift[0] $amount,0,0,0,0
     endif
     done
   blend_median
  endl

   done
  endif
 +map[-1] [1]
 k[-1]
 ## rm[1]
 else
 rm[-1]
 if $do_median
  repeat $median_repeat
  horiz_median[-1] $median_radius
  done
 endif
  +map[-1] [1]
 k[-1]
 endif

nm name($nm)
endl done

#@gui Detect Moire: iain_detect_moire,iain_detect_moire_preview(0)
#@gui : Threshold = float(50,0,100)
#@gui : Mask Size = float(5,0,100)
#@gui : Expand/Contract = int (9,-50,50)
#@gui : sep = separator ()
#@gui : Preview Saturation = float (30,0,100)
#@gui : sep = separator ()
#@gui : note = note("Detect Moire on bayer patterns. Requires RGB bayer image as input. Output is a black and white mask.")
#@gui : note = note("Preview shows mask boundary on top of a fast demosaic that will show more moire than a good demosaicing algorithm.")
iain_detect_moire_preview:
+moire_2018_2[0] $1,$2,$3
laplacian[-1]
abs[-1]
l[0]
split c

l[1]
(0,1)
resize[-1] [0],0,2
+mul[0] [1]
eq[1] 0
+mul[0] [1]
k[2,3]

endl

(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
convolve[0,1,2,3] [-1]
rm[-1]

add[1,2]
mul[1] 0.5

append c

adjust_colors 0,0,0,0,$4,0,255
endl
remove_opacity
## n 0,255
add
c 0,255

iain_detect_moire:

skip $1,$2,$3

channels 1

+l[0] # detect diagonal HF

(1,0,1;0,-4,0;1,0,1)
convolve[0] [1]
rm[1]
abs
endl

+l[0] # detect Horizontal HF

(1,0,-2,0,1)
convolve[0] [1]
rm[1]
abs
endl
+l[0] # detect vertical HF

(1;0;-2;0;1)
convolve[0] [1]
rm[1]
abs
endl
add[-1,-2] # add H and V HF
rm[0]
sub[0] [1]
k[0]

c 0,255
l[0]  # pixel denoise
+l[0]
(1,0,1;1,0,1;1,0,1)
dilate[0] [1]
rm[1]
endl
+l[0]
(1,0,1;1,0,1;1,0,1)
erode[0] [1]
rm[1]
endl
min[0,1]
max[0,1]
endl

mul 10
c 0,255

# remove false HF detail at edges
thickness=5
linethick 0%,0%,100%,0%,$thickness,1,0
linethick 0%,0%,0%,100%,$thickness,1,0
linethick 100%,0%,100%,100%,$thickness,1,0
linethick 0%,100%,100%,100%,$thickness,1,0

blur $2
gt $1
mul 255

if $3>0
dilate $3
endif

if $3<0
erode {$3*-1}
endif

#@gui Iain Remove Pattern: iain_remove_pattern,iain_remove_pattern_preview(0)
#@gui : note = note("<b>Smooth<b>")
#@gui : Pre-Blur = float (3,1,50)
#@gui : Smoothness = float (3,1,14)
#@gui : Radius = float (3,1,40)
#@gui : sep = separator ()
#@gui : note = note("<b>Recover detials<b>")
#@gui : Recover Details  = bool(0)
#@gui : Recovery Amount = float (4,0,10)
#@gui : Tile Size = int(128,16,512)
#@gui : Quality = choice(1,"1","3","5","super slow")
#@gui : sep = separator ()
#@gui : Preview = choice(0,"output","FFT of input","FFT of output","FFT difference")
#@gui : sep = separator ()
#@gui : note = note("This filter remove patterns by eliminating peaks in frequency domain while protecting edges.")

#@gui : note = note("Stage 1 Pre-blur: Create a guide image that has the pattern blured out")
#@gui : note = note("Stage 2 Smooth: Use guide image to do edge-protected smoothing. Make sure pattern is removed before trying to recover detials.")
#@gui : note = note("Stage 3 Detials: Recover detials by keeping non-peaks the the frequency domain.")

iain_remove_pattern:
remove_opacity
+l
+blur[0] $1
guided[0] [1],$2,$3
k[0]
endl
if $4
sub[0] [1]
add[0] 128

iain_remove_pattern_tiles_stack[0] $5,$5,$6,1,$7
sub[0] 128
to_rgb
add
else
k[-1]
endif
c 0,255

iain_remove_pattern_preview:

if $8==0
iain_remove_pattern[0] $1,$2,$3,$4,$5,$6,$7
elif $8==1
to_rgb display_fft
elif $8==2
iain_remove_pattern[0] $1,$2,$3,$4,$5,$6,$7
to_rgb display_fft
elif $8==3
+iain_remove_pattern[0] $1,$2,$3,$4,$5,$6,$7
sub
to_rgb display_fft
endif
iain_remove_pattern_tiles_stack:
offset={round($3/3)}
remove_opacity
luminance
+l

if $5>0

+shift[0] $offset,$offset,0,0
iain_remove_pattern_tiles[-1] $1,$2,$3
shift[-1] {$offset*-1},{$offset*-1},0,0,1

+shift[0] {$offset*-1},{$offset*-1},0,0
iain_remove_pattern_tiles[-1] $1,$2,$3
shift[-1] $offset,$offset,0,0,1
endif
if $5>1
+shift[0] $offset,0,0,0
iain_remove_pattern_tiles[-1] $1,$2,$3
shift[-1] {$offset*-1},0,0,0,1

+shift[0] 0,$offset,0,0
iain_remove_pattern_tiles[-1] $1,$2,$3
shift[-1] 0,{$offset*-1},0,0,1
endif
if $5>2
+shift[0] {$offset*-1},0,0,0
iain_remove_pattern_tiles[-1] $1,$2,$3
shift[-1] $offset,0,0,0,1

+shift[0] 0,{$offset*-1},0,0
iain_remove_pattern_tiles[-1] $1,$2,$3
shift[-1] 0,$offset,0,0,1
endif

iain_remove_pattern_tiles[0] $1,$2,$3

blend_median
endl

if $4
sub
add 128
else
k[1]
endif
iain_remove_pattern_tiles:

l[0]
size=$3
offset={$size/3}
    cropwidth1={w}
    cropheight1={h}
    resize[0] {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,0
    tc={round(w/$size)} tr={round(h/$size)}

    split_tiles $tc,$tr
    apply_parallel "iain_remove_pattern_fft $1,$2,$3"

append_tiles $tc,$tr
crop 0,0,{$cropwidth1-1},{$cropheight1-1}
endl
iain_remove_pattern_fft:
luminance

fftpolar
+log[0]
blur[-1] 10
exp[-1]
+l[-1]
fill[0] $1
circle[-1] 50%,50%,14%,1,$2

endl
mul[-2,-1]
+lt[-1] [0]

circle[-1] 50%,50%,{w*.005},1,1
mul[0] [-1]
k[0,1]
ifftpolar

c 0,255


#@gui IID Demosaic: iain_iid_demosaic,iain_iid_demosaic(0)
#@gui : 1 Starting Pattern = choice(1,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : 2 Clamp Radius = int (1,1,3)
#@gui : 3 Refinement Steps = int(1,0,10)
#@gui : 4 Reduce Moire = bool(0)
#@gui : sep = separator()
#@gui : 5 Use Gamma Adjustment = bool(0)
#@gui : sep = separator()
#@gui : note = note("IID is a demosaicing algorithm that produces good colour detail and works well in the presence of chromatic aberrations. It attempts to reduce moire patterns. Noise tends to render as a maze like texture.")
#@gui : sep = separator()
#@gui : note = note("<b>Clamp Radius:</b> Interploated green pixels are clamped to local values. A clamp radius of 1 reduces ringing and overshoots but may limit some detials. A clamp radius of 3 will give more detials but also more ringing and overshoots. Not much difference can been seen unless you zoom in.")
#@gui : note = note("<b>Refinement Steps:</b> Uses the initital demosaic as a guide for a new partial demosaic, and can be repeated. Each step gives better luma details and noise rendering but degrades chroma edges. Use a low value of clamp radius to reduce arefacts but also the effectiveness. Two or three refinements steps is probably the sweet spot.")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. 25 March 2017 - First release</small>")
iain_iid_demosaic:
pattern=$1

chroma_diff=1.5
chroma_radius=5
clamp_radius1=$2

repeat $! l[$>]
if $5 apply_gamma 2 endif
+l
l
to_rgb
# make two full colour versions using vertical and horizontal interpolation
+iain_iid_demosaic_vertical[0] $pattern,$clamp_radius1
iain_iid_demosaic_horizontal[0] $pattern,$clamp_radius1
# compare versions

 +l

  # look for zippers
  +l[0]
  (1,-1)
  convolve[0] [1]
  k[0]
  abs
  blur 1
  split c
  add
  endl
  +l[1]
  (1;-1)
  convolve[0] [1]
  k[0]
  abs
  blur 1
  split c
  add
  endl

 sub[-1,-2]

  # look for chroma variation
  +l[0]
  +split c
  add[-1,-2,-3]
  mul[-1] {1/3}
  sub
  +blur $chroma_radius
  sub
  abs
  blur 1
  split c
  add
  endl
  +l[1]
  +split c
  add[-1,-2,-3]
  mul[-1] {1/3}
  sub
  +blur $chroma_radius
  sub
  abs
  blur 1
  split c
  add
  endl

 sub[-1,-2]

 mul[-1] $chroma_diff  # weight for chroma variations

 add[-1,-2] # add zippers weights to chroma weights

 gt[-1] 0 # make mask for one direction

 # mask edges to force interpolation direction along edges

 line[-1] 0,0,100%,0%,1,0
 line[-1] 0,100%,100%,100%,1,0

 line[-1] 0,0,0%,100%,1,1
 line[-1] 100%,0%,100%,100%,1,1

 +eq[-1] 0 # make inverse mask for other direction
 # combine masked images
 mul[0,-1]
 mul[1,-1]
 max
 endl

## k[-1]
endl
endl

l[0,-1]
if $3>0
iain_luma_guided_demosaic $1,$3,$2
else
k[1]
endif
endl
if $4
l[-1,-2]
 l[0]
 rgb2yuv
 split c
 fill[0] 0.5
 append c
 yuv2rgb
 endl
 l[1]
 rgb2yuv
 split c
 fill[0] 0.5
 append c
 yuv2rgb
 endl
iain_min_fft3_1 128
endl

rgb2yuv
split c

k[0,-1,-2]
append c
yuv2rgb
else
k[0]
endif

if $5 apply_gamma 0.5 endif
endl done


iain_min_fft3_1:


+l[0,1]
append z
size=$1
cropwidth={w}
cropheight={h}
resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,0
h_tile={h/$1}
v_tile={w/$1}
split_tiles $v_tile,$h_tile

apply_parallel "
 l[0]
 split z
 rgb2yuv
 fftpolar
 min[0,2]
 min[1,2]
 ifftpolar
 yuv2rgb
endl
"

append_tiles $v_tile,$h_tile
crop 0,0,{$cropwidth-1},{$cropheight-1}
c 0,255
endl
k[-1]
iain_iid_demosaic_vertical:
resize {w+8},{h+8},{d},{s},0,0,0.5,0.5
 +l
 rgb2bayer $1,1
  +l[0]
  to_rgb
  channels 1
  (-0.1;0;0.6;1;0.6;0;-0.1)
  convolve[0] [1]
  remove[-1]
  endl

  +iain_demosaic_clamp[0] $2
  rm[2]
  min[1,2]
  max[1,2]

 +to_rgb[1]
  rgb2bayer[-1] $1,1

  split[0] c
  split[-1] c
  sub[0] [4]
  sub[2] [6]

  append[0,1,2] c
  add[0] 128
  rgb2bayer[0] $1,1
  split[0] c

  k[0,2,3]
  reverse[1,2]

  +l[0,1]
  reverse
  iain_guided_fillgrid
  endl
  +l[1,2]

  iain_guided_fillgrid
  endl
 rm[0,2]

 reverse[0,1]
 sub[0,2] 128
  add[0] [1]
  add[2] [1]
  append c
  c 0,255
 endl

k[1]
crop 4,4,{w-5},{h-5}

iain_iid_demosaic_horizontal:
resize {w+8},{h+8},{d},{s},0,0,0.5,0.5 # add borders to limit errors at edges
 +l
 rgb2bayer $1,1
  +l[0] # interpolate green
  to_rgb
  channels 1
  (-0.1,0,0.6,1,0.6,0,-0.1)
  convolve[0] [1]
  remove[-1]
  endl

  +iain_demosaic_clamp[0] $2 # limit new green vlaues to local green minima and maxima
  rm[2]
  min[1,2]
  max[1,2]

  # create green-red and green-blue for colour interpolation

 +to_rgb[1]
  rgb2bayer[-1] $1,1

  split[0] c
  split[-1] c
  sub[0] [4]
  sub[2] [6]

  append[0,1,2] c
  add[0] 128
  rgb2bayer[0] $1,1
  split[0] c

  k[0,2,3]
  reverse[1,2]

  +l[0,1] # interpolate colour differences using green channel as directional guide
  reverse
  iain_guided_fillgrid
  endl
  +l[1,2]

  iain_guided_fillgrid
  endl
 rm[0,2]

 reverse[0,1]
 sub[0,2] 128
  add[0] [1]
  add[2] [1]
  append c
  c 0,255
 endl

k[1]
crop 4,4,{w-5},{h-5}


iain_demosaic_clamp:
channels 1
+l
if $1>2
+shift[0] 3,-2,0,0
+shift[0] -3,-2,0,0
+shift[0] -2,3,0,0
+shift[0] -2,-3,0,0

+shift[0] 3,0,0,0
+shift[0] -3,0,0,0
+shift[0] 0,3,0,0
+shift[0] 0,-3,0,0
endif

if $1>1
+shift[0] 1,2,0,0
+shift[0] -1,2,0,0
+shift[0] 2,1,0,0
+shift[0] 2,-1,0,0

+shift[0] 1,-2,0,0
+shift[0] -1,-2,0,0
+shift[0] -2,1,0,0
+shift[0] -2,-1,0,0
endif

+shift[0] 1,0,0,0
+shift[0] -1,0,0,0
+shift[0] 0,1,0,0
shift[0] 0,-1,0,0
+min[0--1]
max[0--2]
endl
add[1] [0]
add[2] [0]

iain_luma_guided_demosaic:
resize {w+8},{h+8},{d},{s},0,0,0.5,0.5 # add borders to limit errors at edges
remove_opacity
repeat $2
+l

+split[1] c
add[-1,-2,-3]
mul[-1] .33333333333333333

rm[1]

sub[0] [1]

add[0] 255
rgb2bayer[0] $1,1
reverse

split[1] c
+iain_guided_diagonal_interpolation[0,1]
+iain_guided_diagonal_interpolation[0,3]
rm[1,3]
reverse[1,2]
+iain_guided_straight_interpolation[0,1]
+iain_guided_straight_interpolation[0,2]
+iain_guided_straight_interpolation[0,3]
rm[1,2,3]
sub[1,2,3] 255
append[1,2,3] c
to_rgb
add
c 0,255
endl
rm[1]
if $3>0
## split[1] c

## +iain_demosaic_clamp[0] $3
## rm[4]
## min[2] [4] max[2] [5]
## rm[-1,-2]
## append[1,2,3] c
endif
done
k[1]
crop 4,4,{w-5},{h-5}
#@gui Minimum Chroma Demosaic : iain_minimum_chroma_demosaic,iain_minimum_chroma_demosaic(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : Moire Size  = choice (2,"Small","Medium","Large","Extra Large")
#@gui : Details = choice(0,"Less detial but better colour edges","More detial but degraded colour edges")
iain_minimum_chroma_demosaic:
rgb2bayer $1,1
 cropwidth={w}
 cropheight={h}
 resize {w+16},{h+16},{d},{s},0,0,0.5,0.5
+l

if $3==0
+iain_horizontal_interpolate[0] $1,1
iain_vertical_interpolate[0] $1,1
elif $3==1
+iain_tuned_horizontal[0] $1
iain_tuned_vertical[0] $1
endif

l[0]
rgb2yuv
split c
fill[0] .5
append c
yuv2rgb
endl
l[1]
rgb2yuv
split c
fill[0] .5
append c
yuv2rgb
endl
append z

levels={$2+1}
size={3^$levels}

cropwidth2={w}
cropheight2={h}
resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

repeat $levels # number of pyramid levels.
l[-1]
+resize[0] 33.33333%,33.33333%,{d},{s},2
+iain_resize_x3[-1]
sub[0,-1]
endl
done

repeat $!-1 l[{$<}]

split z
+abs

gt[-1] [-2]
rm[-2]
+eq[-1] 0
mul[0,2]
mul[1,2]
add
endl done


l[-1]
split z
k[1]
endl

repeat $!-1

iain_resize_x3[-1]

add[-1,-2]
done
 crop 0,0,{$cropwidth2-1},{$cropheight2-1}
c 0,255
endl

iain_chroma_guide $1,1

crop 8,8,{$cropwidth+7},{$cropheight+7}

iain_chroma_guide:

to_rgb

rgb2bayer[0] $1,1

  +l[0,1]

   split[-1] c
   split[0] c
   name[0] red name[1] green name[2] blue
   name[-3] redblur name[-2] greenblur name[-1] blueblur
   +sub[greenblur] [redblur]
  +sub[greenblur] [blueblur]

  name[-1] bluemul name[-2] redmul
  remove[redblur,greenblur,blueblur]
  add[red] [redmul]
  add[blue] [bluemul]
  keep[red,green,blue]
  append c
  rgb2bayer $1,1
  split c

  add

  endl
rm[1]
+to_rgb[1]
 rgb2bayer[-1] $1,1

 split[0] c
 split[-1] c
 sub[0] [4]
 sub[2] [6]
 append[0,1,2] c
 add[0] 128
 rgb2bayer[0] $1,1
 split[0] c

 rm[1,-1,-2,-3]

 +l[0,2]
 reverse
 iain_guided_fillgrid
 endl
 rm[0]
 +l[0,1]
 reverse
 iain_guided_fillgrid
 endl
 rm[0]
 reverse[0,1]
 sub[0,2] 128
 add[0] [1]
 add[2] [1]
  append c
c 0,255


iain_resize_x3:
resize[0] {(w*3)-2},{(h*3)-2},{d},{s},5,0
resize[0] {w+2},{h+2},{d},{s},0,1,0.5,0.5

iain_vertical_interpolate:

rgb2bayer[0] $1,1
+l[0]
channels 1
(-0.1;0;0.6;1;0.6;0;-0.1)
convolve[0] [-1]
rm[-1]
endl

c 0,255
+to_rgb[1]
 rgb2bayer[-1] $1,1

 split[0] c
 split[-1] c
 sub[0] [4]
 sub[2] [6]
 append[0,1,2] c
 add[0] 128
 rgb2bayer[0] $1,1
 split[0] c

 rm[1,-1,-2,-3]

 +l[0,2]
 reverse
 iain_guided_fillgrid
 endl
 rm[0]
 +l[0,1]
 reverse
 iain_guided_fillgrid
 endl
 rm[0]
 reverse[0,1]
 sub[0,2] 128
 add[0] [1]
 add[2] [1]
  append c
c 0,255

iain_horizontal_interpolate:

rgb2bayer[0] $1,1
+l[0]
channels 1
(-0.1,0,0.6,1,0.6,0,-0.1)
convolve[0] [-1]
rm[-1]
endl

c 0,255
+to_rgb[1]
 rgb2bayer[-1] $1,1

 split[0] c
 split[-1] c
 sub[0] [4]
 sub[2] [6]
 append[0,1,2] c
 add[0] 128
 rgb2bayer[0] $1,1
 split[0] c

 rm[1,-1,-2,-3]

 +l[0,2]
 reverse
 iain_guided_fillgrid
 endl
 rm[0]
 +l[0,1]
 reverse
 iain_guided_fillgrid
 endl
 rm[0]
 reverse[0,1]
 sub[0,2] 128
 add[0] [1]
 add[2] [1]
  append c
c 0,255
iain_guided_fillgrid:
channels 0
# [0] guide [1] grid

l[0] ## find  orientation

  (1,0;0,-1)
  +convolve[0] [1]
  rm[1]
  (0,1;-1,0)
  +convolve[0] [2]
  rm[2]
  l[-1,-2]
  abs
  blur 1
   +max
   eq[0] [-1]
   keep[0]
   mul 255
  endl
 endl

+l[2]
+l[0]
 (0,0,0.5;0,1,0;0.5,0,0)
 convolve[0] [1]
 remove[1]
 endl
 l[0]
 (0.5,0,0;0,1,0;0,0,0.5)
 convolve[0] [1]
 remove[1]
 endl
endl

move[1] 5
append[-1,-2] c
blend[-1,-2] alpha,1,0

rm[1]
l[0] ## find  orientation

  (1,-1)
  +convolve[0] [1]
  rm[1]
  (1;-1)
  +convolve[0] [2]
  rm[2]
  l[-1,-2]
  abs
  blur 1
   +max
   eq[0] [-1]
   keep[0]
   mul 255
  endl
 endl
+l[2]
+l[0]
 (0.5;1;0.5)
 convolve[0] [1]
 remove[1]
 endl
 l[0]
 (0.5,1,0.5)
 convolve[0] [1]
 remove[1]
 endl
endl

move[1] 5
append[-1,-2] c
blend[-1,-2] alpha,1,0
k[-1]
iain_tuned_horizontal:
remove_opacity
l[0]
+fill[0] 1
rgb2bayer[1] $1,1
+l[0]
split c
add
## (-0.25,0.5,0.5,0.5,-0.25)

(-0.025,0.1,-0.225,0.4,0.5,0.4,-0.225,0.1,-0.025)
## (-0.05,0.2,-0.20,0.3,0.5,0.3,-0.20,0.2,-0.05)
convolve[0] [1]
rm[1]
endl

+l[1,2]
shift[0] 1,0,0,0,2
mul
endl
add[-1] [0]
channels[-1] 1

k[0,-1]
to_rgb
iain_luma_guide $1,1,0
endl

iain_tuned_vertical:
remove_opacity
l[0]
+fill[0] 1
rgb2bayer[1] $1,1
+l[0]
split c
add
## (-0.25,0.5,0.5,0.5,-0.25)

(-0.025;0.1;-0.225;0.4;0.5;0.4;-0.225;0.1;-0.025)
## (-0.05,0.2,-0.20,0.3,0.5,0.3,-0.20,0.2,-0.05)
convolve[0] [1]
rm[1]
endl

+l[1,2]
shift[0] 1,0,0,0,2
mul
endl
add[-1] [0]
channels[-1] 1

k[0,-1]
to_rgb
iain_luma_guide $1,1,0
endl
iain_luma_guide:
remove_opacity
if $3
mul {1/255}
pow 2.2
mul 255
endif
repeat $2
+l

+split[1] c
add[-1,-2,-3]
mul[-1] .33333333333333333

rm[1]

sub[0] [1]

add[0] 255
rgb2bayer[0] $1,1
reverse

split[1] c
+iain_guided_diagonal_interpolation[0,1]
+iain_guided_diagonal_interpolation[0,3]
rm[1,3]
reverse[1,2]
+iain_guided_straight_interpolation[0,1]
+iain_guided_straight_interpolation[0,2]
+iain_guided_straight_interpolation[0,3]
rm[1,2,3]
sub[1,2,3] 255
append[1,2,3] c
to_rgb
add
c 0,255
endl
rm[1]
done
keep[1]
if $3
mul {1/255}
pow {1/2.2}
mul 255
endif
iain_guided_diagonal_interpolation:
+l[0] ## find green orientation

  (1,0;0,-1)
  +convolve[0] [1]
  rm[1]
  (0,1;-1,0)
  +convolve[0] [2]
  rm[2]
  l[-1,-2]
  abs
  blur 1.5
   +min
   eq[0] [-1]
   keep[0]

  endl
  rm[-2]
endl
 l[1]
 +l[0]
 (0,0,0.5;0,1,0;0.5,0,0)
 convolve[0] [1]
 remove[1]
 endl
 l[0]
 (0.5,0,0;0,1,0;0,0,0.5)
 convolve[0] [1]
 remove[1]
 endl
endl
rm[0]

+eq[-1] 0
mul[0,2]
mul[1,2]
add

iain_guided_straight_interpolation :
+l[0] ## find green orientation

  (1,-1)
  +convolve[0] [1]
  rm[1]
  (1;-1)
  +convolve[0] [2]
  rm[2]
  l[-1,-2]
  abs
  blur 1.5
   +min
   eq[0] [-1]
   keep[0]

  endl
  rm[-2]
  endl
l[1]
+l[0]
 (0.5;1;0.5)
 convolve[0] [1]
 remove[1]
 endl
 l[0]
 (0.5,1,0.5)
 convolve[0] [1]
 remove[1]
 endl

endl
 +eq[-1] 0
mul[1,3]
mul[2,3]
add[1,2]
keep[1]

#@gui MS NL-Means C Noise2: ms_nlmeans_c_noise2_p,ms_nlmeans_c_noise2_p_preview(0)
#@gui : note = note("<b>Noise Reduction</b>")
#@gui : 1 Fine = float(3,0,10)
#@gui : 2 Coarse = float(1,0,10)
#@gui : 3 Blacks = float (0,-10,10)
#@gui : 4 Shadows = float (0,-10,10)
#@gui : 5 Midtones = float (0,-10,10)
#@gui : 6 Highlights = float (0,-10,10)
#@gui : 7 Whites = float (0,-10,10)
#@gui : 8 Smooth Curve = float (10,0,50)
#@gui : sep = separator ()
#@gui : note = note("<b>Advanced settings</b>")
#@gui : 9 Patch Size = float(2,1,10)
#@gui : 10 Search Radius = int(4,1,10)
#@gui : 11 Patch Size = float(2,1,10)
#@gui : 12 Search Radius = int(7,1,10)
#@gui : sep = separator ()
#@gui : note = note("Side chain Processing")
#@gui : 13 Red/Blue Median = bool(0)
#@gui : 14 Green Despeckle = bool(0)
#@gui : sep = separator ()
#@gui : 15 Use Noise Estimate = bool(0)
#@gui : sep = separator ()
#@gui : 16 Show Info = bool(0)
ms_nlmeans_c_noise2_p_preview:
if $16

remove_opacity
## +l
+ms_nlmeans_c_noise2[0] ${1--1}
sub
mul 2
add 128
c 0,255
## endl
## luminance[0]
## blur[0] 2
## l[0]
## 255,1,1,1,1

## line[-1] 0,0,50,0,1,.8
## line[-1] 51,0,100,0,1,.9
## line[-1] 101,0,152,0,1,1
## line[-1] 153,0,204,0,1,1.1
## line[-1] 205,0,255,0,1,1.2
## map[0] [1]
## rm[1]
## endl
## mul[0,1]

else
ms_nlmeans_c_noise2[0] ${1--1}
endif

ms_nlmeans_c_noise2_p:
ms_nlmeans_c_noise2[0] ${1--1}

## apply_parallel_overlap " ms_nlmeans_c_noise2[0] ${1--1} ",32,0
## time=$|
## text $time,3,3,50,1,0
## text $time,1,1,50,1,255

ms_nlmeans_c_noise2:
remove_opacity
hf_strength={2^$1}
lf_strength={2^$2}
hf_patch=$9
hf_search=$10
lf_patch=$11
lf_search=$12
sc_rb=$13
sc_g=$14

blacks={2^$3}
shadows={2^$4}
midtones={2^$5}
highlights={2^$6}
whites={2^$7}
smooth=$8

shadow={2^$3}
highlight={2^$4}

levels=1
 size={3^$levels}
 cropwidth={w}
 cropheight={h}
 resize {w+($size-w%$size)},{h+($size-h%$size)},{d},{s},0,1

+l[0]

split c
if $sc_rb
median[0,2] 4
endif
if $sc_g
l[1]
+l[0]
(1,1,1;1,0,1;1,1,1)
dilate[0] [1]
rm[1]
endl
+l[0]
(1,1,1;1,0,1;1,1,1)
erode[0] [1]
rm[1]
endl
min[0,1]
max[0,1]
endl
endif
append c
## max
## add
## mul .333333333

luminance

endl
if $11
+c_noise[0] 1.6
else
[1]
## luminance[-1]
to_rgb[-1]
negate[-1]
add[-1] .1
mul[-1] .1
## iain_pixel_denoise[-1] 3,1,0
blur[-1] 2
endif
+l[1]
255,1,1,1,1

line[-1] 0,0,50,0,1,$blacks
line[-1] 51,0,100,0,1,$shadows
line[-1] 101,0,152,0,1,$midtones
line[-1] 153,0,204,0,1,$highlights
line[-1] 205,0,255,0,1,$whites
blur[-1] $smooth
map[0] [1]
keep[0]

endl
## +apply_curve[1] 0,0,$shadow,10,$shadow,117,1,137,1,245,$highlight,255,$highlight

mul[2,-1]

+l[0,1,2]
mul[-1] $hf_strength

f[-1] '-3.0/i' nlmeans_core[0] [1],[2],$hf_patch,$hf_search
keep[0]
endl

reverse[0,-1]
rm[-1]
+l[0,1,2]
resize[0,1,2] 33.33333%,33.33333%,{d},{s},2
mul[-1] $lf_strength

f[-1] '-3.0/i' nlmeans_core[0] [1],[2],$lf_patch,$lf_search
keep[0]
endl
rm[1,2]
+resize[0] 33.33333%,33.33333%,{d},{s},2
linear_x3[-1]
sub[0,-1]
linear_x3[-1]
add
c 0,255
## ## rebuild
 ## repeat $!-1
  ## linear_x3[-1]
  ## blur[-1] 1
  ## add[-1,-2]
 ## done
crop 0,0,{$cropwidth-1},{$cropheight-1} # crop to original image dimensions
c 0,255

c_noise:
width={w}
height={h}
+l[0]
+shift[0] 0,1,0,0,2
+shift[0] 0,-1,0,0,2
## +shift[0] 0,2,0,0,2
## +shift[0] 0,-2,0,0,2
blend_median
endl
sub
abs
add .1
pow $1
resize 25%,25%,1,3,2
median 3

resize $width,$height,1,3,3

#@gui Iain Star Burst: iain_star_burst,iain_star_burst(0)
#@gui : Threshold = int (254,0,255)
#@gui : Radius = float (50,1,255)
#@gui : Intensity = float (5,0,10)
#@gui : Rotate = int (45,0,90)
#@gui : Lines = int (2,1,10)
#@gui : Colour Modify = bool(0)
#@gui : Output Stars Only = bool(0)
iain_star_burst:
repeat $! l[$>] split_opacity l[0]
width={w}
height={h}
resize {w+($2*2)},{h+($2*2)},1,3,0,0,0.5,0.5
+gt[0] $1
mul[1] 255

skeleton[1] 0
if $6
rgb2hsl
split c
[0]
reverse[3,-1]
rm[-1]
append[0,1,2] c
append[1,2,3] c
hsl2rgb
endif
## n 0,255
mul[1] 255
l[1]
{$2*5},{$2*5},1,1,0
set[-1] 1,50%,50%
 l[-1]
  repeat $5
  +blur_linear[0] $2,.5,{$4+((180/$5)*($>+1))}
  done
 rm[0]
 add
 endl
 convolve_fft[0] [1]
endl
mul[1] {1/$5}
## apply_curve[1] 1,0,0,64,32,128,96,255,255
mul[1] {$3*10}
if $7
keep[1]
else
max
endif
c 0,255
crop {$2},{$2},{$width+$2-1},{$height+$2-1}
endl a c endl done
#@gui Fast Median Stack : iain_fast_median_stack, iain_fast_median_stack
#@gui : note = note{"This filter gives the median value of the input images at each pixel location and therefore a single input image will have no change. Two input images will be averaged."}
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update 16 December 2014 - filter now accepts any number of images. ")
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>. Update 8 March 2013 - Combined <i>median_3_stack</i> and <i>median_5_stack</i> into this filter, added <i>median_4_stack</i> and added auto-select based on number of input images.</small> ")
iain_fast_median_stack:
if $!>2
 if $!%2!=0
  repeat $!/2
   repeat $!-1
    l[$>,{$>+1}]
    +max[0,1]
    min[0,1]
    endl
   done
  progress {($>/$!)*200}
  done
 keep[{round(($!/2)-.5)}]
 else
  repeat ($!/2)+1
   repeat $!-1
    l[$>,{$>+1}]
    +max[0,1]
    min[0,1]
    endl
   done
  progress {($>/$!)*200}
  done
 keep[{round(($!/2)-.5)},{round({$!/2}-.5)-1}]
 add
 mul .5
 endif
elif $!==2
add
mul .5
elif $!==1
endif

iain_median_3_stack:
iain_fast_median_stack

iain_median_4_stack:
iain_fast_median_stack

iain_median_5_stack:
iain_fast_median_stack

#@gui MS_Patch_NR3: MS_Patch_NR3,MS_Patch_NR3_p(0)
#@gui : Gamma = float(1.3,.5,2)
#@gui : L Fine = int(0,0,250)
#@gui : L Coarse = int(0,0,250)
#@gui : L Coarsest = int(0,0,250)
#@gui : Patch Size = int(3,3,7)
#@gui : Search Radius = int(5,3,17)
#@gui : Fast = choice (1,"smooth","fast")
#@gui : Pre-Salt and Pepper = choice (0,"none","smooth","fast","strong")
#@gui : Post-Salt and Pepper = choice (0,"none","smooth","fast","strong")
## #@gui : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : C Fine = int(0,0,250)
#@gui : C Coarse = int(0,0,250)
#@gui : C Coarsest = int(0,0,250)
MS_Patch_NR3_p:
to_rgb
MS_Patch_NR3[0] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12
n 0,255

linear_x3:
resize 300%,300%,{d},{s},4,1,.5,.5,0
(.11111,.22222,.33333,.22222,.11111;.22222,.44444,.66666,.44444,.22222;.33333,.66666,1,.66666,.33333;.22222,.44444,.66666,.44444,.22222;.11111,.22222,.33333,.22222,.11111)
convolve[0] [1],0
rm[1]


MS_Patch_NR3:
apply_parallel_overlap[-1] "
if $1!=1
div 255 pow $1 mul 255
endif

if $8==1
iain_pixel_denoise_p 1,1,0,0,1
elif $8==2
iain_pixel_denoise_p 2,1,0,0,1
elif $8==3
hybrid16 hybrid16 hybrid16
endif
cropwidth={w}
cropheight={h}

resize[0] {w+(90-w%90)},{h+(90-h%90)},1,{s},0,1

rgb2yuv8
split c

l[0]
width={w}
height={h}

 if $2>0
  ## apply_parallel_overlap[-1] "denoise 10,{$2/10},$5,$6,0,$7",16
  denoise 10,{$2/10},$5,$6,0,$7
  endif
 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]

 if $3>0
  ## apply_parallel_overlap[-1] "denoise 10,{$3/10},$5,$6,0,$7",16
  denoise 10,{$3/10},$5,$6,0,$7
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 if $4>0
  ## apply_parallel_overlap[-1] "denoise 10,{$4/10},$5,$6,0,$7",16
  denoise 10,{$4/10},$5,$6,0,$7
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]

endl

l[1]
width={w}
height={h}

 if $10>0
  ## apply_parallel_overlap[-1] "denoise 10,{$2/10},$5,$6,0,$7",16
  denoise 10,{$10/10},$5,$6,0,$7
  endif
 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]

 if $11>0
  ## apply_parallel_overlap[-1] "denoise 10,{$3/10},$5,$6,0,$7",16
  denoise 10,{$11/10},$5,$6,0,$7
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 if $12>0
  ## apply_parallel_overlap[-1] "denoise 10,{$4/10},$5,$6,0,$7",16
  denoise 10,{$12/10},$5,$6,0,$7
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]

endl

l[2]
width={w}
height={h}

 if $10>0
  ## apply_parallel_overlap[-1] "denoise 10,{$2/10},$5,$6,0,$7",16
  denoise 10,{$10/10},$5,$6,0,$7
  endif
 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]

 if $11>0
  ## apply_parallel_overlap[-1] "denoise 10,{$3/10},$5,$6,0,$7",16
  denoise 10,{$11/10},$5,$6,0,$7
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 if $12>0
  ## apply_parallel_overlap[-1] "denoise 10,{$4/10},$5,$6,0,$7",16
  denoise 10,{$12/10},$5,$6,0,$7
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]

endl

append c
yuv82rgb
crop 0,0,{$cropwidth-1},{$cropheight-1}

if $1!=1
div 255 pow {1/$1} mul 255
 endif

 if $9==1
iain_pixel_denoise_p 1,1,0,0,1
elif $9==2
iain_pixel_denoise_p 2,1,0,0,1
elif $9==3
hybrid16 hybrid16 hybrid16
endif

c 0,255
",64
#@gui MS Patch NR: MS_Patch_NR,MS_Patch_NR(0)
#@gui : Gamma = float(1.3,.5,2)
#@gui : Fine = float(0,0,250)
#@gui : Coarse = float(0,0,250)
#@gui : Coarsest = float(0,0,250)
#@gui : Patch Size = int(3,3,7)
#@gui : Search Radius = int(5,3,17)
linear_x3:
resize 300%,300%,{d},{s},4,1,.5,.5,0
(.11111,.22222,.33333,.22222,.11111;.22222,.44444,.66666,.44444,.22222;.33333,.66666,1,.66666,.33333;.22222,.44444,.66666,.44444,.22222;.11111,.22222,.33333,.22222,.11111)
convolve[0] [1],0
rm[1]


MS_Patch_NR:
if $1!=1
apply_parallel_overlap "div 255 pow $1 mul 255"
endif
cropwidth={w}
cropheight={h}

resize[0] {w+(90-w%90)},{h+(90-h%90)},1,{s},0,1
l[0]
width={w}
height={h}

 if $2>0
  apply_parallel_overlap[-1] "denoise 10,{$2/10},$5,$6,0,0",16
  endif
 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]

 if $3>0
  apply_parallel_overlap[-1] "denoise 10,{$3/10},$5,$6,0,0",16
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 if $4>0
  apply_parallel_overlap[-1] "denoise 10,{$4/10},$5,$6,0,0",16
  endif

 +resize[-1] 33.333333333%,33.3333333333%,{d},{s},2
 +linear_x3[-1]

 sub[-3,-1]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]
 linear_x3[-1]
 add[-1,-2]

endl
crop 0,0,{$cropwidth-1},{$cropheight-1}
if $1!=1
 apply_parallel_overlap "div 255 pow {1/$1} mul 255"
 endif
c 0,255


#@gui Save Noise Print:  iain_savenoiseprint, iain_savenoiseprint_p(0)
#@gui : Pass = choice ("pass 1 create noise print","pass 2 remove noise")
#@gui : Detail Threshold = float (1,0,5)
#@gui : Gamma = float(1.4,1,4)
#@gui : note = note("This filter requires 2 images as input, the bottom image should be noisey and the top image should be the same image only with some kind of noise reduction.")
#@gui : note = note("You need to do 2 passes of this filter to get the results. The first pass analyses the residual noise and creates a noise print and saves it to your computer. On the 1st pass you can click apply and the noise print will be generated after a while. When that has finished switch to 2nd pass and adjust the Detail Threshold to your liking and hit okay or apply.")
#@gui : note = note("<b> Set output mode to 'New Layers'</b>")

iain_savenoiseprint_p:
if $1==0
text "creating noiseprint",0,0,50,1,255
elif $1==1
iain_savenoiseprint[0,1] $1,$2,$3
endif

iain_savenoiseprint:
remove_opacity
rgb2yuv8
split c
remove[-1,-2]

l[0,3]
apply_parallel_overlap[0] "mul {1/255} pow $3 mul 255 ",0,0
apply_parallel_overlap[1] "mul {1/255} pow $3 mul 255 ",0,0

+sub[1] [0]
add[-1] 128
l[-1]

 if $1==0
 +l
 size=48
 cropwidth={w}
 cropheight={h}
 resize[0] {w+($size-w%$size)},{h+($size-h%$size)},1,{s},0,1

 tc={round(w/$size)} tr={round(h/$size)}

  l[0]
  split_tiles $tc,$tr
  repeat $! local[$>]
  fftpolar[0]
  append[0,1] z
  endl done
  median_median
   endl
  o noiseprint.cimg
  rm
 endl
 elif $1==1

 size=48
 cropwidth={w}
 cropheight={h}
 resize[0] {w+($size-w%$size)},{h+($size-h%$size)},1,{s},0,1

 tc={round(w/$size)} tr={round(h/$size)}

  i noiseprint.cimg
  mul[-1] $2

 +l[0,1]
  split_tiles[0] $tc,$tr

  repeat $!-1
   l[$>,-1]
    [-1]
     l[0,1]
     fftpolar[0]
      l[0,-1]
      split[1] z
      rm[-1]
      +gt[0] [1]
      circle[-1] 50%,50%,1%,1,1
      mul[0] [-1]
      keep[0]
      endl
     ifftpolar
     endl
   endl

  done
  rm[-1]
  append_tiles $tc,$tr
  endl

  +l[0,1]
  shift[0] 16,16,0,0
  split_tiles[0] $tc,$tr

  repeat $!-1
  l[$>,-1]
  [-1]
  l[0,1]
  fftpolar[0]
  l[0,-1]
  split[1] z
  rm[-1]
  +gt[0] [1]
  circle[-1] 50%,50%,1%,1,1
  mul[0] [-1]
  keep[0]
  endl
  ifftpolar
  endl
  endl
  done
  rm[-1]
  append_tiles $tc,$tr
  shift[0] -16,-16,0,0
  endl

  l[0,1]
  shift[0] 32,32,0,0
  split_tiles[0] $tc,$tr

  repeat $!-1
  l[$>,-1]
  [-1]
  l[0,1]
  fftpolar[0]
  l[0,-1]
  split[1] z
  rm[-1]
  +gt[0] [1]
  circle[-1] 50%,50%,1%,1,1
  mul[0] [-1]
  keep[0]
  endl
  ifftpolar
  endl
  endl
  done
  rm[-1]
  append_tiles $tc,$tr
  shift[0] -32,-32,0,0
  endl

  iain_fast_median_stack
  crop 0,0,{$cropwidth-1},{$cropheight-1}

 c 0,255
 endif
 endl

 sub[-1] 128
add[0] [-1]
keep[0]
apply_parallel_overlap[0] "mul {1/255} pow {1/$3} mul 255 ",0,0

endl

append c
yuv82rgb
c 0,255
 if $1==0
rm
endif

median_median:

repeat $!/3-($!%3)
l[$>,{$>+1},{$>+2}]
iain_fast_median_stack
endl
done

repeat $!/3-($!%3)
l[$>,{$>+1},{$>+2}]
iain_fast_median_stack
endl
done

repeat $!/3-($!%3)
l[$>,{$>+1},{$>+2}]
iain_fast_median_stack
endl
done

num=$!
add
div $num

#@gui Brown Spot Clean: iain_brown_spot_clean,iain_brown_spot_clean(0)
#@gui : Red/Green Radius = int (1,1,7)
#@gui : Blue Radius = int (2,1,7)
iain_brown_spot_clean:
red_radius={($1*2)+1}
green_radius={($1*2)+1}
blue_radius={($2*2)+1}

to_rgb
+l
split c
l[0]
median $red_radius
median $red_radius
median $red_radius
endl
l[1]
median $green_radius
median $green_radius
median $green_radius
endl
l[2]
median $blue_radius
median $blue_radius
median $blue_radius
endl
append c
endl
sub[0] [1]
add[0] 128

+l[0]
rgb2hsv8
split c
keep[0]
apply_curve 0,0,0,11,0,13,255,65,255,67,0,255,0
lt 1
endl
sub[0] 128
mul[0,2]
add
c 0,255

nozip:
remove_opacity
+l[0]
(1;-1)
convolve[0] [1]
rm[1]
abs
split c
max
endl
+l[1]
(1,-1)
convolve[0] [1]
rm[1]
abs
split c
max
endl

+l[0]
+l
split c
add
div 3
endl
sub
abs
split c
max
endl

+l[1]
+l
split c
add
div 3
endl
sub
abs
split c
max
endl

mul[-1,-2] $1

add[2,4]
add[3,4]

l[-1,-2]
blur 2
sub
gt 0
mul 255
endl
append[1,2] c
 blend alpha,1,0

#@gui Smart Demosaic: iain_smartdemos, iain_smartdemos(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : Blur Radius = float (1.5,.5,3)
#@gui : Wrong Way-Zippers = float (2,0,5)

iain_smartdemos:

cropwidth={w}
cropheight={h}
resize[0] {w+(64-w%64)},{h+(64-h%64)},{d},{s},0,2
apply_parallel_overlap "
to_rgb
add 1000
rgb2bayer[0] $1,1
+l[0]
+l[0]
split c
 l[0,2]
 (0,0,.5;0,1,0;0.5,0,0)
 convolve[0] [-1]
 convolve[1] [-1]
 rm[-1]
(0,0,.25;0,.5,0;0.25,0,0)
 convolve[0] [-1]
 convolve[1] [-1]
 rm[-1]
 endl

endl

split[0] c
name[0] red name[1] green name[2] blue
   name[3] redblur name[4] greenblur name[5] blueblur

+div[redblur] [blueblur]
replace_nan 0
+mul[blue] [-1]
add[-1] [red]

+div[blueblur] [redblur]
replace_nan 0
+mul[red] [-1]
add[-1] [blue]
 keep[1,-1,-3]
reverse[0,1]
append c
 endl

l[0]
+l[0]
split c
 l[0,2]
 (0.5,0,0;0,1,0;0,0,0.5)
 convolve[0] [-1]
 convolve[1] [-1]
 rm[-1]
(0.25,0,0;0,.5,0;0,0,0.25)
 convolve[0] [-1]
 convolve[1] [-1]
 rm[-1]
 endl

endl

split[0] c
name[0] red name[1] green name[2] blue
   name[3] redblur name[4] greenblur name[5] blueblur

+div[redblur] [blueblur]
replace_nan 0
+mul[blue] [-1]
add[-1] [red]

+div[blueblur] [redblur]
replace_nan 0
+mul[red] [-1]
add[-1] [blue]
 keep[1,-1,-3]
reverse[0,1]
append c
 endl

+l[0]
(.33,0,0,0,0;0,.66,0,0,0;0,0,-2,0,0;0,0,0,.66,0;0,0,0,0,.33)
convolve[0] [1]
rm[1]
abs
split c
rm[1]
max
endl
+l[1]
(0,0,0,0,.33;0,0,0,.66,0;0,0,-2,0,0;0,.66,0,0,0;.33,0,0,0,0)
convolve[0] [1]
rm[1]
abs
split c
rm[1]
max
endl
blur[-1,-2] 2
sub[-1,-2]

 gt[-1] 0
 mul[-1] 255
 append[1,2] c
 blend alpha,1,0

# green v

 +l[0]
 split[0] c
 add[0,2]
 mul[0] 0.5
 reverse
 ## remove[-2,-4]
nm[0] green nm[1] magenta
[0] [1]
nm[-2] greenblur nm[-1] mblur
(0.25;.5;0.5;.5;0.25)
convolve[mblur] [-1] rm[-1]

(0.5;1;0.5)
convolve[greenblur] [-1]
rm[-1]
+div[greenblur] [mblur]
replace_nan 0
nm[-1] mmul
rm[greenblur,mblur]
mul[magenta] [mmul]
keep[green,magenta]
add

  endl

# green h
 +l[0]
 split[0] c
 add[0,2]
 mul[0] 0.5
 reverse
 ## remove[-2,-4]
nm[0] green nm[1] magenta
[0] [1]
nm[-2] greenblur nm[-1] mblur
(0.25,.5,0.5,.5,0.25)
convolve[mblur] [-1] rm[-1]

(0.5,1,0.5)
convolve[greenblur] [-1]
rm[-1]
+div[greenblur] [mblur]
replace_nan 0
nm[-1] mmul
rm[greenblur,mblur]
mul[magenta] [mmul]
keep[green,magenta]
add

  endl
sub 1000
  c 0,255

 +l[0,1]
 rgb2bayer[0] $1,1
+to_rgb[1]
 rgb2bayer[-1] $1,1
 split[0] c
 split[-1] c
 sub[0] [4]
 sub[2] [6]
 (0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
 convolve[0] [-1]
 convolve[2] [-1]
 remove[-1]
 add[0] [3]
 add[2] [3]
 remove[1,4,5,6]
 reverse[1,2]
 append c
endl
 l[0,2]
 rgb2bayer[0] $1,1
+to_rgb[1]
 rgb2bayer[-1] $1,1
 split[0] c
 split[-1] c
 sub[0] [4]
 sub[2] [6]
 (0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
 convolve[0] [-1]
 convolve[2] [-1]
 remove[-1]
 add[0] [3]
 add[2] [3]
 remove[1,4,5,6]
 reverse[1,2]
 append c
endl

rm[1]
replace_inf 255
replace_nan 0

reverse

l[0]
+blur $2
sub[0] [1]
add[0] 128
endl
l[2]
+blur $2
sub[0] [1]
add[0] 128
endl

l[0,2]
nozip $3
endl

l[-1,-2]
+l[0]
+l
split c
add
div 3
endl
sub
+blur 3
sub
abs
split c
max
endl

+l[1]
+l
split c
add
div 3
endl
sub
+blur 3
sub
abs
split c
max
endl
l[-1,-2]
blur 2
sub
gt 0
mul 255
endl
append[1,2] c
 blend alpha,1,0
 endl

sub[0] 128
add

c 0,255
 ",16,0
crop 0,0,{$cropwidth-1},{$cropheight-1}
time=$|
#@gui Grey_Descreen: iain_descreen2,iain_descreen2(0)
#@gui : Analysis Cindow = float (3,0,20)
#@gui : Strength = float(-10000,-10000,10000)
#@gui : Range = float (10,0,20)
iain_descreen2:

channels 0
fftpolar
+blur[0] $1%
sub[-1] [0]
gt[-1] $2
circle[-1] 50%,50%,$3%,1,1
mul[0] [-1]
keep[0,1]
ifftpolar
c 0,255

#@gui Moire Removal Not Parallel: iain_moire_removal_NP, iain_moire_removal_NP(0)
#@gui : Smoothing = float (5,0,20)
#@gui : Smart Threshold = float (5,0,10)
#@gui : Moire Removal Method = choice(0,"Smart","Aggresive","Smooth only")
#@gui : sep = separator()
#@gui : note = note("This filter is the same as the other one but doe snot have parallel processing" )
#@gui : sep = separator()
#@gui : note = note("Moire removal consists of two parts, first, an edge-protected smoothing and second a frequency analyisis of the difference between the smoothed and original image. The image is broken into tiles, and each tile processed. A tile that is a solid colour is skipped." )
#@gui : note = note("Smoothing must be high enough to remove the moire. The <b>Smart Threshold</b> sets the detection of moire for each frequency on each colour channel. If a frequency in one colour channel is determined to be moire it is replaced by the colour channel least likely to have moire." )
#@gui : note = note("The <b>Agressive</b> setting skips the thresolding step and uses the lowest frequency level from the colour channels." )
#@gui : note = note("The filter will reduce chroma details/noise" )

iain_moire_removal_NP:
tile_size=256
overlap=16
cropwidth={w}
cropheight={h}

if $cropwidth%$tile_size>0
resize[0] {w+($tile_size-w%$tile_size)},100%,1,{s},0,1
endif
if $cropheight%$tile_size>0
resize[0] 100%,{h+($tile_size-h%$tile_size)},1,{s},0,1
endif
h_tiles={w/$tile_size}
v_tiles={h/$tile_size}
repeat $v_tiles,v_count
repeat $h_tiles,h_count

+crop[0] {($h_count*$tile_size)-$overlap},{($v_count*$tile_size)-$overlap},{($h_count*$tile_size)+($tile_size+$overlap-1)},{($v_count*$tile_size)+($tile_size+$overlap-1)},1

done
done
rm[0]

repeat $! l[$>]

if iM!=im
[0]
l[1]
l[0]
 repeat 3 # number of pyramid levels.
    l[-1]
    repeat 2
     denoise[0] 10,{$1/($>+1)},5,5,0,{min($>,1)}
    done
    +resize[0] 50%,50%,{d},{s},2
    +resize[-1] 200%,200%,{d},{s},3
    sub[0,-1]
    endl

   done

   ## rebuild
   repeat $!-1
   resize[-1] {-2,w},{-2,h},{d},{s},3
   add[-1,-2]
   done
   endl

  endl
  if $3<2
  sub[0] [1]
  l[0]
   fftpolar[0]
   if $3==1
   append[0,1] x
   split[0] c
   min
   split[0] x,2
   elif $3==0
   fill[1] if(max(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))-min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))<$2,min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2)),(i(x,y,z,c)))
   endif
   ifftpolar[0,1]
   keep[0]
  endl
  to_rgb
 add
 else
 keep[1]
 endif

  c 0,255
endif
## "
endl
progress {($>/$!)*100}
done

# restore
repeat $! l[$>]
crop $overlap,$overlap,{$tile_size+$overlap-1},{$tile_size+$overlap-1}
endl
done
append_tiles $h_tiles,$v_tiles
crop 0,0,{$cropwidth-1},{$cropheight-1}

#@gui Moire Removal: iain_moire_removal, iain_moire_removal(0)
#@gui : Smoothing = float (5,0,20)
#@gui : Smart Threshold = float (5,0,10)
#@gui : Moire Removal Method = choice(0,"Smart","Aggresive","Smooth only")
#@gui : sep = separator()
#@gui : note = note("Moire removal consists of two parts, first, an edge-protected smoothing and second a frequency analyisis of the difference between the smoothed and original image. The image is broken into tiles, and each tile processed. A tile that is a solid colour is skipped." )
#@gui : note = note("Smoothing must be high enough to remove the moire. The <b>Smart Threshold</b> sets the detection of moire for each frequency on each colour channel. If a frequency in one colour channel is determined to be moire it is replaced by the colour channel least likely to have moire." )
#@gui : note = note("The <b>Agressive</b> setting skips the thresolding step and uses the lowest frequency level from the colour channels." )
#@gui : note = note("The filter will reduce chroma details/noise" )

iain_moire_removal:
tile_size=256
overlap=16
cropwidth={w}
cropheight={h}

if $cropwidth%$tile_size>0
resize[0] {w+($tile_size-w%$tile_size)},100%,1,{s},0,1
endif
if $cropheight%$tile_size>0
resize[0] 100%,{h+($tile_size-h%$tile_size)},1,{s},0,1
endif
h_tiles={w/$tile_size}
v_tiles={h/$tile_size}
repeat $v_tiles,v_count
repeat $h_tiles,h_count

+crop[0] {($h_count*$tile_size)-$overlap},{($v_count*$tile_size)-$overlap},{($h_count*$tile_size)+($tile_size+$overlap-1)},{($v_count*$tile_size)+($tile_size+$overlap-1)},1

done
done
rm[0]

repeat $! l[$>]
## apply_parallel "
if iM!=im
[0]
apply_parallel_channels[1] "
l[0]
 repeat 3 # number of pyramid levels.
    l[-1]
    repeat 2
     denoise[0] 10,{$1/($>+1)},5,5,0,{min($>,1)}
    done
    +resize[0] 50%,50%,{d},{s},2
    +resize[-1] 200%,200%,{d},{s},3
    sub[0,-1]
    endl

   done

   ## rebuild
   repeat $!-1
   resize[-1] {-2,w},{-2,h},{d},{s},3
   add[-1,-2]
   done
   endl

  "
  if $3<2
  sub[0] [1]
  l[0]
   fftpolar[0]
   if $3==1
   append[0,1] x
   split[0] c
   min
   split[0] x,2
   elif $3==0
   fill[1] if(max(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))-min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2))<$2,min(i(x,y,z,0),i(x,y,z,1),i(x,y,z,2)),(i(x,y,z,c)))
   endif
   ifftpolar[0,1]
   keep[0]
  endl
  to_rgb
 add
 else
 keep[1]
 endif

  c 0,255
endif
## "
endl
progress {($>/$!)*100}
done

# restore
repeat $! l[$>]
crop $overlap,$overlap,{$tile_size+$overlap-1},{$tile_size+$overlap-1}
endl
done
append_tiles $h_tiles,$v_tiles
crop 0,0,{$cropwidth-1},{$cropheight-1}
#@gui Skin Mask: iain_fx_skin_mask,iain_fx_skin_mask_pr
#@gui : note = note("<b>Main Controls</b>")
#@gui : Magenta Ratio = float (55,0,255)
#@gui : Cyan Ratio = float (200,2,255)
#@gui : sep = separator()
#@gui : note = note("<b>Refine Hue Range</b>")
#@gui : Remove Reds = float (0,0,255)
#@gui : Remove Yellows = float(0,0,100)
#@gui : sep = separator()
#@gui : Output = choice ("Masked Image","Just the Mask")
#@gui : Preview Shows = choice (1,"Output","Highlighted Mask")
#@gui : sep = separator()
#@gui : note = note("Skin mask uses CMYK colour model to selct skin tones. Skin tones generally have a predictable ratios of Cyan, Magetna and Yellow. Different ethnicies have slighty different ratios. ")
#@gui : note = note("<small><b>Magenta Ratio:</b> This sets how much the Magenta content is allowed to be below the Yellow content. Increase to include dark skin tones and shadows.</small>")
#@gui : note = note("<small><b>Cyan Ratio:</b> This set the how much the Cyan content is allowed to be below the Yellow content. Increase to include pale skin tones and highlights.</small>")
#@gui : note = note("<small><b>Refine Hue Range:</b> This allows you to remove tones that pass through the main controls but are not present in your subject.</small>")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")

iain_fx_skin_mask_pr:
if $6==0
iain_skin_mask $1,$2,$3,$4,$5
elif $6==1

+iain_skin_mask $1,$2,$3,$4,1

n[-1] 0.6,1

mul

endif

iain_fx_skin_mask:
tic
apply_parallel_overlap[0] "iain_skin_mask[0] ${1--1}",0,0
toc

iain_skin_mask:

dark={$1}
pale={255-$2}
red={255-$3}
yellow={255-$4}

to_rgb
[0]
[0]
[0]

l[1]
if $3>0
red={255-$3}
fill if(i(x,y,z,0)-i(x,y,z,1)<{$red},i,0)
gt 0
else
fill 1
endif
endl

l[2]
rgb2cmyk
dark={$1}
pale={255-$2}
fill if(i(x,y,z,2)>i(x,y,z,1),if(i(x,y,z,2)-i(x,y,z,1)<{$dark},if((i(x,y,z,0)+{$pale})<i(x,y,z,2),i,255),255),255)
cmyk2rgb
gt 0
endl
l[3]
if $4>0
yellow={255-$4}
rgb2hsv
split c
keep[0]
add[0] 180
mod[0] 360
lt[0] $yellow
else
fill 1
endif
endl

mul[1,2,3]
mul[1] 255
channels[1] 0
if $5
keep[1]

else
append c
endif

#@gui Exfusion5: exfusion5, exfusion5
#@gui : Contrast Bias = float(0,0,1)
#@gui : Saturation Bias = float(.2,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure Bias = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("Post Fusion Options")
#@gui : Local Contrast = float (0,0,3)
#@gui : Curve = float (0,-127,127)
exfusion5:

images=$!
## luminance
cropwidth={w}
cropheight={h}
maxlevels={round(log2(min(w,h))+0.5)+0}
size={2^$maxlevels}
remove_opacity
resize {w+($size-w%$size)},{h+($size-h%$size)},1,3,0,1,0.5,0.5
+l[0-{$images-1}]
repeat $! local[$>]
fx_ExposureWeightMap[0] $1,$2,$3,$4,0
endlocal done
endl

 l[-1--$images]
+add
replace 0,0.0000000000001
repeat $!-1

div[$<] [-1]
 done
rm[-1]
endl

repeat $maxlevels
l[-1--{$images*2}]
  +l[0-{$images-1}]
   repeat $! local[$>]
  +resize[0] 50%,50%,1,3,2
  resize[-1] 200%,200%,1,3,5,0
  sub[0,-1]
  endlocal done
 endl

 l[-1--{$images*2}]
   repeat $images local[$>,{$>+$images}]
  mul[-1] [-2]
  endlocal done
 endl

 l[-1--$images]
 add
 endl

move[-1] 0

 l[-1--{$images*2}]
  repeat $! local[$>]
  resize[0] 50%,50%,1,3,2
  endlocal done
 endl


endl
done

l[-1--{$images*2}]
 if 1
   repeat $images local[$>,{$>+$images}]
  mul[-1] [-2]
  endlocal done
  keep[-1--$images]
  add
 else
 keep[0--{$images-1}]
 add
 div $images
 endif
endl

## rebuild
repeat $!-1
resize[-1] {-2,w},{-2,h},1,3,5,0
add[-1,-2]
done

resize $cropwidth,$cropheight,1,3,0,1,0.5,0.5

n 0,255

mul 1000
apply_curve 1,0,0,128000,{($6*1000)+128000},255000,255000
mul 0.001

+iain_fast_denoise $5,$5,1,{$5/100},0
sub[1] [0]
mul[1] -1
+add
c 0,255
rm[1]
reverse
rgb2lch
split c
keep[0,4,5]
append c
lch2rgb
#@gui Exfusion3: exfusion3, exfusion3
#@gui : Contrast Bias = float(0.3,0,1)
#@gui : Saturation Bias = float(0.3,0,1)
#@gui : Exposure Sigma = float(0.2,0,1)
#@gui : Exposure Bias = float(0.3,0,1)
#@gui : sep = separator()
#@gui : Maxlevels Adjust = int(-1,-5,0)
#@gui : Base Level Median Stack = bool(0)
#@gui : sep = separator()
#@gui : note = note("Pyramid levels are calculated automatically, but you can reduce the number of pyramid levels to save memory. You can choose how the base level is fused, by using weight maps like normal, or by using a median of the image stack")
exfusion3:

## luminance
cropwidth={w}
cropheight={h}
maxlevels={round(log2(min(w,h))+0.5)+$5}
size={2^$maxlevels}

resize {w+($size-w%$size)},{h+($size-h%$size)},1,3,0,1
repeat $maxlevels
l[-1--3]
+l[0,1,2]
+resize[0] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,5
sub[0,-1]
+resize[1] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,5
sub[1,-1]
+resize[2] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,5
sub[2,-1]
endl

# create weightmaps for each image at this level
[0]
fx_ExposureWeightMap[-1] $1,$2,$3,$4,0
[1]
fx_ExposureWeightMap[-1] $1,$2,$3,$4,0
[2]
fx_ExposureWeightMap[-1] $1,$2,$3,$4,0
rm[0,1,2]

+add[-1,-2,-3]
replace[-1,-2,-3,-4] 0,0.0000000000001
div[-2] [-1]
div[-3] [-1]
div[-4] [-1]
rm[-1]

mul[0,6]
mul[1,6]
mul[2,6]
add[0,1,2]

endl
done

l[-1,-2,-3]
if $6
iain_fast_median_stack
else

[0]
[1]
[2]
parallel "
fx_ExposureWeightMap[-1] $1,$2,$3,$4,0","
fx_ExposureWeightMap[-2] $1,$2,$3,$4,0","
fx_ExposureWeightMap[-3] $1,$2,$3,$4,0"

+add[-1,-2,-3]
replace[-1,-2,-3,-4] 0,0.0000000000001
div[-2] [-1]
div[-3] [-1]
div[-4] [-1]
rm[-1]

mul[0,3]
mul[1,3]
mul[2,3]
add
endif
endl

## rebuild
repeat $!-1
resize[-1] {-2,w},{-2,h},1,3,5
add[-1,-2]
done

crop 0,0,{$cropwidth-1},{$cropheight-1}

+l[0]
resize 5%,5%,1,3,2
endl
min={1,im}
max={1,iM}
c[0] $min,$max
keep[0]
n 0,255
#@gui Iain Weightmap: iain_weightmap, iain_weightmap
#@gui : Lap Weight = float (1,0,4)
#@gui : Blur Width = float (40,0,100)
iain_weightmap:
split c
max
255,1
set[-1] 255,128,0
blur[-1] $2
n[-1] 0,255
+map[0] [1]
rm[1]
laplacian[0]
mul[0] $1
abs[0]
add

#@gui Exfusion: exfusion, exfusion
#@gui : Width = float (20,0,50)
exfusion:

## luminance
cropwidth={w}
cropheight={h}
resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
repeat 10
###make hf
l[-1--4]
+l[0,1,2,3]
+resize[0] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,3
sub[0,-1]
+resize[1] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,3
sub[1,-1]
+resize[2] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,3
sub[2,-1]
+resize[3] 50%,50%,1,3,2
+resize[-1] 200%,200%,1,3,3
sub[3,-1]
endl
## parallel "
+iain_weightmap[0] 1,$1 ##","
+iain_weightmap[1] 1,$1 ##","
+iain_weightmap[2] 1,$1  ##","
+iain_weightmap[3] 1,$1 ##"
## parallel "
## +fx_ExposureWeightMap[0] $1,$2,$3,$4,0","
## +fx_ExposureWeightMap[1] $1,$2,$3,$4,0","
## +fx_ExposureWeightMap[2] $1,$2,$3,$4,0","
## +fx_ExposureWeightMap[3] $1,$2,$3,$4,0"
+add[-1,-2,-3,-4]
replace[-1,-2,-3,-4,-5] 0,0.0000000000001
## parallel "
div[-2] [-1] ##","
div[-3] [-1] ##","
div[-4] [-1]  ##","
div[-5] [-1] ##"
rm[-1]

mul[4,12]
mul[5,12]
mul[6,12]
mul[7,12]

add[4,5,6,7]

rm[0,1,2,3]
endl
done
###base level
l[-1,-2,-3,-4]
## parallel "
## +fx_ExposureWeightMap[0] $1,$2,$3,$4,0","
## +fx_ExposureWeightMap[1] $1,$2,$3,$4,0","
## +fx_ExposureWeightMap[2] $1,$2,$3,$4,0","
## +fx_ExposureWeightMap[3] $1,$2,$3,$4,0"
parallel "
+iain_weightmap[0] 4,$1","
+iain_weightmap[1] 4,$1","
+iain_weightmap[2] 4,$1","
+iain_weightmap[3] 4,$1"

+add[-1,-2,-3,-4]
replace[-1,-2,-3,-4,-5] 0,0.00000000000001
div[-2] [-1]
div[-3] [-1]
div[-4] [-1]
div[-5] [-1]
rm[-1]
mul[0,4]
mul[1,4]
mul[2,4]
mul[3,4]
add
endl

## rebuild
repeat $!-1
resize[-1] {-2,w},{-2,h},1,3,3
add[-1,-2]
done

crop 0,0,{$cropwidth-1},{$cropheight-1}
+l[0]
resize 5%,5%,1,3,2
endl
min={1,im}
max={1,iM}
c[0] $min,$max
## c 0,255
keep[0]
n 0,255

#@gui Exfuse: exfuse, exfuse
#@gui : Exposure = float (1,0,2)
#@gui : Contrast Bias = float(0.6,0,1)
#@gui : Saturation Bias = float(0,0,1)
#@gui : Exposure Sigma = float(0.5,0,1)
#@gui : Exposure Bias = float(1,0,1)
#@gui : Blur = float(5,0,50)
exfuse:
cropwidth={w}
cropheight={h}
+mul[0] {2*$1}
+mul[0] {4*$1}
c 0,255
+fx_ExposureWeightMap[0] $2,$3,$4,$5,0
+fx_ExposureWeightMap[1] $2,$3,$4,$5,0
+fx_ExposureWeightMap[2] $2,$3,$4,$5,0
parallel "
freq_pyramid[0]","
freq_pyramid[1]","
freq_pyramid[2]","
dumb_pyramid[3]","
dumb_pyramid[4]","
dumb_pyramid[5]"
parallel "blur[-1] $6","blur[-2] $6","blur[-3] $6"
replace[-1,-2,-3] 0,0.000000001
+add[-1,-2,-3]

div[-2] [-1]
div[-3] [-1]
div[-4] [-1]
rm[-1]
parallel "
mul[0] [3]","
mul[1] [4]","
mul[2] [5]"
add[0,1,2]

keep[0]

ifreq_pyramid[0]
crop 0,0,{$cropwidth-1},{$cropheight-1}
c 0,255

dumb_pyramid:
cropwidth={w}
cropheight={h}
resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
newwidth={w}
+resize[-1] 50%,50%,{d},{s},2
+resize[-1] 50%,50%,{d},{s},2
+resize[-1] 50%,50%,{d},{s},2
+resize[-1] 50%,50%,{d},{s},2
+resize[-1] 50%,50%,{d},{s},2
append x
resize {$newwidth*2},100%,1,3,0,0
ifreq_pyramid:
split x,2
split[1] x,2
split[2] x,2
split[3] x,2
split[4] x,2

crop[1] 0,0,100%,{0,h/2-1}
crop[2] 0,0,100%,{0,h/4-1}
crop[3] 0,0,100%,{0,h/8-1}
crop[4] 0,0,100%,{0,h/16-1}
crop[5] 0,0,{4,w/2-1},{0,h/32-1}

resize[-1] {-2,w},{-2,h},{d},{s},3
add[-1,-2]
resize[-1] {-2,w},{-2,h},{d},{s},3
add[-1,-2]
resize[-1] {-2,w},{-2,h},{d},{s},3
add[-1,-2]
resize[-1] {-2,w},{-2,h},{d},{s},3
add[-1,-2]
resize[-1] {-2,w},{-2,h},{d},{s},3
add[-1,-2]

freq_pyramid:
cropwidth={w}
cropheight={h}
resize {w+(1024-w%1024)},{h+(1024-h%1024)},1,3,0,1
newwidth={w}
+resize[-1] 50%,50%,{d},{s},2
+resize[-1] {-2,w},{-2,h},{d},{s},3
sub[-3,-1]

+resize[-1] 50%,50%,{d},{s},2
+resize[-1] {-2,w},{-2,h},{d},{s},3
sub[-3,-1]

+resize[-1] 50%,50%,{d},{s},2
+resize[-1] {-2,w},{-2,h},{d},{s},3
sub[-3,-1]

+resize[-1] 50%,50%,{d},{s},2
+resize[-1] {-2,w},{-2,h},{d},{s},3
sub[-3,-1]

+resize[-1] 50%,50%,{d},{s},2
+resize[-1] {-2,w},{-2,h},{d},{s},3
sub[-3,-1]

append x

resize {$newwidth*2},100%,1,3,0,0


#@gui FFT Tile: fft_tile,fft_tile_preview(0)
#@gui : Threshold = float (500,0,50000)
#@gui : Tile Size = int (128,16,256)
#@gui : Fast = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/08/08")

fft_tile_fft:

+fftpolar[0]
+threshold[1] $1
set[-1] 1,50%,50%
mul[1] [-1]
+ifftpolar[1,2]
keep[-1]

fft_tile_clean:

tc={round(w/$2)} tr={round(h/$2)}
split_tiles $tc,$tr
repeat $! local[$>]
fft_tile_fft[0--1] $1
endlocal done
append_tiles $tc,$tr
c 0,255

fft_tile:

##Normal

+resize[0] {w+$2},{h+$2},1,1,0,1,1,1
resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
fft_tile_clean[-1] $1,$2
crop[-1] $2,$2,{w-$2-1},{h-$2-1}
if $3==0

#right a bit

push={round($2*1.5)}
pull={$2-$push}

+resize[0] {w+$push},{h+$2},1,1,0,1,1,1
resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
fft_tile_clean[-1] $1,$2
crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}

# Down a bit

+resize[0] {w+$2},{h+$push},1,1,0,1,1,1
resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
fft_tile_clean[-1] $1,$2
crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}

#diagonal 1

dia1={round($2/3)}
dia2={$2-$dia1}

+resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
fft_tile_clean[-1] $1,$2
crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}

#diagonal 2

+resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
fft_tile_clean[-1] $1,$2
crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
endif
remove[0]
if $3==0
blend_median
endif

fft_tile_preview:
fft_tile $1,$2,$3
n 0,255

#@gui MS Patch Chroma: ms_patch_c, ms_patch_c_preview(0)
#@gui : note = note{"Master Patch based smoothing (scale 1)"}
#@gui : Patch Variance = float (5,0.1,50)
#@gui : Median Pass = bool (1)
#@gui : Global Iterations = int (1,1,5)
#@gui : sep = separator ()
#@gui : Scale 2 = float (5,0,25)
#@gui : Scale 3 = float (4,0,25)
#@gui : Scale 4 = float (3,0,25)
#@gui : Scale 5 = float (2,0,25)
#@gui : Scale 6 = float (1,0,25)
#@gui : Scale 7 = float (1,0,25)
#@gui : Undo Gamma = float (1.3,1,3)
#@gui : sep = separator ()
#@gui : note = note{"Customise Luma weighting"}
#@gui : Red = float (0.375,0,1)
#@gui : Green = float (.5,0,1)
#@gui : Blue = float (0.125,0,1)
#@gui : sep = separator ()
#@gui : Show Difference = bool (0)
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 10 December 2012 - added show difference option and changed interations from local operation to global operation.")

create_luma_mix:
+split[0] c
mul[1] {$1/($1+$2+$3)}
mul[2] {$2/($1+$2+$3)}
mul[3] {$3/($1+$2+$3)}
add[1-3]
keep[-1]
to_gray[-1]

ms_patch_c:
to_rgb
+create_luma_mix[0] $11,$12,$13
name[-1] luma
if $2==1
median[0] 3
median[0] 3
endif
repeat $3
ms_patch_smooth[0] 10,$1,3,5,0,1,1,0,$4,$5,$6,$7,$8,$9,$10
done
+create_luma_mix[0] $11,$12,$13
sub[0] [-1]
add[0] [1]
keep[0]
c 0,255

ms_patch_c_preview:

if $-1==0
ms_patch_c ${1--2}
endif
if $-1==1
+ms_patch_c ${1--2}
sub[0] [1]
keep[0]
mul 2
add 128
endif
# #@gui Multi Scale Patch Smoothing: ms_patch_smooth,ms_patch_smooth_preview(0)
# #@gui : note = note{"Normal Patch based smoothing (scale 1)"}
# #@gui : Spatial Variance = float (10,0,20)
# #@gui : Patch Variance = float (5,0.1,50)
# #@gui : Patch Size = int (3,2,21)
# #@gui : Lookup Size = int (5,2,21)
# #@gui : Patch Smoothness = float (0,0,4)
# #@gui : Fast Approximation = bool (1)
# #@gui : Iterations = int (1,1,5)
# #@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
# #@gui : sep = separator ()
# #@gui : note = note{"Patch Variance for additional scales"}
# #@gui : Scale 2 = float (5,0,25)
# #@gui : Scale 3 = float (4,0,25)
# #@gui : Scale 4 = float (3,0,25)
# #@gui : Scale 5 = float (2,0,25)
# #@gui : Scale 6 = float (1,0,25)
# #@gui : Scale 7 = float (1,0,25)
# #@gui : Undo Gamma = float (1.3,1,3)
# #@gui : sep = separator ()
# #@gui : Show Difference = bool (0)
# #@gui : sep = separator ()
# #@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/19/08")

# ms_patch_smoothsmoothing:
# ac "repeat $7 denoise $1,$2,$3,$4,$5,$6 done",$8,0 c 0,255

# ms_patch_smooth2:
# +resize[0] {w/2},{h/2},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth3:
# +resize[0] {w/3},{h/3},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth4:
# +resize[0] {w/4},{h/4},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth5:
# +resize[0] {w/5},{h/5},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth6:
# +resize[0] {w/6},{h/6},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth7:
# +resize[0] {w/7},{h/7},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth:

# apply_gamma {1/$15}

# if $2>0.1
# ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# endif
# if $9>0.1
# ms_patch_smooth2 $1,$9,$3,$4,$5,$6,$7,$8
# endif
# if $10>0.1
# ms_patch_smooth3 $1,$10,$3,$4,$5,$6,$7,$8
# endif
# if $11>0.1
# ms_patch_smooth4 $1,$11,$3,$4,$5,$6,$7,$8
# endif
# if $12>0.1
# ms_patch_smooth5 $1,$12,$3,$4,$5,$6,$7,$8
# endif
# if $13>0.1
# ms_patch_smooth6 $1,$13,$3,$4,$5,$6,$7,$8
# endif
# if $14>0.1
# ms_patch_smooth7 $1,$14,$3,$4,$5,$6,$7,$8
# endif
# apply_gamma {$15}

# c 0,255

# ms_patch_smooth_preview:

# if $-1==0
# ms_patch_smooth ${1--2}
# endif
# if $-1==1
# +ms_patch_smooth ${1--2}
# sub[0] [1]
# keep[0]
# mul 2
# add 128
# endif

#@gui Multi Scale Patch Smoothing: ms_patch_smooth,ms_patch_smooth_preview(0)
#@gui : note = note{"Normal Patch based smoothing (scale 1)"}
#@gui : Spatial Variance = float (10,0,20)
#@gui : Patch Variance = float (5,0.1,50)
#@gui : Patch Size = int (3,2,21)
#@gui : Lookup Size = int (5,2,21)
#@gui : Patch Smoothness = float (0,0,4)
#@gui : Fast Approximation = bool (1)
#@gui : Iterations = int (1,1,5)
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator ()
#@gui : note = note{"Patch Variance for additional scales"}
#@gui : Scale 2 = float (5,0,25)
#@gui : Scale 3 = float (4,0,25)
#@gui : Scale 4 = float (3,0,25)
#@gui : Scale 5 = float (2,0,25)
#@gui : Scale 6 = float (1,0,25)
#@gui : Scale 7 = float (1,0,25)
#@gui : Undo Gamma = float (1.3,1,3)
#@gui : sep = separator ()
#@gui : Show Difference = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 28 August 2012 - minor speed up, but level 7 does not do anything now.")

ms_patch_smoothsmoothing:
ac "repeat $7 denoise $1,$2,$3,$4,$5,$6 done",$8 c 0,255

# ms_patch_smooth2:
# +resize[0] {w/2},{h/2},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth3:
# +resize[0] {w/3},{h/3},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth4:
# +resize[0] {w/4},{h/4},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth5:
# +resize[0] {w/5},{h/5},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth6:
# +resize[0] {w/6},{h/6},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

# ms_patch_smooth7:
# +resize[0] {w/7},{h/7},1,{s},2
# +ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# +resize[1] {0,w},{0,h},1,{s},5
# +sub[0] [3]
# resize[2] {0,w},{0,h},1,{s},5
# +add[2] [4]
# keep[-1]
# c 0,255

ms_patch_smooth:
lvl2=2
lvl3=3
lvl4=4
lvl5=5
lvl6=6
lvl7=8

apply_gamma {1/$15}

ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8

name[0] full
+resize[full] {full,w/$lvl2},{full,h/$lvl2},1,{s},2 name[1] level2
+ms_patch_smoothsmoothing[level2] $1,$9,$3,$4,$5,$6,$7,$8  name[2] level2clean
+resize[level2] {0,w},{0,h},1,{s},5  name[3] low2
+sub[full] [low2]  name[4] level2high
remove[level2,low2]

# 0-full, 1-level2clean, 2-level2high

+resize[level2clean] {full,w/$lvl3},{full,h/$lvl3},1,{s},2 name[3] level3
+ms_patch_smoothsmoothing[level3] $1,$10,$3,$4,$5,$6,$7,$8  name[4] level3clean
+resize[level3] {level2clean,w},{level2clean,h},1,{s},5  name[5] low3
+sub[level2clean] [low3]  name[6] level3high
remove[level3,low3]

# 0-full, 1-level2clean, 2-level2high, 3-level3clean, 4-level3high

+resize[level3clean] {full,w/$lvl4},{full,h/$lvl4},1,{s},2 name[5] level4
+ms_patch_smoothsmoothing[level4] $1,$11,$3,$4,$5,$6,$7,$8  name[6] level4clean
+resize[level4] {level3clean,w},{level3clean,h},1,{s},5  name[7] low4
+sub[level3clean] [low4]  name[8] level4high
remove[level4,low4]

# 0-full, 1-level2clean, 2-level2high, 3-level3clean, 4-level3high, 5-level4clean, 6-level4high

+resize[level4clean] {full,w/$lvl5},{full,h/$lvl5},1,{s},2 name[-1] level5
+ms_patch_smoothsmoothing[level5] $1,$12,$3,$4,$5,$6,$7,$8  name[-1] level5clean
+resize[level5] {level4clean,w},{level4clean,h},1,{s},5  name[-1] low5
+sub[level4clean] [low5]  name[-1] level5high
remove[level5,low5]

+resize[level5clean] {full,w/$lvl6},{full,h/$lvl6},1,{s},2 name[-1] level6
+ms_patch_smoothsmoothing[level6] $1,$13,$3,$4,$5,$6,$7,$8  name[-1] level6clean
+resize[level6] {level5clean,w},{level5clean,h},1,{s},5  name[-1] low6
+sub[level5clean] [low6]  name[-1] level6high
remove[level6,low6]

# +resize[level6clean] {full,w/$lvl7},{full,h/$lvl7},1,{s},2 name[-1] level7
# +blur[level7] 0 name[-1] level7clean
# +resize[level7] {level6clean,w},{level6clean,h},1,{s},5  name[-1] low7
# +sub[level6clean] [low7]  name[-1] level7high
# remove[level7,low7]

# #remove[1,3,5]

# #### rebuild
name[-2] base
# add[base] [level7high]
# remove[level7high]
resize[base] {level6high,w},{level6high,h},1,{s},5
add[base] [level6high]
remove[level6high]

resize[base] {level5high,w},{level5high,h},1,{s},5
add[base] [level5high]
remove[level5high]

resize[base] {level4high,w},{level4high,h},1,{s},5
add[base] [level4high]
remove[level4high]

resize[base] {level3high,w},{level3high,h},1,{s},5
add[base] [level3high]
remove[level3high]

resize[base] {level2high,w},{level2high,h},1,{s},5
add[base] [level2high]
remove[level2high]

keep[-1]
c 0,255
# if $2>0.1
# ms_patch_smoothsmoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
# endif
# if $9>0.1
# ms_patch_smooth2 $1,$9,$3,$4,$5,$6,$7,$8
# endif
# if $10>0.1
# ms_patch_smooth3 $1,$10,$3,$4,$5,$6,$7,$8
# endif
# if $11>0.1
# ms_patch_smooth4 $1,$11,$3,$4,$5,$6,$7,$8
# endif
# if $12>0.1
# ms_patch_smooth5 $1,$12,$3,$4,$5,$6,$7,$8
# endif
# if $13>0.1
# ms_patch_smooth6 $1,$13,$3,$4,$5,$6,$7,$8
# endif
# if $14>0.1
# ms_patch_smooth7 $1,$14,$3,$4,$5,$6,$7,$8
#endif
apply_gamma {$15}

c 0,255

ms_patch_smooth_preview:

if $-1==0
ms_patch_smooth ${1--2}
endif
if $-1==1
+ms_patch_smooth ${1--2}
sub[0] [1]
keep[0]
mul 2
add 128
endif
# #@gui Luminance_NR: luminance_nr, luminance_nr(0)
# #@gui : note = note{"Normal Patch based smoothing (scale 1)"}
# #@gui : Patch Variance = float (10,0,50)
# #@gui : Fast Approximation = bool (1)
# #@gui : Iterations = int (1,1,5)
# #@gui : sep = separator ()
# #@gui : note = note{"Smoothing of addition scales"}
# #@gui : Scale 2 = float (6,0,25)
# #@gui : Scale 3 = float (5,0,25)
# #@gui : Scale 4 = float (4,0,25)
# #@gui : Scale 5 = float (3,0,25)
# #@gui : Scale 6 = float (2,0,25)
# #@gui : Scale 7 = float (1,0,25)
# #@gui : sep = separator ()
# #@gui : note = note{"Restore details"}
# #@gui : Threshold = float (5000,0,5000)
# #@gui : Tile Size = int (64,32,128)
# #@gui : Gamma = float (1.3,1,4)
# #@gui : sep = separator ()
# #@gui : note = note("This filter is <b>slow!</b>")
# #@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/19/08")

luminance_nr:
apply_gamma {1/$12}
ac"
+ms_patch_smooth[0] 10,$1,3,3,0,$2,$3,0,$4,$5,$6,$7,$8,$9,1
+compose_grainextract
fft_tile[-1] $10,$11,0
compose_grainmerge[1,2]
keep[-1]
",7
apply_gamma $12
#@gui Luminance_NR2: luminance_nr_two, luminance_nr_two(0)
#@gui : Patch Variance = float (10,0.1,20)
#@gui : Fast Approximation = bool (1)
#@gui : Iterations = int (1,1,5)
#@gui : sep = separator ()
#@gui : note = note("Adjust NR for for larger scales as %")
#@gui : Scale 2 = float (.8,0,1)
#@gui : Scale 3 = float (.7,0,1)
#@gui : Scale 4 = float (.6,0,1)
#@gui : Scale 5 = float (.5,0,1)
#@gui : Scale 6 = float (.4,0,1)
#@gui : Scale 7 = float (.3,0,1)
#@gui : sep = separator ()
#@gui : note = note("Master threshold for details")
#@gui : Threshold = float (1200,0,10000)
#@gui : Tile Size = int (64,32,128)
#@gui : Nothing = float (0,0,0)
#@gui : sep = separator ()
#@gui : note = note("Adjust threshold for detials")
#@gui : Fine = float (0,-1000,1000)
#@gui : Medium = float (0,-1000,1000)
#@gui : Course = float (0,-1000,1000)
#@gui : Recover Details = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Adjust noise reduction by tone")
#@gui : Blacks = int (0,0,500)
#@gui : Darks = int (0,0,500)
#@gui : Midtones = int (0,0,500)
#@gui : Lights = int (0,0,500)
#@gui : White = int (0,0,500)
#@gui : sep = separator ()
#@gui : Median Pass First = bool (0)
#@gui : note = note("This filter is <b>slow!</b>")
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 25 August 2012")
fft_tile2_fft:

+fftpolar[0]
100%,100%,1,1,1
ellipse[-1] 50%,50%,50%,50%,0,1,$4
ellipse[-1] 50%,50%,15%,15%,0,1,$5
ellipse[-1] 50%,50%,5%,5%,0,1,$6
box_blur[-1] {$2*0.01}
+add[1] [-1]
threshold[-1] {$1/(128/$2)}
set[-1] 1,50%,50%
mul[1] [-1]
+ifftpolar[1,2]
keep[-1]

fft_tile2_clean:

tc={round(w/$2)} tr={round(h/$2)}
split_tiles $tc,$tr
repeat $! local[$>]
fft_tile2_fft[0--1] $1,$2,$3,$4,$5,$6
endlocal done
append_tiles $tc,$tr
c 0,255

fft_tile2:
##Normal

+resize[0] {w+$2},{h+$2},1,1,0,1,1,1
resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,$2,{w-$2-1},{h-$2-1}
if $3==0

#right a bit

push={round($2*1.5)}
pull={$2-$push}

+resize[0] {w+$push},{h+$2},1,1,0,1,1,1
resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}

# Down a bit

+resize[0] {w+$2},{h+$push},1,1,0,1,1,1
resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}

#diagonal 1

dia1={round($2/3)}
dia2={$2-$dia1}

+resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}

#diagonal 2

+resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
fft_tile2_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
endif
remove[0]
if $3==0
iain_median_5_stack
endif

luminance_nr_two:

ac "
mul 9.99
apply_curve 0,0,0,510,{510-$17},1020,{1020-$17-$18},1530,{1530-$17-$18-$19},2040,{2040-$17-$18-$19-$20},2550,{2550-$17-$18-$19-$20-$21},2550,2550
mul 0.1

if $22==1
+median[0] 3
ms_patch_smooth[-1] 10,$1,3,3,0,$2,$3,0,{$1*$4},{$1*$5},{$1*$6},{$1*$7},{$1*$8},{$1*$9},1
endif
if $22==0
+ms_patch_smooth[0] 10,$1,3,3,0,$2,$3,0,{$1*$4},{$1*$5},{$1*$6},{$1*$7},{$1*$8},{$1*$9},1
endif

if $16==1
+compose_grainextract
fft_tile2[-1] $10,$11,3,$13,$14,$15
compose_grainmerge[1,2]
endif
keep[-1]
 mul 9.99
apply_curve 0,0,0,{510-$17},510,{1020-$17-$18},1020,{1530-$17-$18-$19},1530,{2040-$17-$18-$19-$20},2040,{2550-$17-$18-$19-$20-$21},2550,2550,2550
mul 0.1
",7

c 0,255
# #@gui Spot Mask: spot_mask,spot_mask_preview(0)
# #@gui : Spot Size = float (4,1,10)
# #@gui : Threshold = float (80,0,100)
# #@gui : Mask Dilation = int (5,0,10)
# spot_mask:
# to_gray[-1]

# +resize[0] {w/$1},{h/$1},1,3,2
# +iain_pixel_denoise[-1] 1,0
# sub[-1] [-2]
# abs[-1]
# remove[1]

# threshold[-1] $2%
# to_gray[-1]
# dilate_circ[-1] $3
# n 0,255
# resize[-1] {0,w},{0,h},1,3,3
# keep[-1]

# spot_mask_preview:
# +spot_mask $1,$2,$3
# n[-1] 0,255
# add[0] [1]
# keep[0]
# n 0,255

#@gui Fill Holes: fill_holes,fill_holes_preview(0)
#@gui : Morph Radius = int (11,3,50)
#@gui : Edge Radius= int (21,0,50)
#@gui : Close Radius= int (5,0,10)
#@gui : Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Fill Light Colours = bool (0)
#@gui : Fast = bool (1)
#@gui : sep = separator ()
#@gui : note = note("Set Morph radius to close holes, set Edge radius to restore edges, set Close radius to fill small holes near the edge")
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 28 August 2012 - added 'fast' option")

fill_holes:
ac "

if $5==0
 if $6==1
  +dilate[-1] $1
  erode[-1] $2
  compose_lighten
  dilate[-1] $3
  erode[-1] $3
 endif
 if $6==0
  +dilate_circ[-1] $1
  erode_circ[-1] $2
  compose_lighten
  dilate_circ[-1] $3
  erode_circ[-1] $3
 endif
endif
c 0,255

if $5==1
 if $6==1
  +erode[-1] $1
  dilate[-1] $2
  compose_darken
  erode[-1] $3
  dilate[-1] $3
 endif
 if $6==0
  +erode_circ[-1] $1
  dilate_circ[-1] $2
  compose_darken
  erode_circ[-1] $3
  dilate_circ[-1] $3
 endif
endif
c 0,255
",$4

fill_holes_preview:
fill_holes $1,$2,$3,$4,$5,$6


#@gui Automixer: automixer,automixer(0)
#@gui : Output Colour Difference = bool (0)
#@gui : Use Partial Image for Noise Calculation = bool (0)
#@gui : sep = separator ()
#@gui : note = note{"This filter creates a black and white mage with the most pleasant noise characteristics (IMHO). It measures the noise in each colour channel and scales each channel so that the noise levels are even and produces a greyscale output and optionally an extra image with the colour information."}

#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 2012/10/26")
automixer:

to_rgb
+split[-1] c
if $2==1
crop[-1,-2,-3] 40%,40%,60%,60%
endif
bluenoise=${-variance_noise}
remove[-1]
greennoise=${-variance_noise}
remove[-1]
rednoise=${-variance_noise}
remove[-1]

greennoise={$greennoise*0.5}
redadjust={$greennoise/$rednoise}
blueadjust={$greennoise/$bluenoise}

to_rgb
+split[0] c
mul[1] {$redadjust/($redadjust+1+$blueadjust)}
mul[2] {1/($redadjust+1+$blueadjust)}
mul[3] {$blueadjust/($redadjust+1+$blueadjust)}
add[1-3]
if $1==0
keep[-1]
else
+compose_grainextract
remove[0]
endif

# #@gui Noise Reduction 3: nr3,nr3(0)
# #@gui : 1 Strength = float (1,.25,4)
# #@gui : 2 Threshold = float (1,.0,500)
# #@gui : 3 Master Detail Recovery = float (0,0,2000)
# #@gui : 4 Adjust Fine Details = float (0,-500,500)
# #@gui : 5 Adjust Medium Details = float (0,-500,500)
# #@gui : 6 Adjust Large Details = float (0,-500,500)
# #@gui : 7 Enhance Detials = float (1,0,5)
# #@gui : sep = separator ()
# #@gui : note = note("<b> sharpen edges</b>")
# #@gui : 8 Radius = float (.75,.25,5)
# #@gui : 9 Amount = float (1,0,4)
# #@gui : 10 Threshold = float (0,0,5000)
# #@gui : sep = separator ()
# #@gui : note = note("<b> sharpen details</b>")
# #@gui : 11 Radius = float (.75,.25,5)
# #@gui : 12 Amount = float (1,0,4)
# #@gui : 13 Threshold = float (0,0,5000)
# #@gui : sep = separator ()

# #@gui : note = note{"This filter is only intented for and has only been tested on greyscale images." }
# #@gui : note = note{"This filter measures noise in at five different brightnesses, if your preview does not have a full range of brightness shown the preview will not give an accurate indication of the final results."}

# #@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 11 November 2012 - minor quality improvements.")
med3stack16:
blend_median

med5stack16:
blend_median

cross16:
+shift[0] 0,1,0,0,2
+shift[0] 0,-1,0,0,2
+shift[0] 1,0,0,0,2
+shift[0] -1,0,0,0,2
blend_median

ex16:
+shift[0] 1,1,0,0,2
+shift[0] 1,-1,0,0,2
+shift[0] -1,-1,0,0,2
+shift[0] -1,1,0,0,2
blend_median

hybrid16:

+cross16[0]
+ex16[0]
blend_median
autonr2:
+crop 30%,30%,70%,70%
noise0=${-variance_noise}
remove[-1]
cropwidth={w}
cropheight={h}
resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
width={w}
height={h}
 if $noise0>$2
## -hybrid_median[0] 1,0
denoise[-1] 10,{$noise0*$1},3,5,0,1
denoise[-1] 10,{$noise0*$1},3,5,0,1
endif
+resize[0] {$width/2},{$height/2},1,{s},2,1
+resize[-1] $width,$height,1,{s},3,1
sub[0] [-1]
remove[-1]
noise1=${-variance_noise}
if $noise1>$2
denoise[-1] 10,{$noise1*$1},3,5,0,0

endif
+resize[-1] {$width/4},{$height/4},1,{s},2,1
+resize[-1] {$width/2},{$height/2},1,{s},3,1
sub[1] [-1]
remove[-1]
noise2=${-variance_noise}
if $noise2>$2
denoise[-1] 10,{$noise2*$1},3,5,0,1
endif
+resize[-1] {$width/8},{$height/8},1,{s},2,1
+resize[-1] {$width/4},{$height/4},1,{s},3,1
sub[2] [-1]
remove[-1]
noise3=${-variance_noise}
 if $noise3>$2
denoise[-1] 10,{$noise3*$1},3,5,0,1
 endif

 resize[-1] {$width/4},{$height/4},1,{s},3,1
add[-2] [-1]
remove[-1]
resize[-1] {$width/2},{$height/2},1,{s},3,1
add[-2] [-1]
remove[-1]
resize[-1] {$width/1},{$height/1},1,{s},3,1
add[-2] [-1]
remove[-1]

crop 0,0,{$cropwidth-1},{$cropheight-1}

fft_tile3_fft:

+fftpolar[0]
100%,100%,1,1,1
ellipse[-1] 50%,50%,50%,50%,0,1,$4
ellipse[-1] 50%,50%,15%,15%,0,1,$5
ellipse[-1] 50%,50%,5%,5%,0,1,$6

+add[1] [-1]
threshold[-1] $1

## rectangle[-1] 0,0,100%,10%,1,1
## rectangle[-1] 0,90%,100%,100%,1,1

set[-1] 1,50%,50%
mul[1] [-1]
+ifftpolar[1,2]
remove[0,1,2]
keep[-1]

fft_tile3_clean:

tc={round(w/$2)} tr={round(h/$2)}
split_tiles $tc,$tr
repeat $! local[$>]
fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
endlocal done
append_tiles $tc,$tr
c 0,255

fft_tile3:
## fft_tile3_fft  $1,$2,$3,$4,$5,$6
+resize[0] {w+$2},{h+$2},1,1,0,1,1,1
resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,$2,{w-$2-1},{h-$2-1}

#right a bit

push={round($2*1.5)}
pull={$2-$push}

+resize[0] {w+$push},{h+$2},1,1,0,1,1,1
resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}

## Down a bit

+resize[0] {w+$2},{h+$push},1,1,0,1,1,1
resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}

#diagonal 1

dia1={round($2/3)}
dia2={$2-$dia1}

+resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}

#diagonal 2

+resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}

remove[0]

blend_median
## add
## div 5

nr3:
mul 256

radius={0.05*(min(h,w))}
[0]
rectangle[-1] 0,0,100%,$radius,1,{ia}
rectangle[-1] 0,0,$radius,100%,1,{ia}
rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
blur[-1] {$radius/2}
xmin={xm}
ymin={ym}
remove[-1]
+crop[0] {$xmin-$radius},{$ymin-$radius},{$xmin+$radius},{$ymin+$radius}
minnoise=${-variance_noise}
remove[-1]
+sub[0] {250*256}
abs[-1]
rectangle[-1] 0,0,100%,$radius,1,{ia}
rectangle[-1] 0,0,$radius,100%,1,{ia}
rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
blur[-1] {$radius/2}
xmax={xm}
ymax={ym}
+crop[0] {$xmax-$radius},{$ymax-$radius},{$xmax+$radius},{$ymax+$radius}
maxnoise=${-variance_noise}
remove[-1]
+sub[0] {128*256} #{0,ia}
abs[-1]
rectangle[-1] 0,0,100%,$radius,1,{ia}
rectangle[-1] 0,0,$radius,100%,1,{ia}
rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
blur[-1] {$radius/2}
## text[0] $radius,0,0,25,1,{ia}
xave={xm}
yave={ym}
remove[-1]
+crop[0] {$xave-$radius},{$yave-$radius},{$xave+$radius},{$yave+$radius}

midnoise=${-variance_noise}
text[-1] $midnoise,0,0,25,1,{iM}

+sub[0] {64*256} #{0,ia}
abs[-1]

rectangle[-1] 0,0,100%,$radius,1,{ia}
rectangle[-1] 0,0,$radius,100%,1,{ia}
rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
blur[-1] {$radius/2}

xshadow={xm}
yshadow={ym}
remove[-1]
+crop[0] {$xshadow-$radius},{$yshadow-$radius},{$xshadow+$radius},{$yshadow+$radius}

shadownoise=${-variance_noise}

+sub[0] {192*256} #{0,ia}
abs[-1]

rectangle[-1] 0,0,100%,$radius,1,{ia}
rectangle[-1] 0,0,$radius,100%,1,{ia}
rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
blur[-1] {$radius/2}

xbright={xm}
ybright={ym}
remove[-1]
+crop[0] {$xbright-$radius},{$ybright-$radius},{$xbright+$radius},{$ybright+$radius}

brightnoise=${-variance_noise}

## move[2] 6
## move[4] 2
shadows={(($minnoise/$shadownoise)*64)}
mids={(($minnoise/$midnoise)*64)}
brights={(($minnoise/$brightnoise)*64)}
whites={(($minnoise/$maxnoise)*64)}

point1={$shadows+32}
point2={$mids+$shadows+32}
point3={$brights+$mids+$shadows+32}
point4={$whites+$brights+$mids+$shadows+32}

keep[0]
cropwidth={w}
cropheight={h}
resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
width={w}
height={h}
apply_curve[0] 0,0,0,{32*256},{32*256},{96*256},{$point1*256},{160*256},{$point2*256},{223*256},{$point3*256},{287*256},{$point4*256}
## startnoise=${-variance_noise}
sub {128*256} mul .5 add {128*256}
## div 256

+hybrid16[0]

## mul 256
autonr2[-1] $1,$2
## threshold={($startnoise/10)*1000}
autonr2[-1] $1,$2
+sub[0] [1]
add[-1] {128*256}
remove[0]
div[-1] 256

fft_tile3[-1] {2000-$3},48,0,$4,$5,$6,1
mul[-1] 256
sub[-1] {128*256} mul[-1] $7 add[-1] {128*256}
unsharp[0] $8,$9,$10
unsharp[1] $11,$12,$13
sub[1] {128*256}

add[0] [1]
remove[1]

sub {128*256} mul 2 add {128*256}

apply_curve[0] 0,0,0,{32*256},{32*256},{$point1*256},{96*256},{$point2*256},{160*256},{$point3*256},{223*256},{$point4*256},{287*256}
div 256
c 0,255
crop 0,0,{$cropwidth-1},{$cropheight-1}

#@gui Noise Reduction 5: nr5,nr5_preview(0)
#@gui : 1 Luma Denoise = float (1.6,0,10)
#@gui : 2 Colour Denoie = float (5,0,20)
#@gui : sep = separator ()
#@gui : 3 Recover Details = bool(1)
#@gui : 4 Amount = float (1,0.1,10)
#@gui : sep = separator ()
#@gui : note = note("<b> sharpen details</b>")
#@gui : 5 Radius = float (.75,.25,5)
#@gui : 6 Amount = float (3,0,10)
#@gui : 7 Threshold = float (0,0,100)
#@gui : sep = separator ()
#@gui : note = note("<b> sharpen edges</b>")
#@gui : 8 Radius = float (.75,.25,5)
#@gui : 9 Amount = float (.5,0,10)
#@gui : 10 Threshold = float (0,0,100)
#@gui : sep = separator ()
#@gui : note = note("<b>Advanced options</b>")
#@gui : 11 Base Luma Method = choice (1,"Wavelet","Multi-scale patch smoothing","Semi-auto MS patch","Median first MS patch","Multi Scale Median")
#@gui : 12 Chroma Method = choice (1,"Wavelet","Multi-scale patch smoothing")
#@gui : sep = separator ()
#@gui : 13 Adjust Fine Details = float (100,-5000,500)
#@gui : 14 Adjust Medium Details = float (0,-5000,500)
#@gui : 15 Adjust Large Details = float (-100,-5000,500)
#@gui : sep = separator ()
#@gui : Experimental Curves = bool(0)
#@gui : Gamma = float (1.3,.3,2)
#@gui : Show Noise = bool(0)
#@gui : sep = separator ()
#@gui : note = note("Author : <i>Iain Fergusson</i>.      Latest update : 28 November 2012 - added abiltity to view noise")

med3stack16:
blend_median

med5stack16:
blend_median

fft_tile3_fft:

+fftpolar[0]
100%,100%,1,1,1
ellipse[-1] 50%,50%,50%,50%,0,1,$4
ellipse[-1] 50%,50%,15%,15%,0,1,$5
ellipse[-1] 50%,50%,5%,5%,0,1,$6
+add[1] [-1]
threshold[-1] $1
set[-1] 1,50%,50%
mul[1] [-1]
+ifftpolar[1,2]
remove[0,1,2]
keep[-1]

fft_tile3_clean:

tc={round(w/$2)} tr={round(h/$2)}
split_tiles $tc,$tr
repeat $! local[$>]
fft_tile3_fft[0--1] $1,$2,$3,$4,$5,$6
endlocal done
append_tiles $tc,$tr
c 0,255

fft_tile3:

## fft_tile3_fft  $1,$2,$3,$4,$5,$6
+resize[0] {w+$2},{h+$2},1,1,0,1,1,1
resize[-1] {w+$2},{h+$2},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,$2,{w-$2-1},{h-$2-1}

if $8>2
#right a bit

push={round($2*1.5)}
pull={$2-$push}

+resize[0] {w+$push},{h+$2},1,1,0,1,1,1
resize[-1] {w+$pull},{h+$2},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$push},{$2},{w-$pull-1},{h-($2)-1}

## Down a bit

+resize[0] {w+$2},{h+$push},1,1,0,1,1,1
resize[-1] {w+$2},{h+$pull},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] $2,{$push},{w-$2-1},{h-$pull-1}
endif
if $8>1
#diagonal 1

dia1={round($2/3)}
dia2={$2-$dia1}

+resize[0] {w+$dia1},{h+$dia1},1,1,0,1,1,1
resize[-1] {w+$dia2},{h+$dia2},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia1},{$dia1},{w-$dia2-1},{h-$dia2-1}

#diagonal 2

+resize[0] {w+$dia2},{h+$dia2},1,1,0,1,1,1
resize[-1] {w+$dia1},{h+$dia1},1,1,0,1,0,0
fft_tile3_clean[-1] $1,$2,$3,$4,$5,$6
crop[-1] {$dia2},{$dia2},{w-$dia1-1},{h-$dia1-1}
endif
remove[0]
if $8==3
blend_median
endif
if $8==2
blend_median
endif

nr5:
luma_strength=$1
colour_strength=$2
recovery=$3
detail_recovery={5000-($4*500)}
fine_detials=$13
medium_detials=$14
large_details=$15
detail_radius=$5
detail_amount=$6
detail_threshold=$7
edge_radius=$8
edge_amount=$9
edge_threshold=$10
quality=3

if $16==1
 mul[0] 256
 radius={0.05*(min(h,w))}
 [0]
 rectangle[-1] 0,0,100%,$radius,1,{ia}
 rectangle[-1] 0,0,$radius,100%,1,{ia}
 rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
 rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
 blur[-1] {$radius/2}
 xmin={xm}
 ymin={ym}
 remove[-1]
 +crop[0] {$xmin-$radius},{$ymin-$radius},{$xmin+$radius},{$ymin+$radius}
 minnoise=${-variance_noise}
 remove[-1]
 +sub[0] {250*256}
 abs[-1]
 rectangle[-1] 0,0,100%,$radius,1,{ia}
 rectangle[-1] 0,0,$radius,100%,1,{ia}
 rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
 rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
 blur[-1] {$radius/2}
 xmax={xm}
 ymax={ym}
 +crop[0] {$xmax-$radius},{$ymax-$radius},{$xmax+$radius},{$ymax+$radius}
 maxnoise=${-variance_noise}
 remove[-1]
 +sub[0] {128*256} #{0,ia}
 abs[-1]
 rectangle[-1] 0,0,100%,$radius,1,{ia}
 rectangle[-1] 0,0,$radius,100%,1,{ia}
 rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
 rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
 blur[-1] {$radius/2}

 xave={xm}
 yave={ym}
 remove[-1]
 +crop[0] {$xave-$radius},{$yave-$radius},{$xave+$radius},{$yave+$radius}

 midnoise=${-variance_noise}
 text[-1] $midnoise,0,0,25,1,{iM}

 +sub[0] {64*256} #{0,ia}
 abs[-1]

 rectangle[-1] 0,0,100%,$radius,1,{ia}
 rectangle[-1] 0,0,$radius,100%,1,{ia}
 rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
 rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
 blur[-1] {$radius/2}

 xshadow={xm}
 yshadow={ym}
 remove[-1]
 +crop[0] {$xshadow-$radius},{$yshadow-$radius},{$xshadow+$radius},{$yshadow+$radius}

 shadownoise=${-variance_noise}

 +sub[0] {192*256} #{0,ia}
 abs[-1]

 rectangle[-1] 0,0,100%,$radius,1,{ia}
 rectangle[-1] 0,0,$radius,100%,1,{ia}
 rectangle[-1] 0,100%,100%,{h-$radius},1,{ia}
 rectangle[-1] {w-$radius},100%,100%,0,1,{ia}
 blur[-1] {$radius/2}

 xbright={xm}
 ybright={ym}
 remove[-1]
 +crop[0] {$xbright-$radius},{$ybright-$radius},{$xbright+$radius},{$ybright+$radius}

 brightnoise=${-variance_noise}

 shadows={(($minnoise/$shadownoise)*64)}
 mids={(($minnoise/$midnoise)*64)}
 brights={(($minnoise/$brightnoise)*64)}
 whites={(($minnoise/$maxnoise)*64)}

 point1={$shadows+32}
 point2={$mids+$shadows+32}
 point3={$brights+$mids+$shadows+32}
 point4={$whites+$brights+$mids+$shadows+32}

 keep[0]
 ## cropwidth={w}
 ## cropheight={h}
 ## resize[0] {w+(64-w%64)},{h+(64-h%64)},1,{s},0,1
 ## width={w}
 ## height={h}
 apply_curve[0] 0,0,0,{32*256},{32*256},{96*256},{$point1*256},{160*256},{$point2*256},{223*256},{$point3*256},{287*256},{$point4*256}
 div[0] 256
else
 apply_gamma {1/$17}
endif
rgb2ycbcr
split c
if $1>0
## +denoise_haar[0] $luma_strength,0,{$quality*20}
## remove[0]
if $11==0
+denoise_haar[0] $luma_strength,0,{$quality*10}
endif
if $11==1
+ms_patch[0] 10,{$luma_strength*2.5},3,5,0,1,1,0,{$luma_strength*.75},{$luma_strength*.5},{$luma_strength*0},{$luma_strength*0},1,1,1,0
endif
if $11==2
+autonr2[0] $luma_strength,1
endif
if $11==3
+median[0] 3
ms_patch[-1] 10,{$luma_strength*2.5},3,5,0,1,1,0,{$luma_strength*.75},{$luma_strength*.5},{$luma_strength*0},{$luma_strength*0},1,1,1,0
endif
if $11==4
+msmed2[0] 3
repeat $1
msmed2[-1] 3
done
endif
+sub[0] [-1]
add[-1] {128}
remove[0]
if $recovery==1
resize[-1] {w+48},{h+48},{d},{s},0,0,0,0
resize[-1] {w+48},{h+48},{d},{s},0,0,1,1
rectangle[-1] 0,0,100%,48,1,128
rectangle[-1] 0,0,48,100%,1,128
rectangle[-1] 0,100%,100%,{h-48},1,128
rectangle[-1] {w-48},100%,100%,0,1,128
fft_tile3[-1] {$detail_recovery},48,0,$fine_detials,$medium_detials,$large_details,1,$quality
crop[-1] 48,48,{w-49},{h-49}
else
fill[-1] 128
endif
unsharp[-1] $detail_radius,$detail_amount,$detail_threshold
unsharp[2] $edge_radius,$edge_amount,$edge_threshold
sub[-1] {128}
add[2] [-1]
remove[-1]
else
move[0] 3
endif
if $2>0
 median[0,1] 3
 median[0,1] 3
 if $12==1
  ms_patch[0] 10,1,3,5,0,1,1,0,{$colour_strength*1},{$colour_strength*.5},{$colour_strength*.25},{$colour_strength*0},0,1,1,0
  ms_patch[1] 10,1,3,5,0,1,1,0,{$colour_strength*1},{$colour_strength*.5},{$colour_strength*.25},{$colour_strength*0},0,1,1,0
 endif
 if $12==0
  denoise_haar[0] $colour_strength,0,{$quality*3}
  denoise_haar[1] $colour_strength,0,{$quality*3}
 endif

endif

move[-1] 0
append c
ycbcr2rgb
if 16==1
 mul[0] 256
 apply_curve[0] 0,0,0,{32*256},{32*256},{$point1*256},{96*256},{$point2*256},{160*256},{$point3*256},{223*256},{$point4*256},{287*256}
 ## n 0,{256*256}
 div[0] 256
 else
apply_gamma $17
endif
c 0,255
ms_patch_smoothing:
ac "repeat $7 denoise $1,$2,$3,$4,$5,$6 done",$8,0 c 0,255

ms_patch_2:
+resize[0] 50%,50%,1,{s},2   ## create smaller image
+ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8   ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]
c 0,255

ms_patch_3:
+resize[0] 25%,25%,1,{s},2   ## create smaller image
+ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8    ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
## resize[2] {w},{h},1,3,5  ## Resize clean to image size
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]
c 0,255

ms_patch_4:
+resize[0] 12.5%,12.5%,1,{s},2   ## create smaller image
+ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8   ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
## resize[2] {w},{h},1,3,5  ## Resize clean to image size
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]
c 0,255

ms_patch_5:
+resize[0] 6.125%,6.125%,1,{s},2   ## create smaller image
+ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8    ## clean smaller image
+resize[1] {0,w},{0,h},1,{s},5  ## Resize smaller image to image[0] size
+sub[0] [3]     ## Get HF
## resize[2] {w},{h},1,3,5  ## Resize clean to image size
resize[2] {0,w},{0,h},1,{s},5  ## Resize clean to image[0] size
+add[2] [4]     ## Merge HF
keep[-1]
c 0,255

ms_patch:
## resize[0] {w+(60-w%60)},{h+(60-h%60)},1,3,0,1
apply_gamma {1/$14}


repeat $15

if $13==1
ms_patch_smoothing[-1] $1,$2,$3,$4,$5,$6,$7,$8
endif
if $9>0.1
ms_patch_2 $1,$9,$3,$4,$5,$6,$7,$8
endif
if $10>0.1
ms_patch_3 $1,$10,$3,$4,$5,$6,$7,$8
endif
if $11>0.1
ms_patch_4 $1,$11,$3,$4,$5,$6,$7,$8
endif
if $12>0.1
ms_patch_5 $1,$12,$3,$4,$5,$6,$7,$8
endif
done
apply_gamma $14

c 0,255

msmed2:
medlvl2=2
medlvl3=3
medlvl4=4
medlvl5=6
medlvl6=6
medlvl7=7
## split c
## keep[0]

median $1

median $1

name[0] full

+resize[full] {full,w/$medlvl2},{full,h/$medlvl2},1,{s},2
name[-1] level2
+resize[level2] {0,w},{0,h},1,{s},3,1
name[-1] low2
+compose_grainextract[full,low2]
name[-1] level2high
remove[low2]

median[level2] $1

median[level2] $1

name[1] level2

+resize[level2] {full,w/$medlvl3},{full,h/$medlvl3},1,{s},2
name[-1] level3
+resize[level3] {level2,w},{level2,h},1,{s},3,1
name[-1] low3
+compose_grainextract[level2,low3]
name[-1] level3high
remove[1,low3]
median[2] $1

median[2] $1

name[2] level3

+resize[level3] {full,w/$medlvl4},{full,h/$medlvl4},1,{s},2
name[-1] level4
+resize[level4] {level3,w},{level3,h},1,{s},3,1
name[-1] low4
+compose_grainextract[level3,low4]
name[-1] level4high
remove[2,low4]

median[-2] $1

median[-2] $1

#rebuild

 name[-2] base

 resize[base] {level4high,w},{level4high,h},1,{s},3,1
compose_grainmerge[-1,-2]

name[-1] base

resize[base] {level3high,w},{level3high,h},1,{s},3,1
compose_grainmerge[-1,-2]

resize[-1] {full,w},{full,h},1,{s},3,1
compose_grainmerge[-1,-2]

keep[-1]
nr5_preview:
if $-1==0
nr5 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
endif
if $-1==1
+nr5 $1,$2,$3,$4,$5,0,$7,$8,0,$10,$11,$12,$13,$14,$15,$16,$17
sub[0] [1]
keep[0]
mul 2
add 128
endif

#@gui Multi Scale Smoothing: ms_smooth,ms_smooth_preview(0)
#@gui : Smooth Scale 1 = float (0,0,100)
#@gui : Smooth Scale 2 = float (0,0,100)
#@gui : Smooth Scale 3 = float (0,0,100)
#@gui : Smooth Scale 4 = float (0,0,100)
#@gui : Smooth Scale 5 = float (0,0,100)
#@gui : Smooth Scale 6 = float (0,0,100)
#@gui : Smoothness = float (2,0,15)
#@gui : Log Scales= bool (0)
#@gui : Global Repeats = int (2,0,5)
#@gui : Show Difference = bool (0)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 7 Dec 2012")

ms_smoothsmoothing:
## sd $1,$2
smooth {$1*5},0.7,0.7,0.6,$2,0.8,30,2,0,1
## corner_median
## median 3

ms_smooth:
if $8==0
lvl2=2
lvl3=3
lvl4=4
lvl5=5
lvl6=6
endif

if $8==1
lvl2=2
lvl3=4
lvl4=8
lvl5=16
lvl6=32
endif

repeat $9

if $1>0
 ms_smoothsmoothing[-1] $1,$7
endif
name[0] full
+resize[full] {full,w/$lvl2},{full,h/$lvl2},1,{s},2 name[1] level2
if $2>0
 +ms_smoothsmoothing[level2]  $2,$7
else [level2]
endif
 name[2] level2clean

+resize[level2] {0,w},{0,h},1,{s},5  name[3] low2
+sub[full] [low2]  name[4] level2high
remove[level2,low2]

## 0-full, 1-level2clean, 2-level2high

+resize[level2clean] {full,w/$lvl3},{full,h/$lvl3},1,{s},2 name[3] level3
if $3>0
 +ms_smoothsmoothing[level3] $3,$7
 else [level3]
endif
  name[4] level3clean
+resize[level3] {level2clean,w},{level2clean,h},1,{s},5  name[5] low3
+sub[level2clean] [low3]  name[6] level3high
remove[level3,low3]

## 0-full, 1-level2clean, 2-level2high, 3-level3clean, 4-level3high

+resize[level3clean] {full,w/$lvl4},{full,h/$lvl4},1,{s},2 name[5] level4
if $4>0
 +ms_smoothsmoothing[level4] $4,$7
 else [level4]
endif
   name[6] level4clean
+resize[level4] {level3clean,w},{level3clean,h},1,{s},5  name[7] low4
+sub[level3clean] [low4]  name[8] level4high
remove[level4,low4]

## 0-full, 1-level2clean, 2-level2high, 3-level3clean, 4-level3high, 5-level4clean, 6-level4high

+resize[level4clean] {full,w/$lvl5},{full,h/$lvl5},1,{s},2 name[-1] level5

if $5>0
 +ms_smoothsmoothing[level5] $5,$7
 else [level5]
endif
  name[-1] level5clean
+resize[level5] {level4clean,w},{level4clean,h},1,{s},5  name[-1] low5
+sub[level4clean] [low5]  name[-1] level5high
remove[level5,low5]

+resize[level5clean] {full,w/$lvl6},{full,h/$lvl6},1,{s},2 name[-1] level6

if $6>0
 +ms_smoothsmoothing[level6]  $6,$7
else [level6]
endif
name[-1] level6clean
+resize[level6] {level5clean,w},{level5clean,h},1,{s},5  name[-1] low6
+sub[level5clean] [low6]  name[-1] level6high
remove[level6,low6]
## ##### rebuild
name[-2] base

resize[base] {level6high,w},{level6high,h},1,{s},5
add[base] [level6high]
remove[level6high]

resize[base] {level5high,w},{level5high,h},1,{s},5
add[base] [level5high]
remove[level5high]

resize[base] {level4high,w},{level4high,h},1,{s},5
add[base] [level4high]
remove[level4high]

resize[base] {level3high,w},{level3high,h},1,{s},5
add[base] [level3high]
remove[level3high]

resize[base] {level2high,w},{level2high,h},1,{s},5
add[base] [level2high]
remove[level2high]

keep[-1]
c 0,255


c 0,255
done
ms_smooth_preview:

if $-1==0
ms_smooth $1,$2,$3,$4,$5,$6,$7,$8,$9
endif
if $-1==1
+ms_smooth $1,$2,$3,$4,$5,$6,$7,$8,$9
sub[0] [1]
keep[0]
mul 2
add 128
endif

#@gui Simple Local Contrast: simplelocalcontrast_p,simplelocalcontrast_p(0)
#@gui : Edge Sensitivity = float (16,0,25)
#@gui : Iterations = int (2,1,5)
#@gui : Paint Effect = float (0,0,50)
#@gui : Channels = choice (1,"Colour","Luminance Only")
#@gui : Pre-Gamma = float (1,.1,5)
#@gui : Post-Gamma = float (1,.1,5)
#@gui : sep = separator ()
#@gui : note = note("<small><b>Luminance Mask</b></small>" )
#@gui : Blacks = float (1,0,1)
#@gui : Dark Grey = float (1,0,1)
#@gui : Mid Grey = float (1,0,1)
#@gui : Light Grey = float (1,0,1)
#@gui : Whites = float (1,0,1)
#@gui : sep = separator ()
#@gui : Parallel Processing = choice (0,"Auto","None")
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 18 April 2014 - added parallel processing and luminance mask")
simplelocalcontrast_p:
to_rgb
[0]
apply_parallel_overlap[1] "
simplelocalcontrast[0] ${1-6}",{30+$3},$12
+luminance[-1]
apply_curve[-1] 0,0,$7,64,$8,128,$9,196,$10,255,$11

mul[-1] 255
append[1,2] c
 blend alpha,1,0
simplelocalcontrast:
str1=$1
str2={$str1*0.7}
str3={$str2*0.7}
str4={$str3*0.7}
str5={$str4*0.7}
str6={$str5*0.7}
str7={$str6*0.7}
str8={$str7*0.7}

apply_gamma $5
conttest4 $4,$str1,$str2,$str3,$str4,$str5,$str6,$str7,$str8,$2,$3,$3,$3,$3,$3,$3,2,1
apply_gamma $6
n 0,255
conttest4:
to_rgb
if $1==1
+luminance
+smoothbase4[-1] $2,$3,$4,$5,$6,$7,$8,$9,$10
+compose_grainextract[-1,-2]
ms_smooth[-1] $11,$12,$13,$14,$15,$16,$17,$18,1
remove[1,2]
sub[-1] 128 mul[-1] 2 add[-1] 128
+compose_grainmerge
remove[0,1]
else
+smoothbase4 $2,$3,$4,$5,$6,$7,$8,$9,$10
+compose_grainextract
ms_smooth[-1] $11,$12,$13,$14,$15,$16,$17,$18,1
remove[1]
sub[-1] 128 mul[-1] 2 add[-1] 128
+compose_grainmerge
remove[1]
rgb2hsv
split c
remove[1,2,3]
append c
hsv2rgb
endif

smoothbase4:

repeat $9
cropwidth={w}
cropheight={h}
resize[0] {w+(256-w%256)},{h+(256-h%256)},1,{s},0,1
width={w}
height={h}
if $1!=0
denoise[0] 10,$1,3,5,0,1
endif
+resize[0] {$width/2},{$height/2},1,{s},2,1
+resize[-1] $width,$height,1,{s},3,1
blur[-1] .5
compose_grainextract[0,-1]
if $2!=0
denoise[-1] 10,$2,3,5,0,1
endif
+resize[-1] {$width/4},{$height/4},1,{s},2,1
+resize[-1] {$width/2},{$height/2},1,{s},3,1
blur[-1] .5
compose_grainextract[1,-1]
if $3!=0
denoise[-1] 10,$3,3,5,0,1
endif
+resize[-1] {$width/8},{$height/8},1,{s},2,1
+resize[-1] {$width/4},{$height/4},1,{s},3,1
blur[-1] .5
compose_grainextract[2,-1]
if $4!=0
denoise[-1] 10,$4,3,5,0,1
endif
+resize[-1] {$width/16},{$height/16},1,{s},2,1
+resize[-1] {$width/8},{$height/8},1,{s},3,1
blur[-1] .5
compose_grainextract[3,-1]
if $5!=0
denoise[-1] 10,$5,3,5,0,1
endif
+resize[-1] {$width/32},{$height/32},1,{s},2,1
+resize[-1] {$width/16},{$height/16},1,{s},3,1
blur[-1] .5
compose_grainextract[4,-1]
if $6!=0
denoise[-1] 10,$6,3,5,0,1
endif
+resize[-1] {$width/64},{$height/64},1,{s},2,1
+resize[-1] {$width/32},{$height/32},1,{s},3,1
blur[-1] .5
compose_grainextract[5,-1]

if $7!=0
denoise[-1] 10,$7,3,5,0,1
endif
+resize[-1] {$width/128},{$height/128},1,{s},2,1
+resize[-1] {$width/64},{$height/64},1,{s},3,1
blur[-1] .5
compose_grainextract[6,-1]

if $8!=0
denoise[-1] 10,$8,3,5,0,1
endif
+resize[-1] {$width/256},{$height/256},1,{s},2,1
+resize[-1] {$width/128},{$height/128},1,{s},3,1
blur[-1] .5
compose_grainextract[7,-1]

resize[-1] {$width/128},{$height/128},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/64},{$height/64},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/32},{$height/32},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/16},{$height/16},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/8},{$height/8},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/4},{$height/4},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/2},{$height/2},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/1},{$height/1},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
crop 0,0,{$cropwidth-1},{$cropheight-1}
done

#@gui Easy Skin Retouch: iain_easy_skin_retouch,iain_easy_skin_retouch_preview(0)
#@gui : note = note("<b>Base Smoothing</b>")
#@gui : Edge Sensitivity = float (7,0,25)
#@gui : Iterations = int (2,1,5)
#@gui : Low Bias = float(.7,0,1)
#@gui : sep = separator ()
#@gui : note = note("<b>Detail Intensity</b>")
#@gui : note = note("If preview appears dark, increase size of preview window.")
#@gui : On = bool(1)
#@gui : Very Fine  = float (1,0,2)
#@gui : Fine 2 = float (.7,0,2)
#@gui : Medium 3 = float (.6,0,2)
#@gui : Course 4 = float (.5,0,2)
#@gui : Very Course 5 = float (.5,0,2)
#@gui : Reduce Redness = float (.5,0,1)
#@gui : sep = separator ()
#@gui : Split Base and Detail Output = bool(0)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - update 12 May 2013 - now handles alpha channel and some internal changes")
iain_easy_skin_retouch:

repeat $! l[$>] split_opacity l[0]
str1=$1
str2={$str1*$3}
str3={$str2*$3}
str4={$str3*$3}
str5={$str4*$3}
str6={$str5*$3}
str7={$str6*$3}
str8={$str7*$3}

+l[0]
repeat $2
cropwidth={w}
cropheight={h}
resize[0] {w+(256-w%256)},{h+(256-h%256)},1,{s},0,1
width={w}
height={h}
if $str1!=0
denoise[0] 10,$str1,3,5,0,1
endif
+resize[0] {$width/2},{$height/2},1,{s},2,1
+resize[-1] $width,$height,1,{s},3,1
blur[-1] .5
compose_grainextract[0,-1]
if $str2!=0
denoise[-1] 10,$str2,3,5,0,1
endif
+resize[-1] {$width/4},{$height/4},1,{s},2,1
+resize[-1] {$width/2},{$height/2},1,{s},3,1
blur[-1] .5
compose_grainextract[1,-1]
if $str3!=0
denoise[-1] 10,$str3,3,5,0,1
endif
+resize[-1] {$width/8},{$height/8},1,{s},2,1
+resize[-1] {$width/4},{$height/4},1,{s},3,1
blur[-1] .5
compose_grainextract[2,-1]
if $str4!=0
denoise[-1] 10,$str4,3,5,0,1
endif
+resize[-1] {$width/16},{$height/16},1,{s},2,1
+resize[-1] {$width/8},{$height/8},1,{s},3,1
blur[-1] .5
compose_grainextract[3,-1]
if $str5!=0
denoise[-1] 10,$str5,3,5,0,1
endif
+resize[-1] {$width/32},{$height/32},1,{s},2,1
+resize[-1] {$width/16},{$height/16},1,{s},3,1
blur[-1] .5
compose_grainextract[4,-1]
if $str6!=0
denoise[-1] 10,$str6,3,5,0,1
endif
+resize[-1] {$width/64},{$height/64},1,{s},2,1
+resize[-1] {$width/32},{$height/32},1,{s},3,1
blur[-1] .5
compose_grainextract[5,-1]

if $str7!=0
denoise[-1] 10,$str7,3,5,0,1
endif
+resize[-1] {$width/128},{$height/128},1,{s},2,1
+resize[-1] {$width/64},{$height/64},1,{s},3,1
blur[-1] .5
compose_grainextract[6,-1]

if $str8!=0
denoise[-1] 10,$str8,3,5,0,1
endif
+resize[-1] {$width/256},{$height/256},1,{s},2,1
+resize[-1] {$width/128},{$height/128},1,{s},3,1
blur[-1] .5
compose_grainextract[7,-1]

resize[-1] {$width/128},{$height/128},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/64},{$height/64},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/32},{$height/32},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/16},{$height/16},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/8},{$height/8},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/4},{$height/4},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/2},{$height/2},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
resize[-1] {$width/1},{$height/1},1,{s},3,1
blur[-1] .5
compose_grainmerge[-1,-2]
crop 0,0,{$cropwidth-1},{$cropheight-1}
done
endl

if $4==1
+compose_grainextract[0,-1]
+rgb2hsv8[-1]
split[-1] c
remove[-1,-2]
add[-1] 30
mod[-1] 255
ge[-1]  40
n[-1] 0,255
negate[-1]
blur[-1] 4
+split[-2] c
remove[-1,-2]
move[-1] -2
append[-2,-1] c
+blend[-1,-2] alpha
remove[-2]
mul[-1] {$10}
mul[-2] {1-$10}
add[-1] [-2]
remove[-2]

l[-1]
+fftpolar[0]
100%,100%,1,1,1
ellipse[-1] 50%,50%,50%,50%,0,1,$5
ellipse[-1] 50%,50%,25%,25%,0,1,$6
ellipse[-1] 50%,50%,12%,12%,0,1,$7
ellipse[-1] 50%,50%,6%,6%,0,1,$8
ellipse[-1] 50%,50%,3%,3%,0,1,$9
ellipse[-1] 50%,50%,0.1%,0.1%,0,1,1
set[-1] 1,50%,50%
mul[1] [-1]
ifftpolar[1,2]
keep[1]
c 0,255
endl
remove[0]
if $11==0
compose_grainmerge[-1,-2]
endif
else
keep[-1]
endif
endl a c endl done
iain_easy_skin_retouch_preview:
iain_easy_skin_retouch ${1--1}
#@gui Iain Unindex: iain_unindex,iain_unindex_preview(0)
#@gui : Smooth = float (30,0,100)
#@gui : Edge Threshold = float (20,0,50)
#@gui : Preview Zoom = bool(1)
#@gui : Zoom Center H = float(50,0,100)
#@gui : Zoom Center V = float(50,0,100)
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - released 19 Feb 2013")

iain_unindex:
amplitude=$1
sharpness=.3
anisotropy=1
gradient_smoothness=.6
tensor_smoothness=1
spatial_precision=0.8
angular_precision=30
value_precision=2
interpolation=0
fast_approx=1
to_rgb
+smooth[0] $amplitude,$sharpness,$anisotropy,$gradient_smoothness,$tensor_smoothness,$spatial_precision,$angular_precision,$value_precision,$interpolation,$fast_approx
+luminance[-1]
## blur[-1] 1.5
laplacian[-1]
abs[-1]
blur[-1] .5
threshold[-1] $2
mul[-1] -1
add[-1] 1
mul[-1] 255
append[1,2] c
blend alpha,1,0
keep[-1]
iain_unindex_preview:
iain_unindex $1,$2
if $3==1
topleftx={$4-25}
toplefty={$5-25}
botleftx={$4+25}
botlefty={$5+25}
crop $topleftx%,$toplefty%,$botleftx%,$botlefty%
endif
#@gui Fast Formula: iain_fast_formula, iain_fast_formula
#@gui : Apply Formula = text("apply_gamma 2.2")

iain_fast_formula:
256,1
fill[-1] x
local[1]
$1
endlocal

crv0={1,[0]}
crv1={1,[1]}
crv2={1,[2]}
crv3={1,[3]}
crv4={1,[4]}
crv5={1,[5]}
crv6={1,[6]}
crv7={1,[7]}
crv8={1,[8]}
crv9={1,[9]}
crv10={1,[10]}
crv11={1,[11]}
crv12={1,[12]}
crv13={1,[13]}
crv14={1,[14]}
crv15={1,[15]}
crv16={1,[16]}
crv17={1,[17]}
crv18={1,[18]}
crv19={1,[19]}
crv20={1,[20]}
crv21={1,[21]}
crv22={1,[22]}
crv23={1,[23]}
crv24={1,[24]}
crv25={1,[25]}
crv26={1,[26]}
crv27={1,[27]}
crv28={1,[28]}
crv29={1,[29]}
crv30={1,[30]}
crv31={1,[31]}
crv32={1,[32]}
crv33={1,[33]}
crv34={1,[34]}
crv35={1,[35]}
crv36={1,[36]}
crv37={1,[37]}
crv38={1,[38]}
crv39={1,[39]}
crv40={1,[40]}
crv41={1,[41]}
crv42={1,[42]}
crv43={1,[43]}
crv44={1,[44]}
crv45={1,[45]}
crv46={1,[46]}
crv47={1,[47]}
crv48={1,[48]}
crv49={1,[49]}
crv50={1,[50]}
crv51={1,[51]}
crv52={1,[52]}
crv53={1,[53]}
crv54={1,[54]}
crv55={1,[55]}
crv56={1,[56]}
crv57={1,[57]}
crv58={1,[58]}
crv59={1,[59]}
crv60={1,[60]}
crv61={1,[61]}
crv62={1,[62]}
crv63={1,[63]}
crv64={1,[64]}
crv65={1,[65]}
crv66={1,[66]}
crv67={1,[67]}
crv68={1,[68]}
crv69={1,[69]}
crv70={1,[70]}
crv71={1,[71]}
crv72={1,[72]}
crv73={1,[73]}
crv74={1,[74]}
crv75={1,[75]}
crv76={1,[76]}
crv77={1,[77]}
crv78={1,[78]}
crv79={1,[79]}
crv80={1,[80]}
crv81={1,[81]}
crv82={1,[82]}
crv83={1,[83]}
crv84={1,[84]}
crv85={1,[85]}
crv86={1,[86]}
crv87={1,[87]}
crv88={1,[88]}
crv89={1,[89]}
crv90={1,[90]}
crv91={1,[91]}
crv92={1,[92]}
crv93={1,[93]}
crv94={1,[94]}
crv95={1,[95]}
crv96={1,[96]}
crv97={1,[97]}
crv98={1,[98]}
crv99={1,[99]}
crv100={1,[100]}
crv101={1,[101]}
crv102={1,[102]}
crv103={1,[103]}
crv104={1,[104]}
crv105={1,[105]}
crv106={1,[106]}
crv107={1,[107]}
crv108={1,[108]}
crv109={1,[109]}
crv110={1,[110]}
crv111={1,[111]}
crv112={1,[112]}
crv113={1,[113]}
crv114={1,[114]}
crv115={1,[115]}
crv116={1,[116]}
crv117={1,[117]}
crv118={1,[118]}
crv119={1,[119]}
crv120={1,[120]}
crv121={1,[121]}
crv122={1,[122]}
crv123={1,[123]}
crv124={1,[124]}
crv125={1,[125]}
crv126={1,[126]}
crv127={1,[127]}
crv128={1,[128]}
crv129={1,[129]}
crv130={1,[130]}
crv131={1,[131]}
crv132={1,[132]}
crv133={1,[133]}
crv134={1,[134]}
crv135={1,[135]}
crv136={1,[136]}
crv137={1,[137]}
crv138={1,[138]}
crv139={1,[139]}
crv140={1,[140]}
crv141={1,[141]}
crv142={1,[142]}
crv143={1,[143]}
crv144={1,[144]}
crv145={1,[145]}
crv146={1,[146]}
crv147={1,[147]}
crv148={1,[148]}
crv149={1,[149]}
crv150={1,[150]}
crv151={1,[151]}
crv152={1,[152]}
crv153={1,[153]}
crv154={1,[154]}
crv155={1,[155]}
crv156={1,[156]}
crv157={1,[157]}
crv158={1,[158]}
crv159={1,[159]}
crv160={1,[160]}
crv161={1,[161]}
crv162={1,[162]}
crv163={1,[163]}
crv164={1,[164]}
crv165={1,[165]}
crv166={1,[166]}
crv167={1,[167]}
crv168={1,[168]}
crv169={1,[169]}
crv170={1,[170]}
crv171={1,[171]}
crv172={1,[172]}
crv173={1,[173]}
crv174={1,[174]}
crv175={1,[175]}
crv176={1,[176]}
crv177={1,[177]}
crv178={1,[178]}
crv179={1,[179]}
crv180={1,[180]}
crv181={1,[181]}
crv182={1,[182]}
crv183={1,[183]}
crv184={1,[184]}
crv185={1,[185]}
crv186={1,[186]}
crv187={1,[187]}
crv188={1,[188]}
crv189={1,[189]}
crv190={1,[190]}
crv191={1,[191]}
crv192={1,[192]}
crv193={1,[193]}
crv194={1,[194]}
crv195={1,[195]}
crv196={1,[196]}
crv197={1,[197]}
crv198={1,[198]}
crv199={1,[199]}
crv200={1,[200]}
crv201={1,[201]}
crv202={1,[202]}
crv203={1,[203]}
crv204={1,[204]}
crv205={1,[205]}
crv206={1,[206]}
crv207={1,[207]}
crv208={1,[208]}
crv209={1,[209]}
crv210={1,[210]}
crv211={1,[211]}
crv212={1,[212]}
crv213={1,[213]}
crv214={1,[214]}
crv215={1,[215]}
crv216={1,[216]}
crv217={1,[217]}
crv218={1,[218]}
crv219={1,[219]}
crv220={1,[220]}
crv221={1,[221]}
crv222={1,[222]}
crv223={1,[223]}
crv224={1,[224]}
crv225={1,[225]}
crv226={1,[226]}
crv227={1,[227]}
crv228={1,[228]}
crv229={1,[229]}
crv230={1,[230]}
crv231={1,[231]}
crv232={1,[232]}
crv233={1,[233]}
crv234={1,[234]}
crv235={1,[235]}
crv236={1,[236]}
crv237={1,[237]}
crv238={1,[238]}
crv239={1,[239]}
crv240={1,[240]}
crv241={1,[241]}
crv242={1,[242]}
crv243={1,[243]}
crv244={1,[244]}
crv245={1,[245]}
crv246={1,[246]}
crv247={1,[247]}
crv248={1,[248]}
crv249={1,[249]}
crv250={1,[250]}
crv251={1,[251]}
crv252={1,[252]}
crv253={1,[253]}
crv254={1,[254]}
crv255={1,[255]}

apply_curve[0] 0,0,$crv0,1,$crv1,2,$crv2,3,$crv3,4,$crv4,5,$crv5,6,$crv6,7,$crv7,8,$crv8,9,$crv9,10,$crv10,11,$crv11,12,$crv12,13,$crv13,14,$crv14,15,$crv15,16,$crv16,17,$crv17,18,$crv18,19,$crv19,20,$crv20,21,$crv21,22,$crv22,23,$crv23,24,$crv24,25,$crv25,26,$crv26,27,$crv27,28,$crv28,29,$crv29,30,$crv30,31,$crv31,32,$crv32,33,$crv33,34,$crv34,35,$crv35,36,$crv36,37,$crv37,38,$crv38,39,$crv39,40,$crv40,41,$crv41,42,$crv42,43,$crv43,44,$crv44,45,$crv45,46,$crv46,47,$crv47,48,$crv48,49,$crv49,50,$crv50,51,$crv51,52,$crv52,53,$crv53,54,$crv54,55,$crv55,56,$crv56,57,$crv57,58,$crv58,59,$crv59,60,$crv60,61,$crv61,62,$crv62,63,$crv63,64,$crv64,65,$crv65,66,$crv66,67,$crv67,68,$crv68,69,$crv69,70,$crv70,71,$crv71,72,$crv72,73,$crv73,74,$crv74,75,$crv75,76,$crv76,77,$crv77,78,$crv78,79,$crv79,80,$crv80,81,$crv81,82,$crv82,83,$crv83,84,$crv84,85,$crv85,86,$crv86,87,$crv87,88,$crv88,89,$crv89,90,$crv90,91,$crv91,92,$crv92,93,$crv93,94,$crv94,95,$crv95,96,$crv96,97,$crv97,98,$crv98,99,$crv99,100,$crv100,101,$crv101,102,$crv102,103,$crv103,104,$crv104,105,$crv105,106,$crv106,107,$crv107,108,$crv108,109,$crv109,110,$crv110,111,$crv111,112,$crv112,113,$crv113,114,$crv114,115,$crv115,116,$crv116,117,$crv117,118,$crv118,119,$crv119,120,$crv120,121,$crv121,122,$crv122,123,$crv123,124,$crv124,125,$crv125,126,$crv126,127,$crv127,128,$crv128,129,$crv129,130,$crv130,131,$crv131,132,$crv132,133,$crv133,134,$crv134,135,$crv135,136,$crv136,137,$crv137,138,$crv138,139,$crv139,140,$crv140,141,$crv141,142,$crv142,143,$crv143,144,$crv144,145,$crv145,146,$crv146,147,$crv147,148,$crv148,149,$crv149,150,$crv150,151,$crv151,152,$crv152,153,$crv153,154,$crv154,155,$crv155,156,$crv156,157,$crv157,158,$crv158,159,$crv159,160,$crv160,161,$crv161,162,$crv162,163,$crv163,164,$crv164,165,$crv165,166,$crv166,167,$crv167,168,$crv168,169,$crv169,170,$crv170,171,$crv171,172,$crv172,173,$crv173,174,$crv174,175,$crv175,176,$crv176,177,$crv177,178,$crv178,179,$crv179,180,$crv180,181,$crv181,182,$crv182,183,$crv183,184,$crv184,185,$crv185,186,$crv186,187,$crv187,188,$crv188,189,$crv189,190,$crv190,191,$crv191,192,$crv192,193,$crv193,194,$crv194,195,$crv195,196,$crv196,197,$crv197,198,$crv198,199,$crv199,200,$crv200,201,$crv201,202,$crv202,203,$crv203,204,$crv204,205,$crv205,206,$crv206,207,$crv207,208,$crv208,209,$crv209,210,$crv210,211,$crv211,212,$crv212,213,$crv213,214,$crv214,215,$crv215,216,$crv216,217,$crv217,218,$crv218,219,$crv219,220,$crv220,221,$crv221,222,$crv222,223,$crv223,224,$crv224,225,$crv225,226,$crv226,227,$crv227,228,$crv228,229,$crv229,230,$crv230,231,$crv231,232,$crv232,233,$crv233,234,$crv234,235,$crv235,236,$crv236,237,$crv237,238,$crv238,239,$crv239,240,$crv240,241,$crv241,242,$crv242,243,$crv243,244,$crv244,245,$crv245,246,$crv246,247,$crv247,248,$crv248,249,$crv249,250,$crv250,251,$crv251,252,$crv252,253,$crv253,254,$crv254,255,$crv255
keep[0]

#@gui Iain Demosaic: iain_demosiac, iain_demosiac(0)
#@gui : Starting Pattern = choice(0,"Red-Green","Blue-Green","Green-Red","Green-Blue")
#@gui : sep = separator ()
#@gui : note = note("Author: Iain Fergusson - released 6 June 2013")
iain_demosiac:
to_rgb
add 1000
rgb2bayer $1,1
replace 0,0.0000000001
+l[0]  ## make green channel
 replace 0,0.000000001
 +l[0] ## Interpolate green horizontally only
  to_rgb
  +split[0] c
  split[0] c
  name[0] red
  name[1] green
  name[2] blue
  name[-3] redblur
  name[-2] greenblur
  name[-1] blueblur
  (0.25,.5,0.5,.5,0.25)
  convolve[redblur] [-1]
  convolve[blueblur] [-1]
  remove[-1]
  (1;1)
  convolve[redblur] [-1]
  convolve[blueblur] [-1]
  remove[-1]
  (0.5,1,0.5)
  convolve[greenblur] [-1]
  remove[-1]
  +div[greenblur] [redblur]
  +div[greenblur] [blueblur]
  name[-1] bluemul
  name[-2] redmul
  remove[redblur,greenblur,blueblur]
  mul[red] [redmul]
  mul[blue] [bluemul]
  keep[red,green,blue]
  add
  c -100000000,100000000
 endl
 l[0]  ## Interpolate green vertically only
  to_rgb
  +split[0] c
  split[0] c
  name[0] red
  name[1] green
  name[2] blue
  name[-3] redblur
  name[-2] greenblur
  name[-1] blueblur
  (0.25;.5;0.5;.5;0.25)

  convolve[redblur] [-1]
  convolve[blueblur] [-1]
  remove[-1]
  (1,1)
  convolve[redblur] [-1]
  convolve[blueblur] [-1]
  remove[-1]
  (0.5;1;0.5)
  convolve[greenblur] [-1]
  remove[-1]
  +div[greenblur] [redblur]
  +div[greenblur] [blueblur]
  name[-1] bluemul
  name[-2] redmul
  remove[redblur,greenblur,blueblur]
  mul[red] [redmul]
  mul[blue] [bluemul]
  keep[red,green,blue]
  add
  c -100000000,100000000
 endl
 ## choose one without zippers
 (1,-2,1)
 +convolve[1] [-1]
 abs[-1]
 remove[-2]
 (1;-2;1)
 +convolve[0] [-1]
 abs[-1]
 remove[-2]
 +add[-2] [-1]
 div[-2] [-1]
 remove[-1,-3]
 lt[-1] 0.5
 mul[-1] 255
 blur[-1] 1
 append[0,-1] c
 blend alpha,1,1
endl
## interpolate colour differences
split[0] c
remove[1]
reverse[1,2]
(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
convolve[0] [-1]
convolve[2] [-1]
remove[-1]
+resize 50%,50%,{d},{s},2
sub[-1] [-2]
sub[-3] [-2]
remove[-2]
resize[-1,-2] {0,w},{0,h},{d},{s},3
remove[0,2]
add[1] [0]
add[2] [0]
reverse[0,1]
append c
sub 1000
c 0,255

#@gui  Iain 2x: iain_2x, iain_2x(0)
iain_2x:

repeat $! local[$>]
resize[0] 200%,200%,1,3,4
split c
repeat $! local[$>]
+l[0]
(0,0,0.5;0,1,0;0.5,0,0)
convolve[0] [1]
remove[1]
endl
+l[0]
(0.5,0,0;0,1,0;0,0,0.5)
convolve[0] [1]
remove[1]
endl
remove[0]
+l[0]
(0,0,0.5;0,-1,0;0.5,0,0)
convolve[0] [1]
remove[1]
abs
endl
+l[1]
(0.5,0,0;0,-1,0;0,0,0.5)
convolve[0] [1]
remove[1]
abs
endl
dilate[-1,-2] 3
sub[-2] [-1]
remove[-1]
l[-1]
+lt[0] 0
+gt[0] 0
fill[0] 0
sub[0] [1]
add[0] [-1]
keep[0]
add[0] 1
mul[0] 127.5
endl

append[1,2] c
blend alpha,1,0

+l[0]
(0.5,1,0.5)
convolve[0] [1]
remove[1]
endl
+l[0]
(0.5;1;0.5)
convolve[0] [1]
remove[1]
endl
remove[0]
+l[0]
(0.5,-1,0.5)
convolve[0] [1]
remove[1]
abs
endl
+l[1]
(0.5;-1;0.5)
convolve[0] [1]
remove[1]
abs
endl
blur[-1,-2] 3
sub[-2] [-1]
remove[-1]
l[-1]
+lt[0] 0
+gt[0] 0
fill[0] 0
sub[0] [1]
add[0] [-1]
keep[0]
add[0] 1
mul[0] 127.5
endl
append[1,2] c
blend alpha,1,0
 endlocal done
append c
 endlocal done

#@gui Heart Tone: iain_hearttone, iain_hearttone(0)
#@gui : Scale = float(100,10,200)
#@gui : Enhance Details = float(0,0,10)
iain_hearttone:

if $2>0
+iain_fast_denoise[0] $2,0,1,0,0
sub[1] [0]
mul[1] -1
add
n 0,255
endif
luminance
+l
rm
l
190,190,1,1,0
circle 50,50,50,1,10
circle 140,50,50,1,10
polygon 5,10,80,50,50,140,50,180,80,95,190,1,10
resize[-1] {0,w+2},{0,h+2},1,1,0,0,0.5,0.5

+resize[0] 95%,95%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 90%,90%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 85%,85%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 75%,75%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 65%,65%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 55%,55%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 50%,50%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 45%,45%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 40%,40%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 35%,35%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 30%,30%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 25%,25%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 20%,20%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 15%,15%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 10%,10%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 5%,5%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
add
endl
[0]
append y
resize 200%,100%,1,1,0,0,0.5,0.5
+shift[0] 160,100,0,0
+shift[0] -160,100,0,0
add
crop 30,190,350,100%
n 0,255
endl
resize[-1] $1,$1,1,1,2
width={w}
height={h}
w_tiles={0,round(w/$width)}
h_tiles={0,round(h/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
append_tiles[1--1] $w_tiles,$h_tiles
## blur[-1] {5*($1/100)}
equalize[-1] 256
blend alpha,0.5,1
gt 128
mul 255
#@gui Star Tone: star_tone, star_tone(0)
#@gui : Scale = float(100,10,200)
star_tone:
## points
sx1=50
sx2=194
sx3=281
sx4=511
sx5=742
sx6=829
sx7=972
sx8=829
sx9=742
sx10=511
sx11=281
sx12=192

sy1=450
sy2=633
sy3=849
sy4=817
sy5=849
sy6=633
sy7=450
sy8=267
sy9=50
sy10=83
sy11=50
sy12=267

level=10
luminance
+l
rm
2000,2000,1,1,0
repeat 8

polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level

sx2={$sx2+40}
sx6={$sx6-40}
sx8={$sx8-40}
sx12={$sx12+40}

sy2={$sy2-23}
sy4={$sy4-47}
sy6={$sy6-23}
sy8={$sy8+23}
sy10={$sy10+47}
sy12={$sy12+23}

level={$level+25}

done
n 0,255
resize 200,200,1,1,3
+shift[0] -69,-40,0,0
+shift[0] -69,40,0,0
+shift[0] 69,-40,0,0
+shift[0] 69,40,0,0
add
 crop 5,5,142,84
endl
resize[-1] $1,$1,1,1,2
width={w}
height={h}
w_tiles={0,round(w/$width)}
h_tiles={0,round(h/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
append_tiles[1--1] $w_tiles,$h_tiles
## blur[-1] {5*($1/100)}
equalize[-1] 256
blend alpha,0.5,1
gt 128
mul 255

#@gui Turbulent Halftone: iain_turbulent_halftone, iain_turbulent_halftone_preview(0)
#@gui : Amplitude = float(15,0,30)
#@gui : Smoothness = float(20,0,40)
#@gui : Orientation = float(0,0,180)
#@gui : Deviation = float(1,0,1)
#@gui : Tile Size = int(512,128,2048)
#@gui : Blob Size = float(0.75,0,4)
#@gui : Colour Model = choice("RGB","CMYK","Luminance")
#@gui : Enhance Detail = float(0,0,10)
#@gui : Oversample = bool(0)
#@gui : sep = separator(), note = note("Author: Iain Fergusson.      Latest update: 2019/09/20 - Improved quality and added oversample.")
#@gui : note = note("<small>Older updates: 2018/08/24.</small>")

iain_turbulent_halftone:
repeat $! local[$>]
if $8>0
+iain_fast_denoise $8,0,1,0,0
sub[1] [0]
mul[1] -1
add
endif
if $7==1
rgb2cmyk
elif $7==2
luminance
endif
split c
repeat $! local[$>]
+l[0]
channels 0
tsize={min($5,w,h)}
xtile={(round(w/$tsize))+1}
ytile={(round(h/$tsize))+1}
$tsize,$tsize
fx_seamless_turbulence[-1] $1,$2,$3,$4,.25,0
[-1]x{$xtile*$ytile}
append_tiles[1--1] $xtile,$ytile
remove[-1]
crop[-1] 0,0,{0,w},{0,h}
keep[-1]
endl
blur[-1] $6
l[-1] +blur 10 sub endl
n[-1] 0,255
equalize[-1] 256
if $9
resize 400%,400%,100%,100%,3
endif
blend alpha,0.5,1
gt 128
mul 255
 endlocal done
 append c
if $7==1
cmyk2rgb
endif
if $9
resize 25%,25%,100%,100%,3
endif
 endlocal done

 iain_turbulent_halftone_preview:
iain_turbulent_halftone $1,$2,$3,$4,{0,w},$6,$7,$8,$9

#@gui Halftone Shapes: iain_halftone_shapes, iain_halftone_shapes(0)
#@gui : Scale = float(100,5,200)
#@gui : Negative=bool(0)
#@gui : Shape = choice("Circle","Star","Triangle","Heart")
#@gui : Oversample = bool(0)
#@gui : Rotate = float(0,0,180)
#@gui : Twirl = float(0,0,2)
#@gui : Turn on rotate and twirl = bool(0)
#@gui : sep = separator()
#@gui : note = note("Oversample gives smoother results but takes much longer.")
#@gui : note = note("Twirl distorts the hafltone grid. The preview is not accurate. For best results use with oversample.")
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Iain Fergusson</i>.</small>")

iain_halftone_shapes:
warp_it=$7
remove_opacity
scale=$1
luminance
if $4==1
resize 400%,400%,1,1,3
scale={$scale*4}
endif
if $3==0
sx1=353
sx2=515
sx3=677
sx4=1000
sx5=1323
sx6=1485
sx7=1647
sx8=1485
sx9=1323
sx10=1000
sx11=677
sx12=515

sy1=1000
sy2=1280
sy3=1560
sy4=1560
sy5=1560
sy6=1280
sy7=1000
sy8=720
sy9=440
sy10=440
sy11=440
sy12=720

level=19
luminance
+l
rm
2000,2000,1,1,0

repeat 19

polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level

sy3={$sy3-(78/16)}
sy5={$sy5-(78/16)}
sy9={$sy9+(78/16)}
sy11={$sy11+(78/16)}

sx1={$sx1+(90/16)}
sx3={$sx3+(45/16)}
sx5={$sx5-(45/16)}
sx7={$sx7-(90/16)}
sx9={$sx9-(45/16)}
sx11={$sx11+(45/16)}

level={$level+10}
done
radius={560}
level=209
repeat 57
circle 50%,50%,$radius,1,$level
radius={$radius-10}
level={$level+10}
done

n 0,255
+shift[0] 972,560,0,0
+shift[0] 972,-560,0,0
+shift[0] -972,560,0,0
+shift[0] -972,-560,0,0
add
crop 29,440,1972,1560
endl

resize[1] 194,112,1,1,2
equalize[1] 65555
resize[1] $scale%,$scale%,1,1,3
if $2==1
negate[1]
endif
endif

if $3==1

 sx1=50
sx2=194
sx3=281
sx4=511
sx5=742
sx6=829
sx7=972
sx8=829
sx9=742
sx10=511
sx11=281
sx12=192

sy1=450
sy2=633
sy3=849
sy4=817
sy5=849
sy6=633
sy7=450
sy8=267
sy9=50
sy10=83
sy11=50
sy12=267

level=10
luminance
+l
rm
2000,2000,1,1,0
repeat 128

polygon 12,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,$sx4,$sy4,$sx5,$sy5,$sx6,$sy6,$sx7,$sy7,$sx8,$sy8,$sx9,$sy9,$sx10,$sy10,$sx11,$sy11,$sx12,$sy12,1,$level

sx2={$sx2+(40/16)}
sx6={$sx6-(40/16)}
sx8={$sx8-(40/16)}
sx12={$sx12+(40/16)}

sy2={$sy2-(23/16)}
sy4={$sy4-(47/16)}
sy6={$sy6-(23/16)}
sy8={$sy8+(23/16)}
sy10={$sy10+(47/16)}
sy12={$sy12+(23/16)}

level={$level+12}

done
n 0,255
resize 200,200,1,1,3
+shift[0] -69,-40,0,0
+shift[0] -69,40,0,0
+shift[0] 69,-40,0,0
+shift[0] 69,40,0,0
add
 crop 5,5,142,84
endl
resize[1] 194,112,1,1,2
equalize[1] 65555
resize[1] $scale%,$scale%,1,1,3
if $2==1
negate[1]
endif

endif
if $3==2
sx1=161
sx2=1000
sx3=1839

sy1=273
sy2=1727
sy3=273

 level=10
 luminance
+l
rm
2000,2000,1,1,0
repeat 375
polygon 3,$sx1,$sy1,$sx2,$sy2,$sx3,$sy3,1,$level

sx1={$sx1+2.21}

sx3={$sx3-2.21}

sy1={$sy1+1.28}
sy2={$sy2-2.56}
sy3={$sy3+1.28}

level={$level+1}
done
+rotate[0] 180
+shift[1] {840+2}
shift[1] -840
add
crop 160,{216+56},1842,1727
n 0,255
endl
equalize[1] 256
resize[1] 168,145,1,1,2

resize[1] $scale%,$scale%,1,1,3
if $2==1
negate[1]
endif
endif

if $3==3

luminance
+l
rm
l
190,190,1,1,0
circle 50,50,50,1,10
circle 140,50,50,1,10
polygon 5,10,80,50,50,140,50,180,80,95,190,1,10
resize[-1] {0,w+2},{0,h+2},1,1,0,0,0.5,0.5

+resize[0] 95%,95%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 90%,90%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 85%,85%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 75%,75%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 65%,65%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 55%,55%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 50%,50%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 45%,45%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 40%,40%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 35%,35%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 30%,30%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 25%,25%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 20%,20%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 15%,15%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 10%,10%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
+resize[0] 5%,5%,1,1,2
resize[-1] {0,w},{0,h},1,1,0,0,0.5,0.5
add
endl
[0]
append y
resize 200%,100%,1,1,0,0,0.5,0.5
+shift[0] 160,100,0,0
+shift[0] -160,100,0,0
add
crop 30,190,350,100%
n 0,255
endl
resize[-1] $scale,$scale,1,1,2
if $2==1
negate[1]
endif

endif
width={w}
height={h}
w_tiles={round({0,w}/$width)}
h_tiles={round({0,h}/$height)}
total_tiles=$h_tiles*$w_tiles
[-1]x{$total_tiles-1}
append_tiles[1--1] $w_tiles,$h_tiles
## blur[-1] {5*($scale/100)}
equalize[-1] 256
if $warp_it
rotate[-1] $5,1,2,50%,50%
twirl[-1] $6,.5,.5,2
endif
blend alpha,0.5,1
gt 128
mul 255

if $4==1
resize 25%,25%,1,1,3
endif
#@gui CA Correction: iain_CA_correction, iain_CA_correction_pr(0)
#@gui : Blue Adjustment= float(0,-5,5)
#@gui : Red Adjustment= float(0,-5,5)
#@gui : Interpolation Quality = choice (2,"Low","Med","high")
#@gui : sep = separator()
#@gui : Preview Shows = choice ("Output","colours only")
#@gui : Preview Corner = choice (3,"North-West","Northeast","Southeast","South-West")
#@gui : note = note("The preview is only accurate for the corners. Make sure you navigate to the same corner as selected above. ")
iain_CA_correction:
to_rgb
longest_side={max(w,h)}
split c
l[0]
$longest_side,$longest_side
50%,1
fill[-1] 1-(x/w)
+mirror[-1] x
mul[-2] -1
append[-1,-2] x
resize[-1] {1,w},{1,h},1,1,1
[-1]
rotate[-1] 90
append[-1,-2] c
rm[1]
resize[1] {0,w},{0,h},{d},{s},0,0,0.5,0.5
mul[-1] $2
warp[0] [1],1,$3,1
keep[0]
endl
l[2]
$longest_side,$longest_side
50%,1
fill[-1] 1-(x/w)
+mirror[-1] x
mul[-2] -1
append[-1,-2] x
resize[-1] {1,w},{1,h},1,1,1
[-1]
rotate[-1] 90
append[-1,-2] c
rm[1]
resize[1] {0,w},{0,h},{d},{s},0,0,0.5,0.5
mul[-1] $1
warp[0] [1],1,$3,1
keep[0]
endl
append c
c 0,255
iain_CA_correction_pr:
to_rgb
x_mul={w/max(w,h)}
y_mul={h/max(w,h)}

if $-1==0
rx_shift={$2*-1*$x_mul}
ry_shift={$2*-1*$y_mul}
bx_shift={$1*-1*$x_mul}
by_shift={$1*-1*$y_mul}
elif $-1==1
rx_shift={$2*$x_mul}
ry_shift={$2*-1*$y_mul}
bx_shift={$1*$x_mul}
by_shift={$1*-1*$y_mul}
elif $-1==2
rx_shift={$2*$x_mul}
ry_shift={$2*$y_mul}
bx_shift={$1*$x_mul}
by_shift={$1*$y_mul}
elif $-1==3
rx_shift={$2*-1*$x_mul}
ry_shift={$2*$y_mul}
bx_shift={$1*-1*$x_mul}
by_shift={$1*$y_mul}
endif

split c
l[0]
[0]
[0]
fill[1] $rx_shift
fill[2] $ry_shift
append[1,2] c
warp[0] [1],1,$3,1
keep[0]
endl
l[2]
[0]
[0]
fill[1] $bx_shift
fill[2] $by_shift
append[1,2] c
warp[0] [1],1,$3,1
keep[0]
endl
append c

if $-2
rgb2hsv
split c
fill[-1] .5
append c
hsv2rgb
sub 128
mul 2
add 128
c 0,255
endif

#@gui iain_highlight_synthesis: iain_highlight_synthesis,iain_highlight_synthesis(0)
#@gui : red = float(1,0,2)
#@gui : green = float(0.6,0,2)
#@gui : blue = float(1,0,2)
#@gui : rgb to srgb = bool(0)

iain_highlight_synthesis:

red_wb={$1/max($1,$2,$3)}
green_wb={$2/max($1,$2,$3)}
blue_wb={$3/max($1,$2,$3)}


srgb=$4
smoothness=2
smoothness2=2
smoothness3=2


#remove_alpha channel if GIMP layer has one
-remove_opacity


# demosaic channels independantly (choice of demosiacing affects results)
	#detect pattern
	+crop 0,0,500,500 
	sum={is}

	+rgb2bayer[1] 0,1 b_sum0={is} -rm[-1] +rgb2bayer[1] 1,1 b_sum1={is} -rm[-1] +rgb2bayer[1] 2,1 b_sum2={is} -rm[-1] +rgb2bayer[1] 3,1 b_sum3={is} -rm[-1] 
	-if {$sum==$b_sum0} b_pat=0 -elif {$sum==$b_sum1} b_pat=1 -elif {$sum==$b_sum2} b_pat=2 -elif {$sum==$b_sum3} b_pat=3 -endif
	-k[0]
	
	rgb2bayer $b_pat,1
	-split c


	-l[1]

	(1,0,0;0,-1,0;0,0,0)
	(0,1,0;-1,0,0;0,0,0)
	+convolve[0] [1]
	+convolve[0] [2]
	-rm[1,2]

	(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
	-convolve[1,2] [-1]
	-rm[-1]

	-complex2polar[-1,-2]
	-rm[-2]
	-mod[1] {pi}
	-median[-1] 3
	-inrange[-1] 0,{pi/2}

	(0.5,1,0.5)
	(0.5;1;0.5)
	+convolve[0] [2]
	+convolve[0] [3]
	-rm[0,2,3]
	-mul[1] [0]
	-negate[0]
	-mul[2] [0]
	-add[1,2]
	-k[1]
	-endl

	-l[0]

	(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
	-convolve[0] [-1]
	-rm[-1]

	-endl

	-l[2]
	(0.25,0.5,0.25;0.5,1,0.5;0.25,0.5,0.25)
	-convolve[0] [-1]
	-rm[-1]
	-endl

	-append c
 
# End demosaic 
-cut 0,255


-split c # splits RGB image into individualgreyscael images


	+local # create a new grey refernce image

	# sort pixel values 
	+min[0,1,2] # creates new image for minimum of RGB values
	+blend_median[0,1,2] #creates new image for median of RGB values
	+max[0,1,2] #creates new image for median of RGB values
	-rm[0,1,2] #Removes indiviual RGB grey scale images in local context

# highlight synthesis
	-l[0]

		-repeat 4 
		
		# replace clipped pixels by predications
		# process pixels seqentially
		+fill[0] >"
		far = j(-1)+(j(-1)-j(-2))*0.99;
		near = 255+(255-j(-1))*0.99;
		predict = if(far<255,near,far);

		if(i>254,predict,i)

		"
		-rotate[0] 90 # rotate 90 degress and repeat so pixels are predicted from all four directions

		-done
		# undo rotations
		-rotate[2] -90
		-rotate[3] -180
		-rotate[4] 90
		# find minimum of predictions
		 -min[-1,-2,-3,-4] 


	+gt[0] 254 # find clipped area
	-distance[-1] 0 # calculate distance from edge of clipped area

	-cut[-1] 0,50 # restrict max distance to 50
	
		# blur predicted area by the distance from the edge of the clipped area
		
		-repeat $smoothness 
		-gcd_boxfilter_local[1] [2] # use garagecoder's algorthm for bluring
		-sub[2] 0.25 # reduce blur radius a little bit for each repeat
		-cut[2] 0,50 # clip to stop negative values
		-done
		
	-cut[1] 0,{255*(2^2)} # max 2 stops of prediction
	-keep[1] 

	-endl

# end synthesis

# we have now refernce image with syntheised highlights from the minimum RGB values

# Instead of using the reference image we have just created from the minimum RGB values, use all RGB channels for the grey reference by restoring the clipped areas of the median and max RGB images and combining them together

	#  find smoothest parts of the image to propegated information from 

	+blur[0] 0.5 -laplacian[-1] -abs[-1]
	
	# overwrite pixels on the edge of the images so they are ignored 
	-line[-1] 0,0,100%,0,1,500
	-line[-1] 0,0,0,100%,1,500
	-line[-1] 100%,0,100%,100%,1,500
	-line[-1] 0,100%,100%,100%,1,500

	-negate[-1] 
	-blur[-1] 0.5 

	# fill clipped areas of median and max images
	
	+lt[1] 254 #create mask with unclipped area
	-erode[-1] 3 # shrink mask to by 1 pixel 
	-sub[1] [0] # find difference between reference
	+mul[1] [-1] # create new image with clipped area as black by multiplying by mask
	
	-watershed[-1] [3] # use watershed function, guided by image smoothness to propegated values into clipped area.
	
	
	# blur propegated values by the distance from the edge of the mask
	+distance[-2] 1 
	-erode[-1] 3
	-c[-1] 0,20
		-repeat $smoothness2
		-gcd_boxfilter_local[-2] [-1]
		-done
	-rm[-1]
	
	

	#combine newly progated values with difference image
	-mul[1] [-2]
	-negate[-2] 
	-mul[-1,-2]
	-add[1,-1]
	
	# add referance to difference iamge
	-add[1] [0]
	
	# average refernce median image
	-add[0,1]
	-mul[0] 0.5
	
	#repeat propegation procedure for maxium image
	
	
	+lt[1] 254
	-erode[-1] 3
	-sub[1] [0]
	+mul[1] [-1]
	-watershed[-1] [2]
	
		+distance[-2] 1
	-erode[-1] 3
	-c[-1] 0,20
		-repeat $smoothness2
		-gcd_boxfilter_local[-2] [-1]
		-done
-rm[-1]
	
	-mul[1] [-2]
	-negate[-2] 
	-mul[-1,-2]
	-add[1,-1]
	-add[1] [0]
	
	# combine min,median and max images so the result is the average of all three
	-mul[1] 0.5
	-add[0,1]
	-mul[0] {1/1.5}
	
	-remove[-1] # remove smoothness image

	-endl


# now there is a reference image that has syntheised highlights and representes all colour channels


#This reference image is used to propegate information into clipped areas of the R,G,B images using the same techniques as above

+blur[-1] 0.5 -laplacian[-1] -abs[-1]

	-line[-1] 0,0,100%,0,1,500
	-line[-1] 0,0,0,100%,1,500
	-line[-1] 100%,0,100%,100%,1,500
	-line[-1] 0,100%,100%,100%,1,500

	-negate[-1] 
	-blur[-1] 0.5 

# red channel

+lt[0] 254 
-erode[-1] 3 

-mul[0] $red_wb  # apply white balance mulitplier to ensure correct proportions between channels


-sub[0] [3]

+add[0] 1000 # offset differnce image because  "watershed" will might comfused 

-mul[-1] [-2]
-watershed[-1] [4]

+distance[-2] 1 
	-erode[-1] 3
	-c[-1] 0,20
		-repeat $smoothness2
		-gcd_boxfilter_local[-2] [-1]
		-done
	-rm[-1]

-sub[-1] 1000

-mul[0] [-2]
-negate[-2] 
-mul[-1,-2]
-add[0,-1]
-add[0] [3]


# green channel

+lt[1] 254 
-erode[-1] 3 

-mul[1] $green_wb  # apply white balance mulitplier

-sub[1] [3]

+add[1] 1000 # offset differnce image because  "watershed" will might comfused 

-mul[-1] [-2]
-watershed[-1] [4]

+distance[-2] 1 
	-erode[-1] 3
	-c[-1] 0,20
		-repeat $smoothness2
		-gcd_boxfilter_local[-2] [-1]
		-done
	-rm[-1]

-sub[-1] 1000

-mul[1] [-2]
-negate[-2] 
-mul[-1,-2]
-add[1,-1]

-add[1] [3]

# blue channel

+lt[2] 254 
-erode[-1] 3 

-mul[2] $blue_wb  # apply white balance mulitplier to ensure correct proportions between channels


-sub[2] [3]

+add[2] 1000 # offset differnce image because  "watershed" will might comfused 

-mul[-1] [-2]
-watershed[-1] [4]

+distance[-2] 1 
	-erode[-1] 3
	-c[-1] 0,20
		-repeat $smoothness2
		-gcd_boxfilter_local[-2] [-1]
		-done
	-rm[-1]

-sub[-1] 1000

-mul[2] [-2]
-negate[-2] 
-mul[-1,-2]
-add[2,-1]
-add[2,3]


-append[0,1,2] c
-keep[0]
-cut[0] 0,1000000 # cut negative values

# make output sensible for returnnig to GIMP
-n 0,255 # normalise

-if $srgb -rgb2srgb -endif


# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
