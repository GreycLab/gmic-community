#@gmic
# Description: G'MIC custom command file
# Defines a set of image filters for use with the G'MIC program/plugin
#
# Author: Andy Kelday
# Date: 31st August 2016
# Contact: garagecoder@gmail.com
#
#  Licenses        : This file is 'dual-licensed', you have to choose one
#                    of the two licenses below to apply.
#
#                    CeCILL-C
#                    The CeCILL-C license is close to the GNU LGPL.
#                    ( http://cecill.info/licences/Licence_CeCILL-C_V1-en.html )
#
#                or  CeCILL v2.1
#                    The CeCILL license is compatible with the GNU GPL.
#                    ( http://cecill.info/licences/Licence_CeCILL_V2.1-en.html )
#
#  This software is governed either by the CeCILL or the CeCILL-C license
#  under French law and abiding by the rules of distribution of free software.
#  You can  use, modify and or redistribute the software under the terms of
#  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
#  at the following URL: "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
#

#@gui _<b>Artistic</b>

#@gui Aurora : gcd_aurora, gcd_aurora(1)
#@gui : note = note("<i>Simple aurora effect filter</i>"), sep = separator()
#@gui : Vertical Amount = float(6,0,50)
#@gui : Horizontal Amount = float(1,0,50)
#@gui : Blend Mode = choice(0,"None","Average")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_aurora : skip ${1=6},${2=1},${3=0}
  repeat $! l[$>]
    to_rgb +deriche $1%,2,y deriche. $2%,0,x
    c. 0,255 n. 0,255
    if $3 blend average else k. fi
  done done

#@gui _<b>Black & White</b>

#@gui Desaturate Norm : fx_gcd_norm_eq, fx_gcd_norm_eq_preview(0)
#@gui : note = note("<i>Desaturate sRGB using equalized norm</i>"), sep = separator()
#@gui : Red = float(0.5,0,1)
#@gui : Blue = float(0.5,0,1)
#@gui : Exp = float(2,1,3)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/12/27</i>.</small>")
fx_gcd_norm_eq : skip ${1=0.5},${2=0.5},${3=2}
  repeat $! l[$>]
    split_opacity
    l[0]
      to_rgb srgb2rgb gcd_gamma $3
      sh 0 sh.. 2 *.. $1 *. $2 k[0]
      norm / {sqrt(1+$1^2+$2^2)}
      gcd_gamma {1/$3} rgb2srgb
    done a c
  done done

fx_gcd_norm_eq_preview :
  gui_split_preview "fx_gcd_norm_eq ${1--2}",$-1

#@gui Multi-Layer Etch : fx_gcd_layeretch, fx_gcd_layeretch(2)
#@gui : note = note("<u>Etch with selectable number of layers</u>")
#@gui : note = note("<b>Warning: With high number of layers this can be VERY slow!</b>")
#@gui : sep = separator()
#@gui : Total Layers = int(11,2,16)
#@gui : White Layers = int(4,1,15)
#@gui : Etch Tones = int(12,2,32)
#@gui : Tone Blur = float(0.12,0,1)
#@gui : Noise Level = int(100,5,200)
#@gui : Dark Length = float(8.5,0,20)
#@gui : Bright Length = float(5,0,20)
#@gui : Start Angle = int(0,0,180)
#@gui : Random Angle = int(0,0,45)
#@gui : Max Curve = int(3,0,20)
#@gui : Gamma = float(1,0.01,2)
#@gui : Spread Angles = bool(1)
#@gui : Fast Resize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2012/12/21</i>.</small>")
fx_gcd_layeretch : skip ${1=16},${2=7},${3=14},${4=0.12},${5=100},${6=5},${7=4.65},${8=0},${9=0},${10=3},${11=1},${12=1},${13=0}
  repeat $! l[$>]
    w={w} h={h} sc=800 ml=$1 wl={min($2,$ml-1)}
    nwl={$ml-$wl} nwl={$nwl+($nwl%2==0)}
    if !$13 nw=$w nh=$h
    elif w>h nw={min($sc,w)} nh={$nw/w*h}
    else nh={min($sc,h)} nw={$nh/h*w} fi
    to_rgb[0] [0] r[1] $nw,$nh
    norm[1] n[1] 0,255 +tones[1] $ml
    repeat $ml-1 +[{-$<-1}] [{-$<-2}] done
    b[-$ml--1] $4%
    repeat $ml
      pc={($>+1)/$ml} msk={2+$>} {w},{h},1,1,0
      if $12 ang={$>/$nwl} else ang=$pc fi
      if $<>=$wl
        noise. {(1-$pc)*$5},2 ==. 1
        blur_linear. {$6+$pc*($7-$6)}%,0,{$ang*360+u(-$9,$9)+$8}
        quantize. $3,0 deform. {u*$10+1}
      fi
      r. $nw,$nh n. 0,255
      *[$msk,-1] progress {$pc*100}
    done
    +[-$ml--1] c. 0,255
    n. 0,255 negate. apply_gamma. $11
    if $13 r. $w,$h,1,3,5 c. 0,255 fi
    k.
  done done

#@gui Threshold Etch : fx_gcd_etch, fx_gcd_etch_preview(1)
#@gui : note = note("<u>Replace tones with noise generated lines</u>")
#@gui : note = note("\n<i>Input Image Settings</i>"), sep = separator()
#@gui : Threshold Low = int(125,10,255)
#@gui : Threshold Mid = int(153,10,255)
#@gui : Threshold High = int(171,10,255)
#@gui : Threshold Max = int(185,10,255)
#@gui : Blur Amount = float(0.1,0,2)
#@gui : note = note("\n<i>Output Etch Settings</i>"), sep = separator()
#@gui : Horizontal Amount = int(50,0,100)
#@gui : Cross-Hatch Amount = int(80,0,100)
#@gui : Vertical 1 Amount = int(50,0,100)
#@gui : Vertical 2 Amount = int(10,0,100)
#@gui : sep = separator()
#@gui : Horizontal Length = int(15,0,50)
#@gui : Vertical 1 Length = int(12,0,50)
#@gui : Vertical 2 Length = int(20,0,50)
#@gui : Flip Cross-Hatch = bool(0)
#@gui : sep = separator()
#@gui : Curve Amount = int(1,0,20)
#@gui : Gamma = float(0.3,0.01,1)
#@gui : Fast Resize = bool(1)
#@gui : Color Image = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
fx_gcd_etch :
  skip ${1=125},${2=153},${3=171},${4=185},${5=0.1} skip ${6=50},${7=80},${8=50},${9=10}
  skip ${10=15},${11=12},${12=20},${13=0} skip ${14=1},${15=0.3},${16=1},${17=0}
  repeat $! l[$>]
    #image resizing
    w={w} h={h} sc=800 ml=4
    if w>h nw={min($sc,w)} nh={$nw/w*h} else nh={min($sc,h)} nw={$nh/h*w} fi
    to_rgb[0] [0] if $16 r[1] $nw,$nh fi
    #convert to b&w negative
    b[1] $5% norm[1] negate[1] n[1] 0,255
    #split into value ranges
    +c[1] 0,{255-$4} +c[1] {255-$3},128 +c[1] {255-$2},192 +c[1] {255-$1},255 n[-3--1] 0,255
    #create etch layers
    {w},{h},1,1,0 noise. $6,2 ==. 1 deriche. $10,0,x,0
    {w},{h},1,1,0 noise. $7,2 ==. 1 {w},{h},1,3,0 fc. 0,-1,0 smooth.. .,30,30,0 rm.
    if $13 mirror. x fi
    {w},{h},1,1,0 noise. $8,2 ==. 1 deriche. $11,0,y,0
    {w},{h},1,1,0 noise. $9,2 ==. 1 deriche. $12,0,y,0
    #reduce colour levels, add curve
    quantize[-$ml--1] 2,0 deform[-$ml--1] $14
    #combine image & etch layers
    repeat $ml *[{2+$>},-1] done
    #merge layers down, remove negative
    +[-$ml--1] n. 0,255 rm[1]
    negate. apply_gamma. $15
    #restore original size, combine colour
    if $16 r. $w,$h,1,3,5 c. 0,255 fi
    if $17 blend[0,1] shapeaverage else k. fi
  done done

fx_gcd_etch_preview :
  gui_split_preview "fx_gcd_etch ${1--2}",$-1

#@gui _<b>Colors</b>

#@gui HSL Adjustment : gcd_hsl, gcd_hsl_preview(1)
#@gui : note = note("\n<i>Input Saturation Settings</i>"), sep = separator()
#@gui : Contrast = float(1,0,2)
#@gui : Level = float(0,-1,1)
#@gui : Auto Reduce Level (Level Slider Is Disabled) = bool(0)
#@gui : note = note("\n<i>Output Hue Settings</i>"), sep = separator()
#@gui : Hue = float(180,0,360)
#@gui : Amount = float(0.2,0,1)
#@gui : Auto Set Hue Inverse (Hue Slider Is Disabled) = bool(0)
#@gui : note = note("\n<i>Output Luminance Settings</i>"), sep = separator()
#@gui : Gamma = float(1,0,2)
#@gui : Contrast = float(1,0,2)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/05/15</i>.</small>")
gcd_hsl : skip ${1=1},${2=0},${3=0},${4=180},${5=0.2},${6=0},${7=1},${8=1}
  repeat $! l[$>]
    split_opacity to_rgb[0] rgb2hsv[0]
    if $6
      +channels[0] 0
      histogram. 360,0,360
      hue={(xM+180)%360} rm.
    else hue=$4 fi

    sh[0] 1,1
    if $3 sat={-max(0,ia-0.5)} else sat=$2 fi
    -. 0.5 *. $1 +. $sat
    +. 0.5 c. 0,1 rm.
    hsv2rgb[0]

    +channels[0] 0 *. 66
    +channels[0] 1 *. 129 +[-2,-1]
    +channels[0] 2 *. 25 +[-2,-1]
    +. 128 /. 256 +. 16
    apply_gamma. {max(0.001,$7)}
    if $8!=1 -. 128 *. $8 +. 128 fi
    c. 0,255

    sh[0] 0,0 sh[0] 1,1 sh[0] 2,2
    ($hue^1^1) hsv2rgb. n. {1-$5},1
    *[-4] {@0} *... {@1} *.. {@2}
    rm[-4--1] rgb2ycbcr[0] j[0] . rm.
    ycbcr2rgb[0] a c
  done done

gcd_hsl_preview :
  gui_split_preview "gcd_hsl ${1--2}",$-1

#@gui HSV Select: gcd_hsv_select, gcd_hsv_select(2)
#@gui : note = note("<i>Color Selection</i>"), sep = separator()
#@gui : Hue = int(0,0,360)
#@gui : Saturation = float(0.5,0,1)
#@gui : Value = float(1,0,1)
#@gui : note = note("\n<i>Color Range</i>"), sep = separator()
#@gui : Hue Range = int(180,0,180)
#@gui : Sat Range = float(0.5,0,0.5)
#@gui : Val Range = float(0.5,0,0.5)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Grow Alpha = int(2,-20,20)
#@gui : Blur Alpha = int(2,0,20)
#@gui : note = note("\n<i>Advanced Options</i>"), sep = separator()
#@gui : Patch Size = int(18,3,100)
#@gui : Fill Holes % = int(0,0,50)
#@gui : Min Area % = int(0,0,50)
#@gui : Show Watershed = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/11</i>.</small>")
gcd_hsv_select :
  skip ${1=0},${2=0.5},${3=1} skip ${4=180},${5=0.5},${6=0.5}
  skip ${7=2},${8=2} skip ${9=18},${10=0},${11=0},${12=0}
  repeat $! l[$>]
    to_rgba[0] remove_opacity[0]
    if !$12 [0] fi
    l.
      gcd_shrink
      +rgb2hsv[0] s. c
      bh={$1-$4} th={$1+$4}
      +ge[1] {360+$bh} +le[1] {$th-360}
      ir[1] {max($bh,0)},{min($th,360)}
      or[-2,-1] or[1,-1]
      ir[2] {$2-$5},{$2+$5}
      ir[3] {$3-$6},{$3+$6}
      and[-2,-1] and[-2,-1]
      meancurvature_flow[0] 3 median[0] 3
      +[0] 1 +gradient_norm[0] +b. 2,1,1 min_patch. $9
      *[0,-1] *. -1 # dots, mask, gradient
      +*[0] [1] gt[0] 0 negate[1] *[0,1] *[0] 0.5 max[0,-1]
      +watershed[0] . k. -. 1
      gcd_unshrink
    done
    if !$12
      channels. 0 ge. 0
      +area. 0 +le. {($10%*max(w,h))^2}
      +negate... *[-2,-1] inpaint... . rm.
      le. {($11%*max(w,h))^2} *. ..
      inpaint.. . rm. *. 255
      if $7>0 dilate. $7
      elif $7<0 erode. {abs($7)} fi
      if $8 b. $8,1,1 fi
      a[-2,-1] c
    fi
    c. 0,255
  done done

#@gui Specific Saturation: gcd_hio_levels, gcd_hio_levels_preview(1)
#@gui : note = note("\n<i>Hue Levels</i>"), sep = separator()
#@gui : Input = float(1,0,2)
#@gui : Opposing = float(1,0,2)
#@gui : Hue = int(39,0,360)
#@gui : Level = float(0,-0.5,0.5)
#@gui : note = note("\n<i>Luma Levels</i>"), sep = separator()
#@gui : Gamma = float(1,0.2,1.8)
#@gui : Contrast = float(1,0.2,1.8)
#@gui : sRGB Conversion = bool(0)
#@gui : Process Top Layer Only = bool(0)
#@gui : sep = separator(), Preview = choice("Full","Forward horizontal","Forward vertical","Backward horizontal",
#@gui : "Backward vertical","Duplicate horizontal","Duplicate vertical","Blend all layers")
#@gui : Is Preview = value(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/01/22</i>.</small>")
gcd_hio_levels : skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0},${8=0},${9=0},${10=0}
  if $8 _gcd_hio_levels[0] ${1--4} else _gcd_hio_levels ${1--4} fi
  if $10" && "$!>1 rv blend alpha fi

_gcd_hio_levels : skip ${1=1},${2=1},${3=39},${4=0},${5=1},${6=1},${7=0}
  repeat $! l[$>]
    split_opacity to_rgb[0] +gcd_srgb2luma[0]
    if $4!=0
      sh[0] 0 sh[0] 1 sh[0] 2,2
      ({$3%360}^1^1) hsv2rgb. max. 0 *. $4 -. {ia}
      +[-4] {@0} +... {@1} +.. {@2} rm[-4--1] max[0] 0
    fi
    gcd_hue_chroma[0] $3,$1,$2
    gcd_srgb2jpeg[0] j[0] . rm.
    max[0] 0 sh[0] 0 srgb={($5!=1" || "$6!=1)" && "$7}
    if $srgb srgb2rgb. fi
    gcd_gamma. $5
    if $6!=1
      m={iM/2} -. $m +sign. abs..
      gcd_gamma.. $6,1,$m *[-2,-1] +. $m
    fi
    if $srgb rgb2srgb. fi
    rm. gcd_jpeg2srgb[0] a c c 0,255
  done done

gcd_hio_levels_preview :
  if $-2==7 gcd_hio_levels ${1--2},1
  else gui_split_preview "gcd_hio_levels $*",$-2 fi

gcd_hue_chroma : skip ${1=0},${2=1},${3=1}
  if $2==1" && "$3==1 return fi
  repeat $! l[$>]
    # get channels/ratio for hue
    h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
    p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}

    # get current hue level [Ih]
    [0] sh. $p sh.. $s +*.. $x
    +le. .. j... ..,0,0,0,0,1,. rm..
    eq. 0 +*.. $y j[-4] .,0,0,0,0,1,..
    rm[-4--1] sh. $z f. 0 rm.

    # set chroma of hues [0] [Ih] [P] [I0min] [Pn]
    sh. $p +compose_channels[0] min +eq.. 0 +. ...
    if $3!=1
      +/[-2,-1] -. 1 r. 100%,100%,1,3 *. [-5] +[0] .
      +compose_channels[0] min -[0] . *[0] $3 +[0,-1] -[0,-1]
    fi
    if $2!=1 +-[-3,-2] *. $2 +[-3,-1] /[-2,-1] -. 1 *[-3,-1] rm. +
    else k[0] fi
  done done

#@gui Transfer Colors [Patch-Based] : fx_gcd_transfer_colors_patch, fx_gcd_transfer_colors_patch_preview(1)
#@gui : note = note("<i>Generate a CLUT and apply it to other images.</i>")
#@gui : note = note("\n<i>Input Options</i>"), sep = separator()
#@gui : Resolution = int(6,2,8)
#@gui : Smooth = float(3,0,10)
#@gui : Iters = int(5,0,20)
#@gui : Random = int(5,0,20)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Reference = choice("Top layer","Bottom layer")
#@gui : Output CLUT = _choice("Disable","512x512 layer","4096x4096 layer")
#@gui : note = note("\n"), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/08/17</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set the <i>Input layers</i> option to transfer colors to other layers.</small>")
#@gui : note = note("<small>If only one input layer is selected a CLUT is always output.</small>")
#@gui : note = note("<small>Higher resolution, iters, or random generally produce better results - at the cost of processing time.</small>")
#@gui : note = note("<small>Results are not necessarily the same every time due to the random based algorithm.</small>")
fx_gcd_transfer_colors_patch : skip ${1=6},${2=3},${3=5},${4=5},${5=0},${6=0}
  ref={if($5,$!-1,0)} n=$!
  +gcd_extract_clut[$ref] ${1-4}
  map_clut[^-1,$ref] .
  if $6>0" || "$n==1
    r,s={arg(max($6,1),64,256)},{arg(max($6,1),512,4096)}
    r. $r,$r,$r,3,3 r. $s,$s,1,3,-1
  else rm. fi

fx_gcd_transfer_colors_patch_preview :
  fx_gcd_transfer_colors_patch $*
  if !$5 rm[0] fi

#@gui _<b>Degradations</b>

#@gui CRT Sub-Pixels : fx_gcd_crt, fx_gcd_crt(2)
#@gui : note = note("<i>Cathode ray tube sub-pixel rendering filter</i>"), sep = separator()
#@gui : Horizontal Blur = float(1.8,0,5)
#@gui : Vertical Blur = float(1.8,0,5)
#@gui : Screen Border = bool(0)
#@gui : Equalize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/12/11</i>.</small>")
fx_gcd_crt : skip ${1=1.8},${2=1.8},${3=0},${4=0}
  repeat $! l[$>]
    to_rgb[0]
    expand xy,12 24,14,1,3,0
    f. "if((x-c*4)%12<4,255,0)"
    f. "if(x%4==0,0,i)"
    f. "if((y%14==0)&&(x%24<12),0,i)"
    f. "if(((y-7)%14==0)&&((x+12)%24<12),0,i)"
    array. {0,round(w/24)},{0,round(h/14)},2
    z. 0,0,{0,w-1},{0,h-1}
    s c repeat 3 blend[-4,-1] shapeaverage0 done a c
    n. 0,255 meancurvature_flow. 4
    if $3
      {w},{h},1,1,0
      rectangle. 5%,5%,95%,95%,1,1
      b. 10% *[0,1]
    fi
    deriche. $1,0,x deriche. $2,0,y
    shrink. xy,12 n. 0,255
    if $4 equalize. 256 fi
  done done

#@gui _<b>Details</b>

#@gui Tone Enhance : gcd_tone_enhance, gcd_tone_enhance(1)
#@gui : note = note("<i>Sharpen or adjust shadows and highlights</i>")
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Shadows</i></small></span>")
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Highlights</i></small></span>")
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Mid Point</i></small></span>")
#@gui : Centre = int(128,0,255)
#@gui : Detail = float(0,0,2)
#@gui : Gamma = float(1,0.2,1.8)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Extra Shadow/Highlight recovery</i></small></span>")
#@gui : Boost = float(0.5,0,1)
#@gui : Smooth = float(0,0,2)
#@gui : sep = separator(), note = note("<span foreground="orangered"><small><i>Detail Mask</i></small></span>")
#@gui : Smooth = int(0,0,20)
#@gui : sep = separator()
#@gui : Channels = choice(4,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Values = choice("cut","normalize")
#@gui : Color Median = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/01/03</i>.</small>")
gcd_tone_enhance :
  skip ${1=0},${2=1},${3=0},${4=1},${5=128},${6=0},${7=1}
  skip ${8=0.5},${9=0},${10=0},${11=4},${12=0},${13=0}
  if $13 repeat $! l[$>]
    gcd_srgb2jpeg sh 1,2 median. 5,20 rm. gcd_jpeg2srgb c 0,255
  done done fi
  mode=${arg0\ $11,hsi8_i,hsv8_v,lab8_l,lrgb,rgb,ycbcr_y}
  ac "_gcd_tone_enhance ${1-10}",$mode,{$12+1}

_gcd_tone_enhance :
  repeat $! l[$>]
    if $9>0 bilateral 1%,$9 c 0,255 fi
    +norm +bilateral.. 2%,30 norm. -[-2,-1]
    +gradient_norm.. n. 0,1 oneminus. *[-2,-1]
    if $10 b. {0.025*$10}% fi
    +n.. 0,255 median. 3 bilateral. 2%,30
    gcd_srgb2luma. -. $5 +abs. negate.
    +max.. 0 min... 0 abs...
    if $8!=0.5
      +n[{$8>0.5?-3:-1}] 0,1 +gcd_ibezier[0] {1-$8}
      j[0] .,0,0,0,0,1,.. rm[-2,-1]
    fi
    +/... {if(iM#-3>0,iM#-3/(1/$2-1),1)} +. 1
    +/... {if(iM#-3>0,iM#-3/(1/$7-1),1)} +. 1 *[-2,-1]
    +/.. {if(iM#-2>0,iM#-2/(1/$4-1),1)} +. 1 *[-2,-1]
    m={0,iM} /[0] $m ^[0,-1] *[0] $m
    n... 0,$1 n.. 0,$6 n. 0,$3 *[-3--1] [-4] rm[-4] +
  done done

#@gui _<b>Repair</b>

#@gui Deinterlace2x: gcd_deinterlace2x, gcd_deinterlace2x_preview(0)
#@gui : note = note("<i>Blend 2x frames for 4:2:0 YUV</i>"), sep = separator()
#@gui : Balance = int(40,1,255)
#@gui : 2x Type = choice("DCCI2x","Edge","Fast Blend","Set Aspect Only")
#@gui : Aspect = choice("None","1:1","4:3","5:4","16:9","16:10","2.35:1","1.85:1")
#@gui : Interp = choice(2,"linear","bicubic","lanczos")
#@gui : Ignore Current Aspect = bool(0)
#@gui : Fast Blend Preview = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/05/01</i>.</small>")
#@gui : note = note("\n<small><b>Note:</b> preview may be inaccurate</small>")
#@gui : note = note("<small>Interp is only used when setting aspect</small>")
gcd_deinterlace2x : skip ${1=40},${2=0},${3=0},${4=2},${5=0},${6=1}
  if $3 # set aspect
    ca={if($5,1,h/w)} na={arg($3,1,{4/3},{5/4},{16/9},{1.6},{2.35},{1.85})}
    r {$ca*$na*w},100%,1,3,{arg($4+1,3,5,6)} c 0,255
  fi if $2==3 return fi
  repeat $! l[$>]
    w={w} h={h} d={d} hh={int($h/2)} rgb2yuv s c
    l[0] +shift 0,-1 r $w,$hh,$d,1,4 done
    l[-2,-1] r $w,2,$d,$hh,-1 +shift 0,0,0,-1 r $w,2,$d,50%,4 r $w,$hh,$d,1,-1 done
    a[0,2,3] c a[^0] c yuv2rgb # frames are now separate
    if $2==0 scale_dcci2x ,,1 r 50%,100%,1,3,4
    elif $2==1 gcd_upscale_edge 2 r 50%,100%,1,3,4
    else # 2xH scaling
      a={2/3} b={-1/12} ($b,$a,$b;$b,$a,$b;0,0,0) +convolve[^-1] . rm...
      r 100%,200%,1,3,4 shift[-2,-1] 0,1 +[-3,-1] +[-3,-1]
    fi # blend based on thresholded surrounding difference
    c 0,255 shift. 0,1 +- +norm. a={-192^-.5/$1} ($a,$a,$a;$a,0,$a;$a,$a,$a)
    convolve.. . rm. max. -1 +. 1 *[-2,-1] -[0,-1] rm.
  done done

gcd_deinterlace2x_preview :
  gcd_deinterlace2x ${1},{if($6,max(2,$2),$2)},${3--1}

#@gui Despeckle: gcd_despeckle, gcd_despeckle(3)
#@gui : note = note("<i>Remove small dots and specks</i>"), sep = separator()
#@gui : Tolerance = int(20,0,50)
#@gui : Max Area = int(10,0,100)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.   Latest update : <i>2013/02/01</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set max area to 0 for no area size limit.</small>")
gcd_despeckle : skip ${1=15},${2=30}
  repeat $! l[$>]
    ma={if(!$2,w*h,$2)}
    +label. $1,1 nb={1+iM}
    +histogram. $nb,0,{$nb-1}
    map.. . rm.
    le. $ma *. 255
    inpaint.. . rm.
  done done

#@gui _<b>Stereoscopic 3D</b>

#@gui Stereo Image : gcd_stereo_img, gcd_stereo_img(1)
#@gui : note = note("<u>Create a 3D image from a flat one</u>")
#@gui : note = note("\n<i>3D Options</i>"), sep = separator()
#@gui : 3D Image Type = choice("Anaglyph: Red/Cyan","Side by Side","Depth Map","Inverse Depth Map")
#@gui : Balance Color = float(0.5,0,1)
#@gui : Depth = float(1.2,0,3)
#@gui : Distance = float(1,-2,2)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Despeckle = bool(1)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Auto Crop = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/07/02</i>.</small>")
gcd_stereo_img : skip ${1=0},${2=2},${3=1.2},${4=1},${5=0.25},${6=2},${7=4},${8=1},${9=0}
  repeat $! l[$>]
  to_rgb[0] b={abs($3%*w*$4)}
  +gcd_depth[0] $5,$6,$7,$8
  gcd_stereo[0,1] $1,$2,$3%,$4
  if !$1" && "$9 z. $b,{w-1-$b} fi
  done done

gcd_depth : skip ${1=0.25},${2=2},${3=4},${4=1}
  repeat $! l[$>]
    if w>h if w>700 +r. 700,{h*700/w} else [0] fi
    elif {0,h>700} +r. {0,w*700/h},700 else [0] fi
    median. 7 gcd_segment_ch0. 1
    if $4 gcd_label. $3 else label. $3,1 fi
    c. 0,255 b. 0.45% n. 0,$2 r. [0],[0]
    norm[0] n[0] 0,1 +[-2,-1] b. $1% n. 0,255
  done done

gcd_segment_ch0 : check "${1=1}>=0"
  repeat $! l[$>]
    min={im} + {1+$min} +gradient_norm channels[0] 0
    +f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    *[0,-1] *. -1 watershed.. . rm. - {1+$min}
  done done

gcd_stereo : skip ${1=0},${2=1},${3=1.2%},${4=1}
  l[-2,-1]
    if $1==2 k. return
    elif $1==3 k. negate return fi
    wfac={if(${"is_percent $3"},$3*w,$3)} n. 0,$wfac
    if $1<2" && "$2>0 gcd_balance_anaglyph[0] {2-$2} fi
    i[1] [0] warp[0] .,1 *. -1 warp[1] .,1 rm.
    if $1 rv[0,1] append[0,1] x else shift[0] {round(-$wfac*$4)} shift[1] {round($wfac*$4)}
    channels[0] 0 channels[1] 1,2 append[0,1] c
    fi
  done

gcd_balance_anaglyph : skip ${1=1},${2=0.43},${3=0.45}
  l. sh 0,0 sh[0] 1,1 sh[0] 2,2 +-[2] [1] inv={255^(1-$1)*$2}
    if $1>1 +sign. abs.. ^.. $1 *.. $inv *[-2,-1] else *. $2 fi
    -[2,3] . *. {1/$2-1} +[1,-1] +*[3] 0.65 -. [1] max. 0 *. $3
    -[3] . *. {1/$3-1} +[1,-1] apply_gamma[1] 1.15 rm[1-3] c 0,255
  done

#@gui Undo Anaglyph : gcd_unstereo, gcd_unstereo_preview(1)
#@gui : note = note("<u>Attempt to revert red/cyan anaglyph to 2D</u>")
#@gui : note = note("<b>Warning: with high precision or large image this can be VERY slow!</b>")
#@gui : note = note("\n<i>Displacement Settings</i>"), sep = separator()
#@gui : Precision = float(5,1,6)
#@gui : Smoothness = float(0.1,0,1)
#@gui : Horizontal Warp Only = bool(1)
#@gui : Fast (Low Precision) Preview = bool(1)
#@gui : note = note("\n<i>Tile Settings</i>"), sep = separator()
#@gui : Horizontal Tiles = int(1,1,8)
#@gui : Vertical Tiles = int(1,1,8)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/10/26</i>.</small>")
gcd_unstereo : skip ${1=5},${2=0.1},${3=0},${4=1},${5=1},${6=1},${7=0},${8=0}
  repeat $! l[$>]
    if $4" && "$8 pr=1 else pr=$1 fi # set precision to low for fast preview
    to_rgb[0] split_tiles[0] $5,$6
    repeat $! l[$>]
      s[0] c +equalize[0,1] 256 # split red/green channels to new images
      +displacement.. .,$2,$pr # create displacement map from red/green comparison
      if $3 sh. 1,1 f. 0 rm. fi # remove vertical displacement if selected
      /. 2 warp[1,2] .,1 *. -1 warp[0] .,1 # warp channels
      k[0-2] a c c[0] 0,255 # merge channels back to RGB image
    done done
    append_tiles $5,$6
  done done

gcd_unstereo_preview :
  gui_split_preview "gcd_unstereo ${1--1},1",$-1

#@gui _<b>Testing</b>
#@gui <i>Garagecoder</i>

#@gui Aspect Adjustment : fx_gcd_adjust_aspect, fx_gcd_adjust_aspect(1)
#@gui : note = note("<i>Set or expand to aspect ratio</i>"), sep = separator()
#@gui : Aspect = choice(6,"Original","2:3","3:4","1:1","4:3","5:4","16:9","16:10","2.35:1","1.85:1")
#@gui : Source = choice(1,"Fixed","Dimensions","2:3","3:4","1:1","4:3","5:4","16:9","16:10","2.35:1","1.85:1")
#@gui : Inpaint = choice("None","Flat","Blur","Pyramid")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2024/05/01</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Use fixed source for border expansion</small>")
#@gui : note = note("<small>Dimensions source assumes aspect is width:height</small>")
#@gui : note = note("<small><b>Transparent regions</b> will be inpainted</small>")
fx_gcd_adjust_aspect : skip ${1=6},${2=1},${3=0}
  aspect:=arg($1,{2/3},{3/4},1,{4/3},{5/4},{16/9},{1.6},{2.35},{1.85})
  source:=arg($2,0,{2/3},{3/4},1,{4/3},{5/4},{16/9},{1.6},{2.35},{1.85})
  if $3>0 to_rgba fi
  if $1>0
    if $2>0
      gcd_to_aspect $aspect,$source
    else
      gcd_expand_aspect $aspect
    fi
  fi
  if $3>0
    cmd=${arg\ $3,"gcd_inpaint_flat","gcd_blur_inpaint_auto","gcd_inpaint_pyramid"}
    foreach { sh 100% +neq. 100% $cmd[0] . k[0] }
  fi

# target, source (0 = use dimensions)
# {4/3},{5/4},{16/9},{1.6},{2.35},{1.85}
gcd_to_aspect : skip ${1=16/9},${2=0}
  foreach r {$1/($2>0?$2:w/h)*w},100%,100%,100%,3 done

gcd_expand_aspect : skip ${1=16/9}
  foreach a:=w/h r {$a<$1?(h*$1):w},{$1<$a?(w/$1):h},100%,100%,0,0,0.5,0.5 done

gcd_blur_inpaint_auto : check ${"is_image_arg $1"}
  pass$1 0 ge. 1 +distance. 0 mx:=iM/2 rm. store. msk
  foreach # ( G(P) - G(P * mask) ) / 0->1:G(1 - mask)
    [0] i $msk +mul[0] . eq.. 0
    b[^0] $mx sub[1,-1] max. 1e-4 div[1,-1]
    i $msk j[0] ..,0,0,0,0,1,. k[0]
  done

#@gui Despeckle [test] : gcd_despeckle_test, gcd_despeckle_test(3)
#@gui : note = note("<i>Remove small dots and specks</i>"), sep = separator()
#@gui : Tolerance = int(20,0,50)
#@gui : Max Area = int(10,0,100)
#@gui : ClipIn = bool(0)
#@gui : ClipOut = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.   Latest update : <i>2013/02/01</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set max area to 0 for no area size limit.</small>")
gcd_despeckle_test : skip ${1=15},${2=30}
  repeat $! l[$>]
    if $3 c 0,255 fi
    ma={if(!$2,w*h,$2)}
    +label. $1,1 nb={1+iM}
    +histogram. $nb,0,{$nb-1}
    map.. . rm.
    le. $ma inpaint.. . rm.
    if $4 c 0,255 fi
  done done

#@gui Simple Tone Curve : gcd_simple_tonecurve, gcd_simple_tonecurve(1)
#@gui : note = note("<i>Luminance adjustment with local contrast restoration</i>"), sep = separator()
#@gui : Contrast = float(0.5,0,1)
#@gui : Brightness = float(0.5,0,1)
#@gui : Saturation = float(1,0,2)
#@gui : note = note("\n<i>Advanced Options</i>"), sep = separator()
#@gui : Fulcrum = float(0.18,0,0.5)
#@gui : Detail = float(0.75,0,2)
#@gui : Input = choice(1,"Linear RGB","sRGB")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2023/12/28</i>.</small>")
gcd_simple_tonecurve : skip ${1=0.5},${2=0.5},${3=1},${4=0.18},${5=0},${6=1}
  foreach {
    contrast,bright,sat,F={T=1e-5;[vmax(vmin([$1,$2],1-T),T),$3,$4]}

    sh 0,2
    if $6 gcd_srgb2rgb. /. 255 fi

    # norm = luminance
    +gcd_rgb2luminance.

    # local contrast
    +gcd_weighted_box. $5%,1 +eq. 0 +. .. /[-3,-1]

    if $6 in_max,m:=1,1 else in_max,m:=iM#-3,iM fi

    # contrast = (x-F) / ((1-A)*(x-F)/R + A) + F # R = (x-F)>0 ? 1-F : -F
    A:=t=0.5;(t-t*$contrast)/($contrast-t*$contrast)
    /. $m -. $F +gt. 0 -. $F ^. -1 *. .. *. {1-$A} +. $A /[-2,-1] +. $F *. $m

    # brightness = x / (x - Ax + A)
    A:=t=0.5;(t-t*$bright)/($bright-t*$bright)
    +*. {(1-$A)/$m} +. $A /[-2,-1]

    # restore local contrast
    *[-2,-1]

    # saturation and recombine norm
    ^.. $sat +gcd_rgb2luminance.. +eq. 0 +[-2,-1] /[-3,-1] *[-2,-1]

    gcd_softcut. 0,$in_max
    if $6 *. 255 gcd_rgb2srgb. fi
    rm.
  }

#@gui Weighted Boxfilter : fx_gcd_weighted_boxfilter, fx_gcd_weighted_boxfilter(0)
#@gui : note = note("<i>Weighted box average filter</i>"), sep = separator()
#@gui : Radius = float(1,0,2)
#@gui : Weight = float(0,-2,2)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2023/09/30</i>.</small>")
fx_gcd_weighted_boxfilter : skip ${1=1},${2=1},${3=0}
  ac "gcd_weighted_box[0] $1%,$2",$3

#@cli gcd_weighted_box : size>=0[%],_weight,_tolerance>=0
#@cli : Filter selected images by weighted box filter of specified size.
#@cli : Default values: 'size=1', 'weight=1' and 'tolerance=1e-6'.
#@cli : $ image.jpg gcd_weighted_box 1%,-2
gcd_weighted_box : skip ${1=3},${2=0},${3=1e-6}
  foreach {
    C,R,s:=H=iM-im;[H/2+im,H,s] - $C / $R
    +sqr boxfilter $1 +sqr.. -[-2,-1]
    ++. $3 sqrt. *. $2 +[0,-1] compose_channels. + /. $s
    max. $3 ^. -1 *[0] . boxfilter $1 +eq. 0 +[-2,-1] /
    c -0.5,0.5 * $R + $C
  }

#@gui Canny Edge Detection : fx_gcd_canny, fx_gcd_canny(0)
#@gui : note = note("<i>Locate image edges using canny edge detector</i>"), sep = separator()
#@gui : Sigma = float(1,0,10)
#@gui : Lower Threshold = float(0.05,0,1)
#@gui : Upper Threshold = float(0.15,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2023/12/04</i>.</small>")
fx_gcd_canny :
  foreach {
    split_opacity
    gcd_canny[0] $1,{[max($2,1e-6),max($3,1e-6)]}
    *[0] 255 a c
  }

#@cli gcd_canny : sigma,_low_threshold,_high_threshold
#@cli : Locate image edges using canny edge detector.
#@cli : Default values: 'sigma=1', '_low_threshold=0.05' and 'high_threshold=0.15'.
#@cli : $ image.jpg gcd_canny 1.5
gcd_canny : skip ${1=1},${2=0.05},${3=0.15}
  e[^-1] "Apply canny edge detection for image$?, with sigma $1."
  foreach {
    low,high:=[$2*$3,$3]
    # gaussian
    b $1
    # sobel
    (1,2,1;0,0,0;-1,-2,-1)
    +convolve[0] . transpose.. convolve[0] .. rm..
    # polar coord regions
    +atan2.. . sqr[0,1] +[0,1] sqrt..
    mul. {4/pi} round. 1 mod. 4
    # non-maximum suppression
    f.. "
      A=i#1;
      Y=A<1?max(j(0,-1),j(0,1)):A<2?max(j(-1,-1),j(1,1)):A<3?max(j(-1),j(1)):max(j(-1,1),j(1,-1));
      i>=Y?i:0
    " rm.
    # double thresholds
    div {iM} +ge $high ge.. $low
    # hysteresis
    f. ">max(crop(x-1,y-1,z,c,3,3,1,1))&&i#0?1:i"
    f. "<max(crop(x-1,y-1,z,c,3,3,1,1))&&i#0?1:i" rm..
  }

#@gui Simple Dehaze : gcd_simple_dehaze, gcd_simple_dehaze(1)
#@gui : note = note("<i>Simple sRGB dehaze</i>"), sep = separator()
#@gui : Haze = float(0.75,0,1)
#@gui : Exposure = float(1,0,2)
#@gui : Scale = float(0.75,0,25)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2023/04/08</i>.</small>")
gcd_simple_dehaze : skip ${1=0.75},${2=1},${3=0.75}
  foreach {
    split_opacity
    l[0] {
      srgb2rgb div 255
      +gcd_erode_vw $3% compose_channels. min => msk
      #X = n(Y - hT) / (1 - nT)
      +mul[msk] $1 sub[0,-1] max[0] 0 mul[0] $2 # (Y - hT)
      mul[msk] -$2 add[msk] 1 max[msk] 0 # (1 - T)
      +eq[msk] 0 add[msk,-1]
      +compose_channels[0] max
      max[msk,-1] div[0,msk] # divide
      mul 255 rgb2srgb
    }
    a c
  }

#@cli gcd_erode_vw : size>=0[%],_tolerance>=0
#@cli : Filter selected images by variance weighted erosion of specified size.
#@cli : Default values: 'size=3' and 'tolerance=1e-6'.
#@cli : $ image.jpg gcd_erode_vw 5
gcd_erode_vw : skip ${1=3},${2=1e-6}
  foreach {
    C,R:=H=iM-im;[H/2+im,H] - $C / $R
    +sqr boxfilter $1 +sqr.. -[-2,-1]
    ++. $2 sqrt. -[0,-1] r. 100%,100%,100%,1,2
    max. $2 ^. -1 *[0] . boxfilter $1 +eq. 0 +[-2,-1] /
    c -0.5,0.5 * $R + $C
  }

#@cli gcd_dilate_vw : size>=0[%],_tolerance>=0
#@cli : Filter selected images by variance weighted dilation of specified size.
#@cli : Default values: 'size=3' and 'tolerance=1e-6'.
#@cli : $ image.jpg gcd_dilate_vw 5
gcd_dilate_vw : skip ${1=3},${2=1e-6}
  foreach {
    C,R:=H=iM-im;[H/2+im,H] - $C / $R
    +sqr boxfilter $1 +sqr.. -[-2,-1]
    ++. $2 sqrt. +[0,-1] r. 100%,100%,100%,1,2
    max. $2 ^. -1 *[0] . boxfilter $1 +eq. 0 +[-2,-1] /
    c -0.5,0.5 * $R + $C
  }

#@gui Colored signum : fx_gcd_signum_color, fx_gcd_signum_color(1)
#@gui : sep = separator()
#@gui : Sigma1 = float(0.1,0,1)
#@gui : Sigma2 = float(5,0,20)
#@gui : Axes1 = choice(2,"xy","x","y")
#@gui : Axes2 = choice(0,"xy","x","y")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/11/01</i>.</small>")
fx_gcd_signum_color : skip ${1=0.1},${2=5},${3=2},${4=0}
  foreach {
    split_opacity l[0] {
      m:=[im,iM] axesA=${arg\ 1+$3,xy,x,y} axesB=${arg\ 1+$4,xy,x,y}
      +sqr compose_channels. + /. {-1,s} sqrt. +eq. 0 +[-2,-1] /.. .
      b. $axesA,$1% +b. $axesB,$2% -[-2,-1] sign. +. 1 * n $m
    } a c
  }

#@gui Gradient Exponent : fx_gcd_gradient_exponent, fx_gcd_gradient_exponent(1)
#@gui : note = note("<i>Adjust global gradient ratios</i>"), sep = separator()
#@gui : Exponent = float(0.5,0,2)
#@gui : sep = separator()
#@gui : Channels = choice(0,"RGB","HSI","HSV","YCbCr","Lab")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/09/02</i>.</small>")
fx_gcd_gradient_exponent : skip ${1=0.5},${2=0}
  mode=${arg0\ $2,rgb,hsi8_i,hsv8_v,ycbcr_y,lab8_l}
  foreach { ac "gcd_gradient_exponent $1",$mode }

#@cli gcd_gradient_exponent : exponent
#@cli : Adjust gradient ratios via laplacian inversion.
#@cli : Default values: 'exponent=0.5'.
#@cli : $ image.jpg gcd_gradient_exponent 0.5
gcd_gradient_exponent : skip ${1=0.5}
  e[^-1] "Adjust gradient ratios for image$?, with exponent $1."
  foreach {
    repeat s { sh $> l. {
      m={[im,iM]} g xy,1,2
      foreach { +abs ^. $1 sign.. * }
      g.. x,-1,2 g. y,-1,2 + ilaplacian 0 n $m
    } rm. }
  }

#@gui Upscale [Recursive2x] : fx_gcd_upscale_recursive2x, fx_gcd_upscale_recursive2x_preview(0)
#@gui : note = note("<u>Self similarity 2x upscale</u>")
#@gui : note = note("\n<i>Quality Options</i>"), sep = separator()
#@gui : Kernel = _int(4,0,10)
#@gui : note = note("\n<i>Processing Options</i>"), sep = separator()
#@gui : Sharpness = float(0.05,0,0.4)
#@gui : Grain = float(0.01,0,0.1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2023/02/14</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Preview is fixed to lowest quality kernel.</small>")
#@gui : note = note("<small>Kernel size zero will use randomized matching.</small>")
#@gui : note = note("<small>Due to the algorithm some glitches are expected.</small>")
#@gui : note = note("<small>\n<b>Warning:</b> large kernels are slow to compute.</small>")
#@gui : note = note("<small>Image size also affects computation time significantly.</small>")
fx_gcd_upscale_recursive2x : skip ${1=4},${2=0.05},${3=0.01}
  foreach {
    split_opacity
    gcd_upscale_recursive2x[0] {[$1,1-$2,0.25,round(1/log(1+$3))]}
    if $!>1 # 2x bilateral upscale opacity
      (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
      r[1] 200%,200%,100%,100%,1 convolve[1] . rm. a c
    fi
  }

fx_gcd_upscale_recursive2x_preview :
  fx_gcd_upscale_recursive2x 1,${2--1}

#@cli gcd_upscale_recursive2x : search_size>0,0<=_sharpening<=1,0<=_smoothing<=1,_noise_divisor>0
#@cli : Double image size using processed recursive expansion.
#@cli : Default values: 'search_size=4', 'sharpening=0.9', 'smoothing=0.25' and 'noise_divisor=100'.
#@cli : $ image.jpg gcd_upscale_recursive2x 4
gcd_upscale_recursive2x : skip ${1=4},${2=0.95},${3=0.25},${4=100}
  e[^-1] "Double xy-dimensions of image$?, using Recursive2x algorithm."
  foreach {
    m={0,[im,iM]} =>[0] small
    # force even dimensions
    wh:=[w,h]*2 r {[w+w%2,h+h%2]},100%,100%,0,1
    # pre sharpening
    gcd_midrange_exponent $2 c $m
    # self-similar upscale
    +gcd_proximity_ssu2x[0] $1 => large
    # post texture smoothing
    gcd_box_texture[large] 2,$3
    # error diffusion
    +gcd_random[large] {X=iM-im;[-X,X]/$4} +[large,-1]
    +ri[large] [small],2 sub. [small] ri. [large]
    (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
    convolve.. . rm. sub[large,-1]
    rm[small] c[large] $m mv[large] 0
    # restore 2n dimensions
    r $wh,100%,100%,0
  }

#@cli gcd_proximity_ssu2x : search_size>0
#@cli : Double image size using self-similar upscaling.
#@cli : Default values: 'search_size=4'.
#@cli : $ image.jpg gcd_proximity_ssu2x 4
gcd_proximity_ssu2x : skip ${1=4}
  e[^-1] "Double xy-dimensions of image$?, using ssu2x algorithm."
  foreach {
    [0],[0],[0],2
    +rs[0] 50%
    if $1>0
      # calculate search offset coords
      K:=$1*2+1
      $K,$K,1,2,"X=[x,y]-$1;sign(X)*X*X"
      s. c y[-2,-1] x
      # find best matches
      eval[0] ":
        begin(
          const boundary=0;
          const interpolation=0;
          L=crop(#-2);
          M=crop(#-1);
          const S=w#-1;
        );
        X=floor(x/2);
        Y=floor(y/2);
        V=X; W=Y; D=inf;
        P=crop(x-1,y-1,3,3);
        for(K=0,K<S,++K,
          A=X+L[K]; B=Y+M[K];
          Q=crop(#2,A-1,B-1,3,3);
          N=sum(abs(P-Q));
          if(N<D,V=A;W=B;D=N);
        );
        I(#1,x,y)=[V,W];"
    else
      +matchpatch[0] [2],3,3,1,10,15,-2 j[1] . rm.
    fi
    # calculate patch intensity corrections
    +boxfilter[0,2] 3 warp. [1],0 +eq. 0 +[-2,-1] /[-2,-1]
    # upscale and correct intensities
    mul[1] 2 r[1] 200%,200%,100%,100%,1 f[1] "I+[x%2,y%2]"
    warp[0] [1],0 r. 200%,200%,100%,100%,1 mul[0,-1] k[0]
  }

#@gui Upscale [Patch2x] : fx_gcd_upscale_patch2x, fx_gcd_upscale_patch2x_preview(0)
#@gui : Type = choice("Patch2x","Tile2x","Patch4x","Tile4x")
#@gui : Smoothing = bool(0)
#@gui : sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2025/01/10</i>.</small>")
#@gui : sep = separator()
#@gui : note = note("<small>Note: Results are partially random.</small>")
fx_gcd_upscale_patch2x : skip ${1=0},${2=0}
  foreach {
    split_opacity
    if $2
      gcd_box_texture_var[0] 5,0.001
    fi
    if $1>2 gcd_upscale_tile2x[0] gcd_upscale_tile2x[0]
    elif $1>1 gcd_upscale_patch2x[0] gcd_upscale_patch2x[0]
    elif $1>0 gcd_upscale_tile2x[0]
    else gcd_upscale_patch2x[0]
    fi
    if $!>1 # 2x bilateral upscale opacity
      repeat int($1/2)+1 {
        (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
        r[1] 200%,200%,100%,100%,1 convolve[1] . rm.
      }
      a c
    fi
  }

fx_gcd_upscale_patch2x_preview :
  A,B:=P=0.5/($1<2?2:4);[-P,P]*100+50
  z $A%,$A%,$B%,$B% fx_gcd_upscale_patch2x $*

#@cli gcd_upscale_tile2x
#@cli : Double image size using self-similarity and anisotropic convolution.
#@cli : $ image.jpg +gcd_upscale_tile2x
gcd_upscale_tile2x :
  foreach {
    # [range] [up] [hi_orig] [losat] [upsat]
    ps,ol:=[32,8] pd:=[w,h,$ol]*2 sz={[w,h,0]*2+1}

    # up
    (0.25,1,0.25;1,4,1;0.25,1,0.25) /. 9
    +gcd_upscale_solver2x[0] 2 convolve. .. rm..

    # hi, lo
    [0]x2 b. 0.67 sub.. .

    # losat, upsat
    [1] mix_channels[-2,-1] (3,-1,-1;-1,3,-1;-1,-1,3)

    img2patches[0,2,3] $ps,$ol
    img2patches[1,4] {[$ps,$ol]*2}

    # range
    +dilate[0] $sz z. 0,0,0,0 compose_channels. max
    erode[0] $sz z[0] 0,0,0,0 compose_channels[0] min a[0,-1] c
    r[0] [1],[1],100%,100%,1

    # match patches
    l[-2,-1] {
      d:=d s z
      repeat $d { matchpatch[{$d+$>}] [$>],3,3,1,12,13 progress {100*$>/$d} }
      a[50%-100%] z k. r 100%,100%,100%,3,0 sh. 2 f. z rm.
    }

    # warp, add, clamp, assemble
    warp[2] .,0 add[1] [2]
    sh[0] 0 max[1] . rm.
    sh[0] 1 min[1] . rm.
    k[1] patches2img $pd
  }

#@cli gcd_upscale_patch2x
#@cli : Double image size using randomized self-similar matching.
#@cli : $ image.jpg +gcd_upscale_patch2x
gcd_upscale_patch2x :
  foreach {
    m:=[im,iM]
    (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
    +r[0] 200%,200%,100%,100%,1 convolve. .. rm..
    [-1] +b[0] 0.67 sub[0] .
    mix_channels[-2,-1] (3,-1,-1;-1,3,-1;-1,-1,3)
    matchpatch.. .,3,3,1,12,13 rm.
    warp[0] .,0 add[0,1] k[0] c $m
  }

#@cli gcd_midrange_exponent : exponent<=1
#@cli : Sharpen selected images by midrange exponent method.
#@cli : Default values: 'exponent=0.5'.
#@cli : $ image.jpg gcd_midrange_exponent 0.8
gcd_midrange_exponent : skip ${1=0.5}
  e[^-1] "Sharpen image$? with midrange exponent $1."
  foreach {
    C,R:=H=(iM-im)/2;[H+im,H] - $C / $R
    i (0,1,0;1,1,1;0,1,0) +dilate.. . +erode... .. rm[1]
    -.. . /.. 2 +. .. -[0] . +eq[1] 0 +. [1] /[0,-1]
    ^[1] $1 *[0,1] + * $R + $C
  }

#@cli gcd_box_texture : size>=0[%],0<=edge_exponent<=1
#@cli : Edge preserving smooth.
#@cli : Default values: 'size=3' and 'edge_exponent=0.5'.
#@cli : $ image.jpg gcd_box_texture 3
gcd_box_texture : skip ${1=3},${2=0.5}
  e[^-1] "Apply box texture filter of size $1, on image$?."
  foreach { # i = i + (A(k) - i) / stddev(k)^p
    [0] +sqr. boxfilter[-2,-1] $1 +sqr.. -[-2,-1]
    max. 0 +eq. 0 +[-2,-1] sqrt. ^. -$2
    j[0] ..,0,0,0,0,1,. k[0]
  }

#@cli gcd_box_texture_var : size>1[%],_smoothing>=0
#@cli : Edge preserving smooth.
#@cli : Default values: 'size=3' and 'smoothing=0.001'.
#@cli : $ image.jpg gcd_box_texture_var 5,0.1
gcd_box_texture_var : skip ${1=3},${2=1e-3}
  e[^-1] "Apply box texture filter of size $1, on image$?."
  foreach { # i = i + (A(k) - i) / max(var(k)*s,1)
    [0]x2 sqr. boxfilter[-2,-1] $1 +sqr.. -[-2,-1]
    /. {0,sqr((iM-im)/2)*$2} max. 1
    -[1] [0] /[1] . +[0] [1] k[0]
  }

#@gui Upscale [Solver2x] : fx_gcd_upscale_solver2x, fx_gcd_upscale_solver2x_preview(0)
#@gui : note = note("<u>Anisotropic 2x upscale with optional unsharpening</u>")
#@gui : note = note("\n<i>Quality Options</i>"), sep = separator()
#@gui : Kernel = _int(4,1,6)
#@gui : note = note("\n<i>Unsharp Options</i>"), sep = separator()
#@gui : Enabled = bool(0)
#@gui : Radius = float(1,0,30)
#@gui : Amount = float(1,0,5)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/12/20</i>.</small>")
#@gui : note = note("\n<small><b><u>Usage</u></b></small>")
#@gui : note = note("<small>Preview is fixed to lowest quality kernel.</small>")
#@gui : note = note("<small>Very small images tend to require a small kernel.</small>")
#@gui : note = note("<small>Enable unsharpening to counteract prominent halos.</small>")
#@gui : note = note("<small>\n<b>Warning:</b> large kernels are slow to compute.</small>")
#@gui : note = note("<small>Image size also affects computation time significantly.</small>")
fx_gcd_upscale_solver2x : skip ${1=4},${2=0},${3=1},${4=1}
  foreach {
    split_opacity
    if $2 gcd_reverse_unsharp[0] $3,$4 fi
    gcd_upscale_solver2x[0] $1
    if $!>1 # 2x bilateral upscale opacity
      (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
      r[1] 200%,200%,100%,100%,1 convolve[1] . rm. a c
    fi
  }

fx_gcd_upscale_solver2x_preview :
  fx_gcd_upscale_solver2x 1,${2--1}

#@cli gcd_upscale_solver2x : _size>=1,_kernels_only={ 0 | 1 }
#@cli : Double image size using anisotropic kernel solver interpolation.
#@cli : Default values: 'size=4' and 'kernels_only=0'.
#@cli : $ image.jpg +gcd_upscale_solver2x 3
gcd_upscale_solver2x : skip ${1=4},${2=0}
  foreach {
    nm:=n m:=[im,iM]
    +z[0] 0,0,{floor([w,h]/2)*2-1} => crop
    +r. 50%,50%,100%,100%,2 ri. .. => dnup
    rv[-2,-1]
    # get gradient orientations
    +r[0] 100%,100%,100%,1,2
    (0,-0.25,-0.25;0.25,0,-0.25;0.25,0.25,0)
    +convolve.. . mirror.. x convolve... ..
    rm.. atan2.. . rm.
    /. {pi/2} round. 1 mod. 4 -. {im} D:=iM+1 => dirs
    +r[dirs] [crop],[crop],[crop],100%,0 => cdirs
    # get kernels per direction
    r[dnup,crop] 100%,100%,100%,1,2
    repeat $D {
      progress {100*$>/$D}
      +eq[cdirs] $>
      +gcd_solve_kernel[dnup] [crop],$1,[-1]
      rm..
    }
    rm[dnup,crop,cdirs]
    if $2 k[-$D--1] return fi
    i[1] [0] =>[1] small
    r[0,dirs] 200%,200%,100%,100%,1
    i[1] [0] =>[1] target
    # convolve and merge
    repeat $D {
      +convolve[0] [-{$<+1}]
      +eq[dirs] $>
      j[target] ..,0,0,0,0,1,.
      rm[-2,-1]
    }
    # error correction: ensure downscaled ~= original
    k[small,target]
    +ri[target] [small],2 sub. [small]
    ri. [target] sub[target,-1] rm[small]
    k[target] c $m => $nm
  }

#@gui Inpaint [Clone] : fx_gcd_clone_inpaint, fx_gcd_clone_inpaint(1)
#@gui : note = note("<i>Simple proximity cloning inpaint for object removal</i>"), sep = separator()
#@gui : Type = choice("Horizontal","Vertical")
#@gui : Bias = choice(1,"Left/Top","None","Right/Bottom")
#@gui : Scale = float(10,1,100)
#@gui : Blend to boundary = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/08/08</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small><b>Transparent regions</b> will be inpainted</small>")
#@gui : note = note("<small>This filter is <b>not automatic</b>: adjust scale as required</small>")
#@gui : note = note("<small>For best results, inpaint a single region with a simple shape</small>")
fx_gcd_clone_inpaint : skip ${1=0},${2=1},${3=10},${4=1}
  foreach {
    S:=max(3,round(0.25*max(w,h)*$3%))
    if $1 transpose fi
    to_rgba sh 100% eq. 100% mul
    _gcd_clone_patch_sources $S,{arg0($2,1,0.5,0)}
    +_gcd_clone_draw_inpaint_patches.. .,$S
    split_opacity[0]
    if $4
      neq[1] 0 rv[1,-1] _gcd_clone_inner_blend[0,1,-1] k[0] c 0,255
    else
      eq[1] 0 j[0] .,0,0,0,0,1,[1] k[0]
    fi
    if $1 transpose fi
  }

_gcd_clone_patch_sources : skip ${1=20},${2=0.5},${3=2}
  sh 100% => alpha
  4,1,1,1 1,[0],1,1 1,[0],1,1
  eval[alpha] "
    begin(xmin=w#0; xmax=-1; ymin=h#0; ymax=-1);
    if(x==0, L=w#0; R=-1);
    if(i==0,
      x<L?L=x; R=x;
      y<ymin?ymin=y; ymax=y;
      L<xmin?xmin=L;
      R>xmax?xmax=R;
    );
    i[#-2,y]=L; i[#-1,y]=R;
    end(i[#-3,0]=xmin;i[#-3,1]=xmax;i[#-3,2]=ymin;i[#-3,3]=ymax;)
  "
  rm[alpha]
  K:=$1*2+1 erode.. $K dilate. $K -.. 1 +. 1
  ymin,ymax:=[i[#-3,2],i[#-3,3]]
  xtopL,xtopR:=[i[#-2,$ymin],i[#-1,$ymin]]
  xbotL,xbotR:=[i[#-2,$ymax],i[#-1,$ymax]]
  f.. "y<$ymin?$xtopL:y>$ymax?$xbotL:i"
  f. "y<$ymin?$xtopR:y>$ymax?$xbotR:i"
  rm[-3] D:=round($1/$3)*2
  {ceil([w#0/$D,h#0/$D,d#0])},1,"
    begin(
        const S=$1; const K=$1*2+1;
        const EL=K-1; const ER=w#0-2-K;
        const D=$D;
    );
    X=x*D; Y=y*D;
    L=i[#1,Y];
    R=i[#2,Y];
    LX=X-L; RX=R-X;
    L>EL&&(LX/(LX+RX)<$2||R>ER)?-LX-S:RX+S;
  "
  rm[1,2]

_gcd_clone_draw_inpaint_patches : skip ${2=8},${3=2}
  pass$1 0 => points
  repeat $!-1 l[$>,-1] {
    split_opacity[0]
    P:=$2 Q:=round($2/$3) J:=$P*2+1 K:=$Q*2+1 C:=$P-$Q
    $J,$J,1,1 $K,$K,1,1,1 j.. .,$C,$C rm.
    distance. 1 n. 0,1 *. -1 +. 1 f. "i*i*i*(i*(i*6-15)+10)"
    [0] f[0] 0 # [orig] [alpha] [points] [mask] [orig]
    eval[points] "
    begin(const S=$2; const K=S*2+1; const D=$Q*2; ref(crop(#-2),M));
      X=x*D; Y=y*D;
      U=i-S+X; V=Y-S;
      ref(crop(#-1,U,V,K,K),patch);
      ref(crop(#1,U,V,K,K),W);
      draw(#0,patch,X-S,Y-S,0,0,K,K,1,s#0,1,M*W);
    "
    rm[1,-2,-1]
  } done rm.

_gcd_clone_inner_blend :
  # inputs: two images and a mask (0 = inner)
  dim:=max(w,h)
  [0],[0],[0],[0]
  [1],[1],[1],[1]
  [2],[2],[2],[2]
  repeat 12 {
    K:=round($dim/2^$>)
    if $K<=1 break fi
    j[-3] [0] j[-2] [1] j[-1] [2]
    l[-3] { +neq 0 boxfilter $K +eq. 0 +[-2,-1] /[0,-1] }
    l[-2] { +neq 0 boxfilter $K +eq. 0 +[-2,-1] /[0,-1] }
    dilate. $K neq. [2] *.. -1 +.. [1] +.. ...
    j[0] ..,0,0,0,0,1,.
  }

#@gui Dither sRGB : fx_gcd_dither_srgb, fx_gcd_dither_srgb(0)
#@gui : note = note("<i>Dither sRGB image with selected levels per channel</i>"), sep = separator()
#@gui : Levels = int(2,2,16)
#@gui : Luminance = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2021/10/17</i>.</small>")
fx_gcd_dither_srgb : skip ${1=2},${2=1}
  repeat $! l[$>]
    split_opacity
    if $2 gcd_srgb2luma[0] fi
    gcd_dither_srgb[0] $1 round[0] a c
  done done

#@gui Geometric Color Balance : gcd_geometric_balance, gcd_geometric_balance(1)
#@gui : note = note("<i>Equalize XYZ channel gammas</i>"), sep = separator()
#@gui : note = note("<i>Input is assumed to be sRGB D65 [0,255]</i>")
#@gui : Target = float(0,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2019/01/01</i>.</small>")
#@gui : note = note("\n<small>Set target to zero to use input Y geometric mean.</small>")
gcd_geometric_balance : skip ${1=0}
  repeat $! l[$>]
    split_opacity
    l[0] to_rgb
    s c n 0,255 a c
    srgb2rgb rgb2xyz
    m={[im,iM]} n 0.002,0.998 log +r 1,1,1,100%,2
    gm={$1>0?log(min(max($1,0.002),0.998)):i[#1,1]}
    repeat s#1 sh[0] $> *. {$gm/i[#1,$>]} rm. done rm. exp n $m
    xyz2rgb rgb2srgb
    s c n 0,255 a c
    done a c
  done done

#@gui Local F-Mean : gcd_fx_local_fmean, gcd_fx_local_fmean(1)
#@gui : note = note("<i>Map local f-mean to match global or target</i>"), sep = separator()
#@gui : Radius = float(15,0,100)
#@gui : Bright = float(0,0,1)
#@gui : Mean = choice(0,"Harmonic","Geometric","Arithmetic","Quadratic")
#@gui : Channels = choice(5,"HSI","HSV","Lab","Linear RGB","RGB","Luminance","YCbCr")
#@gui : Normalize = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2019/05/11</i>.</small>")
#@gui : note = link("https://en.wikipedia.org/wiki/Quasi-arithmetic_mean")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set bright to zero to auto match global f-mean</small>")
#@gui : note = note("<small>Normalize will disable bright control for arithmetic and quadratic</small>")
gcd_fx_local_fmean : skip ${1=15},${2=0},${3=0},${4=5},${5=0}
  mode=${arg0\ $4,hsi8_i,hsv8_v,lab8_l,lrgb,rgb,gcd_luminance,ycbcr_y}
  if $5 ac "r={[im,iM]} n 0.002,0.998 gcd_fmean_local $1%,{$3-1},$2 n $r",$mode,2
  else ac "/ 255 gcd_fmean_local $1%,{$3-1},$2 * 255",$mode,1
  fi u "{$1}{$2}_"{2-($3>1" && "$5==1)}"{$3}{$4}{$5}"

#@cli gcd_fmean_local : std_deviation>=0[%],-1<=_mean_type<=2,_target>=0
#@cli : Map local f-mean to match global or target.
#@cli : Value range is assumed to be 0 <= input <= 1.
#@cli : When target is zero, it will be set to the global f-mean.
#@cli : Default values: 'std_deviation=1', '_mean_type=0' and '_target=0'.
#@cli : $ image.jpg n 0,1 gcd_fmean_local 1%
gcd_fmean_local : check "${1=1}>=0 && isint(${2=0}) && $2>=-1 && $2<=2 && ${3=0}>=0"
  e[^-1] "Map local f-mean of image$?."
  func=${arg\ 2+$2,hmean,gmean,mean,qmean}
  _gcd_$func m _gcd_func:$_gcd_f m _gcd_finv:$_gcd_i
  repeat $! l[$>] # [1]=nz [2]=(1-G(iz))
    +neq. 0 +eq. 0 +[0] . zs={is} b. $1 *. .. *. -1 +. 1 ($3)
    _gcd_func[0,-1] *[0] [1] # x = f(x), f(0) = 0
    d={0,$3==0?is/(whds-$zs):i#-1} rm. # d = global(f(X))
    +b[0] $1 +eq. 0 +[-2,-1] /[-2,-1] # (1 - z) / b
    *[0] $d *[0,-1] # x = x * d / local(f(X))
    _gcd_finv[0] * # x = f^-1(x), restore zeros
  done done
  uncommand _gcd_func,_gcd_finv

_gcd_qmean : _gcd_f="sqr" _gcd_i="sqrt"
_gcd_mean : _gcd_f="skip 0" _gcd_i="skip 0"
_gcd_gmean : _gcd_f="log" _gcd_i="exp"
_gcd_hmean : _gcd_f="^ -1 - 1" _gcd_i="+ 1 ^ -1"

_ac_gcd_luminance : # not strictly correct due to gamut losses
  _p="to_color"
  _f="srgb2rgb rgb2xyz8 sh 1 a c"
  _b="s c,{1-s} sh.. 1 +eq. 0 +[-2,-1] /[-2,-1] * xyz82rgb rgb2srgb"
  _s=3

#@gui CRMT Tiles : fx_gcd_crmt_tile, fx_gcd_crmt_tile(1)
#@gui : note = note("<i>Tiling by Clone, Rotate, Mirror, Translate method.</i>"), sep = separator()
#@gui : Constants = text{"t_w=[w] t_h=[round(1/2*sqrt(3)*$t_w)]"}
#@gui : Render Size = text("[3*$t_w,2*$t_h]")
#@gui : Command List = text{1,"C0 T0 C0 Fo R-60 T[-1/2*$t_w,0]"}
#@gui : Inpaint = bool(0)
#@gui : sep = separator(), note = note("<small>Implementation : <i>Garagecoder</i>.     Latest update : <i>2019/05/10</i>.</small>")
#@gui : note = note("<small>Author: <i>G. Bachelier</i></small>")
#@gui : note = note("\n<b>Warning</b>: alpha version, don't expect perfection!")
fx_gcd_crmt_tile :
  to_a
  m "_crmt_tile_C : [$""1]"
  m "_crmt_tile_R : rotate. $""1 autocrop."
  m "_crmt_tile_Fo : mirror. x"
  m "_crmt_tile_Fi : mirror. y"
  macros="sind(A)=sin(A/180*pi);cosd(A)=cos(A/180*pi);tand(A)=tan(A/180*pi);"
  ('"_crmt_tiling_command : $1 {``$2},1,4 => _crmt_render $3"')
  replace_str. "C","_crmt_tile_C "
  replace_str. "Fo","_crmt_tile_Fo "
  replace_str. "Fi","_crmt_tile_Fi "
  replace_str. "R","_crmt_tile_R "
  replace_str. "T","_crmt_tile_T "
  replace_str. "[","{"$macros"["
  replace_str. "]","]}"
  m {t}
  rm.
    _crmt_tiling_command k[_crmt_render]
    if $4
      +channels[0] 100% negate. dilate. 3
      inpaint[0] .,0,0 rm.
    fi
  uncommand _crmt_tiling_command

_crmt_tile_T : skip ${1=0},${2=0} # this command renders the tile
  f. ":i3>0?I(#"{``${_crmt_render}}",$1+x,$2+y)=I;i" rm.

#@gui Deblur Texture : fx_gcd_blur_deblur_texture, fx_gcd_blur_deblur_texture_preview(0)
#@gui : note = note("<i>Variance-based edge preserving deblur or smooth</i>"), sep = separator()
#@gui : Iters = int(4,1,20)
#@gui : Sigma = float(1,0,4)
#@gui : Edges = float(0.5,0,1)
#@gui : Action = choice("Deblur","Smooth")
#@gui : Channels = choice(2,"RGB","Linear RGB","Luma","Chroma")
#@gui : Percentage Sigma = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/09/02</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Iters: overall amount, increases computation time.</small>")
#@gui : note = note("<small>Sigma: detail scale.</small>")
#@gui : note = note("<small>Edges: amount of edge preservation.</small>")
#@gui : note = note("<small>Percentage sigma: make detail scale relative to image size.</small>")
fx_gcd_blur_deblur_texture : skip ${1=4},${2=1},${3=0.5},${4=0},${5=2},${6=0}
  repeat $! l[$>]
    mode=${arg\ 1+$5,rgb,lrgb,ycbcr_y,ycbcr_cbcr}
    if $6 r=$2% else r=$2 fi
    if $4 ac "repeat $1 gcd_blur_texture "$r",$3 done",$mode,1
    else ac "repeat $1 +l +gcd_blur_texture "$r",$3 norm - done + done",$mode,1 fi
  done done

fx_gcd_blur_deblur_texture_preview :
  gui_split_preview "fx_gcd_blur_deblur_texture $*",${-3--1}

#@cli gcd_blur_texture : std_deviation>=0[%],0<=edge_exponent<=1
#@cli : Edge preserving smooth.
#@cli : Default values: 'std_deviation=1' and 'edge_exponent=1'.
#@cli : $ image.jpg gcd_blur_texture 1
gcd_blur_texture : skip ${1=1},${2=1}
  e[^-1] "Apply blur texture filter of size $1, on image$?."
  repeat $! l[$>] # i = i + (A(k) - i) / stddev(k)^p
    [0] +sqr. b[-2,-1] $1 +sqr.. -[-2,-1]
    max. 0 +eq. 0 +[-2,-1] sqrt. ^. -$2
    j[0] ..,0,0,0,0,1,. k[0]
  done done

#@gui Undo Unsharp Mask : fx_gcd_undo_unsharp, fx_gcd_undo_unsharp_preview(0)
#@gui : note = note("<i>Reverse the effect of an unsharp mask</i>"), sep = separator()
#@gui : Radius = float(3,0,30)
#@gui : Amount = float(0.5,0,5)
#@gui : Type = choice(1,"Box","Gaussian")
#@gui : sep = separator()
#@gui : Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal",
#@gui : "Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right",
#@gui : "Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2021/12/19</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Useful for fixing halos due to excessive unsharp mask application.</small>")
#@gui : note = note("<small>For best results, settings should match the original unsharp filter.</small>")
#@gui : note = note("<small>This obviously requires estimation if the settings are unknown.</small>")
fx_gcd_undo_unsharp : skip ${1=3},${2=0.5},${3=1}
  repeat $! l[$>]
    split_opacity gcd_reverse_unsharp[0] ${1-3} a c
  done done

fx_gcd_undo_unsharp_preview :
  gui_split_preview "fx_gcd_undo_unsharp ${1-3}",${-3--1}

#@cli gcd_reverse_unsharp : std_deviation>=0[%],_amount>0,_type
#@cli : Apply a reverse unsharp mask to selected images.
#@cli : Values will be restricted to input image range.
#@cli : 'type' can be { 0=boxfilter | 1=gaussian }.
#@cli : Default values: 'std_deviation=3', 'amount=1' and 'type=1'.
#@cli : $ image.jpg unsharp 2,3 c 0,255 +gcd_reverse_unsharp 2,3 c 0,255
gcd_reverse_unsharp : skip ${1=3},${2=1},${3=1}
  e[^-1] "Apply reverse unsharp on image$?, with std_deviation $1."
  repeat $! l[$>]
    if $3 cmd=b else cmd=boxfilter fi
    m={[im,iM]} +$cmd $1 mul. $2 add div {1+$2} c $m
  done done

#@gui LMS Adjustment : gcd_balance_lms, gcd_balance_lms(1)
#@gui : note = note("<i>Chromatically adapt to a new illuminant</i>"), sep = separator()
#@gui : Long = float(1,0.5,1.5)
#@gui : Medium = float(1,0.5,1.5)
#@gui : Short = float(1,0.5,1.5)
#@gui : sep = separator()
#@gui : Adapt Luminance = bool(0)
#@gui : Pre Normalize = bool(0)
#@gui : Auto Balance = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/09/08</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>sRGB D65 input is assumed.</small>")
#@gui : note = note("<small>LMS sliders: control illuminant ratios.</small>")
#@gui : note = note("<small>Adapt Luminance: adjust luminance as well, may cause clipping.</small>")
#@gui : note = note("<small>Pre Normalize: stretch input RGB ranges to maximum.</small>")
#@gui : note = note("<small>Auto Balance: attempt to set neutral grey lighting.</small>")
gcd_balance_lms : skip ${1=1},${2=1},${3=1},${4=0},${5=0},${6=0}
  repeat $! l[$>] split_opacity l[0]
    if $5 s c n 0,255 a c fi srgb2rgb rgb2xyz 1 # D65
    mix_channels (0.7328,0.4296,-0.1624;-0.7036,1.6975,0.0061;0.0030,0.0136,0.9834)
    if $6 # Compare average with average of equalized geometric mean
      m={[im,iM]} +r 1,1,1,100%,2 +n.. 0.002,0.998 log. gm={ia} +r. 1,1,1,100%,2
      repeat s#2 sh[2] $> *. {$gm/i[#3,$>]} rm. done
      rm. exp. n. $m r. 1,1,1,100%,2 /[-2,-1]
    else (1^1^1) fi
    # Adapt to new illuminant (CAT02 with D = 1)
    ($1^$2^$3) n={L=$4?[0.454369,0.473533,0.072098]:[1,1,1];dot(L,I#1)/dot(L,I#2)}
    repeat s#1 sh[0] $> *. {$n*i[#2,$>]/i[#1,$>]} rm. done k[0]
    mix_channels (1.096124,-0.278869,0.182745;0.454369,0.473533,0.072098;-0.009628,-0.005698,1.015326)
    xyz2rgb 1 rgb2srgb
  done a c done done

#@gui Cumulative Math : fx_gcd_cumul_math, fx_gcd_cumul_math_preview(1)
#@gui : note = note("<i>Cumulative Math glitch filter</i>"), sep = separator()
#@gui : Operation = choice(0,"Add","Or","Xor","And","Mod")
#@gui : Amount = int(1,1,512)
#@gui : Step = int(1,1,256)
#@gui : Horizontal = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/18</i>.</small>")
fx_gcd_cumul_math : skip ${1=0},${2=1},${3=1},${4=0}
  op=${arg\ 1+$1,"add","or","xor","and","mod"}
  ac "gcd_cumul_math $2,$3,"$op",$4",rgb replace_nan 255

gcd_cumul_math : skip ${1=1},${2=1},${3="add"},${4=0}
  repeat $! l[$>]
    100%,100%,100%,1,1 (0,$2) if $4 z. 1,1 fi
    +*. $1 shift[1] {^} rm. m={^} rm. [0]
    repeat $1 +shift. $m +*. [1] $3[0,-1] rm.. done k[0] mod 256
  done done

fx_gcd_cumul_math_preview :
  gui_split_preview "fx_gcd_cumul_math ${1--2}",$-1

#@gui Upscale [Edge] : fx_gcd_upscale_edge, fx_gcd_upscale_edge_preview(0)
#@gui : note = note("<i>Edge sharpening upscale</i>"), sep = separator()
#@gui : Factor = choice(1,"custom","2","3","4","5","6","7","8")
#@gui : Factor = float(1,1,8)_0
#@gui : Type = choice(1,"linear","bicubic")
#@gui : Values = choice(1,"unbounded","cut","normalize")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2021/01/12</i>.</small>")
#@gui : note = note("\n<small>Variance smoothed upscale for high scale factors.</small>")
#@gui : note = note("<small>Image dimensions are multiplied by specified factor.</small>")
fx_gcd_upscale_edge : skip ${1=1},${2=1},${3=1},${4=1}
  mx={[im,iM]}
  gcd_upscale_edge {$1==0?$2:$1+1},$3
  if $4==1 c $mx elif $4==2 n $mx fi
  u "{$1}{$2}_"{2*($1==0)}"{$3}{$4}"

fx_gcd_upscale_edge_preview :
  A,B={P=0.5/($1==0?$2:$1+1);[-P,P]*100+50}
  z $A%,$A%,$B%,$B% fx_gcd_upscale_edge $*

#@cli gcd_upscale_edge : factor>=1,_interpolation={ 0=linear | 1=bicubic }
#@cli : Upscale selected images with an edge-sharpening algorithm.
#@cli : Default values: 'factor=2' and 'interpolation=0'.
#@cli : $ image.jpg gcd_upscale_edge 2
gcd_upscale_edge : skip ${1=2},${2=0}
  e[^-1] "Upscale image$? by a factor of $1."
  t={arg0($2,3,5)}
  repeat $! l[$>]
    nw,nh,ms,bs={[w,h,1.75,1.5]*$1}
    +r $nw,$nh,100%,100%,$t
    gcd_smooth_variance. $ms
    +ri. [0],2 -[0,-1] ri[0] .
    boxfilter.. $bs +
  done done

#@cli gcd_resize_vw : width[%],_height[%],_depth[%]
#@cli : Resize selected images with variance weighted bilinear interpolation.
#@cli : Default values: 'height=100%' and 'depth=100%'.
#@cli : $ image.jpg rs 25% +gcd_resize_vw 400%,400%
gcd_resize_vw : skip ${2=100%},${3=100%}
  e[^-1] "Resize image$? to $1x$2x$3, with variance weighted bilinear interpolation."
  repeat $! l[$>]
    if d==1
      (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
    else # volumetric
      (0.015625,0.03125,0.015625;0.03125,0.0625,0.03125;0.015625,0.03125,0.015625/\
      0.03125,0.0625,0.03125;0.0625,0.125,0.0625;0.03125,0.0625,0.03125/\
      0.015625,0.03125,0.015625;0.03125,0.0625,0.03125;0.015625,0.03125,0.015625)
    fi
    [0]x2 sqr.. convolve[-2,-1] [1] rm[1] sqr. -[-2,-1] max. 0
    compose_channels. + /. 3 +. 1e-6 ^. -1
    *.. . r $1,$2,$3,100%,3 /
  done done

#@cli gcd_resize_vw_aligned : width[%],_height[%],_depth[%]
#@cli : Resize selected images with pixel aligned variance weighted bilinear interpolation.
#@cli : Default values: 'height=100%' and 'depth=100%'.
#@cli : $ image.jpg rs 25% +gcd_resize_vw_aligned 400%,400%
gcd_resize_vw_aligned : skip ${2=100%},${3=100%}
  e[^-1] "Resize image$? to $1x$2x$3, with variance weighted bilinear interpolation."
  repeat $! l[$>]
    if d==1
      (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
    else # volumetric
      (0.015625,0.03125,0.015625;0.03125,0.0625,0.03125;0.015625,0.03125,0.015625/\
      0.03125,0.0625,0.03125;0.0625,0.125,0.0625;0.03125,0.0625,0.03125/\
      0.015625,0.03125,0.015625;0.03125,0.0625,0.03125;0.015625,0.03125,0.015625)
    fi
    [0]x2 sqr.. convolve[-2,-1] [1] rm[1] sqr. -[-2,-1] max. 0
    compose_channels. + /. 3 +. 1e-6 ^. -1
    *.. . gcd_resize_aligned $1,$2,$3 /
  done done

#@cli gcd_resize_aligned : width[%],_height[%],_depth[%]
#@cli : Resize selected images with pixel aligned bilinear interpolation.
#@cli : Default values: 'height=100%' and 'depth=100%'.
#@cli : $ image.jpg +gcd_resize_aligned 400%,400% rs 25%
gcd_resize_aligned : skip ${2=100%},${3=100%}
  e[^-1] "Resize image$? to $1x$2x$3, with bilinear interpolation."
  foreach {
    $1,$2,$3,3,"[w#0*(x+0.5)/w-0.5,h#0*(y+0.5)/h-0.5,d#0*(z+0.5)/d-0.5]"
    warp.. .,0 rm.
  }

#@cli gcd_smooth_variance : size>=0[%],_tolerance>=0
#@cli : Filter selected images by variance smoothing of specified size.
#@cli : Default values: 'size=3' and 'tolerance=1e-6'.
#@cli : $ image.jpg gcd_smooth_variance 5
gcd_smooth_variance : skip ${1=3},${2=1e-6} # area, toler
  e[^-1] "Apply variance smoothing to image$?."
  foreach {
    C,R:=H=iM-im;[H/2+im,H] - $C / $R
    [0]x2 sqr.. boxfilter[1,2] $1
    sqr. sub[-2,-1] r. 100%,100%,100%,1,2 # V = box variance
    max. $2 ^. -1 *[0] . # x/V, 1/V
    boxfilter $1 +eq. 0 +[-2,-1] /
    c -0.5,0.5 * $R + $C
  }

#@gui Upscale [Noise] : gcd_upscale_noise, gcd_upscale_noise_preview(0)
#@gui : note = note("<i>Upscale 2x using randomized estimation of original</i>"), sep = separator()
#@gui : Noise = int(16,0,32)
#@gui : Iters = int(2,1,3), sep = separator()
#@gui : note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/08</i>.</small>")
#@gui : note = note("\n<small>Note: reduce iters and increase noise for poor images.</small>")
gcd_upscale_noise : skip ${1=16},${2=2}
  gcd_scale_noise $1,$2 c 0,255

gcd_upscale_noise_preview :
  z 25%,25%,75%,75% gcd_upscale_noise $*

gcd_scale_noise : skip ${1=16},${2=2}
  repeat $! l[$>]
    200%,200%,100%,100% gcd_random. $1
    repeat $2 +ri. ..,2 -. [0] ri. .. boxfilter. 3 -[1,2] done rm..
  done done

gcd_random : skip ${1=1},"${2=?}"
  f u if isnum("$2") n $1,$2 else n 0,$1 fi

#@gui Smooth [Geometric-Median] : fx_gcd_geometric_median, fx_gcd_geometric_median_preview(0)
#@gui : note = note("<i>Smooth using windowed geometric median of vectors</i>"), sep = separator()
#@gui : Radius = int(3,1,9)
#@gui : Iters = int(12,1,20)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/07/18</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>This prototype filter can be extremely slow to compute!</small>")
#@gui : note = note("<small>Only odd window sizes are currently supported.</small>")
fx_gcd_geometric_median :
  ac "gcd_geometric_median $1,$2",$3

fx_gcd_geometric_median_preview :
  gui_split_preview "fx_gcd_geometric_median $*",${-3--1}

#@gui Quick Tonemap : fx_gcd_quicktone, fx_gcd_quicktone(1)
#@gui : note = note("<i>Simple tone and detail control</i>"), sep = separator()
#@gui : Power = float(1,0.5,2.5)
#@gui : Radius = float(4,0,10)
#@gui : Range = float(20,0,20)
#@gui : Smooth = float(0,0,4)
#@gui : Channels = choice(3,"HSI","HSV","Lab","YCbCr")
#@gui : Values = choice(1,"cut","normalize")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/06/26</i>.</small>")
fx_gcd_quicktone : skip ${1=1},${2=4},${3=20},${4=0},${5=3},${6=1}
  mode=${arg0\ $5,hsi8_i,hsv8_v,lab8_l,ycbcr_y}
  if $4>0 r={[im,iM]} bilateral 1%,$4 c $r fi
  ac "+gcd_tonemap_gamma $2% +bilateral. $2%,{(iM#0-im#0)*$3/100} -[-2,-1] *. $1 +",$mode,{$6+1}

#@cli gcd_tonemap_gamma
#@cli : Map tones by local adjustment of geometric mean.
gcd_tonemap_gamma : skip ${1=100}
  repeat $! l[$>] m={[im,iM]} n 0.002,0.998 log +b $1 *.. {0,is/whds} / exp n $m done done

#@gui Normalize Brightness : gcd_normalize_brightness, gcd_normalize_brightness(1)
#@gui : note = note("<i>Normalize brightness across the image</i>"), sep = separator()
#@gui : Bright = float(0,-2,2)
#@gui : Area = float(10,0,100)
#@gui : Smooth = float(0,0,4)
#@gui : Channels = choice(3,"HSI","HSV","Lab","YCbCr","sRGB")
#@gui : Mask = choice("Normal","Darken","Lighten")
#@gui : Absolute Brightness = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/05/27</i>.</small>")
#@gui : note = note("<small>\n<u>Tips:</u>\n\nDefault settings for de-haze.</small>")
#@gui : note = note("<small>Large area and Lab for very bright images.</small>")
#@gui : note = note("<small>Small area and HSV for very dark images.</small>")
#@gui : note = note("<small>Medium area and HSV for high contrast images.</small>")
#@gui : note = note("<small>Smooth to reduce artifacts, however some detail may be lost.</small>")
gcd_normalize_brightness : skip ${1=0},${2=10},${3=0},${4=3},${5=0},${6=0}
  mode=${arg0\ $4,hsi8_i,hsv8_v,lab8_l,ycbcr_y,rgb}
  if $3>0 bilateral 1%,$3 c 0,255 fi
  if $5==0 ac "gcd_tonemap_area $2,$1,$6",$mode,2
  else +ac "gcd_tonemap_area $2,$1,$6",$mode,2 blend ${arg\ $5,darken,lighten} fi

gcd_tonemap_area : skip ${1=100},${2=0},${3=0}
  repeat $! l[$>]
    + 0.5 m={iM+1} / $m # Set domain
    if $3 a={$2/4.001+0.5} else +^. $2 a={is} rm. +^. {$2-1} a={$a/is} rm. fi # Lehmer mean
    H={1/$a-1} +oneminus /. .. b. $1% ^. -1 *. $H # Rational factor map
    +oneminus. *. [0] +[-2,-1] / * $m - 0.5 # Rational mapping
  done done

#@gui Auto Balance: gcd_auto_balance, gcd_auto_balance(1)
#@gui : note = note("<i>Map based tone and color balance</i>"), sep = separator()
#@gui : Area = float(30,0,200)
#@gui : Smooth = float(0,0,2)
#@gui : Channels = choice(0,"HSI","HSV","Lab","Linear RGB","RGB","YCbCr")
#@gui : Balance sRGB = bool(1)
#@gui : Reduce RAM = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2018/08/08</i>.</small>")
gcd_auto_balance : skip ${1=30},${2=0},${3=0},${4=1},${5=0}
  mode=${arg0\ $3,hsi8_i,hsv8_v,lab8_l,lrgb,rgb,ycbcr_y}
  if $2>0 bilateral 1%,$2 c 0,255 fi
  if $4!=0 ac "gcd_rgb_balance",rgb fi
  if $5 ac "gcd_tonemap_inplace $1",$mode,2
  else ac "gcd_tonemap $1",$mode,2 fi

gcd_tonemap : skip ${1=100},${2=255}
  repeat $! l[$>]
    / $2 +boxfilter $1%
    +-. 0.5 sign. *. -1
    +*.. -2 +. 1
    +neq. 0 mul[0,1] .
    eq. 0 +[-2,-1]
    /[0,1] . rm.
    +sqr.. +[0,-1] max[0] 0
    sqrt[0] *[0,-1] - * $2
  done done

gcd_tonemap_inplace : skip ${1=100},${2=255}
  repeat $! l[$>]
    / $2 +boxfilter $1%
    f[0] "*A=i(#-1,x,y,z,c);B=1-2*A;Bx=A/B;-sign(A-0.5)*sqrt(i/B+Bx^2)-Bx;"
    rm. * $2
  done done

gcd_rgb_balance :
  repeat $! l[$>]
    m={iM} s c n 0,$m a c [0] +r. 1,1,1,100%,2
    repeat s#1 sh[1] $> -. {2,i[$>]+$m/2} rm. done
    rm. n. 0,$m +/[0] $m +^. 3 compose_channels. + /. -3 +. 1
    compose_channels.. max *[-2,-1] j[0] ..,0,0,0,0,1,. k[0]
  done done

#@gui Inverse Bezier Warp: gcd_ebwarp, gcd_ebwarp(1)
#@gui : note = note("<i>Horizontal inverse conformal bezier warp</i>"), sep = separator()
#@gui : Mid = float(0.5,0,1)
#@gui : End = float(1,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/02/06</i>.</small>")
#@gui : note = link("http://benpaulthurstonblog.blogspot.co.uk/2015/12/ebezier.html")
gcd_ebwarp : skip ${1=0.5},${2=1}
  repeat $! l[$>]
    b={w*$1*$2} c={w*$2} d={2*$c-4*$b}
    e={(4*$b-$c)/(2*$d)} se={sqr($e)}
    {w},{h},1,1,x
    if $1==0.5 *. {1/$c} else
      /. $d +. $se
      if $1>1 abs. fi
      sqrt.
      if $1>0.5 *. -1 fi
      -. $e
    fi
    *. {w} {w},{h},1,1,y a[^0] c
    warp[0] .,0,2,0 rm. c 0,255
  done done

#@gui Multi Thresholds : tran_multi_threshold, tran_multi_threshold(1)
#@gui : note = note("<i>Apply color to selectable tones</i>"), sep = separator()
#@gui : Threshold_1 = int(50,0,255)
#@gui : Threshold_2 = int(100,0,255)
#@gui : Threshold_3 = int(150,0,255)
#@gui : Threshold_4 = int(200,0,255)
#@gui : 1st Color = color(9,0,1)
#@gui : 2nd Color = color(175,42,27)
#@gui : 3rd Color = color(101,101,101)
#@gui : 4th Color = color(174,165,131)
#@gui : 5th Color = color(247,228,160)
#@gui : sep = separator(), note = note("<small>Author : <i>trandoductin</i>.      Latest update : <i>2016/08/25</i>.</small>")
tran_multi_threshold : skip ${1=50},${2=100},${3=150},${4=200}
  repeat $! l[$>]
    split_opacity +rgb2ycbcr[0] channels. 0 fc[0] ${5-7}
    +fc[0] ${8-10} +ge.. $1 j[0] ..,0,0,0,0,1,. rm[-2,-1]
    +fc[0] ${11-13} +ge.. $2 j[0] ..,0,0,0,0,1,. rm[-2,-1]
    +fc[0] ${14-16} +ge.. $3 j[0] ..,0,0,0,0,1,. rm[-2,-1]
    +fc[0] ${17-19} +ge.. $4 j[0] ..,0,0,0,0,1,. rm[-2,-1]
    rm. a c
  done done

#@gui PQCT Example: gcd_pqct, gcd_pqct(1)
#@gui : note = note("<i>Parameterized Quadratic Conformal transformation</i>")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/02/07</i>.</small>")
#@gui : note = note("\nBased on example code from:")
#@gui : note = link("http://benpaulthurstonblog.blogspot.co.uk/2015/12/parameterized-quadratic-conformal.html")
gcd_pqct :
  repeat $! l[$>]
    ({w*.1},{h*.2};{w*.2},{h*.6};{w*.2},{h*.9};{w*.5},{h*.1};\
     {w*.6},{h*.8};{w*.9},0;{w*.85},{h*.4};{w},{h*.75})
    transpose. 9,2,1,1
    repeat 2 # coefficients
      sh[2] $>,$>,0,0 sh[1] $>,$>,0,0
      k={"k=(i[1]+i[3]+i[4]+i[6])/4; i(#-2,0)=k;
      i(#-2,1)=(i[6]-i[1])/2; i(#-2,2)=(i[3]-i[4])/2;
      i(#-2,3)=(i[6]+i[1])/2-k; i(#-2,4)=(i[3]+i[4])/2-k;
      i(#-2,5)=(i[2]+i[5]-i[0]-i[7])/4;
      i(#-2,6)=(i[0]+i[5]-i[2]-i[7])/4+(i[4]-i[3])/2;
      i(#-2,7)=(i[5]+i[7]-i[0]-i[2])/4+(i[1]-i[6])/2;
      i(#-2,8)=(i[0]+i[2]+i[5]+i[7])/4-k;0"}
      rm[-2,-1]
    done
    +f[0] 0 r. 100%,100%,1,2,-1 sh[0] 0
    f. "begin(cx0=i(#2,0);cx1=i(#2,1);cx2=i(#2,2);cx3=i(#2,3);
         cx4=i(#2,4);cx5=i(#2,5);cx6=i(#2,6);cx7=i(#2,7);cx8=i(#2,8);
         cy0=i(#2,0,1);cy1=i(#2,1,1);cy2=i(#2,2,1);cy3=i(#2,3,1);
         cy4=i(#2,4,1);cy5=i(#2,5,1);cy6=i(#2,6,1);cy7=i(#2,7,1);cy8=i(#2,8,1));
    s=(2*x/w-1); t=-(2*y/h-1); s2=s*s; t2=t*t;
    i(#3,x,y,0,0)=cx8*s2*t2+cx7*s*t2+cx6*s2*t+cx5*s*t+cx4*t2+cx3*s2+cx2*t+cx1*s+cx0;
    i(#3,x,y,0,1)=cy8*s2*t2+cy7*s*t2+cy6*s2*t+cy5*s*t+cy4*t2+cy3*s2+cy2*t+cy1*s+cy0; i"
    rm[-4,-3,-1] round. [0],[0],[0],[0] sh[0] 0 px=""
    repeat {0,s} px=$px;i(#2,a,b,0,$>)=i$>#0 done
    f. 'a=i#1;b=i1#1$px' rm. j[0] . k[0]
  done done

#@gui Blend [Feather]: gcd_blend_feather, gcd_blend_feather(1)
#@gui : note = note("<u>Overlay layers seamlessly by feathering edges</u>")
#@gui : note = note("<small>1. Set Input layers to <b>Active & below</b> for two layers</small>")
#@gui : note = note("<small>2. For best results ensure layers are the same size</small>")
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Max Delta = int(100,0,200)
#@gui : Color Transfer = float(0.5,0,1)
#@gui : Hue Extent = float(2,0,6)
#@gui : Remove BG = int(0,0,20)
#@gui : Keep Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/05/05</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Remove BG can help mask off unwanted areas, which works</small>")
#@gui : note = note("<small>best on objects surrounded by simple backgrounds.</small>")
#@gui : note = note("<small>Overlaying a larger area can sometimes improve the output.</small>")
gcd_blend_feather : skip ${1=100},${2=0.5},${3=2},${4=0},${5=0}
  r[^-1] .,.,1,100%,0,0,0.5,0.5
  if $5
    +gcd_blend_maxdelta ${1-4}
    to_a[0] split_opacity[0] rv[1,-1] a[1,-1] c rm[0]
  else gcd_blend_maxdelta ${1-4} fi

gcd_blend_maxdelta : skip ${1=100},${2=0.5},${3=2},${4=0}
  if $!>1 repeat $!-1 l[0,1]
    to_a split_opacity /[1,3] 255
    =>[0] upper =>[1] alpha =>[2] lower =>[3] mask

    # transfer colours
    +r[lower] 1,1,1,100%,2
      ++[upper] 0.1 *. [alpha]
      s. c discard[-3--1] 0 a[-3--1] c
      r. 1,1,1,100%,2 r[-2,-1] [upper]
    *[-2,-1] $2 -[upper,-1] +[upper,-1] c[upper] 0,255

    # get distance, full blending for lower layer transparency
    +distance[alpha] 0 => dist
    eq[mask] 0 *[mask] {dist,iM} max[dist] [mask]

    # get foreground mask
    if $4>0
      [upper] [alpha] a[-2,-1] c
      gcd_fgmask. {20-$4} b. 3 *[alpha,-1]
    fi

    # hue extent
    +n[dist] 0,$3 c. 0,1 *. [alpha]
    gcd_srgb2jpeg[upper,lower] sh[upper,lower] 1,2
    j. ..,0,0,0,0,1,... rm[-3--1]
    gcd_jpeg2srgb[upper,lower]

    # blend using distance as maximum difference
    n[dist] 0,{255*$1%}
    +-[upper] [lower] *. [alpha]
    +sign. abs.. min[dist,-2] *[dist,-1]
    +[lower] [dist] k[lower] c 0,255
  done done fi

gcd_fgmask : skip ${1=0}
  # Fast foreground select based on central positioning
  # within an alpha selected region, pre-processing with
  # median can improve selections. output range 0 -> 1
  repeat $! l[$>]
    to_a expand xy,20 split_opacity gt. 0
    +distance. 0 max_patch. 3 *. 2
    +erode[1] 20 *[-2,-1] dilate. $1
    +gradient_norm.. gt. 0
    gradient_norm[0] +eq. 0 *[0,-1]
    max[-2,-1] *[0,1] *[0] -1
    watershed. .. rm..
    shrink xy,20 - 1
  done done

#@gui Blend [Multiscale] : fx_gcd_blend_multiscale, fx_gcd_blend_multiscale(0)
#@gui : note = note("<i>Alpha blend with multiscale laplacian filter</i>"), sep = separator()
#@gui : note = note("<small>* Set Input layers to <b>Active & below</b> for two layers</small>")
#@gui : Scales = int(5,1,10)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/05/29</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Top layer must have an opacity channel</small>")
#@gui : note = note("<small>Blending occurs at the edges of an opaque region</small>")
#@gui : note = note("<small>Higher scales increase blend distance and cpu cost</small>")
fx_gcd_blend_multiscale : skip ${1=5}
if 2!=$! error "This filter requires two input layers to function" fi
  l[-2,-1] { name={0,n}
    to_a[0] remove_opacity[1]
    split_opacity[0] n[1] 0,1 mv[1] 0
    +oneminus[0] gcd_inpaint_pyramid[1] . rm.
    K=3 A=1 B=2
    repeat $1 {
      K:=2^($>+2)+1
      boxfilter[0] $K n[0] 0,1
      +boxfilter[$A,$B] $K
      sub[$A] .. sub[$B] .
      mul[$A] [0] negate[0] mul[$B] [0] negate[0]
      if ($>)>0 add[1,3] add[2,3] else A+=2 B+=2 fi
    }
    mul[$A] [0] negate[0] mul[$B] [0]
    add[1,3] add[2,3] add[1,2] k. nm $name
  }

#@gui Depth Blur : gcd_depth_blur, gcd_depth_blur(1)
#@gui : note = note("<u>Selectively blur based on estimated depth</u>")
#@gui : note = note("<small>Amount of blur applied is relative to luminance of the depth map</small>")
#@gui : note = note("\n<i>Focus Options</i>"), sep = separator()
#@gui : Distance Threshold = int(0,0,100)
#@gui : Blur Amount = int(15,0,100)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Create/View Depth Map = bool(0)
#@gui : Reverse Map = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/24</i>.</small>")
gcd_depth_blur : skip ${1=0},${2=15},${3=0.25},${4=2},${5=4},${6=0},${7=1}
  repeat $! l[$>]
  sa={$2*max(w,h)/1000}
  to_rgb[0]
  +gcd_depth[0] $3,$4,$5
  if $7 negate. fi
  threshold. $1%,1 n. 0,255
  if $6 k. else
    {w},{h},1,1,0 .. a[-3--1] c
    smooth.. .,$sa,30,0 rm.
    c. 0,255
  fi
  done done

#@gui Emboss: gcd_emboss, gcd_emboss_preview(1)
#@gui : note = note("<i>Make an image look embossed</i>"), sep = separator()
#@gui : Midpoint = int(128,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/11/11</i>.</small>")
gcd_emboss : skip ${1=128}
  repeat $! l[$>]
    +norm +bilateral[0] 2%,30 norm. -[-2,-1]
    +n[0] 0,255 median. 3 bilateral. 2%,30
    gcd_srgb2luma. -. $1
    +abs. negate.
    +max.. 0 min... 0 abs...
    pde_flow[1] 20,7,iee
    +n... 0,2 *. [1] +[0,-1]
    +n. 0,2 *. [1] +[0,-1]
    +n.. 0,2 *. [1] +[0,-1]
    +[0,2] -[0,3] k[0]
    gcd_srgb2luminance c 0,255
  done done

gcd_emboss_preview :
  gui_split_preview "gcd_emboss ${1--2}",$-1

#@gui Image InfoMap: gcd_infomap, gcd_infomap(1)
#@gui : note = note("<i>View images in various informational ways</i>"), sep = separator()
#@gui : Output = choice("Spectral tones","Detail map","JPEG CbCr detail","Local equality","Standard score")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/09/26</i>.</small>")
gcd_infomap :
  repeat $! l[$>] to_rgb
    if $1>3 gcd_std_score_patch 3 n 0,255
    elif $1>2
      +dilate 3 +erode.. 3 eq[-2,-1] compose_channels. min
      orientation.. * n 0,255
    elif $1>1 gcd_srgb2jpeg channels 1,2 equalize 256 gcd_detail
    elif $1 gcd_detail else gcd_spectral fi
  done done

gcd_detail :
  repeat $! l[$>] +bilateral 2%,30 norm - n 0,255 done done

gcd_spectral :
  repeat $! l[$>]
    to_rgb gcd_srgb2luma - 128
    +max 0 +min[0] 0 abs[^-2] negate[0] a c n 0,255
  done done

gcd_std_score_patch : skip ${1=3}
  repeat $! l[$>]
    +gcd_variance_patch $1 sqrt.
    +boxfilter.. $1 -[0,-1] +eq. 0 +[-2,-1] /
  done done

gcd_variance_patch : skip ${1=3}
  repeat $! l[$>] +sqr boxfilter $1 sqr.. rv - max 0 done done

#@gui Layer Manipulation: gcd_layers, gcd_layers_preview(1)
#@gui : note = note("\n<i>Transform</i>"), sep = separator()
#@gui : Scale = float(100,1,200)
#@gui : Angle = int(0,-90,90)
#@gui : Reduce Only (Requires Two Layers) = bool(1)
#@gui : note = note("\n<i>Position</i>"), sep = separator()
#@gui : CentreX = float(0,-50,50)
#@gui : CentreY = float(0,-50,50)
#@gui : note = note("\n<i>Edges</i>"), sep = separator()
#@gui : Erode = float(0,0,50)
#@gui : Smooth = int(0,0,25)
#@gui : Curvature (Instead of Gaussian) = bool(0)
#@gui : note = note("\n<i>Layer</i>"), sep = separator()
#@gui : Opacity = float(1,0,1)
#@gui : Mode = choice{"Normal","Add","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Grain Extract","Grain Merge","Hard Light","Hue","Lighten",
#@gui : "Multiply","Overlay","Saturation","Soft Light","Screen","Subtract","Value"}
#@gui : Flip = choice("None","Horizontal","Vertical","Both")
#@gui : Match Lower Layer Size = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2017/06/05</i>.</small>")
#@gui : note = note("\n<small><b>Note:</b> preview is low quality for speed</small>")
gcd_layers : skip ${1=100},${2=0},${3=1},${4=50},${5=50},${6=0},${7=0},${8=0},${9=1},${10=1},${11=0},${12=0},${13=0}
  one={$!<2}
  l[${arg\ 1+$one,0-1,0}]
    if $3" && "!$one" && "$1>100 rs. {w/$1%},,{if($-1,2,6)} c. 0,255 fi # ** SCALE
    w={w} h={h} gcd_force_a[0]
    l[0]
      if $11 mirror ${arg\ $11,x,y,xy} fi # FLIP
      if !$3" || "$one" || "$1<100 rs {w*$1%},,{if($-1,2,6)} c 0,255 fi # ** SCALE
      if $2 split_opacity rotate. $2,{2-($-1)} rotate.. $2,{2-($-1)},1 a c c 0,255 fi # ** ROTATE
      if $6" || "$7 # ** ERODE/SMOOTH
        sh 100% +gt. 1 expand. xy,1 distance. 0 gt. {1+$6}% shrink. xy,1
        *. .. if $8" && "$7 pde_flow. $7,30,iee,0 max. 0 fi min[-2,-1] rm.
      fi
      if !$8" && "$7 sh 100% b. {$7/10}%,1,{!$-1} rm. fi
    done
    pos={round(($w-w#0)/2+$w*$4%)},{round(($h-h#0)/2-$h*$5%)} # ** POSITION
    if $-1" || "$12 i[0] $w,$h,1,{0,s} j[0] [1],$pos rm[1] pos=,pos(0,0)
    else pos=,pos($pos) fi
    mode=${arg\ 1+$10,alpha,add,burn,darken,difference,\
    divide,dodge,grainextract,grainmerge,hardlight,hue,lighten,\
    multiply,overlay,saturation,softlight,screen,subtract,value}
    if $-1 if $!>1 rv blend $mode,$9 else sh 100% *. $9 rm. fi
    else =>[0] mode($mode),opacity({$9*100})$pos fi # ** OPACITY
  done

gcd_layers_preview :
  gcd_layers $*,1

#@gui Recolor : gcd_recol, gcd_recol(1)
#@gui : note = note("<i>Apply colors to a black and white image</i>"), sep = separator()
#@gui : Min Hue Drift = int(-14,-45,0)
#@gui : Max Hue Drift = int(14,0,45)
#@gui : sep = separator(), note = note("<b>Note :</b> This filter needs two layers to work properly.")
#@gui : note = note("<small>Original Author : <i>David Tschumperl&#233;</i></small>")
#@gui : note = note("<small>Adapted by : <i>Garagecoder</i>.   Latest update: <i>2013/01/16</i>.</small>")
gcd_recol :
  repeat int($!/2) l[$>,{$>+1}]
    rv[-2,-1]
    channels.. 0 to_rgb.. # -2=b&w -1=cols\RGBA
    to_rgba. split_opacity. neq. 0  # -3=b&w\RGB -2=cols\RGB -1=mask\L
    srgb2rgb[-3,-2] rgb2lab8[-3,-2] channels... 0 channels.. 1,2 # -3=b&w\L -2=cols\AB -1=mask\L
    +.. 1 *.. .
    +meancurvature_flow... 3 median. 3
    gradient_norm. *. -1 watershed... . rm. -.. 1
    # cols=(cols+1)*mask, wshed with b&w-gnorm*-1 -3=b&w\L -2=wshedcols\AB -1=mask\L
    rm. a[-2,-1] c lab82rgb. rgb2srgb.
    rgb2hsv. s c +equalize[2] 512 n. $1,$2 +[0,-1] %[0] 360 a c hsv2rgb. #stretch hues
  done done

#@gui Sharpen [Gradient]: gcd_sharpen_gradient, gcd_sharpen_gradient_preview(1)
#@gui : note = note("<i>Sharpen areas with low detail</i>"), sep = separator()
#@gui : Amount = float(0.5,0,2)
#@gui : Scale = float(2,0.1,2)
#@gui : Values = choice("cut","normalize luma")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/09/28</i>.</small>")
gcd_sharpen_gradient : skip ${1=0.5},${2=2},${3=0}
  repeat $! l[$>]
    split_opacity
    +norm[0] +bilateral[0] $2%,30 norm. -[-2,-1]
    +gradient_norm[0] negate. n. 0,$1 *[-2,-1] +[0,-1]
    if $3 ac[0] "n 0,255",ycbcr_y else c[0] 0,255 fi
    a c
  done done

gcd_sharpen_gradient_preview :
  gui_split_preview "gcd_sharpen_gradient ${1--2}",$-1

#@gui Sharpen [Tones]: gcd_sharpen_tones, gcd_sharpen_tones_preview(1)
#@gui : note = note("<i>Sharpen shadows and highlights</i>"), sep = separator()
#@gui : Amount = float(1,0,4)
#@gui : Centre = int(128,0,255)
#@gui : Values = choice("cut","normalize luma")
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/09/28</i>.</small>")
gcd_sharpen_tones : skip ${1=1},${2=128},${3=0}
  repeat $! l[$>]
    split_opacity
    +norm[0] +bilateral[0] 2%,30 norm. -[-2,-1]
    +gradient_norm[0] n. 0,1 oneminus. *[-2,-1]
    +n[0] 0,255 median. 3 bilateral. 2%,30
    gcd_srgb2luma. -. $2
    +max. 0 min.. 0 abs..
    n[-2,-1] 0,$1 *[-2,-1] ... rm... +[0,-2,-1]
    if $3 ac[0] "n 0,255",ycbcr_y else c[0] 0,255 fi
    a c
  done done

gcd_sharpen_tones_preview :
  gui_split_preview "gcd_sharpen_tones ${1--2}",$-1

#@gui Smart Rotate : gcd_srotate, gcd_srotate(1)
#@gui : note = note("<u>Rotate an image and extrapolate the corners</u>")
#@gui : note = note("\n<i>Rotation Options</i>"), sep = separator()
#@gui : Angle = int(0,-90,90)
#@gui : Centrex = int(50,0,100)
#@gui : Centrey = int(50,0,100)
#@gui : note = note("\n<i>Quality Options</i>"), sep = separator()
#@gui : Interpolation = choice(1,"Linear","Bicubic")
#@gui : Inpainting = choice(1,"Low","Normal","High","Ultra")
#@gui : Lookup Scale = int(6,1,16)
#@gui : Lookup Factor = float(0.6,0.2,2)
#@gui : Seamless = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/12/05</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>* Dimensions are not altered</small>")
#@gui : note = note("<small>* Quality settings affect speed!</small>")
#@gui : note = note("<small>The preview is a rough guide only.  Images with simple edges tend to work best.</small>")
#@gui : note = note("<small>Results can be improved by selecting a higher inpainting quality, but processing will take longer.</small>")
#@gui : note = note("<small>Select seamless to reduce visible seams at the corners.</small>")
gcd_srotate : skip ${1=0},${2=50},${3=50},${4=1},${5=1},${6=6},${7=0.6},${8=0}
  repeat $! l[$>]
    rotate $1,{$4+1},1,$2%,$3% c 0,255 split_opacity
    l[0]
      {w},{h},1,1,1 rotate. $1,0,0,$2%,$3%
      eq. 0 +area. 0 *. ..
      ps={max(round(iM^0.5/6),4)} rm.
      if $8
        +inpaint[0] .,$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08
        rv[-2,-1] a[-2,-1] c blend_seamless 0,0,25%
      else
        inpaint[0] .,$ps,{$ps*$6},$7,{9-$5*2},{$ps*1.2},0,0.08 rm.
      fi
    done a c
  done done

#@gui Split Objects : gcd_splitobj, gcd_splitobj_preview(1)
#@gui : note = note("<u>Extract objects from an image to a new layer</u>")
#@gui : note = note("<small>1. Create a new transparent layer, mark background red and objects green</small>")
#@gui : note = note("<small>2. Set Input layers to <b>Active & below</b>, objects will be split to two layers</small>")
#@gui : note = note("\n<i>Edge Detection Options</i>"), sep = separator()
#@gui : Alpha Min = int(50,0,100)
#@gui : Edge Flow = int(3,0,20)
#@gui : Median = int(3,0,7)
#@gui : note = note("\n<i>Output Options</i>"), sep = separator()
#@gui : Swap Layers = bool(0)
#@gui : Grow Alpha = int(0,-20,20)
#@gui : Blur Alpha = int(0,0,20)
#@gui : Opacity = int(40,0,100)
#@gui : Inpainting = choice(0,"Off","Low","Normal","High","Ultra")
#@gui : Is Preview = value(0)
#@gui : sep = separator(), note = note("<b>Note :</b> This filter needs two layers to work properly.")
#@gui : note = note("<small>Author : <i>Garagecoder</i>.   Latest update: <i>2016/01/22</i>.</small>")
gcd_splitobj : skip ${1=50},${2=3},${3=3},${4=0},${5=0},${6=0},${7=40},${8=0},${9=0}
  if $!<2 return fi
  repeat int($!/2) l[$>,{$>+1}]
    if w!={0,w}" || "h!={0,h} continue fi
    to_rgba . s[1] c,-3 ge[2] $1% luminance[1]
    meancurvature_flow[1] $2 median[1] $3 *[1,2]
    channels[0] 0,1 s[0] c gt[0,1] 50% *[{$4!=0}] 2 +[0,1]
    gradient_norm[1] *[1] -1 watershed[0] [1] -[0] 1 rm[1]
    if $5>0 erode[0] $5 elif $5<0 dilate[0] {abs($5)} fi
    if $6 b[0] $6,1,1 c[0] 0,1 fi
    [1] sh. 3,3 *. [0] rm. oneminus[0]
    if $8>0
      le[0] 80% +area[0] 0 *. [0]
      ps={max(round(iM^0.5/6),4)} rm. n[0] 0,255
      inpaint[1] [0],$ps,{$ps*6},1,{9-$8*2},{$ps*1.2},0,0.08,10,1
    else sh[1] 3,3 *. [0] rm. fi
    rm[0] gcd_fix_alpha =>[1] opacity($7)
    if $9 blend alpha,{$7/100} fi
  done done

gcd_splitobj_preview :
  gcd_splitobj ${1--2},1

#@gui Stereo Video : gcd_stereo_vid, gcd_stereo_vid_preview(1)
#@gui : note = note("<u>Convert a series of image files to 3D</u>")
#@gui : note = note("\n<i>File Options</i>"), sep = separator()
#@gui : Start Image = file()
#@gui : End Image = file()
#@gui : Output Folder = _folder()
#@gui : note = note("\n<i>3D Options</i>"), sep = separator()
#@gui : 3D Image Type = choice("Anaglyph: Red/Cyan","Side by Side","Depth Map","Inverse Depth Map")
#@gui : Balance Color = float(0.5,0,1)
#@gui : Depth = float(1.2,0,2)
#@gui : note = note("\n<i>Depth Map Options</i>"), sep = separator()
#@gui : Blur Percentage = float(0.25,0,2)
#@gui : Object Ratio = float(2,0,4)
#@gui : Object Tolerance = int(4,0,5)
#@gui : Despeckle = bool(1)
#@gui : note = note("\n<i>Video Options</i>"), sep = separator()
#@gui : Frame Buffer = _int(5,1,10)
#@gui : Scene Detection = bool(1)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/07/02</i>.</small>")
gcd_stereo_vid :
  1 l.

  i "$1" st_folder={f} st_file={b} st_ext={x} ({'$st_file'}) cpx={w}
  do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} while ($isnum)&&($cpx>0)
  if $cpx>0 +z. 0,$cpx fsname={t} rm. else fsname="" fi
  z. {$cpx+{!$isnum}},100% dgts={w} fsnum={{t}} rm.

  1 => "$2" en_file={b} ({'$en_file'}) cpx={w}
  do cpx={$cpx-1} dgt={i($cpx)} isnum={($dgt>47)&&($dgt<58)} while ($isnum)&&($cpx>0)
  z. {$cpx+{!$isnum}},100% fenum={{t}} rm[-2,-1]

  bufsz=$11 ttlbuf={$bufsz*2} ttlimg={$fenum-$fsnum+1}
  scene=1 scframe=0 ov={iv} oa={ia}

  repeat $ttlimg
    if $scene" && "$>==$scframe
      k. scene=0
      repeat min($ttlbuf,$ttlimg-$scframe-1)
        curnum={$fsnum+$scframe+$>+1} curnum=${gcd_add0\ $curnum,$dgts}
        i ""${st_folder}${fsname}${curnum}.${st_ext}""
        vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
        ov=$vr oa=$av
        if $12&&($pvr>0.1" || "$pav>0.1) scene=1 scframe={$scframe+$>+1} break
        fi
      done
      #sum of depths in [0], depths in [1], images in [2]
      +l[0--{1+$scene}] ap "gcd_depth $7,$8,$9,$10" ++[0--1] a[0--2] z done
      mv. 0 mv. 1 a[2--{1+$scene}] z
    fi

    +slices[2] 0 +/[0] {1,d} gcd_stereo[-2,-1] $4,$5,$6%

    curnum={$fsnum+$>} curnum=${gcd_add0\ $curnum,$dgts}
    if ${-is_windows} o. "$3"""{`92`}${fsname}${curnum}.${st_ext}""
    else o. "$3"""{`47`}${fsname}${curnum}.${st_ext}"" fi
    progress {($>+1)/$ttlimg*100}

    rm. slices[2] 1,100%

    if !$scene" && "($>>=($scframe+$bufsz))" && "($><($ttlimg-$bufsz-1))
      curnum={$fsnum+$>+$bufsz+1} curnum=${gcd_add0\ $curnum,$dgts}
      i ""${st_folder}${fsname}${curnum}.${st_ext}""
      vr={iv} av={ia} pvr={abs($vr-$ov)/$vr} pav={abs($av-$oa)/$av}
      ov=$vr oa=$av
      if $12&&($pvr>0.1" || "$pav>0.1) scene=1 scframe={$>+$bufsz+1}
      else
        +gcd_depth. $7,$8,$9,$10 +[0] . a[1,-1] z a[2,-1] z
        +slices[1] 0 -[0,-1] slices[1] 1,100%
      fi
    fi
  done
  rm
  done

gcd_stereo_vid_preview : skip "${1=}","${2=}"
  l i "$1" onfail 100,100,1,3,0 t. "Select\nStart\nImage   ",0,0,32,1,255 done
  l i "$2" onfail 100,100,1,3,0 t. "Select\nEnd\nImage   ",0,0,32,1,255 done
  k[-2,-1] a[0,1] x to_rgb[0] +gcd_depth. $7,$8,$9,$10 gcd_stereo $4,$5,$6%

gcd_add0 :
  ({'"$1"'}) if w<$2 {$2-w},1,1,1,48 rv[-2,-1] a[-2,-1] x fi u {t} rm.

#@gui Target Color Spot : fx_gcd_color_target, fx_gcd_color_target(1)
#@gui : note = note("<i>Use color curves to make the selected point match the target</i>"), sep = separator()
#@gui : Coordinates = point(50,50,0,1,40,250,60,128,2%)_0
#@gui : Target Color = color(175,175,175)
#@gui : Chromacity Range = choice("Global","Wide","Narrow")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/06/15</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Set the target to the desired color for the spot you selected.</small>")
#@gui : note = note("<small>Reduce chromacity range to limit the affected regions.</small>")
#@gui : note = note("<small>sRGB D65 input is assumed.</small>")
fx_gcd_color_target :
  foreach {
    split_opacity
    src:=I(#0,$1/100*w#0,$2/100*h#0)
    +gcd_srgb_curve_target[0] $3,$4,$5,$src
    if $6
      +_gcd_chromacity_distance[0] $src *. -1 +. 1
      if $6>1 pow. 3 fi
      j[0] ..,0,0,0,0,1,. rm[-2,-1]
    else j[0] . rm. fi
    a c
  }

_gcd_chromacity_distance :
  if ${"is_image_arg $1"} pass$1 1 else i 1,1,1,3,${^0} fi
  +mix_channels. (0,0.5,0.5;0.5,0,0.5;0.5,0.5,0) -[-2,-1] store. cmp
  foreach {
    +mix_channels (0,0.5,0.5;0.5,0,0.5;0.5,0.5,0)
    - i $cmp repeat {0,s} { sh[0] $> -. {-2,i[$>]} rm. } rm.
    sqr r 100%,100%,100%,1,2 sqrt n 0,1
  }

#@cli gcd_srgb_curve_target : colRt,colGt,colBt,colRs,colGs,colBs
#@cli : Make source sRGB values match target using color curves.
#@cli : Default values: 'colN=128'.
#@cli : $ image.jpg gcd_srgb_curve_target 100,130,160
gcd_srgb_curve_target : skip ${1=128},${2=128},${3=128},${4=128},${5=128},${6=128}
  e[^-1] "Apply curves changing ($4,$5,$6) to ($1,$2,$3) for image$?."
  foreach {
    m={iM} repeat {0,s} { sh $> n. 0,$m rm. }
    ($4^$5^$6) ($1^$2^$3)
    mix_channels (0,0.5,0.5;0.5,0,0.5;0.5,0.5,0)
    srgb2rgb / $m  +*[1,2] -[1,2] . rm. /[1,2]
    repeat {0,s} { A:=i[$>] sh[0] $> +*. {1-$A} +. $A /[-2,-1] rm. }
    k[0] * $m rgb2srgb
    mix_channels (-1,1,1;1,-1,1;1,1,-1) c 0,$m
  }

#@gui Transfer Colors [Curves] : fx_gcd_color_spot_matching, fx_gcd_color_spot_matching_preview(1)
#@gui : note = note("<i>Use color curves to match the target to the source</i>"), sep = separator()
#@gui : Source = point(75,75,0,1,0,150,250,128,2%)
#@gui : Target = point(25,25,0,1,250,250,0,128,2%)
#@gui : Chromacity Range = choice(1,"Global","Wide","Narrow")
#@gui : Preview = choice(0,"Vertical","Horizontal","Layers")
#@gui : Swap layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2022/06/15</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Ensure the layer dimensions match for best results.</small>")
#@gui : note = note("<small>Reduce chromacity range to limit the affected regions.</small>")
#@gui : note = note("<small>sRGB D65 input is assumed.</small>")
fx_gcd_color_spot_matching : skip ${1=50},${2=50},${3=50},${4=60},${5=1},${6=0},${7=0}
if 2!=$! error "This filter requires two input layers to function" fi
if $7 rv fi
  l[0,1] {
    if $6>1
      x0:=$3/100*w#0 y0:=$4/100*h#0
      x1:=$1/100*w#1 y1:=$2/100*h#1
    elif $6>0
      p:=(w#0+w#1) q:=max(h#0,h#1)
      x0:=min($3/100*$p,w#0) y0:=min($4/100*$q,h#0)
      x1:=max($1/100*$p-w#0,0) y1:=min($2/100*$q,h#1)
    else
      p:=max(w#0,w#1) q:=(h#0+h#1)
      x0:=min($3/100*$p,w#0) y0:=min($4/100*$q,h#0)
      x1:=min($1/100*$p,w#1) y1:=max($2/100*$q-h#0,0)
    fi
    to_a =>[0] T =>[1] S split_opacity
    l[T,S] {
      trg:=I(#0,$x0,$y0) src:=I(#1,$x1,$y1)
      +gcd_srgb_curve_target[0] $src,$trg
      if $5
        +_gcd_chromacity_distance[0] $trg *. -1 +. 1
        if $5>1 pow. 3 fi
        j[0] ..,0,0,0,0,1,. rm[-2,-1]
      else j[0] . rm. fi
    }
    a[0,1] c a[-2,-1] c
  }

fx_gcd_color_spot_matching_preview :
  fx_gcd_color_spot_matching $*
  if $6>1 rv blend alpha elif $6>0 a x else a y fi

#@gui Temperature Balance: gcd_temp_balance, gcd_temp_balance(1)
#@gui : note = note("<i>Auto-detect lighting and adjust color temperature</i>"), sep = separator()
#@gui : Saturation = float(0,-1,1)
#@gui : Level = float(0,-1,1)
#@gui : Color = float(1,0,2)
#@gui : Lighting = choice("Automatic","Automatic [Scan All Hues]","Standard [No Scan]")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/08/30</i>.</small>")
gcd_temp_balance : skip ${1=0},${2=0},${3=1},${4=0}
  repeat $! l[$>]
    split_opacity to_rgb[0] +gcd_srgb2luma[0]
    if $4<2
      m={if($4,360,90)} $m,1,1,1 +r[0] 32,32,100%,100%,2
      repeat $m +gcd_hue_level. $> =... {ia},$> rm. done
      rm. h={xM} rm.
    else h=39 fi
    if $2!=0
      +l[0] sh[0] 0 sh[0] 1 sh[0] 2
        ({$h%360}^1^1) hsv2rgb. max. 0 *. $2 -. {ia}
        +[-4] {@0} +... {@1} +.. {@2} rm[-4--1] max[0] 0
      done
      +compose_channels[0] max n. 0,1
      j[0] ..,0,0,0,0,1,. rm[-2,-1]
    fi
    gcd_hue_chroma[0] $h,{($1+1)*$3},$3
    gcd_srgb2jpeg[0] j[0] . rm.
    gcd_jpeg2srgb[0] round 1 a c c 0,255
  done done

gcd_hue_level : skip ${1=0}
  repeat $! l[$>]
    h={($1%360)/60} x={1-abs($h%2-1)} y={if($x>0,1/$x,0)} h={int($h)+1}
    p={arg($h,0,1,1,2,2,0)} s={arg($h,1,0,2,1,0,2)} z={arg($h,2,2,0,0,1,1)}
    sh. $p sh.. $s +*.. $x
    +le. .. j... ..,0,0,0,0,1,. rm..
    eq. 0 +*.. $y j[-4] .,0,0,0,0,1,..
    rm[-4--1] sh. $z f. 0 rm.
  done done

#@gui Unquantize [JPEG Smooth]: gcd_unquantize, gcd_unquantize(0)
#@gui : note = note("<u>Remove quantization artifacts</u>")
#@gui : note = note("<small>1. Preview will <b>not</b> show the final result accurately.</small>")
#@gui : note = note("<small>2. Be sure to apply <b>before</b> any image resizing.</small>")
#@gui : note = note("\n<i>Block Smoothing Options</i>"), sep = separator()
#@gui : Iterations = int(6,0,8)
#@gui : Preserve Edges = float(1,0,1)
#@gui : Color Channels = bool(1)
#@gui : note = note("\n<i>Anti-Aliasing Options</i>"), sep = separator()
#@gui : Iterations = int(5,0,30)
#@gui : Threshold = int(15,1,200)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2014/04/29</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>Useful for removal of common compression and rescaling artifacts.</small>")
#@gui : note = note("<small>* If a specific glitch remains, try reducing edge preservation.</small>")
#@gui : note = note("<small>* For AA only set Block Iterations to 0.</small>")
gcd_unquantize : skip ${1=6},${2=1},${3=1},${4=5},${5=15}
  repeat $! l[$>]
    gcd_srgb2jpeg s c
    if $1>0
      +edges[0] 14.5% n. {1-$2},1
      if $3" && "$!>2
        a[1,2] c +apo[1] "median 5",3
        j[1] .,0,0,0,0,1,.. rm.
      fi
      {w},{h},1,1,0 grid. 8,8,0,0,1,1 grid. 8,8,-1,-1,1,1
      b. 1,0 *[-2,-1] n. 0,1 +pde_flow[0] $1,30,iee,0
      j[0] .,0,0,0,0,1,.. rm[-2,-1]
    fi
    if $4>0
      +median[0] 3 -. [0]
      abs. ge. $5
      dilate. 3 n. 0,1
      +apo[0] "pde_flow "$4",7,iee,0",8
      j[0] .,0,0,0,0,1,.. rm[-2,-1]
    fi
    a c gcd_jpeg2srgb c 0,255
  done done

#@gui Warp Map: gcd_warpmap, gcd_warpmap(1)
#@gui : note = note("<i>Warp an image using another as a surface</i>"), sep = separator()
#@gui : Depth = float(5,0,100)
#@gui : Detail = float(0,0,10)
#@gui : Smoothness = float(0,0,10)
#@gui : Blend Mode = choice("Warp","Multiply","Softlight","None")
#@gui : Swap Layers = bool(0)
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
#@gui : note = note("\n<small><b><u>Notes</u></b></small>")
#@gui : note = note("<small>The top layer will be warped using the bottom layer as a surface.</small>")
#@gui : note = note("<small>\nDepth: Set the apparent depth of the surface.</small>")
#@gui : note = note("<small>Detail: Perform second warp with no smooth for fine detail.</small>")
#@gui : note = note("<small>Smooth: Set low for emboss, high to wrap around large objects.</small>")
gcd_warpmap : skip ${1=5},${2=0},${3=0},${4=0},${5=0}
  repeat int($!/2) l[$>,{$>+1}]
    if $5 rv fi
    if $4==3 bm=0 i[0] . else bm=$4 fi
    if $2 +gcd_warp[-2,-1] $1,$3 rm... rv[-2,-1] gcd_warp[-2,-1] $2,0,$bm
    else gcd_warp[-2,-1] $1,$3,$bm fi
    if $4==3 rv fi
  done done

gcd_warp : skip ${1=5},${2=0},${3=0} # params: max_warp, smooth, blend_type (currently warp/mult/softlight)
  repeat int($!/2) l[$>,{$>+1}]
    wfac={$1%*w} to_rgba[-2,-1] +norm.  # 0=img to warp 1=surface 2=b&w of surface
    b. xy,$2% n. 0,255 g. xy a[-2,-1] c # change 2 into warp field using gradient
    *. -1 n. -$wfac,$wfac warp[0] .,1 rm. # set warp range, warp image 0
    if $3==0 rm. break fi # discard surface and exit if blend mode=warp
    if $3==1 blend multiply,1,1 else blend softlight,1,1 fi
  done done

#@gui Wiremap: gcd_wiremap, gcd_wiremap(1)
#@gui : note = note("<i>Turn an image into a wireframe map</i>"), sep = separator()
#@gui : Segments = int(100,4,400)
#@gui : Depth = int(100,4,400)
#@gui : Smoothness = float(0.5,0,2)
#@gui : Distance = float(0.5,-2,2)
#@gui : Output = choice("Black & White","Color","Transparent Black & White","Transparent Color")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2016/01/27</i>.</small>")
#@gui : note = note("<small>\n<b>Warning:</b> can be extremely slow with high segments!</small>")
#@gui : note = note("<small>Lower layer will be used for color if available.</small>")
gcd_wiremap : skip ${1=100},${2=100},${3=0.5},${4=0.5},${5=0}
  dm={$!>1" && "$5%2}
  l[${arg\ 1+$dm,0,0-1}]
    if $dm op=0
      if s==2||s==4 split_opacity. rv[^0] op=1 remove_opacity[0]
      elif {0,s==2||s==4} split_opacity[0] op=1 fi
    else split_opacity op={$!>1} fi
    +norm[0] b. $3% n. 0,$2 *. -1 w={w/2} h={h/2}
    r. $1,{round(h/w*$1)},1,3,2 v={w*h} p={(w-1)*h+(h-1)*w} ln={h}
    sh. 0 f. x n. -$w,$w rm.
    sh. 1 f. y n. -$h,$h rm. permute. cxyz y.
    (67.5;73.5;109.5;103.5;51.5;100.5) # CImg3d
    ($v;$p) # number of vertices, primitives

    # primitive type, vert. index
    {($1-1)*2},$ln,1,1,if(x%2,-1,2) {($1-1)*2},$ln,1,1,"y*$1+round(x/2)"
    a[-2,-1] c permute. cxyz discard. -1

    {($ln-1)*2},$1,1,1,if(x%2,-1,2) {($ln-1)*2},$1,1,1,"round(x/2)*$1+y"
    a[-2,-1] c permute. cxyz discard. -1 a[-2,-1] y

    if $5%2 # colour
      +r[{$dm?$dm+$op:0}] $1,{0,round(h/w*$1)},1,3,3 +z. 0,0,100%,{h-2}
      permute. cyxz z.. 0,0,{-2,w-2},100% permute.. cxyz y[-2,-1] a[-2,-1] y
    else 1,{$p*3},1,1,255 fi

    if $op # opacity
      +r[1] $1,{0,round(h/w*$1)},1,1,3 gt. 1 +z. 0,0,100%,{h-2} permute. cyxz
      z.. 0,0,{-2,w-2},100% permute.. cxyz y[-2,-1] a[-2,-1] y rm[1]
    else 1,$p,1,1,1 fi

    mv[-6] -3 a[-6--1] y
    if $5>1 # transparent
      f[0] 0 to_a[0] sh[0] 100% f. 255
      j3d[0] ..,50%,50%,{$2*$4},1,1,1,0 negate. rm[-2,-1]
    else f[0] 0 j3d[0] .,50%,50%,{$2*$4},1,1,1,0 rm. fi
  done

#@gui Xbr2x: gcd_xbr2x, gcd_xbr2x(1)
#@gui : note = note("Implementation of the xBR 2x [noblend] algorithm by Hyllian.")
##@gui : note = note("For more info visit: "), note = link("http://board.byuu.org/viewtopic.php?f=10&t=2248")
#@gui : note = link("http://code.google.com/p/2dimagefilter/wiki/ImageResizer")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.  Latest update : <i>2013/05/29</i>.</small>")
#@gui : note = note("<small>Disclaimer : This is a near complete recode based on C# source from ImageResizer</small>")
#@gui : note = note("<small>The results may not fully represent the original routine!</small>")
gcd_xbr2x :
 repeat $! l[$>] to_rgb[0]
  (-1,-1;0,-1;1,-1;-1,0;0,0;1,0;-1,1;0,1;1,1;\
  -1,-2;0,-2;1,-2;-2,-1;-2,0;-2,1;2,-1;2,0;2,1;-1,2;0,2;1,2)
  pa_=0 pb_=1 pc_=2  pd_=3 pe_=4 pf_=5  pg_=6 ph_=7 pi_=8
  a1_=9 b1_=10 c1_=11  a0_=12 d0_=13 g0_=14
  c4_=15 f4_=16 i4_=17  g5_=18 h5_=19 i5_=20
  e0=21 e1=22 e2=23 e3=24
  ($pe_,$pi_,$ph_,$pf_,$pg_,$pc_,$pd_,$pb_,$f4_,$i4_,$h5_,$i5_,$e1,$e2,$e3;\
  $pe_,$pc_,$pf_,$pb_,$pi_,$pa_,$ph_,$pd_,$b1_,$c1_,$f4_,$c4_,$e0,$e3,$e1;\
  $pe_,$pa_,$pb_,$pd_,$pc_,$pg_,$pf_,$ph_,$d0_,$a0_,$b1_,$a1_,$e2,$e1,$e0;\
  $pe_,$pg_,$pd_,$ph_,$pa_,$pi_,$pb_,$pf_,$h5_,$g5_,$d0_,$g0_,$e3,$e0,$e2)
  *[1] -1
  repeat 21 +shift[0] {1,round(i(0,$>))},{1,round(i(1,$>))},0,0,1 done
  [0] [0] [0] [0]
  =>[0] orig mv[0] $! rm[0] =>[0] kern mv[0] $!
  repeat 4
    pe={kern,i(0,$>)}  pi={kern,i(1,$>)}  ph={kern,i(2,$>)}
    pf={kern,i(3,$>)}  pg={kern,i(4,$>)}  pc={kern,i(5,$>)}
    pd={kern,i(6,$>)}  pb={kern,i(7,$>)}  f4={kern,i(8,$>)}
    i4={kern,i(9,$>)}  h5={kern,i(10,$>)} i5={kern,i(11,$>)}
    n1={kern,i(12,$>)} n2={kern,i(13,$>)} n3={kern,i(14,$>)}
    #compare centre pixel to right/below, create lvl1 mask
    +gcd_eq[$pe,$pf] +gcd_eq[$pe,$ph] or[-2,-1] eq. 0 => lvl1
    #get red/blue distances
    +gcd_yuv[$pe,$pc] +gcd_yuv[$pe,$pg] +[-2,-1]
    +gcd_yuv[$pi,$h5] +[-2,-1] +gcd_yuv[$pi,$f4] +[-2,-1]
    +gcd_yuv[$ph,$pf] *. 4 +[-2,-1]
    => red
    +gcd_yuv[$ph,$pd] +gcd_yuv[$ph,$i5] +[-2,-1]
    +gcd_yuv[$pf,$i4] +[-2,-1] +gcd_yuv[$pf,$pb] +[-2,-1]
    +gcd_yuv[$pe,$pi] *. 4 +[-2,-1]
    => blue
    #take colour from closest match between centre and right/below
    +gcd_yuv[$pe,$pf] +gcd_yuv[$pe,$ph] le[-2,-1]
    +image[$ph] [$pf],0,0,0,0,1,. => px rm..
    #If (red<blue)&&((pf!=i4)&&(ph!=i5)&&(pe==pi)||(pf!=pb)&&(ph!=pd)||(pe==pg)||(pe==pc))
    +lt[red,blue]
    +gcd_neq[$pf,$i4] +gcd_neq[$ph,$i5] and[-2,-1] +gcd_eq[$pe,$pi] and[-2,-1]
    +gcd_neq[$pf,$pb] +gcd_neq[$ph,$pd] and[-2,-1] or[-2,-1]
    +gcd_eq[$pe,$pg] or[-2,-1] +gcd_eq[$pe,$pc] or[-2,-1]
    and[-2,-1] => lvl2
    #level 2 interp
      +gcd_yuv[$pf,$pg] => lver # left vertice dist
      +gcd_yuv[$ph,$pc] => uver # upper vertice dist
      #If 2lv<=uv AND pe,pd != pg THEN Left2X(n3,n2,px)
      +*[lver] 2 le. [uver]
      +gcd_neq[$pg,$pe] +gcd_neq[$pg,$pd] and[-2,-1]
      and[-2,-1] and. [lvl2] image[$n3] [px],0,0,0,0,1,.
      #If 2uv<lv AND pe,pb != pc THEN Up2X(n3,n1,px)
      +*[uver] 2 lt. [lver]
      +gcd_neq[$pc,$pe] +gcd_neq[$pc,$pb] and[-2,-1]
      and[-2,-1] and. [lvl2] image[$n3] [px],0,0,0,0,1,.
      #ELSE Dia2X(n3,px) - not relevant for noblend
      #-or[-2,-1] eq. 0
      rm[-2,-1,lver,uver]
    #else if red<=blue blend - not relevant for noblend
    #eq[lvl2] 0 and[lvl1,lvl2] +le[red,blue] and[lvl1,-1]
    #blend pixel using lvl1 mask
    #image[$n3] [px],0,0,0,0,0,[lvl1]
    rm[red,blue,lvl1,lvl2,px] #cleanup
  done
  #render scaled image
  {orig,w},{orig,h},1,1,1 rs. {orig,w*2},,4 => msk
  rs[orig,$e0,$e1,$e2,$e3] {orig,w*2},,1
  image[orig] [$e0],0,0,0,0,1,[msk] shift[msk] 1
  image[orig] [$e1],0,0,0,0,1,[msk] shift[msk] -1,1
  image[orig] [$e2],0,0,0,0,1,[msk] shift[msk] 1
  image[orig] [$e3],0,0,0,0,1,[msk]
  k[orig]
done done

gcd_eq : l[-2,-1] -[-2,-1] norm. eq. 0 done
gcd_neq : l[-2,-1] -[-2,-1] norm. neq. 0 done
gcd_yuv : l[-2,-1] -[-2,-1] abs. rgb2yuv. abs. s. c *... 48 *.. 7 *. 6 +[-3--1] done

#@gui JPEG Smooth : gcd_jpeg_smooth, gcd_jpeg_smooth_preview(0)
#@gui : note = note("<i>Quick JPEG cleanup for moderate compression glitches</i>")
#@gui : sep = separator()
#@gui : Compression Filter = bool(1)
#@gui : Anti Alias = bool(1)
#@gui : Quick Enlarge = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_jpeg_smooth : skip ${1=1},${2=1},${3=0}
  repeat $! l[$>]
    if $1 gcd_comp_blur. 2,3,1,100,1 fi
    if $3 r. 140%,140%,1,3,5 c. 0,255 fi
    if $2 gcd_anti_alias. 10,0.3,10 fi
  done done

gcd_jpeg_smooth_preview :
  gui_split_preview "gcd_jpeg_smooth ${1--2}",$-1

#@gui Compression Blur : gcd_comp_blur, gcd_comp_blur_preview(0)
#@gui : note = note("<i>For subtle smoothing of compression artifacts</i>")
#@gui : sep = separator(), note = note("<small>1. Preview will <b>not</b> show the final result accurately.</small>")
#@gui : note = note("<small>2. Be sure to apply <b>before</b> any image resizing.</small>")
#@gui : note = note("<small>3. Reduce grid width when increasing divisions to avoid over-smoothing.</small>")
#@gui : note = note("<small>4. Set grid divisions to zero for 100% smoothing.\n</small>")
#@gui : sep = separator()
#@gui : Grid Divisions = int(2,0,3)
#@gui : Grid Width = int(3,1,3)
#@gui : Grid Smoothing = float(1,0,1)
#@gui : Preserve Edges = int(100,0,100)
#@gui : Colour Channels = bool(1)
#@gui : Boost Smooth = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2015/05/15</i>.</small>")
gcd_comp_blur : skip ${1=2},${2=3},${3=1},${4=100},${5=1},${6=0}
  gsz={2^(5-$1)}
  repeat $! l[$>]
    remove_opacity.
    +to_gray[0] edges. 14.5% n. {100-$4}%,100%
    if {0,s>1" && "$5}
      +ac[0] "median 5",ycbcr_cbcr
      image[0] .,0,0,0,0,1,.. rm.
    fi
    if $1==0 {w},{h},1,1,255 *[-2,-1] else
      {w},{h},1,1,0
      grid. $gsz,$gsz,0,0,1,255
      if $2>=2 grid. $gsz,$gsz,1,1,1,255 fi
      if $2==3 grid. $gsz,$gsz,-1,-1,1,255 fi
      b. $3,0 *[-2,-1]
    fi
    i.. [0] append[-2,-1] c
    smooth[1] {100*$6+100},0.6,0.3
    blend[0,1] alpha
    if !$6 sharpen. 20 fi
  done done

gcd_comp_blur_preview :
  gui_split_preview "gcd_comp_blur ${1--2}",$-1

#@gui Anti Alias : gcd_anti_alias, gcd_anti_alias_preview(0)
#@gui : note = note("<i>Selectively smooth resizing pixelation</i>"), sep = separator()
#@gui : Smooth Amount = int(60,0,200)
#@gui : Edge Exponent = float(0.3,0,10)
#@gui : Lighten Edges = int(50,0,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>Garagecoder</i>.      Latest update : <i>2013/02/09</i>.</small>")
gcd_anti_alias : skip ${1=10},${2=0.3},${3=10}
  foreach { split_opacity l[0] {
    +smooth[0] $1,0,1,1.6,1.1,0.8,30,0.6
    +gradient_norm[0] +n. 0,$3 +[0,-1]
    ^. $2 n. 0,255
    +gradient_norm. ^. $2 n. 0,255
    blend[-2,-1] overlay append[-2,-1] c
    blend[0,1] alpha c 0,255
  } a c }

gcd_anti_alias_preview :
  gui_split_preview "gcd_anti_alias ${1--2}",$-1

gcd_srgb2jpeg :
  repeat $! l[$>]
    if s<3 continue fi
    if s==4 split_opacity fi
    mix_rgb[0] 0.299,0.587,0.114,-0.1687,-0.3313,0.5,0.5,-0.4187,-0.0813
    sh[0] 1,2 +. 128 rm. a c
  done done

gcd_jpeg2srgb :
  repeat $! l[$>]
    if s<3 continue fi
    if s==4 split_opacity fi
    sh[0] 1,2 -. 128 rm.
    mix_rgb[0] 1,0,1.402,1,-0.34414,-0.71414,1,1.772,0 a c
  done done

gcd_srgb2luma :
  repeat $! l[$>]
    remove_opacity
    if s!=3 continue fi
    sh[0] 0,0 sh[0] 1,1 sh[0] 2,2
    *[1] 0.299 *[2] 0.587 *[3] 0.114
    +[1-3] rm[1] channels[0] 0
  done done

gcd_srgb2luminance :
  repeat $! l[$>]
    remove_opacity
    if s!=3 continue fi
    srgb2rgb[0] sh[0] 0,0 sh[0] 1,1 sh[0] 2,2
    *[1] 0.2126 *[2] 0.7152 *[3] 0.0722
    +[1-3] rm[1] channels[0] 0
  done done

# illuminant E
gcd_rgb2luminance :
  foreach {
    remove_opacity
    if s!=3 continue fi
    sh[0] 0 sh[0] 1 sh[0] 2
    *[1] 0.1762044 *[2] 0.8129847 *[3] 0.0108109
    +[1-3] rm[1] channels[0] 0
  }

gcd_gamma : skip ${1=1},${2=0},${3=255}
  if $1==1 return fi
  repeat $! l[$>]
    if !$2 g={1/max($1,0.001)} -^ $g * {$3^(1-$g)}
    else * -1 + $3 max 0 -^ $1 * {-$3^(1-$1)} + $3 fi
  done done

gcd_sbezier : skip ${1=0.5},${2=255}
  repeat $! l. / $2 +sqr *. {1-2*$1} *.. {2*$1} + * $2 done done

gcd_ibezier : skip ${1=0.5},${2=255}
  if $1==0.5 return fi
  repeat $! l.
    d={1-2*$1} e={$1/$d} / {$2*$d} + {$e*$e}
    sqrt. * {$1>0.5?-1:1} - $e * $2
  done done

gcd_label : skip ${1=4},${2=0.067}
  #***** CUSTOM LABEL, INPAINT SMALL AREAS *****
  # gcd_label <tolerance=4>,<size=0.2>
  repeat $! l[$>]
    label. $1,1 nb={1+iM}
    +histogram. $nb,0,{$nb-1}
    +map.. . rm..
    le. {$2%*w*h} *. 255
    inpaint.. . rm.
  done done

gcd_shrink :
  #***** SHRINK AN IMAGE TO 700px FOR SPEED *****
  _gcd_w={0,w} _gcd_h={0,h}
  repeat $! l[$>] if max(w,h)>700 rr2d. 700,700,0,1 fi done done

gcd_unshrink :
  repeat $! l[$>] r $_gcd_w,$_gcd_h done done

gcd_fix_alpha :
  #***** Force gimp to set transparent region pixels black *****
  repeat $! l[$>] if s==2||s==4
    sh 0,{s-2} sh[0] 100%,100% max. 1 +neq. 1 *[-3,-1] -k[0]
  fi done done

#@cli gcd_noalpha
#@cli : Remove any gimp alpha channel and zero transparencies
gcd_noalpha :
  e[^-1] "Remove gimp alpha channel from image$?."
  repeat $! l[$>] if s==2||s==4
    m={s-2} sh 0,$m sh.. 100% neq. 0 *.. . -k[0] channels 0,$m
  fi done done

#@cli gcd_splitalpha
#@cli : Split any gimp alpha channel and zero transparencies
gcd_splitalpha :
  e[^-1] "Split gimp alpha channel from image$?."
  repeat $! l[$>] if s==2||s==4
    m={s-2} sh 0,$m sh.. 100% . neq.. 0 *[1,2] -k[^1] channels.. 0,$m
  fi done done

#@cli gcd_force_rgb
#@cli : Force selected gimp images to be in RGB mode.
gcd_force_rgb :
   e[^-1] "Force gimp image$? to be in RGB mode."
   repeat $! l[$>]
     if s>4 error[] "Command 'gcd_force_rgb': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
     elif s==4 sh 0,2 sh.. 3 neq. 0 *.. . -k[0] channels 0,2
     elif s==2 sh 0 sh.. 1 neq. 0 *.. . -k[0] channels 0 r 100%,100%,100%,3
     elif s==1 r 100%,100%,100%,3
     fi
   done done

#@cli gcd_force_rgba
#@cli : Force selected gimp images to be in RGBA mode.
gcd_force_rgba :
   e[^-1] "Force gimp image$? to be in RGBA mode."
   repeat $! l[$>]
     if s>4 error[] "Command 'gcd_force_rgba': Image ["$>"] is not a G,GA,RGB or RGBA image ("{s}" channels)."
     elif s==4 +channels 3 neq. 0 *
     elif s==3 channels 0,3 sh. 3 f. 255 rm.
     elif s==2 +channels 1 neq. 0 * r 100%,100%,100%,4 sh. 2 f. .. rm.
     elif s==1 r 100%,100%,100%,4 sh. 3 f. 255 rm.
     fi
   done done

#@cli gcd_force_a
#@cli : Force selected gimp images to have an alpha channel.
gcd_force_a :
  e[^-1] "Force gimp image$? to have an alpha channel."
  repeat $! l[$>]
    if s==1||s==3 channels 0,{s} sh. {s-1} f. 255 rm.
    elif s==2||s==4 +channels 100% neq. 0 * fi
  done done

#@cli gcd_srgb2rgb
#@cli : Convert from sRGB gamma to RGB by fast approximate.
gcd_srgb2rgb :
  e[^-1] "Convert image$? from sRGB gamma to RGB by fast approximate."
  c 0,255 * 257 round 1 (0,255) r. 65536,1,1,1,3 srgb2rgb. map[^-1] . rm.

#@cli gcd_rgb2srgb
#@cli : Convert from RGB to sRGB gamma by fast approximate.
gcd_rgb2srgb :
  e[^-1] "Convert image$? from RGB to sRGB gamma by fast approximate."
  c 0,255 * 257 round 1 (0,255) r. 65536,1,1,1,3 rgb2srgb. map[^-1] . rm.

#@cli gcd_extract_clut : _resolution_root,_smoothness,_nb_iterations>=0,_nb_randoms>=0
#@cli : Extract color LUT from selected images.
gcd_extract_clut : skip ${1=8},${2=3},${3=5},${4=5}
  e[^-1] "Extract color LUT from image$?."
  to_rgb b={int($1)^2} s={$b^1.5}
  (0,1;0,1/0,1;0,1^0,0;1,1/0,0;1,1^0,0;0,0/1,1;1,1)
  *. 255 r. $b,$b,$b,3,3 r. $s,$s,1,3,-1
  repeat $!-1 l[$>,-1] nm="[CLUT: "{0,n}"]"
    +matchpatch. ..,1,1,1,$3,$4 warp[0] .,0
    rm. r.. $b,$b,$b,3,-1 b.. $2 =>.. $nm
  done done rm.

#@cli gcd_geometric_median : size>=0,_nb_iter>=0
#@cli : Apply geometric median filter on vector-valued images.
#@cli : Default values: 'size=3' and 'nb_iter=12'.
#@cli : $ image.jpg +gcd_geometric_median 3
gcd_geometric_median : skip ${1=3},${2=12}
  e[^-1] "Apply geometric median filter of size $1, on image$?."
  repeat $! l[$>]
  [0] +boxfilter. {$1+1-$1%2} sh. 0
  f. "*
    begin(
      const boundary = 1;
      const N = int($1/2);
      const W = N+1;
      weightedSum = I(#1);
      totalDist = weightedSum;
    );

    Y = I(#2,x,y); # centroid

    for (iters = 0, iters<$2, ++iters,
      weightedSum = 0;
      totalDist = 0;
      distSum = 0;
      flag = 0;

      for (j = -N, j<W, ++j,
        for (k = -N, k<W, ++k,
          X = J(#1,j,k);
          diff = X - Y;
          dist = norm2(diff);
          if(dist==0, flag=1,
            R = 1/dist;
            weightedSum += R * X;
            totalDist += R * diff;
            distSum += R;
          );
        );
      );

      if(totalDist==0, break(),
        bal = flag ? 1/norm2(totalDist) : 0;
        Y = max(0, 1 - bal) * weightedSum / distSum + min(1, bal) * Y;1
      )
    );

    I(#0,x,y) = Y;1" k[0]
  done done

#@cli gcd_poisson_disk : _radius[%]>0,_value,_max_iters>0
#@cli : Add poisson disk sampling noise to selected images.
#@cli : Default values: 'radius=8', 'value=1' and 'max_iters=30'.
##@cli : $ 800,800 gcd_poisson_disk 8
gcd_poisson_disk : check "${1=8}>0 && ${3=30}>0" skip ${2=1}
  e[^-1] "Add noise points to image$?, with specified minimum distance."
  repeat $! l[$>]
    R={${"is_percent $1"}?max(w,h,d)*$1:$1}
    # [0] input image to draw samples on
    dim={d>1?3:h>1?2:1} cw={0.999*$R/sqrt($dim)} # dimensions, grid cell width
    ({[w,h,d,1]}) y. c  # [1] image dimensions vector
    {[ceil(I/$cw)]}     # [2] "accelerator" grid/cells
    r[1] 1,1,1,$dim,-1  # keep only used dimensions in [1]
    1,1,1,$dim 1,1,1,1  # [3] samples list, [4] active list
    {vector$dim(2*ceil(sqrt($dim))+1)} r. 100%,100%,100%,2 # [5] cell proximity kernel
    f. "P=[x,y,z]-int([w/2,h/2,d/2]);[sum(sqr(P)),dot(P,[1,w#2,w#2*h#2])]"
    r. {[whd,s,1,1,-1]} sort. +,x z. 0,1,100%,100% y. c # sort kernel by distance
    =>[1] dims =>[2] grid =>[3] samples =>[4] active =>[5] prox
    eval ${-math_lib}${-dar_lib}"
      const N = "$dim";
      const radius = "$R";
      const grid_cw = "$cw";
      const max_sample_attempts = $3;
      mag2(vec) = (sum(sqr(vec)));
      prox = I#5;
      lim = I#1;

      dar_insert(#3,I#1,0);               # dummy sample to simplify bounds checks
      dar_insert(#3,u(I#1),1);            # add initial sample to list
      dar_insert(#4,1,0);                 # add its index to active list
      I(#2,int(I[#3,1]/grid_cw)) = 1;     # add its index to grid cell
      I(#0,I[#3,1]) = $2;                 # draw the point

      while (dar_size(#4)>0,
        R = int(u(dar_size(#4)-1e-4));    # choose a random active list index
        P = i[#4,R];                      # get the index of that sample
        T = I[#3,P];                      # position vector of that sample

        for (attempts=0, attempts < max_sample_attempts, ++attempts,

          do (S=4*(u(vectorN(1))-0.5); M=mag2(S), M <= 1 || M > 4);

          X = T + radius * S;             # potential sample from annulus around T
          if (min(X)<0 || min(lim-X)<0, continue()); # check within bounds

          # check proximity of surrounding points
          G = int(X/grid_cw);             # grid cell position vector
          GI = dot(G,[1,w#2,w#2*h#2]);    # grid cell direct buffer index

          for (K=0;rejected=0, K<size(prox), ++K,
            V = i[#2,GI+prox[K]];         # sample index from grid to check
            if (V>0 && mag2(I[#3,V]-X)<sqr(radius), rejected=1;break())
          );

          if (!rejected,
            Q = dar_size(#3);               # sample found, get new index
            dar_insert(#3,X,Q);             # insert into samples list
            dar_insert(#4,Q,dar_size(#4));  # insert its index into active
            I(#2,G) = Q;                    # insert its index into grid
            I(#0,X) = $2;                   # draw the point
            break();
          );
        );

        if (attempts == max_sample_attempts, dar_remove(#4,R));
      );
    " k[0]
  done done

#@cli gcd_blur_masked : std_deviation>=0[%],_boundary_conditions,_kernel
#@cli : Blur selected images using a binary inclusion mask.
#@cli : See 'help blur' for full parameters description.
#@cli : $ image.jpg to_rgb +to_a circle 50%,50%,80,1,0 gcd_blur_masked 2%
gcd_blur_masked :
  e[^-1] "Blur image$? with binary inclusion masking."
  repeat $! l[$>] # b / (1 - z)
    to_a split_opacity mo={iM}
    ge. 1 *[0] . +eq. 0 b[0,-1] $* *. .. *. -1 +. 1 /[0,-1] *[0] .
    *. $mo a c
  done done

#@cli gcd_boxfilter_local : [reference_image]
#@cli : Blur selected images by a per-pixel box filter (2D SAT implementation).
#@cli : Local window sizes are specified by the reference image.
#@cli : $ sample +gaussian 20%,20% n. 0,50 gcd_boxfilter_local.. .
gcd_boxfilter_local : check ${"is_image_arg $1"}
  pass$1 0 max. 1
  repeat $!-1 l[$>,-1]
    av={ia#0} sub.. $av cumulate.. xy # bias to improve precision
    f.. "
    begin(
      const boundary=1;
      const interpolation=1;
      const W=w-1; const H=h-1;
      T(X,Y)=Y>1?i(X,Y-1):Y*i(X,0);
      B(X,Y)=Y<H?i(X,Y):(1+Y-H)*i(X,H)-(Y-H)*i(X,H-1);
      D(X,Y)=X>1?T(X-1,Y):X*T(0,Y);
      E(X,Y)=X<W?T(X,Y):(1+X-W)*T(W,Y)-(X-W)*T(W-1,Y);
      F(X,Y)=X>1?B(X-1,Y):X*B(0,Y);
      G(X,Y)=X<W?B(X,Y):(1+X-W)*B(W,Y)-(X-W)*B(W-1,Y);
    );
    R=i#1; S=R*R; K=(R-1)/2;
    x0 = x - K;
    y0 = y - K;
    x1 = x + K;
    y1 = y + K;
    (G(x1,y1) - E(x1,y0) - F(x0,y1) + D(x0,y0))/S"
    add.. $av # restore bias
  done done rm.

#@cli gcd_boxfilter_local_hp : [reference_image]
#@cli : Blur selected images by a per-pixel box filter (High precision 2D SAT implementation).
#@cli : Local window sizes are specified by the reference image.
#@cli : $ sample +gaussian 20%,20% n. 0,50 gcd_boxfilter_local_hp.. .
gcd_boxfilter_local_hp : check ${"is_image_arg $1"}
  pass$1 0 max. 1
  repeat $!-1 l[$>,-1]
    av={ia#0} sub.. $av # bias to improve precision
    f.. "
    begin(
      const boundary=1;
      ref(crop(#0),img); # 64bit buffer
      const W=w-1; const H=h-1;
      px(x,y) = (img[x + y*w#0 + c*wh#0]);

      # Bilinear buffer interpolation
      qx(x,y) = (
        xA=floor(x);
        xB=ceil(x);
        yA=floor(y);
        yB=ceil(y);
        lx=x-xA;
        lerp(
          lerp(px(xA,yA),px(xB,yA),lx),
          lerp(px(xA,yB),px(xB,yB),lx),
          y-yA
        )
      );

      # Boundary handling of summed areas
      T(X,Y)=Y>1?qx(X,Y-1):Y*qx(X,0);
      B(X,Y)=Y<H?qx(X,Y):(1+Y-H)*qx(X,H)-(Y-H)*qx(X,H-1);
      D(X,Y)=X>1?T(X-1,Y):X*T(0,Y);
      E(X,Y)=X<W?T(X,Y):(1+X-W)*T(W,Y)-(X-W)*T(W-1,Y);
      F(X,Y)=X>1?B(X-1,Y):X*B(0,Y);
      G(X,Y)=X<W?B(X,Y):(1+X-W)*B(W,Y)-(X-W)*B(W-1,Y);

      # 2D cumulate
      for (C = 0; P = 0, C<s#0, ++C,
        for (X = 0; S = 0, X<w#0, ++X; ++P,
          S += img[P];
          img[P] = S;
        );
        for (Y = 1, Y<h#0, ++Y,
          for (X = 0; S = 0, X<w#0, ++X; ++P,
            S += img[P];
            img[P] = img[P-w#0]+S;
          )
        )
      )
    );
    R=i#1; S=R*R; K=(R-1)/2;
    x0 = x - K;
    y0 = y - K;
    x1 = x + K;
    y1 = y + K;
    (G(x1,y1) - E(x1,y0) - F(x0,y1) + D(x0,y0))/S"
    add.. $av # restore bias
  done done rm.

#@cli gcd_decumulate : _size>=1
#@cli : Compute the 2D cumulative inverse function of specified image data.
#@cli : $ sample cumulate xy gcd_decumulate 1
gcd_decumulate : check "${1=1}>=1"
  f "begin(
    const boundary=1;
    const interpolation=1;
    const W=w-1; const H=h-1;
    T(X,Y)=Y>1?i(X,Y-1):Y*i(X,0);
    B(X,Y)=Y<H?i(X,Y):(1+Y-H)*i(X,H)-(Y-H)*i(X,H-1);
    D(X,Y)=X>1?T(X-1,Y):X*T(0,Y);
    E(X,Y)=X<W?T(X,Y):(1+X-W)*T(W,Y)-(X-W)*T(W-1,Y);
    F(X,Y)=X>1?B(X-1,Y):X*B(0,Y);
    G(X,Y)=X<W?B(X,Y):(1+X-W)*B(W,Y)-(X-W)*B(W-1,Y);
    const R=$1; const S=R*R; const K=(R-1)/2;
  );
  x0 = x - K; y0 = y - K; x1 = x + K; y1 = y + K;
  (G(x1,y1) - E(x1,y0) - F(x0,y1) + D(x0,y0))/S"

#@cli gcd_inpaint_boxlocal : [mask]
#@cli : Inpaint selected images by specified mask.
#@cli : $ image.jpg 100%,100% circle. 50%,50%,50,1,1 gcd_inpaint_boxlocal.. .
gcd_inpaint_boxlocal : check ${"is_image_arg $1"}
  e[^-1] "Inpaint image$? by mask $1, using a per-pixel box filter algorithm."
  pass$1 0 lt. 1 store. msk
  repeat $! l[$>] # A(P * invmask)) / A(invmask)
    i $msk mul.. . +distance. 1 mul. 2
    gcd_boxfilter_local_hp[0,1] . rm.
    +eq. 0 add[-2,-1] div
  done done

#@cli gcd_inpaint_pyramid : [mask]
#@cli : Inpaint selected images by specified mask.
#@cli : $ image.jpg 100%,100% circle. 50%,50%,50,1,1 gcd_inpaint_pyramid.. .
gcd_inpaint_pyramid : check ${"is_image_arg $1"}
  pass$1 0 ge. 1 store. msk
  repeat $! l[$>]
    L,D,X,Y,W,H={\
        L=ceil(log(max(w,h))/log(2));\
        D=2^L;\
        X=ceil((D-w)/2);\
        Y=ceil((D-h)/2);\
        [L,2^L,X,Y,w,h]\
      } # L = number of levels
    i $msk z {[-$X,-$Y,$D-$X-1,$D-$Y-1]},1 # force 2^n dimensions
    eq. 0 mul.. .
    repeat $L
      +r[-2,-1] 50%,50%,100%,100%,2
      +eq. 0 add. .. div[-3,-1] gt. 0
    done
    i[0] (0.0625,0.125,0.0625;0.125,0.25,0.125;0.0625,0.125,0.0625)
    repeat $L
      l[0,-4--1] rm.
        r. [1],[1],[1],[1],1 convolve. [0]
        eq[2] 0 j[1] .,0,0,0,0,1,[2] rm.
      done
    done
    rm[0,-1] z {[$X,$Y,$X+$W-1,$Y+$H-1]},1 # restore dimensions
  done done

#@cli gcd_inpaint_flat : [mask]
#@cli : Inpaint selected images by specified mask using flat fill.
#@cli : $ image.jpg 100%,100% circle. 50%,50%,50,1,1 gcd_inpaint_flat.. .
gcd_inpaint_flat : check ${"is_image_arg $1"}
  img=$! pass$1 0 lt. 1 mul[^-1] . => mask
  +boxfilter[mask] 3 eq[mask] 0 => xmask
  +gt[xmask] 0 => bound
  +eq[xmask] 0 add[xmask] .
  j. [mask] label. 0 add. 1 mul. [mask] => segs
  repeat $img {
    l[$>,mask,xmask,bound,segs] {
      # buffer for inpaints
      [0],[0],[0],{s#0+1}
      j. [bound] j. [0],0,0,0,1 => inp
      # inpaint edges by 1px
      sh[inp] 1,100% boxfilter. 3 div. [xmask] rm.
      # vector histogram
      {segs,iM+1},1,1,[inp] => hist
      eval[segs] "I[#6,i]+=I#5"
      sh[hist] 1,100% sh[hist] 0
      +eq. 0 add[-2,-1] div[-2,-1]
      rm. channels. 1,100%
      # set segment colours and draw
      channels[inp] 0 j[inp] [segs] map[inp] [hist]
      j[0] [inp],0,0,0,0,1,[mask] rm[inp,hist]
    }
  }
  rm[mask,xmask,bound,segs]

#@cli gcd_dither_srgb : _nb_levels>=2
#@cli : Dither selected sRGB images.
#@cli : Default values: 'nb_levels=2'.
#@cli : $ image.jpg gcd_dither_srgb 6 round
gcd_dither_srgb : check "isint(${1=2}) && $1>=2"
  repeat $! l[$>]
    s c (0,255) r. $1,1,1,1,3
    srgb2rgb index[^-1] .,1,1 rm. a c rgb2srgb
  done done

#@cli gcd_shuffle
#@cli : Shuffle vectors of selected images with Fisher-Yates algorithm.
#@cli : $ uniform_distribution 8,3 gcd_shuffle
gcd_shuffle : f "<begin(P=whd);swap(I[int(u(0,P--,1,0))],I());I"

#@cli gcd_primes : limit>=2
#@cli : Return all primes not greater than the specified limit as a 1xN image.
#@cli : Default values: 'limit=97'.
#@cli : $ gcd_primes 1000
gcd_primes : check "isint(${1=97}) && $1>1"
  e[^-1] "Compute prime numbers not greater than $1."
  1,{$1+1},1,1,y
  eval "i[1]=0;for(N=2,N<=sqrt($1),++N,i[N]?for(P=N*N,P<=$1,P+=N,i[P]=0))"
  discard. 0

#@cli gcd_mean_transfer_curve :
#@cli : Calculate mean transfer curve between selected pair of images.
#@cli : Image values will be indexes to an output map per channel.
#@cli : Each map contains original and mapped values.
#@cli : $ image.jpg +negate noise. 50% gcd_mean_transfer_curve dg[^0]
gcd_mean_transfer_curve :
  e[0] "Index and calculate mean transfer curve for image$?."
  if $!!=2 error "Two images are required for $0" fi
  l[-2,-1]
    s0={s#0} r. 100%,100%,100%,$s0 s c
    repeat $s0 l[{[$<,$<+$s0]}]
      dims={0,[w,h,d]}
      $dims,3,[x,y,z] r. 1,{0,whd},1,3,-1
      y[0,1] a c sort +,y $dims,1 1,1,1,2
      eval "
      col=I[#0,0];
      V=col[0]; S=col[1]; N=1;
      i(#-2,col[2,3])=0;

      for(P=1;Q=0,P<h#0,++P,
        col=I[#0,P];
        if(V==col[0],
          S+=col[1]; N++,
          da_push([V,S/N]); V=col[0]; S=col[1]; N=1; Q++;
        );
        i(#-2,col[2,3])=Q;
      );

      da_push([V,S/N])"
      rm[0] z. 0,0,0,{i(0,h-1)-1}
    done done a[^50%-100%] c
  done

#@cli gcd_median_transfer_curve :
#@cli : Calculate median transfer curve between selected pair of images.
#@cli : Image values will be indexes to an output map per channel.
#@cli : Each map contains original and mapped values.
#@cli : $ image.jpg +negate noise. 50% gcd_median_transfer_curve dg[^0]
gcd_median_transfer_curve :
  e[0] "Index and calculate median transfer curve for image$?."
  if $!!=2 error "Two images are required for $0" fi
  l[-2,-1]
    s0={s#0} r. 100%,100%,100%,$s0 s c
    repeat $s0 l[{[$<,$<+$s0]}]
      dims={0,[w,h,d]}
      $dims,3,[x,y,z] r. 1,{0,whd},1,3,-1
      y[0,1] a c sort +,y $dims,1 1,1,1,2
      sh[0] 0 # get max run length
      eval. "begin(R=0;N=1);R=max(R,N);J[0]==J[1]?N++:N=1;end(set('R',R))"
      rm.
      eval "
      median(X,L)=(M=(L-1)/2;X=sort(X,1,L);lerp(X[floor(M)],X[ceil(M)]));
      col=I[#0,0]; V=col[0]; N=1;
      S=vector$R(); S[0]=col[1];
      i(#-2,col[2,3])=0;

      for(P=1;Q=0,P<h#0,++P,
        col=I[#0,P];
        if(V==col[0],
          S[N]=col[1]; N++,
          da_push([V,median(S,N)]); V=col[0]; S[0]=col[1]; N=1; Q++;
        );
        i(#-2,col[2,3])=Q;
      );

      da_push([V,median(S,N)])"
      rm[0] z. 0,0,0,{i(0,h-1)-1}
    done done a[^50%-100%] c
  done

#@cli gcd_solve_kernel : [target],_size>=1,_[mask],_boundary_conditions
#@cli : Solve for 2D [kernel] in 'convolve[selection] [kernel] = [target]'.
#@cli : 'boundary_conditions' can be { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default values: 'size=1' and 'boundary_conditions=1'.
#@cli : $ image.jpg +laplacian +gcd_solve_kernel.. .
gcd_solve_kernel : skip ${3=1},${4=1} check ${"is_image_arg $1"}" && isint(${2=1})"
  e[^-1] "Solve kernel for image$? with convolution target $1
          and "${"arg 1+$4,dirichlet,neumann,periodic,mirror"}" boundary conditions."
  pass$1 K:=$2*2+1 => target
  if ${"is_image_arg $3"}
    pass$3 0 => mask
    repeat $!-2 {
      l[$>,target,mask] {
        nm={0,n}"_kernel" 0 => patches 0 => points
        eval[mask] "begin(const boundary=$4;const K=$K);
          if(i>=1,
            da_push(#-2,crop(#0,x-$2,y-$2,z,c,K,K,1,1));
            da_push(#-1,i(#1,x,y));
          );
          end(set('H',da_size()-1));"
        if h==0 error[0] "Command 'gcd_solve_kernel': mask image is empty." fi
        permute[patches] cyxz
        z[patches,points] 0,0,100%,$H
        invert[patches] 1,1e-6 =>[patches] inv mmul[inv,points]
        mirror[inv] y r[inv] $K,$K,1,1,-1 rm[0] mv[inv] 0
        =>[inv] $nm
      }
    } rm[mask]
  else
    repeat $!-1 {
      l[$>,target] {
        nm={0,n}"_kernel" 0 => patches 0 => points
        eval[0] "begin(const boundary=$4;const K=$K);
            da_push(#-2,crop(#0,x-$2,y-$2,z,c,K,K,1,1));
            da_push(#-1,i(#1,x,y));
            end(set('H',da_size()-1));"
        permute[patches] cyxz
        z[patches,points] 0,0,100%,$H
        invert[patches] 1,1e-6 =>[patches] inv mmul[inv,points]
        mirror[inv] y r[inv] $K,$K,1,1,-1 rm[0] mv[inv] 0
        =>[inv] $nm
      }
    }
  fi
  rm[target]

#@cli gcd_solve_nonnegative : [image]
#@cli : Non-negative least squares using FNNLS algorithm.
#@cli : Solve Ax = b : xi>0 for selected A matrix and specified b vector.
#@cli : $ (7,0,5;5,7,7;9,3,10) (1;5;2) +gcd_solve_nonnegative.. .
gcd_solve_nonnegative : check ${"is_image_arg $1"}
  e[^-1] "Solve non-negative least squares for image$?."
  pass$1 0 => B
  repeat $!-1 { l[$>,-1] {
    M,N:=[h#0,w#0] act=$N best:=inf
    # Active and passive indexes are held in a single vector: [ind]
    1,$N,1,1 => X . => S . => W +f. y => ind
    +transpose[0] . mmul.. [0] mmul. [B] =>.. AtA => AtB

    for $act>0 {
      # W = AtB - AtA*x (negative gradient)
      j[W] [AtB] +mmul[AtA] [X] sub[W,-1]
      1,$act,1,1,"i[#$W,i[#$ind,y]]" => Wact

      # EXIT if most negative gradient hasn't improved
      new:=iM
      if $new<1e-6" || "$new>=$best rm[Wact] break fi
      best=$new

      # Move index of max Wact element from active to passive list
      eval "
        a_index = yM;
        w_index = i[#$ind,a_index];
        copy(i[#$ind,a_index],i[#$ind,a_index+1],$N-1-a_index);
        i[#$ind,$N-1] = w_index;"
      rm[Wact] act:=$act-1

      # Enforce non-negative constraint
      for 1 {
        # Solve As = b for current passive set
        part:=$N-$act
        sh[ind] $act,100%,0,0 => psv # passive indexes
        $part,$part,1,1,"i(#$AtA,i[#$psv,x],i[#$psv,y])" => Apsv
        1,$part,1,1,"i[#$AtB,i[#$psv,y]]" => Bpsv
        +solve[Bpsv] [Apsv] => Spsv

        # Copy passive solution to S, set to zero for active variables
        eval[S] "i[i[#$ind,y]]=y<$act?0:i[#$Spsv,y-$act]"
        rm[Apsv,Bpsv]

        # EXIT moving negatives if passive solution is all non-negative
        if im>0 rm[psv,Spsv] break fi

        # Calculate possible scaling ratios
        1,$part,1,1,"i[#$X,i[#$psv,y]]" => Xpsv
        1,$part,1,1,"XP=i[#$Xpsv,y];XP==0?0:XP/(XP-i[#$Spsv,y])" => ratio

        # Find minimum ratio
        eval[Spsv] "
          begin(MR=inf;MP=-1);
            CR=i[#$ratio,y];
            if(i<=0&&CR<MR,
                MR=CR;
                MP=i[#$psv,y];
              );
          end(set('alpha',MR);set('minpos',MP))"
        rm[Xpsv,ratio]

        # X = X + alpha*(S-X) (Do the scaling)
        +sub[S] [X] mul. $alpha add[X,-1] =[X] 0,0,$minpos

        # Move indexes from passive to active where X[p_index] <= 0
        eval[psv] "
          begin(t=0);
            p_index = i;
            if(i[#$X,p_index]<=0,
                copy(i[#$ind,1],i[#$ind,0],y+$act);
                i[#$ind,0] = p_index;
                t++;
              );
          end(set('act',$act+t))"
        rm[psv,Spsv]
      }
      j[X] [S]
    }
    k[X]
  } }

#@cli gcd_softcut : _low_threshold,_high_threshold,0<=_rolloff<=0.5
#@cli : Soft cut values of selected images to specified range.
#@cli : Default values: 'low_threshold=0', 'high_threshold=1' and 'rolloff=0.05'.
#@cli : $ image.jpg n 0,255 gcd_softcut 100,200
gcd_softcut : check "isnum(${1=0}) && isnum(${2=1}) && isnum(${3=0.05}) && $3>=0 && $3<=0.5"
  e[^-1] "Soft cut image$? range to [$1,$2] with rolloff $3."
  f "begin(
      const B = max($1,im);
      const T = min($2,iM);
      const P = $3 * (T - B);
      const bt = B + P;
      const tt = T - P;
      const br = bt - im;
      const tr = iM - tt;
      const G = br / P;
      const H = P / tr;
      f(X,A) = (X / (X * (1 - A) + A));
    );
    i < bt ? P * f((i-im)/br,G) + B :
    i > tt ? P * f((i-tt)/tr,H) + tt : i"

#@cli gcd_unsoftcut : _low_threshold,_high_threshold,0<=_rolloff<=0.5
#@cli : Reverse soft cut values of selected images to specified range.
#@cli : Default values: 'low_threshold=0', 'high_threshold=1' and 'rolloff=0.05'.
#@cli : $ image.jpg n 0,255 gcd_softcut 100,200 +gcd_unsoftcut 0,255
gcd_unsoftcut : check "isnum(${1=0}) && isnum(${2=1}) && isnum(${3=0.05}) && $3>=0 && $3<=0.5"
  e[^-1] "Reverse soft cut image$? range to [$1,$2] with rolloff $3."
  f "begin(
      const B = min($1,im);
      const T = max($2,iM);
      const P = $3 * (iM - im);
      const bt = im + P;
      const tt = iM - P;
      const br = bt - B;
      const tr = T - tt;
      const G = P / br;
      const H = tr / P;
      f(X,A) = (X / (X * (1 - A) + A));
    );
    i < bt ? br * f((i-im)/P,G) + B :
    i > tt ? tr * f((i-tt)/P,H) + tt : i"

#@cli gcd_self_guided : _radius[%]>=0,_regularization>=0
#@cli : Blur selected images with self-guided image filtering.
#@cli : Default values: 'radius=3' and 'regularization=0.01'.
#@cli : $ image.jpg gcd_self_guided 5%
gcd_self_guided : skip ${1=3},${2=0.01}
  e[^-1] "Apply self-guided filter to image$?, with radius $1 and regularization $2."
  foreach {
    R={$2*sqr(iM-im)} # range invariant epsilon
    [0]x2 sqr. boxfilter[-2,-1] $1 +sqr.. -[-2,-1]
    max. 0 ++. $R /[-2,-1] +boxfilter. $1
    *[0,-1] *. -1 +. 1 *[-2,-1] boxfilter. $1 +
  }

#@cli gcd_seams
#@cli : Find vertical paths with optimal variance for a given gradient map.
#@cli : $ image.jpg gradient_norm gcd_seams
gcd_seams :
  foreach {
    # Calculate low matrix (backwards propagation).
    +f[0] "<i+min(j(-1,1),j(0,1),j(1,1))"

    # Initialise seams, top matrix.
    100%,100%,100%,100% +rows[1] 0
    => grad,low,seam,top

    repeat h#0-1 {
      # get next row from low matrix
      nr:=$>+1 +z[low] 0,$nr,100%,$nr => cmp

      # Find optimum matches between two 1D matrices.
      +*[top,cmp] # vertical weights
      +shift[top] 1 *. [cmp] # diagonal backward weights
      +shift[cmp] 1 *. [top] # diagonal forward weights
      +[-2,-1] # summed diagonal weights
      j[cmp] [top]
      f[cmp] ">max(j(-1)+i#-2,j(-2)+i#-1)" # forward pass: f(x)
      shift[cmp] 1 +[-2] [cmp] # calculate all f(x-1) + vertical
      shift[cmp] 1 +[cmp,-1]   # calculate all f(x-2) + diagonal
      >[-2,-1] f. "<j(1)<0?1:-i" => offs # backward pass: offsets

      # Add matched row to seams.
      j[seam] [offs],0,$>

      # Distribute matched energy within top matrix.
      f[top] "j(i#-1)" rm[offs]

      # Add next energy row to top matrix.
      +z[grad] 0,$nr,100%,$nr +[top,-1]
    }

    # Calculate seam energy.
    j[grad] [top],0,100% rm[low,top]
    f[grad] "<j(i#-1,1,0,0,0,1)" rm[seam]
  }

#=============================================
#************* FILE BROWSER ******************
#=============================================

#@cli gcd_browse : "commands",_width,_height
#@cli : Navigate and display images from local storage.
#@cli : Specified "commands" can be applied while viewing.
#@cli : All arguments are optional.
#@cli :
#@cli : Controls:
#@cli : * `ESC or Q`     : Exit.
#@cli : * `Arrow Keys`   : Navigate directories.
#@cli : * `Page Up/Down` : Navigate images within current directory.
#@cli : * `Home/End`     : View first/last image in current directory.
#@cli : * `SPACE`   : Enable/disable specified commands.
#@cli : * `i`       : Toggle information display.
#@cli : * `f`       : Toggle fullscreen mode.
#@cli : * `e`       : Toggle edge filtering.
#@cli : * `w`       : Toggle wide mode.
#@cli : * `a or z`  : Move up or down in wide mode.
gcd_browse : check "isnum(${2=-1}) && isnum(${3=-1})" skip "${1=,}"
if same(["'$1'"],',')
  m "_gcd_tmp_cmd : +gcd_std_score_patch 3 compose_channels. add orientation.. mul.. 2 add n 0,255"
else m "_gcd_tmp_cmd : $1"
fi
if ${-is_windows}" || "${-is_macos}
  filespec={/"*.jpg","*.jpeg","*.png","*.tif","*.tiff"}
else filespec={/"*.jpg","*.JPG","*.jpeg","*.png","*.tif","*.TIF","*.tiff"}
fi
  w,h={[$2>0?$2:{*,u}-1,$3>0?$3:{*,v}]} # get usable screen dimensions
  cursor[0] 0 font={max(13,sqrt($w*$h)/48)} # font size
  info,hq,fs,cmdon,refresh,pid,wide,start={[1,0,1,0,1,0,0,0.5]}
  path_current path=${}
  gcd_parentdir {``$path} files2img 1,${} => dirs
  gcd_currentdir {``$path} gcd_argnum[dirs] ${}
  dlim,dpos={dirs,[h,${}]} 0 => imgfiles 0 => vwimg
  $w,$h,1,3 => screen # screen buffer image
  1 store. cid # history of subfolder ids
  1 store. pid # history of parentfolder ids
  do
    if $refresh
      rm[imgfiles]
      gcd_filelist {``$path},$filespec
      => imgfiles lim,pos={imgfiles,[h,1]}
      refresh={!$refresh}
    fi
    if $lim>0
      rm[vwimg] gcd_imgarg[imgfiles] $pos i ${}
      dim={`string(w,'x',h,'x',s)`}
      details="dim: "$dim"  "{x}": "{b} => vwimg
    else
      rm[vwimg] 1,1,1,3 => vwimg details="no images"
    fi
    if $cmdon
      l[vwimg] _gcd_tmp_cmd
      if 1!=$! error "Exactly one image must be returned by custom commands" fi
      nm vwimg
      done
    fi
    to_rgb[vwimg] gcd_resize_for_fs[vwimg] $w,$h,$hq,$wide
    f[screen] 0 j[screen] [vwimg],0.5~,$start~
    if $info
      if $hq fe="edge " else fe="" fi if $cmdon fe.="cmd " fi
      0 t. $path,0,0,$font,1,255,255,255 j[screen] .
      0 t. $dpos"/"$dlim,0,0,{$font*2},1,255,0,255 j[screen] .,0,{h#-2} rm[-2,-1]
      0 t. $details,0,0,$font,1,255,255,255 j[screen] .,0,{{screen,h}-h} rm.
      0 t. $fe$pos"/"$lim,0,0,{$font*2},1,0,255,0 j[screen] .,{{screen,w}-w} rm.
    fi
    # display and wait/check for keypress
    w[screen] 100%,100%,0,$fs,"Image Browser" cursor[0] 0 wait
    if {*,PAGEUP}" && "$pos>1 pos-=1 wait -1 fi
    if {*,PAGEDOWN}" && "$pos<$lim pos+=1 wait -1 fi
    if {*,HOME} pos=1 wait -1 elif {*,END} pos=$lim wait -1 fi
    if {*,E} hq={!$hq} wait -1 elif {*,SPACE} cmdon={!$cmdon} wait -1 fi
    if {*,F} fs={!$fs} if $fs w[] 100%,100%,0,1 fi wait -1 fi
    if {*,I} info={!$info} wait -1 fi
    if {*,W} wide={!$wide} wait -1 fi
    if {*,Z} start={min($start+0.25,1)} wait -1 fi
    if {*,A} start={max($start-0.25,0)} wait -1 fi
    if {*,ARROWLEFT}
      i $cid eval "da_push("$dpos")" store. cid
      i $pid eval "S=da_size();V=i[S-1]; S>0?da_remove(); V" nxt=${} store. pid
      gcd_parentdir {``$path} path=${}
      rm[dirs] gcd_parentdir {``$path} files2img 1,${} => dirs
      if $nxt==0 gcd_currentdir {``$path} gcd_argnum[dirs] ${} nxt=${} fi
      dlim,dpos={dirs,[h,max($nxt,1)]}
      refresh=1 wait -1
    fi
    if {*,ARROWRIGHT}" && "$dlim>0
      files2img 1,{``$path} => subdirs
      if h>0
        i $pid eval "da_push("$dpos")" store. pid
        i $cid eval "S=da_size();V=i[S-1]; S>0?da_remove(); V" nxt=${} store. cid
        rm[dirs] =>[subdirs] dirs
        dlim,dpos={dirs,[h,max($nxt,1)]}
        gcd_imgarg[dirs] $dpos path.=${}"/"
        refresh=1 wait -1
      else rm[subdirs] fi
    fi
    if {*,ARROWUP}" && "$dpos>1
      1 store. cid # invalidate subfolder history
      dpos-=1 gcd_parentdir {``$path} path=${}
      gcd_imgarg[dirs] $dpos path.=${}"/"
      refresh=1 wait -1
    fi
    if {*,ARROWDOWN}" && "$dpos<$dlim
      1 store. cid # invalidate subfolder history
      dpos+=1 gcd_parentdir {``$path} path=${}
      gcd_imgarg[dirs] $dpos path.=${}"/"
      refresh=1 wait -1
    fi
  while {*}" && "!{*,Q}" && "!{*,ESC}
  um _gcd_tmp_cmd cursor[0] 1 w 0 # restore view and exit
  e $path e $details rm[dirs,imgfiles,vwimg,screen]

#@cli gcd_imgarg : n>=1
#@cli : Return the n-th argument of the specified string list image.
gcd_imgarg : skip ${1=1} u {``{`I[$1-1]`}}

#@cli gcd_argnum : "search_str"
#@cli : Return the index of the first matching argument in the specified string list image.
gcd_argnum :
  num,sz={[0,s]}
  +l.
    s y ({'"$1"'}:y) r. 1,$sz,1,1,0 neq[^-1] . rm. discard 0
    repeat $! if {$>,whds}==0 num={$>+1} break fi done rm
  done u $num

#@cli gcd_parentdir : "path"
#@cli : Return the parent directory path of the specified directory path.
gcd_parentdir :
  if size(['"$1"'])<3 u "$1" return fi
  ('"$1"') replace_str. "\\","/"
  l.
    if i[#-1,h-1]!='/' ('/') a[-2,-1] y fi
    s +,y,47 rm[-2,-1] a y
  done u {t} rm.

#@cli gcd_currentdir : "path"
#@cli : Return the last directory name of the specified directory path.
gcd_currentdir :
  if size(['"$1"'])<2 u "/" return fi
  ('"$1"') replace_str. "\\","/"
  l. s -,y,47 k. done u {t} rm.

#@cli gcd_filelist : "path",_arg1,...,_argN
#@cli : Return the list of files within the specified directory path.
gcd_filelist :
  path="$1" globs=${2--1} num={$#-1}
  repeat $num
    arg {$>+1},$globs glob=${}
    files2img 3,{``$path}$glob
  done a[-$num--1] y

#@cli gcd_resize_for_fs : width,_height,_is_filtered_edge
#@cli : Resize image for fullscreen display.
gcd_resize_for_fs : skip ${1=1920},${2=1080},${3=0},${4=0}
  repeat $! l[$>]
    w,h={[w,h]} mx={[im,iM]}
    if $4
      if $w>=$1" || "$3==0 rs $1,,3 else gcd_upscale_edge {$1/$w},1 fi
    else
      if $h>=$2" || "$3==0 rs ,$2,3 else gcd_upscale_edge {$2/$h},1 fi
    fi
    gcd_noalpha c $mx
  done done

#=============================================

#@gui _

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
