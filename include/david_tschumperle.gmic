#@gmic
#
#  File        : david_tschumperle.gmic
#                ( G'MIC commands file )
#
#  Description : Personal G'MIC filters done by Ronounours and others.
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

average_colors : average_vectors
covariance_colors : covariance_vectors
median_color :
  u {"expr('med(crop(#-1,0,0,0,y,w#-1,h#-1,d#-1,1))',1,3)"}

#@gui _<b>Artistic</b>
#---------------------

#@gui Illustration Look : fx_illustration_look,fx_illustration_look_preview(0)
#@gui : Strength (%) = float(100,0,100)
#@gui : Tone Mapping (%) = float(100,0,100)
#@gui : Desaturate (%) = float(0,0,100)
#@gui : Vintage Tone (%) = float(0,0,100)
#@gui : Output as Multiple Layers = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Authors: <i>Sébastien Guyader</i> and <i>David Tschumperlé</i>.      Latest update: <i>2017/05/01</i>.</small>")
fx_illustration_look :
  foreach {
    nm=${-gui_layer_name}
    to_rgb => base_layer

    # Create processed layers.
    +fx_smooth_anisotropic[base_layer] 20,0.16,0.63,0.6,2.35,0.8,30,2,0,1,1,0,1,24 => blur_layer
    +blend[base_layer,blur_layer] grainextract => detail_layer
    if $3 rgb2hsv[blur_layer] sh[blur_layer] 1 -. {$3%} c. 0,1 rm. hsv2rgb[blur_layer] fi
    if $4 +fx_mix_rgb[blur_layer] 1,10,0,1,0,0,0.7,-10,0,0,10,0 j[blur_layer] .,0,0,0,0,{$4%} rm. fi
    if $2 +fx_map_tones_fast[blur_layer] 20,0.2,11,0 j[blur_layer] .,0,0,0,0,{$2%} rm. fi
    simplelocalcontrast_p[blur_layer] 25,1,50,1,1,1,1,1,1,1,1,1
    +fx_graphic_novelfxl[blur_layer] 1,2,6,5,20,0,1.02857,200,0,1,0.0761905,0.0857143,0,0,0,2,1,1,1,1.25714,0.371429,1.04762 => graphicnovel_layer

    # Order and set layer properties.
    mv[detail_layer] 0 =>[detail_layer] "name("$nm" [Detail]),mode(grainmerge),opacity(100)"
    mv[graphicnovel_layer] 1 =>[graphicnovel_layer] "name("$nm" [Paint]),mode(normal),opacity(50)"
    mv[blur_layer] 2 =>[blur_layer] "name("$nm" [Base]),mode(normal),opacity(100)"
    if $1<100
      mv[base_layer] 0 =>[base_layer] "name("$nm" [Original]),mode(normal),opacity("{round(100-$1)}")"
    else
      rm[base_layer]
    fi
    if !$5
      gui_merge_layers => "name("$nm"),mode(normal),opacity(100)"
    fi
  }

fx_illustration_look_preview :
  gui_split_preview "fx_illustration_look ${1-4},0",$-1

#@gui _<b>Colors</b>
#---------------------

# Color Grading v1.5.3
# Copyright (c) 2012-2014 John Lakkas
# john_lakkas@yahoo.gr
# Licence: GNU GPLv3  ( http://www.gnu.org/licenses/ )

# Convert HSV to RGB triplets.
jl_hsv_to_rgb :
  ({360*$1}^$2^$3) hsv2rgb. u {^} rm.

# LEVELS input low-high gamma output low/high
levels :
  _inplow={int($1)}
  _inphigh={int($2)}
  _gamma=$3
  _outlow={int($4)}
  _outhigh={int($5)}
  _tmp2=""

  if $_gamma!=1
    _tmp2="-apply_gamma "$_gamma
    apply_channels $_tmp2,$6,0
  fi

  _curve1="0,"
  if $_inplow>0
    _tmp1="0,"
    _curve1=$_curve1$_tmp1$_outlow","
  fi
  _curve1=$_curve1$_inplow","$_outlow","$_inphigh","$_outhigh
  if $_inphigh<255
    _curve1=$_curve1",255,"$_outhigh
  fi

  if ['$_curve1']!='0,0,0,255,255'
    _tmp2="-apply_curve "$_curve1
    apply_channels $_tmp2,$6,0
  fi

fx_equalize_s :
  repeat $! l[$>] split_opacity l[0] to_rgb
     rgb2hsv sh 1,1 *. $1 +. $2 c. 0,1 rm. hsv2rgb
  done a c done done

#@gui Color Grading : jl_colorgrading, jl_colorgrading_preview(1)
#@gui : note = note("A filter for basic photo editing and color grading.")
#@gui : note = note("<small><b>Note:</b> Saturation channel gamma affects more the less saturated areas. S-curve contrast, affects shadows and highlights equally. When using noise reduction or sharpening tools, zoom in for more accurate view.</small>")
#@gui : sep = separator()
#@gui : HDR Effect (Tone Map) = float(0.,0.0,1)
#@gui : Cool / Warm = int(0,-50,50)
#@gui : Saturation = float(1,0,2)
#@gui : Saturation Channel Gamma = float(1,0.1,3)
#@gui : note = note("<small><b>Note:</b> Saturation channel gamma may introduce artifacts depending on the image.</small>")
#@gui : sep = separator()
#@gui : S-Curve Contrast = int(0,-30,30)
#@gui : Shadows = int(0,-50,50)
#@gui : Highlights = int(0,-50,50)
#@gui : Blacks = int(0,0,50)
#@gui : Brightness = int(0,-50,50)
#@gui : Contrast = int(0,-50,50)
#@gui : Gamma = float(1,0.1,3)
#@gui : sep = separator()
#@gui : Clarity = float(0,0.0,2.0)
#@gui : Local Contrast Enhance = float(0,0,3)
#@gui : sep = separator()
#@gui : Color Grading = bool(0)
#@gui : Highlights Color Intensity = int(70,0,130)
#@gui : Highlights Hue = int(0,0,360)
#@gui : Highlights Brightness = int(0,-100,100)
#@gui : Midtones Color Intensity = int(0,0,130)
#@gui : Midtones Hue = int(0,0,360)
#@gui : Midtones Brightness = int(0,-100,100)
#@gui : Shadows Color Intensity = int(70,0,130)
#@gui : Shadows Hue Shift = int(180,0,360)
#@gui : Shadows Brightness = int(0,-100,100)
#@gui : note = note("<small><b>Color grading subsection usage:</b> Use intensity sliders to control the amount of color being applied in the highlights/midtones/shadows, use brightness sliders for bringing up or down highlights/midtones/shadows. Hues here follow rotation axis in color wheel ie: 0 or 360 deg is red, 180 is blue it's complimentary. Shadows hue shift in default position uses always the complimentary color of highlights in the shadows. Default sliders for grading apply red highlights and blue shadows effect.</small>")
#@gui : sep = separator()
#@gui : Output Saturation = float(1,0,2)
#@gui : Output Sharpening = float(0,0,10)
#@gui : Output Chroma NR = float(0,0,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>John Lakkas</i>.      Latest update: <i>17/03/2015</i>.</small>")
jl_colorgrading :
  if $1>0.01
    map_tones_fast 5%,$1
  fi
  _ystr=""
  # COLOR MANIPULATION
  # COOL / WARM filter
  if $2>0
  _mymin={$2}
  _mymax={255-$2}
  apply_channels "-apply_curve 0,0,$_mymin,255,255",ycbcr_cr,0
  apply_channels "-apply_curve 0,0,0,255,$_mymax",ycbcr_cb,0
  fi
  if $2<0
  _mymin={-$2}
  _mymax={255+$2}
  apply_channels "-apply_curve 0,0,$_mymin,255,255",ycbcr_cb,0
  apply_channels "-apply_curve 0,0,0,255,$_mymax",ycbcr_cr,0
  fi
  # HSV SATURATION (linear)
  if $3!=1.0
    fx_equalize_s $3,0
  fi
  # HSV SATURATION (gamma)
  if $4!=1.0
  apply_channels "-apply_gamma $4",hsv_s,0
  fi
  # VALUE MANIPULATION
  # S CURVE
  if $5!=0
  _p1={64-$5}
  _p2={192+$5}
  _ystr=$_ystr" apply_curve 1,0,0,64,$_p1,192,$_p2,255,255"
  fi
  # SHADOWS
  if $6!=0
  _p3={64-$6}
  _ystr=$_ystr" apply_curve 1,0,0,64,$_p3,128,128,192,192,255,255"
  fi
  # HIGHLIGHTS
  if $7!=0
  _p4={192+$7}
  _ystr=$_ystr" apply_curve 1,0,0,64,64,128,128,192,$_p4,255,255"
  fi
  # BLACKS
  if $8>0
  _ystr=$_ystr" apply_curve 1,$8,0,64,64,255,255"
  fi
  # BRIGHTNESS
  if $9>0
  _p5=0
  _ystr=$_ystr" apply_curve 0,0,$9,255,255"
  fi
  if $9<0
  _p5={255+$9}
  _ystr=$_ystr" apply_curve 0,0,0,255,$_p5"
  fi
  # CONTRAST
  if $10>0
  _p6=$10
  _p7={255-$10}
  _ystr=$_ystr" apply_curve 0,0,0,$_p6,0,$_p7,255,255,255"
  fi
  if $10<0
  _p6={-$10}
  _p7={255+$10}
  _ystr=$_ystr" apply_curve 0,0,$_p6,255,$_p7"
  fi
  # GAMMA
  if $11!=1.0
  _ystr=$_ystr" apply_gamma $11"
  fi
  # APPLY VALUE PROCESSING
  if '$_ystr'!=0
  apply_channels $_ystr,hsv_v,0
  fi
  # CLARITY (midtones unsharp mask)
  if $12>0
  to_rgb +rgb2hsl s. c rm.. rm.. *. 255 apply_curve. 1,0,0,63,0,127,255,192,0,255,0 +unsharp[0] 5%,$12,0 c. 0,255 c.. 0,255 rv[-1,-2] a[-1,-2] c blend alpha
  fi
   # LOCAL CONTRAST (unsharp mask)
  if $13>0
  unsharp 1%,$13,0
  c. 0,255
  fi
  # COLOR GRADING STEP
  if $14
    if $16+$22>360
      _shh={($16+$22-360)/360}
    else
      _shh={($16+$22)/360}
    fi
    _shs={$21/100}
    _shlev={$23}
    _midh={$19/360}
    _mids={$18/100}
    _midlev={$20}
    _highh={$16/360}
    _highs={$15/100}
    _highlev={$17}
    _satlev={$24}
    color_grade $_shh,$_shs,$_shlev,$_midh,$_mids,$_midlev,$_highh,$_highs,$_highlev,$_satlev
  fi
  # HSV SATURATION (linear)
  if $24!=1.0
    fx_equalize_s $24,0
  fi
  # USM
  if $25>0
    unsharp 0.5,$25
    c 0,255
  fi
  # CHROMA NR
  if $26>0
    apply_channels "-denoise_haar $26",ycbcr_cb,0
    apply_channels "-denoise_haar $26",ycbcr_cr,0
  fi

color_grade :
#convert_to_levels :
      # input:
      # shh, shs, shlev, midh, mids, midlev, highh, highs, highlev, satlev

      _shadownrgb=${-jl_hsv_to_rgb" "$1,1.0,{$2*0.40}}
      _midtonesrgb=${-jl_hsv_to_rgb" "$4,1.0,{$5*0.40}}
      _highlightsrgb=${-jl_hsv_to_rgb" "$7,1.0,{$8*0.40}}

      # make:
      # crsh, mgsh, ybsh, shlev, crmid, mgmid, ybmid, midlev, crhigh, mghigh, ybhigh, highlev, satlev

      _crsh=${-arg" 1,"$_shadownrgb}
      _mgsh=${-arg" 2,"$_shadownrgb}
      _ybsh=${-arg" 3,"$_shadownrgb}
      _shlev=$3

      _crmid=${-arg" 1,"$_midtonesrgb}
      _mgmid=${-arg" 2,"$_midtonesrgb}
      _ybmid=${-arg" 3,"$_midtonesrgb}
      _midlev=$6

      _crhigh=${-arg" 1,"$_highlightsrgb}
      _mghigh=${-arg" 2,"$_highlightsrgb}
      _ybhigh=${-arg" 3,"$_highlightsrgb}
      _highlev=$9

      _satlev=$10
      _lowinred=0
      _hiinred=255
      _lowingreen=0
      _hiingreen=255
      _lowinblue=0
      _hiinblue=255

      _gammared=0.
      _gammagreen=0.
      _gammablue=0.

      _lowoutred=0
      _hioutred=255
      _lowoutgreen=0
      _hioutgreen=255
      _lowoutblue=0
      _hioutblue=255

      #MIDTONES
      if $_crmid>0
         _gammared={$_gammared+0.4*$_crmid/100.}
         _gammagreen={$_gammagreen-0.3*$_crmid/100.}
         _gammablue={$_gammablue-0.3*$_crmid/100.}
      fi
      if $_crmid<0
         _gammared={$_gammared+0.3*$_crmid/100.}
         _gammagreen={$_gammagreen-0.4*$_crmid/100.}
         _gammablue={$_gammablue-0.4*$_crmid/100.}
      fi
      if $_mgmid>0
         _gammared={$_gammared-0.3*$_mgmid/100.}
         _gammagreen={$_gammagreen+0.4*$_mgmid/100.}
         _gammablue={$_gammablue-0.3*$_mgmid/100.}
      fi
      if $_mgmid<0
         _gammared={$_gammared-0.4*$_mgmid/100.}
         _gammagreen={$_gammagreen+0.3*$_mgmid/100.}
         _gammablue={$_gammablue-0.4*$_mgmid/100.}
      fi
      if $_ybmid>0
         _gammared={$_gammared-0.3*$_ybmid/100.}
         _gammagreen={$_gammagreen-0.3*$_ybmid/100.}
         _gammablue={$_gammablue+0.4*$_ybmid/100.}
      fi
      if $_ybmid<0
         _gammared={$_gammared-0.4*$_ybmid/100.}
         _gammagreen={$_gammagreen-0.4*$_ybmid/100.}
         _gammablue={$_gammablue+0.3*$_ybmid/100.}
      fi
      _gammared={$_gammared+1.}
      _gammagreen={$_gammagreen+1.}
      _gammablue={$_gammablue+1.}

      if $_midlev>0
         _gammared={$_gammared+0.4*$_midlev/100.}
         _gammagreen={$_gammagreen+0.4*$_midlev/100.}
         _gammablue={$_gammablue+0.4*$_midlev/100.}
      fi
      if $_midlev<0
         _gammared={$_gammared+0.3*$_midlev/100.}
         _gammagreen={$_gammagreen+0.3*$_midlev/100.}
         _gammablue={$_gammablue+0.3*$_midlev/100.}
      fi
      #SHADOWS
      _crsh={$_crsh*0.3}
      _mgsh={$_mgsh*0.3}
      _ybsh={$_ybsh*0.3}

      if $_crsh>0
         _lowingreen={$_lowingreen+$_crsh}
         _lowinblue={$_lowinblue+$_crsh}
         _lowoutred={$_lowoutred+$_crsh}
      else
         _lowinred={$_lowinred-$_crsh}
         _lowoutgreen={$_lowoutgreen-$_crsh}
         _lowoutblue={$_lowoutblue-$_crsh}
      fi

      if $_mgsh>0
         _lowinred={$_lowinred+$_mgsh}
         _lowinblue={$_lowinblue+$_mgsh}
         _lowoutgreen={$_lowoutgreen+$_mgsh}
      else
         _lowingreen={$_lowingreen-$_mgsh}
         _lowoutred={$_lowoutred-$_mgsh}
         _lowoutblue={$_lowoutblue-$_mgsh}
      fi

      if $_ybsh>0
         _lowinred={$_lowinred+$_ybsh}
         _lowingreen={$_lowingreen+$_ybsh}
         _lowoutblue={$_lowoutblue+$_ybsh}
      else
         _lowinblue={$_lowinblue-$_ybsh}
         _lowoutred={$_lowoutred-$_ybsh}
         _lowoutgreen={$_lowoutgreen-$_ybsh}
      fi
      if $_shlev>0
         _lowoutred={$_lowoutred+$_shlev}
         _lowoutgreen={$_lowoutgreen+$_shlev}
         _lowoutblue={$_lowoutblue+$_shlev}
      fi
      if $_shlev<0
         _lowinred={$_lowinred-$_shlev}
         _lowingreen={$_lowingreen-$_shlev}
         _lowinblue={$_lowinblue-$_shlev}
      fi
      #HIGHLIGHTS
      _crhigh={$_crhigh*0.3}
      _mghigh={$_mghigh*0.3}
      _ybhigh={$_ybhigh*0.3}

      if $_crhigh>0
         _hiinred={$_hiinred-$_crhigh}
         _hioutgreen={$_hioutgreen-$_crhigh}
         _hioutblue={$_hioutgreen-$_crhigh}
      else
         _hiingreen={$_hiingreen+$_crhigh}
         _hiinblue={$_hiinblue+$_crhigh}
         _hioutred={$_hioutred+$_crhigh}
      fi

      if $_mghigh>0
         _hiingreen={$_hiingreen-$_mghigh}
         _hioutred={$_hioutred-$_mghigh}
         _hioutblue={$_hioutblue-$_mghigh}
      else
         _hiinred={$_hiinred+$_mghigh}
         _hiinblue={$_hiinblue+$_mghigh}
         _hioutgreen={$_hioutgreen+$_mghigh}
      fi

      if $_ybhigh>0
         _hiinblue={$_hiinblue-$_ybhigh}
         _hioutred={$_hioutred-$_ybhigh}
         _hioutgreen={$_hioutgreen-$_ybhigh}
      else
         _hiinred={$_hiinred+$_ybhigh}
         _hiingreen={$_hiingreen+$_ybhigh}
         _hioutblue={$_hioutblue+$_ybhigh}
      fi

      if $_highlev>0
         _hiinred={$_hiinred-$_highlev}
         _hiingreen={$_hiingreen-$_highlev}
         _hiinblue={$_hiinblue-$_highlev}
      fi
      if $_highlev<0
         _hioutred={$_hioutred+$_highlev}
         _hioutgreen={$_hioutgreen+$_highlev}
         _hioutblue={$_hioutblue+$_highlev}
      fi

      levels $_lowinred,$_hiinred,$_gammared,$_lowoutred,$_hioutred,19
      levels $_lowingreen,$_hiingreen,$_gammagreen,$_lowoutgreen,$_hioutgreen,20
      levels $_lowinblue,$_hiinblue,$_gammablue,$_lowoutblue,$_hioutblue,21

jl_colorgrading_preview :
  gui_split_preview "-jl_colorgrading $*",$-1

#@gui _<b>Testing</b>
#---------------------

#@gui <i>Chris From Pixls.Us</i>

#@gui Remove Scratches : fx_remove_scratches, fx_remove_scratches_preview(0)
#@gui : note = note("<small><b>Note:</b> Scratch removal for scanned film images</small>")
#@gui : sep = separator()
#@gui : Threshold = float(72,0,100)
#@gui : Erosion = int(2,0,5)
#@gui : Dilation = int(4,0,7)
#@gui : Show Preview After = choice(3,"Threshold","Erosion","Dilation","Final image")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Chris/Pixls.us</i>.      Latest update: <i>2017/04/01</i>.</small>")
_fx_remove_scratches :
  repeat $! l[$>] to_rgba
    sh 0,2
    sh.. 3
    <. {$1*255%}
    if $4>=1 erode. $2 fi
    if $4>=2 dilate. $3 fi
    if $4<3 k... channels 3 * 255
    else inpaint_matchpatch.. . k... channels 0,2
    fi
  done done

fx_remove_scratches :
  _fx_remove_scratches ${1-3},3

fx_remove_scratches_preview :
  gui_split_preview "_fx_remove_scratches $*",$-1

#@gui _<i>Deprecated</i>

#@gui Morphological Filter (Deprecated) : fx_morpho, fx_morpho_preview(0)
#@gui : Action = choice("Erosion","Dilation","Opening","Closing",
#@gui : "Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gui : Size = int(5,2,60)
#@gui : Negative = bool()
#@gui : Shape = choice(0,"Square","Octagonal","Circular")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Stretch")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2014/06/08</i>.</small>")
fx_morpho :
  ac "__fx_morpho ${^0}",$5,$6

fx_morpho_preview :
  gui_split_preview "fx_morpho ${^0}",$-1

__fx_morpho :
  if $4==1 suf="_oct" elif $4==0 suf="" else suf="_circ" fi
  if $1==0 erode$suf $2
  elif $1==1 dilate$suf $2
  elif $1==2 erode$suf $2 dilate$suf $2
  elif $1==3 dilate$suf $2 erode$suf $2
  elif $1==4 repeat $! +erode$suf $2 -[-2,-1] mv. 0 done
  elif $1==5 repeat $! +dilate$suf $2 rv[-2,-1] -[-2,-1] mv. 0 done
  elif $1==6 repeat $! +erode$suf $2 dilate$suf. $2 -[-2,-1] mv. 0 done
  else repeat $! +dilate$suf $2 erode$suf. $2 rv[-2,-1] -[-2,-1] mv. 0 done
  fi
  if $3 repeat $! l[$>] split_opacity negate[0] a c done done fi

##########################################################

#@gui _<i>Corvo</i>

#@gui Corvo's Painting_5 : fx_corvo_painting_5, fx_corvo_painting_5(0)
#@gui : note = note("Polygonize settings")
#@gui : Amplitude = int(35,0,2000)
#@gui : Smoothness = float(10,0,100)
#@gui : Minimal Area = float(10,0,100)
#@gui : Alpha Polygonize = float(0.5,0,1)
#@gui : sep = separator()
#@gui : Texture = float(50,0,100)
#@gui : Plasma = float(0.3,0,1)
#@gui : sep = separator()
#@gui : note = note("Smooth settings")
#@gui : Amplitude = float(50,0,1000)
#@gui : Gradient Smoothness = float(2,0,10)
#@gui : Tensor Smoothness = float(5,0,10)
#@gui : Alpha Filter= float(1,0,1)
fx_corvo_painting_5 :
+polygonize $1,$2,$3,10,10
+blend[0,1] alpha,$4
-texturize_canvas[2] $5,0.5,0.6
-smooth[2] $7,0.4,0.7,$8,$9
+plasma[2] 0.7,100,8 n 0,255
-blend[3,2] grainmerge,$6
-bilateral[0,2] 10,7
-blend[0,2] alpha,$10
rm.

##########################################################

#@gui _<i>Lylejk</i>

#@gui Lylejk's Stencil : fx_lylejk_stencil, fx_lylejk_stencil(0)
#@gui : Amplitude = int(5,1,10)
#@gui : Sharpness = float(10,0,100)
#@gui : Radius = float(3,0,10)
#@gui : Channel(s) = choice("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), note = note("<small>Authors: <i>Lyle Kroll, David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_lylejk_stencil :
  apply_channels "repeat $1 b $3 unsharp $3,$2 c 0,255 mv. 0 done",$4,0

#@gui Blend [Shape Average] : fx_blend_shapeaverage, fx_blend_shapeaverage(0)
#@gui : Preserve Shading = bool(1)
#@gui : Transparency = bool(0)
#@gui : Revert Layers = bool(0)
#@gui : note = note{"<small><b>Note:</b>
#@gui : This filter needs two layers to work properly. Set the <i>Input layers</i> option to handle multiple input layers.
#@gui : </small>"}
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2011/19/10</i>.</small>")
fx_blend_shapeaverage :
  if ${3=0} _fx_revert_layers fi
  to_rgb
  repeat int($!/2)
    rv[-2,-1]
    if $1 i[0] . fi
    blend[-2,-1] shapeaverage0
    if $1 *[0,-1] /[0] 255 mv[0] $! fi
    if $2 to_rgba. replace_color. 0,0,0,0,0,255,0,0,0,0 fi
  mv. 0 done

#@gui _<i>RL</i>

#@gui RandomWaves : randomwaves, randomwaves
#@gui : Steps Number = int(84,1,1000)
#@gui : Probability of Impulse (% / Step) = float(80.,1.,100.)
#@gui : Lessening = float(1.2,0.01,10.)
#@gui : Random Initialization = int(42,1,100)
#@gui : sep = separator(), note = note("<small>Authors: <i>Jean-Baptiste Rolland, Julien Levillain</i>.      Latest update: <i>2013/28/03</i>.</small>")
randomwaves : check  "isint(${1=84}) && ${2=80}>=0 && $2<=100 && ${3=1.2}>0. && isint(${4=42})"
  srand $4
  (0,1,0;1,0,1;0,1,0) /. 2
  => matconv
  {0,w},{0,h},1,1 set. 255,{u(100)}%,{u(100)}%
  .
  repeat $1
    .
    if ${2}>=u(100)
      circle. {u(100)}%,{u(100)}%,{u(3)},,255
    fi
    convolve. [matconv] /. $3 -. ...
    rm...
  done
  rm[-2,matconv]
  g. a[-1,-2] c -warp[0] .,1 rm.

#@gui Plasma Transition : plasma_transition, plasma_transition
#@gui : Balance = float(0.5,0,1)
#@gui : Scale = int(5,0,50)
#@gui : Smoothness = float(1,0,10)
#@gui : Random Initialization = int(42,1,100)
#@gui : sep = separator(), note = note("<small>Authors: <i>Jean-Baptiste Rolland, Julien Levillain</i>.      Latest update: <i>2013/28/03</i>.</small>")
plasma_transition: check "isint(${4=42}) && isint(${2=5}) && ${1=0.5}>=0  && $1<=1 && $2>=0 && ${3=1}>=0"
  repeat int($!/2)
    local[{$>},{$>+1}]
      if $!<2 return fi
      r ${-max_whds},3
      100%,100% srand $4 plasma. 1,0,$2 n. 0,1
      +<=. $1 b. $3
      rm..
      j... ..,0,0,0,0,1,.
      k...
    done
  done

##########################################################

#@gui _<i>Okyl168</i>

#@gui Jobs Colors : fx_jobs_colors, fx_jobs_colors_preview
#@gui : Gamma = float(0,-2,2)
#@gui : Equalize = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>Oberon Leung</i>.      Latest update: <i>2014/25/01</i>.</small>")
fx_jobs_colors :
  n 0,255 if $2 equalize 256 fi
  luminance apply_gamma {10^$1} n 0,9 round
  (22,187,20,36,235,240,245,243,247,209^18,97,147,157,79,110,121,142,170,200^19,158,192,60,67,65,64,64,64,185)
  map[^-1] . rm.

fx_jobs_colors_preview :
  gui_split_preview "fx_jobs_colors $*",$-1

##########################################################

#@gui _<i>Telperion</i>

# ---------------------------------- v 2.2

# ---------------------------------- v 1.1
#@gui Mc_Flou : mc_flou, mc_flou_preview
#@gui : sep = separator()
#@gui : Sharp = float(30,10,400)
#@gui : Blur = float(6,3,20)
#@gui : Blend = float(1,0,1)
#@gui : sep = separator() ,note = note("Base image adjustement:")
#@gui : Skip = bool(true)
#@gui : Gamma = float(1,0.2,2)
#@gui : Value Min = int(0,0,127)
#@gui : Value Max = int(255,128,255)
#@gui : Gamma R = float(1,0.2,2)
#@gui : Gamma G = float(1,0.2,2)
#@gui : Gamma B = float(1,0.2,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator() ,note = note("Apply a flou effect with edges protection. v.1.1")

mc_flou:
  # base image value corrections
  if $4==0
    to_rgb
    apply_gamma[0] $5
    c[0] $6,$7 n[0] 0,255    # min max val
    s[0] c
    apply_gamma[0] $8
    apply_gamma[1] $9
    apply_gamma[2] $10
    a[0,1,2] c
  fi
  # -----
  # flou
  +fx_gradient_norm[0] 0,1.5,0,50.38,1,0
  sharpen[0] $1 #30
  b[1] 0.5
  n[1] 0,255
  equalize[1] 4,0%,98%
  +a[0,1] c
  b[2] $2 #10
  blend[0,2] alpha,$3
  remove_opacity[0]
  k[0]

mc_flou_preview:
  gui_split_preview "-mc_flou $*",$-1
# ------------------------------------------

#@gui Mc_Pendraw : mc_pendraw, mc_pendraw_preview
#@gui : sep = separator()
#@gui : Amplitude = float(8,0,30)
#@gui : Blur = float(0.8,0.1,2)
#@gui : Sharp = float(450,100,2000)
#@gui : Color = int(21,4,256)
#@gui : Dithering = float(0.5,0,1)
#@gui : Value = float(1,0,1)
#@gui : Mode 2 = bool(false)
#@gui : Color Equal. = bool(false)
#@gui : Equal. Limit = int(255,100,255)
#@gui : sep = separator()
#@gui : Lowers Contrast = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
mc_pendraw:
  repeat $! l[$>]
  split_opacity
  l[0]
  to_rgb
  # contrast mask
  if $10>0
    [0]
    b[0] 1
    negate[0]
    luminance[0]
    rv[0,1]
    blend[0,1] overlay,$10
  fi
  # pendraw
  +fx_gradient_norm[0] 0,1.5,0,50.38,1,0
  [0]
  smooth $1,0.2,1,3,3
  b $2
  sharpen $3
  [0]
  r[0] 20,20,1,3,2
  equalize[0] 256,0%,98%
  index[3] [0],1,1
  rm[0]
  # --
  =>[0] linee
  =>[1] orig
  =>[2] pen
  if $7==0
    rv[pen,linee]
    blend[pen,linee] multiply,1
  elif $7==1
    rv[orig,linee]
    blend[orig,linee] multiply,1
  fi
  n[0] 5,250
  autoindex[0] $4,$5
  rv[0,1]
  blend[0,1] value,$6
  if $8==1
    equalize 21,30,$9
  fi
  done a c done done

mc_pendraw_preview:
  gui_split_preview "-mc_pendraw $*",$-1

##########################################################

#@gui _<i>Ronounours</i>

#@gui Friends Hall of Fame : _none_, fx_friends
#@gui : note = note{"\n<span foreground="purple" underline="single">Supporters:</span>"}
#@gui : note = note{" <b>-</b> A big hug goes to these friends who supported the project:"}
#@gui : note = note{"<i>
#@gui : Christian Stenner,
#@gui : Daniel Balle,
#@gui : Matthias Fuchs,
#@gui : <a href="https://www.augustus5star.fr/">Alban Bourrat</a>,
#@gui : <a href="http://viewbug.com/photo/65310796">Elizabeth Hayman</a>,
#@gui : Nicolas Künzler,
#@gui : Mikael Wargh,
#@gui : Giovanni Bianchessi,
#@gui : Job van der Zwan,
#@gui : <a href="http://espitallier.net/">Laurent Espitallier</a>,
#@gui : Mark van der Grijp,
#@gui : Patrick Wauters,
#@gui : <a href="https://pocketvj.com">Marc-André Gasser</a>,
#@gui : <a href="http://www.flickr.com/photos/ssshupe/">Steven Shupe</a>,
#@gui : Mika Yrjölä,
#@gui : <a href="https://www.silviogrosso.com/">Silvio Grosso</a>,
#@gui : Marek Kubica,
#@gui : <a href="http://www.flickr.com/newmikey">Mike Bing</a>,
#@gui : <a href="http://pixby.com/">Dave Allen</a>,
#@gui : Margaret Wong,
#@gui : Adrian Bottomley,
#@gui : Pamela Young,
#@gui : <a href="http://chrisbowness.com/">Chris Bowness</a>,
#@gui : Peter Howarth,
#@gui : Marlon Montalvo,
#@gui : Christian Freiherr von Malchus,
#@gui : Nolan Tyrrell,
#@gui : Gilles Bouquerel,
#@gui : Mihail Balabanov,
#@gui : Rolf Niepraschk,
#@gui : Volkmar Geske,
#@gui : Menno Tjoelker,
#@gui : <a href="https://borkarabhijeet05.blogspot.com/p/about-me.html">Abhijeet Borkar</a>,
#@gui : <a href="https://www.behance.net/kontaktarl1e0a">Arleta Lesniewska</a>,
#@gui : Nicola Giaccobe,
#@gui : Helmut Mühleisen,
#@gui : Paul Buckley,
#@gui : Olivier Lecarme,
#@gui : Edward Ingram,
#@gui : <a href="http://www.gus-verlag.de/verlag/Artelier/">Stefan Städtler-Ley</a>,
#@gui : Michel Pastor,
#@gui : Sz.U,
#@gui : Sven Kraft,
#@gui : Frederik Elwert,
#@gui : Jessica Leonard,
#@gui : <a href="https://www.viewbug.com/member/KennZaney">Kenneth Simons</a>,
#@gui : <a href="https://www.flickr.com/photos/114936163@N05/">Milos Ciuk</a>,
#@gui : Manlio Barolo,
#@gui : John Lewandowski,
#@gui : <a href="http://mediaklan.com/">Didier Lima</a>,
#@gui : Žygimantas Tauras,
#@gui : Massimo Ferri,
#@gui : <a href="https://github.com/sina-ht">Hiroshi Takekawa</a>,
#@gui : Freelance writer,
#@gui : <a href="https://www.flickr.com/photos/49284009@N04/">Elaine Hutchings</a>,
#@gui : András Somogyi,
#@gui : <a href="https://www.flickr.com/photos/tonurics">Jason Dora</a>,
#@gui : Boris Hajdukovic,
#@gui : <a href="https://mappish.com/pages/about-us">Jeff Combs / Mappish</a>,
#@gui : <a href="http://flickr.com/photos/btraven">BTraven</a>,
#@gui : <a href="https://500px.com/spodeworld">Steven Brener</a>,
#@gui : Susanne Gabrielski,
#@gui : Andrea Correani,
#@gui : Mads Thomsen,
#@gui : Djek Eykhout,
#@gui : Michael Calabrese,
#@gui : Joachim Steiert
#@gui : Christian Dubettier,
#@gui : J. Casseur,
#@gui : <a href="http://www.gnomelibre.fr/">Okki</a>,
#@gui : Dariusz Duma,
#@gui : <a href="http://www.mahvin.com/">Mahvin</a>,
#@gui : Elleen Hennessy,
#@gui : BluffStuffPlus,
#@gui : <a href="http://www.bertrandchan.eu">Bertrand Chan</a>,
#@gui : Mirella Scotto,
#@gui : <a href="http://www.photopablo.com">Paul Sauve</a>,
#@gui : <a href="https://darktablemaster.de">Lars Mielke</a>,
#@gui : Devin Sorell,
#@gui : <a href="http://www.quesepuedehacerenlinux.net">Pepe Baeza</a>,
#@gui : <a href=" http://www.lesnoy-tanets.com">Andrey Pivovarova</a>,
#@gui : <a href="http://doliver.co.uk/">David Oliver</a>,
#@gui : <a href="https://ello.co/errore">errore</a>,
#@gui : <a href="http://www.anudai.de">Anudai</a>,
#@gui : James Stalnaker,
#@gui : <a href="https://plus.google.com/u/0/b/117441237982283011318/112547676857320288448/about">Paolo Finetti</a>,
#@gui : Luigi Scarselli,
#@gui : <a href="https://patdavid.net/">Pat David</a>,
#@gui : Juan Jose Rodriguez Vela,
#@gui : Thomas Jakob,
#@gui : Kim Bartholomew,
#@gui : <a href="http://www.captivemoment.com">Sudi</a>,
#@gui : Michael Prostka,
#@gui : Arkadi Gelfond,
#@gui : <a href="https://joeysl.wordpress.com/">Sabine Schäfers</a>,
#@gui : <a href="http://www.viewbug.com/member/KennZaney">Bull O'Woods</a>,
#@gui : Jost Jakob Schaper,
#@gui : Dominik Wefers,
#@gui : Frank McLaughlin,
#@gui : <a href="https://29a.ch/">Jonas Wagner</a>,
#@gui : <a href="www.ixaarii.com">Void lon iXaarii</a>,
#@gui : Mark Boadey,
#@gui : Laura Haglund,
#@gui : Lee Elliott,
#@gui : Bernard Desenclos,
#@gui : Randy Gordon-Gilmore,
#@gui : Eddie Dedrick,
#@gui : <a href="http://mindprints.org/">Greg FitzPatrick</a>,
#@gui : Zsolt Szabo,
#@gui : Daniel Hanna,
#@gui : Peter Bengtsson,
#@gui : Diego Nassetti,
#@gui : William Tweedy,
#@gui : Shawnee Horn,
#@gui : Stephan Munsch,
#@gui : <a href="http://www.mysticali3n-wear.com">MysticAli3n-Wear</a>,
#@gui : Mika Mantere,
#@gui : Christian Beuschel,
#@gui : Tore Busch,
#@gui : Douc McGregor.
#@gui : Marcel Dahm,
#@gui : Susan Voitel,
#@gui : <a href="https://www.flickr.com/photos/henkkoning">Henk Koning</a>,
#@gui : Arnie Jordan,
#@gui : Carol Jennings,
#@gui : Sébastien Huart,
#@gui : <a href="http://www.jessstryker.com/">Jess Stryker</a>,
#@gui : Rui Luis,
#@gui : <a href="https://www.flickr.com/photos/sallesrenato/">Renato Salles</a>,
#@gui : <a href="http://www.viewbug.com/member/alef0"> Petr Zagalak</a>,
#@gui : <a href="http://www.antonio.cat">Antonio Vicién Faure</a>,
#@gui : Vincent Bermel,
#@gui : Christian Stocco,
#@gui : <a href="https://www.flickr.com/photos/136307651@N04/">Richard Benedict</a>,
#@gui : Dr. Helmut Jarausch,
#@gui : <a href="http://www.michaeljamesbeck.com">Michael Beck</a>,
#@gui : <a href="http://rickleone.tumblr.com/">Riccardo Leone</a>,
#@gui : Gisela Looram,
#@gui : <a href="https://plus.google.com/u/0/+FrankTegtmeyer/posts">Frank Tegtmeyer</a>,
#@gui : David Kettrey,
#@gui : <a href="https://www.youtube.com/user/kncpt1">Peter Hoge</a>,
#@gui : Alexander Heitmann,
#@gui : <a href="http://harlequin.webcomics.fr/page/episode-1-page-1">Olivier Larski</a>,
#@gui : <a href="http://victorfandrey.blogspot.ca">Victor Fandrey</a>,
#@gui : Stefan Peter,
#@gui : <a href="https://plus.google.com/u/0/+DimitriosPsychogios">Dimitrios Psychogios</a>,
#@gui : <a href="https://plus.google.com/+AnttiLuoma">Antti Luoma</a>,
#@gui : <a href="https://twitter.com/jeyoung">Eddy Young Tie Yang</a>,
#@gui : Thomas Elfstrom,
#@gui : Valentine Boyce,
#@gui : George Harnett,
#@gui : Darius Manka,
#@gui : Chris Knox,
#@gui : <a href="http://tomtappingphotoblog.blogspot.fr/">Thomas Tapping</a>,
#@gui : Phillip R Ziesemer,
#@gui : Jean Francois.
#@gui : Franz Ziereis,
#@gui : Alessandro Renzi,
#@gui : Tsuda Koshi,
#@gui : <a href="http://www.boxrec.com">Boxrec Ltd</a>,
#@gui : <a href="http://www.wolfgangschweizer.com/">Wolfgang Schweizer</a>,
#@gui : <a href="http://www.ramonmiranda.com/">Ramon Miranda</a>,
#@gui : Volker Bradley,
#@gui : <a href="http://plus.google.com/+MarcoZara">Marco Zara</a>,
#@gui : <a href="http://plus.google.com/+MarcoTedaldi">Marco Tedaldi</a>,
#@gui : <a href="http://cybertographer.com">Rodney Lee</a>,
#@gui : Konstantinos Blatzonis,
#@gui : Simon Chanson,
#@gui : Herbert Malle,
#@gui : <a href="http://www.matthias-zepper.de/">Matthias Zepper</a>,
#@gui : Christian Mariucci,
#@gui : M. R.,
#@gui : Mark Link,
#@gui : <a href="http://blog.meetthegimp.org/">Rolf Steinort</a>,
#@gui : <a href="https://plus.google.com/112357088505488756823/posts">Daniel Tauro</a>,
#@gui : <a href="http://geniisoft.com/">Ben Langhinrichs</a>,
#@gui : <a href="http://www.openlabs.it/">Paolo Pedaletti</a>,
#@gui : <a href="http://blog.photomontager.com">Ricardo Corin</a>,
#@gui : <a href="https://plus.google.com/115953666279509959258">James Prichard</a>,
#@gui : <a href="https://plus.google.com/116658221461047313647">Matt Jones</a>,
#@gui : <a href="http://www.flickr.com/people/twekkel/">Eddy Vervest</a>,
#@gui : <a href="http://www.flaviocdc.net/wiki/">Flavio Casadei Della Chiesa</a>,
#@gui : <a href="http://www.artwanted.com/artist.cfm?artid=10918">Lyle Kroll</a>.
#@gui : </i>"}
#@gui : sep = separator()
#@gui : note = note{"\n<span foreground="purple" underline="single">Postcard senders:</span>"}
#@gui : note = note{" <b>-</b> We've received <b>46</b> postcards from <b>G'MIC</b> enthusiasts so far.
#@gui :               You could be the <b>47rd</b> sender :)"}
#@gui : note = note{" <b>-</b> A big hug goes to these postcard senders (recently received first) :"}
#@gui : note = note{"<i>
#@gui : <a href="https://cimg.eu/img/postcard73.jpg">Benjamin Russell</a> (Portsmouth/USA),
#@gui : <a href="https://cimg.eu/img/postcard72.jpg">Andreas Weissenburger</a> (Bochum/Germany),
#@gui : <a href="https://cimg.eu/img/postcard70.jpg">Patrick Wanters</a> (USA),
#@gui : <a href="https://cimg.eu/img/postcard69.jpg">Josep Febrer</a> (Pregonda/Menorca),
#@gui : <a href="https://cimg.eu/img/postcard68.jpg">Richard Gledson</a> (Newcastle upon tyne/England),
#@gui : <a href="https://cimg.eu/img/postcard67.jpg">James Jaworski</a> (Winnipeg/Canada),
#@gui : <a href="https://cimg.eu/img/postcard66.jpg">Powlux</a> (France),
#@gui : <a href="https://cimg.eu/img/postcard65.jpg">Volker Doebel</a> (Haldern/Germany),
#@gui : <a href="https://cimg.eu/img/postcard64.jpg">Patrick Wauters</a> (Bilbao/Spain),
#@gui : <a href="https://cimg.eu/img/postcard63.jpg">Sebastien Fourey</a> (Konstanz/Germany),
#@gui : <a href="https://cimg.eu/img/postcard62.jpg">David Revoy</a> (Toulouse/France),
#@gui : <a href="https://cimg.eu/img/postcard61.jpg">Giulio Canevari</a> (Pavia/Italy),
#@gui : <a href="https://cimg.eu/img/postcard60.jpg">Bruno Steinbach</a> (Pondicherry/India),
#@gui : <a href="https://cimg.eu/img/postcard59.jpg">Steve Gillow</a> (Fort Worth/Texas/USA),
#@gui : <a href="https://cimg.eu/img/postcard58.jpg">Peter Neave</a> (Sydney/Australia),
#@gui : <a href="https://cimg.eu/img/postcard57.jpg">Andrea [Photoflow]</a> (Italy),
#@gui : <a href="https://cimg.eu/img/postcard56.jpg">Garry R. Osgood</a> (New York/USA),
#@gui : <a href="https://cimg.eu/img/postcard55.jpg">Justin Pletzfeld</a> (Germany),
#@gui : <a href="https://cimg.eu/img/postcard54.jpg">Werner Meier</a> (Germany),
#@gui : <a href="https://cimg.eu/img/postcard53.jpg">Patrick Wauters</a> (Roma/Italy),
#@gui : <a href="https://cimg.eu/img/postcard52.jpg">Marc Lis</a> (Belgium),
#@gui : <a href="https://cimg.eu/img/postcard51.jpg">ZondeR</a> (France),
#@gui : <a href="https://cimg.eu/img/postcard50.jpg">Bill C.</a> (USA),
#@gui : <a href="https://cimg.eu/img/postcard49.jpg">Michael T.</a> (France),
#@gui : <a href="https://cimg.eu/img/postcard48.jpg">Patrick Wauters</a> (Lisboa),
#@gui : <a href="https://cimg.eu/img/postcard47.jpg">Akky [Gimpchat]</a> (Australia),
#@gui : <a href="https://cimg.eu/img/postcard45.jpg">Michel Thomas</a> (Germany),
#@gui : <a href="https://cimg.eu/img/postcard44.jpg">Pierre-Yves</a> (Ile de Batz/France),
#@gui : <a href="https://cimg.eu/img/postcard43.jpg">Family Hamacher</a> (Trier/Germany),
#@gui : <a href="https://cimg.eu/img/postcard41.jpg">Benoit Gauzere and Francois Lozes</a> (Hokusai/Japan),
#@gui : <a href="https://cimg.eu/img/postcard40.jpg">Dr. Rainer Teubner</a> (Seligenstadt/Germany),
#@gui : <a href="https://cimg.eu/img/postcard39.jpg">Mauro Mitrino</a> (Mantova/Italy),
#@gui : <a href="https://cimg.eu/img/postcard37.jpg">Werner Meier</a> (Mettlach/Germany),
#@gui : <a href="https://cimg.eu/img/postcard36.jpg">Arto Huotari</a> (Helsinki/Finland),
#@gui : <a href="https://cimg.eu/img/postcard33.jpg">Benoit Gauzere</a> (California/USA),
#@gui : <a href="https://cimg.eu/img/postcard30.jpg">Arkadi Gelfond</a> (Foster City - California/USA),
#@gui : <a href="https://cimg.eu/img/postcard29.jpg">Corinne Masimann</a> (Neuchatel/Switzerland),
#@gui : <a href="https://cimg.eu/img/postcard27.jpg">Mahvin</a> (Portland/USA),
#@gui : <a href="https://cimg.eu/img/postcard26.jpg">Vincent Roullier</a> (Caen/France),
#@gui : <a href="https://cimg.eu/img/postcard24.jpg">M????</a> (Munich/Germany),
#@gui : <a href="https://cimg.eu/img/postcard23.jpg">F. Albior</a> (Jaca/Spain),
#@gui : <a href="https://cimg.eu/img/postcard22.jpg">PhotoComIX</a> (Frascati/Italy),
#@gui : <a href="https://cimg.eu/img/postcard21.jpg">Guy Poizat</a> (Cabestany/France),
#@gui : <a href="https://cimg.eu/img/postcard20.jpg">Institut for Biomathematik und Biometrie</a> (Neuherberg/Germany),
#@gui : <a href="https://cimg.eu/img/postcard15.jpg">Jean-Michel Webbe</a> (Guadeloupe/France),
#@gui : <a href="https://cimg.eu/img/postcard14.jpg">Jaime</a> (Barcelona/Spain).
#@gui : </i>"}
#@gui : sep = separator()
#@gui : note = note{"\nMay the force be with you!"}
fx_friends :
  if $! ratio:=w/h else ratio=1 fi
  rm _heart80x73 scale3x r 150%,150%,1,1,0,0,0.5,0.5
  +*. 70 +*.. 110 +*... 255 *[-4] 255 a c
  blur_radial 4 sharpen 300
  i.. ${fitratio_wh\ {w},{h},$ratio},1,3
  rand.. 0,255 sh.. 1,2 /. 2 rm.
  blur_radial.. 20 sharpen.. 50
  r. ..,..,1,4,0,0,0.5,0.5 blend alpha
  143,80,1,1,0 t. "Greetings to\n  all G\47MIC\n  friends!",2,-2,27,1,1
  +dilate. 3 *.. 255 to_rgb.. j... ..,{[w#-3-w#-2,h#-3-h#-2]/2},0,0,1,.
  rm[-2,-1]

_heart80x73 :
  40,73,1,1,0 ellipse 22,22,20,20,0,1,1 polygon 3,7,37,42,72,42,27,1,1 +mirror x a x

#@gui Contributors : _none_, _none_
#@gui : note = note{"
#@gui : We would like to thank all these people who contributed to <b>G'MIC</b> in one way or another.
#@gui : A big hug to : \n\n
#@gui : <b> -</b> <i>Sylvie Alexandre</i> <small>(packaging, testing & filters)</small>
#@gui : <b> -</b> <i>Partha Bagchi</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Daniel P. Berrangé</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Sébastien Bougleux</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Jérome Boulanger</i> <small>(testing & code)</small>
#@gui : <b> -</b> <i>Claude Bulin</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Aurélien Ceyden</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>François Collard</i> <small>(testing)</small>
#@gui : <b> -</b> <i>Patrick David</i> <small>(testing & filters)</small>
#@gui : <b> -</b> <i>Maxime Daisy</i> <small>(code & testing)</small>
#@gui : <b> -</b> <i>Frédéric Devernay</i> <small>(code)</small>
#@gui : <b> -</b> <i>Iain Fergusson</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Tobias Fleischer</i> <small>(testing & code)</small>
#@gui : <b> -</b> <i>Roberto Ferramosca</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Jérome Ferrari</i> <small>(testing, code & tutorials)</small>
#@gui : <b> -</b> <i>Andrea Ferrero</i> <small>(testing, code)</small>
#@gui : <b> -</b> <i>Chris Fiedler</i> <small>(gfx)</small>
#@gui : <b> -</b> <i>Sébastien Fourey</i> <small>(G'MIC-Qt, ZArt code & G'MIC online)</small>
#@gui : <b> -</b> <i>Gentlemanbeggar</i> <small>(filters)</small>
#@gui : <b> -</b> <i>David Gowers</i> <small>(testing)</small>
#@gui : <b> -</b> <i>Claes Holmerson</i> <small>(tutorials)</small>
#@gui : <b> -</b> <i>Arto Huotari</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Dan Leinir Turthra Jensen</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Tom Keil</i> <small>(testing, filters & tutorials)</small>
#@gui : <b> -</b> <i>Andy Kelday</i> <small>(testing & filters)</small>
#@gui : <b> -</b> <i>Alan Kwan</i> (afre) <small>(testing & filters)</small>
#@gui : <b> -</b> <i>Angelo Lama</i> <small>(testing & EKD integration)</small>
#@gui : <b> -</b> <i>John Lakkas</i> <small>(filters)</small>
#@gui : <b> -</b> <i>Stéphane de la Linuxerie</i> <small>(design)</small>
#@gui : <b> -</b> <i>Mark</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Mahvin</i> <small>(testing & design)</small>
#@gui : <b> -</b> <i>MareroQ</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Ramon Miranda</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Tou Omiya</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Mauro Quercia</i> <small>(translation)</small>
#@gui : <b> -</b> <i>PhotoComiX</i> <small>(testing, translation & filters)</small>
#@gui : <b> -</b> <i>Garry Osgood</i> <small>(documentation & filters)</small>
#@gui : <b> -</b> <i>Jehan Pages</i> <small>(testing & code)</small>
#@gui : <b> -</b> <i>Andreas Påhlsson</i> <small>(filters)</small>
#@gui : <b> -</b> <i>James Prichard</i> <small>(testing & filters)</small>
#@gui : <b> -</b> <i>Guilherme Razgriz</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Karsten Rodenacker</i> <small>(packaging & code)</small>
#@gui : <b> -</b> <i>Marc Roovers</i> <small>(clut data)</small>
#@gui : <b> -</b> <i>Dani Sardà</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Yuri Shemanin</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Silvio Grosso</i> <small>(debugging)</small>
#@gui : <b> -</b> <i>Stepanekos</i> <small>(translation)</small>
#@gui : <b> -</b> <i>Thorsten "otto" Stettin</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Lukas Tvrdy</i> <small>(Krita integration)</small>
#@gui : <b> -</b> <i>Martin Wolff</i> <small>(testing & filters)</small>
#@gui : <b> -</b> <i>Bernd Zeimetz</i> <small>(packaging)</small>
#@gui : <b> -</b> <i>Matthias Zepper</i> <small>(testing)</small>
#@gui : <b> -</b>"}

#@gui Krita Helper : fx_krita, fx_krita
fx_krita :
  text="Krita helper:\n"\
       "Image size = "{w}x{h}x{d}x{s}"\n"\
       "Minimal value = "{im}"\n"\
       "Maximal value = "{iM}"\n"\
       "Average value = "{_round(ia,0.1)}"\n\n\n"\
       "* We love Krita! *"
  n 0,255 drgba r 512,512,1,3
  to $text,3,3,5%

#_gui_filter_sources : skip ${1=0}
  # ok_host={['$_host']!='gimp_qt'" && "['$_host']!='krita'" && "['$_host']!='standalone'}
  # ok_host=0
  # file_hc=${_path_rc}hc.gmic
  # if $file_hc # File exist
  #   i raw:$file_hc,uchar c={i[1]} rm.
  #   if $c==126 # Filter already displayed : discard it
  #     if !$1 (35,33) o. raw:{/$file_hc},uchar rm. fi
  #   elif $ok_host
  #     is_too_old={"Y = date(0); M = date(1); D = date(2); date_current = Y*365 + M*31 + D;
  #                  Y = date(0,"$file_hc"); M = date(1,"$file_hc"); D = date(2,"$file_hc"); date_file = Y*365 + M*31 + D;
  #                  delta = date_current - date_file;
  #                  "$c">=125 || ("$c"==32 && delta>12) || ("$c">32 && delta>45 && (delta<60 || delta>200))"}
  #     if $is_too_old
  #       ({'"\#~"\n\
  #          "\#@gui !<span color=\"red\">&#x2764; <b>One-click chocolate !</b></span> : _none_, fx_friends"\n\
  #          "\#@gui : note = note{\"Want to send a <b>free hot chocolate</b> to the <b>hard-working</b> developers who provide G\47MIC <b>for free</b> ?\\n"\n\
  #          "\#@gui : Just follow the link below (or copy/paste into your browser) and click <b>on the sponsored link</b> that is shown. It\47s as simple as that and"\n\
  #          "\#@gui : we\47ll drink to you :)\"}"\n\
  #          "\#@gui : url = link{\"Send a free hot chocolate to the G\47MIC developers\",\"http://gmic.eu/freechocolate.shtml\"}"\n\
  #          "\#@gui : url = link{\"http://gmic.eu/freechocolate.shtml\"}"\n\
  #          "\#@gui : note = note{\"If you\47d like to send <b>more</b> than a single hot chocolate for our efforts, you are welcome too!\"}"\n\
  #          "\#@gui : sep = separator()"\n\
  #          "\#@gui : note = note{\"<small><b>Note:</b> This filter won\47t appear anymore after you re-run the plug-in. So, don\47t miss the occasion!</small>\"}"\n\
  #       @gui/"\/   : sep = separator(), note = note(\"<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>06/17/2016</i>.</small>\")"\n\
  #       '})
  #       o. raw:$file_hc,uchar rm.
  #     else
  #       (35,{$c+1}) o. raw:{/$file_hc},uchar rm.
  #     fi
  #   fi
  # else # File does not exist
  #   if $ok_host (35,32) o. raw:$file_hc,uchar rm. fi
  # fi
  # if $ok_host" && "isfile(['{/$file_hc}']) ({'{/$file_hc}'}) fi

  # l[]
  #   strin="<i><a href=\"http://ow.ly/wpsV30fzhdI\">David Tschumperlé</a></i>"
  #   strout="<i><a href=\"http://ow.ly/wpsV30fzhdI\">David Tschumperlé / <span color=\"#FF6060\">&#x2764;&#x2764;</span></a></i>"
  #   filename=${_path_rc}update$_version.gmic
  #   i raw:$filename,uchar,32
  #   s -,10 is_marked={1,h>1} rm
  #   if $is_marked
  #     i raw:$filename,uchar
  #     replace_str "#@gmic\n##\n","#@gmic\n#\n"
  #     replace_str $strout,$strin
  #     o raw:$filename,uchar
  #   else
  #     if u<0.2
  #       i raw:$filename,uchar
  #       replace_str "#@gmic\n#\n","#@gmic\n##\n"
  #       replace_str $strin,$strout
  #       o raw:$filename,uchar
  #     fi
  #   fi
  #   rm
  # onfail rm
  # done

#@gui GAAP Test : gaap_test, gaap_test
#@gui : Sigma = float(0,0,100)
#@gui : Color = color(0,0,0)
gaap_test :
  b $1
  u \{{$1+10}\}\{$2,$3,255\}

#@gui Layer Info : gui_layer_info, gui_layer_info_preview
#@gui : Number of Output Layers for Each Input Layer = int(1,1,5)
#@gui : note = note("<small><b>Note:</b> This filter displays layer info on each layer.</small>")
gui_layer_info :
  repeat $! l[$<] nm={n}
    animate b,0,10,$1
    => $nm
  done done

  repeat $! l[$>]
    0 t. "Layer indice: ""#"$>"\nLayer name: "${-gui_layer_name}"\nBlending mode: "${-gui_layer_mode}"\nOpacity : "${-gui_layer_opacity}"\nPosition: "${-gui_layer_pos},0,0,40,1,255
    to_rgba[0] expand. xy,8 +dilate. 8 to_colormode[1] {0,s} j[0] [1],20,20,0,0,1,[2],255
    k[0]
  done done

gui_layer_info_preview :
  gui_layer_info $1
  gui_preview

#@gui Graduated Color Accent : fx_gca, fx_gca_preview
#@gui : Reference Color = color(255,255,255)
#@gui : Amplitude = float(1,0,5)
#@gui : Max Value = choice("From input","From reference color","Maximum allowed")
#@gui : Channel = choice(0,"Saturation","Lightness")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2015/15/07</i>.</small>")
fx_gca :
  channel={1+$6}
  repeat $! l[$>] to_color split_opacity l[0]
    +fc $1,$2,$3
    -[1] [0] norm[1] /[1] {1e-6+iM} *[1] -1 +[1] 1 ^[1] $4
    rgb2hsl[0] s[0] c
    if $5==0 *[$channel,-1]
    elif $5==1 ($1^$2^$3) rgb2hsl. *[$channel] {i[$channel]} rm[-2,-1]
    else rv[$channel,-1] rm.
    fi
    a c hsl2rgb
  done a c done done

fx_gca_preview :
  gui_split_preview "fx_gca $*",$-1

#@gui Faded Mirror : fx_faded_mirror, fx_faded_mirror(1)
#@gui : Axis = choice("x-axis","y-axis")
#@gui : Fading = float(10,0,100)
#@gui : Overlapping = float(10,0,100)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2013/29/05</i>.</small>")
fx_faded_mirror :
  repeat $! l[$>]
    if $1==0  # X-axis
      100%,1,1,1,"a=1/(1-w*$2%);b=-a*(w-1);a*x+b" c. 0.01,1 *.. .
      r. 100%,.. a c r {2*w-w*$3%},100%,1,100%,0 +mirror x
    else # Y-axis
      1,100%,1,1,"a=1/(1-h*$2%);b=-a*(h-1);a*y+b" c. 0.01,1 r. ..,100% *.. .
      a c r 100%,{2*h-h*$3%},1,100%,0 +mirror y
    fi
     + s. c,-{s-1} /[-2,-1]
  done done

#@gui Fourier Transform [Old] : fx_fourier_old,fx_fourier_old_preview(1)* : *
#@gui :Magnitude / Phase=choice{0,"One Layer (Horizontal)","One Layer (Vertical)","Two Layers"}
#@gui :Discard Transparency=bool(1)
#@gui :_=separator()
#@gui :_=note("<small><b>Note:</b> Apply this filter once to get the direct FFT, and once again to get the reverse \
# transform.</small>")
#@gui :_=link("Click here for a video tutorial","http://www.youtube.com/watch?v=3137dDa6P4s")
#@gui :_=separator()
#@gui : note = note("<small>Author: <i>David Tschumperlé</i>.      Latest Update: <i>2018/06/16</i>.</small>")
fx_fourier_old : skip ${2=0}
  if $2 remove_opacity fi
  magic="GMICFFT" i=0
  for $i<$! {
    ni:=$i+1 nm={$i,n} is_ifft=0
    +columns[$i] 100%
    l. {
      mag,m0,M0,m1,M1=${u\ {t}}
      if ['$mag']=='$magic' is_ifft=1 fi
      onfail
    }
    rm.
    if !$is_ifft +rows[$i] 100% l. { mag,m0,M0,m1,M1=${u\ {t}} if ['$mag']=='$magic' is_ifft=2 fi onfail } rm. fi
    if !$is_ifft
      +rows[$i] 100% l. { mag,m0,M0=${u\ {t}} if ['$mag']=='$magic' is_ifft=3 fi onfail } rm.
      if $is_ifft==3
        is_ifft=0 +rows[$ni] 100%
        l. { mag,m1,M1=${u\ {t}} if ['$mag']=='$magic' is_ifft=3 fi onfail } rm.
      fi
    fi
    if !$is_ifft
      l[$i] {
        fftpolar +.. 1 log.. m0,M0,m1,M1:=im#0,iM#0,im#1,iM#1 n[-2,-1] 0,255
        if !$1 ({'$magic,$m0,$M0,$m1,$M1'},0) y. a x
        elif $1==1 ({'$magic,$m0,$M0,$m1,$M1'},0) a y
        else ({'$magic,$m0,$M0'},0) a[-3,-1] y ({'$magic,$m1,$M1'},0) a[-2,-1] y
        fi
        => $nm
      }
    else
      if $is_ifft==1 columns[$i] 0,{$i,w-2} s[$i] x,2
      elif $is_ifft==2 rows[$i] 0,{$i,h-2} s[$i] y,2
      else rows[$i,$ni] 0,{$i,h-2}
      fi
      l[$i,{$i+1}] { n[0] $m0,$M0 n[1] $m1,$M1 exp[0] -[0] 1 ifftpolar c 0,255 }
    fi
    i+=$1<2" || "$is_ifft>2?1:2
  }

fx_fourier_old_preview :
  if $2 remove_opacity fi
  dfft

#@gui Grain [Old] : fx_grain, fx_grain_preview(0)
#@gui : Amplitude = float(40,0,512)
#@gui : Tone Smoothness = float(5,0,15)
#@gui : Grain Type = choice("Gaussian","Uniform")
#@gui : Channel(s) = choice(2,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator()
#@gui : note = note("<small><b>Shadows:</b></small>")
#@gui : Strength = float(0.8,0,1)
#@gui : Scale = float(0.5,0,2)
#@gui : Channel Correlation = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Mid-tones:</b></small>")
#@gui : Strength = float(1,0,1)
#@gui : Scale = float(0,0,2)
#@gui : Channel Correlation = float(0.5,0,1)
#@gui : sep = separator()
#@gui : note = note("<small><b>Highlights:</b></small>")
#@gui : Strength = float(0.6,0,1)
#@gui : Scale = float(0.2,0,2)
#@gui : Channel Correlation = float(0.5,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2013/21/11</i>.</small>")
fx_grain :
  repeat $! l[$>] apply_channels "_fx_grain ${1-13}",$4,0 done done

_fx_grain :
  if !$1 return fi
  s={s} +luminance

  # Shadows.
  if $5
    100%,100%,1,$s noise. 1,$3 b. $6 *. {(1-$7)/max(abs(im),abs(iM))}
    100%,100%,1,1 noise. 1,$3 b. $6 *. {$7/max(abs(im),abs(iM))}
    +[-2,-1] +ir[1] 0,85 b. $2 n. 0,1 *[-2,-1] *. $5
  fi

  # Midlights.
  if $8
    100%,100%,1,$s noise. 1,$3 b. $9 *. {(1-$10)/max(abs(im),abs(iM))}
    100%,100%,1,1 noise. 1,$3 b. $9 *. {$10/max(abs(im),abs(iM))}
    +[-2,-1] +ir[1] 86,169 b. $2 n. 0,1 *[-2,-1] *. $8
  fi

  # Highlights.
  if $11
    100%,100%,1,$s noise. 1,$3 b. $12 *. {(1-$13)/max(abs(im),abs(iM))}
    100%,100%,1,1 noise. 1,$3 b. $12 *. {$13/max(abs(im),abs(iM))}
    +[-2,-1] +ir[1] 170,256 b. $2 n. 0,1 *[-2,-1] *. $11
  fi

  rm[1] +[-3--1] n. -$1,$1 + c 0,255

fx_grain_preview :
  gui_split_preview "fx_grain $*",$-1

#@gui Shaded Segmentation : dt_segment_shaded,dt_segment_shaded(0)
#@gui : Density = float(1,0,3)
#@gui : Shading = float(0.7,0,2)
#@gui : Smoothness = float(1,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2013/01/02</i>.</small>")
dt_segment_shaded :
  repeat $! l[$>]
    b $3 segment_watershed $1,1
    +g xy,1 a[-2,-1] c norm. !=. 0 distance[1] 1 normalize_local. 1000
    n. 0,1 ^. {max(1e-5,$2)} n. 0,255
    blend value
  done done

#@gui Perspective Scale : fx_perspective_scale, fx_perspective_scale_preview(1)
#@gui : Iterations = int(2,2,10)
#@gui : Factor = float(75,0,100)
#@gui : X-Offset = float(0,-100,100)
#@gui : Y-Offset = float(0,-100,100)
#@gui : Output Mode = _choice("Single layer","Multiple layers")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2013/08/02</i>.</small>")
fx_perspective_scale :
  repeat $! l[$<] to_rgba
    w={w} h={h}
    f=100 repeat $1-1 f={$f*$2%} +r[0] $f%,$f%,1,4,2 done
    repeat $!-1 l[{$>+1}]
      sx={round(($>+1)*$w*$3%/($1-1))}
      sy={round(($>+1)*$h*$4%/($1-1))}
      r $w,$h,1,4,0,0,0.5,0.5 shift. $sx,$sy,0,0,0
    done done
    if !$5 repeat $!-1 blend[0,1] alpha,1,1 done fi
  done done

fx_perspective_scale_preview :
  fx_perspective_scale ${1-4},0

#@gui Auto-Adjust Orientation : fx_adjust_orientation, fx_adjust_orientation(1)
#@gui : Threshold = float(5,0,100)
fx_adjust_orientation :
  repeat $!
    M={max(w,h)}
    +gradient_norm. ge. $1%                      # Compute binary contours
    +*. '1+y' *.. '1+x' a[-2,-1] c               # Extract contours points
    r. {w*h},2,1,1,-1 sort. +,x autocrop. 0
    /. $M +r. 1,2,1,1,2 r. .. -[-2,-1]    # Estimate main axis
    +transpose. m*[-2,-1]
    eigen. rm.. z. 0,0
    if i<0 *. -1 fi
    theta={180*atan2(i(0,1),i)/pi}
    rm.
    if w>h rotate. {-$theta},1,0,50%,50%
    else rotate. {-$theta+90},1,0,50%,50%
    fi
  mv. 0 done

#@gui Curves : fx_apply_curve, fx_apply_curve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : Display Histogram = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")
fx_apply_curve :
  ac "_fx_apply_curve ${1-13}",$14,$15

_fx_apply_curve :
  apply_curve $13,0,$1,\
                   ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                   ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                   ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                   ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                   ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                   255,$12

fx_apply_curve_preview :
  function1d $13,0,$1,\
                  ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                  ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                  ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                  ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                  ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                  255,$12
  mv. 0
  repeat $!-1
    +gui_split_preview. "fx_apply_curve $*",$-1
    100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
    grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
    line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
    if $-2
      .,. to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,1 -!=. 0 *. 255 rm...
      +xor[-2,-1] j... .,0,0,0,0,$16,..,255 rm[-2,-1]
     else rm.. fi
     100%,100% graph. [0],1,0,255,0,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
     _fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
     _fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
     _fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
     _fx_apply_curve_preview 255,$12,6
  mv. 1 done rm[0]

_fx_apply_curve_preview :
  if $1>=0
    x={$1*100/255}% y={100-$2*100/255}%
    ellipse. $x,$y,3,3,0,1,0xFFFFFFFF,0,0,0 ellipse. $x,$y,2,2,0,1,0,255,0
    t. $3,$x,{$y*h-20},13,1,255
  fi

#@gui Curves [RGB]
#@gui Red : fx_apply_RGBcurve, fx_apply_Rcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")

#@gui Green : fx_apply_RGBcurve, fx_apply_Gcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")

#@gui Blue : fx_apply_RGBcurve, fx_apply_Bcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui _
fx_apply_RGBcurve : skip $1
  fx_apply_RGBcurve_configfile
  repeat $!-1 l[$>,-1]
    to_colormode[0] {max(3,s)}
    sh[0] 0 _fx_apply_RGBcurve. {-2,@0-12} rm.
    sh[0] 1 _fx_apply_RGBcurve. {-2,@13-25} rm.
    sh[0] 2 _fx_apply_RGBcurve. {-2,@26-38} rm.
  done done
  rm.

_fx_apply_RGBcurve :
  apply_curve $13,0,$1,\
                   ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                   ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                   ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                   ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                   ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                   255,$12
  c 0,255

fx_apply_Rcurve_preview :
  fx_apply_RGBcurve_configfile
  sh. 0,0,0,0 f. ${1--3} rm.
  fx_apply_RGBcurve_preview[^-1] {^},0,${-2,-1} rm.

fx_apply_Gcurve_preview :
  fx_apply_RGBcurve_configfile
  sh. 1,1,0,0 f. ${1--3} rm.
  fx_apply_RGBcurve_preview[^-1] {^},1,${-2,-1} rm.

fx_apply_Bcurve_preview :
  fx_apply_RGBcurve_configfile
  sh. 2,2,0,0 f. ${1--3} rm.
  fx_apply_RGBcurve_preview[^-1] {^},2,${-2,-1} rm.

fx_apply_RGBcurve_configfile :
  filename=${-path_tmp}.gmic_RGBcurve.dlm
  if isfile(['{/$filename}']) $filename else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) r. 100%,3 fi

fx_apply_RGBcurve_preview :
  (${1--3}) r. 13,3,1,1,-1 o. ${-path_tmp}.gmic_RGBcurve.dlm rm.
  function1d $13,0,$1,\
                  ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                  ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                  ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                  ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                  ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                  255,$12
  function1d $26,0,$14,\
                  ${"if $15>=0 u $15,$16, else u \"\" fi"}\
                  ${"if $17>=0 u $17,$18, else u \"\" fi"}\
                  ${"if $19>=0 u $19,$20, else u \"\" fi"}\
                  ${"if $21>=0 u $21,$22, else u \"\" fi"}\
                  ${"if $23>=0 u $23,$24, else u \"\" fi"}\
                  255,$25
  function1d $39,0,$27,\
                  ${"if $28>=0 u $28,$29, else u \"\" fi"}\
                  ${"if $30>=0 u $30,$31, else u \"\" fi"}\
                  ${"if $32>=0 u $32,$33, else u \"\" fi"}\
                  ${"if $34>=0 u $34,$35, else u \"\" fi"}\
                  ${"if $36>=0 u $36,$37, else u \"\" fi"}\
                  255,$38
  a[-3--1] y mv. 0
  repeat $!-1
    +gui_split_preview. "fx_apply_RGBcurve 0",$-1
    100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
    grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
    line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
     if $-2
        .,.,1,1,-{$-2*255/100} to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,0
        rm... +. {$-2*255/100} +[-2,-1] c. 0,255
     else rm.. fi
     line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
     sh[0] 0,0,0,0
     graph.. .,1,0,255,0,1,255,128,128 -. 1
     graph.. .,1,0,255,0,0.5,200,0,0 rm.
     sh[0] 1,1,0,0
     graph.. .,1,0,255,0,1,128,255,128 -. 1
     graph.. .,1,0,255,0,0.5,0,200,0 rm.
     sh[0] 2,2,0,0
     graph.. .,1,0,255,0,1,128,128,255 -. 1
     graph.. .,1,0,255,0,0.5,0,0,200 rm.
     if $40==0
       _fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
       _fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
       _fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
       _fx_apply_curve_preview 255,$12,6
     elif $40==1
       _fx_apply_curve_preview 0,$14,0 _fx_apply_curve_preview $15,$16,1
       _fx_apply_curve_preview $17,$18,2 _fx_apply_curve_preview $19,$20,3
       _fx_apply_curve_preview $21,$22,4 _fx_apply_curve_preview $23,$24,5
       _fx_apply_curve_preview 255,$25,6
     else
       _fx_apply_curve_preview 0,$27,0 _fx_apply_curve_preview $28,$29,1
       _fx_apply_curve_preview $30,$31,2 _fx_apply_curve_preview $32,$33,3
       _fx_apply_curve_preview $34,$35,4 _fx_apply_curve_preview $36,$37,5
       _fx_apply_curve_preview 255,$38,6
     fi
  mv. 1 done rm[0]

#@gui Curves [YCbCr]
#@gui Luminance : fx_apply_YCbCrcurve, fx_apply_Ycurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")

#@gui Blue Chrominance : fx_apply_YCbCrcurve, fx_apply_Cbcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")

#@gui Red Chrominance : fx_apply_YCbCrcurve, fx_apply_Crcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui _
fx_apply_YCbCrcurve : skip $1
  fx_apply_YCbCrcurve_configfile
  repeat $!-1 l[$>,-1]
    to_colormode[0] {max(3,s)} sh[0] 0,2 rgb2ycbcr. rm.
    sh[0] 0 _fx_apply_YCbCrcurve. {-2,@0-12} rm.
    sh[0] 1 _fx_apply_YCbCrcurve. {-2,@13-25} rm.
    sh[0] 2 _fx_apply_YCbCrcurve. {-2,@26-38} rm.
    sh[0] 0,2 -ycbcr2rgb. rm.
  done done
  rm.

_fx_apply_YCbCrcurve :
  apply_curve $13,0,$1,\
                   ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                   ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                   ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                   ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                   ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                   255,$12
  c 0,255

fx_apply_Ycurve_preview :
  fx_apply_YCbCrcurve_configfile
  sh. 0,0,0,0 f. ${1--3} rm.
  fx_apply_YCbCrcurve_preview[^-1] {^},0,${-2,-1} rm.

fx_apply_Cbcurve_preview :
  fx_apply_YCbCrcurve_configfile
  sh. 1,1,0,0 f. ${1--3} rm.
  fx_apply_YCbCrcurve_preview[^-1] {^},1,${-2,-1} rm.

fx_apply_Crcurve_preview :
  fx_apply_YCbCrcurve_configfile
  sh. 2,2,0,0 f. ${1--3} rm.
  fx_apply_YCbCrcurve_preview[^-1] {^},2,${-2,-1} rm.

fx_apply_YCbCrcurve_configfile :
  filename=${-path_tmp}.gmic_YCbCrcurve.dlm
  if isfile(['{/$filename}']) $filename else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) r. 100%,3 fi

fx_apply_YCbCrcurve_preview :
  (${1--3}) r. 13,3,1,1,-1 o. ${-path_tmp}.gmic_YCbCrcurve.dlm rm.
  function1d $13,0,$1,\
                  ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                  ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                  ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                  ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                  ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                  255,$12
  function1d $26,0,$14,\
                  ${"if $15>=0 u $15,$16, else u \"\" fi"}\
                  ${"if $17>=0 u $17,$18, else u \"\" fi"}\
                  ${"if $19>=0 u $19,$20, else u \"\" fi"}\
                  ${"if $21>=0 u $21,$22, else u \"\" fi"}\
                  ${"if $23>=0 u $23,$24, else u \"\" fi"}\
                  255,$25
  function1d $39,0,$27,\
                  ${"if $28>=0 u $28,$29, else u \"\" fi"}\
                  ${"if $30>=0 u $30,$31, else u \"\" fi"}\
                  ${"if $32>=0 u $32,$33, else u \"\" fi"}\
                  ${"if $34>=0 u $34,$35, else u \"\" fi"}\
                  ${"if $36>=0 u $36,$37, else u \"\" fi"}\
                  255,$38
  a[-3--1] y mv. 0
  repeat $!-1
    +gui_split_preview. "fx_apply_YCbCrcurve 0",$-1
    axes. 0,255,255,0,13,1,255
    100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
    grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
    line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
     if $-2
        .,.,1,1,-{$-2*255/100} to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,0
        rm... +. {$-2*255/100} +[-2,-1] c. 0,255
     else rm.. fi
     line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
     sh[0] 0,0,0,0
     graph.. .,1,0,255,0,1,255,255,255 -. 1
     graph.. .,1,0,255,0,0.5,200,200,200 rm.
     sh[0] 1,1,0,0
     graph.. .,1,0,255,0,1,128,128,255 -. 1
     graph.. .,1,0,255,0,0.5,0,0,200 rm.
     sh[0] 2,2,0,0
     graph.. .,1,0,255,0,1,255,128,128 -. 1
     graph.. .,1,0,255,0,0.5,200,0,0 rm.
     if $40==0
       _fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
       _fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
       _fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
       _fx_apply_curve_preview 255,$12,6
     elif $40==1
       _fx_apply_curve_preview 0,$14,0 _fx_apply_curve_preview $15,$16,1
       _fx_apply_curve_preview $17,$18,2 _fx_apply_curve_preview $19,$20,3
       _fx_apply_curve_preview $21,$22,4 _fx_apply_curve_preview $23,$24,5
       _fx_apply_curve_preview 255,$25,6
     else
       _fx_apply_curve_preview 0,$27,0 _fx_apply_curve_preview $28,$29,1
       _fx_apply_curve_preview $30,$31,2 _fx_apply_curve_preview $32,$33,3
       _fx_apply_curve_preview $34,$35,4 _fx_apply_curve_preview $36,$37,5
       _fx_apply_curve_preview 255,$38,6
     fi
  mv. 1 done rm[0]

#@gui Curves [Lab]
#@gui Lightness : fx_apply_Labcurve, fx_apply_Lcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")

#@gui A-Color : fx_apply_Labcurve, fx_apply_acurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")

#@gui B-Color : fx_apply_Labcurve, fx_apply_bcurve_preview
#@gui : Starting Y = int(0,0,255)
#@gui : sep = separator()
#@gui : X-Coord(1) = int(-1,-1,255)
#@gui : Y-Coord(1) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(2) = int(-1,-1,255)
#@gui : Y-Coord(2) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(3) = int(-1,-1,255)
#@gui : Y-Coord(3) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(4) = int(-1,-1,255)
#@gui : Y-Coord(4) = int(128,0,255)
#@gui : sep = separator()
#@gui : X-Coord(5) = int(-1,-1,255)
#@gui : Y-Coord(5) = int(128,0,255)
#@gui : sep = separator()
#@gui : Ending Y = int(255,0,255)
#@gui : sep = separator()
#@gui : Curve Smoothness = float(1,0,1)
#@gui : Display Histogram = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/29/12</i>.</small>")
#@gui _
fx_apply_Labcurve : skip $1
  fx_apply_Labcurve_configfile
  repeat $!-1 l[$>,-1]
    to_colormode[0] {max(3,s)} sh[0] 0,2 rgb2lab. rm.
    sh[0] 0 *. 2.55 _fx_apply_Labcurve. {-2,@0-12} /. 2.55 rm.
    sh[0] 1 +. 86 *. 1.38587 _fx_apply_Labcurve. {-2,@13-25} /. 1.38587 -. 86 rm.
    sh[0] 2 +. 108 *. 1.25616 _fx_apply_Labcurve. {-2,@26-38} /. 1.25616 -. 108 rm.
    sh[0] 0,2 lab2rgb. rm.
  done done
  rm.

_fx_apply_Labcurve :
  apply_curve $13,0,$1,\
                   ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                   ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                   ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                   ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                   ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                   255,$12
  c 0,255

fx_apply_Lcurve_preview :
  fx_apply_Labcurve_configfile
  sh. 0,0,0,0 f. ${1--3} rm.
  fx_apply_Labcurve_preview[^-1] {^},0,${-2,-1} rm.

fx_apply_acurve_preview :
  fx_apply_Labcurve_configfile
  sh. 1,1,0,0 f. ${1--3} rm.
  fx_apply_Labcurve_preview[^-1] {^},1,${-2,-1} rm.

fx_apply_bcurve_preview :
  fx_apply_Labcurve_configfile
  sh. 2,2,0,0 f. ${1--3} rm.
  fx_apply_Labcurve_preview[^-1] {^},2,${-2,-1} rm.

fx_apply_Labcurve_configfile :
  filename=${-path_tmp}.gmic_Labcurve.dlm
  if isfile(['{/$filename}']) $filename else (0,-1,128,-1,128,-1,128,-1,128,-1,128,255,1) r. 100%,3 fi

fx_apply_Labcurve_preview :
  (${1--3}) r. 13,3,1,1,-1 o. ${-path_tmp}.gmic_Labcurve.dlm rm.
  function1d $13,0,$1,\
                  ${"if $2>=0 u $2,$3, else u \"\" fi"}\
                  ${"if $4>=0 u $4,$5, else u \"\" fi"}\
                  ${"if $6>=0 u $6,$7, else u \"\" fi"}\
                  ${"if $8>=0 u $8,$9, else u \"\" fi"}\
                  ${"if $10>=0 u $10,$11, else u \"\" fi"}\
                  255,$12
  function1d $26,0,$14,\
                  ${"if $15>=0 u $15,$16, else u \"\" fi"}\
                  ${"if $17>=0 u $17,$18, else u \"\" fi"}\
                  ${"if $19>=0 u $19,$20, else u \"\" fi"}\
                  ${"if $21>=0 u $21,$22, else u \"\" fi"}\
                  ${"if $23>=0 u $23,$24, else u \"\" fi"}\
                  255,$25
  function1d $39,0,$27,\
                  ${"if $28>=0 u $28,$29, else u \"\" fi"}\
                  ${"if $30>=0 u $30,$31, else u \"\" fi"}\
                  ${"if $32>=0 u $32,$33, else u \"\" fi"}\
                  ${"if $34>=0 u $34,$35, else u \"\" fi"}\
                  ${"if $36>=0 u $36,$37, else u \"\" fi"}\
                  255,$38
  a[-3--1] y mv. 0
  repeat $!-1
    +gui_split_preview. "fx_apply_Labcurve 0",$-1
    axes. 0,255,255,0,13,1,255
    100%,100% axes. 0,255,255,0,13,1,255 +dilate. 3 r.. ... j... ..,0,0,0,0,1,.,255 rm[-2,-1]
    grid. 10%,10%,0,0,0.3,0xCCCCCCCC,255
    line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
     if $-2
        .,.,1,1,-{$-2*255/100} to_gray... histogram... 256,0,255 graph. ...,3,0,0,0,1,0
        rm... +. {$-2*255/100} +[-2,-1] c. 0,255
     else rm.. fi
     line. 0,100%,100%,0,0.3,0xCCCCCCCC,255
     sh[0] 0,0,0,0
     graph.. .,1,0,255,0,1,255,255,255 -. 1
     graph.. .,1,0,255,0,0.5,200,200,200 rm.
     sh[0] 1,1,0,0
     graph.. .,1,0,255,0,1,255,128,128 -. 1
     graph.. .,1,0,255,0,0.5,200,0,0 rm.
     sh[0] 2,2,0,0
     graph.. .,1,0,255,0,1,128,128,255 -. 1
     graph.. .,1,0,255,0,0.5,0,0,200 rm.
     if $40==0
       _fx_apply_curve_preview 0,$1,0 _fx_apply_curve_preview $2,$3,1
       _fx_apply_curve_preview $4,$5,2 _fx_apply_curve_preview $6,$7,3
       _fx_apply_curve_preview $8,$9,4 _fx_apply_curve_preview $10,$11,5
       _fx_apply_curve_preview 255,$12,6
     elif $40==1
       _fx_apply_curve_preview 0,$14,0 _fx_apply_curve_preview $15,$16,1
       _fx_apply_curve_preview $17,$18,2 _fx_apply_curve_preview $19,$20,3
       _fx_apply_curve_preview $21,$22,4 _fx_apply_curve_preview $23,$24,5
       _fx_apply_curve_preview 255,$25,6
     else
       _fx_apply_curve_preview 0,$27,0 _fx_apply_curve_preview $28,$29,1
       _fx_apply_curve_preview $30,$31,2 _fx_apply_curve_preview $32,$33,3
       _fx_apply_curve_preview $34,$35,4 _fx_apply_curve_preview $36,$37,5
       _fx_apply_curve_preview 255,$38,6
     fi
  mv. 1 done rm[0]
cracks_old : skip ${1=0.2},${2=40},${3=0}
  e[^-1] "Add random cracks to image$?, with density $1."
  v - repeat $! l[$>]
    ({im},{iM}) ..,..,1,1 noise. $1,2 ==. 1 distance. 1 sharpen. 10000
    if $3 g. xy +[-2,-1] n. -1,1 else n. 0,1 fi
    *. $2 +[-3,-1] c.. {^} rm.
  done done v +

fx_cracks_old :
  ac "-cracks_old $1,$2,$3",$4

negative :
  e[^-1] "Compute negative of image$?."
  v - repeat $! l[$>] - {iM} done done * -1 v +

transfer_colors : skip ${2=0}
  e[^-1] "Transfer colors of image $1 to image$?."
  v - pass$1 0 mv. 0 to_rgb[0] to_colormode[^0] {max(3,${-max_s})} c 0,255   # Convert all images to RGB[A]
  repeat $! l[$>] split_opacity rgb2ycbcr[0] a c done done                   # Perform RGB[A] to YCbCr[A] conversion
  l[0] s c histogram_cumul 256,1,0,255 a c * 255 done                        # Compute channel-by-channel cumulative histogram of target image
  repeat $!-1 l[0,{$<+1}]
    if $2 repeat 3 sh[0,1] $> equalize. 256,0,255 index. ..,0,0 rm[-2,-1] done     # Transfer brightness + colors
    else repeat 2 sh[0,1] {$>+1} equalize. 256,0,255 index. ..,0,0 rm[-2,-1] done  # Transfer colors only
    fi
  done done rm[0]
  repeat $! l[$>] split_opacity ycbcr2rgb[0] a c done done    # Perform YCbCr[A] to RGB[A] conversion
  c 0,255
  v +

_transfer_colors :  # Check transfer_colors performance
  repeat $! l[$>] rgb2ycbcr s c histogram 256,0,255 a c -dg 300,200 done done

is_bwclut :
  to_clutname "$1" name=${} l[]
  if narg($GMIC_SYSTEM_PATH) g_path_unix=$GMIC_SYSTEM_PATH
  else g_path_unix=/usr/lib/gimp/2.0/plug-ins/
  fi
  path_test0=$path_clut
  path_test1=$_path_rc
  path_test2=${-path_gimp}plug-ins/
  path_test3=${-path_gimp}plug-ins/gmic_gimp_qt/
  path_test4=$g_path_unix
  repeat 5 file_clut=${path_test$>}/gmic_cluts.gmz
    l[] $file_clut onfail done if $! break fi
  done
  if !$! # Download from G'MIC server
    i https://gmic.eu/gmic_cluts.gmz o ${path_clut}gmic_cluts.gmz
  fi
  k[${"nmd 1,"$name}]
  u {s==4}
  rm done

# Custom version of native command 'mproj', for G'MIC < 2.9.2
mproj : check ${"is_image_arg $1"}" && isint(${2=0}) && $2>=0 && isint(${3=0}) && $3>=0 && ${4=1e-5}>=0"
  # Method; Orthogonal projection (can be done simultaneously for all images/columns).
  s0,s1="ces","x"
  if !$2
    e[^-1] "Project matri"${s{$!==1}}" onto dictionnary $1, using orthogonal projection."
    pass$1 solve[^-1] . rm. return
  elif $2==1
    m="Matching Pursuit"
  elif $2==2
    m="Matching Pursuit + orthogonal projection"
  else
    m="Orthogonal Matching Pursuit, with ortho-projection every "{$2-2}" iterations."
  fi
  e[^-1] "Project matri"${s{$!==1}}" onto dictionnary $1, using "$m"."

  # Compute dictionnary norms and normalize it.
  pass$1 0 1,{w},1,1,"max(1e-8,norm(crop(#-1,y,1)))" /.. .

  # Process selected matrices.
  repeat $!-2 l[$>,-2,-1] s[0] x

    # Process each signal independently
    repeat $!-2 l[$>,-2]
      if $2<3
        # Method : Matching Pursuit.
        1,{1,w} # [2] = Weights to be computed
        eval "
          const nmax = $3?$3:w#1;
          ref(crop(#0),S);
          residual = inf;
          for (n = 0, n<nmax && residual>$4, ++n,

            # Find best-matching dictionary atom.
            lmax = -1;
            absdotmax = dotmax = 0;
            for (l = 0, l<w#1, ++l,
              ref(crop(#1,l,1),D);
              dot = dot(D,S);
              absdot = abs(dot);
              absdot>absdotmax?(
                absdotmax = absdot;
                dotmax = dot;
                lmax = l;
              );
            );
            i[#2,lmax] += dotmax;
            S-=(crop(#1,lmax,1)*=dotmax);
            residual = norm(S)/size(S);
          )"

        if $2==2
          # Apply final orthogonal projection on selected vectors.
          f[2] i?y+1:0 +discard[2] 0 transpose. -. 1
          +r[1] 100%,1,1,{1,h},-1 warp. .. r. 100%,{0,h},1,1,-1
          +solve[0] .
          eval[3] i[#2,i]=i[#-1,x]
          rm[3--1]
        fi

      else
        # Method : Orthogonal Matching Pursuit.
        1,{1,w} # [2] = Weights to be computed
        [0] # [3] = Temp image used for residual computation
        eval "
          orthoproj() = ( # Orthoprojection onto parse span
            run('f[2] i?y+1:0 +discard[2] 0 transpose. -. 1
                 +r[1] 100%,1,1,{1,h},-1 warp. .. r. 100%,{0,h},1,1,-1
                 +solve[0] . eval[4] i[#2,i]=i[#-1,x] rm...
                 m*[-2,-1]
                 j[3] [0] -[3,-1]');
          );

          const nmax = $3?$3:w#1;
          ref(crop(#0),S);
          residual = inf;
          is_orthoproj = 0;
          for (n = 0, n<nmax && residual>$4, ++n,

            # Find best-matching dictionary atom.
            lmax = -1;
            absdotmax = dotmax = 0;
            for (l = 0, l<w#1, ++l,
              ref(crop(#1,l,1),D);
              dot = dot(D,S);
              absdot = abs(dot);
              absdot>absdotmax?(
                absdotmax = absdot;
                dotmax = dot;
                lmax = l;
              );
            );
            !n || (n%($2-2))?( # 1st iteration? -> eq. to matching pursuit
              i[#2,lmax] += dotmax;
              S-=(crop(#1,lmax,1)*=dotmax);
              residual = norm(S)/size(S);
              is_orthoproj = 0;
            ):(
              i[#2,lmax] = 1; # Only used as a mark
              orthoproj();
              S = crop(#3);
              residual = norm(S)/size(S);
              is_orthoproj = 1;
            );
          );
          !is_orthoproj?orthoproj(); # Perform one last projection if needed
          "
        rm.
      fi
      rv[0,-1] rm.
    done done

    # Renormalize result to fit range of non-normalized input dictionnary.
    /[^-2,-1] . a[^-2,-1] x
  done done
  rm[-2,-1]

# Display a random command.
#--------------------------
dodoc :
  it $HOME/work/src/gmic/src/gmic_stdlib.gmic
  parse_cli list
  list=${}
  ind={N=narg($list);int(u(0,N))%N}
  e[] "\nDocument command : '"${"arg "$ind,$list}"'\n"
  q



#@gui Blur [Quad] : fx_blur_quad, fx_blur_quad_preview
#@gui : note = note("<small><b>Blur parameters:</b></small>")
#@gui : 1st Amplitude (%) = float(0,0,100)
#@gui : 2nd Amplitude (%) = float(5,0,100)
#@gui : Brightness (%) = float(0,-100,100)
#@gui : Contrast (%) = float(0,-100,100)
#@gui : Gamma (%) = float(0,-100,100)
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain Extract","Grain Merge","Green","Hard Light",
#@gui : "Hard Mix","Hue","Interpolation","Lighten","Lightness","Linear Burn","Linear Light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin Light","Red","Reflect","Saturation",
#@gui : "Soft Burn","Soft Dodge","Soft Light","Screen","Stamp","Subtract","Value","Vivid Light","Xor"}
#@gui : Opacity (%) = float(100,0,100)
#@gui : sep = separator()
#@gui : note = note("<small><b>Quad coordinates:</b></small>")
#@gui : P0 = point(40,25,0,1)
#@gui : P1 = point(60,25,0,1)
#@gui : P2 = point(95,90,0,1)
#@gui : P3 = point(5,90,0,1)
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>David Tschumperlé</i>.      Latest Update: <i>2021/01/18</i>.</small>")
fx_blur_quad :
  mode=${"arg 1+$6,add,alpha,and,average,blue,burn,darken,difference,divide,dodge,edges,exclusion,freeze,grainextract,\
              grainmerge,green,hardlight,hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,\
              luminance,multiply,negation,or,overlay,pinlight,red,reflect,saturation,softburn,softdodge,softlight,\
              screen,stamp,subtract,value,vividlight,xor"}
  repeat $! l[$>]
    100%,100%,1,3
    100%,100%,1,[0],"
      begin(
        const interpolation = 1;
        const boundary = 1;
        const w1 = w - 1;
        const h1 = h - 1;
        x0 = $8*w1%; y0 = $9*h1%;
        x1 = $10*w1%; y1 = $11*h1%;
        x2 = $12*w1%; y2 = $13*h1%;
        x3 = $14*w1%; y3 = $15*h1%;
      );
      xw1 = x/w1;
      yh1 = y/h1;
      xl = lerp(x0,x3,yh1);
      yl = lerp(y0,y3,yh1);
      xr = lerp(x1,x2,yh1);
      yr = lerp(y1,y2,yh1);
      xc = lerp(xl,xr,xw1);
      yc = lerp(yl,yr,xw1);
      I(#1,round(xc),round(yc))+=[ x,y,1 ];
      I(#0,xc,yc)"

    f.. "B?[ R,G,0 ]/B:[ -1,-1,0 ]" channels.. 0,1
    b. x,1% b. y,2%
    adjust_colors. ${3-5},0,0,0,255

    to_a.
    100%,100%,1,1,1 a[-2,-1] c
    warp. ..,0,1,0 rm..
    sh. 100% mul[-2,-1] channels. 0,{s-2}
    blend[-2,-1] $mode,$7%

  done done

fx_blur_quad_preview :
  fx_blur_quad $*
  polygon 4,$8%,$9%,$10%,$11%,$12%,$13%,$14%,$15%,0.5,0xCCCCCCCC,0,0,0,255
  polygon 4,$8%,$9%,$10%,$11%,$12%,$13%,$14%,$15%,0.5,0x33333333,255

#@cli frame_round_old : _sharpness>0,_size>=0,_smoothness,_shading,_R,_G,_B,_A
#@cli : Draw RGBA-colored round frame in selected images.
#@cli : Default values: 'sharpness=10', 'size=10', 'smoothness=0', 'shading=0' and 'R=G=B=A=255'.
#@cli : $ image.jpg frame_round 10
frame_round_old : skip ${1=10},${2=10},${3=0},${4=0},${5=255},${6=$5},${7=$6},${8=255}
  e[^-1] "Draw round frame on image$?, with sharpness $1, size $2, smoothness $3, shading $4 and
          RGBA color ($5,$6,$7,$8)."
  to_rgba
  foreach {
    nm={n}
    100%,100%,1,1,"-(abs(x/w-0.5)^$1 + abs(y/h-0.5)^$1)^(1/$1)" >=. $2%
    if $4 distance. 1 n. 0,1 *. -1 +. 1 ^. {1/$4} fi
    b. $3 i... 100%,100%,1,4 fc... $5,$6,$7,$8 blend_fade[0,1] . rm.
    => $nm
  }

#@gui Frame [Round] Old : fx_frame_round_old, fx_frame_round_old(1)
#@gui : Sharpness = float(6,0.1,40)
#@gui : Size (%) = float(20,0,100)
#@gui : Smoothness = float(0.1,0,15)
#@gui : Shade = float(0,0,1)
#@gui : Color = color(255,255,255,255)
#@gui : Blur Frame = float(0,0,100)
#@gui : Blur Shade = float(0.1,0,1)
#@gui : Blur Amplitude = float(3,0,10)
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>David Tschumperlé</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_frame_round_old :
  frame_round ${1-8}
  if $9 frame_blur $1,{min(99,$1+$9)},$3,$10,$11% fi

#@gui For Littbarski : fx_for_littbarski, fx_for_littbarski
#@gui : Palette file (PNG) = file("")
#@gui : Dithering (%) = float(50,0,100)
#@gui : Output Mode = choice(1,"Color Indices","Colors")
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>David Tschumperlé</i>
#@gui :       Latest Update: <i>2025/09/04</i>.</small>")
fx_for_littbarski : skip "${1=}"
  to_rgb
  l[] { i "$1" to_rgb onfail error "No Palette File Specified!" }
  foreach[^-1] { pass. 1 index.. .,$2,$3 rm. }
  rm.

#--------------------------------------------------
# Viewer of volumetric binary shapes as 3D surfels.
#--------------------------------------------------
view_surfels3d :

  # Generate volumetric image.
  nm={n}
  +distance. 0 *. -1 +. 1 *. .. +distance.. 1 +[-2,-1] round. 0.1 # Last channel : used for threshold
  l[0] { expand. xyz,1 b. 4,0 g xyz,0,0 shrink xyz,1 a c n 0,255 } # RGB colors
  a c
  => img

  # Init variables and display window.
  m:=round(0.75*min({*,u,v})) w[] $m,$m,0,$nm" ("{img,w}x{img,h}x{img,d}")"
  axes3d 60 => axes3d
  (1,0,0,0;0,1,0,0;0,0,1,0) store. pose3d
  posx,posy,zoom_factor=50,50,1
  T=1

  # Start event loop.
  do

    # Generate 3D object.
    if !0$img3d
      if {img,s==1} +f[img] 164 [img] lfacts=0.75,1,1.25 # Only threshold value -> constant color
      elif {img,s==3} [img] +norm. gt. 0 *. -inf lfacts=0.9,1,1.1 # Only RGB color, no threshold
      else +s[img] c,-{img,s-1} lfacts=0.9,1,1.1 # Color + threshold
      fi
      lt. $T *[-2,-1]
      to_rgb. surfels3d. $lfacts
      l. { s3d. c.. 0,255 a y }
      box3d {img,[w,h,d]} -3d. 0.5,0.5,0.5 col3d. 255,255,255 p3d. 1 o3d. 0.25 +3d[-2,-1]
      => img3d
    fi

    # Generate background.
    update_bg:=!0$bg
    if 0$bg" && "{0$bg,[w,h]!=[{*,w,h}]} update_bg=1 fi
    if $update_bg
      (0,0,0;0,0,100;100,0,50) permute. cyzx r. {*,w,h},1,3,3
      => bg
    fi

    # Display 3D object.
    +-3d[img3d] {img,[w,h,d]/2} *3d. {img,0.65*$zoom_factor*min({*,w,h})/max(w,h,d)}
    $pose3d p={^} rm.
    pose3d. $p +j3d[bg] .,$posx%,$posy%,0,1,2,1,1 rm..
    +pose3d[axes3d] $p j3d.. .,{-2,[80,h-80]},0,0.75,3,0,0,200 rm.
    to. "Threshold: "{_$T},,,3%
    w. rm.

    # Manage key events.
    if {*,-ARROWUP} T+=0.2 rmn img3d
    elif {*,-ARROWDOWN} T-=0.2 rmn img3d
    elif {*,-PAGEUP} T+=5 rmn img3d
    elif {*,-PAGEDOWN} T-=5 rmn img3d
    fi
    T={_round($T,0.1)}

    # Manage object rotation/zoom/pan.
    mx,my,mb={*,x,y,b}
    is_CTRL={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
    if $mx>=0 # Manage mouse-drag
      if $mb
        if !narg($mx0) mx0,my0,mx1,my1=$mx,$my,$mx,$my else mx1,my1=$mx,$my fi
      else
        if narg($mx0) rmn render fi
        mx0,my0,mx1,my1=
      fi
    fi
    if narg($mx1)" && "($mx0!=$mx1" || "$my0!=$my1)
      if $mb&1" && "!$is_CTRL # Rotation
        rotation3d[] {"
          const w2 = "{*,w}"/2;
          const h2 = "{*,h}"/2;
          const R = 0.375*min("{*,w,h}");
          const u0 = "$mx0" - w2;
          const v0 = "$my0" - h2;
          const u1 = "$mx1" - w2;
          const v1 = "$my1" - h2;
          n0 = norm(u0,v0);
          nu0 = n0>R?u0*R/n0:u0;
          nv0 = n0>R?v0*R/n0:v0;
          nw0 = sqrt(max(0,R^2 - nu0^2 - nv0^2));
          n1 = norm(u1,v1);
          nu1 = n1>R?u1*R/n1:u1;
          nv1 = n1>R?v1*R/n1:v1;
          nw1 = sqrt(max(0,R^2 - nu1^2 - nv1^2));
          u = nv0*nw1 - nw0*nv1;
          v = nw0*nu1 - nu0*nw1;
          w = nv0*nu1 - nu0*nv1;
          n = norm(u,v,w);
          [ u,v,w,-asin(n/R^2)*180/pi ]"}
        $pose3d m*[-2,-1] store. pose3d
        mx0,my0=$mx1,$my1
      elif $mb&4" || "($mb&1" && "$is_CTRL) # Pan
        posx,posy={"
          const px = "$mx1-$mx0+$posx*{*,w}%";
          const py = "$my1-$my0+$posy*{*,h}%";
          cut([ px*100/"{*,w}", py*100/"{*,h}" ],0,100)"}
        mx0,my0=$mx1,$my1
      elif $mb&2 # Zoom with mouse button
        fact={1+($my0-$my1)/100}
        zoom_factor*=$fact
        mx0,my0=$mx1,$my1
      fi
    fi
    if {*,o} # Zoom with mousewheel
      fact={1+{*,-o}/10}
      zoom_factor*=$fact
    fi

    wait
  while {*}" && "!{*,ESC}
  rm

#@cli lezoray3d : out_filename.png,nb_frames>0
#@cli : Generate a 3D animation from a set of two 3D meshes.
#@cli : Output frames are 1024x512 RGBA images.
#@cli : $ gmic mesh1.obj mesh2.obj lezoray3d out.png,180 (silent mode)
#@cli : $ gmic mesh1.obj mesh2.obj w[] lezoray3d out.png,180 (with display).
lezoray3d : check "isint(${2=180}) && $2>0" skip "${1=out.png}"
  basename {0,n} nm0=${}
  basename {1,n} nm1=${}
  e[^-1] "Generate 3D animation of 3D meshes '"$nm0"' and '"$nm1"', with output filename '$1' and $2 frames.\n"

  # Normalize objects.
  c3d n3d *3d 400
  if {*} w[] ${"fitscreen 1024,512"},0 fi

  # Generate animation.
  repeat $2 {
    e "\r - Frame \#"{$>+1}/$2
    +r3d[0,1] 0,1,0,{$>*360/$2}
    1024,512,1,3,-1
    j3d. ...,25%,50%,0,1,4,1,1
    j3d. ..,75%,50%,0,1,4,1,1
    to_rgba. replace_color. 0,0,-1,-1,-1,255,0,0,0,0
    filename $1,$> file=${}
    o. $file
    if {*} drgba. to. "Frame \#"{$>+1}/$2,0,0,5% w. fi
    k[0,1]
  }
  rm
  e "\r  - Done!               "

#--------------------------------------------------
#
#  Deprecated commands.
#
#--------------------------------------------------

d2d :
  _gmic_s="$?" v + _display2d 0,1

_d2d_core :
  _gmic_s="$?" _d2d_core=1 v + _display2d $1,1

display2d :
  _gmic_s="$?" v + _$0 0,1

# $1 = exit_on_single_click?, can be { 0=no | 1=yes }.
# $2 = default window normalization for display window #0.
_display2d : check "isbool(${1=0}) && isint(${2=1}) && $2>=0"
  e[0--3] "Start interactive display of 2D image"$_gmic_s"."
  m "_d2d_format :
       if $""#>8 u {_([$""*])[0,4]:\\ }\\ ...\\ {_([$""*])[$""#-4,4]:\\ }
       else ('\"$""*\"') replace. {','},32 u {t} rm.
       fi"
  p
  foreach {
    ('{n}') if s=crop();find(s,_'.',size(s)-1,-1)>0 nm={-2,b}.{-2,x} else nm={-2,b} fi rm.
    => img

    if !w v - d v + break fi
    if d>10
      error[0--6] "Command 'display2d': Input image has "{d}" slices, cannot manage more than 10 simultaneous views."
    fi
    is_multiview:=d>1
    is_moderate_ratio={0,D=[w,h];max(D)/min(D)<6}
    may_have_alpha:=s==2||s>=4
    alpha_mode,axes_mode,fullscreen_mode,ratio_mode={s==1||s==3},1,0,$is_moderate_ratio
    normalization_mode={{*}?!!{*,n}:$2}
    posx,posy,sizx,sizy={0,[0,0,w,h]}
    is_bottom_text,wait_event,mx,my,omb=0,1,-1,-1,0
    xsel0,ysel0,xsel1,ysel1,notification=
    wnormalization0={*,n}
    fontsize,fontsize_notif=

    if $is_multiview" && "!${-is_macos}
      if d==2 if {*,u}/w>={*,v}/h wsiz0={r={*,u}*0.48;round([r,r*h/w])} else wsiz0={r={*,v}*0.40;round([r*w/h,r])} fi
      elif d<=4 wsiz0=${fitscreen\ .,,45%}
      else wsiz0=${fitscreen\ .,,30%}
      fi
      wsiz0=${fitscreen\ $wsiz0,90%}
    else wsiz0=${fitscreen\ .}
    fi

    if $is_multiview
      if narg($_d2d_names) l[] { $_d2d_names repeat $! { wname$>={$>,t} } rm } fi
      com_iskey,com_flushkey,com_isvisible,com_isresized,com_idisp,sep=
      repeat {img,d} {
        if narg($_d2d_names) w$>[] {{*$>,w}?[-1,-1]:[$wsiz0]},0,${wname$>}" ("{w}x{h}x{d}x{s}")"
        else w$>[] {{*$>,w}?[-1,-1]:[$wsiz0]},0,$nm" ("{w}x{h}x{d}x{s}")-#"$>
        fi
        com_iskey.=$sep"{*"$>",$""1}"
        com_flushkey.=$sep"{*"$>",-$""1}"
        com_isvisible.=$sep"{*"$>"}"
        com_isresized.=$sep"{*"$>",r}"
        com_idisp.=$sep"{*"$>",x}"
        sep=,
      }
      m "iskey : u {max("$com_iskey")}"\n\
        "flushkey : skip "$com_flushkey\n\
        "isvisible : u {min("$com_isvisible")}"\n\
        "isresized : u {max("$com_isresized")}"\n\
        "idisp : u {argmax("$com_idisp")}"

      # Auto-arrange display window layout in multi-view mode.
      if !${-is_macos}
        ww,wh={[$wsiz0]+[8,40]}
        if d==2
          if {*,u}/$ww>{*,v}/$wh # Horizontal alignment
            ox,oy={round([max(0,{*,u}-2*$ww),max(0,{*,v}-$wh)]/2)}
            w0[] -1,-1,-1,-1,$ox,$oy
            w1[] -1,-1,-1,-1,{$ox+$ww},$oy
          else # Vertical alignment
            ox,oy={round([{*,u}-$ww,{*,v}-2*$wh]/2)}
            w0[] -1,-1,-1,-1,$ox,$oy
            w1[] -1,-1,-1,-1,$ox,{$oy+$wh}
          fi
        elif d<=4
          ox,oy={round([max(0,{*,u}-2*$ww),max(0,{*,v}-2*$wh)]/2)}
          ww,wh+=$ox,$oy
          w0[] -1,-1,-1,-1,$ox,$oy
          w1[] -1,-1,-1,-1,$ww,$oy
          w2[] -1,-1,-1,-1,$ox,$wh
          if d==4 w3[] -1,-1,-1,-1,$ww,$wh fi
        else
          ox,oy={round([max(0,{*,u}-3*$ww),max(0,{*,v}-(d>6?3:2)*$wh)]/2)}
          ww2,wh2={2*[$ww,$wh]+[$ox,$oy]}
          ww,wh+=$ox,$oy
          w0[] -1,-1,-1,-1,$ox,$oy
          w1[] -1,-1,-1,-1,$ww,$oy
          w2[] -1,-1,-1,-1,$ww2,$oy
          w3[] -1,-1,-1,-1,$ox,$wh
          w4[] -1,-1,-1,-1,$ww,$wh
          if d>5 w5[] -1,-1,-1,-1,$ww2,$wh fi
          if d>6 w6[] -1,-1,-1,-1,$ox,$wh2 fi
          if d>7 w7[] -1,-1,-1,-1,$ww,$wh2 fi
          if d>8 w8[] -1,-1,-1,-1,$ww2,$wh2 fi
        fi
      fi

    else
      w[] {{*,w}?[-1,-1]:[$wsiz0]},0,$nm" ("{w}x{h}x{d}x{s}")"
      m "iskey : u {*,$""1}"\n\
        "flushkey : skip {*,-$""1}"\n\
        "isvisible : u {*}"\n\
        "isresized : u {*,r}"\n\
        "idisp : u 0"
    fi

    repeat {img,d} { cursor[$>] 0 }

    # Start event loop.
    for ${-isvisible}" && "!${"iskey ESC"}" && "!((${"iskey CTRLLEFT"}" || "${"iskey CTRLRIGHT"})" && "${"iskey W"}) {

      # Correct aspect ratio while centering image.
      if $ratio_mode" && "$sizx>16" && "$sizy>16
        nposx,nposy,nsizx,nsizy=$posx,$posy,$sizx,$sizy
        repeat 2 {
          if {*,w}/$sizx<{*,h}/$sizy
            nposy,nsizy={nsizy=$nsizx*{*,h}/{*,w};round([$nposy-(nsizy-$nsizy)/2,nsizy])}
          else
            nposx,nsizx={nsizx=$nsizy*{*,w}/{*,h};round([$nposx-(nsizx-$nsizx)/2,round(nsizx)])}
          fi
          if $<" && "$nsizx>w#0" && "$nsizy>h#0 nposx,nposy,nsizx,nsizy={[0,0,w#0,h#0]} fi
        }
        if [$nposx,$nposy,$nsizx,$nsizy]!=[$posx,$posy,$sizx,$sizy]
          posx,posy,sizx,sizy=$nposx,$nposy,$nsizx,$nsizy
          rmn baseview
        fi
      fi

      # Generate baseview.
      if !narg($baseview)

        # Get view corresponding to position and zoom factor.
        ($posx,{$posx+$sizx}) ($posy;{$posy+$sizy}) r[-2,-1] 2,2 a[-2,-1] c
        r. {[{*,w,h}]+1},1,2,3 z. 0,0,{[w,h]-2} round. 1,-1 ind_warp={$!-1}
        +channels[0] {0,[0,min(3,s-1)]} warp. ..,0,0,1
        if $is_multiview repeat {img,d-1} { +slices[img] {1+$>} warp. [$ind_warp],0,0,1 } a[-{img,d}--1] z fi
        rm..

        if s>($alpha_mode?4:3) channels. 0,{$alpha_mode?3:2} fi # Discard useless channels

        # Check if image potentially contain inf or nan values.
        +r[0] 1,1,1,1,2 is_infnan={isnan(i)||isinf(i)} rm.

        if $normalization_mode
          if $is_infnan
            # Find min and max values that are not nan of inf.
            eval[0] "*begin(m = inf; M = -inf);
              !isinf(i) && !isnan(i)?(m = min(i,m); M = max(i,M));
              end(
                merge(m,min);
                merge(M,max);
                run('im,iM=',m,',',M)
              )"
            vim,viM={[$im-abs($im),$iM+abs($iM)]}
            f. "isnan(i)?"$vim":isinf(i)?(i<0?"$vim":"$viM"):i"
          else
            im,iM={0,[im,iM]}
          fi

        else
          im,iM=0,255
          if $is_infnan f. "isnan(i)?"$im":isinf(i)?(i<0?"$im":"$iM"):i" fi
        fi

        # Normalize view.
        if $normalization_mode==1
          sh. 0,{s-($alpha_mode" && "$may_have_alpha?2:1)}
          if $is_multiview repeat {img,d} { +slices. $> n. 0,255 j.. .,0,0,$> rm. } else n. 0,255 fi
          rm.
        elif $normalization_mode==2
          sh. 0,{s-($alpha_mode" && "$may_have_alpha?2:1)}
          if $is_multiview repeat d*s { z,c={[$>%d,int($>/d)]} sh. $z,$z,$c n. 0,255 rm. }
          else repeat s { sh. $> n. 0,255 rm. }
          fi
          rm.
        fi
        if $posx<0" || "$posy<0" || "$posx+$sizx>=w#0" || "$posy+$sizy>=h#0
          100%,100%
          rectangle. {A=-[$posx,$posy]*[w,h]/[$sizx,$sizy];\
                      B=A+[w#0,h#0]*[w,h]/[$sizx,$sizy]-1;\
                      [ceil(A),floor(B)]},1,1
          *[-2,-1]
        fi

        # Add alpha channel if necessary.
        if $alpha_mode
          coords={A=-[$posx,$posy]*[w,h]/[$sizx,$sizy];\
                  B=A+[w#0,h#0]*[w,h]/[$sizx,$sizy]-1;\
                  [ceil(A),floor(B)]}
          if !$may_have_alpha # Alpha mode without alpha channel -> Add alpha channel
            100%,100%,1,1,64 rectangle. $coords,1,255 r. 100%,100%,.. a[-2,-1] c
          else # Alpha mode with alpha channel
            sh. 100% 100%,100%,1,1,64 rectangle. $coords,1,0 r. 100%,100%,.. +[-2,-1] rm.
          fi
        fi

        # Render image with transparency pattern.
        if $alpha_mode
          (128,160;160,128) r. 32,32,1,{-2,s-1} r. ..,..,..,100%,0,2,0.5,0.5 sh.. 100% j.. ...,0,0,0,0,1,.,255 rm[-3,-1]
        elif s==1 r. 100%,100%,100%,3
        elif s==2 r. 100%,100%,100%,3,0
        fi
        => baseview
        rmn view
      fi

      # Manage notifications.
      if narg($notification)
        wait_event=0
        if !isnum($notification) # Create notification gfx
          rmn notification_gfx
          ofs,fs={narg($fontsize_notif)?0$fontsize_notif:32}
          do
            0 t. {``$notification},0,0,$fs,1,255
            if narg($fontsize_notif) break
            elif {baseview,"(w#-1>0.7*w || h#-1>0.25*h) && "$fs>13" && "$ofs>=$fs}
              ofs,fs=$fs,{max(13,round($fs/1.25))} rm.
            elif {baseview,"w#-1<0.3*w && h#-1<0.25*h && "$fs<64" && "$ofs<=$fs}
              ofs,fs=$fs,{min(64,round($fs*1.25))} rm.
            else
              fontsize_notif=$fs break
            fi
          while 1

          r. {[w+12,h+8]},1,1,0,0,0.5,0.5 rectangle. 0,0,100%,100%,1,0xFFFFFFFF,255 to_rgb.
          => notification_gfx
          notification=$|
        else
          if $|>$notification+1 rm[notification_gfx] wait_event=1 notification= fi
          rmn view
        fi
      fi

      # Generate view.
      if !narg($view)
        [baseview]
        if $mx>=0
          posmx,posmy={floor([$posx,$posy]+[$mx,$my]*[$sizx,$sizy]/[{*,w,h}])}
          is_selection_a_point={[0$xsel0,0$ysel0]==[0$xsel1,0$ysel1]}

          if narg($xsel0)" && "!$is_selection_a_point
            dselx,dsely={[$xsel1-$xsel0,$ysel1-$ysel0]}
            ofs,fs={narg($fontsize)?0$fontsize:32}
            do
              0 t. " Box ( "{``{[min($xsel0,$xsel1),min($ysel0,$ysel1)]}}" ) - "\
                   "( "{``{[max($xsel0,$xsel1),max($ysel0,$ysel1)]}}" ) \n"\
                   " Size = ( "{``{abs([$dselx,$dsely]+1)}}" ), "\
                   "Length = "{_norm($dselx,$dsely)}" \n"\
                   " Angle = "{_atan2($dsely,$dselx)*180/pi}"\260 ",1,0,$fs,1,1
              if narg($fontsize) break
              elif {baseview,"(w#-1>0.7*w || h#-1>0.45*h) && "$fs>13" && "$ofs>=$fs}
                ofs,fs=$fs,{max(13,round($fs/1.25))} rm.
              elif {baseview,"w#-1<0.3*w && h#-1<0.45*h && "$fs<64" && "$ofs<=$fs}
                ofs,fs=$fs,{min(64,round($fs*1.25))} rm.
              else
                fontsize=$fs break
              fi
            while 1
            n. 0,255 +dilate. 3 *. -1 n. 0,80 +[-2,-1] r. 100%,100%,..,..
            j.. .,0,$is_bottom_text~,0,0,0.85 rm.
          fi

          if $mx>=0
            if $posmx>=0" && "$posmx<w#0" && "$posmy>=0" && "$posmy<h#0
              if !narg($xsel0)" || "$is_selection_a_point
                repeat {img,d} {
                  if {img,P=I($posmx,$posmy,$>);(s>=1" || "s<=4)" && "min(isint(P))" && "min(P)>=0" && "max(P)<=255}
                    hexstr="= \#"\
                          {img,`"digit(x) = (x<10?_'0' + x:_'A' + x - 10);\
                                 P = I("$posmx,$posmy,$>");\
                                 [ digit(P[0]>>4),digit(P[0]&15),\
                                   s<2?0:digit(P[1]>>4),s<2?0:digit(P[1]&15),\
                                   s<3?0:digit(P[2]>>4),s<3?0:digit(P[2]&15),\
                                   s<4?0:digit(P[3]>>4),s<4?0:digit(P[3]&15) ]"`}" "
                  else hexstr= fi
                  ofs,fs={narg($fontsize)?0$fontsize:32}
                  do
                    0 t. " Point ( "$posmx","$posmy" ) = [ "${_d2d_format\ {img,_I($posmx,$posmy,$>)}}" ] "$hexstr,\
                         1,0,$fs,1,1
                    if narg($fontsize) break
                    elif {baseview,"(w#-1>0.7*w || h#-1>0.15*h) && "$fs>13" && "$ofs>=$fs}
                      _ofs,fs=$fs,{max(13,round($fs/1.25))} rm.
                    elif {baseview,"w#-1<0.3*w && h#-1<0.15*h && "$fs<64" && "$ofs<=$fs}
                      ofs,fs=$fs,{min(64,round($fs*1.25))} rm.
                    else
                      fontsize=$fs break
                    fi
                  while 1

                  n. 0,255 +dilate. 3 *. -1 n. 0,80 +[-2,-1] r. 100%,100%,1,..
                  j.. .,0,$is_bottom_text~,$>,0,0.85 rm.
                }
              fi
              x0,y0,x1,y1={[round([$posmx-$posx,$posmy-$posy]*[{*,w,h}]/[$sizx,$sizy]),\
                            round([$posmx-$posx+1,$posmy-$posy+1]*[{*,w,h}]/[$sizx,$sizy])-1]}
              if $x1-$x0>=8" && "$y1-$y0>=8 # Draw pixel contour when zoomed-in
                repeat d==1?1:d*s {
                  if d==1 sh. else sh. {z=$>%d;[z,z,int($>/d)]} fi
                  rectangle. $x0,$y0,$x1,$y1,1,0x55555555,0
                  rectangle. $x0,$y0,$x1,$y1,1,0xAAAAAAAA,255
                  rm.
                }
              fi
            fi
            if $axes_mode # Draw horizontal/vertical axes
              repeat d==1?1:d*s {
                if d==1 sh. else sh. {z=$>%d;[z,z,int($>/d)]} fi
                line. $mx,0,$mx,100%,0.5,0xFF00FF00,255
                line. $mx,0,$mx,100%,0.5,0x00FF00FF,0
                line. 0,$my,100%,$my,0.5,0xFF00FF00,255
                line. 0,$my,100%,$my,0.5,0x00FF00FF,0
                rm.
              }
            fi
          fi

          if narg($xsel0) # Draw rectangular selection
            x0,y0,x1,y1={xm=min($xsel0,$xsel1);xM=max($xsel0,$xsel1);\
                         ym=min($ysel0,$ysel1);yM=max($ysel0,$ysel1);\
                         [[xm-$posx,ym-$posy]*[{*,w,h}]/[$sizx,$sizy],\
                          [xM+1-$posx,yM+1-$posy]*[{*,w,h}]/[$sizx,$sizy]-1]}
            repeat d==1?1:d*s {
              if d==1 sh. else sh. {z=$>%d;[z,z,int($>/d)]} fi
              rectangle. $x0,$y0,$x1,$y1,0.2,0
              rectangle. $x0,$y0,$x1,$y1,0.9,0x55555555,0
              rectangle. $x0,$y0,$x1,$y1,0.9,0xAAAAAAAA,255
              rm.
            }
            if $xsel0>$xsel1 x0,x1=$x1,$x0 fi
            if $ysel0>$ysel1 y0,y1=$y1,$y0 fi
            if $xsel0!=$xsel1" && "$ysel0!=$ysel1
              x0,y0,x1,y1={[(0.5+[$xsel0-$posx,$ysel0-$posy])*[{*,w,h}]/[$sizx,$sizy],\
                            (0.5+[$xsel1-$posx,$ysel1-$posy])*[{*,w,h}]/[$sizx,$sizy]]}
              repeat d==1?1:d*s {
                if d==1 sh. else sh. {z=$>%d;[z,z,int($>/d)]} fi
                line. $x0,$y0,$x1,$y1,0.9,0x33333333,0
                line. $x0,$y0,$x1,$y1,0.9,0xCCCCCCCC,255
                rm.
              }
            fi
          fi
        fi

        if $notification_gfx
          +r[notification_gfx] 100%,100%,. j.. .,{[w#-2-w-4,4]},0,0,{sqrt(max(0,1-($|-$notification)))} rm.
        fi

        => view
        if $is_multiview repeat d { +slices[view] $> w$>. rm. } else w. fi
      fi

      # Manage user events.
      if $wait_event wait else wait 40 fi
      idisp=${-idisp} # Index of 'active' display window
      wait_event=1

      old_mx,old_my=$mx,$my
      nposx,nposy,nsizx,nsizy=$posx,$posy,$sizx,$sizy
      is_CTRL,mb,mx,my,mo={${"iskey CTRLLEFT"}" || "${"iskey CTRLRIGHT"}},{*$idisp,b,x,y,-o}

      # Test end of pan shift.
      if !($mb&4)" && "!($is_CTRL" && "($mb&1)) pan_mx,pan_my,pan_posx,pan_posy= fi

      # Test if text must be displayed at the bottom.
      if {view,$my<0" || "$my>=h-16} is_bottom_text=0
      elif $my<16 is_bottom_text=1
      fi

      # Events related to window resizing.
      if ${-isresized} # One of the display windows has been resized
        repeat {img,d} {
          w=$> if {*$w,r}
            w$w[] {*$w,d,e}
            if $is_multiview repeat {img,d} { w$>[] {*$w,w,h} } fi
            if $nsizx>w#0" && "$nsizy>h#0 nposx,nposy,nsizx,nsizy={[0,0,w#0,h#0]} fi
            break
          fi
        }
        fontsize,fontsize_notif=
        rmn baseview
      elif $is_CTRL" && "${"iskey D"}" && "{*$idisp,d}<{*$idisp,u}" && "{*$idisp,e}<{*$idisp,v} # Increase window size
        w$idisp[] {round([{*$idisp,w,h}]*1.25)}
        if $is_multiview repeat {img,d} { w$>[] {*$idisp,w,h} } fi
        notification="Increase Window Size"
        fontsize,fontsize_notif=
        flushkey D rmn baseview
      elif $is_CTRL" && "${"iskey C"}" && "{*$idisp,d}>64" && "{*$idisp,e}>64 # Decrease window size
        w$idisp[] {round([{*$idisp,w,h}]/1.25)}
        if $is_multiview repeat {img,d} { w$>[] {*$idisp,w,h} } fi
        notification="Decrease Window Size"
        fontsize,fontsize_notif=
        flushkey C rmn baseview
      elif $is_CTRL" && "${"iskey R"} # Reset window size (and view)
        nposx,nposy,nsizx,nsizy={0,[0,0,w,h]}
        repeat {img,d} { w$>[] $wsiz0 }
        notification="Reset Window Size"
        fontsize,fontsize_notif=
        flushkey R rmn baseview
      fi

      # Events related to image selection.
      if !$is_CTRL" && "$mb&1" && "$mx>0
        xsel,ysel={X=[$nposx,$nposy]+[$mx,$my]*[$nsizx,$nsizy]/[{*,w,h}];\
                   floor([max(0,min(X[0],w#0-1)),max(0,min(X[1],h#0-1))])}
        if !narg($xsel0)" && "!($omb&1) xsel0,ysel0,xsel1,ysel1=$xsel,$ysel,$xsel,$ysel
        elif narg($xsel0) xsel1,ysel1=$xsel,$ysel
        fi
        if $mx<=16 nposx-={$nsizx/64} wait_event=0 xzoom,yzoom=
        elif $mx>={*,w}-17 nposx+={$nsizx/64} wait_event=0 xzoom,yzoom=
        fi
        if $my<=16 nposy-={$nsizy/64} wait_event=0 xzoom,yzoom=
        elif $my>{*,h}-17 nposy+={$nsizx/64} wait_event=0 xzoom,yzoom=
        fi
        wait_event=0
        rmn view
      elif !($mb&1)
        if narg($xsel0)

          if "p0 = ["$xsel0,$ysel0]"; p1 = ["$xsel1,$ysel1"];  # One px selection -> reset view or exit
              siz = max("$sizx,$sizy");
              p0==p1 || (siz>128 && norm1(p1-p0)<=siz/100)"
            if $1" && "$nsizx>=w#0" && "$nsizy>=h#0 break fi
            nposx,nposy,nsizx,nsizy={0,[0,0,w,h]}
          else # Otherwise, zoom in
            nposx,nposy,nsizx,nsizy={[min($xsel0,$xsel1),min($ysel0,$ysel1),abs([$xsel1-$xsel0,$ysel1-$ysel0])+1]}
          fi
          xzoom,yzoom= mb={$mb&6}
          rmn view
        fi
        xsel0,ysel0,xsel1,ysel1=
      fi

      # Events related to image displacement and mode changes.
      if ${"iskey ARROWLEFT"} nposx-={$nsizx/($is_CTRL?4:16)} xzoom,yzoom= # Go left
      elif ${"iskey ARROWRIGHT"} nposx+={$nsizx/($is_CTRL?4:16)} xzoom,yzoom= # Go right
      elif ${"iskey ARROWUP"} nposy-={$nsizy/($is_CTRL?4:16)} xzoom,yzoom= # Go up
      elif ${"iskey ARROWDOWN"} nposy+={$nsizy/($is_CTRL?4:16)} xzoom,yzoom= # Go down
      elif $is_CTRL" && "${"iskey O"} # Save copy
        n=0 do filename gmic.gmz,$n n+=1 while isfile(['{/${}}'])
        if $is_multiview +slices[img] $idisp o. ${} rm. else o[img] ${} fi
        notification="Save Copy:\n"${}
        flushkey O
      elif $is_CTRL" && "${"iskey S"} # Save screenshot
        n=0 do filename gmic.png,$n n+=1 while isfile(['{/${}}'])
        if $is_multiview +slices[baseview] $idisp o. ${} rm. else o[baseview] ${} fi
        notification="Save Screenshot:\n"${}
        flushkey S
      elif $is_CTRL" && "${"iskey SPACE"} # Center view
        nposx,nposy,nsizx,nsizy={0,[0,0,w,h]}
        notification="Center View"
        flushkey SPACE
      elif $is_CTRL" && "${"iskey N"} # Change normalization mode
        normalization_mode={($normalization_mode+1)%3}
        notification=${"s0=Disable s1=Enable s2=\"Enable C.by.C\" u ${s"$normalization_mode"}"}" Normalization"
        flushkey N rmn baseview
      elif $is_CTRL" && "${"iskey A"} # Toggle alpha mode
        alpha_mode={!$alpha_mode}
        notification=${"s0=Disable s1=Enable u ${s"$alpha_mode"}"}" Alpha"
        flushkey A rmn baseview
      elif $is_CTRL" && "${"iskey F"} # Toggle fullscreen mode
        fullscreen_mode={!$fullscreen_mode}
        if $fullscreen_mode
          fullscreen_wsize={*,w,h} fullscreen_params=$nposx,$nposy,$nsizx,$nsizy
          w[] {*,u,v},0,1
        else
          nposx,nposy,nsizx,nsizy=$fullscreen_params
          w[] $fullscreen_wsize,0,0
        fi
        repeat {img,d} { cursor[$>] {!$axes_mode} }
        notification=${"s0=Disable s1=Enable u ${s"$fullscreen_mode"}"}" Fullscreen"
        flushkey F rmn baseview
      elif $is_CTRL" && "${"iskey X"} # Toggle axes mode
        repeat {img,d} { cursor[$>] $axes_mode } axes_mode={!$axes_mode}
        notification=${"s0=Hide s1=Show u ${s"$axes_mode"}"}" Axes"
        flushkey X rmn view
      elif $is_CTRL" && "${"iskey Z"}" && "$is_moderate_ratio # Toggle aspect-ratio mode
        ratio_mode={!$ratio_mode}
        notification=${"s0=Release s1=Hold u ${s"$ratio_mode"}"}" Aspect Ratio"
        if !$ratio_mode nposx,nposy,nsizx,nsizy={0,[0,0,w,h]} fi
        flushkey Z rmn baseview
      elif $mx>=0" && "($mb&4" || "($is_CTRL" && "$mb&1)) # Pan (middle mouse button)
        if !narg($pan_mx) pan_mx,pan_my,pan_posx,pan_posy=$mx,$my,$posx,$posy fi
        nposx,nposy={shiftx=($mx-$pan_mx)*$nsizx/{*,w};\
                     shifty=($my-$pan_my)*$nsizy/{*,h};\
                     [$pan_posx-shiftx,$pan_posy-shifty]}
        xzoom,yzoom=
      elif ${"iskey PADSUB"}" || "($mx>=0" && "$mo<0) # Zoom out
        if $nsizx>=w#0" && "$nsizy>=h#0
          nposx,nposy,nsizx,nsizy={[$nposx/2,$nposy/2,w#0,h#0]}
        else
          if !narg($xzoom)
            xzoom,yzoom={X=$mx<0?[$nposx,$nposy]+[$nsizx,$nsizy]/2:\
                           [$nposx,$nposy]+[$mx,$my]*[$nsizx,$nsizy]/[{*,w,h}];\
                   [max(0,min(X[0],w#0-1)),max(0,min(X[1],h#0-1))]}
          fi
          nposx,nposy,nsizx,nsizy={[[$xzoom,$yzoom]+[$nposx-$xzoom,$nposy-$yzoom]/0.75,\
                                   min(w#0,round($nsizx/0.75)),\
                                   min(h#0,round($nsizy/0.75))]}
          if $nsizx>w#0" && "$nsizy>h#0 nsizx,nsizy={[w#0,h#0]} fi
        fi
      elif ($nsizx>2" || "$nsizy>2)" && "(${"iskey PADADD"}" || "($mx>=0" && "$mo>0)) # Zoom in
        xzoom,yzoom={X=$mx<0?[$nposx,$nposy]+[$nsizx,$nsizy]/2:\
                             [$nposx,$nposy]+[$mx,$my]*[$nsizx,$nsizy]/[{*,w,h}];\
               [max(0,min(X[0],w#0-1)),max(0,min(X[1],h#0-1))]}
        nposx,nposy,nsizx,nsizy={[[$xzoom,$yzoom]+0.75*[$nposx-$xzoom,$nposy-$yzoom],round(0.75*[$nsizx,$nsizy])]}
      fi

      # Constrain image displacement.
      if $nposx>=w#0-0.5*$nsizx nposx={w#0-1-0.5*$nsizx}
      elif $nposx<=-0.5*$nsizx nposx={1-0.5*$nsizx}
      fi
      if $nposy>=h#0-0.5*$nsizy nposy={h#0-1-0.5*$nsizy}
      elif $nposy<=-0.5*$nsizy nposy={1-0.5*$nsizy}
      fi

      if [$nposx,$nposy,$nsizx,$nsizy]!=[$posx,$posy,$sizx,$sizy]
        posx,posy,sizx,sizy=$nposx,$nposy,$nsizx,$nsizy
        rmn baseview
      fi
      if [$mx,$my]!=[$old_mx,$old_my] rmn view fi
      omb=$mb

    }
    k[0]
    if narg($_d2d_core) w[] -1,-1,$wnormalization0
    else
      if $is_multiview repeat d { w$>[] 0 } else w[] 0 fi
    fi
    => $nm um iskey,flushkey,isvisible,isresized,idisp
  }
  um _d2d_format v -1 d[]

dp :
  _gmic_s="$?" v + _display_parallel 1

display_parallel :
  _gmic_s="$?" v + _$0 1

# $1 = Normalization used for display window.
_display_parallel : check ${1=0}>=0
  e[0--3] "Display image$? in parallel."
  print
  is_d2d_compatible={"res = l<=10; repeat (l,k, res&=(w#k==w && h#k==h && d#k==1 && s#k==s))"}
  if $is_d2d_compatible
    N=$!
    repeat $! {
      if s=['{$>,n}'];find(s,_'.',size(s)-1,-1)>0 nm={$>,b}.{$>,x} else nm={$>,b} fi
      ('$nm':;)
    }
    store[-$N--1] _d2d_names
    a z _display2d 0,$1 s z
    _d2d_names=
  else
    if $!<=1 v - d v + return fi
    14,$! eval. "!x?copy(i(),[[',d['],v2s(y,10,10),_']'])" =. 0 discard. 0 str={t} rm.
    m "__dp : parallel "$str __dp um __dp
  fi
  v -1 d[]

dp0 :
  _gmic_s="$?" v + _display_parallel 0

display_parallel0 :
  _gmic_s="$?" v + _display_parallel 0

default_display :
  _gmic_s="$?" v + _display "",1,$[]

# d3d : eq. to 'display3d'.
d3d : skip "${1=},${2=0}"
  l[] { is_image_arg=${"is_image_arg $1"} is_arg={$is_image_arg" || isnum($1)"} onfail is_arg=0 }
  if $is_arg arg=$is_image_arg,$2 if $is_image_arg pass$1 1 _d3d_wh={[w,h]} store. _d3d_background fi
  else arg=0,0 noarg fi
  v + _display3d $arg

# display3d : _[background_image],_exit_on_anykey={ 0 | 1 } : _exit_on_anykey={ 0 | 1 }
# : Display selected 3D objects in an interactive viewer (use the instant display window [0] if opened).
# : (eq. to 'd3d').
# : Default values: '[background_image]=(default)' and 'exit_on_anykey=0'.
display3d : skip "${1=},${2=0}"
  l[] { is_image_arg=${"is_image_arg $1"} is_arg={$is_image_arg" || isnum($1)"} onfail is_arg=0 }
  if $is_arg arg=$is_image_arg,$2 if $is_image_arg pass$1 1 _d3d_wh={[w,h]} store. _d3d_background fi
  else arg=0,0 noarg fi
  v + _$0 $arg

# $1 = is_user_background?
# $2 = exit_on_any_key?
_display3d :
  is_user_background,exit_on_anykey=$1,$2
  if !$! e[0--3] "Display 3D object []." return fi
  foreach {
    l. { check3d 1 onfail l[] { ({'${}'}) s +,{'"'check3d': "'} k. msg={t} rm } error[] "Command 'display3d': "$msg }
    nm={n} bnm={b} l. { if ['{x}']!=0 bnm.=.{x} fi onfail bnm.=.{x} }
    nbv,nbp:=f2ui([i[6],i[7]])
    e[0--4] "Display 3D object ["{arg(1+$>,$[])}"] = '"$nm"' ("$nbv" vertices, "$nbp" primitives)."

    # Init display window and variables.
    if ['$_d3d_title']==0 disp_title=$bnm" ("$nbv" vertices, "$nbp" primitives)" else disp_title=$_d3d_title fi
    if !{*}
      if narg($_d3d_wh) w[] ${fitscreen\ $_d3d_wh,128,1024},0,$disp_title
      else w[] ${fitscreen\ {[0.5,0.6]*[{*,u,v}]},128,1024},0,$disp_title
      fi
    else disp_normalization={*,n} w[] -1,-1,0,$disp_title fi
    disp_size0={*,w,h}

    (1,0,0,0;0,1,0,0;0,0,1,0) store. pose3d
    posx,posy,zoom_factor=50,50,1
    is_fullscreen,is_zbuffer,is_axes3d,is_outline,is_boundingbox,is_animate,is_outvideo={*,f},1,1,0,0,0,0
    mode_render:=isint($_mode3d)?$_mode3d:4
    mode_drender:=isint($_moded3d)?$_moded3d:-1
    mode_background={$is_user_background?7:5}
    mode_orientation:=!isbool($_double3d)?2:$_double3d==1?2:0;
    mode_animate=1
    speed_animate=1
    focale:=isnum($_focale3d)?$_focale3d:800
    mx0,my0,mx1,my1=
    notification= fontsize_notif=
    wait_event=1

    # Create 3D axes.
    axes3d 40,40,40,20,X,Y,Z,0 col3d. 0,255,0 l. { s3d a[0-3] y off_axes={0,h} a y } => axes3d

    # Start interactive loop.
    do
      is_motion={narg($mx0)}
      if $is_animate" || "$is_outvideo rmn render fi

      # Init background image.
      if !narg($background)
        if $mode_background<3 {*,w,h},1,3,{arg(1+$mode_background,0,255,128)}
        elif $mode_background==3 3,2,1,1,"16,16,48,44,96,76" permute. cyzx r. {*,w,h},1,3,3 round.
        elif $mode_background==4 3,2,1,1,"0,0,0,0,64,96" permute. cyzx r. {*,w,h},1,3,3 round.
        elif $mode_background==5 3,3,1,1,"0,0,0,0,0,100,100,0,50" permute. cyzx r. {*,w,h},1,3,3 round.
        elif $mode_background==6 2,2,1,1,110,90,90,110 r. 64,64,1,3 r. {*,w,h},1,3,0,2,0.5,0.5
        else $_d3d_background r. {*,w,h},1,3,1
        fi
        w. => background
        rmn object3d
      fi

      # Init normalized 3D object.
      if !narg($object3d)
        +c3d[0] n3d. *3d. {background,$zoom_factor*0.65*min(w,h)}
        if $mode_orientation==1 rv3d. fi
        rmn boundingbox3d
        if $is_boundingbox +boundingbox3d. o3d. 0.2 => boundingbox3d +3d.. . rv[-2,-1] fi
        => object3d
        rmn render
      fi

      # Render 3D object.
      if !narg($render)
        $pose3d
        if $is_animate" || "$is_outvideo l. {
          da={$speed_animate*($is_animate?20*($|-$time_animate):1)}
          if $mode_animate==0 rotation3d 1,0,0,$da rv
          elif $mode_animate==1 rotation3d 0,1,0,$da rv
          elif $mode_animate==2 rotation3d 0,0,1,$da rv
          else
            dax,day,daz={[0.75,0.82,0.97]*$da}
            rotation3d 0,1,0,$dax rotation3d 1,0,0,$day rotation3d 0,0,1,$daz rv
          fi
          m* 1,3,1,1 j.. .,3 rm. +store. pose3d
          time_animate=$|
        } fi
        p={^} rm.
        m={$is_motion?$mode_drender:$mode_render}
        [background] => render
        if $m<0
          if !narg($boundingbox3d) +boundingbox3d[object3d] o3d. 0.35 => boundingbox3d fi
          +pose3d[boundingbox3d] $p
          j3d[render] .,$posx%,$posy%,0,1,1,0,0,$focale rm.
        else
          +pose3d[object3d] $p
          if $is_outline
            {render,[w,h]},1,3,-1
            j3d. ..,$posx%,$posy%,0,1,$m,{$mode_orientation==2},$is_zbuffer,$focale
            +channels. 0 !=. -1
            +dilate. 5 r. 100%,100%,1,3 j[render] .,0,0,0,0,0.8,. rm.
            j[render] ..,0,0,0,0,1,. rm[-2,-1]
          else
            j3d[render] .,$posx%,$posy%,0,1,$m,{$mode_orientation==2},$is_zbuffer,$focale
          fi
          rm.
        fi
        if $is_axes3d
          +pose3d[axes3d] $p
          eval " # Colorize axes depending on their Z-sign
            const off = "$off_axes";
            ref([ 255,0,0 ],col);
            i[13]>0?copy(i[off],col,3);
            i[19]>0?copy(i[off + 3],col,3);
            i[25]>0?copy(i[off + 6],col,3);
          "
          j3d[render] .,50,{-2,h-50},0,0.75,1,0,0,150 rm.
        fi
        rmn view

        if $is_outvideo
          o[render] $filename_outvideo,20,0,1
          nb_frames={int(360/$speed_animate)}
          if $is_outvideo>=$nb_frames
            o[] $filename_outvideo,20,0,0 # Close video stream
            is_outvideo=0
            notification="Output Video:\nDone!"
          else
            is_outvideo+=1
            notification="Output Video:\nFrame "{$is_outvideo-1}/$nb_frames
          fi
        fi
      fi

      # Manage notifications.
      if narg($notification)
        wait_event=0
        if !isnum($notification) # Create notification gfx
          rmn notification_gfx
          ofs,fs={narg($fontsize_notif)?0$fontsize_notif:32}
          do
            0 t. {``$notification},0,0,$fs,1,255
            if narg($fontsize_notif) break
            elif {background,"(w#-1>0.7*w || h#-1>0.25*h) && "$fs>13" && "$ofs>=$fs}
              ofs,fs=$fs,{max(13,round($fs/1.25))} rm.
            elif {background,"w#-1<0.3*w && h#-1<0.25*h && "$fs<64" && "$ofs<=$fs}
              ofs,fs=$fs,{min(64,round($fs*1.25))} rm.
            else
              fontsize_notif=$fs break
            fi
          while 1
          r. {[w+12,h+8]},1,1,0,0,0.5,0.5 rectangle. 0,0,100%,100%,1,0xFFFFFFFF,255 to_rgb.
          => notification_gfx
          notification=$|
        else
          if $|>$notification+1 rm[notification_gfx] wait_event=1 notification= fi
          rmn view
        fi
      fi

      # Refresh window view.
      if !narg($view)
        if $notification_gfx
          +j[render] [notification_gfx],0.99~,5,0,0,{sqrt(max(0,1-($|-$notification)))}
        else [render]
        fi
        => view w. -1,-1,0,$is_fullscreen,$disp_title
      fi

      if $is_motion" || "$is_animate wait_event=0 fi
      if $wait_event wait elif !$is_outvideo wait 20 fi

      # Manage user-events
      if $exit_on_anykey" && "{*,k} break fi
      if $is_outvideo continue fi # Skip user event management
      mx,my,mb={*,x,y,b}
      is_CTRL={{*,CTRLLEFT}" || "{*,CTRLRIGHT}}
      if {*,-F1} # Render: Dots
        mode_render,mode_drender={M=0;m=$mode_render;wasbbox=$mode_drender<0;[M,m!=M?(wasbbox?-1:M):(wasbbox?M:-1)]}
        notification="Render: Dots" if $mode_drender<0 notification.=" + Box" fi
        rmn render
      elif {*,-F2} # Render: Wireframe
        mode_render,mode_drender={M=1;m=$mode_render;wasbbox=$mode_drender<0;[M,m!=M?(wasbbox?-1:M):(wasbbox?M:-1)]}
        notification="Render: Wireframe" if $mode_drender<0 notification.=" + Box" fi
        rmn render
      elif {*,-F3} # Render: Flat
        mode_render,mode_drender={M=2;m=$mode_render;wasbbox=$mode_drender<0;[M,m!=M?(wasbbox?-1:M):(wasbbox?M:-1)]}
        notification="Render: Flat" if $mode_drender<0 notification.=" + Box" fi
        rmn render
      elif {*,-F4} # Render: Flat-shaded
        mode_render,mode_drender={M=3;m=$mode_render;wasbbox=$mode_drender<0;[M,m!=M?(wasbbox?-1:M):(wasbbox?M:-1)]}
        notification="Render: Flat-Shaded" if $mode_drender<0 notification.=" + Box" fi
        rmn render
      elif {*,-F5} # Render: Gouraud-shaded
        mode_render,mode_drender={M=4;m=$mode_render;wasbbox=$mode_drender<0;[M,m!=M?(wasbbox?-1:M):(wasbbox?M:-1)]}
        notification="Render: Gouraud-Shaded" if $mode_drender<0 notification.=" + Box" fi
        rmn render
      elif {*,-F6} # Render: Phong-shaded
        mode_render,mode_drender={M=5;m=$mode_render;wasbbox=$mode_drender<0;[M,m!=M?(wasbbox?-1:M):(wasbbox?M:-1)]}
        notification="Render: Phong-Shaded" if $mode_drender<0 notification.=" + Box" fi
        rmn render
      elif {*,-F7}" && "($focale>100" || "!$focale) # Decrease focale
        if !$focale focale=2000 else focale-=100 fi
        notification="Focale: "$focale
        rmn render
      elif {*,-F8}" && "$focale # Increase focale
        if $focale>=2000 focale=0 notification="Focale: Inf" else focale+=100 notification="Focale: "$focale fi
        rmn render
      elif {*,-F9} # Choose animation mode
        mode_animate={($mode_animate+1)%4}
        n0,n1,n2,n3="X-Axis","Y-Axis","Z-Axis","XYZ-Axes" notification="Animation Mode: "${n$mode_animate}
        rmn render
      elif {*,-F10} # Choose animation speed
        speed_animate={max(1,($speed_animate+1)%9)}
        notification="Animation Speed: X"$speed_animate
      elif {*,-SPACE} # Start/stop animation
        is_animate,time_animate={!$is_animate},$|
        n0,n1="Off","On" notification="Animation: "${n$is_animate}
        rmn render
      fi
      if $is_CTRL
        if {*,-A} # Show/hide 3D axes
          is_axes3d={!$is_axes3d}
          n0,n1="Off","On" notification="3D Axes: "${n$is_axes3d}
          rmn render
        elif {*,-B} # Change background
          mode_background={($mode_background+1)%($is_user_background?8:7)}
          n0,n1,n2,n3,n4,n5,n6,n7=\
            "Black","White","Gray","Gradient \#1","Gradient \#2","Gradient \#3","Checkerboard","User-Defined"
          notification="Background: "${n$mode_background}
          rmn background
        elif {*,-C}" && "{*,w}>128" && "{*,h}>128 w[] {0.8*[{*,w,h}]} # Decrease window size
          notification="Decrease Window Size" fontsize_notif=
          rmn background
        elif {*,-D}" && "{*,w}<0.8*{*,u}" && "{*,h}<0.8*{*,v} w[] {1.25*[{*,w,h}]} # Increase window size
          notification="Increase Window Size" fontsize_notif=
          rmn background
        elif {*,-F} # Toggle fullscreen
          is_fullscreen={!$is_fullscreen}
          if $is_fullscreen w[] {*,u,v} else w[] {0.75*[{*,u,v}]} fi
          n0,n1="Off","On" notification="Fullscreen: "${n$is_fullscreen} fontsize_notif=
          rmn background
        elif {*,-G} # Save object as a .obj file
          n=0 do filename gmic.obj,$n n+=1 while isfile(['{/${}}'])
          notification="Save Copy:\n"${}
          o[0] ${}
        elif {*,-L} # Show/hide outline
          is_outline={!$is_outline}
          n0,n1="Off","On" notification="Outline: "${n$is_outline}
          rmn render
        elif {*,-O} # Save object as a .gmz file
          n=0 do filename gmic.gmz,$n n+=1 while isfile(['{/${}}'])
          o[0] ${}
          notification="Save Copy:\n"${}
        elif {*,-P} # Print 3D pose on console
          $pose3d v 0 e "  > 3D Pose = [ "{^}" ]." rm.
        elif {*,-R} # Reset window
          w[] $disp_size0
          notification="Reset Window Size" fontsize_notif=
          rmn background
        elif {*,-S} # Save screenshot
          n=0 do filename gmic.png,$n n+=1 while isfile(['{/${}}'])
          o[render] ${}
          notification="Save Screenshot:\n"${}
        elif {*,-T} # Change orientation mode
          mode_orientation={($mode_orientation+1)%3}
          n0,n1,n2="Forward","Backward","Double-Sided" notification="Orientation: "${n$mode_orientation}
          if $mode_orientation rv3d[object3d] fi
          rmn render
        elif {*,-V} # Start/stop output video
          is_outvideo={!$is_outvideo}
          is_animate=0
          n=0 do filename gmic.mp4,$n n+=1 while isfile(['{/${}}'])
          filename_outvideo=${}
        elif {*,-X} # Show/hide bounding-box
          is_boundingbox={!$is_boundingbox}
          n0,n1="Off","On" notification="Bounding Box: "${n$is_boundingbox}
          rmn object3d
        elif {*,-Z} # Enable/disable Z-buffer
          is_zbuffer={!$is_zbuffer}
          n0,n1="Off","On" notification="Z-Buffer: "${n$is_zbuffer}
          rmn render
        fi
      fi
      if {*,-r} rmn background fontsize_notif= fi

      if $mx>=0 # Manage mouse-drag
        if $mb
          if !narg($mx0) mx0,my0,mx1,my1=$mx,$my,$mx,$my else mx1,my1=$mx,$my fi
        else
          if narg($mx0) rmn render fi
          mx0,my0,mx1,my1=
        fi
      fi

      # Estimate new 3D pose from motion.
      if narg($mx1)" && "($mx0!=$mx1" || "$my0!=$my1)
        rmn render
        if $mb&1" && "!$is_CTRL # Rotation
          rotation3d[] {"
            const w2 = "{*,w}"/2;
            const h2 = "{*,h}"/2;
            const R = 0.375*min("{*,w,h}");
            const u0 = "$mx0" - w2;
            const v0 = "$my0" - h2;
            const u1 = "$mx1" - w2;
            const v1 = "$my1" - h2;
            n0 = norm(u0,v0);
            nu0 = n0>R?u0*R/n0:u0;
            nv0 = n0>R?v0*R/n0:v0;
            nw0 = sqrt(max(0,R^2 - nu0^2 - nv0^2));
            n1 = norm(u1,v1);
            nu1 = n1>R?u1*R/n1:u1;
            nv1 = n1>R?v1*R/n1:v1;
            nw1 = sqrt(max(0,R^2 - nu1^2 - nv1^2));
            u = nv0*nw1 - nw0*nv1;
            v = nw0*nu1 - nu0*nw1;
            w = nv0*nu1 - nu0*nv1;
            n = norm(u,v,w);
            [ u,v,w,-asin(n/R^2)*180/pi ]"}
          $pose3d m*[-2,-1] store. pose3d
          mx0,my0=$mx1,$my1
        elif $mb&4" || "($mb&1" && "$is_CTRL) # Pan
          posx,posy={"
            const px = $mx1 - $mx0 + $posx*"{*,w}"%;
            const py = $my1 - $my0 + $posy*"{*,h}"%;
            [px,py]*100/["{*,w,h}"]"}
          mx0,my0=$mx1,$my1
        elif $mb&2 # Zoom with mouse button
          fact={1+($my0-$my1)/100}
          zoom_factor*=$fact
          *3d[object3d] $fact if narg($boundingbox3d) *3d[boundingbox3d] $fact fi
          mx0,my0=$mx1,$my1
        fi
      fi
      if {*,o} # Zoom with mousewheel
        fact={1+{*,-o}/10}
        zoom_factor*=$fact
        *3d[object3d] $fact if narg($boundingbox3d) *3d[boundingbox3d] $fact fi
        rmn render
      fi

    while {*}" && "!{*,ESC}" && "!($is_CTRL" && "{*,W})
    k[0]
  }
  if narg($disp_normalization) w[] -1,-1,$disp_normalization else w[] 0 fi
  v -1 d[]

is_percent :
  u {"s=['$1'];s[size(s)-1]==_'%'"}

dar_lib :
  u "

  # Return number of elements in dynamic array #ind.
  dar_size(ind) = i[#ind,h(#ind) - 1];

  # Return last element of a dynamic array
  dar_Back(ind) = I[#ind,dar_size(#ind) - 1];
  dar_back(ind) = i[#ind,dar_size(#ind) - 1];

  # Inserts new element 'elt' into dynamic array #ind, at index [pos] ('pos' must be in [0,dar_size(#ind)]).
  dar_insert(ind,elt,pos) = (
    ref(pos,_dar_pos);
    ref(elt,_dar_elt);
    _dar_siz = dar_size(#ind);
    ref(max(1,s(#ind),size(_dar_elt)),_dar_sizelt);
    if (_dar_pos<=_dar_siz,
      _dar_siz>=h(#ind) - 1?resize(#ind,1,_dar_siz*2 + 2,1,_dar_sizelt,0);
      for (_dar_c = 0, _dar_c<_dar_sizelt, ++_dar_c,
        copy(i(#ind,_dar_pos + 1,0,0,_dar_c),i(#ind,_dar_pos,0,0,_dar_c),_dar_siz - _dar_pos)
      );
      copy(i[#ind,_dar_pos],_dar_elt,_dar_sizelt,h(#ind),1);
      i[#ind,h(#ind) - 1] = ++_dar_siz;
    );
  );

  # Inserts new element 'elt' at the end of dynamic array #ind.
  dar_insert(ind,elt) = (
    ref(elt,_dar_elt);
    _dar_siz = dar_size(#ind);
    ref(max(1,s(#ind),size(_dar_elt)),_dar_sizelt);
    _dar_siz>=h(#ind) - 1?resize(#ind,1,_dar_siz*2 + 2,1,_dar_sizelt,0);
    copy(i[#ind,_dar_siz],_dar_elt,_dar_sizelt,h(#ind),1);
    i[#ind,h(#ind) - 1] = ++_dar_siz;
  );

  # Remove element from dynamic array #ind, at index [pos] ('pos' must be in [0,dar_size(#ind) - 1]).
  dar_remove(ind,pos) = (
    ref(pos,_dar_pos);
    _dar_siz = dar_size(#ind);
    if (_dar_pos<_dar_siz,
      _dar_siz = --dar_size(#ind);
      for (_dar_c = 0, _dar_c<s(#ind), ++_dar_c,
        copy(i(#ind,_dar_pos,0,0,_dar_c),i(#ind,_dar_pos + 1,0,0,_dar_c),_dar_siz - _dar_pos)
      );
    )
  );

  # Remove last element from dynamic array #ind.
  dar_remove(ind) = (
    _dar_siz = dar_size(#ind);
    _dar_siz>0?--dar_size(#ind);
  );"

# rand_pdf : [probability_density],_min_value,_max_value,_precision[%]
# : Fill selected images with random values which follow the given probability distribution.
# : This commands implements the inverse random sampling algorithm, as described in
# : <https://en.wikipedia.org/wiki/Inverse_transform_sampling>.
# : The 'precision' argument sets the number of distinct random values that can be generated.
# : Default values: 'min_value=-1', 'max_value=1' and 'precision=65536'.
# : $ (1,0.5,1) 50,50 rand_pdf[1] [0],0,255
# : $ 256 gaussian[-1] 30 line[-1] 47%,0,53%,0,1,0 500,500 rand_pdf[-1] [-2],0,255 +histogram[-1] 256 \
# display_graph[0,2] 640,480,3,0
rand_pdf : check ${"is_image_arg $1"}" && isnum(${2=-1}) && isnum(${3=1}) && ${4=65536}>=0"
  e[^-1] "Fill image$? with random values in [$2,$3], according to probability distribution $1, with precision $4."

  # Compute normalized cumulated density function (cdf).
  pass$1 0 y. x
  if w<2 rm. f $2 return fi
  prec:=round(!$4?w:ispercentage($4)?w*$4:$4)
  max. 0 cumulate. *. {($prec-1)/i[-1,2]}

  # Compute inverse cdf.
  $prec,1,1,1,">begin(k = 0); while (p = i[#-1,k]; k<w#-1 && (!p || p<x), ++k); lerp($2,$3,min(k/(w#-1-1),1))" rm..

  # Sample random numbers according to given pdf.
  f[^-1] "ind = lerp(0,w#-1,u); i[#-1,ind,2]" rm.

# r2dx : eq. to 'resize2dx'.
r2dx :
  _gmic_s="$?" v + _resize2dx $*

# resize2dx : width[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images along the x-axis, while preserving 2D ratio.
# : (eq. to 'r2dx').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
# : $ image.jpg +resize2dx 100,2 append x
resize2dx :
  _gmic_s="$?" v + _$0 $*

_resize2dx : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 &&
                    ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 2D image"$_gmic_s" to $1 pixels along the x-axis, while preserving 2D ratio."
  foreach {
    size:=ispercentage($1)?$1*w:$1
    r {max(1,$size)},{max(1,h*$size/w)},100%,100%,${2-7}
  }

# r2dy : eq. to 'resize2dy'.
r2dy :
  _gmic_s="$?" v + _resize2dy $*

# resize2dy : height[%]>=0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images along the y-axis, while preserving 2D ratio.
# : (eq. to 'r2dy').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
# : $ image.jpg +resize2dy 100,2 append x
resize2dy :
  _gmic_s="$?" v + _$0 $*

_resize2dy : check "$1>=0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 &&
                    ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 2D image"$_gmic_s" to $1 pixels along the y-axis, while preserving 2D ratio."
  foreach {
    size:=ispercentage($1)?$1*h:$1
    r {max(1,w*$size/h)},{max(1,$size)},100%,100%,${2-7}
  }

# rr2d : eq. to 'resize_ratio2d'.
rr2d :
  _gmic_s="$?" v + _resize_ratio2d $*

# resize_ratio2d : width>0,height>0,_mode={ 0:inside | 1:outside | 2:padded },0=<_interpolation<=6
# : Resize selected images while preserving their aspect ratio.
# : (eq. to 'rr2d').
# : Default values: 'mode=0' and 'interpolation=6'.
resize_ratio2d :
  _gmic_s="$?" v + _$0 $*

_resize_ratio2d : check "$1>0 && $2>0 && ${3=0}>=0 && $3<=2 && ${4=6}>=0 && $4<=6"
  e[0--3] "Resize 2D image"$_gmic_s" to $1x$2 with ratio-"${arg0\ $3,inside,outside,padded}\
           " mode and interpolation type $4."
  foreach {
    ratio:=$3==1?max($1/w,$2/h):min($1/w,$2/h)
    r {[max(1,round(w*$ratio)),max(1,round(h*$ratio))]},100%,100%,$4
  }
  if $3==2 r $1,$2,100%,100%,0,0,0.5,0.5 fi

# r3dx : eq. to 'resize3dx'.
r3dx :
  _gmic_s="$?" v + _resize3dx $*

# resize3dx : width[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images along the x-axis, while preserving 3D ratio.
# : (eq. to 'r3dx').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dx :
  _gmic_s="$?" v + _$0 $*

_resize3dx : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 &&
                    ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the x-axis, while preserving 3D ratio."
  foreach {
    size:=ispercentage($1)?$1*w:$1
    r {max(1,$size)},{max(1,h*$size/w)},{max(1,d*$size/w)},100%,${2-7}
  }

# r3dy : eq. to 'resize3dy'.
r3dy :
  _gmic_s="$?" v + _resize3dy $*

# resize3dy : height[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images along the y-axis, while preserving 3D ratio.
# : (eq. to 'r3dy').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dy :
  _gmic_s="$?" v + _$0 $*

_resize3dy : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 &&
                    ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the y-axis, while preserving 3D ratio."
  foreach {
    size:=ispercentage($1)?$1*h:$1
    r {max(1,w*$size/h)},{max(1,$size)},{max(1,d*$size/h)},100%,${2-7}
  }

# r3dz : eq. to 'resize3dz'.
r3dz :
  _gmic_s="$?" v + _resize3dz $*

# resize3dz : depth[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images along the z-axis, while preserving 3D ratio.
# : (eq. to 'r3dz').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dz :
  _gmic_s="$?" v + _$0 $*

_resize3dz : check "$1>0 && ${2=3}>=0 && $2<=6 && ${3=0}>=0 && $3<=3 && ${4=0}>=0 && $4<=1 && ${5=0}>=0 && $5<=1 &&
                    ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1"
  e[0--3] "Resize 3D image"$_gmic_s" to $1 pixels along the z-axis, while preserving 3D ratio."
  foreach {
    size:=ispercentage($1)?$1*d:$1
    r[$>] {max(1,w*$size/d)},{max(1,h*$size/d)},{max(1,$size)},100%,${2-7}
  }

# r2din : eq. to 'resize2din'
r2din :
  _gmic_s="$?" v + _resize2din $*

# resize2din : width[%]>0,_height[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images so the size is not larger than 'width'x'height' while preserving 2D ratio.
# : (eq. to 'r2din').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'height=100%', 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
# : $ image.jpg +resize2din 100,100 append x
resize2din :
  _gmic_s="$?" v + _$0 $*

_resize2din : check "$1>0 && ${2=100%}>0 && ${3=3}>=0 && $3<=6 && ${4=0}>=0 && $4<=3 && "\
                    "${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1 && ${8=0}>=0 && $8<=1"
  e[0--3] "Resize image"$_gmic_s" so the size is not larger than $1x$2, while preserving 2D ratio."
  eval "repeat (l,k,
    W = ispercentage($1)?w#k*$1:$1;
    H = ispercentage($2)?h#k*$2:$2;
    dims = round(min(W/w#k,H/h#k)*[w#k,h#k]);
    resize(#k,max(1,dims[0]),max(1,dims[1]),d#k,s#k,${3-8});
  )"

# r3din : eq. to 'resize3din'
r3din :
  _gmic_s="$?" v + _resize3din $*

# resize3din : width[%]>0,_height[%]>0,_depth[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images so the size is not larger than 'width'x'height'x'depth' while preserving 3D ratio.
# : (eq. to 'r3din').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'height=100%', 'depth=100%', 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3din :
  _gmic_s="$?" v + _$0 $*

_resize3din : check "$1>0 && ${2=100%}>0 && ${3=100%}>0 && ${4=3}>=0 && $4<=6 && ${5=0}>=0 && $5<=3 && "\
                    "${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1 && ${8=0}>=0 && $8<=1 && ${9=0}>=0 && $9<=1"
  e[0--3] "Resize image"$_gmic_s" so the size is not larger than $1x$2x$3, while preserving 3D ratio."
  eval "repeat (l,k,
    W = ispercentage($1)?w#k*$1:$1;
    H = ispercentage($2)?h#k*$2:$2;
    D = ispercentage($3)?d#k*$3:$3;
    dims = round(min(W/w#k,H/h#k,D/d#k)*[w#k,h#k,d#k]);
    resize(#k,max(1,dims[0]),max(1,dims[1]),max(1,dims[2]),s#k,${4-9});
  )"

# r2dout : eq. to 'resize2dout'
r2dout :
  _gmic_s="$?" v + _resize2dout $*

# resize2dout : width[%]>0,_height[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images so the size is not smaller than 'width'x'height' while preserving 2D ratio.
# : (eq. to 'r2dout').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'height=100%', 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
# : $ image.jpg +resize2dout 100,100 append x
resize2dout :
  _gmic_s="$?" v + _$0 $*

_resize2dout : check "$1>0 && ${2=100%}>0 && ${3=3}>=0 && $3<=6 && ${4=0}>=0 && $4<=3 && "\
                     "${5=0}>=0 && $5<=1 && ${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1 && ${8=0}>=0 && $8<=1"
  e[0--3] "Resize image"$_gmic_s" so the size is not larger than $1x$2, while preserving 2D ratio."
  eval "repeat (l,k,
    W = ispercentage($1)?w#k*$1:$1;
    H = ispercentage($2)?h#k*$2:$2;
    dims = round(max(W/w#k,H/h#k)*[w#k,h#k]);
    resize(#k,max(1,dims[0]),max(1,dims[1]),d#k,s#k,${3-8});
  )"

# r3dout : eq. to 'resize3dout'
r3dout :
  _gmic_s="$?" v + _resize3dout $*

# resize3dout : width[%]>0,_height[%]>0,_depth[%]>0,_interpolation,_boundary_conditions,_ax,_ay,_az,_ac
# : Resize selected images so the size is not smaller than 'width'x'height'x'depth' while preserving 3D ratio.
# : (eq. to 'r3dout').\n
# : 'interpolation' can be { -1:none (memory content) | 0:none | 1:nearest | 2:average | 3:linear | \
# 4:grid | 5:bicubic | 6:lanczos }.
# : 'boundary_conditions' has different meanings, according to the chosen 'interpolation' mode :
# : . When 'interpolation=={ -1 | 1 | 2 | 4 }', 'boundary_conditions' is meaningless.
# : . When 'interpolation==0', 'boundary_conditions' can be { 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }.
# : . When 'interpolation=={ 3 | 5 | 6 }', 'boundary_conditions' can be { 0:none | 1:neumann }.
# : 'ax,ay,az,ac' set the centering along each axis when 'interpolation=0'
# : (set to '0' by default, must be defined in range [0,1]).
# : Default values: 'height=100%', 'depth=100%', 'interpolation=3', 'boundary_conditions=0' and 'ax=ay=az=ac=0'.
resize3dout :
  _gmic_s="$?" v + _$0 $*

_resize3dout : check "$1>0 && ${2=100%}>0 && ${3=100%}>0 && ${4=3}>=0 && $4<=6 && ${5=0}>=0 && $5<=3 && "\
                     "${6=0}>=0 && $6<=1 && ${7=0}>=0 && $7<=1 && ${8=0}>=0 && $8<=1 && ${9=0}>=0 && $9<=1"
  e[0--3] "Resize image"$_gmic_s" so the size is not larger than $1x$2x$3, while preserving 3D ratio."
  eval "repeat (l,k,
    W = ispercentage($1)?w#k*$1:$1;
    H = ispercentage($2)?h#k*$2:$2;
    D = ispercentage($3)?d#k*$3:$3;
    dims = round(max(W/w#k,H/h#k,D/d#k)*[w#k,h#k,d#k]);
    resize(#k,max(1,dims[0]),max(1,dims[1]),max(1,dims[2]),s#k,${4-9});
  )"

# expand_x : size,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Expand selected images along the x-axis.
# : Default value: 'boundary_conditions=0'.
# : $ image.jpg expand_x 30,0
expand_x : check "isint($1) && isint(${2=0},0,3)"
  e[^-1] "Expand image$? along the x-axis with size $1 and "${"arg0 $2,dirichlet,neumann,periodic,mirror"}"
          boundary conditions."
  repeat $! { l[$>] { r {w+2*$1},100%,100%,100%,0,$2,0.5 onfail rm 0 } }

# expand_xy : size,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Expand selected images along the xy-axes.
# : Default value: 'boundary_conditions=0'.
# : $ image.jpg expand_xy 30,0
expand_xy : check "isint($1) && isint(${2=0},0,3)"
  e[^-1] "Expand image$? along the xy-axes with size $1 and "${"arg0 $2,dirichlet,neumann,periodic,mirror"}"
          boundary conditions."
  repeat $! { l[$>] { r {[w,h]+2*$1},100%,100%,0,$2,0.5,0.5 onfail rm 0 } }

# expand_xyz : size,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Expand selected images along the xyz-axes.
# : Default value: 'boundary_conditions=0'.
expand_xyz : check "isint($1) && isint(${2=0},0,3)"
  e[^-1] "Expand image$? along the xyz-axes with size $1 and "${"arg0 $2,dirichlet,neumann,periodic,mirror"}"
          boundary conditions."
  repeat $! { l[$>] { r {[w,h,d]+2*$1},100%,0,$2,0.5,0.5,0.5 onfail rm 0 } }

# expand_y : size,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Expand selected images along the y-axis.
# : Default value: 'boundary_conditions=0'.
# : $ image.jpg expand_y 30,0
expand_y : check "isint($1) && isint(${2=0},0,3)"
  e[^-1] "Expand image$? along the y-axis with size $1 and "${"arg0 $2,dirichlet,neumann,periodic,mirror"}"
          boundary conditions."
  repeat $! { l[$>] { r 100%,{h+2*$1},100%,100%,0,$2,0,0.5 onfail rm 0 } }

# expand_z : size_z,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Expand selected images along the z-axis.
# : Default value: 'boundary_conditions=0'.
expand_z : check "isint($1) && isint(${2=0},0,3)"
  e[^-1] "Expand image$? along the z-axis with size $1 and "${"arg0 $2,dirichlet,neumann,periodic,mirror"}"
          boundary conditions."
  repeat $! { l[$>] { r 100%,100%,{d+2*$1},100%,0,$2,0,0,0.5 onfail rm 0 } }

# shrink_x : size
# : Shrink selected images along the x-axis.
# : $ image.jpg shrink_x 30
shrink_x : check "isint($1)"
  e[^-1] "Shrink image$? along the x-axis with size $1."
  expand_x {-$1}

# shrink_xy : size
# : Shrink selected images along the xy-axes.
# : $ image.jpg shrink_xy 30
shrink_xy : check "isint($1)"
  e[^-1] "Shrink image$? along the xy-axes with size $1."
  expand_xy {-$1}

# shrink_xyz : size
# : Shrink selected images along the xyz-axes.
shrink_xyz : check "isint($1)"
  e[^-1] "Shrink image$? along the xyz-axes with size $1."
  expand_xyz {-$1}

# shrink_y : size
# : Shrink selected images along the y-axis.
# : $ image.jpg shrink_y 30
shrink_y : check "isint($1)"
  e[^-1] "Shrink image$? along the y-axis with size $1."
  expand_y {-$1}

# shrink_z : size
# : Shrink selected images along the z-axis.
shrink_z : check "isint($1)"
  e[^-1] "Shrink image$? along the z-axis with size $1."
  expand_z {$-1}

# blur_xy : amplitude_x[%],amplitude_y[%],_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Blur selected images along the X and Y axes.
# : Default value: 'boundary_conditions=1'.
# : $ image.jpg +blur_xy 6
# : $$ https://gmic.eu/oldtutorial/_blur_y
blur_xy : skip ${2=$1} check "isint(${3=1},0,3)"
  e[^-1] "Blur image$? along the xy-axes, with sigma $1 and "${arg0\ !$2,neumann,dirichlet}" boundary conditions."
  deriche $1,0,x,$3 deriche $2,0,y,$3

# blur_x : amplitude[%]>=0,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Blur selected images along the x-axis.
# : Default value: 'boundary_conditions=1'.
# : $ image.jpg +blur_x 6
# : $$ https://gmic.eu/oldtutorial/_blur_x
blur_x : check "isint(${2=1},0,3)"
  e[^-1] "Blur image$? along the x-axis, with sigma $1 and "${arg0\ !$2,neumann,dirichlet}" boundary conditions."
  deriche $1,0,x,$2

# blur_xyz : amplitude_x[%],amplitude_y[%],amplitude_z,\
# _boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Blur selected images along the X, Y and Z axes.
# : Default value: 'boundary_conditions=1'.
# : $$ https://gmic.eu/oldtutorial/_blur_xyz
blur_xyz : skip ${2=$1},${3=$1} check "isint(${4=1},0,3)"
  e[^-1] "Blur image$? along the xyz-axes, with sigma $1 and "${arg0\ !$2,neumann,dirichlet}" boundary conditions."
  deriche $1,0,x,$4 deriche $2,0,y,$4 deriche $3,0,z,$4

# blur_y : amplitude[%]>=0,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Blur selected images along the y-axis.
# : Default value: 'boundary_conditions=1'.
# : $ image.jpg +blur_y 6
# : $$ https://gmic.eu/oldtutorial/_blur_y
blur_y : check "isint(${2=1},0,3)"
  e[^-1] "Blur image$? along the y-axis, with sigma $1 and "${arg0\ !$2,neumann,dirichlet}" boundary conditions."
  deriche $1,0,y,$2

# blur_z : amplitude[%]>=0,_boundary_conditions={ 0:dirichlet | 1:neumann | 2:periodic | 3:mirror }
# : Blur selected images along the z-axis.
# : Default value: 'boundary_conditions=1'.
# : $$ https://gmic.eu/oldtutorial/_blur_z
blur_z : check "isint(${2=1},0,3)"
  e[^-1] "Blur image$? along the z-axis, with sigma $1 and "${arg0\ !$2,neumann,dirichlet}" boundary conditions."
  deriche $1,0,z,$2

# frame_x : size_x[%],_col1,...,_colN
# : Insert outer frame along the x-axis in selected images.
# : Default values: 'col1=col2=col3=255' and 'col4=255'.
# : $ image.jpg frame_x 20,255,0,255
frame_x : skip ${2=255},${3=$2},${4=$3},${5=255}
  e[^-1] "Insert $1 outer frame in image$? along the x-axis, with color (${2--1})."
  _frame $1,0,0,${2--1}

# frame_xy : size_x[%],_size_y[%],_col1,...,_colN
# : Insert outer frame along the x-axis in selected images.
# : Default values: 'size_y=size_x', 'col1=col2=col3=255' and 'col4=255'.
# : (eq. to 'frame').
# : $ image.jpg frame_xy 1,1,0 frame_xy 20,10,255,0,255
frame_xy : skip ${2=$1},${3=255},${4=$3},${5=$4},${6=255}
  _gmic_s="$?" v + _$0 ${1--1}

_frame_xy :
  e[0--3] "Insert $1x$2 outer frame in image"$_gmic_s" along the xy-axes, with color (${3--1})."
  _frame $1,$2,0,${3--1}

# frame_xyz : size_x[%],_size_y[%],_size_z[%]_col1,...,_colN
# : Insert outer frame along the x-axis in selected images.
# : Default values: 'size_y=size_x=size_z', 'col1=col2=col3=255' and 'col4=255'.
frame_xyz : skip ${2=$1},${3=$2},${4=255},${5=$4},${6=$5},${7=255}
  e[^-1] "Insert $1x$2x$3 outer frame in image$? along the xyz-axes, with color (${4--1})."
  _frame $1,$2,$3,${4--1}

# frame_y : size_y[%],_col1,...,_colN
# : Insert outer frame along the y-axis in selected images.
# : Default values: 'col1=col2=col3=255' and 'col4=255'.
# : $ image.jpg frame_y 20,255,0,255
frame_y : skip ${2=255},${3=$2},${4=$3},${5=255}
  e[^-1] "Insert $1 outer frame in image$? along the y-axis, with color (${2--1})."
  _frame 0,$1,0,${2--1}

_frame :
  foreach {
    nm={n}
    fw,fh,fd:=round([ispercentage($1)?w*$1:$1,ispercentage($2)?h*$2:$2,ispercentage($3)?d*$3:$3])
    1,1,1,100%,${4--1} r. {0,[w,h,d]+2*[$fw,$fh,$fd]},100%
    j. ..,$fw,$fh,$fd
    k. => $nm
  }

#@gui Zoom : fx_zoom, fx_zoom(1)
#@gui : Factor = float(2,0.01,10)
#@gui : Center (%) = point(50,50,0,1,255)
#@gui : Boundary = choice(0,"Transparent","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>David Tschumperlé</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_zoom :
  if !$4" && "$1<1 to_a fi
  zoom $1,{$2%},{$3%},0,$4

#@cli drawing : _amplitude>=0
#@cli : Apply drawing effect on selected images.
#@cli : Default value: 'amplitude=200'.
#@cli : $ image.jpg +drawing ,
drawing : skip ${1=200}
  e[^-1] "Apply drawing effect on image$? with amplitude $1."
  foreach {
    split_opacity
    l[0] {
      to_rgb
      smooth $1,0.2,1,3,3 b 2 sharpen 1000 [0]
      r[0] 20,20,1,3,2 equalize[0] index[1] [0],1,1
      => {0,n} rm[0]
    }
    a c
  }

#@gui Pen Drawing : fx_pen_drawing, fx_pen_drawing(0)+
#@gui : Amplitude = ~float(10,0,30)
#@gui : sep = separator()
#@gui : note = note("<small>Author: <i>David Tschumperlé</i>.      Latest Update: <i>2010/29/12</i>.</small>")
fx_pen_drawing :
  drawing $1

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
