#@gmic
#
#  File        : joan_rake.gmic
#                ( G'MIC commands file )
#
#  Description : The author of these filters ('Joan Rake', not her real
#                name) describes them as a gritty and overloaded series of
#                mistakes which will probably be frowned upon by hordes of
#                snobbish graphic designers. Good for them, Joan doesn't care.
#                At least not until they start overusing her filters to the
#                extent that everyone gets tired of them.
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#@cli invert_rgb
#@cli : Inverts images in the RGB colour space.
invert_rgb:
repeat $! split_opacity
l[0] c 0,255 *[$>] -1 +[$>] 255 endl
a c
done

#@cli invert_alpha
#@cli : Inverts the alpha channel of images.
invert_alpha:
repeat $! split_opacity
l[1] c 0,255 *[$>] -1 +[$>] 255 endl
a c
done

#@gui _<b>Testing</b>
#@gui <i>Joan Rake</i>

#@gui Mesh Blend : fx_mesh_blend, fx_mesh_blend_preview(1)
#@gui : note = note("Universal blending algorithm. Resizes an RGB&#40;A&#41; image to a 256x256 image and uses it as an RGBA LUT 'transfer function mesh' to blend two other images together. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : sep = separator(), note = note("<small>[0] is bottom layer, [1] is top layer, [2] is mesh. Mesh origin is at bottom-left. Plugin GUI preview does not accurately show mesh.</small>")
#@gui : Process As = choice(0,"Three-by-three","Self-mesh and self-blend for each layer")
#@gui : Resize Interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Reverse Blending Layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Blend Alpha Channels = bool(0)
#@gui : Keep Mesh = bool(0)
_fx_mesh_blend :
r. 256,256,100%,100%,$1
if $4 to_rgba else to_rgb fi
if $2 rv[0,1] fi
f[$3] "i(#2,i(#0),256-i(#1))"
if {!$5} rm[2] fi
if $3 rm[0] else rm[1] fi
fx_mesh_blend :
if {$1==0} repeat {int($!/3)} l[$>-{$>+2}] rv _fx_mesh_blend ${2-6} endl done
elif {$1==1} repeat $! l[$>] [0]x2 _fx_mesh_blend ${2-6} endl done fi
fx_mesh_blend_preview :
fx_mesh_blend $*


#@gui <b>Artistic</b>

#@gui Whirling Lines : fx_whirling_lines, fx_whirling_lines_preview()
#@gui : note = note("Creates fingerprint-like lines out of images by blurring and rounding their values. Works best with single-channel images.")
#@gui : 1. Blur = float(30,0,100)
#@gui : 2. Round = float(6,0,255)
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 3. Norm Mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 4. Smoothness = float(0,0,10)
#@gui : 5. Contrast = float(0.45,0,1.5)
#@gui : 6. Min Threshold = float(40,0,100)
#@gui : 7. Max Threshold = float(60,0,100)
#@gui : 8. Dilate or Erode = int(0,-5,20)
#@gui : 9. Negative = bool(0)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(30,0,100)
#@gui : 11. Edge Threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,10)
#@gui : 13. Value Action = choice(3,"None","Cut","Normalize","Cut then normalize")
fx_whirling_lines :
b $1 f "round(i,$2)"
if {$3==1}
b $4
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $4
s={s} s. c +[-$s--1] sqrt.
elif {$3==2}
b $4 laplacian abs to_gray to_rgb
elif {$3==3}
b $4 gradient xyz abs blend add to_gray to_rgb
else
b $4 gradient_norm
fi
c 0,255
^ $5
c $6%,$7%
n 0,255
if {$8>=0}
dilate_circ $8
elif {$8<=0}
erode {-$8}
fi
if $9 negate fi
if {$10!=0||$11!=100}
fx_smooth_antialias ${10-12}
fi
if {$13==1} c 0,255 elif {$13==2} n 0,255 elif {$13==3} c 0,255 n 0,255 fi
fx_whirling_lines_preview :
fx_whirling_lines $*

#@gui Dreamy Watercolour : fx_dreamy_watercolour, fx_dreamy_watercolour(0)
#@gui : note = note("Creates abstract watercolour images.")
#@gui : sep = separator(), note = note("<b>Gradient norm</b>")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.3,0,2)
#@gui : 3. Min Threshold = float(40,0,100)
#@gui : 4. Max Threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 7. Amplitude = float(50,0,200)
#@gui : 8. Edge Threshold (%) = float(0,0,100)
#@gui : 9. Smoothness = float(10,0,20)
#@gui : sep = separator(), note = note("<b>Dreamy abstraction</b>")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 10. Edge Threshold = float(2,0,30)
#@gui : 11. Smoothness = float(1,0,10)
#@gui : 12. Blend Mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 13. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 14. Noise Amplitude = float(10,0,100)
#@gui : 15. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 16. Noise Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 17. Blend Mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 18. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 19. Blur Strength = float(3,0,20)
#@gui : 20. Sharpen Radius Factor = float(1,0,5)
#@gui : 21. Amount Factor = float(1,0,5)
#@gui : 22. Threshold = float(1,0,5)
#@gui : 23. Constraint Radius Factor = float(1,0,5)
#@gui : 24. Overshoot Factor = float(1,0,20)
#@gui : 25. Sharpen Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 26. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 27. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("<b>Deform colour layer</b>")
#@gui : 28. Amplitude = float(5,0,50)
#@gui : 29. Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : 30. Matrix Density = float(10,1,100)
#@gui : 31. Matrix Interpolation = choice(1,"Linear","Bicubic")
#@gui : 32. Mode = Choice("Noise","Spread noise")
#@gui : 33. Character = float(0,-100,100)
#@gui : 34. Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), note = note("<b>Plasma</b>")
#@gui : 35. Alpha = float(0.5,0,5)
#@gui : 36. Beta = float(0,0,100)
#@gui : 37. Scale = float(8,1,20)
#@gui : 38. Randomize = bool(1)
#@gui : 39. Transparency = bool(0)
#@gui : 40-42. Color Balance = color(128,128,128)
#@gui : 43. Fix Edges = float(0.5,0,1)
#@gui : sep = separator(), note = note("<b>Transfer colours</b>")
#@gui : 44. Enable = bool(1)
#@gui : 45. Regularization = int(8,0,32)
#@gui : 46. Preserve Luminance = float(0.2,0,1)
#@gui : 47. Precision = _choice(1,"Low","Normal","High","Very high")
#@gui : 48. Reference Colors = choice(1,"Plasma","Painting")
#@gui : 49. Add User-Defined Constraints (Interactive) = _bool(0)
#@gui : 50. Blend Mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 51. Opacity = float(0.75,0,1)
#@gui : 52. Reverse Order = bool(0)
#@gui : sep = separator(), note = note("<b>Local normalisation</b>")
#@gui : 53. Amplitude = float(1,0,80)
#@gui : 54. Radius = int(20,1,96)
#@gui : 55. Neighborhood Smoothness = float(40,0,60)
#@gui : 56. Average Smoothness = float(40,0,60)
#@gui : 57. Constrain Values = bool(1)
#@gui : 58. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<b>Noise</b>")
#@gui : 59. Power = float(1.25,0,5)
#@gui : 60. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : 61. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 62. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 63. Blend Mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 64. Opacity = float(1,0,1)
fx_dreamy_watercolour :
repeat $! l[$>]
to_rgb
if $6
+b $1
l[1] gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255
if {$9!=0||$10!=100}
fx_smooth_antialias ${7-9}
fi
endl
fi
fx_jr_deform[0] 0,${28-34}
fx_dreamy_abstraction[0] ${10-27}
n[1] 0,255 negate[1] blend[0,1] multiply,$6
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
100%,100%,1,3
CF={$37*20*$38}
 l[1] if {$43} z {-$CF},{-$CF},{w+$CF},{h+$CF} fi fx_plasma ${35-42} if {$43} z {$CF},{$CF},{w-$CF},{h-$CF} fi endl
if $44 fx_transfer_rgb ${45-49} fi
if $52 rv fi
blend ${_mode{$50+1}},$51
fx_normalize_local ${53-58}
if $59
100%,100%,1,3 fc[1] 127,127,127 jr_fx_noise[1] {(2^($59/5))*($59*20)},${60-62}
blend ${_mode{$63+1}},$64
fi
endl done
fx_dreamy_watercolour_preview :
fx_dreamy_watercolour $*

#@gui Hard Painting : fx_hard_painting, fx_hard_painting_preview(0)+
#@gui : note = note("Modular filter which can be used to apply an extremely-glossy paint effect.")
#@gui : sep = separator(), note = note("<small>Painting authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.\nLatest update: <i>2011/28/02</i>.</small>")
#@gui : 1. Abstraction = int(1,0,20)
#@gui : 2. Details Scale = float(2.5,0,100)
#@gui : 3. Color = float(4,0,25)
#@gui : 4. Smoothness = float(50,0,2000)
#@gui : 5. Sharpen Shades = bool(1)
#@gui : sep = separator (), note = note("<small>Graphic novel author: <i>PhotoComiX</i>. Latest update : <i>2011/13/11</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=1582")
#@gui : 6. Graphic Novel Iterations = int(1,0,10)
#@gui : sep = separator ()
#@gui : note = note("Apply Local Normalization")
#@gui : 7. Skip This Step = bool(false)
#@gui : sep = separator ()
#@gui : note = note("Local Normalization Controls")
#@gui : 8. Ln Amplititude = float(2,0,60)
#@gui : 9. Ln Size = float(6,0,64)
#@gui : 10. Ln Neightborhood-Smoothness = float(5,0,40)
#@gui : 11. Ln Average-Smoothness = float(20,0,40)
#@gui : sep = separator()
#@gui : 12. Skip All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note(" Pencil Options")
#@gui : 13. Pencil Size = float(0.62,0,4)
#@gui : 14. Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : 15. Skip All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : 16. Activate "pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : sep = separator()
#@gui : 17. Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : 18. Pencil Smoother Edge Protection = float(0.78,0,1)
#@gui : 19. Pencil Smoother Smoothness = float(1.92,0,10)
#@gui : sep = separator()
#@gui : 20. Skip All Other Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator()
#@gui : note = note ("Boost Merging Options")
#@gui : 21. Swap Layers = bool (false)
#@gui : 22. Mixer = choice("Overlay","Multiply","Soft light","Color Burn","Darken","Stamp","Hard Light","Value","Grain Merge","Freeze","Lightness", "Luminance","*Colors Doping","*Comix Colors*" ,"Graphic Colours","*Graphix Colors","*Vivid Edges*","*Dark Edges*","*Dark Screen*","*Vivid Screen*","Interpolate")
#@gui : 23. Opacity = float(1,0,1)
#@gui : 24. Intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : 25. Add Painter's Touch = bool(true)
#@gui : sep = separator ()
#@gui : 26. Painter's Touch Sharpness = float(0.5,0,2)
#@gui : 27. Painter's Edge Protection Flow = float(0.8,0,1)
#@gui : 28. Painter's Smoothness = float(1.28,0,10)
#@gui : sep = separator(), 29-31. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_hard_painting : skip ${4=0},${5=0}
repeat $! l[$>]
to_colormode {max(3,s)} split_opacity -rv
repeat $1 fx_normalize_local. 10,6,5,20,1,11 done
fx_smooth_anisotropic. {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
fx_mix_lab. 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
if $5 fx_segment_watershed. 10,1,0 fi
smooth. $4,0,1,1,1
-split_opacity -l[0]
-repeat {max(0,$6)}
-if {$7==0} -fx_normalize_local $8,$9,$10,$11,1,3,0 -endif
-if {$12==0} --fx_pencilbw $13,$14,0,0,0 -endif
-if {$15==1} -keep[-1] -break -endif
-if {$16==1} -fx_smooth_anisotropic[-1] 60,$17,$18,$19,1.1,0.8,30,2,0,1,1,0 -endif
-if {$20==1} -keep[-1] -break -endif
-if {$21==1} -reverse -endif
-if {$22==0} -fx_compose_overlay $23,0
-elif {$22==1} -fx_compose_multiply $23,0
-elif {$22==2} -fx_compose_softlight $23,0
-elif {$22==3} -fx_compose_colorburn $23,0
-elif {$22==4} -fx_compose_darken $23,0
-elif {$22==5} -fx_compose_stamp $23,0
-elif {$22==6} -fx_compose_hardlight $23,0
-elif {$22==7} -fx_compose_value $23,1
-elif {$22==8} -fx_compose_grainmerge $23,0
-elif {$22==9} -fx_compose_freeze $23,0
-elif {$22==10} -fx_compose_lightness $23,1
-elif {$22==11} -fx_compose_luminance $23,1
-elif {$22==12} -fx_compose_colordoping $23,0
-elif {$22==13} -fx_compose_comix_color $23,0,$24
-elif {$22==14} -fx_compose_graphicolor $23,0,$24
-elif {$22==15} -fx_compose_graphixcolor $23,0
-elif {$22==16} -fx_compose_vividedges $23,0.50,0,$24
-elif {$22==17} -fx_compose_darkedges $23,0.50,0,$24
-elif {$22==18} -fx_compose_vividscreen $23,0,$24
-elif {$22==19} -fx_compose_darkscreen $23,0,$24
-elif {$22==20} -fx_compose_interpolation $23,0 -endif
-if {$25==1} -fx_smooth_anisotropic 60,$26,$27,$28,1.1,0.8,30,2,0,1,1,0 -endif
-done
endl
rv a c
endl
done
fx_hard_painting_preview :
gui_split_preview "-fx_hard_painting $*",${-3--1}
#@gui Neon : fx_neon, fx_neon_preview(0)
#@gui : note = note("Turns bright image outlines into bright, neon-like lines.")
#@gui : sep = separator(), note = note("Lines")
#@gui : 1. Norm Mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 2. Smoothness = float(0,0,10)
#@gui : 3. Contrast = float(0.45,0,1.5)
#@gui : 4. Min Threshold = float(40,0,100)
#@gui : 5. Max Threshold = float(60,0,100)
#@gui : 6. Negative = bool(0)
#@gui : 7. Opacity = float(1,0,1)
#@gui : 8. Saturation = float(1.15,0,4)
#@gui : 9. Blur Original = float(2,0,20)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(3,0,100)
#@gui : 11. Edge Threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,5)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 13. Size = float(20,0,100)
#@gui : 14. Intensity = float(0.4,0,3)
#@gui : 15. Darken = float(0.1,0,1)
#@gui : 16. Saturation = float(1.5,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 17. Size = float(5,0,100)
#@gui : 18. Intensity = float(0.2,0,3)
#@gui : 19. Darken = float(0.1,0,1)
#@gui : 20. Saturation = float(1,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 21. Size = float(2,0,5)
#@gui : 22. Intensity = float(1,0,2)
#@gui : sep = separator()
#@gui : 23. Smooth Hues = float(0,0,20)
#@gui : sep = separator()
#@gui : 24. Alpha = bool(0)
#@gui : 25. Alpha Power = float(1,0,5)
#@gui : 26. Alpha Multiplier = float(1,0,5)
#@gui : sep = separator(), 27-29. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_neon :
repeat $! l[$>]
if $9
b $9
fi
+fc 0,0,0 rv blend alpha
to_rgb rgb2hsl s c
*.. {$8^2.5}
a[0-2] c hsl2rgb
if $7
[0] l[1]
if {$1==1}
b $2
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $2
s={s} s. c +[-$s--1] sqrt.
elif {$1==2}
b $2 laplacian abs to_gray to_rgb
elif {$1==3}
b $2 gradient xyz abs blend add to_gray to_rgb
else
b $2 gradient_norm
fi
c 0,255
^ $3
c $4%,$5%
if $6 negate fi
n 0,255
if {$10!=0||$11!=100}
fx_smooth_antialias ${10-12}
fi
endl
if $9
b.. $9
fi
blend multiply,$7
fi
+b[0] {$13%*100},1 *[1] {$14*sqrt($13%)*10} -[1] {(($14*sqrt($13%)*128)-1)^(sqrt($15))}
+b[0] {$17%*100},1 *[2] {$18*sqrt($17%)*10} -[2] {(($18*sqrt($17%)*128)-1)^(sqrt($19))}
+b[0] $21,1 *[3] {($14+$18)*$21*$22}
rgb2hsl[1-3] s[1-3] c
*[2] {$16^2.5}
*[5] {$20^2.5}
*[8] 0
a[1-3] c a[2-4] c a[3-5] c hsl2rgb[1-3]
blend add,$7
if $23
rgb2ycbcr s c b[1,2] {$23%*100} a c ycbcr2rgb
fi
if $24
rgb2hsv8 100%,100%,1,1 f[1] "((j(#0,0,0,0,2)/255)^(1/$25))*255*$26" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
fi
endl done
fx_neon_preview :
gui_split_preview "-fx_neon ${1-26}",${-3--1}
#@gui Neon Alpha: fx_neon_alpha, fx_neon_alpha_preview(0)
#@gui : note = note("An attempt to make the Neon filter work with alpha channels. Low-quality, comes with some artefacts.")
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.45,0,1.5)
#@gui : 3. Min Threshold = float(40,0,100)
#@gui : 4. Max Threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Blur Original = float(2,0,20)
#@gui : 7. Saturation = float(1.15,0,4)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 8. Size = float(20,0,100)
#@gui : 9. Intensity = float(0.4,0,3)
#@gui : 10. Darken = float(0.1,0,1)
#@gui : 11. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 12. Size = float(5,0,100)
#@gui : 13. Intensity = float(0.2,0,3)
#@gui : 14. Darken = float(0.1,0,1)
#@gui : 15. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 16. Size = float(2,0,5)
#@gui : 17. Intensity = float(1,0,2)
fx_neon_alpha :
repeat $! l[$>]
to_rgba
+split_opacity
rm[1]
fx_solidify_td[0] 100,0,10,2,0 +invert_rgb[0]
blend[1,2] difference
fx_gradient_norm[1] ${1-4},0
if {$7!=1}
l[0] to_rgb[0] rgb2hsl[0] s[0] c
*[1] {$7^2.5}
a[0-2] c hsl2rgb[0]
endl fi
if $6
b[0] $6
fi



[0] [1] a[2,3] c b[2] $8,1 *[2] {$9*sqrt($8)} -[2] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
[0] [1] a[3,4] c b[3] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
split_opacity[2,3]

l[2] to_rgb[0] rgb2hsv[0] s[0] c
*[1] {$11^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] endl
l[4] to_rgb[0] rgb2hsv[0] s[0] c
*[1] {$15^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] endl




blend[3,5] average
blend[2,4] add


b[2] {$9*13}

+blend[0,2] add rm[0] mv[3] 0
[1]
a[0,1] c a[1,2] c [1] mv[3] 0
blend[0,1] alpha blend[0,1] add

#a[0,1] c









#+b[1] $16,1 *[2] {($9+$13)*$16*$17}
#+b[1] $8,1 *[3] {$9*sqrt($8)} -[3] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
#+b[1] $12,1 *[4] {$13*sqrt($12)} -[4] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
#+b[0] {$12+$8}
#blend[3,4] add
#+a[0,3] c
#a[0,1] c rm[2]

#blend[0,1] add













#+b[2] $8,1 *[3] {$9*sqrt($8)} -[3] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
#+b[1] $16,1 *[2] {($9+$13)*$16*$17}
#blend[1,3] add


#rgb2hsl[1] s[1] c *[2] $11 a[1-3] c  hsl2rgb[1] a[1-2] c *[1]

#[1] rv[0,1] blend[0,1] alpha blend[0,1] add
#+a[0,1] c

#+b[1] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
#+b[0] $16,1 *[2] {($9+$13)*$16*$17}
#blend[0,2] add
#c 0,255
#+a[0,1] c
#blend[0-1]
#rv[1-4] blend[1-4] add


#a[0,1] c
endl done
fx_neon_alpha_preview :
fx_neon_alpha $*


#@gui Dreamy Abstraction : fx_dreamy_abstraction, fx_dreamy_abstraction_preview()
#@gui : note = note("A less-aggressive alternative to the Painting filter. Yes, 'Joan Rake' made a filter that isn't aggressive! What kind of digital paint has she been sniffing?")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 1. Edge Threshold = float(2,0,30)
#@gui : 2. Smoothness = float(1,0,10)
#@gui : 3. Blend Mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 4. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 5. Noise Amplitude = float(10,0,100)
#@gui : 6. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 7. Noise Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 8. Blend Mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 9. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 11. Blur Strength = float(3,0,20)
#@gui : 12. Sharpen Radius Factor = float(1,0,5)
#@gui : 13. Amount Factor = float(1,0,5)
#@gui : 14. Threshold = float(1,0,5)
#@gui : 15. Constraint Radius Factor = float(1,0,5)
#@gui : 16. Overshoot Factor = float(1,0,20)
#@gui : 17. Sharpen Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 18. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 19. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("Glow")
#@gui : 20. Size = float(5,0,50)
#@gui : 21. Intensity = float(1,0,3)
#@gui : 22. Darken = float(0,0,1)
#@gui : 23. Saturation = float(1.5,0,4)
#@gui : sep = separator(), 24-26. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_dreamy_abstraction :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption1=$3
Opacity1=$4
MergingOption2=$8
Opacity2=$9
if {$4>=0}
+fx_segment_watershed $1,$2,1,1 blend ${_mode{$MergingOption1+1}},$Opacity1
fi
if {$5>=0}
+fc 0,0,0 -to_rgb
if {$6==5}
ac. "spread {([$5,$5]/100)*max(w,h)}",$7,1
else
ac. "_jr_fx_noise {255*$5/100},$6",$7,1
fi
blend ${_mode{$MergingOption2+1}},$Opacity2
if {$10>=0}
_fx_gaussian_blur $10,0,0,1
fi
fi
radius={$10*$11*2}
amount={$10*$12*2}
cradius={$10*$14*2}
overshoot={$10*$15/10}
iain_constrained_sharpen $radius,$amount,$13,$cradius,$overshoot,$16,$17
if {$18>=0}
fx_smooth_antialias {$18+(5*$10)},0,{($18+(5*$10))/20}
fi
fx_dreamy_abstraction_preview:
gui_split_preview "-fx_dreamy_abstraction $*",${-3--1}

#@gui Otsu-Hessian Blend: fx_otsu_hessian_blend, fx_otsu_hessian_blend_preview(1)
#@gui : note = note("Expansion of <a href="https://discuss.pixls.us/t/one-liner-challenge/8785/7?u=joan_rake1">a one-line filter by Afre</a>.")
#@gui : Otsu Levels = int(4,1,32)
#@gui : Norm 1 = float(0,-5,5)
#@gui : Norm 2 = float(1,-5,5)
#@gui : Merging Option = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse Order = bool(0)
fx_otsu_hessian_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption=$4
Opacity=$5
ReverseOrder={!$6}
+l otsu $1 af_hnorm n $2,$3 endl +* blend ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
fx_otsu_hessian_blend_preview :
repeat {max(0,l)}
fx_otsu_hessian_blend[$>] $*
done

#@gui _<b>Rendering</b>

#@gui Satellite : fx_satellite, fx_satellite_preview(1)
#@gui : note = note("Converts to grayscale and uses <a href="https://www.ospo.noaa.gov/Organization/FAQ/enhancements.html">image enhancement colour schemes</a> which are used in NOAA satellite weather products.")
#@gui : Enhancement = choice("Aviation","Dvorak","Funktop","JSL2","Shortwave IR2 &#40;Standard and Tropical&#41;","Shortwave IR2 &#40;Fire&#41;","Shortwave IR2 &#40;Summer Fire&#41;","Shortwave IR2 &#40;Winter Fire&#41;","Rainbow &#40;Old&#41;","Rainbow &#40;New&#41;","Water Vapour","Water Vapour &#40;Blue&#41;","IR Window","IR Window &#40;blue&#41")
#@gui : Gamma Power = float(0,-5,5)
#@gui : Lower Threshold = float(0,0,100)
#@gui : Higher Threshold = float(100,0,100)
#@gui : Normalize = bool(1)
#@gui : To sRGB = bool(0)
fx_satellite :
repeat $! l[$>]
to_gray
f "255*((i/255)^(2^(2^($2^2))))"
c $3%,$4% if $5 n 0,255 fi
to_rgb
# use '{ print("(i<="$2+1")?["$3"+(i-"$1")*"($4-$3)/($2-$1)","$5"+(i-"$1")*"($6-$5)/($2-$1)","$7"+(i-"$1")*"($8-$7)/($2-$1)"]:") }' in awk to get values from text files from the linked NOAA site.
if {$1==0}
f "(i<=48)?[0,0,0]:
(i<=52)?[8,8,8]:
(i<=56)?[20,20,20]:
(i<=60)?[28,28,28]:
(i<=64)?[40,40,40]:
(i<=68)?[52,52,52]:
(i<=72)?[60,60,60]:
(i<=76)?[72,72,72]:
(i<=80)?[84,84,84]:
(i<=84)?[92,92,92]:
(i<=88)?[104,104,104]:
(i<=92)?[112,112,112]:
(i<=96)?[124,124,124]:
(i<=100)?[136,136,136]:
(i<=104)?[144,144,144]:
(i<=108)?[156,156,156]:
(i<=112)?[168,168,168]:
(i<=116)?[176,176,176]:
(i<=120)?[188,188,188]:
(i<=124)?[196,196,196]:
(i<=128)?[208,208,208]:
(i<=132)?[220,220,220]:
(i<=136)?[228,228,228]:
(i<=140)?[240,240,240]:
(i<=144)?[252,252,252]:
(i<=148)?[244,156,0]:
(i<=152)?[236,152,0]:
(i<=156)?[228,148,0]:
(i<=160)?[220,144,0]:
(i<=164)?[212,140,0]:
(i<=168)?[208,136,0]:
(i<=172)?[200,132,0]:
(i<=176)?[192,128,0]:
(i<=180)?[184,124,0]:
(i<=184)?[176,120,0]:
(i<=188)?[0,160,160]:
(i<=192)?[0,188,188]:
(i<=196)?[0,220,220]:
(i<=200)?[0,248,248]:
(i<=204)?[0,180,252]:
(i<=208)?[0,160,232]:
(i<=212)?[0,140,216]:
(i<=216)?[0,120,196]:
(i<=220)?[0,0,232]:
(i<=224)?[0,0,248]:
(i<=250)?[88,88,88]:
(i<=256)?[255,255,255]"
elif {$1==1}
f "(i<=59)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=68)?[6+(i-59)*7,6+(i-59)*7,6+(i-59)*7]:
(i<=97)?[75+(i-68)*6.42857,75+(i-68)*6.42857,75+(i-68)*6.42857]:
(i<=175)?[112+(i-97)*1.19481,112+(i-97)*1.19481,112+(i-97)*1.19481]:
(i<=188)?[64+(i-175)*0,64+(i-175)*0,64+(i-175)*0]:
(i<=199)?[112+(i-188)*0,112+(i-188)*0,112+(i-188)*0]:
(i<=209)?[160+(i-199)*0,160+(i-199)*0,160+(i-199)*0]:
(i<=215)?[0+(i-209)*0,0+(i-209)*0,0+(i-209)*0]:
(i<=221)?[255+(i-215)*0,255+(i-215)*0,255+(i-215)*0]:
(i<=226)?[136+(i-221)*0,136+(i-221)*0,136+(i-221)*0]:
(i<=256)?[88+(i-226)*0,88+(i-226)*0,88+(i-226)*0]"
elif {$1==2}
f "(i<=44)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=152)?[20+(i-44)*1.83178,20+(i-44)*1.83178,20+(i-44)*1.83178]:
(i<=184)?[0+(i-152)*0,100+(i-152)*4.77419,100+(i-152)*4.77419]:
(i<=204)?[120+(i-184)*6.94737,0+(i-184)*13.2632,0+(i-184)*0]:
(i<=216)?[0+(i-204)*0,0+(i-204)*0,84+(i-204)*15.2727]:
(i<=224)?[80+(i-216)*8.57143,80+(i-216)*8.57143,252+(i-216)*0]:
(i<=237)?[0+(i-224)*21,252+(i-224)*0,0+(i-224)*21]:
(i<=253)?[252+(i-237)*0,252+(i-237)*0,252+(i-237)*0]:
(i<=256)?[255+(i-253)*0,255+(i-253)*0,255+(i-253)*0]"
elif {$1==3}
f "(i<=4)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=8)?[28+(i-4)*0,0+(i-4)*0,28+(i-4)*0]:
(i<=12)?[60+(i-8)*0,0+(i-8)*0,60+(i-8)*0]:
(i<=16)?[92+(i-12)*0,0+(i-12)*0,92+(i-12)*0]:
(i<=20)?[124+(i-16)*0,0+(i-16)*0,124+(i-16)*0]:
(i<=24)?[156+(i-20)*0,0+(i-20)*0,156+(i-20)*0]:
(i<=28)?[188+(i-24)*0,0+(i-24)*0,188+(i-24)*0]:
(i<=32)?[220+(i-28)*0,0+(i-28)*0,220+(i-28)*0]:
(i<=36)?[252+(i-32)*0,0+(i-32)*0,252+(i-32)*0]:
(i<=40)?[236+(i-36)*0,0+(i-36)*0,224+(i-36)*0]:
(i<=44)?[220+(i-40)*0,0+(i-40)*0,196+(i-40)*0]:
(i<=48)?[208+(i-44)*0,0+(i-44)*0,168+(i-44)*0]:
(i<=52)?[192+(i-48)*0,0+(i-48)*0,140+(i-48)*0]:
(i<=56)?[180+(i-52)*0,0+(i-52)*0,112+(i-52)*0]:
(i<=60)?[164+(i-56)*0,0+(i-56)*0,84+(i-56)*0]:
(i<=64)?[152+(i-60)*0,0+(i-60)*0,56+(i-60)*0]:
(i<=68)?[136+(i-64)*0,0+(i-64)*0,28+(i-64)*0]:
(i<=72)?[124+(i-68)*0,0+(i-68)*0,0+(i-68)*0]:
(i<=76)?[136+(i-72)*0,28+(i-72)*0,0+(i-72)*0]:
(i<=80)?[152+(i-76)*0,56+(i-76)*0,0+(i-76)*0]:
(i<=84)?[164+(i-80)*0,84+(i-80)*0,0+(i-80)*0]:
(i<=88)?[180+(i-84)*0,112+(i-84)*0,0+(i-84)*0]:
(i<=92)?[192+(i-88)*0,140+(i-88)*0,0+(i-88)*0]:
(i<=96)?[208+(i-92)*0,168+(i-92)*0,0+(i-92)*0]:
(i<=100)?[220+(i-96)*0,196+(i-96)*0,0+(i-96)*0]:
(i<=104)?[236+(i-100)*0,224+(i-100)*0,0+(i-100)*0]:
(i<=108)?[252+(i-104)*0,252+(i-104)*0,0+(i-104)*0]:
(i<=112)?[224+(i-108)*0,236+(i-108)*0,0+(i-108)*0]:
(i<=116)?[196+(i-112)*0,220+(i-112)*0,0+(i-112)*0]:
(i<=132)?[92+(i-116)*0.8,92+(i-116)*0.8,92+(i-116)*0.8]:
(i<=144)?[112+(i-132)*0.727273,112+(i-132)*0.727273,112+(i-132)*0.727273]:
(i<=156)?[128+(i-144)*0.727273,128+(i-144)*0.727273,128+(i-144)*0.727273]:
(i<=168)?[144+(i-156)*0.727273,144+(i-156)*0.727273,144+(i-156)*0.727273]:
(i<=180)?[160+(i-168)*0.727273,160+(i-168)*0.727273,160+(i-168)*0.727273]:
(i<=184)?[176+(i-180)*0,176+(i-180)*0,176+(i-180)*0]:
(i<=188)?[184+(i-184)*0,184+(i-184)*0,184+(i-184)*0]:
(i<=192)?[192+(i-188)*0,192+(i-188)*0,192+(i-188)*0]:
(i<=196)?[200+(i-192)*0,200+(i-192)*0,200+(i-192)*0]:
(i<=200)?[208+(i-196)*0,208+(i-196)*0,208+(i-196)*0]:
(i<=202)?[216+(i-200)*0,216+(i-200)*0,216+(i-200)*0]:
(i<=215)?[0+(i-202)*5,0+(i-202)*5,60+(i-202)*16.25]:
(i<=226)?[71+(i-215)*11.9,71+(i-215)*11.9,255+(i-215)*0]:
(i<=246)?[101+(i-226)*6.36842,0+(i-226)*10.5789,101+(i-226)*6.36842]:
(i<=256)?[0+(i-246)*0,0+(i-246)*0,0+(i-246)*0]"
elif {$1==4}
f "(i<=2)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=26)?[0+(i-2)*0,0+(i-2)*0,235+(i-2)*-10.2174]:
(i<=51)?[0+(i-26)*0,0+(i-26)*0,0+(i-26)*0]:
(i<=62)?[12+(i-51)*0.3,12+(i-51)*0.3,12+(i-51)*0.3]:
(i<=68)?[23+(i-62)*7.6,23+(i-62)*7.6,23+(i-62)*7.6]:
(i<=69)?[75+(i-68)*nan,75+(i-68)*nan,75+(i-68)*nan]:
(i<=81)?[76+(i-69)*7.63636,76+(i-69)*7.63636,76+(i-69)*7.63636]:
(i<=111)?[161+(i-81)*2.72414,161+(i-81)*2.72414,161+(i-81)*2.72414]:
(i<=131)?[226+(i-111)*0.736842,226+(i-111)*0.736842,226+(i-111)*0.736842]:
(i<=171)?[255+(i-131)*-3.46154,255+(i-131)*-3.46154,160+(i-131)*-1.02564]:
(i<=256)?[150+(i-171)*0.833333,50+(i-171)*0.595238,50+(i-171)*0.595238]"
elif {$1==5}
f "(i<=151)?[255+(i-0)*-1.7,255+(i-0)*-1.7,255+(i-0)*-1.7]:
(i<=256)?[0+(i-151)*0,0+(i-151)*0,0+(i-151)*0]"
elif {$1==6}
f "(i<=13)?[255+(i-0)*-2,255+(i-0)*-2,255+(i-0)*-2]:
(i<=126)?[228+(i-13)*-2.03571,228+(i-13)*-2.03571,228+(i-13)*-2.03571]:
(i<=256)?[0+(i-126)*0,0+(i-126)*0,0+(i-126)*0]"
elif {$1==7}
f "(i<=42)?[255+(i-0)*0,255+(i-0)*0,255+(i-0)*0]:
(i<=191)?[253+(i-42)*-1.70946,253+(i-42)*-1.70946,253+(i-42)*-1.70946]:
(i<=256)?[0+(i-191)*0,0+(i-191)*0,0+(i-191)*0]"
elif {$1==8}
f "(i<=4)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=8)?[28+(i-4)*0,0+(i-4)*0,28+(i-4)*0]:
(i<=12)?[60+(i-8)*0,0+(i-8)*0,60+(i-8)*0]:
(i<=16)?[92+(i-12)*0,0+(i-12)*0,92+(i-12)*0]:
(i<=20)?[124+(i-16)*0,0+(i-16)*0,124+(i-16)*0]:
(i<=24)?[156+(i-20)*0,0+(i-20)*0,156+(i-20)*0]:
(i<=28)?[188+(i-24)*0,0+(i-24)*0,188+(i-24)*0]:
(i<=32)?[220+(i-28)*0,0+(i-28)*0,220+(i-28)*0]:
(i<=36)?[252+(i-32)*0,0+(i-32)*0,252+(i-32)*0]:
(i<=40)?[236+(i-36)*0,0+(i-36)*0,224+(i-36)*0]:
(i<=44)?[220+(i-40)*0,0+(i-40)*0,196+(i-40)*0]:
(i<=48)?[208+(i-44)*0,0+(i-44)*0,168+(i-44)*0]:
(i<=52)?[192+(i-48)*0,0+(i-48)*0,140+(i-48)*0]:
(i<=56)?[180+(i-52)*0,0+(i-52)*0,112+(i-52)*0]:
(i<=60)?[164+(i-56)*0,0+(i-56)*0,84+(i-56)*0]:
(i<=64)?[152+(i-60)*0,0+(i-60)*0,56+(i-60)*0]:
(i<=68)?[136+(i-64)*0,0+(i-64)*0,28+(i-64)*0]:
(i<=72)?[124+(i-68)*0,0+(i-68)*0,0+(i-68)*0]:
(i<=76)?[136+(i-72)*0,28+(i-72)*0,0+(i-72)*0]:
(i<=80)?[152+(i-76)*0,56+(i-76)*0,0+(i-76)*0]:
(i<=84)?[164+(i-80)*0,84+(i-80)*0,0+(i-80)*0]:
(i<=88)?[180+(i-84)*0,112+(i-84)*0,0+(i-84)*0]:
(i<=92)?[192+(i-88)*0,140+(i-88)*0,0+(i-88)*0]:
(i<=96)?[208+(i-92)*0,168+(i-92)*0,0+(i-92)*0]:
(i<=100)?[220+(i-96)*0,196+(i-96)*0,0+(i-96)*0]:
(i<=104)?[236+(i-100)*0,224+(i-100)*0,0+(i-100)*0]:
(i<=108)?[252+(i-104)*0,252+(i-104)*0,0+(i-104)*0]:
(i<=112)?[224+(i-108)*0,236+(i-108)*0,0+(i-108)*0]:
(i<=116)?[196+(i-112)*0,220+(i-112)*0,0+(i-112)*0]:
(i<=120)?[168+(i-116)*0,208+(i-116)*0,0+(i-116)*0]:
(i<=124)?[140+(i-120)*0,192+(i-120)*0,0+(i-120)*0]:
(i<=128)?[112+(i-124)*0,180+(i-124)*0,0+(i-124)*0]:
(i<=132)?[84+(i-128)*0,164+(i-128)*0,0+(i-128)*0]:
(i<=136)?[56+(i-132)*0,152+(i-132)*0,0+(i-132)*0]:
(i<=140)?[28+(i-136)*0,136+(i-136)*0,0+(i-136)*0]:
(i<=144)?[0+(i-140)*0,124+(i-140)*0,0+(i-140)*0]:
(i<=148)?[0+(i-144)*0,136+(i-144)*0,28+(i-144)*0]:
(i<=152)?[0+(i-148)*0,152+(i-148)*0,56+(i-148)*0]:
(i<=156)?[0+(i-152)*0,164+(i-152)*0,84+(i-152)*0]:
(i<=160)?[0+(i-156)*0,180+(i-156)*0,112+(i-156)*0]:
(i<=164)?[0+(i-160)*0,192+(i-160)*0,140+(i-160)*0]:
(i<=168)?[0+(i-164)*0,208+(i-164)*0,168+(i-164)*0]:
(i<=172)?[0+(i-168)*0,220+(i-168)*0,196+(i-168)*0]:
(i<=176)?[0+(i-172)*0,236+(i-172)*0,224+(i-172)*0]:
(i<=180)?[0+(i-176)*0,252+(i-176)*0,252+(i-176)*0]:
(i<=184)?[0+(i-180)*0,224+(i-180)*0,236+(i-180)*0]:
(i<=188)?[0+(i-184)*0,196+(i-184)*0,220+(i-184)*0]:
(i<=192)?[0+(i-188)*0,168+(i-188)*0,208+(i-188)*0]:
(i<=196)?[0+(i-192)*0,140+(i-192)*0,192+(i-192)*0]:
(i<=200)?[0+(i-196)*0,112+(i-196)*0,180+(i-196)*0]:
(i<=204)?[0+(i-200)*0,84+(i-200)*0,164+(i-200)*0]:
(i<=208)?[0+(i-204)*0,56+(i-204)*0,152+(i-204)*0]:
(i<=212)?[0+(i-208)*0,28+(i-208)*0,136+(i-208)*0]:
(i<=216)?[0+(i-212)*0,0+(i-212)*0,124+(i-212)*0]:
(i<=220)?[0+(i-216)*0,0+(i-216)*0,160+(i-216)*0]:
(i<=224)?[0+(i-220)*0,0+(i-220)*0,192+(i-220)*0]:
(i<=228)?[0+(i-224)*0,0+(i-224)*0,216+(i-224)*0]:
(i<=232)?[0+(i-228)*0,0+(i-228)*0,252+(i-228)*0]:
(i<=236)?[252+(i-232)*0,252+(i-232)*0,252+(i-232)*0]:
(i<=256)?[0+(i-236)*13.4211,0+(i-236)*13.4211,0+(i-236)*13.4211]"
elif {$1==9}
f "(i<=61)?[0+(i-0)*2,0+(i-0)*2,0+(i-0)*2]:
(i<=91)?[3+(i-61)*3,3+(i-61)*3,3+(i-61)*3]:
(i<=101)?[91+(i-91)*1,91+(i-91)*1,91+(i-91)*1]:
(i<=145)?[103+(i-101)*3.37209,103+(i-101)*3.37209,103+(i-101)*3.37209]:
(i<=155)?[250+(i-145)*0.555556,250+(i-145)*-27.7778,250+(i-145)*-6.55556]:
(i<=171)?[255+(i-155)*0,0+(i-155)*0,191+(i-155)*-12.7333]:
(i<=191)?[242+(i-171)*-12.7368,12+(i-171)*12.7895,0+(i-171)*0]:
(i<=201)?[0+(i-191)*0,255+(i-191)*0,25+(i-191)*25.5556]:
(i<=211)?[0+(i-201)*0,229+(i-201)*-25.4444,255+(i-201)*0]:
(i<=221)?[0+(i-211)*0,0+(i-211)*0,229+(i-211)*-25.4444]:
(i<=246)?[20+(i-221)*9.79167,20+(i-221)*9.79167,20+(i-221)*9.79167]:
(i<=256)?[255+(i-246)*0,255+(i-246)*0,255+(i-246)*0]"
elif {$1==10}
f "(i<=130)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=165)?[90+(i-130)*-2.64706,160+(i-130)*-4.70588,255+(i-130)*-7.5]:
(i<=183)?[0+(i-165)*15,0+(i-165)*15,0+(i-165)*15]:
(i<=198)?[255+(i-183)*-8.92857,255+(i-183)*-12.5,255+(i-183)*-18.2143]:
(i<=206)?[130+(i-198)*2.85714,80+(i-198)*10,0+(i-198)*0]:
(i<=214)?[0+(i-206)*0,150+(i-206)*-14.2857,160+(i-206)*12.8571]:
(i<=222)?[220+(i-214)*0,0+(i-214)*0,150+(i-214)*14.2857]:
(i<=230)?[226+(i-222)*-13.1429,0+(i-222)*0,0+(i-222)*0]:
(i<=256)?[255+(i-230)*0,255+(i-230)*0,255+(i-230)*0]"
elif {$1==11}
f "(i<=110)?[0+(i-0)*0,0+(i-0)*0,0+(i-0)*0]:
(i<=142)?[0+(i-110)*0.0967742,0+(i-110)*8.09677,255+(i-110)*0]:
(i<=172)?[8+(i-142)*5.44828,243+(i-142)*-8.37931,247+(i-142)*-8.41379]:
(i<=192)?[170+(i-172)*4.47368,12+(i-172)*12.7895,15+(i-172)*12.6316]:
(i<=219)?[246+(i-192)*-9.42308,250+(i-192)*-5.5,246+(i-192)*-9.42308]:
(i<=255)?[7+(i-219)*6.88571,110+(i-219)*3.91429,1+(i-219)*0.0857143]:
(i<=256)?[255+(i-255)*0,255+(i-255)*0,255+(i-255)*0]"
elif {$1==12}
f "(i<=152)?[0+(i-0)*1.30464,0+(i-0)*1.30464,0+(i-0)*1.30464]:
(i<=174)?[0+(i-152)*0,255+(i-152)*-12.1429,255+(i-152)*-6.66667]:
(i<=187)?[0+(i-174)*0,0+(i-174)*21.25,115+(i-174)*-9.58333]:
(i<=197)?[0+(i-187)*28.3333,255+(i-187)*0,0+(i-187)*0]:
(i<=207)?[255+(i-197)*0,255+(i-197)*-28.3333,0+(i-197)*0]:
(i<=216)?[255+(i-206)*-28.3333,0+(i-206)*0,0+(i-206)*0]:
(i<=225)?[0+(i-216)*28.625,0+(i-216)*28.625,0+(i-216)*28.625]:
(i<=236)?[242+(i-225)*-11.5,114+(i-225)*-11.4,195+(i-225)*-6.8]:
(i<=256)?[255+(i-236)*0,255+(i-236)*0,0+(i-236)*13.4211]"
elif {$1==13}
f "(i<=152)?[0+(i-0)*0,0+(i-0)*1.68874,0+(i-0)*1.68874]:
(i<=174)?[0+(i-152)*0,255+(i-152)*-12.1429,255+(i-152)*-6.66667]:
(i<=187)?[0+(i-174)*0,0+(i-174)*21.25,115+(i-174)*-9.58333]:
(i<=196)?[0+(i-187)*31.875,255+(i-187)*0,0+(i-187)*0]:
(i<=207)?[255+(i-196)*0,255+(i-196)*-25.5,0+(i-196)*0]:
(i<=216)?[255+(i-206)*-28.3333,0+(i-206)*0,0+(i-206)*0]:
(i<=225)?[0+(i-216)*28.625,0+(i-216)*28.625,0+(i-216)*28.625]:
(i<=236)?[242+(i-225)*-11.5,114+(i-225)*-11.4,195+(i-225)*-6.8]:
(i<=254)?[255+(i-236)*-15,255+(i-236)*-15,0+(i-236)*0]:
(i<=255)?[255,255,255]"
fi
if $6 rgb2srgb fi
endl done
fx_satellite_preview :
fx_satellite $*


#@gui Rectexture : fx_rectexture, fx_rectexture(1)
#@gui : note = note("Generates textures from rectangles, difference blending and warping.")
#@gui : Recompute = button()
#@gui : Iterations = int(10,0,500)
#@gui : Colours = choice(3,"Random colours &#40;difference blending&#41;","Random colours &#40;diffblend &#43; sine mapping&#41;","Random colours &#40;diffblend &#43; sinemap &#43; random HSV mixing&#41;","Black and white")
#@gui : Warp Multiplier = float(1,0,5)
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")

rectexture:
  split_opacity l[0]

  if {$2==0}
    fill_color[-1] ${-RGB}
  elif {$2==1}
    fill_color[-1] ${-RGB}
  elif {$2==2}
    fill_color[-1] ${-RGB}
  else
    rr={255*round(u)}
    fill_color[-1] $rr,$rr,$rr
  endif
  repeat {max(0,$1)}
    +fill_color 0,0,0
    if {$2==0}
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      blend[-1,-2] difference
    elif {$2==1}
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      blend[-1,-2] difference
    elif {$2==2}
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      blend[-1,-2] difference
    else
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,255,255,255
      blend[-1,-2] difference
    fi
  done
  if {$4==0}
    f={u(0,3)}
  elif {$4==1}
    f={u(0,2)+1}
  else
    f={($4)-2}
  fi
  fx_warp_by_intensity {$3*(u(2)-1)},{$3*(u(2)-1)},{w*$3*(u(2)-1)},{h*$3*(u(2)-1)},0,0,{$f},0,0
  if {$2==1}
       normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
  fi
  if {$2==2}
      normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
      mults=u(0,2.5)
      multv=u(0,2.5)
      fx_mix_hsv {(2^u(0,2.5))-1},{u(-180,180)},0,{(2^$mults)-1},{max(0,2-(2^$mults))*u(-1,1)},0,{(2^$multv)-1},{max(0,2-(2^$multv))*u(-1,1)},0,0,2,0
  fi
  endl a c

fx_rectexture:
  repeat $! l[$>]
    ac "rectexture ${2-5}",$-2,$-1
  endl done

#@gui Crazy Texture: fx_crazy_texture, fx_crazy_texture_preview(1)
#@gui : note = note("Generates black and white textures from deformed edge offsets around Poisson-disk noise.")
#@gui : 1. Recompute = button()
#@gui : sep = separator(), note = note("Poisson-Disk Noise")
#@gui : 2. Radius = float(75,1,1000)
#@gui : 3. Max Sampling Attempts = int(30,1,200)
#@gui : sep = separator(), note = note("Edge Offsets")
#@gui : 4. Smoothness = float(0,0,10)
#@gui : 5. Threshold = float(15,0,50)
#@gui : 6. Scale = int(6,0,32)
#@gui : 7. Thickness = int(3,0,16)
#@gui : 8. Negative Colors = bool(0)
#@gui : sep = separator(), note = note("Deform 1")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;coarse&#41;</small>")
#@gui : 9. Strength = float(15,0,30)
#@gui : 10. Interpolation = choice("none","bilinear","bicubic")
#@gui : 11. Matrix Density &#40;&#37;&#41; = float(1,1,100)
#@gui : 12. Matrix Interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : 13. Matrix Contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("Deform 2")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;fine&#41;</small>")
#@gui : 14. Strength = float(1.5,0,30)
#@gui : 15. Interpolation = choice("none","bilinear","bicubic")
#@gui : 16. Matrix Density &#40;&#37;&#41; = float(1,1,100)
#@gui : 17. Matrix Interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : 18. Matrix Contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("This can slow things down a lot if both deform strengths are high!")
#@gui : 19. Accurate Boundaries = bool(1)
#@gui : 20. Crop Strength = float(1,0,1)
_crazy_texture :
to_rgb fc 0,0,0
ms1=0 if {$10==1} ms1={0.125*max(w,h)/($2^0.375)} else ms1=$11 fi
ms2=0 if {$15==1} ms2={0.625*max(w,h)/($2^0.25)} else ms2=$16 fi
CF={$8*$13*$19}
if {$18} expand_xy {$CF} fi
noise_poissondisk $1,$2
fx_edge_offsets ${3-7}
jr_deform $8,$9,$ms1,$11,$12
jr_deform $13,$14,$ms2,$16,$17
if {$18} shrink_xy {$CF} fi
fx_crazy_texture:
_crazy_texture ${2-20}
fx_crazy_texture_preview :
fx_crazy_texture $*



#@gui _<b>Deformations</b>

#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100,_boundary
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0},${7=1}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
S={${"is_percent $3"}?max(w,h)*$3:$3}
P={$4==0?3:5}
if {$5==1} +r. $3,$3,1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200} else
$3,$3,1,4 noise. $1
fi
ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
endl done v +

#@gui Layer Cake : fx_layer_cake, fx_layer_cake_preview(1)
#@gui : note = note("Splits image into annular or circular layers and rotates each layer. Based on <a href="https://forums.getpaint.net/topic/26566-layer-cake-plugin/">the Paint.NET plugin</a>.")
#@gui : Iterations = int(4,1,32)
#@gui : Angle at Centre = float(360,-1440,1440)
#@gui : Angle Times Iteration = bool(0)
#@gui : Size = float(75,0,200)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Boundary = choice(3,"None","Nearest","Periodic","Mirror")
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Blur = float(0,0,200)
#@gui : sep = separator()
#@gui : Anti-Alias Amplitude = float(30,0,100)
#@gui : Edge Threshold (%) = float(0,0,100)
#@gui : Smoothness = float(3,0,10)
#@gui : Output Layers = choice("Off","Hollow","Filled")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_layer_cake :
repeat $! l[$>]
iter=$1
angle=$2
if $3 angle*=$iter fi
size=$4/2
to_rgba split_opacity to_rgb
repeat 2
part={1-$>}
l[$part]
repeat $iter
[0] rotate[-1] {$angle/$iter*($>+1)},$8,$7,$5%,$6%
100%,100%,1,1 ellipse. $5%,$6%,{$size/$iter*($iter-$>)}%,{$size/$iter*($iter-$>)}%,0,1,255
if {$13!=2} ellipse. $5%,$6%,{$size/$iter*($iter-1-$>)}%,{$size/$iter*($iter-1-$>)}%,0,1,1 fi
blur. {$9/$iter}
fx_smooth_antialias. ${10-12}
blend[-1,-2] multiply
done
if {!$13} blend[^0] add fi
if {$13!=2} 100%,100%,1,1 fc. 255,255,255 ellipse. $5%,$6%,{$size}%,{$size}%,0,1,0
blur. {$9/$iter}
fx_smooth_antialias. ${9-11}
blend[-1,0] multiply fi
if {!$13} blend add fi
if $part to_gray fi
endl
done
list={int($!/2)}
repeat {$list} a[$>,$list] c done
skip {$13==0}
if {$13} rv fi
endl
done
fx_layer_cake_preview:
if {!$13} gui_split_preview "fx_layer_cake $*",${-3--1} else fx_layer_cake ${1-12},0 fi

#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0}
e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
v - repeat $! l[$>]
S={${"is_percent $3"}?max(w,h)*$3:$3}
P={$4==0?3:5}
if {$5==1} +r. $3,$3,1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200} else
$3,$3,1,4 noise. $1
fi
ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
endl done v +

#@gui Random Deformations (JR's Mod) : fx_jr_deform, fx_jr_deform_preview(1)
#@gui : Recompute = button(0)
#@gui : Amplitude = float(5,0,50)
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Matrix Density = float(10,1,100)
#@gui : Matrix Interpolation = choice(1,"Linear","Bicubic")
#@gui : Mode = choice("Noise","Spread noise")
#@gui : Character = float(0,-100,100)
#@gui : Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_jr_deform :
repeat $! l[$>]
jr_deform ${2-8}
endl done
fx_jr_deform_preview :
gui_split_preview "fx_jr_deform $*",${-3--1}

#@gui Buffer Error: fx_buffer_error, fx_buffer_error_preview(0)
#@gui : note = note("<small>Resizes an image without changing the positions of pixels in a simulated image buffer.</small>")
#@gui : 1. Width = float(50,0,200)
#@gui : 2. Height = float(50,0,200)
#@gui : 3. Buffer Start = float(0,0,400)
#@gui : 4. Buffer End = float(100,0,400)
#@gui : 5. Buffer Shift = float(0,0,200)
#@gui : 6. Repeat Buffer = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0

_fx_virtual_buffer :
r {wh},1,100%,100%,-1,0

_fx_virtual_buffer_resize :
wwhh={int(wh)}
dimx={int($1)}
dimy={int($2)}
cs={int($3)}
ce={int($4)}
shift={int($5)}
bound=$6
# transform image to buffer
_fx_virtual_buffer crop $ce,$cs,2 shift {$shift},0,0,0,2  if $bound resize {$dimx*$dimy},1,100%,100%,0,2 fi
# transform buffer into new image
$dimx,$dimy,100%,100%
f. ">begin(index=-1);index+=1;I[#0,index]"
k.
fx_buffer_error :
repeat $! l[$>]
dimx={int($1/100*w)}
dimy={int($2/100*h)}
cs={$3/100*wh}
ce={$4/100*wh}
shift={$5/100*wh}
bound=$6
_fx_virtual_buffer_resize $dimx,$dimy,$cs,$ce,$shift,$bound

endl done
fx_buffer_error_preview :
gui_split_preview "fx_buffer_error $*",${-3--1}

#@gui Buffer Destroyer: fx_buffer_destroyer, fx_buffer_destroyer_preview(0)
#@gui : note = note("<small>A preset combo of filters which rip images apart through simulated buffer manipulation and warping.</small>")
#@gui : 0. Recompute = button(0)
#@gui : 1. Alpha = bool(1)
#@gui : sep = separator(), note = note("<b>Buffer Error 1</b>")
#@gui : 2. Width = float(50,0,200)
#@gui : 3. Height = float(50,0,200)
#@gui : 4. Buffer Start = float(0,0,400)
#@gui : 5. Buffer End = float(100,0,400)
#@gui : 6. Buffer Shift = float(0,0,200)
#@gui : 7. Repeat Buffer = bool(1)
#@gui : sep = separator(), note = note("<b>Shredder</b>")
#@gui : 8. Randomised Start = bool(1)
#@gui : 9. Channels = choice("Correlated","RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : 10. Min Gap = float(50,0,100)
#@gui : 11. Max Gap = float(100,0,100)
#@gui : 12. Strength = float(0.5,0,1)
#@gui : sep = separator(), note = note("<b>Pixel Sort</b>")
#@gui : note = note{"<small><b>Sorting parameters:</b></small>"}
#@gui : 13. Order = choice(1,"Decreasing","Increasing")
#@gui : 14. Axis = choice("X-axis","Y-axis","X-axis Then Y-axis","Y-axis Then X-axis")
#@gui : 15. Sorting Criterion = choice(3,"Red","Green","Blue","Intensity","Luminance","Lightness","Hue",
#@gui : "Saturation","Minimum","Maximum","Random")
#@gui : note = note{"<small><b>Masking parameters:</b></small>"}
#@gui : 16. Mask By = choice("Criterion","Contours","Random")
#@gui : 17. Lower Mask Threshold (%) = float(50,0,100)
#@gui : 18. Higher Mask Threshold (%) = float(100,0,100)
#@gui : 19. Mask Smoothness (%) = float(0,0,5)
#@gui : 20. Invert Mask = bool(0)
#@gui : 21. Preview Mask = bool(0)
#@gui : sep = separator(), note = note("<b>Shifter</b>")
#@gui : 22. Channels = choice("Correlated","RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : 23. X Amplitude = float(1,0,10)
#@gui : 24. X Iterations = int(20,0,400)
#@gui : 25. Y Amplitude = float(1,0,10)
#@gui : 26. Y Iterations = int(20,0,400)
#@gui : 27. Matrix Warp Multiplier = float(1,0,5)
#@gui : 28. Matrix Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : 29. Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : sep = separator(), note = note("<b>Buffer Error 2</b>")
#@gui : 30. Inverse Of BE1 = bool(1)
#@gui : 31. Width = float(120,0,200)
#@gui : 32. Height = float(80,0,200)
#@gui : 33. Buffer Start = float(0,0,400)
#@gui : 34. Buffer End = float(100,0,400)
#@gui : 35. Buffer Shift = float(0,0,200)
#@gui : 36. Repeat Buffer = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0

_fx_buffer_destroyer :
repeat $! l[$>]
to_rgba split_opacity
if $1 a c fi
l[0]
ow={w}
oh={h}
dimx1={int($2/100*w)}
dimy1={int($3/100*h)}
cs1={$4/100*wh}
ce1={$5/100*wh}
shift1={$6/100*wh}
bound1=$7
crit={1+$16}
_fx_virtual_buffer_resize {$dimx1*$dimy1},1,$ce1,$cs1,$shift1,$bound1
_fx_shredder $8,$9,$1,${10-12},0,0,0,0,0
$dimx1,$dimy1,100%,100%
f. ">begin(index=-1);index+=1;I[#0,index]"
k.
_fx_pixelsort ${13-15},{$crit},${17-21}
_fx_shifter $22,$1,${23-29}
if $30
_fx_virtual_buffer_resize $ow,$oh,0,{wh},{-$shift1},$bound1
else
dimx2={int($31/100*w)}
dimy2={int($32/100*h)}
cs2={$33/100*wh}
ce2={$34/100*wh}
shift2={$35/100*wh}
bound2=$36
_fx_virtual_buffer_resize $dimx2,$dimy2,$cs2,$ce2,$shift2,$bound2
fi
endl a c
endl done
fx_buffer_destroyer:
_fx_buffer_destroyer ${2-37}
fx_buffer_destroyer_preview :
gui_split_preview "fx_buffer_destroyer $*",${-3--1}

#@gui UltraWarp 2 : fx_ultrawarptwo, fx_ultrawarptwo_preview(1)
#@gui : 1. Recompute = button(0)
#@gui : sep = separator(), note = note("<b>Warping</b>")
#@gui : 2. Iterations = int(3,1,30)
#@gui : 3. From RGB To = choice(1,"Random","RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : 4. X-Factor Centre = float(0,-30,30)
#@gui : 5. X-Factor Range = float(3,0,30)
#@gui : 6. Y-Factor Centre = float(0,-30,30)
#@gui : 7. Y-Factor Range = float(3,0,30)
#@gui : 8. X-Offset Centre = float(0,-30,30)
#@gui : 9. X-Offset Range = float(3,0,30)
#@gui : 10. Y-Offset Centre = float(0,-30,30)
#@gui : 11. Y-Offset Range = float(3,0,30)
#@gui : 12. Correlated Channels = choice(2,"On","Off","Random")
#@gui : 13. Interpolation = choice(2,"Nearest","Linear","Random")
#@gui : 14. Boundary = choice(5,"Transparent","Nearest","Periodic","Mirror","Random","Random &#40;non-transparent&#41;")
#@gui : 15. Warp Channel(s) = choice(3,"None","Random","All","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 16. Include Alpha = bool(0)
#@gui : 17. To RGB From = choice(1,"Random","RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : 18. Random Negation = bool(1)
#@gui : sep = separator(), note = note("<b>Post-warping HSX8 mixing</b>")
#@gui : 19. Repeat For Each Iteration = bool(1)
#@gui : 20. X Channel = choice("Value","Intensity","Lightness")
#@gui : 21. Hue Factor Centre = float(1,-20,20)
#@gui : 22. Hue Factor Range = float(0.5,0,20)
#@gui : 23. Saturation Factor Centre = float(2.5,-20,20)
#@gui : 24. Saturation Factor Range = float(5,0,20)
#@gui : 25. X Channel Factor Centre = float(1,-20,20)
#@gui : 26. X Channel Factor Range = float(0,0,20)
#@gui : 27. Alpha Factor Centre = float(1,-20,20)
#@gui : 28. Alpha Factor Range = float(0,0,20)
#@gui : 29. Hue Shift Centre = float(0,-255,255)
#@gui : 30. Hue Shift Range = float(255,0,255)
#@gui : 31. Saturation Shift Centre = float(0,-255,255)
#@gui : 32. Saturation Shift Range = float(255,0,255)
#@gui : 33. X Channel Shift Centre = float(0,-255,255)
#@gui : 34. X Channel Shift Range = float(0,0,255)
#@gui : 35. Alpha Shift Centre = float(0,-255,255)
#@gui : 36. Alpha Shift Range = float(0,0,255)
#@gui : sep = separator(), note = note("<b>Custom code</b>")
ultrawarptwo :

repeat $! l[$>] to_rgba split_opacity

iter=$1
sc=$2
xfc=$3
xfr=$4
yfc=$5
yfr=$6
xoffc=$7
xoffr=$8
yoffc=$9
yoffr=$10
corr=$11
inter=$12
bound=$13
chann=$14
alpha=$15
cs=$18
rn=$19

rpo=$18
vil=$19
hfc=$20
hfr=$21
sfc=$22
sfr=$23
vilfc=$24
vilfr=$25
afc=$26
afr=$27
hoffc=$28
hoffr=$29
soffc=$30
soffr=$31
viloffc=$32
viloffr=$33
aoffc=$34
aoffr=$35

repeat $iter
if $alpha

opacity=2
else
opacity=1
fi
repeat $opacity
if {$sc==0}
frgbt={floor(u(0,25))}
else
frgbt={$sc-1}
fi
if {$cs==0}
trgbf={floor(u(0,25))}
else
trgbf={$cs-1}
fi
if {$>==0}
csswap[$>] 0,$frgbt
fi
if {$>==1||$chann!=0}
if {$chann==1}
channel={floor(u(2,37))}
else
channel=$chann
fi
if {$channel==0}
channels=0
elif {$channel>=2}
channels={$channel-1}
elif {$channel>=6}
channels=$channel
else
channels={$channel-2}
fi
if {$corr==2}
correl=round(u)
else
correl=$corr
fi
if {$inter==2}
interp=round(u)
else
interp=$inter
fi
if {$bound==4}
bounds={floor(u(4))}
elif {$bound==5}
bounds={floor(u(3))+1}
else
bounds=$bound
fi
xf={($xfc+u(-$xfr,$xfr))}
yf={($yfc+u(-$yfr,$yfr))}
xoff={($xoffc+u(-$xoffr,$xoffr))}
yoff={($yoffc+u(-$yoffr,$yoffr))}
xff={sign($xf)*w*0.00002*(abs($xf)^2)}
yff={sign($yf)*h*0.00002*(abs($yf)^2)}
xofff={sign($xoff)*w*0.00002*(abs($xoff)^2)}
yofff={sign($yoff)*w*0.00002*(abs($yoff)^2)}
fx_warp_by_intensity[$>] $xff,$yff,$xofff,$yofff,$correl,$interp,$bounds,$channels,0
fi
if {$>==0}
csswap[$>] $trgbf,0
fi
if $rn
if {round(u)}
negate[$>]
fi
fi
done
if {$>==($iter-1)||$rpo}
hf={$hfc+u(-$hfr,$hfr)}
sf={$sfc+u(-$sfr,$sfr)}
vilf={$vilfc+u(-$vilfr,$vilfr)}
af={$afc+u(-$afr,$afr)}
hoff={$hoffc+u(-$hoffr,$hoffr)}
soff={$soffc+u(-$soffr,$soffr)}
viloff={$viloffc+u(-$viloffr,$viloffr)}
aoff={$aoffc+u(-$aoffr,$aoffr)}
l[0] if {$vil==1} rgb2hsi8 elif {$vil==2} rgb2hsl8 else rgb2hsv8 fi
s c
*[0] $hf +[0] {$hoff*max(1,abs($hf))} %[0] 255
*[1] $sf +[1] {$soff*max(1,abs($sf))}
*[2] $vilf +[2] {$viloff*max(1,abs($vilf))}
a c
if {$vil==1} hsi82rgb elif {$vil==2} hsl82rgb else hsv82rgb fi
endl
*[1] $af +[1] {$aoff*max(1,abs($af))}
fi

done
to_rgb[0]
to_gray[1]
a c
endl
done

fx_ultrawarptwo :
ultrawarptwo ${2--1}

fx_ultrawarptwo_preview:
fx_ultrawarptwo $*


#@gui UltraWarp++++ : fx_ultrawarpplusplusplusplus, fx_ultrawarpplusplusplusplus(1)
#@gui :  note  = note("Sequence of multiple partially-randomised texture generation and image deformation filters with multi-iteration warping")
#@gui :  note  = note("<small>This modular filter is extremely complex and its logic may not follow that which you expect. Left on its default settings, it is very likely to munge your image beyond recognition.</small>"), sep = separator()
#@gui :  1.  Recompute  = button(0)
#@gui :  sep  = separator()
#@gui :  2.  Plasma Texture [Discards Input Image]  = bool(0)
#@gui :  3.  Plasma Scale  = float(3.3,0,20)
#@gui :  4.  Plasma Alpha Channel  = bool(0)
#@gui :  sep  = separator()
#@gui :  5.  Segmentation [No Alpha Channel]  = bool(0)
#@gui :  6.  Edge Threshold  = float (5,0.01,60)
#@gui :  7.  Smoothness  = float (0,0,60)
#@gui :  sep  = separator()
#@gui :  8.  Blur  = float (0,0,30)
#@gui :  sep  = separator()
#@gui :  9.  Quadtree Pixelisation [No Alpha Channel]  = bool(0)
#@gui :  10.  Quadtree Min Precision  = int(4,2,8192)
#@gui :  11.  Quadtree Max Precision  = int(256,0,8192)
#@gui :  12.  Quadtree Min Homogeneity  = float(4.8,0,5)
#@gui :  13.  Quadtree Max Homogeneity  = float(5,0,5)
#@gui :  sep  = separator()
#@gui :  14. Noise Type  = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui :  15. Minimum Noise  = float(0,0,8)
#@gui :  16. Maximum Noise  = float(0,0,8)
#@gui :  17. Noise Channel(s)  = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  sep  = separator(), note = note("<small>Warping</small>")
#@gui :  18. Warp Iterations  = int(3,0,30)
#@gui :  19. Warp Intensity  = float(3,0,10)
#@gui :  20. Warp Offset  = float(20,0,2000)
#@gui :  21. Scale to Width  = bool(1)
#@gui :  22. Scale to Height  = bool(1)
#@gui :  23. Correlated Channels  = choice("Random","Off","On")
#@gui :  24. Boundary  = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui :  25. Warp Channel(s)  = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  26. Random Negation  = bool(1)
#@gui :  27. Random Negation Channel(s)  = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  28. Gamma Offset  = float(0.25,0,1)
#@gui :  29. Hue Offset  = float(1,0,1)
#@gui :  30. Normalise  = bool(1)
#@gui :  sep  = separator(), note = note("<small>Final HSV Scaling</small>")
#@gui :  31. Minimum Hue  = float(0,0,20)
#@gui :  32. Maximum Hue  = float(5,0,20)
#@gui :  33. Minimum Saturation  = float(0,0,20)
#@gui :  34. Maximum Saturation  = float(3,0,20)
#@gui :  35. Minimum Value  = float(0.5,0,20)
#@gui :  36. Maximum Value  = float(2,0,20)
#@gui :  note  = note("<small>Set these to their minimum values for randomisation</small>")
#@gui :  37. Hue Offset  = float(-180.01, -180.01, 180)
#@gui :  38. Saturation Offset  = float(0, -1.01, 1)
#@gui :  39. Value Offset  = float(0,-20.01,20)
#@gui :  sep  = separator(),
#@gui :  -4. Normalise  = bool(1)
#@gui :  -3. Normalisation Channel(s)  = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  sep  = separator(),
#@gui :  -2. UltraWarp++++ Channel(s)  = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  -1. Value Action  = choice("None","Cut","Normalize")
ultrawarpplusplusplusplus:
hue_min={$30}
hue_max={$31}
sat_min={$32}
sat_max={$33}
val_min={$34}
val_max={$35}
j={min($hue_min,$hue_max)+(u*(max($hue_min,$hue_max)-min($hue_min,$hue_max)))}
k={min($sat_min,$sat_max)+(u*(max($sat_min,$sat_max)-min($sat_min,$sat_max)))}
l={min($val_min,$val_max)+(u*(max($val_min,$val_max)-min($val_min,$val_max)))}
if {$1}
if {$2} ch=0 -else ch=2 -endif
ac  "rr={round(u*255)}
gg={round(u*255)}
bb={round(u*255)}
fx_plasma 0.5,0,{$2},1,1,{$rr},{$gg},{$bb}
if {$3} to_rgba else ch=2 -to_rgb -endif",{$ch} fi
fx_gaussian_blur {$7},0,0,1,2,0,0
n_min=$14
n_max=$15
if {$n_min>$n_max}
n_min = {$n_min + $n_max}
n_max = {$n_min - $n_max}
n_min = {$n_min - $n_max}
fi
noise_exp={max(0,$n_min+(u*($n_max-$n_min)))}
n_amt={(2^($noise_exp-3))*$noise_exp}
if {$4} fx_segment_watershed {$5},{$6},0,2,0 fi
if {$8}
p_min={$9}
p_max={$10}
h_min={$11}
h_max={$12}
if {$p_min>$p_max}
p_min = {$p_min + $p_max}
p_max = {$p_min - $p_max}
p_min = {$p_min - $p_max}
fi
if {$h_min>$h_max}
h_min = {$h_min + $h_max}
h_max = {$h_min - $h_max}
h_min = {$h_min - $h_max}
fi
fx_noise {$n_amt},{$13},{$16},1,0
fx_quadtree 0,{max(2,round($p_min+(u*($p_max-$p_min))))},{max(0,round($h_min+(u*($h_max-$h_min))))},0,3,1.5,1,1,0
fi
fx_noise {$n_amt},{$13},{$16},1,0
f={$17}
i={$18}
m={$19}
s={$20}
v={$21}
repeat {max(0,$f)}
if {$20}
scale_x=w/10
a={((2^($18-5))*$18)*(u-0.5)*$scale_x*0.025}
else
scale_x=1
a={((2^($18-5))*$18)*(u-0.5)}
fi
if {$22}
scale_y=h/10
b={((2^($18-5))*$18)*(u-0.5)*$scale_y*0.025}
else
scale_y=1
b={((2^($18-5))*$18)*(u-0.5)}
fi
c=(u-0.5)*$m*sign($m)*$scale_x
d=(u-0.5)*$m*sign($m)*$scale_y
g={round((u*33.98)-0.49)}
h={(u-0.5)*$s*200}
o={(u-0.5)*$v*200}
if {$22==1}
e=0
elif {$22==2}
e=1
else
e={round(u)}
fi
if {$23==0}
f={round((u*2.98)-0.49)}
elif {$23==1}
f={round((u*2.98)+0.51)}
else
f={($23)-2}
fi
ac  "_fx_warp_by_intensity "{$a}","{$b}","{$c}","{$d}","{$e}",0,"{$f}"",{$24},0
if {$25}
nn={round(u)}
if {$nn}
if {$26==0}
nch={round((u*33.98)-0.49)}
ac "-negate",{$nch}
else
ac "-negate",{$26}
fi
fi
fi
fx_adjust_colors 0,0,{$h},{$o},0,0
if {$29}
ac "n 0,255",3
fi
done
if {$36==-180.1}
hh=((u-0.5)*360)
else
hh={$36}
fi
if {$37==-8.01}
ss=((u-0.5)*2)
else
ss={$37}
fi
if {$38==-20.01}
vv=((u-0.5)*2)
else
vv={$38}
fi
fx_mix_hsv {$j},{$hh},0,{$k},{$ss},0,{$l},{$vv},0,0,2,0
if {$-2}
ac "n 0,255",{$-1}
fi
fx_ultrawarpplusplusplusplus:
repeat $! l[$>]
ac "ultrawarpplusplusplusplus ${2--3}",$-2,$-1
fx_adjust_colors 0,0,0,{(u-0.5)*200},0,0
endl done

#@gui Rays from Image : fx_rays_from_image, fx_rays_from_image(1)
#@gui : Power = float(5,0,10)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")

rays_from_image:

fx_transform_polar 0,$2,$3,"(R-a)*(4^(($1)-5))*$1/5","a",3

fx_rays_from_image:

repeat {max(0,l)}
  ac[$>] "rays_from_image $*",$-2,$-1
done

#@gui Shifter : fx_shifter, fx_shifter_preview(1)
#@gui : Recompute = button(0)
#@gui : Channels = choice("Correlated","RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : Alpha = bool(1)
#@gui : X Amplitude = float(1,0,10)
#@gui : X Iterations = int(20,0,400)
#@gui : Y Amplitude = float(1,0,10)
#@gui : Y Iterations = int(20,0,400)
#@gui : Matrix Warp Multiplier = float(1,0,5)
#@gui : Matrix Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
_fx_shifter:
repeat $! l[$>]
to_rgba split_opacity
if $2 a c fi
l[0]
if $1
csswap 0,{$1-1} s c
fi
repeat $! l[$>]
100%,100%,1,3 [1] fc[1,2] 0
rectexture[1] $4,0,$7,$8,2,0
rectexture[2] $6,0,$7,$8,2,0
to_gray[^0]
f[1] "$3*510*(0.25-abs(0.5-i/255))"
f[2] "$5*510*(0.25-abs(0.5-i/255))"
a[^0] c
if {$9==0}
f={u(0,3)}
elif {$9==1}
f={u(0,2)+1}
else
f={($9)-2}
fi
warp.. .,1,0,{int($f)}
rm.
endl done
endl
a c
if $1
csswap {$1-1},0
fi
endl done

fx_shifter:
_fx_shifter ${2-10}
fx_shifter_preview:
gui_split_preview "fx_shifter $*",${-3--1}

#@gui _<b>Contours</b>

#@gui Gradient Norm [JR's Mod] : fx_jr_gradient_norm, fx_jr_gradient_norm_preview(1)
#@gui : Smoothness = float(0,0,10)
#@gui : Contrast = float(0.45,0,1.5)
#@gui : Min Threshold = float(40,0,100)
#@gui : Max Threshold = float(60,0,100)
#@gui : Negative = bool(0)
#@gui : Include Orientation = choice("Off","On","On &#40;extrapolate if negative&#41;")
#@gui : Scale X = float(1,0,5)
#@gui : Scale Y = float(1,0,5)
#@gui : Interpolation = choice(2,"Nearest","Average","Bilinear","Bicubic")
#@gui : Alpha = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")

jr_dir2rgb :
v - channels 0,1 repeat $! l[$>] nm={0,n}
s c complex2polar round.. 0.001
*. {180/pi} %. 360 100%,100%,1,1,1 mv... $!
c 0,360 if {im!=iM} n. 0,1 else f. 1  fi
a c hsv2rgb
nm $nm endl done v +

jr_gradient_norm :
b $1 gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255

fx_jr_gradient_norm :
repeat $! l[$>]
if {$9==3}
inter=5
else
inter={1+$9}
fi
if {$7!=1||$8!=1}
ww={w}
hh={h}
shift -0.5,-0.5,0,0,1
r {max(1,$7*w)},{max(1,$8*h)},100%,100%,$inter
fi
if $6
+l luminance gradient append c
blur $1 orientation +jr_dir2rgb
endl rm[1]
if $5
l[1]
rgb2hsv8 100%,100%,1,1 f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
if {$6==2}
fx_solidify_td 100,0,10,2,0
fi
rgb2hsv8 f "[i0,i1,255]" hsv82rgb
endl
fi
fi
jr_gradient_norm[0] ${1-5}
if {$7!=1||$8!=1}
r $ww,$hh,100%,100%,$inter
fi
if $6 blend multiply fi
if {$6==1} c 0,255 f "I==[255,255,255]?[0,0,0]:I" fi
if $10 rgb2hsv8 100%,100%,1,1 if {$6} [1] f[2] "j(#0,0,0,0,1)" f[0] "[i0,255,i2]" fi f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0] if {$6} blend[1,2] multiply fi a c fi
endl done
fx_jr_gradient_norm_preview :
gui_split_preview "fx_jr_gradient_norm $*",${-3--1}

#@gui _<b>Colors</b>

#@gui Quick Desaturate: jr_desaturate, jr_desaturate_preview(1)
#@gui : note = note("Generates greyscale images, allowing for different &#40;s&#47;&#41;RGB channel intensities before merging. A smaller counterpart to the 'Black &#38; White' filter intended for generating intensity maps.")
#@gui : Colour Space = choice("RGB","sRGB")
#@gui : Channel 1 = float(1,0,3)
#@gui : Channel 2 = float(1,0,3)
#@gui : Channel 3 = float(1,0,3)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
jr_desaturate :
repeat $! l[$>] split_opacity l[0] to_rgb if $1 srgb2rgb fi
f "avg(i0*$2,i1*$3,i2*$4)" if $5 n 0,255 fi c 0,255
endl a c endl done
jr_desaturate_preview :
gui_split_preview "jr_desaturate $*",${-3--1}


#@cli rgb2ycbcrglic : convert from rgb to ycbcrglic
#see https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde
rgb2ycbcrglic :
split_opacity l[0] to_rgb
f "R=i0;G=i1;B=i2;
  [0.2988390*R+0.5868110*G+0.1143500*B,-0.168736*R-0.3312640*G+0.5000000*B+127.5,0.5000000*R-0.4186880*G-0.0813120*B+127.5]"
endl a c
#@cli ycbcrglic2rgb : convert from ycbcrglic to rgb
ycbcrglic2rgb :
split_opacity l[0] to_rgb
 f "Y=i0;Cb=i1-127.5;Cr=i2-127.5;
# original GLIC implementation added 1 to each channel to correct the transformation
  [Y+1.402*Cr,Y-0.344136*Cb-0.714136*Cr,Y+1.772000*Cb]"
endl a c

#@gui Colour Space Swap: csswap, csswap_preview()
#@gui : To RGB From = choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : From RGB To = choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
csswap:
repeat $! l[$>] split_opacity l[0] to_rgb
cs=$1
sc=$2
if {$cs==1} srgb2rgb
elif {$cs==2} hsv82rgb
elif {$cs==3} hsv2rgb
elif {$cs==4} hsl82rgb
elif {$cs==5} hsl2rgb
elif {$cs==6} hsi82rgb
elif {$cs==7} hsi2rgb
elif {$cs==8} lch82rgb
elif {$cs==9} lch2rgb
elif {$cs==10} lab82rgb
elif {$cs==11} lab2rgb
elif {$cs==12} ycbcr2rgb
elif {$cs==13} ycbcrglic2rgb
elif {$cs==14} gcd_jpeg2srgb srgb2rgb
elif {$cs==15} yiq82rgb
elif {$cs==16} yiq2rgb
elif {$cs==17} yuv82rgb
elif {$cs==18} yuv2rgb
elif {$cs==19} hcy2rgb
elif {$cs==20} xyz82rgb
elif {$cs==21} xyz2rgb
elif {$cs==22} ryb2rgb
elif {$cs==23} cmy2rgb
elif {$cs==24} cmyk2rgb
elif {$cs==25} bayer2rgb 0,0,0
fi
if {$sc==1} rgb2srgb
elif {$sc==2} rgb2hsv8
elif {$sc==3} rgb2hsv
elif {$sc==4} rgb2hsl8
elif {$sc==5} rgb2hsl
elif {$sc==6} rgb2hsi8
elif {$sc==7} rgb2hsi
elif {$sc==8} rgb2lch8
elif {$sc==9} rgb2lch
elif {$sc==10} rgb2lab8
elif {$sc==11} rgb2lab
elif {$sc==12} rgb2ycbcr
elif {$sc==13} rgb2ycbcrglic
elif {$sc==14} rgb2srgb gcd_srgb2jpeg
elif {$sc==15} rgb2yiq8
elif {$sc==16} rgb2yiq
elif {$sc==17} rgb2yuv8
elif {$sc==18} rgb2yuv
elif {$sc==19} rgb2hcy
elif {$sc==20} rgb2xyz8
elif {$sc==21} rgb2xyz
elif {$sc==22} rgb2ryb
elif {$sc==23} rgb2cmy
elif {$sc==24} rgb2cmyk
elif {$sc==25} rgb2bayer 0
fi
to_rgb endl a c endl done
csswap_preview :
gui_split_preview "csswap $*",${-3--1}

#@gui CubeHelix: fx_cubehelix, fx_cubehelix_preview(1)
#@gui : note = note("<small>Implements and extends <a href="https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/">the CubeHelix family of colour schemes</a>, allowing for interpolation between two colours as well as scaling the helix dimensions for each individual channel based on those colours.</small>")
#@gui : Convert to Grayscale = bool(1)
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Pre-Normalise = bool(0)
#@gui : Start Colour = color(0,0,0)
#@gui : End Colour = color(255,255,255)
#@gui : Start Hue = float(1,0,3)
#@gui : Rotations = float(-1.5,-20,20)
#@gui : Hue Intensity = float(1,0,5)
#@gui : Gamma Power = float(0,-4,4)
#@gui : sep = separator()
#@gui : Scale Colour Variations = float(1,-4,4)
#@gui : note = note("<small>Scales the colour variations to reflect the difference between the start and end colours. For example, a value of 0 when going from black to yellow will flatten the helix so that only the red and green channels vary.</small>")
#@gui : sep = separator()
#@gui : Red Cos = float(-0.14861,-4.00000,4.00000)
#@gui : Red Sin = float(1.78277,-4.00000,4.00000)
#@gui : Green Cos = float(-0.29227,-4.00000,4.00000)
#@gui : Green Sin = float(-0.90649,-4.00000,4.00000)
#@gui : Blue Cos = float(1.97294,-4.00000,4.00000)
#@gui : Blue Sin = float(0.00000,-4.00000,4.00000)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_cubehelix :
scv={-$15}
repeat $! l[$>]
if $1 to_gray fi to_rgb abs c 0,255 c $2%,$3% if $4 n 0,255 fi *. {1/255}
f "angle=(2*pi*(($11/3)+1+$12*I));fract=(I^(2^($14^2)));amp=($13*fract*(1-fract)/2);
helix=(amp*[$16*cos(angle[0])+$17*sin(angle[0]),$18*cos(angle[1])+$19*sin(angle[1]),$20*cos(angle[2]+$21*sin(angle[2]))]);
scale=([${8-10}]-[${5-7}])/255;
([${5-7}]/255)-"$scv"*(fract*scale+helix)+(1+"$scv")*(fract+(helix*sign(scale)))*scale"
c 0,1
*. 255
endl done
fx_cubehelix_preview :
gui_split_preview "fx_cubehelix $*",${-3--1}

#@gui _<b>Details</b>

bitplane8 :
100%,100%,8,100%,"(i(#-1,x,y,0,c)>>z)&1" rm[0]

debitplane8 :
f "a=0;for(k=0,k<8,++k,a+=i(x,y,k)*2^k)"

#@gui 8-Bits Planes : fx_bitplane8, fx_bitplane8_preview(1)
#@gui : Mode = choice("Decompose","Recompose")
#@gui : Split Mode = choice(1,"Z layers","Separate images")
#@gui : Scale Mode = choice("True","1","255")
#@gui : Alpha = bool(0)
fx_bitplane8 :
if $1
##recompose
if {!$2} s z fi
repeat {int($!/8)} l[$>-{$>+7}]
repeat 8
iter=$>
l[$>]
if {$3==0}
/ {2^$iter} cut 0,1 round 0,1 * {2^$iter}
elif {$3==1}
cut 0,1 round 0,1 * {2^$iter}
elif {$3==2}
/ 255 cut 0,1 round 0,1 * {2^$iter}
fi
endl done
+
endl done
else
##decompose
repeat 8
[0]
&[-1] {2^$>}
if {$3==1}
/[-1] {2^$>}
elif {$3==2}
/[-1] {2^$>/255}
fi
if {!$2} a[^0] z fi
done
rm[0]
fi
#n 0,255
fx_bitplane8_preview :
fx_bitplane8 $*

#@gui _<b>Degradations</b>

#@gui Shredder : fx_shredder, fx_shredder_preview(0)
#@gui : note = note("<small>Re-fills an image with its own values but makes random jumps in the relative positions where the lookup for the values takes place. Can be channel-independent. Relative gap sizes are cubed to make it easier to use small gaps between jumps.</small>")
#@gui : 0. Recompute = button(0)
#@gui : 1. Randomised Start = bool(1)
#@gui : 2. Channels = choice("Correlated","RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : 3. Alpha = bool(1)
#@gui : 4. X Min Gap = float(0,0,100)
#@gui : 5. X Max Gap = float(100,0,100)
#@gui : 6. X Strength = float(0.5,0,1)
#@gui : 7. Y Min Gap = float(0,0,100)
#@gui : 8. Y Max Gap = float(100,0,100)
#@gui : 9. Y Strength = float(0.5,0,1)
#@gui : 10. Mirror = choice("None","X","Y","XY")
#@gui : 11. Rotate = choice("None,"90 clockwise","180","90 anticlockwise")
_fx_shredder :
repeat $! l[$>]
xming={$4/100}
xmaxg={$5/100}
strengthx={($6^4)}
yming={$7/100}
ymaxg={$8/100}
strengthy={($9^4)}
to_rgba split_opacity to_rgb.. to_gray.
l[0]
if $2
csswap 0,{($2)-1}
fi
endl
if $3 a c fi
l[0]
if {$10==1}
mirror[0] x
elif {$10==2}
mirror[0] y
elif {$10==3}
mirror[0] xy
fi
if $11
rotate[0] {$11*90},0
fi
[0]
f[0] ">begin((!$1)?(col=0;row=0):(col=u*w^2;row=u*h^2);countx=(u("$xming","$xmaxg")^3)*wh+1;county=(u("$yming","$ymaxg")^3)*wh+1);
countx-=1;
county-=1;
countx<=0?(col=(u*w);countx=(u("$xming","$xmaxg")^3)*wh+1);
county<=0?(row=(u*h);county=(u("$yming","$ymaxg")^3)*wh+1);
(!$2)?J(#-1,"$strengthx"*col,"$strengthy"*row,0,0,2)
:j(#-1,"$strengthx"*col,"$strengthy"*row,0,0,0,2)"
rm[1]
if $11
rotate[0] {-$11*90},0
fi
if {$10==1}
mirror[0] x
elif {$10==2}
mirror[0] y
elif {$10==3}
mirror[0] xy
fi
if {$2>=1}
s[0] c
if {$3} a[^-1] c else a c fi
l[0]
if $2
csswap {($2)-1},0
fi
endl
fi
endl
a c
endl done

fx_shredder :
_fx_shredder ${2--1}
fx_shredder_preview :
fx_shredder $*

#@gui Blur [Bloom Glare] : fx_blur_bloom_glare, fx_blur_bloom_glare_preview(0)
#@gui : Amplitude = float(1,0,20)
#@gui : Ratio = float(2,0,10)
#@gui : Iterations = int(5,0,200)
#@gui : Operator = choice("Add","Max","Min")
#@gui : Kernel = choice("Quasi-gaussian","Gaussian","Box","Triangle","Quadratic")
#@gui : Normalize Scales = bool(0)
#@gui : Anisotropy = bool(0)
#@gui : Angle = float(0,0,180)
#@gui : Axis = int(3,1,20)
#@gui : Opacity = float(0.5,0,1)
#@gui : note = note("Parameters <i>Angle</i>, <i>Axis</i> and <i>Opacity</i> are only active when <i>Anisotropy</i> is checked")
#@gui : sep = separator()
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator()
#@gui : Preview Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest update: <i>2015/03/02</i>.</small>")
fx_blur_bloom_glare :
op=${"arg 1+$4,+,max,min"}
if {!$7}
	ac "blur_bloom ${1-3},"$op",${5-6},xy",$11
else
	wh={[w,h]}
	repeat $9
		ang={(180/$9)*($>)+$8}
		+rotate[0] $ang,2,1
		ac. "blur_bloom ${1-3},"$op",${5-6},x",$11
		rotate. {-$ang},2,1
		r. $wh,1,100%,0,0,0.5,0.5
		c. 0,255
	done
	repeat {$9}
		blend[0,-1] screen,$10
	done
fi
fx_blur_bloom_glare_preview :
gui_split_preview "fx_blur_bloom_glare $*",$-1

#@gui Bomb Blend : fx_blend_bomb, fx_blend_bomb_preview()
#@gui : note = note("Creates a random transfer function 'mesh' and then blends images accordingly. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : Recompute = button(0)
#@gui : Process As = choice(1,"Two-by-two","Self-blend for each layer")
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh Smoothness = float(2,0,10)
#@gui : Contrast Scheme = choice("Arctan","Clip","Power")
#@gui : Mesh Contrast = float(50,0,100)
#@gui : Reverse Blending Layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Alpha = bool(0)
#@gui : Normalise = bool(0)
#@gui : Output Mesh = bool(0)

_blend_bomb :
to_rgba
$1,$2,1,4 noise. 255
if $8 ac. "noise 255",rgba_a fi
r. 256,256 n. 0,255 blur. {$3^2}%
l. if {$4==0}
f "val = i/255; (val-0.5+(atan((val-0.5)*($5/10)^3)/pi)+0.5)*255" n 0,255
elif {$4==1}
c {($5-1/255)/2}%,{100-($5-1/255)/2}% n 0,255
elif {$4==2}
f "val = (2*i/255)-1; (val*(abs(val)^(0-($5/100)))+1)*255/2"
fi endl
rv
fx_mesh_blend 0,1,$6,$7,$8,$10
if $9 ac "n 0,255",rgba fi

blend_bomb :
if {$1==0} repeat {int($!/2)} l[$>,{$>+1}] _blend_bomb ${2--1} endl done
elif {$1==1} repeat $! l[$>] [0] _blend_bomb ${2--1} endl done fi

fx_blend_bomb :
blend_bomb ${2--1}

fx_blend_bomb_preview :
fx_blend_bomb $*

#@gui JFIF [JPEG] Self-Bomb : fx_jfif_bomb, fx_jfif_bomb_preview()
#@gui : note = note("OI! TRY SMOOTHING THIS!")
#@gui : note = note("<small>Adds JPEG artefacts and then self-bomb-blends. Use grid interpolation with scale factors above 1 to destroy the results even more.</small>")
#@gui : Recompute = button(0)
#@gui : sep = separator()
#@gui : Quality (%) = int(50,1,100)
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh Smoothness = float(0.5,0,10)
#@gui : Contrast Scheme = choice(1,"Arctan","Clip","Power)
#@gui : Mesh Contrast = float(75,0,100)
#@gui : Scale X = float(1,0.05,16)
#@gui : Scale Y = float(1,0.05,16)
#@gui : Interpolation = choice(0,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Normalize = bool(0)
#@gui : Output Mesh = bool(0)
#@gui : sep = separator()
#@gui : Solidify Alpha = bool(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-oriented","Edge-oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Dilation / Erosion = int(0,-20,20)
#@gui : Colorspace = choice(1,"sRGB","Linear RGB")
_fx_jfif_bomb :
repeat $! l[$>]
if $12
+fx_solidify_td ${13-17}
negate. rv blend alpha
fi
ww={w}
hh={h}
r {$7*100}%,{$8*100}%,100%,100%,$9
fx_jpeg_artefacts $1
blend_bomb 1,${2-6},0,0,0,${10-11}
r $ww,$hh,100%,100%,$9
endl done
fx_jfif_bomb:
_fx_jfif_bomb ${2--1}
fx_jfif_bomb_preview :
fx_jfif_bomb $*

#@gui Noise [Additive] : fx_noise, fx_noise_preview(0)
#@gui : Amplitude = float(10,0,200)
#@gui : Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice(1,"None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
jr_fx_noise :
ac "_fx_noise $1,$2",$3,$4
_jr_fx_noise :
repeat $! l[$>] split_opacity l[0] noise $1,$2 endl a c endl done
jr_fx_noise_preview :
gui_split_preview "jr_fx_noise $*",${-3--1}

#@gui Cascading Self Glitching : fx_self_glitching_cascade, fx_self_glitching_cascade_preview(1)
#@gui : note = note("Shifts images in a cascading fashion but computes values based on shifted and original images.")
#@gui : note = note("<small>This filter has many channel options and many operation options allowing for extremely-distorted images. Don't always trust the preview!</small>"), sep = separator()
#@gui : 1. Shift Channels = choice("RGB&#47;sRGB","CMYK&#47;CMY","HSV&#47;HSV8","HSL&#47;HSL8","HSI&#47;HSI8","LCH&#47;LCH8","Lab&#47;Lab8","YCbCr&#47;YCbCrGLIC","YIQ&#47;YIQ8","YUV&#47;YUV8","RYB&#47;HCY","XYZ&#47;XYZ8")
#@gui : 2. Alt Choice = bool(0)
#@gui : 3. Process Alpha = bool(0)
#@gui : 4,5. Zeroth Shift = point(50,50,0,1,255,255,255,175)
#@gui : 6. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : 7. Iterations = int(3,1,64)
#@gui : 8. Repeat Post-Shift Operations = bool(1)
#@gui : sep = separator()
#@gui : 9,10. Shift Target = point(55,55,0,1,255,0,0,175)
#@gui : 11. Target for Final &#40;Rather than First&#41; Shift = bool(0)
#@gui : 12,13. Cascade Centre Point = point(45,45,0,1,0,255,0,175)
#@gui : 14. Shift Randomness = float(0.75,0,4)
#@gui : 15. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : 16. Power = float(0,-5,5)
#@gui : 17. Bias = float(0,-256,256)
#@gui : 18. Negation = bool(0)
#@gui : 19. Shift Operator = choice("Add","Multiply","Bitwise And","Bitwise Or","Bitwise Xor","Power","Reverse Power",
#@gui : "Modulo","Reverse Modulo","Divide","Reverse Divide","Subtract","Reverse Subtract",
#@gui : "Left Bitwise Shift","Reverse LBS","Right Bitwise Shift","Reverse RBS","Left Bitwise Rotation","Reverse LBR","Right Bitwise Rotation","Reverse RBR",
#@gui : "Average","Round","Reverse Round","Sine","Reverse Sine","Cosine","Reverse Cosine","Tangent","Reverse Tangent &#40;CPU-intensive&#41;",
#@gui : "Cosecant","Reverse Cosecant","Secant","Reverse Secant","Cotangent","Reverse Cotangent","Variance","Difference","Minimum","Maximum",
#@gui : "Interference &#40;Add&#41;","Reverse Interference &#40;Add&#41;","Interference &#40;Multiply&#41;",
#@gui : "Interference &#40;Divide&#41;","Reverse Interference &#40;Div&#41;",
#@gui : "Interference &#40;Subtract&#41;","Reverse Interference &#40;Subt&#41;","Interference &#40;Rev Subt&#41;","Reverse Interference &#40;Rev Subt&#41;",
#@gui : "Interference &#40;Difference&#41;","Reverse Interference &#40;Diff&#41;","Interference &#40;Variance&#41;",
#@gui : "Screen","Colour Dodge","Reverse Colour Dodge","Colour Burn","Reverse Colour Burn","Soft Light &#40;illusions&#46;hu&#41;","Reverse Soft Light &#40;illusions&#46;hu&#41;",
#@gui : "Geometric Mean","Bright Hard Mix","Dark Hard Mix")
#@gui : 20. Multiplier 1 = float(1,-10,10)
#@gui : 21. Addition 1 = int(0,-1024,1024)
#@gui : 22. Sawtoother Mode = choice(0,"Modulo","Triangular-Modulo","Legacy Modulo")
#@gui : 23. Maximum End Value = int(256,0,1024)
#@gui : 24. Multiplier 2 = float(1,-10,10)
#@gui : 25. Addition 2 = int(0,-1024,1024)
#@gui : sep = separator(), 26. Run on channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Original author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>&#59; extended by some nobody who calls themselves 'Joan Rake' or something.<p>Latest update: <i>2018/08/24</i>.</small>")
fx_self_glitching_cascade :
skip "${25=-skip ,}","${26=-skip ,}"
shift {$4-50}%,{$5-50}%,0,0,$6,0
repeat $! l[$>] if {!$3} split_opacity fi l[0] to_rgb
if {$2}
if {$1==0} rgb2srgb
elif {$1==1} rgb2cmy
elif {$1==2} rgb2hsv8
elif {$1==3} rgb2hsl8
elif {$1==4} rgb2hsi8
elif {$1==5} rgb2lch8
elif {$1==6} rgb2lab8
elif {$1==7} rgb2ycbcrglic
elif {$1==8} rgb2yiq8
elif {$1==9} rgb2yuv8
elif {$1==10} rgb2hcy
elif {$1==11} rgb2xyz8
fi else
if {$1==1} rgb2cmyk
elif {$1==2} rgb2hsv
elif {$1==3} rgb2hsl
elif {$1==4} rgb2hsi
elif {$1==5} rgb2lch
elif {$1==6} rgb2lab
elif {$1==7} rgb2ycbcr
elif {$1==8} rgb2yiq
elif {$1==9} rgb2yuv
elif {$1==10} rgb2bayer 0
elif {$1==11} rgb2xyz
fi fi
if $11 stype=$7 else stype=1 fi
repeat $7
+shift[0] {((([w,h]-1)*([$12,$13]-[$9,$10]+[u(-1,1),u(-1,1)]*sqrt((($12-$9)^2)+(($13-$10)^2))*($14^3)))/$stype)/100},0,0,$15
f.. "begin(
const sign = $18?-1:1;
);
operate(mode,s1,s2,mult,power) =
(mode==0?(s1 + s2):
mode==1?(s1 * s2):
mode==2?(s1 & s2):
mode==3?(s1 | s2):
mode==4?xor(s1,s2):
mode==5?(s1^(s2*0.01)):
mode==6?(s2^(s1*0.01)):
mode==7?(s1%s2):
mode==8?(s2%s1):
mode==9?(s1 / s2):
mode==10?(s2 / s1):
mode==11?(s2 - s1):
mode==12?(s1 - s2):
mode==13?(s1 << s2):
mode==14?(s2 << s1):
mode==15?(s1 >> s2):
mode==16?(s2 >> s1):
mode==17?for(n=0,n<(s2%32),n++,rol(s1)):
mode==18?for(n=0,n<(s1%32),n++,rol(s2)):
mode==19?for(n=0,n<(s2%32),n++,ror(s1)):
mode==20?for(n=0,n<(s1%32),n++,ror(s2)):
mode==21?avg(s2,s1):
mode==22?round(s1,s2,0):
mode==23?round(s2,s1,0):
mode==24?s2*sin(s1*2*pi/mult):
mode==25?s1*sin(s2*2*pi/mult):
mode==26?sign*s2*cos(s1*2*pi/mult):
mode==27?sign*s1*cos(s2*2*pi/mult):
mode==28?s2*tan(s1*pi/mult):
mode==29?s1*tan(s2*pi/mult):
mode==30?s2*sin(mult/(s1*2*pi)):
mode==31?s1*sin(mult/(s2*2*pi)):
mode==32?sign*s2*cos(mult/(s1*2*pi)):
mode==33?sign*s1*cos(mult/(s2*2*pi)):
mode==34?s2*tan(mult/(s1*pi)):
mode==35?s1*tan(mult/(s2*pi)):
mode==36?mult*var(s1,s2):
mode==37?abs(s2 - s1):
mode==38?min(s2,s1):
mode==39?max(s2,s1):
mode==40?0.005*s2*(((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power))+s1):
mode==41?0.005*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)+s2):
mode==42?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)*s1:
mode==43?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s1:
mode==44?0.1*s1*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s2:
mode==45?0.001*s2*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==46?0.001*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==47?0.001*s2*(s1-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==48?0.001*s1*(s2-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==49?0.001*s2*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==50?0.001*s1*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==51?0.00001*mult*var(s1,s2,(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==52?(255-((255-s1)*(255-s2))):
mode==53?(s1/(255-s2)):
mode==54?(s2/(255-s1)):
mode==55?((255-s2)/s1*255):
mode==56?((255-s1)/s2*255):
mode==57?((((s1)/255)^2)^(2*(0.5-(s2/255))))*255:
mode==58?((((s2)/255)^2)^(2*(0.5-(s1/255))))*255:
mode==59?sqrt(abs(s1*s2)):
mode==60?(if((s1+s2)>=255,255,0)):
(if((s1+s2)<=255,0,255)));
val = sign*((2^$16)*j(#-1) + $17);operate($19,val,i,$20,$16);
" rm.
if {$8}
*. $20 +. $21 if {$22==2} if $23 %. $23 fi else if $23 modf $22,$23,1,0 fi fi *. $24 +. $25
fi
done
if {!$8}
*. $20 +. $21 if {$22==2} if $23 %. $23 fi else if $23 modf $22,$23,1,0 fi fi *. $24 +. $25
fi
if {$2}
if {$1==0} srgb2rgb
elif {$1==1} cmy2rgb
elif {$1==2} hsv82rgb
elif {$1==3} hsl82rgb
elif {$1==4} hsi82rgb
elif {$1==5} lch82rgb
elif {$1==6} lab82rgb
elif {$1==7} ycbcrglic2rgb
elif {$1==8} yiq82rgb
elif {$1==9} yuv82rgb
elif {$1==10} hcy2rgb
elif {$1==11} xyz82rgb
fi else
if {$1==1} cmyk2rgb
elif {$1==2} hsv2rgb
elif {$1==3} hsl2rgb
elif {$1==4} hsi2rgb
elif {$1==5} lch2rgb
elif {$1==6} lab2rgb
elif {$1==7} ycbcr2rgb
elif {$1==8} yiq2rgb
elif {$1==9} yuv2rgb
elif {$1==10} bayer2rgb 0,0,0
elif {$1==11} xyz2rgb
fi fi
endl a c endl done
fx_self_glitching_cascade_preview :
repeat {max(0,l)}
ac[$>] "-fx_self_glitching_cascade $*",$26
done

#@gui Sawtoother [CMY(/K)] : sawtoother_cmy_k, sawtoother_cmy_k_preview(1)+
#@gui : note = note("Splits image into CMY or CMYK channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Cyan</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Magenta</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Yellow</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Key</b>")
#@gui : Include Channel = bool(0)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_cmy_k :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $26,$27
if $19 rgb2cmyk. else rgb2cmy. fi s. c
index=0
if {$19} index=-1 if {$23} b[-1] $22% +[-1] $25 %[-1] {256/$20} *[-1] $20 %[-1] 256 *[-1] $24 +[-1] $21 else *[-1] $20 +[-1] {$21*$20} b[-1] $22% fi fi
if {$4} b[{$index-3}] $3% +[{$index-3}] $6 %[{$index-3}] {256/$1} *[{$index-3}] $1 %[{$index-3}] 256 *[{$index-3}] $5 +[{$index-3}] $2 else *[{$index-3}] $1 +[{$index-3}] {$2*$1} b[{$index-3}] $3% fi
if {$10} b[{$index-2}] $9% +[{$index-2}] $12 %[{$index-2}] {256/$7} *[{$index-2}] $7 %[{$index-2}] 256 *[{$index-2}] $11 +[{$index-2}] $8 else *[{$index-2}] $7 +[{$index-2}] {$8*$7} b[{$index-2}] $9% fi
if {$16} b[{$index-1}] $15% +[{$index-1}] $18 %[{$index-1}] {256/$13} *[{$index-1}] $13 %[{$index-1}] 256 *[{$index-1}] $17 +[{$index-1}] $14 else *[{$index-1}] $13 +[{$index-1}] {$14*$13} b[{$index-1}] $15% fi
c 0,255 a[{$index-3}--1] c
if $19 cmyk2rgb. else cmy2rgb. fi
fx_end_mix $26
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_cmy_k_preview :
sawtoother_cmy_k $*
#gui_split_preview "sawtoother_cmy_k $*",$-1

#@gui Sawtoother [HSX] : sawtoother_hsx, sawtoother_hsx_preview(1)+
#@gui : note = note("Splits image into HSV, HSI or HSL channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-180,180)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<b>Saturation</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-1,1)
#@gui : sep = separator(), note = note("<b>Value&#47;Intensity&#47;Lightness</b>")
#@gui : Channel = choice("Value","Intensity","Lightness)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-1,1)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_hsx :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $20,$21
if {$13==1} rgb2hsi. elif {$13==2} rgb2hsl. else rgb2hsv. fi
s. c
if {$4} +[-3] $6 %[-3] {360/($1)^2} *[-3] $1 %[-3] 360 *[-3] {$5*$1} +[-3] {$2} else *[-3] $1 +[-3] {$2*$1} fi %[-3] 360
if {$10} b[-2] $9% +[-2] $12 %[-2] {(1+(1/255))/$7} *[-2] {$7} %[-2] {(1+(1/255))} *[-2] $11 +[-2] {$8} else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$17} b[-1] $16% +[-1] $19 %[-1] {(1+(1/255))/$14} *[-1] {$14} %[-1] {(1+(1/255))} *[-1] $18 +[-1] {$15} else *[-1] $14 +[-1] {$15*$14} b[-1] $16% fi
c[-2,-1] 0,1 a[-3--1] c
if {$13==1} hsi2rgb. elif {$13==2} hsl2rgb. else hsv2rgb. fi
if $3 l[-1] +b $3% rgb2hsv[0,1] f.. "[i0(#1),i1,i2]" rm. hsv2rgb endl fi
fx_end_mix $20
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_hsx_preview :
gui_split_preview "sawtoother_hsx $*",$-1

#@gui Sawtoother [LCH8] : sawtoother_lch8, sawtoother_lch8_preview(1)+
#@gui : note = note("Splits image into LCH8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chroma</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_lch8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lch8.
s. c
if {$4} +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/($13)^2} *[-1] $13 %[-1] 256 *[-1] {$17*$13} +[-1] {$14} else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi %[-1] 256
a[-3--1] c c. 0,255 lch82rgb.
if $3 l[-1] +b $3% rgb2lch8[0,1] f.. "[i0,i1,i2(#1)]" rm. lch82rgb endl fi
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_lch8_preview :
sawtoother_lch8 $*
#gui_split_preview "sawtoother_lch8 $*",$-1

#@gui Sawtoother [YIQ8] : sawtoother_yiq8, sawtoother_yiq8_preview(1)+
#@gui : note = note("Splits image into YIQ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_yiq8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yiq8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yiq82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_yiq8_preview :
gui_split_preview "sawtoother_yiq8 $*",$-1

#@gui Sawtoother [XYZ8] : sawtoother_xyz8, sawtoother_xyz8_preview(1)+
#@gui : note = note("Splits image into XYZ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>X</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Y</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Z</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_xyz8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2xyz8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 xyz82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_xyz8_preview :
gui_split_preview "sawtoother_xyz8 $*",$-1

#@gui Sawtoother [YUV8] : sawtoother_yuv8, sawtoother_yuv8_preview(1)+
#@gui : note = note("Splits image into YUV8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_yuv8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yuv8. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yuv82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_yuv8_preview :
gui_split_preview "sawtoother_yuv8 $*",$-1

#@gui Sawtoother [YCbCr-(/GLIC/JPEG)] : sawtoother_ycbcr, sawtoother_ycbcr_preview(1)+
#@gui : note = note("Splits image into YCbCr channels and uses modulo operations to generate sawtooth waves and map channel intensities to them. One can choose between the original G'MIC implementation, <a href="https://web.archive.org/web/20180906062556/https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde">the GLIC implementation</a>, and the JPEG-style implementation by Garagecoder.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : Channel = choice("YCbCr","YCbCrGLIC","YCbCrJPEG")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Red Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_ycbcr :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $20,$21
if $1==1 rgb2ycbcrglic. elif $1==2 rgb2srgb. gcd_srgb2jpeg. else rgb2ycbcr. fi s. c
+[-2,-1] 0.5
if {$5} b[-3] $4% +[-3] $7 %[-3] {256/$2} *[-3] $2 %[-3] 256 *[-3] $6 +[-3] $3 else *[-3] $2 +[-3] {$3*$2} b[-3] $4% fi
if {$11} b[-2] $10% +[-2] $13 %[-2] {256/$8} *[-2] $8 %[-2] 256 *[-2] $12 +[-2] $9 else *[-2] $8 +[-2] {$9*$8} b[-2] $10% fi
if {$17} b[-1] $16% +[-1] $19 %[-1] {256/$14} *[-1] $14 %[-1] 256 *[-1] $18 +[-1] $15 else *[-1] $14 +[-1] {$15*$14} b[-1] $16% fi
a[-3--1] c c. 0,255 if $1==1 ycbcrglic2rgb. elif $1==2 gcd_jpeg2srgb. srgb2rgb. else ycbcr2rgb. fi
fx_end_mix $20
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_ycbcr_preview :
gui_split_preview "sawtoother_ycbcr $*",$-1

#@gui Sawtoother [RGB] : sawtoother_rgb, sawtoother_rgb_preview(1)+
#@gui : note = note("Splits image into RGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_rgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_rgb_preview :
gui_split_preview "sawtoother_rgb $*",$-1

#@gui Sawtoother [sRGB] : sawtoother_srgb, sawtoother_srgb_preview(1)+
#@gui : note = note("Splits image into sRGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_srgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2srgb. s. c
+[-2,-1] 0.5
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 srgb2rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_srgb_preview :
sawtoother_srgb $*
#gui_split_preview "sawtoother_srgb $*",$-1

#@gui Sawtoother [Lab8] : sawtoother_lab8, sawtoother_lab8_preview(1)+
#@gui : note = note("Splits image into Lab8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance a</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance b</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
fx_start_mix :
if {$1==1} +tones. 3 +[-2,-1] b[-2,-1] $2% r[-2,-1] ... *. ... mv... $!
elif {$1==2} +tones. 3 +[-3,-1] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
elif {$1==3} +tones. 3 +[-3,-2] b[-2,-1] $2% r[-2,-1] ... *.. ... mv... $!
fi
fx_end_mix :
if {$1==1} *[-3,-1] +[-2,-1]
elif {$1==2} *[-2,-1] +[-2,-1]
elif {$1==3} *[-2,-1] +[-2,-1]
fi
c 0,255
sawtoother_lab8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lab8. s. c
if {$4} b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if {$10} b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if {$16} b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c lab82rgb.
fx_end_mix $19
if {$!!=3} rv a c fi endl mv. 0 done
sawtoother_lab8_preview :
sawtoother_lab8 $*
#gui_split_preview "sawtoother_lab8 $*",$-1

#@gui Pseudo-ECB (Electronic Code Book Algorithm): pseudo_ecb, _pseudo_ecb_preview(0)
#@gui : note = note("This filter is inspired by one of the glitch plugin for Paint.NET. This doesn't actually emulate how the codebook encryption algorithm actually work, but it is inspired from it.  This filter uses bomb blending mode which involves RGBA Transfer Function Mesh. See Mesh Blend filter for a link. \n\n <u>Note that the filter works best on images with large patches of single colors.</u> ")
#@gui : sep = separator()
#@gui : note = note("<b>Color Space Choice</b> \n\n <i>Keep in mind that you may not necessarily get what you imagine. Just treat these as themes. </i>")
#@gui : Colour Space = choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : sep = separator()
#@gui : note = note("<b>Final Color Processing</b> \n\n <i>This refers to the how the colors are going to be processed. If you find that there's too little difference in hues or chroma or luminosity in local areas, this should be on. Sometimes, the result are better without the final processing.</i>")
#@gui : Equalize Filter = bool(0)
#@gui : Pseudo-Coloring = bool(1)
#@gui : Tonality Blend = choice(20,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Tonality Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Pattern Key Generator</b>")
#@gui : Double Gradient? = bool(1)
#@gui : Length of Gradient#1 = float(5,0,32)
#@gui : ECB Gradient#1 Angle = float(0,0,360)
#@gui : ECB Inversion#1 = bool(0)
#@gui : Length of Gradient#2 = float(5,0,32)
#@gui : ECB Gradient#2 Angle = float(90,0,360)
#@gui : ECB Inversion#2 = bool(0)
#@gui : Gradient Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Gradient Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Sharpen Filtering</b>")
#@gui : Sharpening Noise Processing = float(15,0,200)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Image Processing</b>")
#@gui : Transfer Mesh Size for Image (Squared) = int(256,2,256)
#@gui : Image Mesh Contrast = int(75,25,100)
#@gui : Transfer Mesh Size for Gradient (Squared) = int(16,2,256)
#@gui : Gradient Mesh Contrast = int(100,25,100)
#@gui : Double Encryption Effect = bool(1)
#@gui : Inner Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Inner Blend Opacity = float(1,0,1)
#@gui : Outer Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Outer Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Self-Image Post-Processing</b> \n\n <i>This invokes a self-blending operation after the main pseudo-ecb has been generated with different blend mode.</i>")
#@gui : Activate Self-Image Post-Processing = bool(1)
#@gui : Equalize ECB Processing = bool(0)
#@gui : Psuedo-Coloring = bool(1)
#@gui : Self-Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Self-Blend Opacity = float(1,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2018/12/30</i>.</small>")

pseudo_ecb:
csswap $1,0
repeat $! l[$>]
repeat {$20+1}
pseudo_ecb_generate ${2-19},${21-29}
done
endl
csswap 0,$1
done

pseudo_ecb_generate:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
+ac "ecb_gradient_base[0] $6,$7,$8",rgb
if {$2==1} _pseudo_c[1] fi
local[1]
if {$5==1} +ac "ecb_gradient_base[0] $9,$10,$11",rgb
_pseudo_c[1]
blend ${_mode{$12+1}},$13 if {$1==1} equalize fi fi
endlocal
local[0]
sharpen $14
if {$2==1} +_pseudo_c[0]
elif {$2==1} [0] fi
+fx_blend_bomb[0] 0,1,$15,$15,0,0,$16,0,0,0,1,0
blend ${_mode{$19+1}},$20
endlocal
fx_blend_bomb[1] 0,1,$17,$17,0,0,$18,0,0,0,0,0
if {$1==1} equalize[1] fi
blend ${_mode{$21+1}},$22
if {$1==1} +equalize blend ${_mode{$3+1}},$4 fi
if {$1==0} [0] blend ${_mode{$3+1}},$4 fi
if {$23==1} [0] if {$24==1} equalize[1] fi if {$25==1} _pseudo_c[1] fi blend ${_mode{$26+1}},$27
fi

ecb_gradient_base:
f "ang=pi*$2/180;G=x*cos(ang)+y*sin(ang);G%$1" n 0,255
if {$3==1} mul -1 abs fi

_pseudo_c : v - if {s!=1} to_gray. fi {max(1,round(iM,1,1))},1,1,3,u(255) round. map.. . rm.  v +

_pseudo_ecb_preview :
gui_split_preview "pseudo_ecb $*",${-3--1}

#@gui Faux-QAM Glitch: fx_qam_glitch, fx_qam_glitch_preview(0)
#@gui : note = note("Tries to emulate the effect of a faulty Quadrature Amplitude Modulator.")
#@gui : sep = separator()
#@gui : note = note("<b>Channel Modulation</b>")
#@gui : 1. Amplitude = float(2,0,10)
#@gui : 2. Period = float(20,0,100)
#@gui : 3. Phase Offset = float(0,-180,180)
#@gui : 4. Angle = float(0,-180,180)
#@gui : 5. Amplitude Offset = float(1,-10,10)
#@gui : 6. Wave Offset = float(127.5,0,255)
#@gui : 7. Colour Space = choice("RGBA","sRGBA","HSVA8","HSVA","HSLA8","HSLA","HSIA8","HSIA","LCHA8","LCHA","LabA8","LabA","YCbCrA","YCbCrAGLIC","YCbCrAJPEG","YIQA8","YIQA","YUVA8","YUVA","HCYA","XYZA8","XYZA","RYBA","CMYA")
#@gui : 8. Channel 0 = bool(1)
#@gui : 9. Channel 1 = bool(1)
#@gui : 10. Channel 2 = bool(1)
#@gui : 11. Alpha = bool(0)
#@gui : 12. Glitch Negation = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Scanlines</b>")
#@gui : 13. Amplitude = float(20,0,255)
#@gui : 14. Bandwidth = float(5,0,20)
#@gui : 15. Shape = choice(0,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : 16. Angle Offset = float(0,-180,180)
#@gui : 17. Offset = float(0,0,500)
#@gui : 18. Blur = float(2,0,10)
#@gui : 19. Amplitude Modulation = float(0.6,0,1)
#@gui : 20. Phase Modulation = float(0.05,0,1)
#@gui : sep = separator(), 21-23. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0

_scanlines : skip ${1=60},${2=2},${3=0},${4=0},${5=0}
v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
repeat $! l[$>]
100%,100%,1,1,"x" -. {w/2-$5} 100%,100%,1,1,'y'
-. {h/2-$5} *.. $S *. $C +[-2,-1]
_ripple$3. $1,$2
n. {-$1},$1
+ cut 0,255
endl done v +

_qam_glitch :

100%,100%,1,1 _scanlines. ${7-9},{(90+$4+$10)},$11 b. $12
*. 2 -. $7
f.. "line=i(#-1\,x\,y\,z\,0);ang=(90+$4)*pi/180;(i+(((1+line*5*$13/255)*($1*i/255+$5))*(i*sin(((x-w/2)*cos(ang)+(y-h/2)*sin(ang))/$2+($3+(line*$2*$14/10)/255*360)*pi/180))+($6*($1)-($1*i/2)))-i/255)%255"
rm.

fx_qam_glitch :
repeat $! l[$>]
to_rgba
cs=$7
if $12 negate fi
csswap 0,$cs
counter=0
if $8 sh[0] 0 fi
if $9 sh[0] 1 fi
if $10 sh[0] 2 fi
if $11 sh[0] 3 fi
repeat {$!-1} l[{$>+1}]
_qam_glitch ${1-6},${13-20}
endl done
k[0]
csswap $cs,0
if $12 negate fi
endl done
fx_qam_glitch_preview :
gui_split_preview "fx_qam_glitch $*",${-3--1}

#@gui Butterworth Bandpass: fx_butterworth_bp, fx_butterworth_bp_preview(0)
#@gui : note = note("Lowpass and highpass zero-phase Butterworth filters.")
#@gui : sep = separator()
#@gui : LP Frequency Power = float(3,0,16)
#@gui : LP Order Cube Root = float(2,0,4)
#@gui : HP Frequency Power = float(4,0,16)
#@gui : HP Order Cube Root = float(2,0,4)
#@gui : Colour Space= choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : Alpha = bool(0)
#@gui : Absolute = bool(1)
#@gui : Makeup Gain = bool(1)YZ8","XYZ")

_butterworth_bp :
v -
100%,100%,100% f. "scale=max(w,h,d);vx=(x-w/2)/scale;vy=(y-h/2)/scale;vz=(z-d/2)/scale;rad=(vx^2+vy^2+vz^2)^0.5;func=(1/((1+((rad/(2^$1))*scale*log2(scale))^($2^3))^0.5))*(1/((1+(((rad/(2^$3)*scale*log2(scale))^($4^3))^-1))^0.5));func"
shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2 *. 2
fft.. *... . *[-2,-1] ifft rm[-1]
v +
fx_butterworth_bp:
repeat $! l[$>]
if {!$6} split_opacity fi
l[0]
gain={iM} csswap 0,$5
_butterworth_bp ${1-4}
csswap $5,0 if $7 abs fi if $8 * {$gain/iM} fi
endl
if {!$6} a c fi
endl done

fx_butterworth_bp_preview :
fx_butterworth_bp $*

#@gui Broken Texture_Afre: fx_texture_afre_broken, fx_texture_afre_broken_preview(0)
#@gui : note = note("This shouldn't have happened.")
#@gui : sep = separator()
#@gui : P1 = float(1,0,10)
#@gui : P2 = float(10,0,100)
#@gui : Difference = bool(0)

fx_texture_afre_broken:
repeat $! l[$>]
  n 0,255
  if $3 +l fi
  +l
    +l
      if $1 gradient_orientation 2 n 0,1 + y50_afre 0 gradient_norm
      else gradient_norm fi
      b 1,1,1
    endl
    *. {255*$2/iM} +
    n 0,255
  endl
  +l.. n 0,1 f gauss(i-.5) n 0,1 endl
  blend_fade[0,1] . k[0]
  if $3 blend difference fi
endl done

fx_texture_afre_broken_preview :
fx_texture_afre_broken $*

#@gui Row Shifter: fx_row_shift, fx_row_shift_preview(0)
#@gui : note = note("Shifts rows.")
#@gui : sep = separator()
#@gui : Order = choice("X then Y","Simultaneous","Y then X")
#@gui : X Shift = float(0,-5,5)
#@gui : X Centre = float(0.5,0,1)
#@gui : Y Shift = float(0,-5,5)
#@gui : Y Centre = float(0.5,0,1)
#@gui : Interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic","Lanczos")
#@gui : Invert Shifts = bool(0)
fx_row_shift :
repeat $! l[$>]
z 0,0,{w+1},{h+1},2
inv={($7*-2)+1}
opt={int(($1-1)*$inv)}
if {$opt==-1}
f "j((y-h*$3)*$2*"$inv",0,0,0,$6,2)"
f "j(0,(x-w*$5)*$4*"$inv",0,0,$6,2)"
elif {$opt==1}
f "j(0,(x-w*$5)*$4*"$inv",0,0,$6,2)"
f "j((y-h*$3)*$2*"$inv",0,0,0,$6,2)"
else
if {$inv==1}
f "j((y-h*$3)*$2*"$inv",(x-w*$5)*$4*"$inv",0,0,$6,2)"
elif {$inv==-1}
f "j((y-h*$3)*$2*"$inv",(x-w*$5)*$4*"$inv",0,0,$6,2)"
fi
fi
z 0,0,{w-1},{h-1}
endl done
fx_row_shift_preview :
fx_row_shift $*

#@gui Fake JFIF (JPEG) Encoder : fx_jfif_fake, fx_jfif_fake_preview(0)
#@gui : note = note("<small>A fake jfif encoder.</small>")
#@gui : Quality (%) = int(50,1,100)
#@gui : Encoding = choice("444","442","424","422")
#@gui : sep = separator()
#@gui : note = note("Fake Glitch")
#@gui : Power = float(0,0,5)
#@gui : Colour Distortion = float(1.25,0,10)
#@gui : Max Tile Error Length = int(5,1,10)
#@gui : Persistent Tile Error Power = float(0.25,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author: Joan Rake, \'borrowed\' from <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/05/07</i>.</small>")
fx_jfif_fake :
glitch=(0.25^(10-$3))*$3/4
cd=$4
te=$5
ste=$6
base642img "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"
base642img "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"
nm[-2,-1] dct,idct
i[Q] (16,11,10,16,24,40,51,61;12,12,14,19,26,58,60,55;14,13,16,24,40,57,69,56;14,17,22,29,51,87,80,62;18,22,37,56,68,109,103,77;24,35,55,64,81,104,113,92;49,64,78,87,103,121,120,101;72,92,95,98,112,100,103,99)
f. "const S = $1<50?5000/$1:200-2*$1; max(1,round((S*i+50)/100,1,-1))"
repeat {$!-3} l[$>,-3--1]
l[0] w,h={[w,h]} r {w+(-w%16)},{h+(-h%16)},1,100%,0,3 rgb2ycbcr s c
if {$2==1} r[-2,-1] 100%,50%,1,1,2 elif {$2==2} r[-2,-1] 50%,100%,1,1,2 elif {$2==3} r[-2,-1] 50%,50%,1,1,2 fi round. endl
repeat 3
[$>]
f[$>] "begin(boundary = 2; res = vector64(); chance = "$glitch"; val = 1; errtile = 0; tt=-1; const tlen = "$te"; const sticky = "$ste"; stuck = 0; cold = "$cd");
if (!(x%8) && !(y%8),
src = crop(x,y,8,8);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; u<=chance?(val+=(u(-cold,cold)/10);tt=u(1,tlen);(u<=sticky?stuck=1:stuck=0)); stuck==0?errtile=0; tt>=1?(errtile=u(0,64)); res[off] = sum(val*src*crop(#"$dct",0,0,(off+errtile)%64,8,8,1))));
draw(#-1,res,x,y,0,0,8,8); tt-=1;
); i"
round.
+r[Q] {$>,w},100%,1,1,0,2 /.. . round.. *[-2,-1]
f. "begin(boundary = 2; res = vector64(); chance = "$glitch"; val = 0; errtile = 0; tt=-1; const tlen = "$te"; const sticky = "$ste"; stuck = 0; cold = "$cd");
if (!(x%8) && !(y%8),
src = crop(x,y,8,8);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; u<=chance?(val+=(u(-cold,cold)/10);tt=u(1,tlen);(u<=sticky?stuck=1:stuck=0)); stuck==0?errtile=0; tt>=1?(errtile=u(0,64)); res[off] = sum(val+src*crop(#"$idct",0,0,(off+errtile)%64,8,8,1))));
draw(#"$>",res,x,y,0,0,8,8); tt-=1;
); i"
rm.
round[$>]
done
l[^3--1] r ${-max_wh},1,1,1 a c ycbcr2rgb round. r $w,$h,1,3,0 endl
endl done
rm[dct,idct,Q]
fx_jfif_fake_preview :
gui_split_preview "fx_jfif_fake $*",${-3--1}

#@gui JFIF Effects : fx_jfif, fx_jfif_preview(0)
#@gui : note = note("<small>A poorly-implemented JFIF encoder with extras, all designed to screw with images. Quite slow and very aggressive.</small>")
#@gui : 1. Quality (%) = int(50,1,100)
#@gui : 2. Encoding = choice(3,"444","442","424","422")
#@gui : sep = separator()
#@gui : note = note("Fake Glitch")
#@gui : 3. Power = float(0,0,10)
#@gui : 4. Colour Distortion = float(1,0,2)
#@gui : 5. Max Glitch Length = int(5,2,10)
#@gui : 6. Max Value Errors Per Tile = int(5,0,10)
#@gui : 7. Error Strength = float(3,0,8)
#@gui : 8. Persistent Value Errors Power = float(0.25,0,1)
#@gui : 9. Error Bias = float(0.5,0,1)
#@gui : 10. Tile Shift Power = float(0.25,0,1)
#@gui : 11. Mirror = choice("None","X","Y","XY")
#@gui : 12. Rotate = choice("None,"90 clockwise","180","90 anticlockwise")
#@gui : sep = separator()
#@gui : note = note("Self-Bomb")
#@gui : 13. Enable = bool(0)
#@gui : 14. Mesh X = int(16,1,256)
#@gui : 15. Mesh Y = int(16,1,256)
#@gui : 16. Mesh Smoothness = float(0.5,0,10)
#@gui : 17. Contrast Scheme = choice(1,"Arctan","Clip","Power)
#@gui : 18. Mesh Contrast = float(75,0,100)
#@gui : 19. Scale X = float(1,0.05,16)
#@gui : 20. Scale Y = float(1,0.05,16)
#@gui : 21. Interpolation = choice(0,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : 22. Normalise = bool(0)
#@gui : 23. Output Mesh = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui : sep = separator(), note = note("<small>Author: Joan Rake, \'borrowed\' from <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/05/07</i>.</small>")
fx_jfif :
cd={$4^2.5}
gl=$5
ve=$6
es=$7
ste=$8
bias={2^(6-($9*12))}
ts={$10^2}
base642img "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"
base642img "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"
nm[-2,-1] dct,idct
i[Q] (16,11,10,16,24,40,51,61;12,12,14,19,26,58,60,55;14,13,16,24,40,57,69,56;14,17,22,29,51,87,80,62;18,22,37,56,68,109,103,77;24,35,55,64,81,104,113,92;49,64,78,87,103,121,120,101;72,92,95,98,112,100,103,99)
f. "const S = $1<50?5000/$1:200-2*$1; max(1,round((S*i+50)/100,1,-1))"
repeat {$!-3} l[$>,-3--1]
gp={(0.25^((10-$3)*log(wh(#0))/30))*$3/10}
ww={w(#0)}
hh={h(#0)}
if {$11==1}
mirror[0] x
elif {$11==2}
mirror[0] y
elif {$11==3}
mirror[0] xy
fi
if $12
rotate[0] {$12*90},0
fi
if $13
www={w(#0)}
hhh={h(#0)}
r[0] {$www*$19},{$hhh*$20},100%,100%,$21
fi
i[G] {w(#0)},{h(#0)},1,1 f[$G] ">begin(chance = "$gp"; tlmax="$gl"; tt=-1; val=0; sticky="$ste");
if (!(x%16) && !(y%16),for (l = 0, l<2, ++l, for (k = 0, k<2, ++k, (u<=chance?((val=1);tt=round(u(1,tlmax))):tt>=0?(val=0;--tt):(u<=sticky?(val=-2):val=-1)); j(k*8,l*8)=val)),0)"
l[0] w,h={[w,h]} r {w+(-w%16)},{h+(-h%16)},1,100%,0,3 rgb2srgb gcd_srgb2jpeg s c
if {$2==1} r[-2,-1] 100%,50%,1,1,2 elif {$2==2} r[-2,-1] 50%,100%,1,1,2 elif {$2==3} r[-2,-1] 50%,50%,1,1,2 fi round. endl
bw,bh=8
repeat 3
if {$>==1}
if {$2==1} bh=16 elif {$2==2} bw=16 elif {$2==3} bh,bw=16 fi
fi
[$>]
f[$>] ">begin(boundary = 2; res = vector64(); gres = vector64(); const cbw="$bw"; const cbh="$bh"; const cbwh=cbw*cbh; glitch=0; const cold="$cd"; gval=1; const errval="$ve"; const bias = "$bias"; const strength="$es");
if (!(x%(128/cbw)) && !(y%(128/cbh)),for (ll = 0, ll<(16/cbw), ++ll, for (kk = 0, kk<(16/cbh), ++kk,
src = crop(x+(ll*8),y+(kk*8),8,8);
gpunch=crop(#"$G",cbw/8*(x+(ll*8)),cbh/8*(y+(ll*8)),cbw,cbh);
max(gpunch)==1?(glitch=1);
glitch==1?(gval=cut(gval+(u(-cold,cold)/15),-1,5);errnum=u(1,errval);for (ve=0,ve<errnum,++ve,gres[floor((u^bias)*8)+floor((u^bias)*8)*8]=ceil(u(-strength,strength)^5))*10);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = int(gres[off]/10+sum(gval*src*crop(#"$dct",0,0,off,8,8,1)))));
draw(#-1,res,x+(ll*8),y+(kk*8),0,0,8,8);
min(gpunch)<=-1?(glitch=0;errnum=0;tileerror=0;min(gpunch)==-1?gres=vector64(0))))); i"
round.
+r[$Q] {$>,w},100%,1,1,0,2 /.. . round.. *[-2,-1]
dispw={w(#1)}
f. ">begin(boundary = 2; res = vector64(); const cbw="$bw"; const cbh="$bh"; const cbwh=cbw*cbh; glitch=0; const cold="$cd"; gval=0; const dispwidth="$dispw";disp=0;shift="$ts");
if (!(x%(128/cbw)) && !(y%(128/cbh)),for (ll = 0, ll<(16/cbw), ++ll, for (kk = 0, kk<(16/cbh), ++kk,
src = crop((x+(ll*8+cbw*disp))%(dispwidth/cbw*16),y+(kk*8)+cbh*floor((x+cbw*disp)/(dispwidth/cbw*16)),8,8);
gpunch=crop(#"$G",cbw/8*(x+(ll*8)),cbh/8*(y+(ll*8)),cbw,cbh);
max(gpunch)==1?(glitch=1);
glitch==1?((u<=shift?++disp);gval=cut(gval+(u(-cold,cold)/5),-1,5));
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = int(sum(gval+src*crop(#"$idct",0,0,off,8,8,1)))));
draw(#"$>",res,x+(ll*8),y+(kk*8),0,0,8,8);
min(gpunch)<=-1?(glitch=0;errnum=0;min(gpunch)==-1?gres=vector64(0))))); i"
rm.
l[$>] r {w*($bw/8)},{h*($bh/8)},1,1,1 endl
round[$>]
done
rm[$G]
l[^4--1] a c gcd_jpeg2srgb srgb2rgb round. r $w,$h,1,3,0
if $13 blend_bomb 1,${14-18},0,0,0,${22-23}
r $www,$hhh,100%,100%,$21 fi
if $12
rotate[0] {-$12*90},0
fi
if {$11==1}
mirror[0] x
elif {$11==2}
mirror[0] y
elif {$11==3}
mirror[0] xy
fi
endl
endl done
rm[$dct,$idct,$Q]
fx_jfif_preview :
gui_split_preview "fx_jfif $*",${-3--1}

#@gui DCT FSU: fx_dct_fsu, fx_dct_fsu_preview(0)
#@gui : 1. Operation = choice("Low Pass 1","Low Pass 2","High Pass 1","High Pass 2","Isolate","Plaid","Plaid LP", "Plaid HP","Randomised Spread","Randomised Spread [intense]")
#@gui : 2. X (%) = float(50,0,100)
#@gui : 3. Y (%) = float(50,0,100)
#@gui : 4. Shift X (%) = float(0,0,100)
#@gui : 5. Shift Y (%) = float(0,0,100)
#@gui : 6. Absolute = bool(0)
#@gui : 7. Normalise (%) = bool(1)
#@gui : 8. Colour Space = choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","RYB","CMY","CMYK","Bayer")
#@gui : 9. Alpha = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_dct_fsu:
repeat $! l[$>]
if !$9 split_opacity fi
l[0]
csswap $8,0 dct
f "
begin(op="$1"; ox=round("$2"*w/100); oy=round("$3"*h/100));
(op==0)?(((x<=ox)&&(y<=oy))?i:0):
(op==1)?(((x<=ox)||(y<=oy))?i:0):
(op==2)?(((x<=ox)||(y<=oy))?0:i):
(op==3)?(((x<=ox)&&(y<=oy))?0:i):
(op==4)?(((x==ox)&&(y==oy))?i:0):
(op==5)?(((x==ox)||(y==oy))?i:0):
(op==6)?((((x==ox)||(y==oy))&&((x<=ox)&&(y<=oy)))?i:0):
(op==7)?((((x==ox)||(y==oy))&&((x>=ox)&&(y>=oy)))?i:0):
(op==8)?(j(round(ox*u(-1,1)^45),round(oy*u(-1,1)^45),0,0,0,2)):
(op==9)?(j(round(ox*u(-1,1)^5),round(oy*u(-1,1)^5),0,0,0,2))
"
shift $4%,$5%,0,0,2
idct
csswap 0,$8
if $6 abs fi
if $7 n 0,255 fi
endl
if !$9 a c fi
endl done
fx_dct_fsu_preview:
gui_split_preview "fx_dct_fsu $*",${-3--1}



	#@gui Superstreak: fx_superstreak, fx_superstreak_preview(0)
	#@gui : sep = separator()
	#@gui : 1. Iterations = int(10,1,20)
	#@gui : 2. Propagation = choice(3,"Backward","Forward","Bidirectional [Sharp]","Bidirectional [Smooth]")

	_superstreak :
	repeat $! l[$>]
	to_rgba
	if {!$4} T,R,G,B,A=0 else T,R,G,B,A=${1-5} fi +select_color $T,$R,$G,$B,$A
	if {$8==3} srgb2rgb.. fi
	f.. "
	const step = max(1,$6%*min(w,h));
	const angle = $7*pi/180;
	const dx = step*cos(angle);
	const dy = step*sin(angle);
	if (!i(#-1),I,
	ixf = xf = x; iyf = yf = y; lf = 0; if ($8>=1, while (i(#-1,ixf=round(xf),iyf=round(yf)), ++lf; xf-=dx; yf-=dy));
	ixb = xb = x; iyb = yb = y; lb = 0; if ($8!=1, while (i(#-1,ixb=round(xb),iyb=round(yb)), ++lb; xb+=dx; yb+=dy));
	$8==0?I(ixb,iyb):
	$8==1?I(ixf,iyf):
	$8==2?(lf<lb?I(ixf,iyf):I(ixb,iyb)):
	(lb*lb*I(ixf,iyf) + lf*lf*I(ixb,iyb))/(lb^2+lf^2);
	)"
	if {$8==3} rgb2srgb.. fi
	rm.
	endl done
	fx_superstreak :
	repeat $! l[$>]
	repeat $1
	a={u(0,512)}
	b={round(u(0,255))}
	c={round(u(0,255))}
	d={round(u(0,255))}
	e={round(u(0,255))}
	f={u(10,30)}
	g={u(0,360)}
	_superstreak {$a},{$b},{$c},{$d},{$e},{$f},{$g},$2
	done
	endl done
	fx_superstreak_preview :
	fx_superstreak $*

######################

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
