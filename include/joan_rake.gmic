#@gmic
#
#  File        : joan_rake.gmic
#                ( G'MIC commands file )
#
#  Description : The author of these filters ('Joan Rake', not her real
#                name) describes them as a gritty and overloaded series of
#                mistakes which will probably be frowned upon by hordes of
#                snobbish graphic designers. Good for them, Joan doesn't care.
#                At least not until they start overusing her filters to the
#                extent that everyone gets tired of them.
#
#  Copyright   : David Tschumperle
#                ( http://tschumperle.users.greyc.fr/ )
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#


gcd_spiralbw_warp :
to_graya.
sh. 0
eval. "
begin(P=[0,0];M=0;LX=w-1;LY=h-1;D=[1,0];R=[0,-1,1,0];off=0);
if(
(P[0]==LX && (P[1]==M || P[1]==LY)) || (P[0]==M && P[1]==LY), D=R*D);
if((P[0]==M && P[1]==M+1), D=R*D;M++;LX--;LY--);
P+=D;
I(#-2,P[0],P[1])=[off%w,int(off/w)];
++off;
"
rm.

#@cli invert_rgb
#@cli : Inverts images in the RGB colour space.
invert_rgb:
repeat $! split_opacity
l[0] c 0,255 *[$>] -1 +[$>] 255 done
a c
done

#@cli invert_alpha
#@cli : Inverts the alpha channel of images.
invert_alpha:
repeat $! split_opacity
l[1] c 0,255 *[$>] -1 +[$>] 255 done
a c
done

#@cli index_table: 0<width, 0<height
#@cli : Adds a 2D image which stores index offsets.
index_table:
$1,$2,1,1,">begin(index=-1);index+=1;index"

#@gui _<b>Testing</b>
#@gui <i>Joan Rake</i>

#@gui Mesh Blend : fx_mesh_blend, fx_mesh_blend_preview(1)
#@gui : note = note("Universal blending algorithm. Resizes an RGB&#40;A&#41; image to a 256x256 image and uses it as an RGBA LUT 'transfer function mesh' to blend two other images together. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : sep = separator(), note = note("<small>[0] is bottom layer, [1] is top layer, [2] is mesh. Mesh origin is at bottom-left. Plugin GUI preview does not accurately show mesh.</small>")
#@gui : Process As = choice(0,"Three-by-three","Self-mesh and self-blend for each layer")
#@gui : Resize Interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Reverse Blending Layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Blend Alpha Channels = bool(0)
#@gui : Keep Mesh = bool(0)
_fx_mesh_blend :
r. 256,256,100%,100%,$1
if $4 to_rgba else to_rgb fi
if $2 rv[0,1] fi
f[$3] "i(#2,i(#0),256-i(#1))"
if !$5 rm[2] fi
if $3 rm[0] else rm[1] fi
fx_mesh_blend :
if $1==0 repeat int($!/3) l[$>-{$>+2}] rv _fx_mesh_blend ${2-6} done done
elif $1==1 repeat $! l[$>] [0]x2 _fx_mesh_blend ${2-6} done done fi
fx_mesh_blend_preview :
fx_mesh_blend $*
#@gui <b>Artistic</b>
#@gui Charred Plastic : fx_charred_plastic, fx_charred_plastic_preview()
#@gui : sep = separator(), note = note("<small><b>Difference of Gaussians</b></small>")
#@gui : 1. Amplitude = float(1,-10,10)
#@gui : 2. Gaussian 1 = float(10,0,100)
#@gui : 3. Gaussian 2 = float(40,0,100)
#@gui : 4. Mode = choice(1,"Pixels","Percent")
#@gui : sep = separator(), note = note("<small><b>Noise</b></small>")
#@gui : 5. Amplitude = float(10,0,200)
#@gui : 6. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : 7. Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small><b>Local Normalization</b></small>")
#@gui : 8. Amplitude = float(2,0,60)
#@gui : 9. Radius = int(6,1,64)
#@gui : 10. Neighborhood Smoothness = float(5,0,40)
#@gui : 11. Average Smoothness = float(20,0,40)
#@gui : 12. Constrain Values = bool(0)
#@gui : 13. Channel(s) = choice(11,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
fx_charred_plastic:
if $4
+dog $2%,$3%
else
+dog $2,$3
fi
*. $1
+.. .
rm.
ac "_fx_noise $5,$6",$7
c 0,255
normalize_local ${8-13}
fx_charred_plastic_preview:
fx_charred_plastic $*

#@gui Whirling Lines : fx_whirling_lines, fx_whirling_lines_preview()
#@gui : note = note("Creates fingerprint-like lines out of images by blurring and rounding their values. Works best with single-channel images.")
#@gui : 1. Blur = float(30,0,100)
#@gui : 2. Round = float(6,0,255)
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 3. Norm Mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient")
#@gui : 4. Smoothness = float(0,0,10)
#@gui : 5. Contrast = float(0.45,0,1.5)
#@gui : 6. Min Threshold = float(40,0,100)
#@gui : 7. Max Threshold = float(60,0,100)
#@gui : 8. Dilate or Erode = int(0,-5,20)
#@gui : 9. Negative = bool(0)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 10. Amplitude = float(30,0,100)
#@gui : 11. Edge Threshold (%) = float(0,0,100)
#@gui : 12. Smoothness = float(3,0,10)
#@gui : 13. Value Action = choice(3,"None","Cut","Normalize","Cut then normalize")
fx_whirling_lines :
b $1 f "round(i,$2)"
if $3==1
b $4
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1] b $4
s={s} s. c +[-$s--1] sqrt.
elif $3==2
b $4 laplacian abs to_gray to_rgb
elif $3==3
b $4 gradient xyz abs blend add to_gray to_rgb
else
b $4 gradient_norm
fi
c 0,255
^ $5
c $6%,$7%
n 0,255
if $8>=0
dilate_circ $8
elif $8<=0
erode {-$8}
fi
if $9 negate fi
if $10!=0||$11!=100
fx_smooth_antialias ${10-12}
fi
if $13==1 c 0,255 elif $13==2 n 0,255 elif $13==3 c 0,255 n 0,255 fi
fx_whirling_lines_preview :
fx_whirling_lines $*

#@gui Dreamy Watercolour : fx_dreamy_watercolour, fx_dreamy_watercolour(0)
#@gui : note = note("Creates abstract watercolour images.")
#@gui : sep = separator(), note = note("<b>Gradient norm</b>")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.3,0,2)
#@gui : 3. Min Threshold = float(40,0,100)
#@gui : 4. Max Threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 7. Amplitude = float(50,0,200)
#@gui : 8. Edge Threshold (%) = float(0,0,100)
#@gui : 9. Smoothness = float(10,0,20)
#@gui : sep = separator(), note = note("<b>Dreamy abstraction</b>")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 10. Edge Threshold = float(2,0,30)
#@gui : 11. Smoothness = float(1,0,10)
#@gui : 12. Blend Mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 13. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 14. Noise Amplitude = float(10,0,100)
#@gui : 15. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 16. Noise Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 17. Blend Mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 18. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 19. Blur Strength = float(3,0,20)
#@gui : 20. Sharpen Radius Factor = float(1,0,5)
#@gui : 21. Amount Factor = float(1,0,5)
#@gui : 22. Threshold = float(1,0,5)
#@gui : 23. Constraint Radius Factor = float(1,0,5)
#@gui : 24. Overshoot Factor = float(1,0,20)
#@gui : 25. Sharpen Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 26. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 27. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("<b>Deform colour layer</b>")
#@gui : 28. Amplitude = float(5,0,50)
#@gui : 29. Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : 30. Matrix Density = float(10,1,100)
#@gui : 31. Matrix Interpolation = choice(1,"Linear","Bicubic")
#@gui : 32. Mode = Choice("Noise","Spread noise")
#@gui : 33. Character = float(0,-100,100)
#@gui : 34. Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), note = note("<b>Plasma</b>")
#@gui : 35. Alpha = float(0.5,0,5)
#@gui : 36. Beta = float(0,0,100)
#@gui : 37. Scale = float(8,1,20)
#@gui : 38. Randomize = bool(1)
#@gui : 39. Transparency = bool(0)
#@gui : 40-42. Color Balance = color(128,128,128)
#@gui : 43. Fix Edges = float(0.5,0,1)
#@gui : sep = separator(), note = note("<b>Transfer colours</b>")
#@gui : 44. Enable = bool(1)
#@gui : 45. Regularization = int(8,0,32)
#@gui : 46. Preserve Luminance = float(0.2,0,1)
#@gui : 47. Precision = _choice(1,"Low","Normal","High","Very high")
#@gui : 48. Reference Colors = choice(1,"Plasma","Painting")
#@gui : 49. Add User-Defined Constraints (Interactive) = _bool(0)
#@gui : 50. Blend Mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 51. Opacity = float(0.75,0,1)
#@gui : 52. Reverse Order = bool(0)
#@gui : sep = separator(), note = note("<b>Local normalisation</b>")
#@gui : 53. Amplitude = float(1,0,80)
#@gui : 54. Radius = int(20,1,96)
#@gui : 55. Neighborhood Smoothness = float(40,0,60)
#@gui : 56. Average Smoothness = float(40,0,60)
#@gui : 57. Constrain Values = bool(1)
#@gui : 58. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<b>Noise</b>")
#@gui : 59. Power = float(1.25,0,5)
#@gui : 60. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui : 61. Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 62. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 63. Blend Mode = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 64. Opacity = float(1,0,1)
fx_dreamy_watercolour :
repeat $! l[$>]
to_rgb
if $6
+b $1
l[1] gradient_norm c 0,255 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255
if $9!=0||$10!=100
fx_smooth_antialias ${7-9}
fi
done
fi
fx_jr_deform[0] 0,${28-34}
fx_dreamy_abstraction[0] ${10-27}
if $6 n[1] 0,255 negate[1] blend[0,1] multiply,$6 fi
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
100%,100%,1,3
CF={$37*20*$38}
 l[1] if $43 z {-$CF},{-$CF},{w+$CF},{h+$CF} fi fx_plasma ${35-42} if $43 z {$CF},{$CF},{w-$CF},{h-$CF} fi done
if $44 fx_transfer_rgb ${45-49} fi
if $52 rv fi
blend ${_mode{$50+1}},$51
fx_normalize_local ${53-58}
if $59
100%,100%,1,3 fc[1] 127,127,127 jr_fx_noise[1] {(2^($59*0.2))*($59*20)},${60-62}
blend ${_mode{$63+1}},$64
fi
done done
fx_dreamy_watercolour_preview :
fx_dreamy_watercolour $*

#@gui Hard Painting : fx_hard_painting, fx_hard_painting_preview(0)+
#@gui : note = note("Modular filter which can be used to apply an extremely-glossy paint effect.")
#@gui : sep = separator(), note = note("<small>Painting authors: <i>Lyle Kroll</i>, <i>Angelo Lama</i> and <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.\nLatest update: <i>2011/28/02</i>.</small>")
#@gui : 1. Abstraction = int(1,0,20)
#@gui : 2. Details Scale = float(2.5,0,100)
#@gui : 3. Color = float(4,0,25)
#@gui : 4. Smoothness = float(50,0,2000)
#@gui : 5. Sharpen Shades = bool(1)
#@gui : sep = separator (), note = note("<small>Graphic novel author: <i>PhotoComiX</i>. Latest update : <i>2011/13/11</i>.</small>")
#@gui : note = link("Filter explained here","http://www.gimpchat.com/viewtopic.php?f=9&t=1582")
#@gui : 6. Graphic Novel Iterations = int(1,0,10)
#@gui : sep = separator ()
#@gui : note = note("Apply Local Normalization")
#@gui : 7. Skip This Step = bool(false)
#@gui : sep = separator ()
#@gui : note = note("Local Normalization Controls")
#@gui : 8. Ln Amplititude = float(2,0,60)
#@gui : 9. Ln Size = float(6,0,64)
#@gui : 10. Ln Neightborhood-Smoothness = float(5,0,40)
#@gui : 11. Ln Average-Smoothness = float(20,0,40)
#@gui : sep = separator()
#@gui : 12. Skip All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : note = note(" Pencil Options")
#@gui : 13. Pencil Size = float(0.62,0,4)
#@gui : 14. Pencil Amplitude = float(14,0,200)
#@gui : sep = separator()
#@gui : 15. Skip All Other Steps = bool(false)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui : 16. Activate "pencil Smoother" = bool(true)
#@gui : note = note(" If unchecked the 3 sliders below are disabled ")
#@gui : sep = separator()
#@gui : 17. Pencil Smoother Sharpness = float(0.5,0,2)
#@gui : 18. Pencil Smoother Edge Protection = float(0.78,0,1)
#@gui : 19. Pencil Smoother Smoothness = float(1.92,0,10)
#@gui : sep = separator()
#@gui : 20. Skip All Other Steps = bool(false)
#@gui : sep = separator ()
#@gui : sep = separator()
#@gui : note = note ("Boost Merging Options")
#@gui : 21. Swap Layers = bool (false)
#@gui : 22. Mixer = choice("Overlay","Multiply","Soft light","Color Burn","Darken","Stamp","Hard Light","Value","Grain Merge","Freeze","Lightness", "Luminance","*Colors Doping","*Comix Colors*" ,"Graphic Colours","*Graphix Colors","*Vivid Edges*","*Dark Edges*","*Dark Screen*","*Vivid Screen*","Interpolate")
#@gui : 23. Opacity = float(1,0,1)
#@gui : 24. Intensity = float(1,0,1)
#@gui : sep = separator ()
#@gui : 25. Add Painter's Touch = bool(true)
#@gui : sep = separator ()
#@gui : 26. Painter's Touch Sharpness = float(0.5,0,2)
#@gui : 27. Painter's Edge Protection Flow = float(0.8,0,1)
#@gui : 28. Painter's Smoothness = float(1.28,0,10)
#@gui : sep = separator(), 29-31. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_hard_painting : skip ${4=0},${5=0}
repeat $! l[$>]
to_colormode {max(3,s)} split_opacity
l[0]
repeat $1 fx_normalize_local 10,6,5,20,1,11 done
fx_smooth_anisotropic {100*$2},0.2,1,$2,{2*$2},0.8,90,2,0,1,1,2,1,16
fx_mix_lab 1,0,0,$3,0,0.5,$3,0,0.5,0,2,0
if $5 fx_segment_watershed 10,1,0 fi
smooth. $4,0,1,1,1
split_opacity l[0]
repeat max(0,$6)
if $7==0 fx_normalize_local $8,$9,$10,$11,1,3,0 fi
if $12==0 +fx_pencilbw $13,$14,0,0,0 fi
if $15==1 k[-1] break fi
if $16==1 fx_smooth_anisotropic[-1] 60,$17,$18,$19,1.1,0.8,30,2,0,1,1,0 fi
if $20==1 k[-1] break fi
if $21==1 rv fi
if $22==0 fx_compose_overlay $23,0
elif $22==1 fx_compose_multiply $23,0
elif $22==2 fx_compose_softlight $23,0
elif $22==3 fx_compose_colorburn $23,0
elif $22==4 fx_compose_darken $23,0
elif $22==5 fx_compose_stamp $23,0
elif $22==6 fx_compose_hardlight $23,0
elif $22==7 fx_compose_value $23,1
elif $22==8 fx_compose_grainmerge $23,0
elif $22==9 fx_compose_freeze $23,0
elif $22==10 fx_compose_lightness $23,1
elif $22==11 fx_compose_luminance $23,1
elif $22==12 fx_compose_colordoping $23,0
elif $22==13 fx_compose_comix_color $23,0,$24
elif $22==14 fx_compose_graphicolor $23,0,$24
elif $22==15 fx_compose_graphixcolor $23,0
elif $22==16 fx_compose_vividedges $23,0.50,0,$24
elif $22==17 fx_compose_darkedges $23,0.50,0,$24
elif $22==18 fx_compose_vividscreen $23,0,$24
elif $22==19 fx_compose_darkscreen $23,0,$24
elif $22==20 fx_compose_interpolation $23,0 fi
if $25==1 fx_smooth_anisotropic 60,$26,$27,$28,1.1,0.8,30,2,0,1,1,0 fi
done
done
done
a c
done
done
fx_hard_painting_preview :
gui_split_preview "fx_hard_painting $*",${-3--1}
#@gui Neon : fx_neon, fx_neon_preview
#@gui : note = note("Turns bright image outlines into bright, neon-like lines.")
#@gui : sep = separator(), note = note("Lines")
#@gui : 1. Norm Mode = choice("Gradient norm","Hessian","Laplacian","Rotation-invariant gradient","Afre's Edge algorithm")
#@gui : 2. Thinning  = int(1,1,10)
#@gui : 3. Recovery  = float(1,.5,4)
#@gui : 4. Brightness  = float(1,.5,4)
#@gui : 5. Details  = float(1,.5,4)
#@gui : 6. Smoothness = float(0,0,10)
#@gui : 7. Contrast = float(0.45,0,1.5)
#@gui : 8. Min Threshold = float(40,0,100)
#@gui : 9. Max Threshold = float(60,0,100)
#@gui : 10. Negative = bool(0)
#@gui : 11. Opacity Over Original = float(1,0,1)
#@gui : 12. Saturation = float(1.15,0,4)
#@gui : 13. Blur Colours = float(2,0,20)
#@gui : sep = separator(), note = note("Antialias")
#@gui : 14. Amplitude = float(3,0,100)
#@gui : 15. Edge Threshold (%) = float(0,0,100)
#@gui : 16. Smoothness = float(3,0,5)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 17. Size = float(20,0,100)
#@gui : 18. Intensity = float(0.4,0,3)
#@gui : 19. Darken = float(0.1,0,1)
#@gui : 20. Saturation = float(1.5,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 21. Size = float(5,0,100)
#@gui : 22. Intensity = float(0.2,0,3)
#@gui : 23. Darken = float(0.1,0,1)
#@gui : 24. Saturation = float(1,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 25. Size = float(2,0,5)
#@gui : 26. Intensity = float(1,0,3)
#@gui : sep = separator()
#@gui : 27. Smooth Hues = float(0,0,20)
#@gui : sep = separator()
#@gui : 28. Alpha = bool(0)
#@gui : 29. Alpha Power = float(1,0,5)
#@gui : 30. Alpha Multiplier = float(1,0,5)
#@gui : sep = separator(),  31. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), 32-33. Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_neon :
repeat $! l[$>]
+fc 0,0,0 rv blend alpha
to_rgb rgb2hsl8 s c
*.. {$12^2.5} c 0,255
a[0-2] c hsl82rgb
if $11
[0] l[1]
b $6
if $1==1
+hessian xx sqr.
+hessian.. yy sqr. +[-2,-1]
hessian.. zz sqr.. +[-2,-1]
s={s} s. c +[-$s--1] sqrt.
elif $1==2
laplacian abs to_gray to_rgb
elif $1==3
gradient xyz abs blend add to_gray to_rgb
elif $1==4
afre_edge ${2-5} * 4
else
gradient_norm replace_inf 1 replace_nan 0
fi
c 0,255
^ $7
c $8%,$9%
if $10 negate fi
n 0,255
if $14!=0||$15!=100
fx_smooth_antialias ${14-16}
fi
done
if $13
b[0] {$13}%
fi
blend multiply,$11
fi
+b[0] {$17%*100},1 *[1] {$18*sqrt($17%)*10} -[1] {(($18*sqrt($17%)*128)-1)^(sqrt($19))}
+b[0] {$21%*100},1 *[2] {$22*sqrt($21%)*10} -[2] {(($22*sqrt($21%)*128)-1)^(sqrt($19))}
+b[0] $25,1 *[3] {($18+$22)*$25*($26^2.5)}
rgb2hsl[1-3] s[1-3] c
*[2] {$20^2.5}
*[5] {$24^2.5}
*[8] 0
a[1-3] c a[2-4] c a[3-5] c hsl2rgb[1-3]
replace_inf 1 replace_nan 0
blend add
if $27
rgb2ycbcr s c b[1,2] {$27%*100} a c ycbcr2rgb
fi
if $28
rgb2hsv8 100%,100%,1,1 f[1] "((j(#0,0,0,0,2)/255)^(1/$25))*255*$30" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
fi

done done
fx_neon_preview :
gui_split_preview "fx_neon ${1-30}",${-3--1}
u "{$1}"\
"{$2}"_{$1==4?2:0}\
"{$3}"_{$1==4?2:0}\
"{$4}"_{$1==4?2:0}\
"{$5}"_{$1==4?2:0}\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18}"\
"{$19}"\
"{$20}"\
"{$21}"\
"{$22}"\
"{$23}"\
"{$24}"\
"{$25}"\
"{$26}"\
"{$27}"\
"{$28}"\
"{$29}"\
"{$30}"\
"{$31,$32}"\
"{$33}"
#@gui Neon Alpha: fx_neon_alpha, fx_neon_alpha_preview(0)
#@gui : note = note("An attempt to make the Neon filter work with alpha channels. Low-quality, comes with some artefacts.")
#@gui : sep = separator(), note = note("Gradient norm")
#@gui : 1. Smoothness = float(0,0,10)
#@gui : 2. Linearity = float(0.45,0,1.5)
#@gui : 3. Min Threshold = float(40,0,100)
#@gui : 4. Max Threshold = float(60,0,100)
#@gui : 5. Negative = bool(0)
#@gui : 6. Blur Original = float(2,0,20)
#@gui : 7. Saturation = float(1.15,0,4)
#@gui : sep = separator(), note = note("Colour Glow 1")
#@gui : 8. Size = float(20,0,100)
#@gui : 9. Intensity = float(0.4,0,3)
#@gui : 10. Darken = float(0.1,0,1)
#@gui : 11. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Colour Glow 2")
#@gui : 12. Size = float(5,0,100)
#@gui : 13. Intensity = float(0.2,0,3)
#@gui : 14. Darken = float(0.1,0,1)
#@gui : 15. Saturation = float(2.25,0,4)
#@gui : sep = separator(), note = note("Boost Glow")
#@gui : 16. Size = float(2,0,5)
#@gui : 17. Intensity = float(1,0,2)
fx_neon_alpha :
repeat $! l[$>]
to_rgba
+split_opacity
rm[1]
fx_solidify_td[0] 100,0,10,2,0 +invert_rgb[0]
blend[1,2] difference
fx_gradient_norm[1] ${1-4},0
if $7!=1
l[0] to_rgb[0] rgb2hsl[0] s[0] c
*[1] {$7^2.5}
a[0-2] c hsl2rgb[0]
done fi
if $6
b[0] $6
fi

[0] [1] a[2,3] c b[2] $8,1 *[2] {$9*sqrt($8)} -[2] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
[0] [1] a[3,4] c b[3] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
split_opacity[2,3]

l[2] to_rgb[0] rgb2hsv[0] s[0] c
*[1] {$11^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] done
l[4] to_rgb[0] rgb2hsv[0] s[0] c
*[1] {$15^2.5}
+[2] 1
a[0-2] c hsv2rgb[0] done


blend[3,5] average
blend[2,4] add
b[2] {$9*13}

+blend[0,2] add rm[0] mv[3] 0
[1]
a[0,1] c a[1,2] c [1] mv[3] 0
blend[0,1] alpha blend[0,1] add

#a[0,1] c

#+b[1] $16,1 *[2] {($9+$13)*$16*$17}
#+b[1] $8,1 *[3] {$9*sqrt($8)} -[3] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
#+b[1] $12,1 *[4] {$13*sqrt($12)} -[4] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
#+b[0] {$12+$8}
#blend[3,4] add
#+a[0,3] c
#a[0,1] c rm[2]

#blend[0,1] add


#+b[2] $8,1 *[3] {$9*sqrt($8)} -[3] {(($9*sqrt($8)*128)-1)^(sqrt($10))}
#+b[1] $16,1 *[2] {($9+$13)*$16*$17}
#blend[1,3] add
#rgb2hsl[1] s[1] c *[2] $11 a[1-3] c  hsl2rgb[1] a[1-2] c *[1]

#[1] rv[0,1] blend[0,1] alpha blend[0,1] add
#+a[0,1] c

#+b[1] $12,1 *[3] {$13*sqrt($12)} -[3] {(($13*sqrt($12)*128)-1)^(sqrt($14))}
#+b[0] $16,1 *[2] {($9+$13)*$16*$17}
#blend[0,2] add
#c 0,255
#+a[0,1] c
#blend[0-1]
#rv[1-4] blend[1-4] add
#a[0,1] c
done done
fx_neon_alpha_preview :
fx_neon_alpha $*
#@gui Dreamy Abstraction : fx_dreamy_abstraction, fx_dreamy_abstraction_preview()
#@gui : note = note("A less-aggressive alternative to the Painting filter. Yes, 'Joan Rake' made a filter that isn't aggressive! What kind of digital paint has she been sniffing?")
#@gui : sep = separator(), note = note("Segmentation")
#@gui : 1. Edge Threshold = float(2,0,30)
#@gui : 2. Smoothness = float(1,0,10)
#@gui : 3. Blend Mode = choice(1,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 4. Opacity = float(0.5,0,1)
#@gui : sep = separator(), note = note("Noise")
#@gui : 5. Noise Amplitude = float(10,0,100)
#@gui : 6. Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice","Spread")
#@gui : 7. Noise Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 8. Blend Mode = choice(7,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : 9. Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("Blur &#38; Constrained Sharpen")
#@gui : 11. Blur Strength = float(3,0,20)
#@gui : 12. Sharpen Radius Factor = float(1,0,5)
#@gui : 13. Amount Factor = float(1,0,5)
#@gui : 14. Threshold = float(1,0,5)
#@gui : 15. Constraint Radius Factor = float(1,0,5)
#@gui : 16. Overshoot Factor = float(1,0,20)
#@gui : 17. Sharpen Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : 18. Value Action = choice(1,"None","Cut","Normalize")
#@gui : 19. Antialias = float(25,0,100)
#@gui : sep = separator(), note = note("Glow")
#@gui : 20. Size = float(5,0,50)
#@gui : 21. Intensity = float(1,0,3)
#@gui : 22. Darken = float(0,0,1)
#@gui : 23. Saturation = float(1.5,0,4)
#@gui : sep = separator(), 24-26. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_dreamy_abstraction :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption1=$3
Opacity1=$4
MergingOption2=$8
Opacity2=$9
if $4>=0
+fx_segment_watershed $1,$2,1,1 blend ${_mode{$MergingOption1+1}},$Opacity1
fi
if $5>=0
+fc 0,0,0 -to_rgb
if $6==5
ac. "spread {([$5,$5]/100)*max(w,h)}",$7,1
else
ac. "_jr_fx_noise {255*$5/100},$6",$7,1
fi
blend ${_mode{$MergingOption2+1}},$Opacity2
if $10>=0
_fx_gaussian_blur $10,0,0,1
fi
fi
radius={$10*$11*2}
amount={$10*$12*2}
cradius={$10*$14*2}
overshoot={$10*$15/10}
iain_constrained_sharpen $radius,$amount,$13,$cradius,$overshoot,$16,$17
if $18>=0
fx_smooth_antialias {$18+(5*$10)},0,{($18+(5*$10))/20}
fi
fx_dreamy_abstraction_preview:
gui_split_preview "-fx_dreamy_abstraction $*",${-3--1}

#@gui Otsu-Hessian Blend: fx_otsu_hessian_blend, fx_otsu_hessian_blend_preview(1)
#@gui : note = note("Expansion of <a href="https://discuss.pixls.us/t/one-liner-challenge/8785/7?u=joan_rake1">a one-line filter by Afre</a>.")
#@gui : Otsu Levels = int(4,1,32)
#@gui : Norm 1 = float(0,-5,5)
#@gui : Norm 2 = float(1,-5,5)
#@gui : Merging Option = choice(27,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Opacity = float(1,0,1)
#@gui : Reverse Order = bool(0)
fx_otsu_hessian_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
MergingOption=$4
Opacity=$5
ReverseOrder={!$6}
+l otsu $1 afre_hnorm n $2,$3 done +* blend ${_mode{$MergingOption+1}},$Opacity,$ReverseOrder
fx_otsu_hessian_blend_preview :
repeat max(0,l)
fx_otsu_hessian_blend[$>] $*
done

#@gui _<b>Rendering</b>

#@gui Rectexture : fx_rectexture, fx_rectexture(1)
#@gui : note = note("Generates textures from rectangles, difference blending and warping.")
#@gui : Recompute = button()
#@gui : Iterations = int(10,0,500)
#@gui : Colours = choice(3,"Random colours &#40;difference blending&#41;","Random colours &#40;diffblend &#43; sine mapping&#41;","Random colours &#40;diffblend &#43; sinemap &#43; random HSV mixing&#41;","Black and white")
#@gui : Warp Multiplier = float(1,0,5)
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Channel(s) = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")

rectexture:
split_opacity l[0]

  if $2==0
    fill_color[-1] ${-RGB}
  elif $2==1
    fill_color[-1] ${-RGB}
  elif $2==2
    fill_color[-1] ${-RGB}
  else
    rr={255*round(u)}
    fill_color[-1] $rr,$rr,$rr
  fi
  repeat max(0,$1)
    +fill_color 0,0,0
    if $2==0
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      blend[-1,-2] difference
    elif $2==1
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      blend[-1,-2] difference
    elif $2==2
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,${-RGB}
      blend[-1,-2] difference
    else
      rectangle[-1] {u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,{u(-50,150)}%,1,255,255,255
      blend[-1,-2] difference
    fi
  done
  if $4==0
    f={u(0,3)}
  elif $4==1
    f={u(0,2)+1}
  else
    f={($4)-2}
  fi
  fx_warp_by_intensity {$3*(u(2)-1)},{$3*(u(2)-1)},{w*$3*(u(2)-1)},{h*$3*(u(2)-1)},0,0,{$f},0,0
  if $2==1
       normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
  fi
  if $2==2
      normalize 0,{u(5,20)*pi} sin[-1] -n 0,255
      mults=u(0,2.5)
      multv=u(0,2.5)
      fx_mix_hsv {(2^u(0,2.5))-1},{u(-180,180)},0,{(2^$mults)-1},{max(0,2-(2^$mults))*u(-1,1)},0,{(2^$multv)-1},{max(0,2-(2^$multv))*u(-1,1)},0,0,2,0
  fi
  done a c

fx_rectexture:
  repeat $! l[$>]
    ac "rectexture ${2-5}",$-2,$-1
  done done

#@gui Crazy Texture: fx_crazy_texture, fx_crazy_texture_preview(1)
#@gui : note = note("Generates black and white textures using deformed edge offsets applied to Poisson-disk noise. The textures can range from smoothly-deformed and trippy to gnarled and wood-like.")
#@gui : 0. Recompute = button(0)
#@gui : sep = separator(), note = note("Poisson-Disk Noise")
#@gui : 1. Radius = float(75,1,1000)
#@gui : 2. Max Sampling Attempts = int(30,1,200)
#@gui : sep = separator(), note = note("Edge Offsets")
#@gui : 3. Smoothness = float(0,0,10)
#@gui : 4. Threshold = float(15,0,50)
#@gui : 5. Scale = int(6,0,64)
#@gui : 6. Thickness = int(3,0,32)
#@gui : 7. Negative Colors = bool(0)
#@gui : sep = separator(), note = note("Deform 1")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;coarse&#41;</small>")
#@gui : 8. Strength = float(15,0,30)
#@gui : 9. Interpolation = choice("none","bilinear","bicubic")
#@gui : 10. Matrix Density &#40;&#37;&#41; = float(1,1,100)
#@gui : 11. Matrix Interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : 12. Matrix Contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("Deform 2")
#@gui : note = note("<small>Set matrix density to 1 for automatic size &#40;fine&#41;</small>")
#@gui : 13. Strength = float(1.5,0,30)
#@gui : 14. Interpolation = choice("none","bilinear","bicubic")
#@gui : 15. Matrix Density &#40;&#37;&#41; = float(1,1,100)
#@gui : 16. Matrix Interpolation &#40;&#37;&#41; = choice(1,"bilinear","bicubic")
#@gui : 17. Matrix Contrast = float(0,-100,100)
#@gui : sep = separator(), note = note("This can slow things down a lot if both deform strengths are high!")
#@gui : 18. Accurate Boundaries = bool(1)
#@gui : 19. Crop Strength = float(1,0,1)
_crazy_texture :
to_rgb fc 0,0,0
ms1=0 if $10==1 ms1={0.125*max(w,h)/($2^0.375)} else ms1=$10 fi
ms2=0 if $15==1 ms2={0.625*max(w,h)/($2^0.25)} else ms2=$15 fi
CF={$8*$13*$19}
if $18 expand_xy {$CF} fi
noise_poissondisk $1,$2
fx_edge_offsets ${3-7}
jr_deform $8,$9,$ms1,$11,0,$12,1
jr_deform $13,$14,$ms2,$16,0,$17,1
if $18 shrink_xy {$CF} fi
fx_crazy_texture:
_crazy_texture ${2-20}
fx_crazy_texture_preview :
fx_crazy_texture $*

#@gui _<b>Deformations</b>

#@gui Auto-Gnarl : fx_auto_gnarl, fx_auto_gnarl_preview(1)
#@gui : note = note("Applies random deformations mainly to sharp edges.")
#@gui : sep = separator()
#@gui : note = note("<small>Gradient Norm</small>")
#@gui : Smoothness = float(3,0,10)
#@gui : Contrast = float(0.45,0,1.5)
#@gui : Min Threshold = float(40,0,100)
#@gui : Max Threshold = float(60,0,100)
#@gui : Negative = bool(0)
#@gui : Scale X = float(1,0,5)
#@gui : Scale Y = float(1,0,5)
#@gui : Interpolation = choice(2,"Nearest","Average","Bilinear","Bicubic")
#@gui : sep = separator()
#@gui : note = note("<small>Noise Local Normalisation</small>")
#@gui : Amplitude = float(4,0,60)
#@gui : Radius = int(6,1,64)
#@gui : Neighborhood Smoothness = float(5,0,40)
#@gui : Average Smoothness = float(20,0,40)
#@gui : Constrain Values = bool(1)
#@gui : sep = separator()
#@gui : note = note("<small>Warping</small>")
#@gui : Smoothness = float(2.5,0,30)
#@gui : Rounding = float(0.5,0,1)
#@gui : Amplitude = float(2,0,5)
#@gui : Interpolation = choice(2,"Nearest","Bilinear","Bicubic")
#@gui : Boundary = choice(3,"None","Nearest","Periodic","Mirror")
fx_auto_gnarl:
repeat $! l[$>]
+fx_jr_gradient_norm ${1-5},0,${6-8},0
100%,100%,1,2 f. "u(-1,1)"
b. $14
normalize_local. ${9-13},-1,1
n. -1,1
*. .. rm.. *. {1/255} round. {$15^4}
*. {$16^3}
warp.. .,1,$17,$18
rm.
done done
fx_auto_gnarl_preview:
fx_auto_gnarl $*

#@cli symmetrize_jr : _x[%],_y[%],_angle,_boundary_conditions={ 0=dirichlet | 1=neumann | 2=periodic | 3=mirror },_is_antisymmetry={ 0 | 1 },_swap_sides={ 0 | 1 },_interpolation={ 0=none | 1=linear | 2=bicubic }
#@cli : Symmetrize selected images regarding specified axis.
#@cli : Default values: 'x=y=50%', 'angle=90', 'boundary_conditions=3', 'is_antisymmetry=0', 'swap_sides=0' and 'interpolation=1'.
#@cli : $ image.jpg +symmetrize 50%,50%,45 +symmetrize[-1] 50%,50%,-45
symmetrize_jr : skip ${1=50%},${2=50%},${3=90},${4=3},${5=0},${6=0},${7=1}
e[^-1] "Symmetrize image$?, regarding axis ($1,$2,$3 deg.)."
v -
theta={$3*pi/180} u={cos($theta)} v={sin($theta)}
if $6 symmetry_cond=A<0 else symmetry_cond=A>0 fi
repeat $! l[$>]
x0={if(${is_percent\ $1},w*$1,$1)}
y0={if(${is_percent\ $2},h*$2,$2)}
if $5 f 'A=($y0-y)*$u-($x0-x)*$v;X=x+2*($x0-x);Y=y+2*($y0-y);if($symmetry_cond,i(X,Y,z,c,$7,$4),i)'
else f 'A=($y0-y)*$u-($x0-x)*$v;X=x-2*$v*A;Y=y+2*$u*A;if($symmetry_cond,i(X,Y,z,c,$7,$4),i)'
fi
done done
#@cli jr_deform : _amplitude>=0,_interpolation,_matrix_density[%]>=0,_matrix_interpolation,_mode,-100<=_character<=100,_boundary
#@cli : Apply random smooth deformation on selected images. An upgrade to the existing deform command.
#@cli : 'interpolation' can be { 0=none | 1=linear | 2=bicubic }.
#@cli : 'matrix_interpolation' can be { 0=linear | 1=bicubic }.
#@cli : 'mode' can be { 0=noise | 1=spread_noise }.
#@cli : 'boundary' can be  { 0=dirichlet | 1=neumann | 2=periodic | 3=mirror }.
#@cli : Default value: 'amplitude=10'.
#@cli : $ image.jpg +deform[0] 10 +deform[0] 20
jr_deform : skip ${1=10},${2=1},${3=2%},${4=1},${5=0},${6=0},${7=1}
  e[^-1] "Apply random smooth deformation on image$?, with amplitude $1."
  v - repeat $! l[$>]
    R={max(1,${"is_percent $3"}?$3*max(w,h):$3)}
    P={$4==0?3:5}
    if $5==1 +r. {$R},{$R},1,4 spread. {max(w,h)*($6+100)/200},{max(w,h)*($6+100)/200}
    else {$R},{$R},1,4 noise. $1
    fi
    ac. "adjust_colors 0,$6,0,0,0",rgba r. ..,..,1,4,$P warp.. .,1,$2,$7 rm.
  done done v +

#@gui Layer Cake : fx_layer_cake, fx_layer_cake_preview(1)
#@gui : note = note("Splits image into annular or circular layers and rotates each layer. Based on <a href="https://forums.getpaint.net/topic/26566-layer-cake-plugin/">the Paint.NET plugin</a>.")
#@gui : Iterations = int(4,1,32)
#@gui : Angle at Centre = float(360,-1440,1440)
#@gui : Angle Times Iteration = bool(0)
#@gui : Size = float(75,0,200)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Boundary = choice(3,"None","Nearest","Periodic","Mirror")
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Blur = float(0,0,200)
#@gui : sep = separator()
#@gui : Anti-Alias Amplitude = float(30,0,100)
#@gui : Edge Threshold (%) = float(0,0,100)
#@gui : Smoothness = float(3,0,10)
#@gui : Output Layers = choice("Off","Hollow","Filled")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
fx_layer_cake :
repeat $! l[$>]
iter=$1
angle=$2
if $3 angle*=$iter fi
size=$4/2
to_rgba split_opacity to_rgb
repeat 2
part={1-$>}
l[$part]
repeat $iter
[0] rotate[-1] {$angle/$iter*($>+1)},$8,$7,$5%,$6%
100%,100%,1,1 ellipse. $5%,$6%,{$size/$iter*($iter-$>)}%,{$size/$iter*($iter-$>)}%,0,1,255
if $13!=2 ellipse. $5%,$6%,{$size/$iter*($iter-1-$>)}%,{$size/$iter*($iter-1-$>)}%,0,1,1 fi
blur. {$9/$iter}
fx_smooth_antialias. ${10-12}
blend[-1,-2] multiply
done
if !$13 blend[^0] add fi
if $13!=2 100%,100%,1,1 fc. 255,255,255 ellipse. $5%,$6%,{$size}%,{$size}%,0,1,0
blur. {$9/$iter}
fx_smooth_antialias. ${9-11}
blend[-1,0] multiply fi
if !$13 blend add fi
if $part to_gray fi
done
done
list={int($!/2)}
repeat $list a[$>,$list] c done
skip {$13==0}
if $13 rv fi
done
done
fx_layer_cake_preview:
if !$13 gui_split_preview "fx_layer_cake $*",${-3--1} else fx_layer_cake ${1-12},0 fi

#@gui Layer Cake 2 : fx_layer_cake_2, fx_layer_cake_2_preview(1)
#@gui : Layer Density = float(4,1,100)
#@gui : Angle Value = float(360,-2880,2880)
#@gui : Angle Mode = choice("Divided by Density","Per Layer")
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Interpolation = choice(2,"None","Linear","Bicubic")
#@gui : Boundary = choice(3,"None","Nearest","Periodic","Mirror")
#@gui : Blur = float(50,0,100)
#@gui : Blur Mode = choice("Anti-Alias","Layer Smoothing")
#@gui : Output Mode = choice("Full","Filled Layers","Hollow Layers")
fx_layer_cake_2 :
num=$1
inter=$6
bound=$7
if $3
ang={$2*2*pi/360}
else
ang={$2*2*pi/(($num)*360)}
fi
repeat $! l[$>]
xc=$4%
yc=$5%
if $9
aa={$8*norm(w,h)/100}
else
aa={$8/25*$num}
fi
if $10
to_rgba
#repeat ceil($num*(1+max(norm(w/2-$xc,h/2-$yc)/norm(w,h)*2,1))
100%,100%,100%,100%,(0)
repeat ceil($num*(1+max(norm(w/2-$xc,h/2-$yc)/norm(w,h)*2,1)))
[1]
done
inuma=0
inumb=0
eval[0] "begin(ang=("$ang");xoff=w*"$xc";yoff=h*"$yc";num="$num";aa="$aa";inter="$inter";bound="$bound");
vx=x-xoff+0.5;vy=y-yoff+0.5;
lnum=max((norm(vx,vy))/norm(w,h)*2*num-(0.5*aa/norm(w,h)),0);
lnumint=floor(lnum);
run("inuma=lnumint+1
inumb=lnumint+2");
angle=((ang*lnumint)%(2*pi));
pa=I(#0,vx*cos(angle)+vy*sin(angle)+xoff-0.5,vy*cos(angle)-vx*sin(angle)+yoff-0.5,z,inter,bound);
pb=I(#0,vx*cos(angle+ang)+vy*sin(angle+ang)+xoff-0.5,vy*cos(angle+ang)-vx*sin(angle+ang)+yoff-0.5,z,inter,bound);
func=min((lnumint+1-lnum)*norm(w,h)/aa,1);

I(#"$3")=(pb*(1-func));
I(#"{$3+2}")=(pa*(func))
"
#done
else
f "begin(ang=("$ang");xoff=w*"$xc";yoff=h*"$yc";num="$num";aa="$aa";inter="$inter";bound="$bound");
vx=x-xoff+0.5;vy=y-yoff+0.5;
lnum=max((norm(vx,vy))/norm(w,h)*2*num-(0.5*aa/norm(w,h)),0);
lnumint=floor(lnum);
angle=((ang*lnumint)%(2*pi));
pa=I(vx*cos(angle)+vy*sin(angle)+xoff-0.5,vy*cos(angle)-vx*sin(angle)+yoff-0.5,z,inter,bound);
angle+=ang;
pb=I(vx*cos(angle)+vy*sin(angle)+xoff-0.5,vy*cos(angle)-vx*sin(angle)+yoff-0.5,z,inter,bound);
func=min((lnumint+1-lnum)*norm(w,h)/aa,1);
I=(pa*(func)+pb*(1-func))"
fi
done done
fx_layer_cake_2_preview :
fx_layer_cake_2 $*

#@gui PowerTwirl : fx_powertwirl, fx_powertwirl_preview(1)
#@gui : Amplitude = float(1,-20,20)
#@gui : Offset = float(0,-180,180)
#@gui : Center (%) = point(50,50,0,1)
#@gui : Power = float(1,-20,20)
#@gui : Interpolation = choice(2,"None","Linear","Bicubic")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : Mode = choice(0,"Polar","Cartesian")
fx_powertwirl:
if $8
f "begin(amp=$1;offset=$2;xoff=$3*w/100;yoff=$4*h/100;power=$5;interpolation=$6;boundary=$7);
vx=x-xoff+0.5;vy=y-yoff+0.5;
ang=(2*pi*((offset/360)+(amp*((norm(vx,vy)/(norm(w,h)/2))^power))))%(2*pi);
I=I(vx*cos(ang)+vy*sin(ang)+xoff-0.5,vy*cos(ang)-vx*sin(ang)+yoff-0.5,z,interpolation,boundary)"
else
euclidean2polar $3%,$4%,$6,$7 repeat $!
[$>],[$>],1,1,$1*0.75*(((x/w)^$5))*w channels. -1,0 warp[$>] .,1,1,2 rm.
done polar2euclidean $3%,$4%,$6,$7
fi
fx_powertwirl_preview:
fx_powertwirl $*

#@gui Kaleidoscope Layer Cake : fx_jr_klc, fx_jr_klc_preview(1)
#@gui : sep = separator()
#@gui : Kaleidoscope Mirrors = int(6,0,64)
#@gui : Mirror Rotation = float(0,-360,360)
#@gui : M-Rot Mode = choice("Fixed Mirrors","Fixed Background")
#@gui : Result Rotation = float(0,-360,360)
#@gui : R-Rot Mode = choice("Full","Sector")
#@gui : Mirror Offset (%) = point(50,50,0,1)
#@gui : Centre (%) = point(50,50,0,1)
#@gui : Slice Mode = choice("Symmetric","Asymmetric","Reverse Asymmetric")
#@gui : sep = separator()
#@gui : Layer Cake Density = float(30,0,100)
#@gui : Angle = float(0,-1440,1440)
#@gui : Angle Mode = choice("Layer","Density","Sector","Density & Sector")
#@gui : sep = separator()
#@gui : Scale (%) = float(100,0,1000)
#@gui : Anti-Alias = float(1,0,2)
#@gui : Interpolation = choice(2,"None","Linear","Bicubic")
#@gui : Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
fx_jr_klc:
num=$1
mrot={$2/180*pi}
rrot={$4/180*pi}
if $5 rrot/={max($num,1)} fi
if !$3 rrot-=$mrot fi
symm=$10
lcd=$11
lcmode=$13
if $lcmode==1
lcang={$12/(180*$lcd)*pi}
elif $lcmode==2
lcang={$12/(180*(max($num,1)))*pi}
elif $lcmode==3
lcang={$12/(180*$lcd*(max($num,1)))*pi}
else
lcang={$12/180*pi}
fi
scale=$14*0.01
aa=$15*0.25
inter=$16
bound=$17
repeat $! l[$>]
ox=$6*w*0.01
oy=$7*h*0.01
cx=$8*w*0.01
cy=$9*h*0.01
f "begin(const num="$num";const cx="$cx";const cy="$cy";const ox="$ox";const oy="$oy";const aa="$aa";const rrot="$rrot";
num==0?(const awidth=8*pi;const mrot=0;const symm=1):(const awidth=pi/num;const mrot="$mrot";const symm="$symm");const interpolation="$inter";const boundary="$bound";const scale="$scale";const lcd="$lcd";
lcd==0?(const ilcang="$lcang"):(const ilcang="$lcang");const diag=sqrt(w^2+h^2));
vx=x-cx;vy=y-cy;
iang=atan2(vy,vx)-rrot-mrot;
irad=norm(vx,vy);
lnum=max((irad/diag*2-(4*aa/diag))*lcd*scale,0);
lnumint=floor(lnum);
ang=iang-(((lcd==0?(irad/diag*2-(4*aa/diag))*scale:(lnumint))+[0,1])*ilcang);
mult=ang/awidth - 1;
multint=floor(mult);
multintaa = floor(mult+min((aa*0.5*num)/(irad),irad*0.5/(pi*num)));
kfunc=[min(((mult[0]-multintaa[0])*irad/(aa*num)+0.5),1),min(((mult[1]-multintaa[1])*irad/(aa*num)+0.5),1)];
lcfunc=min((lnumint+1-lnum)/(aa*(lcd==0?(abs(ilcang)):(lcd))*scale)*diag*0.125,1);
angle0=ang-multintaa*awidth;
angle1=ang-(multintaa+1)*awidth;
for(i=0,i<2,i++,
symm==1?(angle1[i]=angle1[i]):symm==2?(angle0[i]=awidth-angle0[i];angle1[i]=awidth-angle1[i]):
((multint[i]%2==1)?(multintaa[i]>multint[i]?(angle1[i]=awidth-angle1[i]):(angle0[i]=awidth-angle0[i])):(multintaa[i]>multint[i]?(angle0[i]=awidth-angle0[i]):(angle1[i]=awidth-angle1[i])));
isnan(kfunc[i])?kfunc[i]=1);
angle0+=mrot;
angle1+=mrot;
frad=irad*scale;
xwarp00=frad*cos(angle0[0])+ox;
ywarp00=frad*sin(angle0[0])+oy;
xwarp01=frad*cos(angle1[0])+ox;
ywarp01=frad*sin(angle1[0])+oy;
xwarp10=frad*cos(angle0[1])+ox;
ywarp10=frad*sin(angle0[1])+oy;
xwarp11=frad*cos(angle1[1])+ox;
ywarp11=frad*sin(angle1[1])+oy;
(I(xwarp00,ywarp00)*(1-kfunc[0])+I(xwarp01,ywarp01)*(kfunc[0]))*(lcfunc)+(I(xwarp10,ywarp10)*(1-kfunc[1])+I(xwarp11,ywarp11)*(kfunc[1]))*(1-lcfunc)"
done done
fx_jr_klc_preview:
fx_jr_klc $*
c 0,255

#@gui Random Deformations (JR's Mod) : fx_jr_deform, fx_jr_deform_preview(1)
#@gui : Recompute = button(0)
#@gui : Amplitude = float(5,0,50)
#@gui : Interpolation = choice(1,"None","Linear","Bicubic")
#@gui : Matrix Density = float(10,1,100)
#@gui : Matrix Interpolation = choice(1,"Linear","Bicubic")
#@gui : Mode = choice("Noise","Spread noise")
#@gui : Character = float(0,-100,100)
#@gui : Boundary = choice(1,"Dirichlet","Neumann","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
fx_jr_deform :
repeat $! l[$>]
jr_deform ${2-8}
done done
fx_jr_deform_preview :
gui_split_preview "fx_jr_deform $*",${-3--1}

#@gui Buffer Error: fx_buffer_error, fx_buffer_error_preview(0)
#@gui : note = note("<small>Resizes an image without changing the positions of pixels in a specified selection of a simulated image buffer. Buffer shift scales with the buffer length.</small>")
#@gui : 1. Width = float(50,0,200)
#@gui : 2. Height = float(50,0,200)
#@gui : 3. Buffer Selection Start (%) = float(0,0,100)
#@gui : 4. Buffer Selection Length (%) = float(100,0,400)
#@gui : 5. Buffer Selection Shift (%) = float(0,0,100)
#@gui : 6. Repeat Buffer = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)

_fx_virtual_buffer :
r {wh},1,100%,100%,-1,0

_fx_virtual_buffer_resize :
owh={int(wh)}
dimx={max(1,int($1))}
dimy={max(1,int($2))}
cs={int($3)}
cl={int($4)}
shift={int($5)}
bound=$6
# transform image to buffer
_fx_virtual_buffer shift {-$cs},0,0,0,2 crop 0,$cl,2 shift {$shift},0,0,0,2  if $bound resize {$dimx*$dimy},1,100%,100%,0,2 fi
# transform buffer into new image
$dimx,$dimy,100%,100%
f. ">begin(index=-1);index+=1;I[#0,index]"
k.
fx_buffer_error :
repeat $! l[$>]
dimx={int($1/100*w)}
dimy={int($2/100*h)}
cs={$3/100*wh}
cl={$4/100*wh}
shift={$5/100*$cl}
bound=$6
_fx_virtual_buffer_resize $dimx,$dimy,$cs,$cl,$shift,$bound

done done
fx_buffer_error_preview :
gui_split_preview "fx_buffer_error $*",${-3--1}

#@gui Buffer Destroyer: fx_buffer_destroyer, fx_buffer_destroyer_preview(0)
#@gui : note = note("<small>A preset combo of filters which rip images apart through simulated buffer manipulation and warping.</small>")
#@gui : 0. Recompute = button(0)
#@gui : 1. Alpha = bool(1)
#@gui : sep = separator(), note = note("<b>Buffer Error 1</b>")
#@gui : 2. Width = float(75,0,200)
#@gui : 3. Height = float(40,0,200)
#@gui : 4. Buffer Selection Start (%) = float(0,0,100)
#@gui : 5. Buffer Selection Length (%) = float(100,0,400)
#@gui : 6. Buffer Selection Shift (%) = float(0,0,100)
#@gui : 7. Repeat Buffer = bool(1)
#@gui : sep = separator(), note = note("<b>Shredder</b>")
#@gui : 8. Randomised Start = bool(1)
#@gui : 9. Channels = choice("Correlated","RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 10. Min Gap = float(50,0,100)
#@gui : 11. Max Gap = float(100,0,100)
#@gui : 12. Strength = float(0.5,0,1)
#@gui : sep = separator(), note = note("<b>Pixel Sort</b>")
#@gui : note = note{"<small><b>Sorting parameters:</b></small>"}
#@gui : 13. Order = choice(1,"Decreasing","Increasing")
#@gui : 14. Axis = choice("X-axis","Y-axis","X-axis Then Y-axis","Y-axis Then X-axis")
#@gui : 15. Sorting Criterion = choice(3,"Red","Green","Blue","Intensity","Luminance","Lightness","Hue",
#@gui : "Saturation","Minimum","Maximum","Random")
#@gui : note = note{"<small><b>Masking parameters:</b></small>"}
#@gui : 16. Mask By = choice("Criterion","Contours","Random")
#@gui : 17. Lower Mask Threshold (%) = float(50,0,100)
#@gui : 18. Higher Mask Threshold (%) = float(100,0,100)
#@gui : 19. Mask Smoothness (%) = float(0,0,5)
#@gui : 20. Invert Mask = bool(0)
#@gui : 21. Preview Mask = bool(0)
#@gui : sep = separator(), note = note("<b>Shifter</b>")
#@gui : note = note("<small>Amplitudes are cubed to tame the distortion a little bit.</small>")
#@gui : 22. Channels = choice("Correlated","RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 23. X Amplitude = float(2.5,0,10)
#@gui : 24. X Iterations = int(20,0,400)
#@gui : 25. Y Amplitude = float(2.5,0,10)
#@gui : 26. Y Iterations = int(20,0,400)
#@gui : 27. Matrix Warp Multiplier = float(1,0,5)
#@gui : 28. Matrix Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : 29. Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : sep = separator(), note = note("<b>Buffer Error 2</b>")
#@gui : 30. Inverse Of BE1 = bool(1)
#@gui : 31. Width = float(120,0,200)
#@gui : 32. Height = float(80,0,200)
#@gui : 33. Buffer Selection Start (%) = float(0,0,100)
#@gui : 34. Buffer Selection Length (%) = float(100,0,100)
#@gui : 35. Buffer Selection Shift (%) = float(0,0,100)
#@gui : 36. Repeat Buffer = bool(1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)

_fx_buffer_destroyer :
repeat $! l[$>]
to_rgba split_opacity
if $1 a c fi
l[0]
ow={w}
oh={h}
dimx1={int($2/100*w)}
dimy1={int($3/100*h)}
cs1={$4/100*wh}
cl1={$5/100*wh}
shift1={$6/100*$cl1}
bound1=$7
crit={1+$16}
_fx_virtual_buffer_resize {$dimx1*$dimy1},1,$cs1,$cl1,$shift1,$bound1
_fx_shredder $8,$9,$1,${10-12},0,0,0,0,0
$dimx1,$dimy1,100%,100%
f. ">begin(index=-1);index+=1;I[#0,index]"
k.
_fx_pixelsort ${13-15},{$crit},${17-21}
_fx_shifter $22,$1,{(($23/10)^3)*10},$24,{(($25/10)^3)*10},${26-29}
if $30
_fx_virtual_buffer_resize $ow,$oh,0,{wh},{-$shift1},$bound1
else
dimx2={int($31/100*w)}
dimy2={int($32/100*h)}
cs2={$33/100*wh}
cl2={$34/100*wh}
shift2={$35/100*$cl2}
bound2=$36
_fx_virtual_buffer_resize $dimx2,$dimy2,$cs2,$cl2,$shift2,$bound2
fi
done a c
done done
fx_buffer_destroyer:
_fx_buffer_destroyer ${2-37}
fx_buffer_destroyer_preview :
gui_split_preview "fx_buffer_destroyer $*",${-3--1}

#@gui UltraWarp 2 : fx_ultrawarptwo, fx_ultrawarptwo_preview(1)
#@gui :  note  = note("<small>A sequence of multiple self-warps and HSV/HSI/HSL operations. A remake of UltraWarp++++ but with more focus on granular features rather than preset combinations of filters. 'Range' parameters determine the upper and lower bounds while the 'centre' parameters set the mean values.</small>"), sep = separator()
#@gui : 0. Recompute = button(0)
#@gui : sep = separator(), note = note("<b>Warping</b>")
#@gui : 1. Iterations = int(3,1,30)
#@gui : 2. From RGB To = choice(1,"Random","RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 3. X-Factor Centre = float(0,-30,30)
#@gui : 4. X-Factor Range = float(3,0,30)
#@gui : 5. Y-Factor Centre = float(0,-30,30)
#@gui : 6. Y-Factor Range = float(3,0,30)
#@gui : 7. X-Offset Centre = float(0,-30,30)
#@gui : 8. X-Offset Range = float(3,0,30)
#@gui : 9. Y-Offset Centre = float(0,-30,30)
#@gui : 10. Y-Offset Range = float(3,0,30)
#@gui : 11. Correlated Channels = choice(2,"On","Off","Random")
#@gui : 12. Interpolation = choice(2,"Nearest","Linear","Random")
#@gui : 13. Boundary = choice(5,"Transparent","Nearest","Periodic","Mirror","Random","Random &#40;non-transparent&#41;")
#@gui : 14. Warp Channel(s) = choice(3,"None","Random","All","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : 15. Include Alpha = bool(0)
#@gui : 16. To RGB From = choice(1,"Random","RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 17. Random Negation = bool(1)
#@gui : sep = separator(), note = note("<b>Post-warping HSX8 mixing</b>")
#@gui : 18. Repeat For Each Iteration = bool(1)
#@gui : 19. X Channel = choice("Value","Intensity","Lightness")
#@gui : 20. Hue Factor Centre = float(1,-20,20)
#@gui : 21. Hue Factor Range = float(0.5,0,20)
#@gui : 22. Saturation Factor Centre = float(2.5,-20,20)
#@gui : 23. Saturation Factor Range = float(5,0,20)
#@gui : 24. X Channel Factor Centre = float(1,-20,20)
#@gui : 25. X Channel Factor Range = float(0,0,20)
#@gui : 26. Alpha Factor Centre = float(1,-20,20)
#@gui : 27. Alpha Factor Range = float(0,0,20)
#@gui : 28. Hue Shift Centre = float(0,-255,255)
#@gui : 29. Hue Shift Range = float(255,0,255)
#@gui : 30. Saturation Shift Centre = float(0,-255,255)
#@gui : 31. Saturation Shift Range = float(255,0,255)
#@gui : 32. X Channel Shift Centre = float(0,-255,255)
#@gui : 33. X Channel Shift Range = float(0,0,255)
#@gui : 34. Alpha Shift Centre = float(0,-255,255)
#@gui : 35. Alpha Shift Range = float(0,0,255)
ultrawarptwo :

repeat $! l[$>] to_rgba split_opacity

iter=$1
sc=$2
xfc=$3
xfr=$4
yfc=$5
yfr=$6
xoffc=$7
xoffr=$8
yoffc=$9
yoffr=$10
corr=$11
inter=$12
bound=$13
chann=$14
alpha=$15
cs=$16
rn=$17

rpo=$18
vil=$19
hfc=$20
hfr=$21
sfc=$22
sfr=$23
vilfc=$24
vilfr=$25
afc=$26
afr=$27
hoffc=$28
hoffr=$29
soffc=$30
soffr=$31
viloffc=$32
viloffr=$33
aoffc=$34
aoffr=$35

repeat $iter
if $alpha

opacity=2
else
opacity=1
fi
repeat $opacity
if $sc==0
frgbt={floor(u(0,25))}
else
frgbt={$sc-1}
fi
if $cs==0
trgbf={floor(u(0,25))}
else
trgbf={$cs-1}
fi
if $>==0
csswap[$>] 0,$frgbt
fi
if $>==1||$chann!=0
if $chann==1
channel={floor(u(2,37))}
else
channel=$chann
fi
if $channel==0
channels=0
elif $channel>=2
channels={$channel-1}
elif $channel>=6
channels=$channel
else
channels={$channel-2}
fi
if $corr==2
correl=round(u)
else
correl=$corr
fi
if $inter==2
interp=round(u)
else
interp=$inter
fi
if $bound==4
bounds={floor(u(4))}
elif $bound==5
bounds={floor(u(3))+1}
else
bounds=$bound
fi
xf={($xfc+u(-$xfr,$xfr))}
yf={($yfc+u(-$yfr,$yfr))}
xoff={($xoffc+u(-$xoffr,$xoffr))}
yoff={($yoffc+u(-$yoffr,$yoffr))}
xff={sign($xf)*w*0.00002*(abs($xf)^2)}
yff={sign($yf)*h*0.00002*(abs($yf)^2)}
xofff={sign($xoff)*w*0.00002*(abs($xoff)^2)}
yofff={sign($yoff)*w*0.00002*(abs($yoff)^2)}
fx_warp_by_intensity[$>] $xff,$yff,$xofff,$yofff,$correl,$interp,$bounds,$channels,0
fi
if $>==0
csswap[$>] $trgbf,0
fi
if $rn
if round(u)
negate[$>]
fi
fi
done
if $>==($iter-1)||$rpo
hf={$hfc+u(-$hfr,$hfr)}
sf={$sfc+u(-$sfr,$sfr)}
vilf={$vilfc+u(-$vilfr,$vilfr)}
af={$afc+u(-$afr,$afr)}
hoff={$hoffc+u(-$hoffr,$hoffr)}
soff={$soffc+u(-$soffr,$soffr)}
viloff={$viloffc+u(-$viloffr,$viloffr)}
aoff={$aoffc+u(-$aoffr,$aoffr)}

l[0] if $vil==1 rgb2hsi8 elif $vil==2 rgb2hsl8 else rgb2hsv8 fi
s c
*[0] $hf +[0] {$hoff*max(1,abs($hf))} %[0] 255
*[1] $sf +[1] {$soff*max(1,abs($sf))}
*[2] $vilf +[2] {$viloff*max(1,abs($vilf))}
a c
if $vil==1 hsi82rgb elif $vil==2 hsl82rgb else hsv82rgb fi
done
*[1] $af +[1] {$aoff*max(1,abs($af))}
fi

done
to_rgb[0]
to_gray[1]
a c
done
done

fx_ultrawarptwo :
ultrawarptwo ${2--1}

fx_ultrawarptwo_preview:
fx_ultrawarptwo $*

#@gui UltraWarp++++ : fx_ultrawarp4plus, fx_ultrawarp4plus_preview(0)
#@gui :  note  = note("A sequence of multiple partially-randomised texture generation and image deformation filters with multi-iteration warping.")
#@gui :  note  = note("<small>This modular filter is extremely complex and its logic may not follow that which you expect. Left on its default settings, it is very likely to munge your image beyond recognition. This original version has been kept alive despite being slower than UltraWarp 2.</small>"), sep = separator()
#@gui :  0.  Recompute  = button(0)
#@gui :  sep  = separator()
#@gui :  1.  Plasma Texture [Discards Input Image]  = bool(0)
#@gui :  2.  Plasma Scale  = float(3.3,0,20)
#@gui :  3.  Plasma Alpha Channel  = bool(0)
#@gui :  sep  = separator()
#@gui :  4.  Segmentation [No Alpha Channel]  = bool(0)
#@gui :  5.  Edge Threshold  = float (5,0.01,60)
#@gui :  6.  Smoothness  = float (0,0,60)
#@gui :  sep  = separator()
#@gui :  7.  Blur  = float (0,0,30)
#@gui :  sep  = separator()
#@gui :  8.  Quadtree Pixelisation [No Alpha Channel]  = bool(0)
#@gui :  9.  Quadtree Min Precision  = int(4,2,8192)
#@gui :  10.  Quadtree Max Precision  = int(256,0,8192)
#@gui :  11.  Quadtree Min Homogeneity  = float(4.8,0,5)
#@gui :  12.  Quadtree Max Homogeneity  = float(5,0,5)
#@gui :  sep  = separator()
#@gui :  13. Noise Type  = choice(2,"Gaussian","Uniform","Salt and pepper","Poisson")
#@gui :  14. Minimum Noise  = float(0,0,8)
#@gui :  15. Maximum Noise  = float(0,0,8)
#@gui :  16. Noise Channel(s)  = choice(2,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  sep  = separator(), note = note("<small>Warping</small>")
#@gui :  17. Warp Iterations  = int(3,0,30)
#@gui :  18. Warp Intensity  = float(3,0,10)
#@gui :  19. Warp Offset  = float(20,0,2000)
#@gui :  20. Scale to Width  = bool(1)
#@gui :  21. Scale to Height  = bool(1)
#@gui :  22. Correlated Channels  = choice("Random","Off","On")
#@gui :  23. Boundary  = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui :  24. Warp Channel(s)  = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  25. Random Negation  = bool(1)
#@gui :  26. Random Negation Channel(s)  = choice(2,"Random","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  27. Gamma Offset  = float(0.25,0,1)
#@gui :  28. Hue Offset  = float(1,0,1)
#@gui :  29. Normalise  = bool(1)
#@gui :  sep  = separator(), note = note("<small>Final HSV Scaling</small>")
#@gui :  30. Minimum Hue  = float(0,0,20)
#@gui :  31. Maximum Hue  = float(5,0,20)
#@gui :  32. Minimum Saturation  = float(0,0,20)
#@gui :  33. Maximum Saturation  = float(3,0,20)
#@gui :  34. Minimum Value  = float(0.5,0,20)
#@gui :  35. Maximum Value  = float(2,0,20)
#@gui :  note  = note("<small>Set these to their minimum values for randomisation</small>")
#@gui :  36. Hue Offset  = float(-180, -180, 180)
#@gui :  37. Saturation Offset  = float(0, -1.01, 1)
#@gui :  38. Value Offset  = float(0,-20.01,20)
#@gui :  sep  = separator(),
#@gui :  -4. Normalise  = bool(1)
#@gui :  -3. Normalisation Channel(s)  = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  sep  = separator(),
#@gui :  -2. Overall Channel(s)  = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui :  -1. Value Action  = choice("None","Cut","Normalize")
ultrawarp4plus:
hue_min={$30}
hue_max={$31}
sat_min={$32}
sat_max={$33}
val_min={$34}
val_max={$35}
j={min($hue_min,$hue_max)+(u*(max($hue_min,$hue_max)-min($hue_min,$hue_max)))}
k={min($sat_min,$sat_max)+(u*(max($sat_min,$sat_max)-min($sat_min,$sat_max)))}
l={min($val_min,$val_max)+(u*(max($val_min,$val_max)-min($val_min,$val_max)))}
if $1
if $2 ch=0 else ch=2 fi
ac  "rr={round(u*255)}
gg={round(u*255)}
bb={round(u*255)}
fx_plasma 0.5,0,{$2},1,1,{$rr},{$gg},{$bb}
if $3 to_rgba else ch=2 to_rgb fi",{$ch} fi
fx_gaussian_blur {$7},0,0,1,2,0,0
n_min=$14
n_max=$15
if $n_min>$n_max
n_min=$n_min + $n_max
n_max=$n_min - $n_max
n_min=$n_min - $n_max
fi
noise_exp={max(0,$n_min+(u*($n_max-$n_min)))}
n_amt={(2^($noise_exp-3))*$noise_exp}
if $4 fx_segment_watershed {$5},{$6},0,2,0 fi
if $8
p_min={$9}
p_max={$10}
h_min={$11}
h_max={$12}
if $p_min>$p_max
p_min=$p_min + $p_max
p_max=$p_min - $p_max
p_min=$p_min - $p_max
fi
if $h_min>$h_max
h_min=$h_min + $h_max
h_max=$h_min - $h_max
h_min=$h_min - $h_max
fi
ac "noise "$n_amt",$13",$16,1
fx_quadtree 0,{max(2,round($p_min+(u*($p_max-$p_min))))},{max(0,round($h_min+(u*($h_max-$h_min))))},0,3,1.5,1,1,0
fi
ac "noise "$n_amt",$13",$16,1
f={$17}
i={$18}
m={$19}
s={$27}
v={$28}
repeat max(0,$f)
if $20
scale_x=w/10
a={((2^($18-5))*$18)*(u-0.5)*$scale_x*0.025}
else
scale_x=1
a={((2^($18-5))*$18)*(u-0.5)}
fi
if $22
scale_y=h/10
b={((2^($18-5))*$18)*(u-0.5)*$scale_y*0.025}
else
scale_y=1
b={((2^($18-5))*$18)*(u-0.5)}
fi
c=(u-0.5)*$m*sign($m)*$scale_x
d=(u-0.5)*$m*sign($m)*$scale_y
g={round((u*33.98)-0.49)}
h={u(-100,100)}
o={u(-100,100)}
if $22==1
e=0
elif $22==2
e=1
else
e={round(u)}
fi
if $23==0
f={round((u*2.98)-0.49)}
elif $23==1
f={round((u*2.98)+0.51)}
else
f={($23)-2}
fi
ac  "_fx_warp_by_intensity "{$a}","{$b}","{$c}","{$d}","{$e}",0,"{$f}"",{$24},0
if $25
nn={round(u)}
if $nn
if $26==0
nch={round((u*33.98)-0.49)}
ac "negate",{$nch}
else
ac "negate",{$26}
fi
fi
fi
fx_adjust_colors 0,0,{$h},{$o},0,0
if $29
ac "n 0,255",3
fi
done
if $36==-180
hh=((u-0.5)*360)
else
hh={$36}
fi
if $37==-8.01
ss=((u-0.5)*2)
else
ss={$37}
fi
if $38==-20.01
vv=((u-0.5)*2)
else
vv={$38}
fi
fx_mix_hsv {$j},{$hh},0,{$k},{$ss},0,{$l},{$vv},0,0,2,0
if $-2
ac "n 0,255",{$-1}
fi
fx_ultrawarp4plus:
repeat $! l[$>]
ac "ultrawarp4plus ${2--3}",$-2,$-1
fx_adjust_colors 0,0,0,{(u-0.5)*200},0,0
done done
fx_ultrawarp4plus_preview:
variablelist=${1--1}
fx_ultrawarp4plus $variablelist

#@gui Rays from Image : fx_rays_from_image, fx_rays_from_image(1)
#@gui : note = note("<small>Creates rays from the colours of an image. If the power is 5, the lines radiate outwards as if the image is being exploded from the chosen point.</small>")
#@gui : sep  = separator()
#@gui : Power = float(5,0,10)
#@gui : Centre = point(50,50,0,1,255,255,255,175)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value Action = choice("None","Cut","Normalize")

rays_from_image:

fx_transform_polar 0,$2,$3,"(R-a)*(4^(($1)-5))*$1/5","a",3

fx_rays_from_image:

repeat max(0,l)
  ac[$>] "rays_from_image $*",$-2,$-1
done

#@gui Shifter : fx_shifter, fx_shifter_preview(1)
#@gui : note = note("<small>Shifts portions of an image using warp maps made from difference blending of rectangles.</small>")
#@gui : sep  = separator()
#@gui : Recompute = button(0)
#@gui : Channels = choice("Correlated","RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : Alpha = bool(1)
#@gui : X Amplitude = float(1,0,10)
#@gui : X Iterations = int(20,0,400)
#@gui : Y Amplitude = float(1,0,10)
#@gui : Y Iterations = int(20,0,400)
#@gui : Matrix Warp Multiplier = float(1,0,5)
#@gui : Matrix Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : Warp Boundary = choice(5,"Random","Random [non-transparent]","Transparent","Nearest","Periodic", "Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
_fx_shifter:
repeat $! l[$>]
to_rgba split_opacity
if $2 a c fi
l[0]
if $1
csswap 0,{$1-1} s c
fi
repeat $! l[$>]
100%,100%,1,3 [1] fc[1,2] 0
rectexture[1] $4,0,$7,$8,2,0
rectexture[2] $6,0,$7,$8,2,0
to_gray[^0]
f[1] "$3*510*(0.25-abs(0.5-i/255))"
f[2] "$5*510*(0.25-abs(0.5-i/255))"
a[^0] c
if $9==0
f={u(0,3)}
elif $9==1
f={u(0,2)+1}
else
f={($9)-2}
fi
warp.. .,1,0,{int($f)}
rm.
done done
done
a c
if $1
csswap {$1-1},0
fi
done done

fx_shifter:
_fx_shifter ${2-10}
fx_shifter_preview:
gui_split_preview "fx_shifter $*",${-3--1}

#@gui Spiral Matrix Transformation : fx_jr_spiral_transform, fx_jr_spiral_transform_preview(1)
#@gui : note = note("<small>Transforms images into rectangular spirals. The main use is to run effects on the transformed images and then use a corresponding reverse transformation for unusual effects. Preview may be highly-inaccurate. Based off an unfinished script from the <a href="https://forums.getpaint.net/topic/30276-glitch-effect-plugin-polyglitch-v14b/">PolyGlitch Paint.NET plugin</a>.</small>\n\n Details of the Spiral Matrix Transform's mathematics can be found in this thread - <i><a href="https://discuss.pixls.us/t/challenge-spiralbw-as-a-parametric-function-x-t-y-t/12779">Challenge: Spiralbw as a parametric function &#40;x&#40;t&#41;,y&#40;t&#41;&#41;</a></i>.")
#@gui : sep  = separator()
#@gui : Mode = choice("Spiral","Inverse Spiral")
#@gui : Spiral Rotation = choice("Clockwise","Anticlockwise")
#@gui : Direction = choice("Down","Up")
#@gui : Starting Axis = choice("X","Y")
#@gui : Spiral Start = choice("Outside","Inside")
#@gui : sep  = separator(), note = note("<small>Author: Reptorian, <i><a href="http://bit.ly/2CmhX65">David Tschumperl&#233;</a></i>.,Joan Rake and Garagecoder. Latest Update: <i>2019/5/28</i>.</small>")
fx_jr_spiral_transform:
repeat $! l[$>]
if $4 permute yxzc fi
spiralbw {[w,h]},0
if $2 mirror[1] x fi
if $3 mirror[1] y fi
if $5 f[1] "iM-i" fi
[0]
if $1
f[2] "I(#0,i0#1%w,floor(i0#1/w),0)=I"
else
f[0] "I(i#1%w,floor(i#1/w))"
fi
k[0]
if $4 permute yxzc fi
done done
fx_jr_spiral_transform_preview:
fx_jr_spiral_transform $*
#@gui _<b>Contours</b>

#@gui Gradient Norm [JR's Mod] : fx_jr_gradient_norm, fx_jr_gradient_norm_preview(1)
#@gui : Smoothness = float(0,0,10)
#@gui : Contrast = float(0.45,0,1.5)
#@gui : Min Threshold = float(40,0,100)
#@gui : Max Threshold = float(60,0,100)
#@gui : Negative = bool(0)
#@gui : Include Orientation = choice("Off","On","On &#40;extrapolate if negative&#41;")
#@gui : Scale X = float(1,0,5)
#@gui : Scale Y = float(1,0,5)
#@gui : Interpolation = choice(2,"Nearest","Average","Bilinear","Bicubic")
#@gui : Alpha = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
#@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")

jr_dir2rgb :
v - channels 0,1 repeat $! l[$>] nm={0,n}
s c complex2polar round.. 0.001
*. {180/pi} %. 360 100%,100%,1,1,1 mv... $!
c 0,360 if im!=iM n. 0,1 else f. 1  fi
a c hsv2rgb
nm $nm done done v +

jr_gradient_norm :
b $1 gradient_norm replace_inf 1 replace_nan 0 ^ $2
c $3%,$4%
if $5 negate fi
n 0,255

fx_jr_gradient_norm :
repeat $! l[$>]
if $9==3
inter=5
else
inter={1+$9}
fi
if $7!=1||$8!=1
ww={w}
hh={h}
shift -0.5,-0.5,0,0,1
r {max(1,$7*w)},{max(1,$8*h)},100%,100%,$inter
fi
if $6
+l luminance gradient append c
blur $1 orientation +jr_dir2rgb
done rm[1]
if $5
l[1]
rgb2hsv8 100%,100%,1,1 f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0]  a c
if $6==2
fx_solidify_td 100,0,10,2,0
fi
rgb2hsv8 f "[i0,i1,255]" hsv82rgb
done
fi
fi
jr_gradient_norm[0] ${1-5}
if $7!=1||$8!=1
r $ww,$hh,100%,100%,$inter
fi
if $6 blend multiply fi
if $6==1 c 0,255 f "I==[255,255,255]?[0,0,0]:I" fi
if $10 rgb2hsv8 100%,100%,1,1 if $6 [1] f[2] "j(#0,0,0,0,1)" f[0] "[i0,255,i2]" fi f[1] "j(#0,0,0,0,2)" f[0] "[i0,i1,255]" hsv82rgb[0] if $6 blend[1,2] multiply fi a c fi
done done
fx_jr_gradient_norm_preview :
gui_split_preview "fx_jr_gradient_norm $*",${-3--1}

#@gui _<b>Colors</b>

#@gui Frequency Representation : fx_frequency_representation, fx_frequency_representation_preview(1)
#@gui : note = note("<small>Changes values based on relative frequencies of those values in a histogram of image intensity.</small>")
#@gui : Iterations = int(3,1,20)
#@gui : Clusters = int(256,2,1024)
#@gui : Split Channels = bool(0)
#@gui : Blur = float(40,0,100)
#@gui : Colour Space = choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
fx_frequency_representation:
repeat $! l[$>]
to_rgba split_opacity rv
csswap[^0] 0,$5
if $3 s. c fi
repeat $!-1 l[{$>+1}]
s z
repeat $! l[$>]
repeat $1
+histogram $2 b. {($4/100)^2*100}%
f[^-1] "i(#-1,i,y,z,c,1,2)"
k[^-1]
n 0,{$2-1}
done
done done
a z
done done
n[^0] 0,255
a[^0] c csswap[^0] $5,0 rv a c
done done
fx_frequency_representation_preview:
fx_frequency_representation $*

#@gui Satellite : fx_satellite, fx_satellite_preview(1)
#@gui : note = note("Expresses luminance of images using <a href="https://www.ospo.noaa.gov/Organization/FAQ/enhancements.html">image enhancement colour schemes</a> which are used in NOAA satellite weather products.")
#@gui : sep = separator()
#@gui : Colour Scheme = choice("Aviation","Dvorak","Funktop","JSL2","Shortwave IR2 &#40;Standard and Tropical&#41;","Shortwave IR2 &#40;Fire&#41;","Shortwave IR2 &#40;Summer Fire&#41;","Shortwave IR2 &#40;Winter Fire&#41;","Rainbow &#40;Old&#41;","Rainbow &#40;New&#41;","Water Vapour","Water Vapour &#40;Blue&#41;","IR Window &#40;White-White&#41","IR Window &#40;White-Brown&#41","IR Window &#40;White-Black&#41","IR Window &#40;Blue-White&#41","IR Window &#40;Blue-Brown&#41","IR Window &#40;Blue-Black&#41")
#@gui : Gamma Bend = float(0,-3,3)
#@gui : note = note("<small>Cut range from original image</small>")
#@gui : Cut Lower Threshold = float(0,0,100)
#@gui : Cut Higher Threshold = float(100,0,100)
#@gui : note = note("<small>Apply range of colour scheme to image</small>")
#@gui : Normalise = bool(1)
#@gui : Normalise Lower Threshold = float(0,0,255)
#@gui : Normalise Higher Threshold = float(255,0,255)
#@gui : To sRGB = bool(0)
#@gui : Preview Colour Scheme = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
fx_satellite :
c 0,255
luminance
f "255*((i/255)^(2^($2^2)))"
cut {$3}%,{$4}% if $5 n $6,$7 fi
to_rgb
255,1,1,3 f. "x"
# use '{ print("((i>="$1")&&(i<"$2+1"))?["$7","$5","$3"]+(i-"$1")*["($8-$7)","($6-$5)","($4-$3)"]/"($2-$1)":") }' in awk (including apostrophes) to get values from text files from the linked NOAA site for all colour schemes apart from the IR window schemes, which can be found here: https://discuss.pixls.us/t/glitch-art-filters/2159/197
l.
if $1==0 # Aviation
f "((i>=0)&&(i<48))?[0,0,0]+(i-0)*[0,0,0]/47:
((i>=48)&&(i<52))?[8,8,8]+(i-48)*[0,0,0]/3:
((i>=52)&&(i<56))?[20,20,20]+(i-52)*[0,0,0]/3:
((i>=56)&&(i<60))?[28,28,28]+(i-56)*[0,0,0]/3:
((i>=60)&&(i<64))?[40,40,40]+(i-60)*[0,0,0]/3:
((i>=64)&&(i<68))?[52,52,52]+(i-64)*[0,0,0]/3:
((i>=68)&&(i<72))?[60,60,60]+(i-68)*[0,0,0]/3:
((i>=72)&&(i<76))?[72,72,72]+(i-72)*[0,0,0]/3:
((i>=76)&&(i<80))?[84,84,84]+(i-76)*[0,0,0]/3:
((i>=80)&&(i<84))?[92,92,92]+(i-80)*[0,0,0]/3:
((i>=84)&&(i<88))?[104,104,104]+(i-84)*[0,0,0]/3:
((i>=88)&&(i<92))?[112,112,112]+(i-88)*[0,0,0]/3:
((i>=92)&&(i<96))?[124,124,124]+(i-92)*[0,0,0]/3:
((i>=96)&&(i<100))?[136,136,136]+(i-96)*[0,0,0]/3:
((i>=100)&&(i<104))?[144,144,144]+(i-100)*[0,0,0]/3:
((i>=104)&&(i<108))?[156,156,156]+(i-104)*[0,0,0]/3:
((i>=108)&&(i<112))?[168,168,168]+(i-108)*[0,0,0]/3:
((i>=112)&&(i<116))?[176,176,176]+(i-112)*[0,0,0]/3:
((i>=116)&&(i<120))?[188,188,188]+(i-116)*[0,0,0]/3:
((i>=120)&&(i<124))?[196,196,196]+(i-120)*[0,0,0]/3:
((i>=124)&&(i<128))?[208,208,208]+(i-124)*[0,0,0]/3:
((i>=128)&&(i<132))?[220,220,220]+(i-128)*[0,0,0]/3:
((i>=132)&&(i<136))?[228,228,228]+(i-132)*[0,0,0]/3:
((i>=136)&&(i<140))?[240,240,240]+(i-136)*[0,0,0]/3:
((i>=140)&&(i<144))?[252,252,252]+(i-140)*[0,0,0]/3:
((i>=144)&&(i<148))?[0,156,244]+(i-144)*[0,0,0]/3:
((i>=148)&&(i<152))?[0,152,236]+(i-148)*[0,0,0]/3:
((i>=152)&&(i<156))?[0,148,228]+(i-152)*[0,0,0]/3:
((i>=156)&&(i<160))?[0,144,220]+(i-156)*[0,0,0]/3:
((i>=160)&&(i<164))?[0,140,212]+(i-160)*[0,0,0]/3:
((i>=164)&&(i<168))?[0,136,208]+(i-164)*[0,0,0]/3:
((i>=168)&&(i<172))?[0,132,200]+(i-168)*[0,0,0]/3:
((i>=172)&&(i<176))?[0,128,192]+(i-172)*[0,0,0]/3:
((i>=176)&&(i<180))?[0,124,184]+(i-176)*[0,0,0]/3:
((i>=180)&&(i<184))?[0,120,176]+(i-180)*[0,0,0]/3:
((i>=184)&&(i<188))?[160,160,0]+(i-184)*[0,0,0]/3:
((i>=188)&&(i<192))?[188,188,0]+(i-188)*[0,0,0]/3:
((i>=192)&&(i<196))?[220,220,0]+(i-192)*[0,0,0]/3:
((i>=196)&&(i<200))?[248,248,0]+(i-196)*[0,0,0]/3:
((i>=200)&&(i<204))?[252,180,0]+(i-200)*[0,0,0]/3:
((i>=204)&&(i<208))?[232,160,0]+(i-204)*[0,0,0]/3:
((i>=208)&&(i<212))?[216,140,0]+(i-208)*[0,0,0]/3:
((i>=212)&&(i<216))?[196,120,0]+(i-212)*[0,0,0]/3:
((i>=216)&&(i<220))?[232,0,0]+(i-216)*[0,0,0]/3:
((i>=220)&&(i<224))?[248,0,0]+(i-220)*[0,0,0]/3:
((i>=224)&&(i<250))?[88,88,88]+(i-224)*[0,0,0]/25:
((i>=250)&&(i<256))?[255,255,255]+(i-250)*[0,0,0]/5"
elif $1==1 # Dvorak
f "((i>=0)&&(i<59))?[0,0,0]+(i-0)*[0,0,0]/58:
((i>=59)&&(i<68))?[6,6,6]+(i-59)*[56,56,56]/8:
((i>=68)&&(i<97))?[75,75,75]+(i-68)*[180,180,180]/28:
((i>=97)&&(i<175))?[112,112,112]+(i-97)*[92,92,92]/77:
((i>=175)&&(i<188))?[64,64,64]+(i-175)*[0,0,0]/12:
((i>=188)&&(i<199))?[112,112,112]+(i-188)*[0,0,0]/10:
((i>=199)&&(i<209))?[160,160,160]+(i-199)*[0,0,0]/9:
((i>=209)&&(i<215))?[0,0,0]+(i-209)*[0,0,0]/5:
((i>=215)&&(i<221))?[255,255,255]+(i-215)*[0,0,0]/5:
((i>=221)&&(i<226))?[136,136,136]+(i-221)*[0,0,0]/4:
((i>=226)&&(i<256))?[88,88,88]+(i-226)*[0,0,0]/29"
elif $1==2 # Funktop
f "((i>=0)&&(i<44))?[0,0,0]+(i-0)*[0,0,0]/43:
((i>=44)&&(i<152))?[20,20,20]+(i-44)*[196,196,196]/107:
((i>=152)&&(i<184))?[100,100,0]+(i-152)*[148,148,0]/31:
((i>=184)&&(i<204))?[0,0,120]+(i-184)*[0,252,132]/19:
((i>=204)&&(i<216))?[84,0,0]+(i-204)*[168,0,0]/11:
((i>=216)&&(i<224))?[252,80,80]+(i-216)*[0,60,60]/7:
((i>=224)&&(i<237))?[0,252,0]+(i-224)*[252,0,252]/12:
((i>=237)&&(i<253))?[252,252,252]+(i-237)*[0,0,0]/15:
((i>=253)&&(i<256))?[255,255,255]+(i-253)*[0,0,0]/2"
elif $1==3 # JSL2
f "((i>=0)&&(i<4))?[0,0,0]+(i-0)*[0,0,0]/3:
((i>=4)&&(i<8))?[28,0,28]+(i-4)*[0,0,0]/3:
((i>=8)&&(i<12))?[60,0,60]+(i-8)*[0,0,0]/3:
((i>=12)&&(i<16))?[92,0,92]+(i-12)*[0,0,0]/3:
((i>=16)&&(i<20))?[124,0,124]+(i-16)*[0,0,0]/3:
((i>=20)&&(i<24))?[156,0,156]+(i-20)*[0,0,0]/3:
((i>=24)&&(i<28))?[188,0,188]+(i-24)*[0,0,0]/3:
((i>=28)&&(i<32))?[220,0,220]+(i-28)*[0,0,0]/3:
((i>=32)&&(i<36))?[252,0,252]+(i-32)*[0,0,0]/3:
((i>=36)&&(i<40))?[224,0,236]+(i-36)*[0,0,0]/3:
((i>=40)&&(i<44))?[196,0,220]+(i-40)*[0,0,0]/3:
((i>=44)&&(i<48))?[168,0,208]+(i-44)*[0,0,0]/3:
((i>=48)&&(i<52))?[140,0,192]+(i-48)*[0,0,0]/3:
((i>=52)&&(i<56))?[112,0,180]+(i-52)*[0,0,0]/3:
((i>=56)&&(i<60))?[84,0,164]+(i-56)*[0,0,0]/3:
((i>=60)&&(i<64))?[56,0,152]+(i-60)*[0,0,0]/3:
((i>=64)&&(i<68))?[28,0,136]+(i-64)*[0,0,0]/3:
((i>=68)&&(i<72))?[0,0,124]+(i-68)*[0,0,0]/3:
((i>=72)&&(i<76))?[0,28,136]+(i-72)*[0,0,0]/3:
((i>=76)&&(i<80))?[0,56,152]+(i-76)*[0,0,0]/3:
((i>=80)&&(i<84))?[0,84,164]+(i-80)*[0,0,0]/3:
((i>=84)&&(i<88))?[0,112,180]+(i-84)*[0,0,0]/3:
((i>=88)&&(i<92))?[0,140,192]+(i-88)*[0,0,0]/3:
((i>=92)&&(i<96))?[0,168,208]+(i-92)*[0,0,0]/3:
((i>=96)&&(i<100))?[0,196,220]+(i-96)*[0,0,0]/3:
((i>=100)&&(i<104))?[0,224,236]+(i-100)*[0,0,0]/3:
((i>=104)&&(i<108))?[0,252,252]+(i-104)*[0,0,0]/3:
((i>=108)&&(i<112))?[0,236,224]+(i-108)*[0,0,0]/3:
((i>=112)&&(i<116))?[0,220,196]+(i-112)*[0,0,0]/3:
((i>=116)&&(i<132))?[92,92,92]+(i-116)*[12,12,12]/15:
((i>=132)&&(i<144))?[112,112,112]+(i-132)*[8,8,8]/11:
((i>=144)&&(i<156))?[128,128,128]+(i-144)*[8,8,8]/11:
((i>=156)&&(i<168))?[144,144,144]+(i-156)*[8,8,8]/11:
((i>=168)&&(i<180))?[160,160,160]+(i-168)*[8,8,8]/11:
((i>=180)&&(i<184))?[176,176,176]+(i-180)*[0,0,0]/3:
((i>=184)&&(i<188))?[184,184,184]+(i-184)*[0,0,0]/3:
((i>=188)&&(i<192))?[192,192,192]+(i-188)*[0,0,0]/3:
((i>=192)&&(i<196))?[200,200,200]+(i-192)*[0,0,0]/3:
((i>=196)&&(i<200))?[208,208,208]+(i-196)*[0,0,0]/3:
((i>=200)&&(i<202))?[216,216,216]+(i-200)*[0,0,0]/1:
((i>=202)&&(i<215))?[60,0,0]+(i-202)*[195,60,60]/12:
((i>=215)&&(i<226))?[255,71,71]+(i-215)*[0,119,119]/10:
((i>=226)&&(i<246))?[101,0,101]+(i-226)*[121,201,121]/19:
((i>=246)&&(i<256))?[0,0,0]+(i-246)*[0,0,0]/9"
elif $1==4 # Shortwave IR2 (Standard and Tropical)
f "((i>=0)&&(i<2))?[0,0,0]+(i-0)*[0,0,0]/1:
((i>=2)&&(i<26))?[235,0,0]+(i-2)*[-235,0,0]/23:
((i>=26)&&(i<51))?[0,0,0]+(i-26)*[0,0,0]/24:
((i>=51)&&(i<62))?[12,12,12]+(i-51)*[3,3,3]/10:
((i>=62)&&(i<68))?[23,23,23]+(i-62)*[38,38,38]/5:
((i>=68)&&(i<69))?[75,75,75]+(i-68)*[0,0,0]/0:
((i>=69)&&(i<81))?[76,76,76]+(i-69)*[84,84,84]/11:
((i>=81)&&(i<111))?[161,161,161]+(i-81)*[79,79,79]/29:
((i>=111)&&(i<131))?[226,226,226]+(i-111)*[14,14,14]/19:
((i>=131)&&(i<171))?[160,255,255]+(i-131)*[-40,-135,-135]/39:
((i>=171)&&(i<256))?[50,50,150]+(i-171)*[50,50,70]/84"
elif $1==5 # Shortwave IR2 (Fire)
f "((i>=0)&&(i<151))?[255,255,255]+(i-0)*[-255,-255,-255]/150:
((i>=151)&&(i<256))?[0,0,0]+(i-151)*[0,0,0]/104"
elif $1==6 # Shortwave IR2 (Summer Fire)
f "((i>=0)&&(i<13))?[255,255,255]+(i-0)*[-24,-24,-24]/12:
((i>=13)&&(i<126))?[228,228,228]+(i-13)*[-228,-228,-228]/112:
((i>=126)&&(i<256))?[0,0,0]+(i-126)*[0,0,0]/129"
elif $1==7 # Shortwave IR2 (Winter Fire)
f "((i>=0)&&(i<42))?[255,255,255]+(i-0)*[0,0,0]/41:
((i>=42)&&(i<191))?[253,253,253]+(i-42)*[-253,-253,-253]/148:
((i>=191)&&(i<256))?[0,0,0]+(i-191)*[0,0,0]/64"
elif $1==8 # Rainbow (Old)
f "((i>=0)&&(i<4))?[0,0,0]+(i-0)*[0,0,0]/3:
((i>=4)&&(i<8))?[28,0,28]+(i-4)*[0,0,0]/3:
((i>=8)&&(i<12))?[60,0,60]+(i-8)*[0,0,0]/3:
((i>=12)&&(i<16))?[92,0,92]+(i-12)*[0,0,0]/3:
((i>=16)&&(i<20))?[124,0,124]+(i-16)*[0,0,0]/3:
((i>=20)&&(i<24))?[156,0,156]+(i-20)*[0,0,0]/3:
((i>=24)&&(i<28))?[188,0,188]+(i-24)*[0,0,0]/3:
((i>=28)&&(i<32))?[220,0,220]+(i-28)*[0,0,0]/3:
((i>=32)&&(i<36))?[252,0,252]+(i-32)*[0,0,0]/3:
((i>=36)&&(i<40))?[224,0,236]+(i-36)*[0,0,0]/3:
((i>=40)&&(i<44))?[196,0,220]+(i-40)*[0,0,0]/3:
((i>=44)&&(i<48))?[168,0,208]+(i-44)*[0,0,0]/3:
((i>=48)&&(i<52))?[140,0,192]+(i-48)*[0,0,0]/3:
((i>=52)&&(i<56))?[112,0,180]+(i-52)*[0,0,0]/3:
((i>=56)&&(i<60))?[84,0,164]+(i-56)*[0,0,0]/3:
((i>=60)&&(i<64))?[56,0,152]+(i-60)*[0,0,0]/3:
((i>=64)&&(i<68))?[28,0,136]+(i-64)*[0,0,0]/3:
((i>=68)&&(i<72))?[0,0,124]+(i-68)*[0,0,0]/3:
((i>=72)&&(i<76))?[0,28,136]+(i-72)*[0,0,0]/3:
((i>=76)&&(i<80))?[0,56,152]+(i-76)*[0,0,0]/3:
((i>=80)&&(i<84))?[0,84,164]+(i-80)*[0,0,0]/3:
((i>=84)&&(i<88))?[0,112,180]+(i-84)*[0,0,0]/3:
((i>=88)&&(i<92))?[0,140,192]+(i-88)*[0,0,0]/3:
((i>=92)&&(i<96))?[0,168,208]+(i-92)*[0,0,0]/3:
((i>=96)&&(i<100))?[0,196,220]+(i-96)*[0,0,0]/3:
((i>=100)&&(i<104))?[0,224,236]+(i-100)*[0,0,0]/3:
((i>=104)&&(i<108))?[0,252,252]+(i-104)*[0,0,0]/3:
((i>=108)&&(i<112))?[0,236,224]+(i-108)*[0,0,0]/3:
((i>=112)&&(i<116))?[0,220,196]+(i-112)*[0,0,0]/3:
((i>=116)&&(i<120))?[0,208,168]+(i-116)*[0,0,0]/3:
((i>=120)&&(i<124))?[0,192,140]+(i-120)*[0,0,0]/3:
((i>=124)&&(i<128))?[0,180,112]+(i-124)*[0,0,0]/3:
((i>=128)&&(i<132))?[0,164,84]+(i-128)*[0,0,0]/3:
((i>=132)&&(i<136))?[0,152,56]+(i-132)*[0,0,0]/3:
((i>=136)&&(i<140))?[0,136,28]+(i-136)*[0,0,0]/3:
((i>=140)&&(i<144))?[0,124,0]+(i-140)*[0,0,0]/3:
((i>=144)&&(i<148))?[28,136,0]+(i-144)*[0,0,0]/3:
((i>=148)&&(i<152))?[56,152,0]+(i-148)*[0,0,0]/3:
((i>=152)&&(i<156))?[84,164,0]+(i-152)*[0,0,0]/3:
((i>=156)&&(i<160))?[112,180,0]+(i-156)*[0,0,0]/3:
((i>=160)&&(i<164))?[140,192,0]+(i-160)*[0,0,0]/3:
((i>=164)&&(i<168))?[168,208,0]+(i-164)*[0,0,0]/3:
((i>=168)&&(i<172))?[196,220,0]+(i-168)*[0,0,0]/3:
((i>=172)&&(i<176))?[224,236,0]+(i-172)*[0,0,0]/3:
((i>=176)&&(i<180))?[252,252,0]+(i-176)*[0,0,0]/3:
((i>=180)&&(i<184))?[236,224,0]+(i-180)*[0,0,0]/3:
((i>=184)&&(i<188))?[220,196,0]+(i-184)*[0,0,0]/3:
((i>=188)&&(i<192))?[208,168,0]+(i-188)*[0,0,0]/3:
((i>=192)&&(i<196))?[192,140,0]+(i-192)*[0,0,0]/3:
((i>=196)&&(i<200))?[180,112,0]+(i-196)*[0,0,0]/3:
((i>=200)&&(i<204))?[164,84,0]+(i-200)*[0,0,0]/3:
((i>=204)&&(i<208))?[152,56,0]+(i-204)*[0,0,0]/3:
((i>=208)&&(i<212))?[136,28,0]+(i-208)*[0,0,0]/3:
((i>=212)&&(i<216))?[124,0,0]+(i-212)*[0,0,0]/3:
((i>=216)&&(i<220))?[160,0,0]+(i-216)*[0,0,0]/3:
((i>=220)&&(i<224))?[192,0,0]+(i-220)*[0,0,0]/3:
((i>=224)&&(i<228))?[216,0,0]+(i-224)*[0,0,0]/3:
((i>=228)&&(i<232))?[252,0,0]+(i-228)*[0,0,0]/3:
((i>=232)&&(i<236))?[252,252,252]+(i-232)*[0,0,0]/3:
((i>=236)&&(i<256))?[0,0,0]+(i-236)*[255,255,255]/19"
elif $1==9 # Rainbow (New)
f "((i>=0)&&(i<61))?[0,0,0]+(i-0)*[120,120,120]/60:
((i>=61)&&(i<91))?[3,3,3]+(i-61)*[87,87,87]/29:
((i>=91)&&(i<101))?[91,91,91]+(i-91)*[9,9,9]/9:
((i>=101)&&(i<145))?[103,103,103]+(i-101)*[145,145,145]/43:
((i>=145)&&(i<155))?[250,250,250]+(i-145)*[-59,-250,5]/9:
((i>=155)&&(i<171))?[191,0,255]+(i-155)*[-191,0,0]/15:
((i>=171)&&(i<191))?[0,12,242]+(i-171)*[0,243,-242]/19:
((i>=191)&&(i<201))?[25,255,0]+(i-191)*[230,0,0]/9:
((i>=201)&&(i<211))?[255,229,0]+(i-201)*[0,-229,0]/9:
((i>=211)&&(i<221))?[229,0,0]+(i-211)*[-229,0,0]/9:
((i>=221)&&(i<246))?[20,20,20]+(i-221)*[235,235,235]/24:
((i>=246)&&(i<256))?[255,255,255]+(i-246)*[0,0,0]/9"
elif $1==10 # Water Vapour
f "((i>=0)&&(i<130))?[0,0,0]+(i-0)*[0,0,0]/129:
((i>=130)&&(i<165))?[255,160,90]+(i-130)*[-255,-160,-90]/34:
((i>=165)&&(i<183))?[0,0,0]+(i-165)*[255,255,255]/17:
((i>=183)&&(i<198))?[255,255,255]+(i-183)*[-255,-175,-125]/14:
((i>=198)&&(i<206))?[0,80,130]+(i-198)*[0,70,20]/7:
((i>=206)&&(i<214))?[160,150,0]+(i-206)*[90,-100,0]/7:
((i>=214)&&(i<222))?[150,0,220]+(i-214)*[100,0,0]/7:
((i>=222)&&(i<230))?[0,0,226]+(i-222)*[0,0,-92]/7:
((i>=230)&&(i<256))?[255,255,255]+(i-230)*[0,0,0]/25"
elif $1==11 # Water Vapour (Blue)
f "((i>=0)&&(i<110))?[0,0,0]+(i-0)*[0,0,0]/109:
((i>=110)&&(i<142))?[255,0,0]+(i-110)*[0,251,3]/31:
((i>=142)&&(i<172))?[247,243,8]+(i-142)*[-244,-243,158]/29:
((i>=172)&&(i<192))?[15,12,170]+(i-172)*[240,243,85]/19:
((i>=192)&&(i<219))?[246,250,246]+(i-192)*[-245,-143,-245]/26:
((i>=219)&&(i<255))?[1,110,7]+(i-219)*[3,137,241]/35:
((i>=255)&&(i<256))?[255,255,255]"
elif $1==12 # IR Window (White-White)
f "((i>=0)&&(i<154))?[0,0,0]+(i-0)*[255,255,255]/153:
((i>=154)&&(i<174))?[0,255,255]+(i-154)*[0,-255,-140]/19:
((i>=174)&&(i<187))?[0,0,115]+(i-174)*[0,255,-115]/12:
((i>=187)&&(i<197))?[0,255,0]+(i-187)*[255,0,0]/9:
((i>=197)&&(i<207))?[255,255,0]+(i-197)*[0,-255,0]/9:
((i>=207)&&(i<216))?[255,0,0]+(i-207)*[-255,0,0]/8:
((i>=216)&&(i<225))?[0,0,0]+(i-216)*[230,230,230]/8:
((i>=225)&&(i<237))?[242,114,195]+(i-225)*[-115,-114,-68]/11:
((i>=237)&&(i<256))?[255,255,0]+(i-237)*[0,0,255]/18"
elif $1==13 # IR Window (White-Brown)
f "((i>=0)&&(i<154))?[0,0,0]+(i-0)*[255,255,255]/153:
((i>=154)&&(i<174))?[0,255,255]+(i-154)*[0,-255,-140]/19:
((i>=174)&&(i<187))?[0,0,115]+(i-174)*[0,255,-115]/12:
((i>=187)&&(i<197))?[0,255,0]+(i-187)*[255,0,0]/9:
((i>=197)&&(i<207))?[255,255,0]+(i-197)*[0,-255,0]/9:
((i>=207)&&(i<216))?[255,0,0]+(i-207)*[-255,0,0]/8:
((i>=216)&&(i<225))?[0,0,0]+(i-216)*[230,230,230]/8:
((i>=225)&&(i<237))?[242,114,195]+(i-225)*[-115,-114,-68]/11:
((i>=237)&&(i<255))?[255,255,0]+(i-237)*[-128,-220,35]/17:
((i>=255)&&(i<256))?[255,255,255]"
elif $1==14 # IR Window (White-Black)
f "((i>=0)&&(i<154))?[0,0,0]+(i-0)*[255,255,255]/153:
((i>=154)&&(i<174))?[0,255,255]+(i-154)*[0,-255,-140]/19:
((i>=174)&&(i<187))?[0,0,115]+(i-174)*[0,255,-115]/12:
((i>=187)&&(i<197))?[0,255,0]+(i-187)*[255,0,0]/9:
((i>=197)&&(i<207))?[255,255,0]+(i-197)*[0,-255,0]/9:
((i>=207)&&(i<216))?[255,0,0]+(i-207)*[-255,0,0]/8:
((i>=216)&&(i<225))?[0,0,0]+(i-216)*[230,230,230]/8:
((i>=225)&&(i<237))?[242,114,195]+(i-225)*[-115,-114,-68]/11:
((i>=237)&&(i<255))?[255,255,0]+(i-237)*[-255,-255,0]/17:
((i>=255)&&(i<256))?[255,255,255]"
elif $1==15 # IR Window (Blue-White)
f "((i>=0)&&(i<154))?[0,0,0]+(i-0)*[0,255,255]/153:
((i>=154)&&(i<174))?[0,255,255]+(i-154)*[0,-255,-140]/19:
((i>=174)&&(i<187))?[0,0,115]+(i-174)*[0,255,-115]/12:
((i>=187)&&(i<197))?[0,255,0]+(i-187)*[255,0,0]/9:
((i>=197)&&(i<207))?[255,255,0]+(i-197)*[0,-255,0]/9:
((i>=207)&&(i<216))?[255,0,0]+(i-207)*[-255,0,0]/8:
((i>=216)&&(i<225))?[0,0,0]+(i-216)*[230,230,230]/8:
((i>=225)&&(i<237))?[242,114,195]+(i-225)*[-115,-114,-68]/11:
((i>=237)&&(i<256))?[255,255,0]+(i-237)*[0,0,255]/18"
elif $1==16 # IR Window (Blue-Brown)
f "((i>=0)&&(i<154))?[0,0,0]+(i-0)*[0,255,255]/153:
((i>=154)&&(i<174))?[0,255,255]+(i-154)*[0,-255,-140]/19:
((i>=174)&&(i<187))?[0,0,115]+(i-174)*[0,255,-115]/12:
((i>=187)&&(i<197))?[0,255,0]+(i-187)*[255,0,0]/9:
((i>=197)&&(i<207))?[255,255,0]+(i-197)*[0,-255,0]/9:
((i>=207)&&(i<216))?[255,0,0]+(i-207)*[-255,0,0]/8:
((i>=216)&&(i<225))?[0,0,0]+(i-216)*[230,230,230]/8:
((i>=225)&&(i<237))?[242,114,195]+(i-225)*[-115,-114,-68]/11:
((i>=237)&&(i<255))?[255,255,0]+(i-237)*[-128,-220,35]/17:
((i>=255)&&(i<256))?[255,255,255]"
elif $1==17 # IR Window (Blue-Black)
f "((i>=0)&&(i<154))?[0,0,0]+(i-0)*[0,255,255]/153:
((i>=154)&&(i<174))?[0,255,255]+(i-154)*[0,-255,-140]/19:
((i>=174)&&(i<187))?[0,0,115]+(i-174)*[0,255,-115]/12:
((i>=187)&&(i<197))?[0,255,0]+(i-187)*[255,0,0]/9:
((i>=197)&&(i<207))?[255,255,0]+(i-197)*[0,-255,0]/9:
((i>=207)&&(i<216))?[255,0,0]+(i-207)*[-255,0,0]/8:
((i>=216)&&(i<225))?[0,0,0]+(i-216)*[230,230,230]/8:
((i>=225)&&(i<237))?[242,114,195]+(i-225)*[-115,-114,-68]/11:
((i>=237)&&(i<255))?[255,255,0]+(i-237)*[-255,-255,0]/17:
((i>=255)&&(i<256))?[255,255,255]"
fi
if $8 rgb2srgb fi
done
f[^-1] "I[#-1,i]"
rm.
fx_satellite_preview :
if $9
rm 256,256,1,1,"x" fx_satellite $*
else
gui_split_preview "fx_satellite $*",${-3--1}
fi

#@gui Quick Desaturate: jr_desaturate, jr_desaturate_preview(1)
#@gui : note = note("Generates greyscale images, allowing for different &#40;s&#47;&#41;RGB channel intensities before merging. A smaller counterpart to the 'Black &#38; White' filter intended for generating intensity maps.")
#@gui : Colour Space = choice("RGB","sRGB")
#@gui : Channel 1 = float(1,0,3)
#@gui : Channel 2 = float(1,0,3)
#@gui : Channel 3 = float(1,0,3)
#@gui : Normalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
jr_desaturate :
repeat $! l[$>] split_opacity l[0] to_rgb if $1 srgb2rgb fi
f "avg(i0*$2,i1*$3,i2*$4)" if $5 n 0,255 fi c 0,255
done a c done done
jr_desaturate_preview :
gui_split_preview "jr_desaturate $*",${-3--1}
#@cli rgb2ycbcrglic : convert from rgb to ycbcrglic
#see https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde
rgb2ycbcrglic :
split_opacity l[0] to_rgb
f "R=i0;G=i1;B=i2;
  [0.2988390*R+0.5868110*G+0.1143500*B,-0.168736*R-0.3312640*G+0.5000000*B+127.5,0.5000000*R-0.4186880*G-0.0813120*B+127.5]"
done a c
#@cli ycbcrglic2rgb : convert from ycbcrglic to rgb
ycbcrglic2rgb :
split_opacity l[0] to_rgb
 f "Y=i0;Cb=i1-127.5;Cr=i2-127.5;
# original GLIC implementation added 1 to each channel to correct the transformation but in G'MIC this is not necessary for some reason.
  [Y+1.402*Cr,Y-0.344136*Cb-0.714136*Cr,Y+1.772000*Cb]"
done a c

#@gui Colour Space Swap: csswap, csswap_preview()
#@gui : To RGB From = choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : From RGB To = choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Jzczhz","HCY")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
csswap:

scfrom=$1
csto=$2

if ('$scfrom'!='$csto')
list=srgb,cmy,ryb,ohta8,ohta,yes8,yes,k18,k1,lab8,lab,oklab,luv,jzazbz,yiq8,yiq,yuv8,yuv,ycbcr,ycbcrglic,ycbcrjpeg,ydbdr,xyz8,xyz,hsv8,hsv,hsl8,hsl,hsi8,hsi,lch8,lch,jzczhz,hcy

repeat $! l[$>] split_opacity l[0] to_rgb

if ('$scfrom'!='rgb')&&('$scfrom'!='0')
if isnum($scfrom)
scfrom=${arg\ $scfrom,$list}
else
strlowercase $scfrom
scfrom=${}
fi
m "sc: comm="$scfrom" u $comm{/2rgb}"
${"-sc"}
um sc
fi

if ('$csto'!='rgb')&&('$csto'!='0')
if isnum($csto)
csto=${arg\ $csto,$list}
else
strlowercase $csto
csto=${}
fi
m "cs: comm="$csto" u {/rgb2}$comm"
${"-cs"}
um cs
fi

to_rgb done a c done done
fi
csswap_preview :
gui_split_preview "csswap $*",${-3--1}

#@gui CubeHelix: fx_cubehelix, fx_cubehelix_preview(1)
#@gui : note = note("<small>Implements and extends <a href="https://www.mrao.cam.ac.uk/~dag/CUBEHELIX/">the CubeHelix family of colour schemes</a>, allowing for interpolation between two colours as well as scaling the helix dimensions for each individual channel based on those colours.</small>")
#@gui : Pre-Greyscale = choice(1,"Off","Luminance","sRGB Mean")
#@gui : Min Threshold = float(0,0,100)
#@gui : Max Threshold = float(100,0,100)
#@gui : Pre-Normalise = bool(0)
#@gui : Start Colour = color(0,0,0)
#@gui : End Colour = color(255,255,255)
#@gui : sep = separator()
#@gui : Start Hue = float(1,0,3)
#@gui : Rotations = float(-1.5,-20,20)
#@gui : Rotation Bend = float(0,-3,3)
#@gui : sep = separator()
#@gui : Saturation Bend = float(0,-3,3)
#@gui : Saturation Start = float(1,0,5)
#@gui : Saturation End = float(1,0,5)
#@gui : Gamma Bend = float(0,-3,3)
#@gui : Gamma Start = float(0,0,1)
#@gui : Gamma End = float(1,0,1)
#@gui : sep = separator()
#@gui : Scale Colour Variations = float(1,-4,4)
#@gui : note = note("<small>Scales the colour variations to reflect the difference between the start and end colours. For example, a value of 0 when going from black to yellow will flatten the helix so that only the red and green channels vary.</small>")
#@gui : sep = separator()
#@gui : Red Amplitude = float(1,0,4.00000)
#@gui : Red Phase Shift = float(0,0,360)
#@gui : Green Amplitude = float(1,0,4.00000)
#@gui : Green Phase Shift = float(0,0,360)
#@gui : Blue Amplitude = float(1,0,4.00000)
#@gui : Blue Phase Shift = float(0,0,360))
#@gui : sep = separator()
#@gui : Preview Colour Scheme = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
fx_cubehelix :

sh=((1-$11)/3)+1

ramp=$21*-1.7889532707703687
rang={0.083166763586+($22/180)*pi}
gamp=$23*-0.952442057555209
gang={2.8296965485317932+($24/180)*pi}
bamp=$25*1.97294
bang={(0.5+$26/180)*pi}
gs=$18^2
ge=$19^2
scv=-$20
rotb={2^($13^2)}
satb={2^($14^2)}
gamb={2^($17^2)}
repeat $! l[$>]
to_rgba split_opacity l[0]
if $1==1 luminance[0] to_rgb elif $1==2 f "(i0+i1+i2)/3" fi
abs c 0,255 c $2%,$3% if $4 n 0,255 fi *. {1/255}
f "begin(scale=([${8-10}]-[${5-7}])/255;
colstart=([${5-7}])/255;
const sh="$sh";
const gs="$gs";const ge="$ge"; const scv="$scv";
rotb="$rotb";satb="$satb";gamb="$gamb";
const ramp="$ramp";const rang="$rang";
const gamp="$gamp";const gang="$gang";
const bamp="$bamp";const bang="$bang");
angle=(2*pi*(sh+$12*(I^(rotb))));fract=gs+(I^(gamb))*(ge-gs);amp=(($15+($16-$15)*I^(satb))*fract*(1-fract)*0.5);
helix=(amp*[ramp*sin(rang-angle[0]),gamp*sin(gang-angle[1]),bamp*sin(bang-angle[2])]);
(colstart)-scv*(fract*scale+helix)+(1+scv)*(fract+(helix*sign(scale)))*scale"
c 0,1
*. 255
done a c
done done
fx_cubehelix_preview :
if $27
rm 256,256,1,3,"x"
fx_cubehelix $*
else
gui_split_preview "fx_cubehelix $*",${-3--1}
fi

#@gui _<b>Details</b>

#@gui Bilinear Enhancement : fx_jr_bilinear, fx_jr_bilinear_preview(1)
#@gui : Overall Iterations = int(1,1,10)
#@gui : Bilateral Sub-Iterations = int(3,1,10)
#@gui : Spatial Variance = float(10,0,100)
#@gui : Value Variance = float(10,0,100)
#@gui : Amplitude = float(1,-10,10)
#@gui : sep = separator()
#@gui : Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui : sep = separator()
#@gui : Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal",
#@gui : "Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right",
#@gui : "Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui : Preview Split = point(50,50,0,0,200,200,200,0,10)_0
fx_jr_bilinear:
repeat $! l[$>]
to_rgba
ac "
repeat $1
.
repeat $2 bilateral.. $3,$4 done
-. ..
*. {2^($5*0.5)}
+. ..
rm..
done
",$6
done done

fx_jr_bilinear_preview:
gui_split_preview "fx_jr_bilinear $*",${-3--1}

bitplane8 :
100%,100%,8,100%,"(i(#-1,x,y,0,c)>>z)&1" rm[0]

debitplane8 :
f "a=0;for(k=0,k<8,++k,a+=i(x,y,k)*2^k)"

#@gui 8-Bit Plane Splitter : fx_bitplane8, fx_bitplane8_preview(1)
#@gui : Mode = choice("Decompose","Recompose")
#@gui : Split Mode = choice(1,"Z layers","Separate images")
#@gui : Value Mode = choice("Real","1","255")
#@gui : Alpha = bool(0)
fx_bitplane8 :
if $4 to_rgba else to_rgb fi
if $1
if !$2 s z fi
repeat int($!/8) l[$>-{$>+7}]
repeat 8
iter=$>
l[$>]
if $3==0
/ {2^$iter} cut 0,1 round 0,1 * {2^$iter}
elif $3==1
cut 0,1 round 0,1 * {2^$iter}
elif $3==2
/ 255 cut 0,1 round 0,1 * {2^$iter}
fi
done done
+
done done
else
repeat 8
[0]
&[-1] {2^$>}
if $3==1
/[-1] {2^$>}
elif $3==2
/[-1] {2^$>/255}
fi
if !$2 a[^0] z fi
done
rm[0]
fi
fx_bitplane8_preview :
fx_bitplane8 $*

#@gui _<b>Degradations</b>

#@gui Shredder : fx_shredder, fx_shredder_preview(0)
#@gui : note = note("<small>Re-fills an image with its own values but makes random jumps in the relative positions where the lookup for the values takes place. Can be channel-independent. Relative gap sizes are cubed to make it easier to use small gaps between jumps.</small>")
#@gui : 0. Recompute = button(0)
#@gui : 1. Randomised Start = bool(1)
#@gui : 2. Channels = choice("Correlated","RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 3. Alpha = bool(1)
#@gui : 4. X Min Gap = float(0,0,100)
#@gui : 5. X Max Gap = float(100,0,100)
#@gui : 6. X Strength = float(0.5,0,1)
#@gui : 7. Y Min Gap = float(0,0,100)
#@gui : 8. Y Max Gap = float(100,0,100)
#@gui : 9. Y Strength = float(0.5,0,1)
#@gui : 10. Mirror = choice("None","X","Y","XY")
#@gui : 11. Rotate = choice("None,"90 clockwise","180","90 anticlockwise")
_fx_shredder :
repeat $! l[$>]
xming={$4/100}
xmaxg={$5/100}
strengthx={($6^4)}
yming={$7/100}
ymaxg={$8/100}
strengthy={($9^4)}
to_rgba split_opacity to_rgb.. to_gray.
l[0]
if $2
csswap 0,{($2)-1}
fi
done
if $3 a c fi
l[0]
if $10==1
mirror[0] x
elif $10==2
mirror[0] y
elif $10==3
mirror[0] xy
fi
if $11
rotate[0] {$11*90},0
fi
[0]
f[0] ">begin((!$1)?(col=0;row=0):(col=u*w^2;row=u*h^2);countx=(u("$xming","$xmaxg")^3)*wh+1;county=(u("$yming","$ymaxg")^3)*wh+1);
countx-=1;
county-=1;
countx<=0?(col=(u*w);countx=(u("$xming","$xmaxg")^3)*wh+1);
county<=0?(row=(u*h);county=(u("$yming","$ymaxg")^3)*wh+1);
(!$2)?J(#-1,"$strengthx"*col,"$strengthy"*row,0,0,2)
:j(#-1,"$strengthx"*col,"$strengthy"*row,0,0,0,2)"
rm[1]
if $11
rotate[0] {-$11*90},0
fi
if $10==1
mirror[0] x
elif $10==2
mirror[0] y
elif $10==3
mirror[0] xy
fi
if $2>=1
s[0] c
if $3 a[^-1] c else a c fi
l[0]
if $2
csswap {($2)-1},0
fi
done
fi
done
a c
done done

fx_shredder :
_fx_shredder ${2--1}
fx_shredder_preview :
fx_shredder $*

#@gui Blur [Bloom Glare] : fx_blur_bloom_glare, fx_blur_bloom_glare_preview(0)
#@gui : Amplitude = float(1,0,20)
#@gui : Ratio = float(2,0,10)
#@gui : Iterations = int(5,0,200)
#@gui : Operator = choice("Add","Max","Min")
#@gui : Kernel = choice("Quasi-gaussian","Gaussian","Box","Triangle","Quadratic")
#@gui : Normalize Scales = bool(0)
#@gui : Anisotropy = bool(0)
#@gui : Angle = float(0,0,180)
#@gui : Axis = int(3,1,20)
#@gui : Opacity = float(0.5,0,1)
#@gui : note = note("Parameters <i>Angle</i>, <i>Axis</i> and <i>Opacity</i> are only active when <i>Anisotropy</i> is checked")
#@gui : sep = separator()
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator()
#@gui : Preview Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
#@gui : sep = separator(), note = note("<small>Authors: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest update: <i>2015/03/02</i>.</small>")
fx_blur_bloom_glare :
op=${"arg 1+$4,+,max,min"}
if !$7
 ac "blur_bloom ${1-3},"$op",${5-6},xy",$11
else
 wh={[w,h]}
 repeat $9
  ang={(180/$9)*($>)+$8}
  +rotate[0] $ang,2,1
  ac. "blur_bloom ${1-3},"$op",${5-6},x",$11
  rotate. {-$ang},2,1
  r. $wh,1,100%,0,0,0.5,0.5
  c. 0,255
 done
 repeat $9
  blend[0,-1] screen,$10
 done
fi
fx_blur_bloom_glare_preview :
gui_split_preview "fx_blur_bloom_glare $*",$-1

#@gui Bomb Blend : fx_blend_bomb, fx_blend_bomb_preview()
#@gui : note = note("Creates a random transfer function 'mesh' and then blends images accordingly. Based on method shown <a href="https://discuss.pixls.us/t/im-generating-new-blending-modes-for-krita/8104/16">on discuss.pixls.us</a>.")
#@gui : Recompute = button(0)
#@gui : Process As = choice(1,"Two-by-two","Self-blend for each layer")
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh Smoothness = float(2,0,10)
#@gui : Contrast Scheme = choice("Arctan","Clip","Power")
#@gui : Mesh Contrast = float(50,0,100)
#@gui : Reverse Blending Layers = bool(0)
#@gui : Dimensions = choice("Bottom layer","Top layer")
#@gui : Alpha = bool(0)
#@gui : Normalise = bool(0)
#@gui : Output Mesh = bool(0)

_blend_bomb :
to_rgba
$1,$2,1,4 noise. 255
if $8 ac. "noise 255",rgba_a fi
r. 256,256 n. 0,255 blur. {$3^2}%
l. if $4==0
f "val = i/255; (val-0.5+(atan((val-0.5)*($5/10)^3)/pi)+0.5)*255" n 0,255
elif $4==1
c {($5-1/255)/2}%,{100-($5-1/255)/2}% n 0,255
elif $4==2
f "val = (2*i/255)-1; (val*(abs(val)^(0-($5/100)))+1)*255/2"
fi done
rv
fx_mesh_blend 0,1,$6,$7,$8,$10
if $9 ac "n 0,255",rgba fi

blend_bomb :
if $1==0 repeat int($!/2) l[$>,{$>+1}] _blend_bomb ${2--1} done done
elif $1==1 repeat $! l[$>] [0] _blend_bomb ${2--1} done done fi

fx_blend_bomb :
blend_bomb ${2--1}

fx_blend_bomb_preview :
fx_blend_bomb $*

#@gui JFIF [JPEG] Self-Bomb : fx_jfif_bomb, fx_jfif_bomb_preview()
#@gui : note = note("OI! TRY SMOOTHING THIS!")
#@gui : note = note("<small>Adds JPEG artefacts and then self-bomb-blends. Use grid interpolation with scale factors above 1 to destroy the results even more.</small>")
#@gui : Recompute = button(0)
#@gui : sep = separator()
#@gui : Quality (%) = int(50,1,100)
#@gui : Mesh X = int(16,1,256)
#@gui : Mesh Y = int(16,1,256)
#@gui : Mesh Smoothness = float(0.5,0,10)
#@gui : Contrast Scheme = choice(1,"Arctan","Clip","Power)
#@gui : Mesh Contrast = float(75,0,100)
#@gui : Scale X = float(1,0.05,16)
#@gui : Scale Y = float(1,0.05,16)
#@gui : Interpolation = choice(0,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : Normalize = bool(0)
#@gui : Output Mesh = bool(0)
#@gui : sep = separator()
#@gui : Solidify Alpha = bool(1)
#@gui : Smoothness (%) = float(75,0,100)
#@gui : Regularization = choice(1,"Isotropic","Delaunay-oriented","Edge-oriented")
#@gui : Regularization Iterations = int(20,0,100)
#@gui : Dilation / Erosion = int(0,-20,20)
#@gui : Colorspace = choice(1,"sRGB","Linear RGB")
_fx_jfif_bomb :
repeat $! l[$>]
if $12
+fx_solidify_td ${13-17}
negate. rv blend alpha
fi
ww={w}
hh={h}
r {$7*100}%,{$8*100}%,100%,100%,$9
fx_jpeg_artefacts $1
blend_bomb 1,${2-6},0,0,0,${10-11}
r $ww,$hh,100%,100%,$9
done done
fx_jfif_bomb:
_fx_jfif_bomb ${2--1}
fx_jfif_bomb_preview :
fx_jfif_bomb $*

# #@gui Noise [Additive] : fx_noise, fx_noise_preview(0)
# #@gui : Amplitude = float(10,0,200)
# #@gui : Noise Type = choice("Gaussian","Uniform","Salt and pepper","Poisson","Rice")
# #@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
# #@gui : Value Action = choice(1,"None","Cut","Normalize")
# #@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
# #@gui : sep = separator(), note = note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperl&#233;</a></i>.      Latest update: <i>2010/29/12</i>.</small>")
jr_fx_noise :
ac "_fx_noise $1,$2",$3,$4
_jr_fx_noise :
repeat $! l[$>] split_opacity l[0] noise $1,$2 done a c done done
jr_fx_noise_preview :
gui_split_preview "jr_fx_noise $*",${-3--1}

#@gui Cascading Self Glitching : fx_self_glitching_cascade, fx_self_glitching_cascade_preview(1)
#@gui : note = note("Shifts images in a cascading fashion but computes values based on shifted and original images.")
#@gui : note = note("<small>This filter has many channel options and many operation options allowing for extremely-distorted images. Don't always trust the preview!</small>"), sep = separator()
#@gui : 1. Shift Channels = choice("RGB&#47;sRGB","CMYK&#47;CMY","HSV&#47;HSV8","HSL&#47;HSL8","HSI&#47;HSI8","LCH&#47;LCH8","Lab&#47;Lab8","YCbCr&#47;YCbCrGLIC","YIQ&#47;YIQ8","YUV&#47;YUV8","RYB&#47;HCY","XYZ&#47;XYZ8")
#@gui : 2. Alt Choice = bool(0)
#@gui : 3. Process Alpha = bool(0)
#@gui : 4,5. Zeroth Shift = point(50,50,0,1,255,255,255,175)
#@gui : 6. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : sep = separator()
#@gui : 7. Iterations = int(3,1,64)
#@gui : 8. Repeat Post-Shift Operations = bool(1)
#@gui : sep = separator()
#@gui : 9,10. Shift Target = point(55,55,0,1,255,0,0,175)
#@gui : 11. Target for Final &#40;Rather than First&#41; Shift = bool(0)
#@gui : 12,13. Cascade Centre Point = point(45,45,0,1,0,255,0,175)
#@gui : 14. Shift Randomness = float(0.75,0,4)
#@gui : 15. Boundary = choice(3,"Zero","Nearest","Periodic","Mirror")
#@gui : 16. Power = float(0,-5,5)
#@gui : 17. Bias = float(0,-256,256)
#@gui : 18. Negation = bool(0)
#@gui : 19. Shift Operator = choice("Add","Multiply","Bitwise And","Bitwise Or","Bitwise Xor","Power","Reverse Power",
#@gui : "Modulo","Reverse Modulo","Divide","Reverse Divide","Subtract","Reverse Subtract",
#@gui : "Left Bitwise Shift","Reverse LBS","Right Bitwise Shift","Reverse RBS","Left Bitwise Rotation","Reverse LBR","Right Bitwise Rotation","Reverse RBR",
#@gui : "Average","Round","Reverse Round","Sine","Reverse Sine","Cosine","Reverse Cosine","Tangent","Reverse Tangent &#40;CPU-intensive&#41;",
#@gui : "Cosecant","Reverse Cosecant","Secant","Reverse Secant","Cotangent","Reverse Cotangent","Variance","Difference","Minimum","Maximum",
#@gui : "Interference &#40;Add&#41;","Reverse Interference &#40;Add&#41;","Interference &#40;Multiply&#41;",
#@gui : "Interference &#40;Divide&#41;","Reverse Interference &#40;Div&#41;",
#@gui : "Interference &#40;Subtract&#41;","Reverse Interference &#40;Subt&#41;","Interference &#40;Rev Subt&#41;","Reverse Interference &#40;Rev Subt&#41;",
#@gui : "Interference &#40;Difference&#41;","Reverse Interference &#40;Diff&#41;","Interference &#40;Variance&#41;",
#@gui : "Screen","Colour Dodge","Reverse Colour Dodge","Colour Burn","Reverse Colour Burn","Soft Light &#40;illusions&#46;hu&#41;","Reverse Soft Light &#40;illusions&#46;hu&#41;",
#@gui : "Geometric Mean","Bright Hard Mix","Dark Hard Mix")
#@gui : 20. Multiplier 1 = float(1,-10,10)
#@gui : 21. Addition 1 = int(0,-1024,1024)
#@gui : 22. Sawtoother Mode = choice(0,"Modulo","Triangular-Modulo","Legacy Modulo")
#@gui : 23. Maximum End Value = int(256,0,1024)
#@gui : 24. Multiplier 2 = float(1,-10,10)
#@gui : 25. Addition 2 = int(0,-1024,1024)
#@gui : sep = separator(), 26. Run on channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), note = note("<small>Original author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>&#59; extended by some nobody who calls themselves 'Joan Rake' or something.<p>Latest update: <i>2018/08/24</i>.</small>")
fx_self_glitching_cascade :
skip "${25=skip ,}","${26=skip ,}"
shift {$4-50}%,{$5-50}%,0,0,$6,0
repeat $! l[$>] if !$3 split_opacity fi l[0] to_rgb
if $2
if $1==0 rgb2srgb
elif $1==1 rgb2cmy
elif $1==2 rgb2hsv8
elif $1==3 rgb2hsl8
elif $1==4 rgb2hsi8
elif $1==5 rgb2lch8
elif $1==6 rgb2lab8
elif $1==7 rgb2ycbcrglic
elif $1==8 rgb2yiq8
elif $1==9 rgb2yuv8
elif $1==10 rgb2hcy
elif $1==11 rgb2xyz8
fi else
if $1==1 rgb2cmyk
elif $1==2 rgb2hsv
elif $1==3 rgb2hsl
elif $1==4 rgb2hsi
elif $1==5 rgb2lch
elif $1==6 rgb2lab
elif $1==7 rgb2ycbcr
elif $1==8 rgb2yiq
elif $1==9 rgb2yuv
elif $1==10 rgb2bayer 0
elif $1==11 rgb2xyz
fi fi
if $11 stype=$7 else stype=1 fi
repeat $7
+shift[0] {((([w,h]-1)*([$12,$13]-[$9,$10]+[u(-1,1),u(-1,1)]*sqrt((($12-$9)^2)+(($13-$10)^2))*($14^3)))/$stype)/100},0,0,$15
f.. "begin(
const sign = $18?-1:1;
);
operate(mode,s1,s2,mult,power) =
(mode==0?(s1 + s2):
mode==1?(s1 * s2):
mode==2?(s1 & s2):
mode==3?(s1 | s2):
mode==4?xor(s1,s2):
mode==5?(s1^(s2*0.01)):
mode==6?(s2^(s1*0.01)):
mode==7?(s1%s2):
mode==8?(s2%s1):
mode==9?(s1 / s2):
mode==10?(s2 / s1):
mode==11?(s2 - s1):
mode==12?(s1 - s2):
mode==13?(s1 << s2):
mode==14?(s2 << s1):
mode==15?(s1 >> s2):
mode==16?(s2 >> s1):
mode==17?for(n=0,n<(s2%32),n++,rol(s1)):
mode==18?for(n=0,n<(s1%32),n++,rol(s2)):
mode==19?for(n=0,n<(s2%32),n++,ror(s1)):
mode==20?for(n=0,n<(s1%32),n++,ror(s2)):
mode==21?avg(s2,s1):
mode==22?round(s1,s2,0):
mode==23?round(s2,s1,0):
mode==24?s2*sin(s1*2*pi/mult):
mode==25?s1*sin(s2*2*pi/mult):
mode==26?sign*s2*cos(s1*2*pi/mult):
mode==27?sign*s1*cos(s2*2*pi/mult):
mode==28?s2*tan(s1*pi/mult):
mode==29?s1*tan(s2*pi/mult):
mode==30?s2*sin(mult/(s1*2*pi)):
mode==31?s1*sin(mult/(s2*2*pi)):
mode==32?sign*s2*cos(mult/(s1*2*pi)):
mode==33?sign*s1*cos(mult/(s2*2*pi)):
mode==34?s2*tan(mult/(s1*pi)):
mode==35?s1*tan(mult/(s2*pi)):
mode==36?mult*var(s1,s2):
mode==37?abs(s2 - s1):
mode==38?min(s2,s1):
mode==39?max(s2,s1):
mode==40?0.005*s2*(((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power))+s1):
mode==41?0.005*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)+s2):
mode==42?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)*s1:
mode==43?0.1*s2*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s1:
mode==44?0.1*s1*(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)/s2:
mode==45?0.001*s2*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==46?0.001*s1*((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==47?0.001*s2*(s1-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==48?0.001*s1*(s2-(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==49?0.001*s2*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s1):
mode==50?0.001*s1*abs((j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)-s2):
mode==51?0.00001*mult*var(s1,s2,(j(#-1,0,0,0,(c+1)%(s(#0)-1)+1)*2^power)):
mode==52?(255-((255-s1)*(255-s2))):
mode==53?(s1/(255-s2)):
mode==54?(s2/(255-s1)):
mode==55?((255-s2)/s1*255):
mode==56?((255-s1)/s2*255):
mode==57?((((s1)/255)^2)^(2*(0.5-(s2/255))))*255:
mode==58?((((s2)/255)^2)^(2*(0.5-(s1/255))))*255:
mode==59?sqrt(abs(s1*s2)):
mode==60?(if((s1+s2)>=255,255,0)):
(if((s1+s2)<=255,0,255)));
val = sign*((2^$16)*j(#-1) + $17);operate($19,val,i,$20,$16);
" rm.
if $8
*. $20 +. $21 if $22==2 if $23 %. $23 fi else if $23 modf $22,$23,1,0 fi fi *. $24 +. $25
fi
done
if !$8
*. $20 +. $21 if $22==2 if $23 %. $23 fi else if $23 modf $22,$23,1,0 fi fi *. $24 +. $25
fi
if $2
if $1==0 srgb2rgb
elif $1==1 cmy2rgb
elif $1==2 hsv82rgb
elif $1==3 hsl82rgb
elif $1==4 hsi82rgb
elif $1==5 lch82rgb
elif $1==6 lab82rgb
elif $1==7 ycbcrglic2rgb
elif $1==8 yiq82rgb
elif $1==9 yuv82rgb
elif $1==10 hcy2rgb
elif $1==11 xyz82rgb
fi else
if $1==1 cmyk2rgb
elif $1==2 hsv2rgb
elif $1==3 hsl2rgb
elif $1==4 hsi2rgb
elif $1==5 lch2rgb
elif $1==6 lab2rgb
elif $1==7 ycbcr2rgb
elif $1==8 yiq2rgb
elif $1==9 yuv2rgb
elif $1==10 bayer2rgb 0,0,0
elif $1==11 xyz2rgb
fi fi
done a c done done
fx_self_glitching_cascade_preview :
repeat max(0,l)
ac[$>] "-fx_self_glitching_cascade $*",$26
done

#@gui Sawtoother [CMY(/K)] : sawtoother_cmy_k, sawtoother_cmy_k_preview(1)+
#@gui : note = note("Splits image into CMY or CMYK channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Cyan</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Magenta</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Yellow</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Key</b>")
#@gui : Include Channel = bool(0)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_cmy_k :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $26,$27
if $19 rgb2cmyk. else rgb2cmy. fi s. c
index=0
if $19 index=-1 if $23 b[-1] $22% +[-1] $25 %[-1] {256/$20} *[-1] $20 %[-1] 256 *[-1] $24 +[-1] $21 else *[-1] $20 +[-1] {$21*$20} b[-1] $22% fi fi
if $4 b[{$index-3}] $3% +[{$index-3}] $6 %[{$index-3}] {256/$1} *[{$index-3}] $1 %[{$index-3}] 256 *[{$index-3}] $5 +[{$index-3}] $2 else *[{$index-3}] $1 +[{$index-3}] {$2*$1} b[{$index-3}] $3% fi
if $10 b[{$index-2}] $9% +[{$index-2}] $12 %[{$index-2}] {256/$7} *[{$index-2}] $7 %[{$index-2}] 256 *[{$index-2}] $11 +[{$index-2}] $8 else *[{$index-2}] $7 +[{$index-2}] {$8*$7} b[{$index-2}] $9% fi
if $16 b[{$index-1}] $15% +[{$index-1}] $18 %[{$index-1}] {256/$13} *[{$index-1}] $13 %[{$index-1}] 256 *[{$index-1}] $17 +[{$index-1}] $14 else *[{$index-1}] $13 +[{$index-1}] {$14*$13} b[{$index-1}] $15% fi
c 0,255 a[{$index-3}--1] c
if $19 cmyk2rgb. else cmy2rgb. fi
fx_end_mix $26
if $!!=3 rv a c fi done mv. 0 done
sawtoother_cmy_k_preview :
sawtoother_cmy_k $*
#gui_split_preview "sawtoother_cmy_k $*",$-1

#@gui Sawtoother [HSX] : sawtoother_hsx, sawtoother_hsx_preview(1)+
#@gui : note = note("Splits image into HSV, HSI or HSL channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-180,180)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-180,180)
#@gui : sep = separator(), note = note("<b>Saturation</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-1,1)
#@gui : sep = separator(), note = note("<b>Value&#47;Intensity&#47;Lightness</b>")
#@gui : Channel = choice("Value","Intensity","Lightness)
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-1,1)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-1,1)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_hsx :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $20,$21
if $13==1 rgb2hsi. elif $13==2 rgb2hsl. else rgb2hsv. fi
s. c
if $4 +[-3] $6 %[-3] {360/($1)^2} *[-3] $1 %[-3] 360 *[-3] {$5*$1} +[-3] {$2} else *[-3] $1 +[-3] {$2*$1} fi %[-3] 360
if $10 b[-2] $9% +[-2] $12 %[-2] {(1+(1/255))/$7} *[-2] {$7} %[-2] {(1+(1/255))} *[-2] $11 +[-2] {$8} else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $17 b[-1] $16% +[-1] $19 %[-1] {(1+(1/255))/$14} *[-1] {$14} %[-1] {(1+(1/255))} *[-1] $18 +[-1] {$15} else *[-1] $14 +[-1] {$15*$14} b[-1] $16% fi
c[-2,-1] 0,1 a[-3--1] c
if $13==1 hsi2rgb. elif $13==2 hsl2rgb. else hsv2rgb. fi
if $3 l[-1] +b $3% rgb2hsv[0,1] f.. "[i0(#1),i1,i2]" rm. hsv2rgb done fi
fx_end_mix $20
if $!!=3 rv a c fi done mv. 0 done
sawtoother_hsx_preview :
gui_split_preview "sawtoother_hsx $*",$-1

#@gui Sawtoother [LCH8] : sawtoother_lch8, sawtoother_lch8_preview(1)+
#@gui : note = note("Splits image into LCH8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chroma</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Hue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_lch8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lch8.
s. c
if $4 +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/($13)^2} *[-1] $13 %[-1] 256 *[-1] {$17*$13} +[-1] {$14} else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi %[-1] 256
a[-3--1] c c. 0,255 lch82rgb.
if $3 l[-1] +b $3% rgb2lch8[0,1] f.. "[i0,i1,i2(#1)]" rm. lch82rgb done fi
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_lch8_preview :
sawtoother_lch8 $*
#gui_split_preview "sawtoother_lch8 $*",$-1

#@gui Sawtoother [YIQ8] : sawtoother_yiq8, sawtoother_yiq8_preview(1)+
#@gui : note = note("Splits image into YIQ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_yiq8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yiq8. s. c
+[-2,-1] 0.5
if $4 b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yiq82rgb.
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_yiq8_preview :
gui_split_preview "sawtoother_yiq8 $*",$-1

#@gui Sawtoother [XYZ8] : sawtoother_xyz8, sawtoother_xyz8_preview(1)+
#@gui : note = note("Splits image into XYZ8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>X</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Y</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Z</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_xyz8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2xyz8. s. c
+[-2,-1] 0.5
if $4 b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 xyz82rgb.
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_xyz8_preview :
gui_split_preview "sawtoother_xyz8 $*",$-1

#@gui Sawtoother [YUV8] : sawtoother_yuv8, sawtoother_yuv8_preview(1)+
#@gui : note = note("Splits image into YUV8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance I</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance Q</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_yuv8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2yuv8. s. c
+[-2,-1] 0.5
if $4 b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 yuv82rgb.
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_yuv8_preview :
gui_split_preview "sawtoother_yuv8 $*",$-1

#@gui Sawtoother [YCbCr-(/GLIC/JPEG)] : sawtoother_ycbcr, sawtoother_ycbcr_preview(1)+
#@gui : note = note("Splits image into YCbCr channels and uses modulo operations to generate sawtooth waves and map channel intensities to them. One can choose between the original G'MIC implementation, <a href="https://web.archive.org/web/20180906062556/https://github.com/GlitchCodec/GLIC/blob/master/colorspaces.pde">the GLIC implementation</a>, and the JPEG-style implementation by Garagecoder.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : Channel = choice("YCbCr","YCbCrGLIC","YCbCrJPEG")
#@gui : sep = separator(), note = note("<b>Y &#40;Luminance&#41;</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Red Chrominance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_ycbcr :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $20,$21
if $1==1 rgb2ycbcrglic. elif $1==2 rgb2srgb. gcd_srgb2jpeg. else rgb2ycbcr. fi s. c
+[-2,-1] 0.5
if $5 b[-3] $4% +[-3] $7 %[-3] {256/$2} *[-3] $2 %[-3] 256 *[-3] $6 +[-3] $3 else *[-3] $2 +[-3] {$3*$2} b[-3] $4% fi
if $11 b[-2] $10% +[-2] $13 %[-2] {256/$8} *[-2] $8 %[-2] 256 *[-2] $12 +[-2] $9 else *[-2] $8 +[-2] {$9*$8} b[-2] $10% fi
if $17 b[-1] $16% +[-1] $19 %[-1] {256/$14} *[-1] $14 %[-1] 256 *[-1] $18 +[-1] $15 else *[-1] $14 +[-1] {$15*$14} b[-1] $16% fi
a[-3--1] c c. 0,255 if $1==1 ycbcrglic2rgb. elif $1==2 gcd_jpeg2srgb. srgb2rgb. else ycbcr2rgb. fi
fx_end_mix $20
if $!!=3 rv a c fi done mv. 0 done
sawtoother_ycbcr_preview :
gui_split_preview "sawtoother_ycbcr $*",$-1

#@gui Sawtoother [RGB] : sawtoother_rgb, sawtoother_rgb_preview(1)+
#@gui : note = note("Splits image into RGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_rgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
s. c
+[-2,-1] 0.5
if $4 b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_rgb_preview :
gui_split_preview "sawtoother_rgb $*",$-1

#@gui Sawtoother [sRGB] : sawtoother_srgb, sawtoother_srgb_preview(1)+
#@gui : note = note("Splits image into sRGB channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Red</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Green</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Blue</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_srgb :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2srgb. s. c
+[-2,-1] 0.5
if $4 b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c c. 0,255 srgb2rgb.
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_srgb_preview :
sawtoother_srgb $*
#gui_split_preview "sawtoother_srgb $*",$-1

#@gui Sawtoother [Lab8] : sawtoother_lab8, sawtoother_lab8_preview(1)+
#@gui : note = note("Splits image into Lab8 channels and uses modulo operations to generate sawtooth waves and map channel intensities to them.")
#@gui : note = note("<small>This filter was intended for screwing up images but it can also be used for quick analysis among other things.</small>")
#@gui : sep = separator(), note = note("<b>Luminance</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance a</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator(), note = note("<b>Chrominance b</b>")
#@gui : Factor = float(1,0,20)
#@gui : Shift = float(0,-256,256)
#@gui : Smoothness = float(0,0,10)
#@gui : Modulo = bool(1)
#@gui : Multiplier = float(1,0,20)
#@gui : Phase Shift = float(0,-256,256)
#@gui : sep = separator()
#@gui : Tones Range = choice("All tones","Shadows","Mid-tones","Highlights")
#@gui : Tones Smoothness = float(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right")
sawtoother_lab8 :
repeat $! l. split_opacity rv to_rgb.
fx_start_mix $19,$20
rgb2lab8. s. c
if $4 b[-3] $3% +[-3] $6 %[-3] {256/$1} *[-3] $1 %[-3] 256 *[-3] $5 +[-3] $2 else *[-3] $1 +[-3] {$2*$1} b[-3] $3% fi
if $10 b[-2] $9% +[-2] $12 %[-2] {256/$7} *[-2] $7 %[-2] 256 *[-2] $11 +[-2] $8 else *[-2] $7 +[-2] {$8*$7} b[-2] $9% fi
if $16 b[-1] $15% +[-1] $18 %[-1] {256/$13} *[-1] $13 %[-1] 256 *[-1] $17 +[-1] $14 else *[-1] $13 +[-1] {$14*$13} b[-1] $15% fi
a[-3--1] c lab82rgb.
fx_end_mix $19
if $!!=3 rv a c fi done mv. 0 done
sawtoother_lab8_preview :
sawtoother_lab8 $*
#gui_split_preview "sawtoother_lab8 $*",$-1

#@gui Pseudo-ECB (Electronic Code Book Algorithm): pseudo_ecb, _pseudo_ecb_preview(0)
#@gui : note = note("This filter is inspired by one of the glitch plugin for Paint.NET. This doesn't actually emulate how the codebook encryption algorithm actually work, but it is inspired from it.  This filter uses bomb blending mode which involves RGBA Transfer Function Mesh. See Mesh Blend filter for a link. \n\n <u>Note that the filter works best on images with large patches of single colors.</u> ")
#@gui : sep = separator()
#@gui : note = note("<b>Color Space Choice</b> \n\n <i>Keep in mind that you may not necessarily get what you imagine. Just treat these as themes. </i>")
#@gui : Colour Space = choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : sep = separator()
#@gui : note = note("<b>Final Color Processing</b> \n\n <i>This refers to the how the colors are going to be processed. If you find that there's too little difference in hues or chroma or luminosity in local areas, this should be on. Sometimes, the result are better without the final processing.</i>")
#@gui : Equalize Filter = bool(0)
#@gui : Pseudo-Coloring = bool(1)
#@gui : Tonality Blend = choice(20,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Tonality Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Pattern Key Generator</b>")
#@gui : Double Gradient? = bool(1)
#@gui : Length of Gradient#1 = float(5,0,32)
#@gui : ECB Gradient#1 Angle = float(0,0,360)
#@gui : ECB Inversion#1 = bool(0)
#@gui : Length of Gradient#2 = float(5,0,32)
#@gui : ECB Gradient#2 Angle = float(90,0,360)
#@gui : ECB Inversion#2 = bool(0)
#@gui : Gradient Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Gradient Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Sharpen Filtering</b>")
#@gui : Sharpening Noise Processing = float(15,0,200)
#@gui : sep = separator()
#@gui : note = note("<b>ECB Image Processing</b>")
#@gui : Transfer Mesh Size for Image (Squared) = int(256,2,256)
#@gui : Image Mesh Contrast = int(75,25,100)
#@gui : Transfer Mesh Size for Gradient (Squared) = int(16,2,256)
#@gui : Gradient Mesh Contrast = int(100,25,100)
#@gui : Double Encryption Effect = bool(1)
#@gui : Inner Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Inner Blend Opacity = float(1,0,1)
#@gui : Outer Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Outer Blend Opacity = float(1,0,1)
#@gui : sep = separator()
#@gui : note = note("<b>Self-Image Post-Processing</b> \n\n <i>This invokes a self-blending operation after the main pseudo-ecb has been generated with different blend mode.</i>")
#@gui : Activate Self-Image Post-Processing = bool(1)
#@gui : Equalize ECB Processing = bool(0)
#@gui : Pseudo-Coloring = bool(1)
#@gui : Self-Blend = choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui : "difference","divide","dodge","exclusion","freeze",
#@gui : "grainextract","grainmerge","green","hardlight","hardmix",
#@gui : "hue","interpolation","lighten","lightness","linearburn",
#@gui : "linearlight","luminance","multiply","negation","or",
#@gui : "overlay","pinlight","red","reflect","saturation","screen",
#@gui : "shapeaverage","softburn","softdodge","softlight","stamp",
#@gui : "subtract","value","vividlight","xor")
#@gui : Self-Blend Opacity = float(1,0,1)
#@gui : sep = separator(), note = note("<b>Multilayer processing</b>\n\n<small><b>Warning:</b>All layer must be of same size for expected result!</small>"), Apply to all layers? = bool(0)
#@gui : Boundary Condition = choice(0,"Neumann","Periodic","Mirror")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
#@gui : sep = separator(), note = note("<small>Author : <i>Reptorian</i>      Latest update: <i>2018/12/30</i>.</small>")
pseudo_ecb:
ww={w+4}
hh={h+4}
total_image_minus_one={$!-1}
if $total_image_minus_one&&$30 expand_xy 4,$31 a x _pseudo_ecb ${1-29} s x,{$total_image_minus_one+1} shrink_xy 4 rv
else _pseudo_ecb ${1-29} fi
_pseudo_ecb:
csswap $1,0
repeat $! l[$>]
repeat $20+1
pseudo_ecb_generate ${2-19},${21-29}
done
done
csswap 0,$1
done

pseudo_ecb_generate:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
+ac "ecb_gradient_base[0] $6,$7,$8",rgb
if $2==1 _pseudo_c[1] fi
local[1]
if $5==1 +ac "ecb_gradient_base[0] $9,$10,$11",rgb
_pseudo_c[1]
blend ${_mode{$12+1}},$13 if $1==1 equalize fi fi
done
local[0]
sharpen $14
if $2==1 +_pseudo_c[0]
elif $2==1 [0] fi
+fx_blend_bomb[0] 0,1,$15,$15,0,0,$16,0,0,0,1,0
blend ${_mode{$19+1}},$20
done
fx_blend_bomb[1] 0,1,$17,$17,0,0,$18,0,0,0,0,0
if $1==1 equalize[1] fi
blend ${_mode{$21+1}},$22
if $1==1 +equalize blend ${_mode{$3+1}},$4 fi
if $1==0 [0] blend ${_mode{$3+1}},$4 fi
if $23==1 [0] if $24==1 equalize[1] fi if $25==1 _pseudo_c[1] fi blend ${_mode{$26+1}},$27
fi

ecb_gradient_base:
f "ang=pi*$2/180;G=x*cos(ang)+y*sin(ang);G%$1" n 0,255
if $3==1 mul -1 abs fi

_pseudo_c : v - if s!=1 to_gray. fi {max(1,round(iM,1,1))},1,1,3,u(255) round. map.. . rm.  v +

_pseudo_ecb_preview :
gui_split_preview "pseudo_ecb $*",${-3--1}

#@gui Faux-QAM Glitch: fx_qam_glitch, fx_qam_glitch_preview(0)
#@gui : note = note("Tries to emulate the effect of a faulty Quadrature Amplitude Modulator.")
#@gui : sep = separator()
#@gui : note = note("<b>Channel Modulation</b>")
#@gui : 1. Amplitude = float(2,0,10)
#@gui : 2. Period = float(20,0,100)
#@gui : 3. Phase Offset = float(0,-180,180)
#@gui : 4. Angle = float(0,-180,180)
#@gui : 5. Amplitude Offset = float(1,-10,10)
#@gui : 6. Wave Offset = float(127.5,0,255)
#@gui : 7. Colour Space = choice("RGBA","sRGBA","HSVA8","HSVA","HSLA8","HSLA","HSIA8","HSIA","LCHA8","LCHA","LabA8","LabA","YCbCrA","YCbCrAGLIC","YCbCrAJPEG","YIQA8","YIQA","YUVA8","YUVA","HCYA","XYZA8","XYZA","RYBA","CMYA")
#@gui : 8. Channel 0 = bool(1)
#@gui : 9. Channel 1 = bool(1)
#@gui : 10. Channel 2 = bool(1)
#@gui : 11. Alpha = bool(0)
#@gui : 12. Glitch Negation = bool(0)
#@gui : sep = separator()
#@gui : note = note("<b>Scanlines</b>")
#@gui : 13. Amplitude = float(20,0,255)
#@gui : 14. Bandwidth = float(5,0,20)
#@gui : 15. Shape = choice(0,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : 16. Angle Offset = float(0,-180,180)
#@gui : 17. Offset = float(0,0,500)
#@gui : 18. Blur = float(2,0,10)
#@gui : 19. Amplitude Modulation = float(0.6,0,1)
#@gui : 20. Phase Modulation = float(0.05,0,1)
#@gui : sep = separator(), 21-23. Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)

_scanlines : skip ${1=60},${2=2},${3=0},${4=0},${5=0}
v -
theta={$4*pi/180} C={cos($theta)} S={-sin($theta)}
repeat $! l[$>]
100%,100%,1,1,"x" -. {w/2-$5} 100%,100%,1,1,'y'
-. {h/2-$5} *.. $S *. $C +[-2,-1]
_ripple$3. $1,$2
n. {-$1},$1
+ cut 0,255
done done v +

_qam_glitch :

100%,100%,1,1 _scanlines. ${7-9},{(90+$4+$10)},$11 b. $12
*. 2 -. $7
f.. "line=i(#-1\,x\,y\,z\,0);ang=(90+$4)*pi/180;(i+(((1+line*5*$13/255)*($1*i/255+$5))*(i*sin(((x-w/2)*cos(ang)+(y-h/2)*sin(ang))/$2+($3+(line*$2*$14/10)/255*360)*pi/180))+($6*($1)-($1*i/2)))-i/255)%255"
rm.

fx_qam_glitch :
repeat $! l[$>]
to_rgba
cs=$7
if $12 negate fi
csswap 0,$cs
counter=0
if $8 sh[0] 0 fi
if $9 sh[0] 1 fi
if $10 sh[0] 2 fi
if $11 sh[0] 3 fi
repeat $!-1 l[{$>+1}]
_qam_glitch ${1-6},${13-20}
done done
k[0]
csswap $cs,0
if $12 negate fi
done done
fx_qam_glitch_preview :
gui_split_preview "fx_qam_glitch $*",${-3--1}

#@gui Smooth EQ: fx_jr_smooth_eq, fx_jr_smooth_eq_preview(0)
#@gui : note = note("A zero-phase equaliser with low-pass and high-pass filters and 5 band shelves.")
#@gui : sep = separator(), note = note("<b>Low Pass</b>")
#@gui : Frequency Power = float(8,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Resonance = float(0,0,5)
#@gui : sep = separator(), note = note("<b>Band Shelf 1</b>")
#@gui : Frequency Power = float(3,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Bandwidth = float(1.5,0,16)
#@gui : Gain = float(0,-10,10)
#@gui : sep = separator(), note = note("<b>Band Shelf 2</b>")
#@gui : Frequency Power = float(4,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Bandwidth = float(2,0,16)
#@gui : Gain = float(0,-10,10)
#@gui : sep = separator(), note = note("<b>Band Shelf 3</b>")
#@gui : Frequency Power = float(5,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Bandwidth = float(2,0,16)
#@gui : Gain = float(0,-10,10)
#@gui : sep = separator(), note = note("<b>Band Shelf 4</b>")
#@gui : Frequency Power = float(6,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Bandwidth = float(2,0,16)
#@gui : Gain = float(0,-10,10)
#@gui : sep = separator(), note = note("<b>Band Shelf 5</b>")
#@gui : Frequency Power = float(7,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Bandwidth = float(2,0,16)
#@gui : Gain = float(0,-10,10)
#@gui : sep = separator(), note = note("<b>High Pass</b>")
#@gui : Frequency Power = float(3,0,16)
#@gui : Order Cube Root = float(2,0,4)
#@gui : Resonance = float(0,0,5)
#@gui : Colour Space= choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : Alpha = bool(0)
#@gui : Absolute = bool(1)
#@gui : Makeup Gain = bool(1)
#@gui : Preview Frequency Response = bool(0)

_jr_smooth_eq_prepare :

f. "begin(scale=((w^2+h^2+d^2)^0.5)/2;ol=$2^3;oh=$25^3;ql=(2-2/(($3+1)^2));qh=(2-2/(($26+1)^2));rsl=1/(2^$1);rsh=1/(2^$24);ol=$2^3;oh=$25^3;
order1=$5^3;band1=$6^2;gain1=$7;
order2=$9^3;band2=$10^2;gain2=$11;
order3=$13^3;band3=$14^2;gain3=$15;
order4=$17^3;band4=$18^2;gain4=$19;
order5=$21^3;band5=$22^2;gain5=$23);
vx=(x-w/2);vy=(y-h/2);vz=(z-d/2);rad=((vx^2+vy^2+vz^2)^0.5)*scale/16;
fl=rad*rsl;
fh=(rad*rsh)^-1; # modify for highpass
func=(1/((1-ql*(fl)^(ol/2)+(fl)^(ol))^0.5)); # lowpass
func*=2^(gain1/sqrt(1+2*abs(log2(rad/(2^"$4"))/(band1))^order1)); # band shelf 1
func*=2^(gain2/sqrt(1+2*abs(log2(rad/(2^"$8"))/(band2))^order2)); # band shelf 2
func*=2^(gain3/sqrt(1+2*abs(log2(rad/(2^"$12"))/(band3))^order3)); # band shelf 3
func*=2^(gain4/sqrt(1+2*abs(log2(rad/(2^"$16"))/(band4))^order4)); # band shelf 4
func*=2^(gain5/sqrt(1+2*abs(log2(rad/(2^"$20"))/(band5))^order5)); # band shelf 5
func*=(1/((1-qh*(fh)^(oh/2)+(fh)^(oh))^0.5)); # highpass
func"

_jr_smooth_eq :
v -
100%,100%,100%
_jr_smooth_eq_prepare ${1-26}
shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2
fft.. *... . *[-2,-1] ifft rm[-1]
v +
fx_jr_smooth_eq :
repeat $! l[$>]
if !$28 split_opacity fi
l[0]
gain={iM} csswap 0,$27
_jr_smooth_eq ${1-26}
csswap $27,0 if $29 abs fi if $30 * {$gain/iM} fi
done
if !$28 a c fi
done done

fx_jr_smooth_eq_preview :
if $31
rm
4000,1,1 _jr_smooth_eq_prepare ${1-26}
columns 50%,100%
1000,500,1,1
f. "cut((i(#-2,2^(x*log2(w)/w-1),0,0,0,2,1)*(255)-y)*127.5,0,255)"
mirror y
r. 50%,100%
k[-1]
else
fx_jr_smooth_eq ${1-30}
fi

#@gui Butterworth Bandpass: fx_butterworth_bp, fx_butterworth_bp_preview(0)
#@gui : note = note("Lowpass and highpass zero-phase resonant Butterworth-style filters.")
#@gui : sep = separator()
#@gui : LP Frequency Power = float(3,0,16)
#@gui : LP Order Cube Root = float(2,0,4)
#@gui : LP Resonance = float(0,0,5)
#@gui : HP Frequency Power = float(4,0,16)
#@gui : HP Order Cube Root = float(2,0,4)
#@gui : HP Resonance = float(0,0,5)
#@gui : Colour Space= choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : Alpha = bool(0)
#@gui : Absolute = bool(1)
#@gui : Makeup Gain = bool(1)
#@gui : Preview Frequency Response = bool(0)

_bwbp_prepare :

f. "begin(scale=max(w,h,d);ol=$2^3;oh=$5^3;ql=(2-2/(($3+1)^2));qh=(2-2/(($6+1)^2));rsl=scale*log2(scale)/(2^$1);rsh=scale*log2(scale)/(2^$4));
vx=(x-w/2)/scale;vy=(y-h/2)/scale;vz=(z-d/2)/scale;rad=(vx^2+vy^2+vz^2)^0.5;
fl=rad*rsl;
fh=(rad*rsh)^-1;
ol=$2^3;
oh=$5^3;
func=(1/((1-ql*(fl)^(ol/2)+(fl)^(ol))^0.5)); # lp
func*=(1/((1-qh*(fh)^(oh/2)+(fh)^(oh))^0.5));func"

_butterworth_bp :
v -
100%,100%,100%
_bwbp_prepare ${1-6}
shift. {int(w/2)},{int(h/2)},{int(d/2)},0,2
fft.. *... . *[-2,-1] ifft rm[-1]
v +
fx_butterworth_bp:
repeat $! l[$>]
if !$8 split_opacity fi
l[0]
gain={iM} csswap 0,$7
_butterworth_bp ${1-6}
csswap $7,0 if $9 abs fi if $10 * {$gain/iM} fi
done
if !$8 a c fi
done done

fx_butterworth_bp_preview :
if $11
rm
4000,1,1 _bwbp_prepare ${1-6}
columns 50%,100%
1000,500,1,1
f. "cut((i(#-2,2^(x*log2(w)/w-1),0,0,0,2,1)*(255)-y)*127.5,0,255)"
mirror y
r. 50%,100%
k[-1]
else
fx_butterworth_bp ${1-10}
fi

#@gui Broken Texture_Afre: fx_texture_afre_broken, fx_texture_afre_broken_preview(0)
#@gui : note = note("This shouldn't have happened.")
#@gui : sep = separator()
#@gui : P1 = float(1,0,10)
#@gui : P2 = float(10,0,100)
#@gui : Difference = bool(0)

fx_texture_afre_broken:
repeat $! l[$>]
  n 0,255
  if $3 +l fi
  +l
    +l
      if $1 gradient_orientation 2 n 0,1 + y50_afre 0 gradient_norm
      else gradient_norm fi
      b 1,1,1
    done
    *. {255*$2/iM} +
    n 0,255
  done
  +l.. n 0,1 f gauss(i-.5) n 0,1 done
  blend_fade[0,1] . k[0]
  if $3 blend difference fi
done done

fx_texture_afre_broken_preview :
fx_texture_afre_broken $*

#@gui Row Shifter: fx_row_shift, fx_row_shift_preview(0)
#@gui : note = note("Shifts rows.")
#@gui : sep = separator()
#@gui : Order = choice("X then Y","Simultaneous","Y then X")
#@gui : X Shift = float(0,-5,5)
#@gui : X Centre = float(0.5,0,1)
#@gui : Y Shift = float(0,-5,5)
#@gui : Y Centre = float(0.5,0,1)
#@gui : Interpolation = choice(3,"None","Nearest","Average","Bilinear","Grid","Bicubic","Lanczos")
#@gui : Invert Shifts = bool(0)
fx_row_shift :
repeat $! l[$>]
z 0,0,{w+1},{h+1},2
inv={($7*-2)+1}
opt={int(($1-1)*$inv)}
if $opt==-1
f "j((y-h*$3)*$2*"$inv",0,0,0,$6,2)"
f "j(0,(x-w*$5)*$4*"$inv",0,0,$6,2)"
elif $opt==1
f "j(0,(x-w*$5)*$4*"$inv",0,0,$6,2)"
f "j((y-h*$3)*$2*"$inv",0,0,0,$6,2)"
else
if $inv==1
f "j((y-h*$3)*$2*"$inv",(x-w*$5)*$4*"$inv",0,0,$6,2)"
elif $inv==-1
f "j((y-h*$3)*$2*"$inv",(x-w*$5)*$4*"$inv",0,0,$6,2)"
fi
fi
z 0,0,{w-1},{h-1}
done done
fx_row_shift_preview :
fx_row_shift $*

#@gui Fake JFIF (JPEG) Encoder : fx_jfif_fake, fx_jfif_fake_preview(0)
#@gui : note = note("<small>A fake jfif encoder.</small>")
#@gui : Quality (%) = int(50,1,100)
#@gui : Encoding = choice("444","442","424","422")
#@gui : sep = separator()
#@gui : note = note("Fake Glitch")
#@gui : Power = float(0,0,5)
#@gui : Colour Distortion = float(1.25,0,10)
#@gui : Max Tile Error Length = int(5,1,10)
#@gui : Persistent Tile Error Power = float(0.25,0,1)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
#@gui : sep = separator(), note = note("<small>Author: Joan Rake, \'borrowed\' from <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/05/07</i>.</small>")
fx_jfif_fake :
glitch=(0.25^(10-$3))*$3/4
cd=$4
te=$5
ste=$6
base642img "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"
base642img "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"
nm[-2,-1] dct,idct
i[Q] (16,11,10,16,24,40,51,61;12,12,14,19,26,58,60,55;14,13,16,24,40,57,69,56;14,17,22,29,51,87,80,62;18,22,37,56,68,109,103,77;24,35,55,64,81,104,113,92;49,64,78,87,103,121,120,101;72,92,95,98,112,100,103,99)
f. "const S = $1<50?5000/$1:200-2*$1; max(1,round((S*i+50)/100,1,-1))"
repeat $!-3 l[$>,-3--1]
l[0] w,h={[w,h]} r {w+(-w%16)},{h+(-h%16)},1,100%,0,3 rgb2ycbcr s c
if $2==1 r[-2,-1] 100%,50%,1,1,2 elif $2==2 r[-2,-1] 50%,100%,1,1,2 elif $2==3 r[-2,-1] 50%,50%,1,1,2 fi round. done
repeat 3
[$>]
f[$>] "begin(boundary = 2; res = vector64(); chance = "$glitch"; val = 1; errtile = 0; tt=-1; const tlen = "$te"; const sticky = "$ste"; stuck = 0; cold = "$cd");
if (!(x%8) && !(y%8),
src = crop(x,y,8,8);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; u<=chance?(val+=(u(-cold,cold)/10);tt=u(1,tlen);(u<=sticky?stuck=1:stuck=0)); stuck==0?errtile=0; tt>=1?(errtile=u(0,64)); res[off] = sum(val*src*crop(#"$dct",0,0,(off+errtile)%64,8,8,1))));
draw(#-1,res,x,y,0,0,8,8); tt-=1;
); i"
round.
+r[Q] {$>,w},100%,1,1,0,2 /.. . round.. *[-2,-1]
f. "begin(boundary = 2; res = vector64(); chance = "$glitch"; val = 0; errtile = 0; tt=-1; const tlen = "$te"; const sticky = "$ste"; stuck = 0; cold = "$cd");
if (!(x%8) && !(y%8),
src = crop(x,y,8,8);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; u<=chance?(val+=(u(-cold,cold)/10);tt=u(1,tlen);(u<=sticky?stuck=1:stuck=0)); stuck==0?errtile=0; tt>=1?(errtile=u(0,64)); res[off] = sum(val+src*crop(#"$idct",0,0,(off+errtile)%64,8,8,1))));
draw(#"$>",res,x,y,0,0,8,8); tt-=1;
); i"
rm.
round[$>]
done
l[^3--1] r ${-max_wh},1,1,1 a c ycbcr2rgb round. r $w,$h,1,3,0 done
done done
rm[dct,idct,Q]
fx_jfif_fake_preview :
gui_split_preview "fx_jfif_fake $*",${-3--1}

#@gui JFIF Effects : fx_jfif, fx_jfif_preview(0)
#@gui : note = note("<small>A poorly-implemented JFIF encoder with extras, all designed to screw with images. Quite slow and very aggressive.</small>")
#@gui : 1. Quality (%) = int(50,1,100)
#@gui : 2. Encoding = choice(3,"444","442","424","422")
#@gui : sep = separator()
#@gui : note = note("Fake Glitch")
#@gui : 3. Power = float(0,0,10)
#@gui : 4. Colour Distortion = float(1,0,2)
#@gui : 5. Max Glitch Length = int(5,2,10)
#@gui : 6. Max Value Errors Per Tile = int(5,0,10)
#@gui : 7. Error Strength = float(3,0,8)
#@gui : 8. Persistent Value Errors Power = float(0.25,0,1)
#@gui : 9. Error Bias = float(0.5,0,1)
#@gui : 10. Tile Shift Power = float(0.25,0,1)
#@gui : 11. Mirror = choice("None","X","Y","XY")
#@gui : 12. Rotate = choice("None,"90 clockwise","180","90 anticlockwise")
#@gui : sep = separator()
#@gui : note = note("Self-Bomb")
#@gui : 13. Enable = bool(0)
#@gui : 14. Mesh X = int(16,1,256)
#@gui : 15. Mesh Y = int(16,1,256)
#@gui : 16. Mesh Smoothness = float(0.5,0,10)
#@gui : 17. Contrast Scheme = choice(1,"Arctan","Clip","Power)
#@gui : 18. Mesh Contrast = float(75,0,100)
#@gui : 19. Scale X = float(1,0.05,16)
#@gui : 20. Scale Y = float(1,0.05,16)
#@gui : 21. Interpolation = choice(0,"None","Nearest","Average","Bilinear","Grid","Bicubic")
#@gui : 22. Normalise = bool(0)
#@gui : 23. Output Mesh = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
#@gui : sep = separator(), note = note("<small>Author: Joan Rake, \'borrowed\' from <i><a href="https://goo.gl/Ryf7Cv">David Tschumperl&#233;</a></i>.      Latest Update: <i>2017/05/07</i>.</small>")
fx_jfif :
cd={$4^2.5}
gl=$5
ve=$6
es=$7
ste=$8
bias={2^(6-($9*12))}
ts={$10^2}
base642img "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"
base642img "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"
nm[-2,-1] dct,idct
i[Q] (16,11,10,16,24,40,51,61;12,12,14,19,26,58,60,55;14,13,16,24,40,57,69,56;14,17,22,29,51,87,80,62;18,22,37,56,68,109,103,77;24,35,55,64,81,104,113,92;49,64,78,87,103,121,120,101;72,92,95,98,112,100,103,99)
f. "const S = $1<50?5000/$1:200-2*$1; max(1,round((S*i+50)/100,1,-1))"
repeat $!-3 l[$>,-3--1]
gp={(0.25^((10-$3)*log(wh(#0))/30))*$3/10}
ww={w(#0)}
hh={h(#0)}
if $11==1
mirror[0] x
elif $11==2
mirror[0] y
elif $11==3
mirror[0] xy
fi
if $12
rotate[0] {$12*90},0
fi
if $13
www={w(#0)}
hhh={h(#0)}
r[0] {$www*$19},{$hhh*$20},100%,100%,$21
fi
i[G] {w(#0)},{h(#0)},1,1 f[$G] ">begin(chance = "$gp"; tlmax="$gl"; tt=-1; val=0; sticky="$ste");
if (!(x%16) && !(y%16),for (l = 0, l<2, ++l, for (k = 0, k<2, ++k, (u<=chance?((val=1);tt=round(u(1,tlmax))):tt>=0?(val=0;--tt):(u<=sticky?(val=-2):val=-1)); j(k*8,l*8)=val)),0)"
l[0] w,h={[w,h]} r {w+(-w%16)},{h+(-h%16)},1,100%,0,3 rgb2srgb gcd_srgb2jpeg s c
if $2==1 r[-2,-1] 100%,50%,1,1,2 elif $2==2 r[-2,-1] 50%,100%,1,1,2 elif $2==3 r[-2,-1] 50%,50%,1,1,2 fi round. done
bw,bh=8
repeat 3
if $>==1
if $2==1 bh=16 elif $2==2 bw=16 elif $2==3 bh,bw=16 fi
fi
[$>]
f[$>] ">begin(boundary = 2; res = vector64(); gres = vector64(); const cbw="$bw"; const cbh="$bh"; const cbwh=cbw*cbh; glitch=0; const cold="$cd"; gval=1; const errval="$ve"; const bias = "$bias"; const strength="$es");
if (!(x%(128/cbw)) && !(y%(128/cbh)),for (ll = 0, ll<(16/cbw), ++ll, for (kk = 0, kk<(16/cbh), ++kk,
src = crop(x+(ll*8),y+(kk*8),8,8);
gpunch=crop(#"$G",cbw/8*(x+(ll*8)),cbh/8*(y+(ll*8)),cbw,cbh);
max(gpunch)==1?(glitch=1);
glitch==1?(gval=cut(gval+(u(-cold,cold)/15),-1,5);errnum=u(1,errval);for (ve=0,ve<errnum,++ve,gres[floor((u^bias)*8)+floor((u^bias)*8)*8]=ceil(u(-strength,strength)^5))*10);
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = int(gres[off]/10+sum(gval*src*crop(#"$dct",0,0,off,8,8,1)))));
draw(#-1,res,x+(ll*8),y+(kk*8),0,0,8,8);
min(gpunch)<=-1?(glitch=0;errnum=0;tileerror=0;min(gpunch)==-1?gres=vector64(0))))); i"
round.
+r[$Q] {$>,w},100%,1,1,0,2 /.. . round.. *[-2,-1]
dispw={w(#1)}
f. ">begin(boundary = 2; res = vector64(); const cbw="$bw"; const cbh="$bh"; const cbwh=cbw*cbh; glitch=0; const cold="$cd"; gval=0; const dispwidth="$dispw";disp=0;shift="$ts");
if (!(x%(128/cbw)) && !(y%(128/cbh)),for (ll = 0, ll<(16/cbw), ++ll, for (kk = 0, kk<(16/cbh), ++kk,
src = crop((x+(ll*8+cbw*disp))%(dispwidth/cbw*16),y+(kk*8)+cbh*floor((x+cbw*disp)/(dispwidth/cbw*16)),8,8);
gpunch=crop(#"$G",cbw/8*(x+(ll*8)),cbh/8*(y+(ll*8)),cbw,cbh);
max(gpunch)==1?(glitch=1);
glitch==1?((u<=shift?++disp);gval=cut(gval+(u(-cold,cold)/5),-1,5));
for (l = 0, l<8, ++l, for (k = 0, k<8, ++k, off = k + 8*l; res[off] = int(sum(gval+src*crop(#"$idct",0,0,off,8,8,1)))));
draw(#"$>",res,x+(ll*8),y+(kk*8),0,0,8,8);
min(gpunch)<=-1?(glitch=0;errnum=0;min(gpunch)==-1?gres=vector64(0))))); i"
rm.
l[$>] r {w*($bw/8)},{h*($bh/8)},1,1,1 done
round[$>]
done
rm[$G]
l[^4--1] a c gcd_jpeg2srgb srgb2rgb round. r $w,$h,1,3,0
if $13 blend_bomb 1,${14-18},0,0,0,${22-23}
r $www,$hhh,100%,100%,$21 fi
if $12
rotate[0] {-$12*90},0
fi
if $11==1
mirror[0] x
elif $11==2
mirror[0] y
elif $11==3
mirror[0] xy
fi
done
done done
rm[$dct,$idct,$Q]
fx_jfif_preview :
gui_split_preview "fx_jfif $*",${-3--1}

#@gui JFIF Effects Extended : fx_jfif_xt, fx_jfif_xt_preview(0)
#@gui : note = note("<small>A poorly-implemented JFIF encoder with extras, all designed to screw with images. Quite slow and very aggressive.</small>")
#@gui : 1. Quality (%) = float(50,0,100)
#@gui : 2. Size X = int(8,1,100)
#@gui : 3. Size Y = int(8,1,100)
fx_jfif_xt:
ww={w}
hh={h}
qu=$1/100
sx=$2
sy=$3
to_rgb
csswap rgb,ycbcrjpeg
minl=0.05*wh
maxl=0.1*wh
diffx={-w%$sx}
diffy={-h%$sy}
w,h={[w,h]} r {w+$diffx},{h+$diffy},1,100%,0,3
www={w}
hhh={h}
split_tiles -$sx,-$sy
dct f "I*cut(1+(("$sx"+"$sy")*"$qu"-(x+y)),0,1)"
append_tiles {$www/$sx}
f ">begin(const minl="$minl";const maxl="$maxl";cd=round(u(minl,maxl)));
cd-=1;
(cd<=0)?(cd=round(u(minl,maxl));J[0]=[u*50000,u*50000,u*50000]):(J[0])"
split_tiles -$sx,-$sy
idct
append_tiles {$www/$sx}
r {w-$diffx},{h-$diffy},1,100%,0,3
csswap ycbcrjpeg,rgb

fx_jfif_xt_preview:
fx_jfif_xt $*

#@gui DCT FSU: fx_dct_fsu, fx_dct_fsu_preview(0)
#@gui : 1. Operation = choice("Low Pass 1","Low Pass 2","High Pass 1","High Pass 2","Isolate","Plaid","Plaid LP", "Plaid HP","Randomised Spread","Randomised Spread [intense]")
#@gui : 2. X (%) = float(50,0,100)
#@gui : 3. Y (%) = float(50,0,100)
#@gui : 4-5. Shift Before = point(0,0,0,-1,255,127,0,175)
#@gui : 6-7. Shift After = point(100,100,0,-1,127,255,0,175)
#@gui : 8. Absolute = bool(0)
#@gui : 9. Normalise = bool(1)
#@gui : 10. Colour Space = choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 11. Alpha = bool(0)
#@gui : sep = separator(), Preview Type = choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)
fx_dct_fsu:
repeat $! l[$>]
if !$11 split_opacity fi
l[0]
csswap $10,0 dct
shift $4%,$5%,0,0,2
f "
begin(op="$1"; ox=round("$2"*w/100); oy=round("$3"*h/100));
(op==0)?(((x<=ox)&&(y<=oy))?i:0):
(op==1)?(((x<=ox)||(y<=oy))?i:0):
(op==2)?(((x<=ox)||(y<=oy))?0:i):
(op==3)?(((x<=ox)&&(y<=oy))?0:i):
(op==4)?(((x==ox)&&(y==oy))?i:0):
(op==5)?(((x==ox)||(y==oy))?i:0):
(op==6)?((((x==ox)||(y==oy))&&((x<=ox)&&(y<=oy)))?i:0):
(op==7)?((((x==ox)||(y==oy))&&((x>=ox)&&(y>=oy)))?i:0):
(op==8)?(j(round(ox*u(-1,1)^45),round(oy*u(-1,1)^45),0,0,0,2)):
(op==9)?(j(round(ox*u(-1,1)^5),round(oy*u(-1,1)^5),0,0,0,2))
"
shift $6%,$7%,0,0,2
idct
csswap 0,$10
if $8 abs fi
if $9 n 0,255 fi
done
if !$11 a c fi
done done
fx_dct_fsu_preview:
gui_split_preview "fx_dct_fsu $*",${-3--1}
#@gui Superstreak: fx_superstreak, fx_superstreak_preview(0)
#@gui : sep = separator()
#@gui : 1. Random Seed = int(10,0,65535)
#@gui : 2. Iterations = int(10,1,20)
#@gui : 3. Propagation = choice(3,"Backward","Forward","Bidirectional [Sharp]","Bidirectional [Smooth]")
#@gui : 4. Min Threshold = float(0.50,0.00,1.00)
#@gui : 5. Max Threshold = float(0.50,0.00,1.00)
#@gui : 6. Min Step Size = float(10,0,100)
#@gui : 7. Max Step Size = float(30,0,100)

_superstreak :
repeat $! l[$>]
to_rgba
if !$5 T,R,G,B,A=0 else T,R,G,B,A=${1-5} fi +select_color $T,$R,$G,$B,$A
f.. "
const step = max(1,$6%*min(w,h));
const angle = $7*pi/180;
const dx = step*cos(angle);
const dy = step*sin(angle);
if (!i(#-1),I,
ixf = xf = x; iyf = yf = y; lf = 0; if ($8>=1, while (i(#-1,ixf=round(xf),iyf=round(yf)), ++lf; xf-=dx; yf-=dy));
ixb = xb = x; iyb = yb = y; lb = 0; if ($8!=1, while (i(#-1,ixb=round(xb),iyb=round(yb)), ++lb; xb+=dx; yb+=dy));
$8==0?I(ixb%w,iyb%h):
$8==1?I(ixf%w,iyf%h):
$8==2?(lf<lb?I(ixf%w,iyf%h):I(ixb%w,iyb%h)):
(lb*lb*I(ixf%w,iyf%h) + lf*lf*I(ixb%w,iyb%h))/(lb^2+lf^2);;
)"
rm.
done done
fx_superstreak :
srand $1
repeat $! l[$>]
srand {int(u*65535)}
repeat $2
a=((u($4,$5)^2)*512)
b={round(u(0,255))}
c={round(u(0,255))}
d={round(u(0,255))}
e={round(u(0,255))}
f={u($6,$7)}
g={u(0,360)}
_superstreak {$a},{$b},{$c},{$d},{$e},{$f},{$g},$3
done
done done
fx_superstreak_preview :
fx_superstreak $*

#@gui UltraWarp 3: fx_ultrawarp3_preview
#@gui : sep = separator()
#@gui : 0. Recompute = button()
#@gui : 1. Random Seed = int(-1,-1,65535)
#@gui : 2. Iterations = int(1,1,10)
#@gui : 3. Warp Magnitude = float(1,0,10)
#@gui : 4. WM Range = float(1,0,10)
#@gui : 5. Warp Angle = float(0,0,360)
#@gui : 6. WA Range = float(360,0,360)
#@gui : 7. Offset Magnitude = float(1,0,100)
#@gui : 8. OM Range = float(1,0,100)
#@gui : 9. Offset Angle = float(0,0,360)
#@gui : 10. OA Range = float(360,0,360)
#@gui : 11. Correlated Channels = bool(0)
#@gui : 12. Interpolation = choice(1,"Nearest Neighbor","Linear")
#@gui : 13. Boundary = choice(3,"Transparent","Nearest","Periodic","Mirror")
#@gui : 14. Colour Space = choice("RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : sep = separator()
#@gui : 15. Channel(s) = choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui : "Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui : "YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui : "YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui : "Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui : "HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui : "CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
_fx_uw3:
#pre
[0]
#image to warp
#warping field
if $5 f.. "ni = norm(R,G,B); I(#0) = J(#1,(ni)*$1-$3,(ni)*$2-$4,0,2,3)"
else f.. "i(#0)=j(#1,(i)*$1-$3,(i)*$2-$4,0,0,2,3)"
fi
rm[1]
#post

fx_ultrawarp3:
if $1!=-1 srand $1 fi
num=$2
wm=$3
wmr=$4
wa={$5*pi/180}
war={$6*pi/180}
om=$7
omr=$8
oa={$9*pi/180}
oar={$10*pi/180}
cc=$11
inter=$12
bound=$13
cs=$14
channels=$15
csswap 0,$14
repeat $! l[$>]
om*={norm(w,h)*0.001}
omr*={norm(w,h)*0.001}
srand {int(u*65535)}
repeat $2
wmag={((($wm+(u-0.5)*$wmr)*0.1)^2)*10}
omag={((($om+(u-0.5)*$omr)*0.1)^2)*10}
wangle={$wa+(u-0.5)*$war}
oangle={$oa+(u-0.5)*$oar}
wx={$wmag*sin(-$wangle%(2*pi))}
wy={$wmag*cos(-$wangle%(2*pi))}
ox={$omag*sin(-$oangle%(2*pi))}
oy={$omag*cos(-$oangle%(2*pi))}

ac "
_fx_uw3 "$wx","$wy","$ox","$oy","$cc","$inter","$bound"",$channels
done
csswap $14,0
done done

fx_ultrawarp3_preview :
fx_ultrawarp3 ${2-16}

##@gui Cubism: fx_jr_rep_cubism_preview
#@gui : sep = separator()
#@gui : 0. Recompute = button()
#@gui : 1. Density=float(15,0,100)
#@gui : 2. Details Influence=float(50,0,100)
#@gui : 3. X Offset Centre=float(0,-100,100)
#@gui : 4. X Offset Range=float(25,0,200)
#@gui : 5. Y Offset Centre=float(0,-100,100)
#@gui : 6. Y Offset Range=float(25,0,200)
#@gui : 7. Z Offset Centre=float(0,-100,100)
#@gui : 8. Z Offset Range=float(0,0,200)
#@gui : 9. Rot Angle Centre=float(0,-360,360)
#@gui : 10. Rot Angle Range=float(360,0,360)
#@gui : 11. Rot Axis X Centre=float(0,-1,1)
#@gui : 12. Rot Axis X Range=float(0,0,2)
#@gui : 13. Rot Axis Y Centre=float(0,-1,1)
#@gui : 14. Rot Axis Y Range=float(0,0,2)
#@gui : 15. Rot Axis Z Centre=float(1,-1,1)
#@gui : 16. Rot Axis Z Range=float(0,0,2)
#@gui : 17. AA Iterations=int(16,0,100)
#@gui : 18. Sharpness=float(0,0,2)
#@gui : 19. AA Anisotropy=float(1,0,1)
#@gui : 20. AA Gradient Smoothness=float(1,0,10)
#@gui : 21. Tensor Smoothness=float(5,0,10)
#@gui : 22. Time Step=float(15,5,50)


fx_jr_rep_cubism:
to_gray
# initial parameters for all images
rotac=$9
rotar=$10
rotxxc=$11
rotxxr=$12
rotxyc=$13
rotxyr=$14
rotxzc=$15
rotxzr=$16
aa=$17
repeat $! l[$>]
# initial parameters for each image
ww={w}
hh={h}
dd={d}
xoffc=$3*0.01*$ww
xoffr=$4*0.01*$hh
yoffc=$5*0.01*$dd
yoffr=$6*0.01*$ww
zoffc=$7*0.01*$hh
zoffr=$8*0.01*$dd
+gradient_norm
100%,100%,100%,2,'begin(n=-1);u<lerp(0.5,i(-1),$2%)*($1%)^4?(n+=1;[n,1])' s. c
distance. 1 *. -1  watershed.. . rm[1,3]
label.	# labelling the segments of the copied image
l[1]
# get the edges of the segment and find the distance to the nearest pixel on the other side of the nearest edge for each pixel in terms of x, y and z components
# this will be used for the anti-aliasing later on
+gradient_orientation. 3
a[^0] c
100%,100%,100%,1,"min(1,ceil(norm(I(#1))))"
rm[1]
+distance. 1
+gradient_orientation. 3
f[2] "(i)"  # experimenting with this to find a good distance offset, should really be (i+0.5) for true distance to edge
a[2-5] c
*[^0] 255
smooth[^0] $aa,${18-22},0
/[^0] 255
abs[1]
done
# uncomment this to blur this distance-to-edge image, was just another experiment but could be used to highlight the problem in a clearer way
# b. 2
# approximate the centre of each segment and store the x, y and z components in a new image which will store more parameters later
# this image's x coordinate is the segment id as specified in the labelled segment image (#1)
initsize={1+iM#1}
$initsize,10,1,1
vsize={$initsize*3}
eval ${-math_lib}"
coordinates_per_val=vector"$vsize"(0);
count_per_val=vector"$initsize"(0);
for(px=0,px<w#1,px++,
 for(py=0,py<h#1,py++,
  for(pz=0,pz<d#1,pz++,
   pos=i(#1,px,py,pz);
   coordinates_per_val[pos*3]+=px;
   coordinates_per_val[pos*3+1]+=py;
   coordinates_per_val[pos*3+2]+=pz;
   count_per_val[pos]++;
  );
 );
);
for(n=0,n<"$initsize",n++,
 coordinates_per_val[n*3]/=count_per_val[n];
 coordinates_per_val[n*3+1]/=count_per_val[n];
 coordinates_per_val[n*3+2]/=count_per_val[n];
 I(n,0)=coordinates_per_val[n*3];
 I(n,1)=coordinates_per_val[n*3+1];
 I(n,2)=coordinates_per_val[n*3+2];
);
"

# add pseudo-randomised parameters for each segment id to the parameters image
sh. 3,9,0,0 f. ">begin(randm=u(100,200);randa=u(1,3));srand((x+(randa)+(u))*(randm+y));u(-1,1)"
eval. "begin(multvec=["$xoffr","$yoffr","$zoffr","$rotar","$rotxxr","$rotxyr","$rotxzr"];
addvec=["$xoffc","$yoffc","$zoffc","$rotac","$rotxxc","$rotxyc","$rotxzc"]);
for(n=0,n<w,n++,
strip=crop(n,0,0,0,1,7,1,1);
draw(#5,(strip*multvec)+addvec,n,0,0,0,1,7,1,1,1))"
rm.
# let's put all of this together now
f[0] "critical(begin(const spec=s;aa="$aa";
cubism(id,xx,yy,zz)=( # this function warps a given pixel using the parameters assigned to a specified id within the parameters image
params=crop(#4,id,0,0,0,1,10,1,1);
# get segment centre
xc=params[0];
yc=params[1];
zc=params[2];
# get offsets
xoff=params[3];
yoff=params[4];
zoff=params[5];
# get rotation angle and axis
ang=params[6];
xa=params[7];
ya=params[8];
za=params[9];
# rotate and offset
vx=xx-xc-xoff;
vy=yy-yc-yoff;
vz=zz-zc-zoff;
pix=[xa,ya,za];
select=(rot(asin(pix/norm(pix))*2/pi,ang)*[vx,vy,vz])+[xc,yc,zc];
# return the new pixel value
I(select,1,3)));
# anti-aliasing only if the setting's enabled and we're at a pixel where the mask (#4) has a non-zero value
(aa&&(i(#2)>0))?(
# get the displacements necessary to reach the nearest pixel on the other side of the nearest edge
dist=i(#3,x,y,z,0);
xdist=i(#3,x,y,z,1)*dist;
ydist=i(#3,x,y,z,2)*dist;
zdist=i(#3,x,y,z,3)*dist;
# trilinear interpolation to determine the value of the nearest pixel behind the nearest edge
# we don't have to run cubism() eight times for each pixel here since we can instead make a weighted histogram of ids
idlist=vector(#8,-1);
freqlist=vector(#8,0);
idnum=0;
xint=floor(xdist);yint=floor(ydist);zint=floor(zdist);
xo=xdist-xdist;yo=ydist-ydist;zo=zdist-zdist;
gridmult=[(1-xo)*(1-yo)*(1-zo),xo*(1-yo)*(1-zo),(1-xo)*yo*(1-zo),xo*yo*(1-zo),(1-xo)*(1-yo)*zo,xo*(1-yo)*zo,(1-xo)*yo*zo,xo*yo*zo];
for(pz=0,pz<2,pz++,
 for(py=0,py<2,py++,
  for(px=0,px<2,px++,
   curr=i(#1,x+xint+px,y+yint+py,z+zint+pz,0,1,0);
   pos=find(idlist,curr);
   pos==-1?(idnum+=1;pos=find(idlist,-1);idlist[pos]=curr);
   freqlist[pos]+=gridmult[(pz*4)+(py*2)+px];
  );
 );
);
val=0; # val=vector(#spec,0);
for(n=0,n<idnum,n++,
# construct the final value for the interpolated pixel
val+=idlist[n]*freqlist[n]);
# interpolate between that pixel and the current one in accordance with the AA mask
lerp(val,i(#1,x,y,z,0,1,1),1-(i(#2)*0.5))):
# if we don't need any AA, we can just use the current pixel
(i(#1,x,y,z,0,1,1)))
"
# clean up now that we're done
rm[^0]
done done
to_rgb
n 0,255
fx_jr_rep_cubism_preview:
fx_jr_rep_cubism ${2-23}


#@gui Multi-Mosaic: fx_jr_multi_mosaic_preview
#@gui : sep = separator()
#@gui : 0. Recompute = button()
#@gui : 1. Iterations=int(3,1,10)
#@gui : sep = separator(), note = note("<small><b>Mosaic</b></small>")
#@gui : 2. Lowest Density=float(15,0,100)
#@gui : 3. Highest Density=float(45,0,100)
#@gui : 4. Details Influence=float(50,0,100)
#@gui : 5. Details Smoothness=float(0,0,100)
#@gui : 6-8. Colour Balance=color(128,128,128)
#@gui : 9. Luma Range = float(0,0,100)
#@gui : 10. Chroma Range = float(0,0,100)
#@gui : 11. Hue Range = float(0,0,100)
#@gui : sep = separator(), note = note("<small><b>Edges [Gradient Norm]</b></small>")
#@gui : 12. Opacity=float(1,-1,1)
#@gui : 13. Smoothness=float(0,0,10)
#@gui : 14. Linearity=float(0.5,0,1.5)
#@gui : 15. Min Threshold=float(0,0,100)
#@gui : 16. Max Threshold=float(100,0,100)
#@gui : 17. Thickness=int(1,1,10)
#@gui : 18-20. Color = color(0,0,0)
#@gui : 21. Luma Range = float(0,0,100)
#@gui : 22. Chroma Range = float(0,0,100)
#@gui : 23. Hue Range = float(0,0,100)
#@gui : sep = separator(), note = note("<small><b>Final Edge Blend</b></small>")
#@gui : 24. Edge Blend=bool(1)
#@gui : 25. Smoothness=float(15,0,100)
#@gui : sep = separator(), note = note("<small><b>Smooth [Diffusion]</b></small>")
#@gui : 26. Iterations=int(16,0,100)
#@gui : 27. Sharpness=float(0.5,0,2)
#@gui : 28. Anisotropy=float(1,0,1)
#@gui : 29. Gradient Smoothness=float(3,0,10)
#@gui : 30. Tensor Smoothness=float(5,0,10)
#@gui : 31. Time Step=float(15,5,50)
#@gui : sep = separator(), note = note("<small><b>Local Normalization</b></small>")
#@gui : 32. Amplitude=float(2,0,60)
#@gui : 33. Radius=int(6,1,64)
#@gui : 34. Neighborhood Smoothness=float(5,0,40)
#@gui : 35. Average Smoothness=float(20,0,40)
#@gui : 36. Constrain Values=bool(1)
#@gui : 37 .Channel(s)=choice(2,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")

fx_jr_multi_mosaic:
to_rgba
repeat $! l[$>]
repeat $1 +l[0]
+gradient_norm n. 0,1 b. $5
100%,100%,100%,2,'u<lerp(0.5,i(#1),$4%)*((lerp($2,$3,($>/max(1,($1-1))))*0.01))^4?[u,1]'  s. c
distance. 1 *. -1  watershed.. . rm[1,3]
blend shapeaverage
1,1,1,3,([$6,$7,$8]) rgb2lch8. f. "I+[u(-255,255)*$9%,u(-255,255)*$10%,u(-255,255)*$11%]" lch82rgb.  fx_balance_gamma.. {I(#-1,0,0,0)},0 rm.
+to_rgb.
fx_gradient_norm. ${13-16},0 dilate_circ $17 to_rgba. 1,1,1,3,([$18,$19,$20]) rgb2lch8. f. "I+[u(-255,255)*$21%,u(-255,255)*$22%,u(-255,255)*$23%]" lch82rgb. f.. "[I(#-1,0,0,0),($12<0?255-i0:i0)*abs($12)]" rm.
blend alpha
done done
rm[0]
if $24 blend_edges $25 fi
smooth ${26-31},0
done done
fx_normalize_local ${32-37}
fx_jr_multi_mosaic_preview :
fx_jr_multi_mosaic ${2-38}


rgb2lms :
# model properties: reference white, reference illuminant, surround ratio, adapting field luminance
# reference white in XYZ
wx=95.047
wy=100
wz=108.883
# reference illuminant wr in XYZ
wrx=95.047
wry=100
wrz=108.883
# surround ratio
sr=0.2
# adapting field luminance
la=(10^2)
# relative background luminance
yb=1


factor={min((0.8+$sr),1)}
adapt=($factor*(1-(exp(-($la+42)/92))/3.6))
kmm=(1/((5*$la)+1))
flmm=($kmm^4*$la+0.1*(1-$kmm^4)^2*(5*$la)^1/3)
1,1,1,3,"["$wx","$wy","$wz"]*0.01"
1,1,1,3,"["$wrx","$wry","$wrz"]*0.01"
(0.7328,0.4296,-0.1624;-0.7036,1.6975,0.0061;0.003,0.0136,0.9384) +invert. # cat02 matrix and its inverse
+mix_channels[-4,-3] [-1]
lumcorr={i(#-6,0,0,0,1)/i(#-5,0,0,0,1)}
lmult={i(#-1,0,0,0,0)/i(#-2,0,0,0,0)}
mmult={i(#-1,0,0,0,1)/i(#-2,0,0,0,1)}
smult={i(#-1,0,0,0,2)/i(#-2,0,0,0,2)}
rm[-2,-1]

to_rgb[0] rgb2xyz[0] 1 f[0] "I/[0.95047,1,1.08883]"
mix_channels[0] [-2]
f[0] "begin(n=("$lumcorr"*["$lmult","$mmult","$smult"]*"$adapt")+1-"$adapt");n*I"
mix_channels[0] [-1]
(0.38971,0.68898,-0.07868;-0.22981,1.1834,0.04641;0,0,1)
mix_channels[0] [-1]
rm.
f[0] "temp=("$flmm"*abs(I))^0.42;
sign(I)*400*(temp/(temp+27.13))+0.1"
rm[^0]

lms2rgb :
# model properties: reference white, reference illuminant, surround ratio, adapting field luminance
# reference white in XYZ
wx=95.047
wy=100
wz=108.883
# reference illuminant wr in XYZ
wrx=95.047
wry=100
wrz=108.883
# surround ratio
sr=0.2
# adapting field luminance
la=(10^2)
# relative background luminance
yb=1

factor={min((0.8+$sr),1)}
adapt=($factor*(1-(exp(-($la+42)/92))/3.6))
kmm=(1/((5*$la)+1))
flmm=($kmm^4*$la+0.1*(1-$kmm^4)^2*(5*$la)^1/3)
1,1,1,3,"["$wx","$wy","$wz"]*0.01"
1,1,1,3,"["$wrx","$wry","$wrz"]*0.01"
(0.7328,0.4296,-0.1624;-0.7036,1.6975,0.0061;0.003,0.0136,0.9384) +invert. # cat02 matrix and its inverse
+mix_channels[-4,-3] [-1]
lumcorr={i(#-6,0,0,0,1)/i(#-5,0,0,0,1)}
lmult={i(#-1,0,0,0,0)/i(#-2,0,0,0,0)}
mmult={i(#-1,0,0,0,1)/i(#-2,0,0,0,1)}
smult={i(#-1,0,0,0,2)/i(#-2,0,0,0,2)}
rm[-2,-1]

f[0] "(sign(I-0.1)*(1/"$flmm")*((27.13*abs(I-0.1))/(400-abs(I-0.1)))^(1/0.42))"
(0.38971,0.68898,-0.07868;-0.22981,1.1834,0.04641;0,0,1) invert.
mix_channels[0] [-1]
rm.
mix_channels[0] [-2]
f[0] "begin(n=("$lumcorr"*["$lmult","$mmult","$smult"]*"$adapt")+1-"$adapt");I/n"
mix_channels[0] [-1]
f[0] "I*[0.95047,1,1.08883]" xyz2rgb[0] 1
rm[^0]

dct_tileset:
{$1^2},{$2^2},1,1
f. :"begin(const tw=$1;const th=$2;const stw=sqrt(tw);const sth=sqrt(th);const itw=1/tw;const ith=1/th;const istw=sqrt(itw);const isth=sqrt(ith);const s2=sqrt(2));
px=x%tw;
py=y%th;
tx=(x-(px))*itw;
ty=(y-(py))*ith;
cx=cos((tx*0.5+((tx+0.5)*x*itw))*pi)*istw;
cy=cos((ty*0.5+((ty+0.5)*y*ith))*pi)*isth;
px!=0?(cx*=s2);
py!=0?(cy*=s2);
val=cx*cy;
val;
"

idct_tileset:
{$1^2},{$2^2},1,1
f. :"begin(const tw=$1;const th=$2;const stw=sqrt(tw);const sth=sqrt(th);const itw=1/tw;const ith=1/th;const istw=sqrt(itw);const isth=sqrt(ith);const s2=sqrt(2));
px=x%tw;
py=y%th;
tx=(x-(px))*itw;
ty=(y-(py))*ith;
cx=cos((x+0.5)*tx*pi*itw)*istw;
cy=cos((y+0.5)*ty*pi*ith)*isth;
tx!=0?(cx*=s2);
ty!=0?(cy*=s2);
val=-cx*cy*(((tx+ty)%2)*2-1);
val;
"

rgb2ycbcrjpeg :

rgb2srgb gcd_srgb2jpeg

ycbcrjpeg2rgb :

gcd_jpeg2srgb srgb2rgb

rgb2jzczhz :
afre_jchz

jzczhz2rgb :
afre_ijchz


#@gui JPEG Encoder: fx_jpeg_preview
#@gui : sep = separator()
#@gui : 1. Quality=float(80,0,100)
#@gui : 2. Colour Space = choice(21,"RGB","sRGB","CMY","RYB","Ohta8","Ohta","YES8","YES","Kodak 1-8","Kodak1","Lab8","Lab","Oklab","LUV","Jzazbz","YIQ8","YIQ","YUV8","YUV","YCbCr","YCbCrGLIC","YCbCrJPEG","YDbDr","XYZ8","XYZ","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","JzCzHz","HCY")
#@gui : 3. Channel 1 Block Width = int(8,2,32)
#@gui : 4. Channel 1 Block Height = int(8,2,32)
#@gui : 5. Channel 2 Block Width = int(16,2,32)
#@gui : 6. Channel 2 Block Height = int(16,2,32)
#@gui : 7. Channel 3 Block Width = int(16,2,32)
#@gui : 8. Channel 3 Block Height = int(16,2,32)
#@gui : Toggle Block Offsets = bool(0)
#@gui : 9. Channel 1 Block X Offset = int(0,-32,32)
#@gui : 10. Channel 1 Block Y Offset = int(0,-32,32)
#@gui : 11. Channel 2 Block X Offset = int(0,-32,32)
#@gui : 12. Channel 2 Block Y Offset = int(0,-32,32)
#@gui : 13. Channel 3 Block X Offset = int(0,-32,32)
#@gui : 14. Channel 3 Block Y Offset = int(0,-32,32)

fx_jpeg :
to_rgb

inum=$!
q=$1
cs=$2
($3,$5,$7;$4,$6,$8;0,0,0;$9,$11,$13;$10,$12,$14)
nm. params

eval. "begin(index=0;list=transpose(crop(0,0,3,2),3);foundlist=vector6(0));
for(n=0,n<3,++n,
pos=n*2;
cp=list[pos,2];
(find(foundlist,cp,0,2)==-1)?(
index=find(foundlist,[0,0],0,2);
foundlist[index]=cp[0];
foundlist[index+1]=cp[1]);
i(n,2)=find(foundlist,cp,0,2)*0.5
);"

tcount=0
repeat 3
tnum={i(#$params,$>,2)}
if $tnum==$tcount
tw={i(#$params,$>,0)}
th={i(#$params,$>,1)}
dct_tileset $tw,$th
idct_tileset $tw,$th
# nm[-2,-1] "dct"$tcount"","idct"$tcount""
tcount+=1
fi
done

repeat $inum l[$>,{(-2*$tcount)-1}--1]

csswap[0] 0,$cs s[0] c

repeat 3
cw={w(#0)}
ch={h(#0)}
tw={i(#$params,$>,0)}
th={i(#$params,$>,1)}
tn={i(#$params,$>,2)}
ox={-i(#$params,$>,3)%$tw}
oy={-i(#$params,$>,4)%$th}
imax=0
imin=0
l[$>]
imax={iM}
imin={im}
if $imax!=$imin
- $imin * {1/($imax-$imin)}
else
+ {1-$imax}
fi
done

z[$>] {-$ox},{-$oy},{$cw+((-$cw)%$tw)-1-$ox},{$ch+((-$ch)%$th)-1-$oy},3
[$>]
f[$>] :"
begin(const tw="$tw";const th="$th";const twh=tw*th;const tn="$tn";const tileset=(tn-"$tcount")*2-1);
if (!(x%tw) && !(y%th),
res=vector(#twh,0);
ref(crop(x,y,tw,th),src);
for (l = 0, l<th, ++l, for (k = 0, k<tw, ++k,
off = k + tw*l;
res += src[off]*crop(#tileset,k*tw,l*th,tw,th,1))); # ?
draw(#-1,res,x,y,0,0,tw,th);
); i"

f. :"begin(const factor=sqrt("$tw"*"$th");const invfactor=1/factor; const qual=(1-("$q"*0.01))^4);factor*round(i*invfactor,qual)"

f. :"
begin(const tw="$tw";const th="$th";const twh=tw*th;const tn="$tn";const tileset=(tn-"$tcount")*2);
if (!(x%tw) && !(y%th),
res=vector(#twh,0);
ref(crop(x,y,tw,th),src);
for (l = 0, l<th, ++l, for (k = 0, k<tw, ++k,
off = k + tw*l;
res += src[off]*crop(#tileset,k*tw,l*th,tw,th,1))); # ?
draw(#"$>",res,x,y,0,0,tw,th);
); i"
rm.
l[$>]
if $imax!=$imin
* {($imax-$imin)} + $imin
else
+ {$imax-1}
fi
done

z[$>] $ox,$oy,{$cw-1+$ox},{$ch-1+$oy},3

done
a[0-2] c  csswap[0] $cs,0

done done

rm[{(-2*$tcount)-1}--1]


fx_jpeg_preview:

if $9
o0,o1,o2,o3,o4,o5=${10-15}
else
repeat 6
o$>=0
done
fi
fx_jpeg ${1-8},$o0,$o1,$o2,$o3,$o4,$o5

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{"$o0"}_"{$9?2:0}\
"{"$o1"}_"{$9?2:0}\
"{"$o2"}_"{$9?2:0}\
"{"$o3"}_"{$9?2:0}\
"{"$o4"}_"{$9?2:0}\
"{"$o5"}_"{$9?2:0}\
######################

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
