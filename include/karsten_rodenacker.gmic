#@gmic
#
#  File        : karsten_rodenacker.gmic
#                ( G'MIC and G'MIC-Gimp commands file )
#
#  Description : Define several gmic commands
#
#  Copyright   : Karsten Rodenacker
#
#  License     : CeCILL v2.0
#                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://www.cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#@gui _<b>Testing</b>
#@gui KaRo's Tests

#@gui About : _none_, karos_about
#@gui : note = note{"KaRo's test files for <b>G'MIC</b>\n\written by"}
#@gui : note = link("Karsten Rodenacker","http://K.Rodenacker.de")
#@gui : note = note{"\n"}
#@gui : note = note{"The source code of this set of filters is available at :"}
#@gui : note = link("https://github.com/dtschump/gmic-community/blob/master/karsten_rodenacker.gmic")
#@gui : sep = separator()
#@gui : note = note{"Several operations here rely on executables existing <i>in search PATH</i> ($PATH unter Mac/Unix).
#@gui : This means that the executable is downloaded or built and properly located.
#@gui : E. g. CImg examples have to be built and copied to a location in the search path, e.g. under unix <i>/usr/local/bin</i>.
#@gui : Similar with PINK executables. For Mac they have to be built according the README with <i>./makelin</i>
#@gui : and PATH as to be extended by <i>..pink location../linux/bin</i>."}
#@gui : sep = separator()
#@gui : note = note{"  CImg Skeleton: <i>use_skeleton</i> in search PATH"}
#@gui : note = link("https://github.com/dtschump/CImg/blob/master/examples/use_skeleton.cpp")
#@gui : note = note{"  CImg nlmeans: <i>use_nlmeans</i> in search PATH"}
#@gui : note = link("https://github.com/dtschump/CImg/blob/master/examples/use_nlmeans.cpp")
#@gui : note = note{"  mM Differences: \nmathematical morphology operation differences\nmM operation size - mM operation size2"}
#@gui : note = note{"  oC Differences: \nmathematical morphology open/close differences\nmM open size - mM close size"}
#@gui : note = note{"  Pink operations binary: <i>Pink applications</i> in search PATH"}
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/index.html")
#@gui : sep = separator()
#@gui : note = note{"\nThe functions defined are quite <i>experimental</i> and subject to changes.
#@gui : Please do not rely on the fact that they will perform equally forever."}
karos_about :
  fx_logo_version{round(u(0.5,3.49))} $_version [0] *. 0 text. "KaRo's",10%,22%,57,1,255 text. "Tests",40%,60%,57,1,200
  +to_gray. skeleton. , n[-1--2] 0,255 dilate.. 2 -[-1--2] + n 0,255

#------------------------------------
#
#@cli :: PINK-library operators
#
#------------------------------------

_wrbytepnk :
  output_pink3d ${1}.pnk

_xpink :
  na={-1,n}
  filename=${-file_rand}
  x_filename={/$filename}
  if {if(isval($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0} verb=" 2>&1" else verb=" >/dev/null 2>&1" fi
  if {if(isval($GMIC_PINK_NO_RM),0$GMIC_PINK_NO_RM,0)>0} no_rm=1 else no_rm=0 fi
  prefix=pink.
  if {!${-is_windows}}
    -x "which "${prefix}${1}$verb
    if {${}!=0} prefix=""
      -x "which "$1$verb
      if {${}!=0} v + error "Executable (pink.)"$1" not found in PATH, status = "${}"!! Returning!!\n" fi
    fi
    output_pink3d ${filename}.pnk -x ${prefix}${1}" "${filename}".pnk $2 "${filename}"_o.pnk"$verb
  else
    output_pink3d ${filename}.pnk -x $1" "${x_filename}".pnk $2 "${x_filename}"_o.pnk"
  fi
  status=${}
  if {!$no_rm} file_rm ${x_filename}.pnk fi
  if {$status!=0" && "['"$1"']!='seuilauto'} v + error "Exec status is "${status}"."
  elif ${filename}_o.pnk i ${filename}_o.pnk file_rm ${x_filename}_o.pnk k. nm. $na
  else v + error "Exec error!!"
  fi

_xpinks :
  s={s} if {$s>1} s. c fi
  repeat $! l[$>]  _xpink $1,"$2" k. endl done
  if {$s>1} a[-$s--1] c fi

_xframe :
  line 0%,0%,100%,0% line 0%,100%,100%,100% line 0%,0%,0%,100% line 100%,0%,100%,100%

#@cli output_pink3d : filename,_type
#@cli : Save selected images as _type-coded (P5,P8,P9) PPM files (PINK extension for 3d volumetric images).
output_pink3d : skip ${2=P5}
  e[^-1] "Output image$? as file '$1' (in 3d pink extension of "$2"-coded PPM format)."
  v - if {$!==1} filename0="$1"
  else repeat $! filename$>=${filename\ "\"$1\"",$>} done
  fi
  repeat $! l[$>]
    if {['"$2"']=='P5'}
      if {d==1} o. ppm:${filename$>}  # 2d image, save as regular PPM format.
      else                            # 3d image, save as PINK PPM extension.
        ({'P5\n{w}\ {h}\ {d}\n255\n'})
        +channels.. 0 y. x a[-2,-1] x
        o. raw:${filename$>},uchar
        rm.
      fi
    elif {['"$2"']=='P8'}
      ({'P8\n{w}\ {h}\ {d}\n{iM}\n'})
      +channels.. 0 cast. uint,uchar y[-2,-1] x a[-2,-1] x
      o. raw:${filename$>},uchar
      rm.
    elif {['"$2"']=='P9'}
      ({'P9\n{w}\ {h}\ {d}\n{ceil(iM)}\n'})
      +channels.. 0 cast. float,uchar y[-2,-1] x a[-2,-1] x
      o. raw:${filename$>},uchar
      rm.
    else error "Type "$2"not implemented!" fi
  endl done v +

#@cli pinkxipo : [b1],..[bn],name,pn+2, .. ,pm
#@cli : Pink wrapper pinkxipo[a] [b1,..bn,]name(pn+1)[,pn+2, .. ,pm] (requires the PINK library to be installed).
#@cli : Executables with 1, 2-n input image files (xi), pos. parameters (p), output file (o)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/)
#@cli : prepares input, calls external "name inputa [inputb1 ... inputbn] [pn+2 ... pm] output" and reads output (/tmp)
#@cli : Add. images are located before the pink executable name. If images are replaced by a parameter,
#@cli : e.g. null, than it has to be located after the executable name!
#@cli : $ sp 1 ir. 0,50% +pinkxipo. distc,3 +negate.. +pinkxipo... dist,3 pinkxipo[1] [0],bisector pinkxipo[3] [2],bisector k[0,1,3] a c
#@cli : $ sp 2 +pinkxipo. dilatballnum,5 +-
#@cli : $ sp 1 ir. 0,50% +pinkxipo. dilatballnum,10 +pinkxipo.. .,distgeo,4
#@cli : $ sp 1 +pinkxipo. seuilauto,128,max,3
pinkxipo :
  e[^0] "Pink cmd "$* v -
  $=var
  p=1
  na={n}
  for {$#>=$p&&${-is_image_arg\ ${var$p}}} pass${var$p} p+=1 done pl=$p-1
  exec=${var$p} p+=1
  if {$#==$p} pp=${var$p}
  elif {$#>$p} repeat {$#-$p+1} if {$>==0} pp=${var$p} else pp=$pp" "${var$p} fi p+=1 done
  else pp="" fi
  filename=${-file_rand}
  if {if(isval($GMIC_PINK_VERBOSE),0$GMIC_PINK_VERBOSE,0)>0} verb=" 2>&1" else verb=" >/dev/null 2>&1" fi
  if {if(isval($GMIC_PINK_NO_RM),0$GMIC_PINK_NO_RM,0)>0} no_rm=1 else no_rm=0 fi
  echo_stdout $verb
  if {!${-is_windows}}
    prefix=pink.
    x "which "$prefix$exec$verb
    if {${}!=0} prefix="" x "which "$exec$verb
      if {${}!=0} error "executable (pink.)"$exec" not found in PATH, status = "${}"!! Returning!!\n" return fi
    fi
  else prefix="" fi
  ni=$!
  repeat $!
    if {iM#$>>255} output_pink3d[$>] ${filename}$>.pnk,P8 else output_pink3d[$>] ${filename}$>.pnk fi
    if {$>==0} il=${filename}$>.pnk else il=$il","${filename}$>.pnk fi done
  ilk=${-karo_li2st\ $il}
  cmd=$prefix$exec\ $ilk\ $pp\ ${filename}"_o.pnk"$verb
  e $cmd
  x $cmd
  status=${}
  if {!$no_rm} repeat $ni file_rm ${-arg\ {$>+1},$il} done fi
  if {$status!=0" && "['$exec']!='seuilauto'} v + error $exec" Status is "$status"." return
  elif ${filename}_o.pnk i ${filename}_o.pnk file_rm ${filename}_o.pnk k. nm $na~
  else error "exec Error!!" fi
  v +

#@cli pink
#@cli : Pink wrapper name,p1,...,pn (requires the PINK library to be installed).
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/)
#@cli : prepares input, calls external "name input p1...pn output" and reads output (/tmp)
#@cli : $ image.jpg +pink asfr,5 pink[0] asf,5
#@cli : $ image.jpg +blur 2 pink maxima,4
pink : v -
  if {$#>1} ({"'${2--1}'"}) replace. {','},{"' '"} p={t} rm. else p=" " fi
  v + e[^-1] "Call pink package on image$? with cmd: \"$1 [img] "$p" [img]\"." v -
  repeat $! l[$>] _xpinks $1,$p endl done v +

#@cli pink_grayskel : _connectivity={ 4 | 8 | 6 | 26 }, _lambda=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/grayskel_8c.html)
#@cli : Grayscale homotopic skeleton (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'lambda=0'.
#@cli : $ image.jpg +pink_grayskel , +pink_grayskel[0] ,10 +pink_grayskel[0] ,100 append_tiles 2
pink_grayskel : skip ${1=4},${2=0}
  check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  repeat $! l[$>] _xpinks "grayskel","null $1 $2" endl done

#@cli pink_heightmaxima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/heightmaxima_8c.html)
#@cli : Heightmaxima filtering (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'height=1'.
#@cli : $ image.jpg +blur 2 +pink_heightminima ,15 +pink_heightmaxima[0,1] ,15 -[-3,-1] -[-3,-1] keep[-1,-2]
pink_heightmaxima : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=1}
  e[^-1] "Filter by heightmaxima exec with connectivity $1 height $2."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    repeat $! l[$>] _xpink "heightmaxima","$1 $2" k. endl done
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli pink_heightminima : _connectivity={ 4 | 8 | 6 | 26 },_height=1
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/heightminima_8c.html)
#@cli : Heightminima filtering (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'height=1'.
#@cli : $ image.jpg +blur 2 +pink_heightminima ,15 +pink_heightmaxima[0,1] ,15 -[-3,-1] -[-3,-1] keep[-1,-2]
pink_heightminima : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=1}
  e[^-1] "Apply filter by heightminima exec with connectivity $1 height $2."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    repeat $! l[$>] _xpink "heightminima","$1 $2" k. endl done
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli pink_htkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/htkern_8c.html)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/htkernu_8c.html)
#@cli : Grayscale ultimate homotopic thinning/thickening without condition (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'type=""'.
#@cli : $ image.jpg +pink_htkern ,u +pink_htkern[0] , +-[-1,-2] remove[0]
pink_htkern : skip ${1=4},${2=""} v -
  repeat $! l[$>] _xpinks htkern$2,"null $1" endl done v +

#@cli pink_lvkern : _connectivity={ 4 | 8 | 6 | 26 }, _type={""|u}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/lvkern_8c.html)
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/lvkernu_8c.html)
#@cli : Grayscale ultimate leveling thinning/thickening without condition (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'type=""'.
#@cli : $ image.jpg pink_lvkern ,u
pink_lvkern : skip ${1=4},${2=""}
  check "${1=4}==4 || $1==8 || $1==6 || $1==26" v -
  repeat $! l[$>] _xpinks lvkern${2},"null $1" endl done v +

#@cli pink_reg_minima : _connectivity={ 4 | 8 | 6 | 26 }
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/minima_8c.html)
#@cli : Regional minima (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4'.
#@cli : $ image.jpg +blur 2 pink_reg_minima ,
pink_reg_minima : check "${1=4}==4 || $1==8 || $1==6 || $1==26"
  e[^-1] "Compute regional minima exec with connectivity $1."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    repeat $! l[$>]  _xpink "minima","$1" k. endl done
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli pink_skelcurv : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelcurv_8c.html)
#@cli : Curvilinear binary skeleton guided by a priority function or image (requires the PINK library to be installed).
#@cli : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% {w},{h} fill[-1] 'if(x>w/2,255,0)' tp=${-path_tmp} output[-1] ${tp}/inhibit.pgm remove[-1] +pink_skelcurv[0] , +pink_skelcurv[0] ,,${tp}/inhibit.pgm exec "rm "${tp}"/inhibit.pgm"
#@cli : $ image.jpg threshold 50% +pink_skelcurv , +pink_skelcurv[-2] ,8
pink_skelcurv : skip ${1=0},${2=4},${3=""}
  e[^-1] "Curvilinear binary skeleton guided by a priority function or image from image$?, prio=$1, connectivity=$2, inhibit=$3."
  v - repeat $! l[$>] _xpinks "skelcurv","$1 $2 $3" endl done v +

#@cli pink_skelend : _connectivity={ 4 | 8 | 6 | 26 },_n=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelend_8c.html)
#@cli : Homotopic skeleton of a 2d or 3d binary image with dynamic detection of end points (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4' and 'n=0'.
#@cli : $ image.jpg threshold 50% +pink_skelend , +pink_skelend[-2] ,-1
pink_skelend : skip ${1=4},${2=0}
  v - repeat $! l[$>] _xpinks "skelend","$1 $2" endl done v +

#@cli pink_skeleton : _prio={0|1|2|3|4|8|6|26},_connectivity={ 4 | 8 | 6 | 26 },_inhibit={""}
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skeleton_8c.html)
#@cli : Ultimate binary skeleton guided by a priority image (requires the PINK library to be installed).
#@cli : Default values: 'prio=0', 'connectivity=4' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% +pink_skeleton[-1] ,
 pink_skeleton : skip ${1=0},${2=4},${3=""}
  v - repeat $! l[$>] _xpinks "skeleton","$1 $2 $3" endl done v +

#@cli pink_skelpar : _algorithm={0...29},_nsteps=_1,_inhibit=""
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/skelpar_8c.html)
#@cli : Parallel binary skeleton (requires the PINK library to be installed).
#@cli : Default values: 'algorithm=4', 'nsteps=-1' and 'inhibit=""'.
#@cli : $ image.jpg threshold 50% +pink_skelpar[-1] 0 +pink_skelpar[-1] 2
pink_skelpar : skip ${1=4},${2=-1},${3=""}
  v - repeat $! l[$>] _xframe _xpinks "skelpar","$1 $2 $3" endl done v +

#@cli pink_wshed : _connectivity={ 4 | 8 | 6 | 26 },_inverse={ 0 | 1 },_height=0
#@cli : (https://perso.esiee.fr/~talboth/ISBS/Morpho/pink/doc/wshedtopo_8c.html)
#@cli : Watershed (requires the PINK library to be installed).
#@cli : Default values: 'connectivity=4', 'inverse=0' and 'height=0'.
#@cli : $ image.jpg +pink_wshed ,1,5 pink_wshed[0] ,,5
pink_wshed : check "${1=4}==4 || $1==8 || $1==6 || $1==26" skip ${2=0},${3=0}
  e[^-1] "Compute wshedtopo exec with connectivity $1 inversion $2 height $3."
  v - repeat $! l[$>]
    s={s} if {$s>1} s. c fi
    if {d==1}
      check "${1=4}==4 || $1==8"
      repeat $! l[$>]
        f max(min(i,255),0)
        if {$2!=0} negate 255 fi
        if {$3>=0} pink heightminima,$1,$3 fi
        pink wshedtopo,$1
        if {$2!=0} negate 255 fi
      endl done
    else
      check "$1==6 || $1==26"
      repeat $! l[$>]
        f max(min(i,255),0)
        if {$2!=0} negate 255 fi
        if {$3>=0}
          pink heightminima,$1,$3
        fi
        pink wshedtopo,$1
        if {$2!=0} negate 255 fi
      endl done
    fi
    if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli output_pinklist : _filename (def. $TMPDIR/pink.list)
#@cli : Write a pink list file from (2,n) or (3,n) coordinate list image
output_pinklist :
  check {w<=3&&w>1} skip ${1=$TMPDIR/pink.list}
  e[^-1] "Generetate a pink list file $1 from the ("{w}","{h}") image"
  v -
#  file_rand nn=${}.list
  nn=$1.list
  typ={w==3?'n':'b'}
  ($typ,32,{'{h}'})
  o.. asc:$nn rm..
  i raw:$nn,uchar s +,10 rm[1] a y
  file_rm $nn
  o raw:$1,uchar rm
  v +

#@cli input_pinklist : file_name, _mode
#@cli : Read a pink list file (type G from pink.delaunay) at file_name and prepare
#@cli : _mode == 0 a 3d object or
#@cli : _mode != 0 the vertice, hull, edge lists and the adjacency matrix
#@cli : Other list file types are still not implemented
input_pinklist :
  check $1 skip ${2=0}
  e[^-1] "Read pinklist $1" v -
  i[0] raw:$1,uchar s[0] -,10
  if {{0,@0}=={'G'}}
    rows[0] 2,100% n={{0,t}} rm[0]
    3,$n,1,1 nm. vertices
    1,$n,1,1 nm. vhull
    0 nm. edges
    repeat {$!-3} l[{$>},vertices,vhull,edges]
      s[0] -,32
      =[vertices] {0,t},0,$> =[vertices] {1,t},1,$> =[vertices] {2,t},2,$>
      =[vhull] {3,t},0,$> {{4,t}*3},1,1,1 p=$>
      repeat {4,t} =. 2,{$>*3} =. $p,{$>*3+1} =. {{$>+5},t},{$>*3+2} done
      a[edges] .,x rm[1-4,-1]
    endl done
    k[vhull,vertices,edges] mv[vhull] 0
    ver={vertices,h}
    edg={edges,{w/3}}
    nhull={vhull,is}
    if {$2==0}
      if {vhull,is} repeat {vertices,h}
        if {vhull,@{$>}} (1,$>) a[edges] .,x rm. edg+=1 fi
      done fi
      ({'CImg3d'}) mv. -3
      ($ver,$edg) mv. -3
      (255^255^255) r. {$edg-$nhull}
      (0,0,255) .x{$nhull-1} a[-1--$nhull] x
      (0.6) r. {$edg-$nhull}
      (1) .x{$nhull-1} a[-1--$nhull] x
      unroll y a[-1--8] y rm..
    else
      $ver,$ver
      repeat {{edges,w}/3}
        =. 1,{edges,@{$>*3+1}},{edges,@{$>*3+2}}
      done
    fi
    u $ver,$edg,$nhull
  elif  {{0,@0}=={'b'}} e "2d list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    error "Not implemented!"
  elif  {{0,@0}=={'n'}} e "3d list file"
    rows[0] 2,100% n={{0,t}} rm[0]
    error "Not implemented!"
  fi
  v +

#@cli pink_delaunay : _mode
#@cli : Prepare the delaunay triangulation from a list of coordimates (vertices)
#@cli : using the external program pink.delaunay
#@cli : _mode == 0 a 3d object or
#@cli : _mode != 0 the vertice, hull, edge lists and the adjacency matrix
#@cli : $ 2,50,1,1 rand 0,512 pink_delaunay. 0
pink_delaunay : skip ${1=0} v -
  file_rand nn=${}
  output_pinklist. $nn".tmp"
  x 0,"pink.delaunay "$nn".tmp "$nn".del"
  input_pinklist[] $nn".del",$1
  file_rm $nn.tmp
  file_rm $nn.del
  v +

#@cli :: KaRo's Tests

#@cli osteo : Load osteoblast cell image 128,128,1,1 (transmitted light)
osteo :
  e[^-1] "Load osteoblast nucleus example image"
  v - l[]
    str2uchar "1_11130_1_1_AW1pPbBdNqtZN5xXO65m86ldR7FgNJxZPaFdMKs:AH8s834mC20l834U8n4lA3Ik2bWQ;LhLYmHLaRqzIql8gNF2KWocWVGLixk5G2t160:3QHrHjfnrZJaJNP9gZqgvAnoMvn3RLNLSRUBGV48DSZ247jKaQqs1Utbceev:SyxbnbQyQyrERqnPBVnHhqlPBln7h0n;glnTAGnwttWCvteiOPiCulWiNJjsj6ZT1sPXSfdXKI4Mw6CqPvaysHfLcSDtXiDOhVKubiJSVvP5RrvoLBhnbFjLls:yvS1XLiXP7ftbM7aPLn0hIvSlh8ST3RyprR2kLABpLFj;ufvjCfPaC0uSN5oviiY71fPgQnyK6sGSvxiuWvrW0m4yUxKlcH1kPRxnf03TRazgk;53nrA2lkyl7RSygHqQoBEgVrjq;Ro:HQApQJPToHmLSwDvfgwRCVGCWxTsaCjchjCHdxhiU3Qg6zgCTRTrHQhqLG413Jg:8PkkR4AguTaVtS;8UKpTrnVC4DUr59DbQBAsBaHUafu7NGlRwnk;AXMhe82bpW0oow0KEwjGl3MhonBwmwQlLJRrklj7pXo;PrYs7yHWL4Cb0GHXM1bg8n13zmMATEwvx9kkwCoUjA5jc0IQ1CenBFnIhD4Mqz6sY6B139O75uOZKHUQRcMn187ZiteBYx0Qg4i;SjBz2ZlwW7xwnvRdBhQSJ1lSSwuDhibtLiXmm3WzvkRs69ETEDwrpzWLkgMLMI3q:eG9kT1gK0NA4Y;rDMV1Ut8QpsJgfjaS4lViU0RG1lMqt6Yf6ULo29qvy9vfk1Mhoks26v:03c8UQ3Fc4Jg8g45gW:;ljC3ORG4llx0VHESasngEDZHgVJ2X0Si6FJj24JnDd5TM1cn0kP53vADmD9oehIknj16i4I9WVVrM8RHeKfHQOwX7dYLUknug44M3AQ89T3Tk0sf9RGpfhM;Y8GYLdwKGXaPF874S7ATXporjlbDcEN0vRU6fktOQOwU:izBwpkjkoQ3ov330pnksArm0GzfLy8VjIzyCuToI1BvpnPITVDE3uCKOOq8hHHABi1wrepaoDasSKr9czt2i6L2bC36wZu3U6zWW6x8o3NDK06CXyICqo0xA36u;PQ:GM3fsmS67OINMxnewcK713K4B3Z41WlYuTAyZ4XEs5vGAwxbEaIZc0GOtCWETQWJgUQM5rHh41eXFhgIL7Nm:wX4U0wUI7iQsqCPp3Mn90oXVLMQyEBA3U77HV1w7xiIOQ4Cg1AIuA7mTlizE:j4;nwHyH5S7L0:y2Rxk73q0V0a5iVBSqvtak3tUS;vhQkQVpKr1u00CDgs9j;e107mLVij3itk0sb0V3Yw3o6bkzlh7KmshS9RjsC4apWEiKENKVqLNZaRf06VLs2FqWEzEo:0MrO8QHRzLSI20ba7HXUD;284s8HN1286xCTtDg7fz9j3U3f0M5zc:LLq9REnH10miB5q7OpeOOQ:yc4127amSvUYohUZyU1MU0dwCaFYVVE2nVwDEBvmExc5B6vM1JvN3m1MT2Pq03ax1qE0FvCB7nu9Fi3sV6rfK6LTk;RDE8FH46dAOdFxElP03m1PTBD0FK0kAvENGUJvUEWtqMxCIB5jc73M73EEOR8BR1n0g7dgiV;qtk2BilPi6bi0dZbQH6ZU;2:W7BWnEoj1Ri3yCOVByyEdV36u8JKm1EDk;DEV0c1gOh0sMecbM0:K8S6H1rE1;F6mM:o09LU1jjUZUTBS429Tc1LG27ZMOJj;Vi:ut1CWOQ2u151tg0Iu41EBPlnYc1QA:PlVzcLo05UAZV6IkpY4ng4KMZqrkpl2hMm8uoh9wa0bw7Fi1AE:aw0th4Vz34c6boQzcn2PxXn:01zWI8hk:elAS80VMb1J2GY2LYBP4u8eRkjK9S0EvbdpE1fAIL86:lCM3lbwueQApUOg4ZdjEjM4FEFUoNrWHtVfOIaTggsZYCZkEuc;AUKZo2f4Od8m0:aF71A2y8Gvyu15p;6:Z8oW8FoBkEycyd;1xVZb82f7Djl4sxVCo82U320KR7V7EA5Rs41W5FZLGyr0OYrPDW8x7UmfsviIGvcEBKJE0sU;gAfWluFt4MQU1nw1DA674M5Rw5E4DXc7JT14s0emARTpfsVzAGrAp0wT5gq09E03;k3s86EFT70FiFVzHf1g4;pjHsBBUN2sQ4u4BRU1JEI9k7qWPVUbCtJpPVes9g0:4MMo0IQ03s8K67s8BE2;k1e9DEApNGtWx26qO0E:5PPWSK96GgWYSieF1zkRuMI4RTAc9WF1Mqc25ko0AXOMDFu:lL3jMa4ijErFm2;okNSzOwM5OI0106Dkii;6U3RUJu1E2jSpc9joDtUTeVAAPJ2:o7kf4wq0YdY7DU;29UAFYQZDgkM31oDiVah0Y803o09VkJQeFT8M65Be0CxyvkSYULsTO36b8BAGElpzN3;zQ6qCLFFs24N0L0inlP4A3s61;1gAk0vF5TwB6w65RA2Is8JO32pqvEauys2rM96E05:PdkmcFy4AucGDsZ2b098HyRAhTEJnLJ2Ls7GWJFaQb5h:aO8yq1VqPS;eUe637aY748yYAsEqqnfU1ws7i6JK1QA;eMMECl7l3xaQ;6gdT0JLkIiCrS6834QEGlv40WZUEgIqX9C0CaUOy34MAVu2akVJIVeAOQ7MM08r4dhgXRBW2om;KQxzk9t:7UBU3s4MMVeoUJ47epmvF0DFhOPhsCikOQjBpg7nTB0rB2bXe9PUXsuY7SbhBaA:OY9NjUOu2p9VYG3FGt250HtTw0L4Gj8PWdt53H91a29C3EM2SYOQUV31oAk1WGwO:faw;IajPaUviEY9Y4zTApR;nEHhifiqJQ0IB0UHL1vW:O6DPkUfUgK2Pw5A2dQRIUAm7bc7niXEpG0nU00vZ4zx2umROGFUGnJoRoXPdRVtCHmMfH0xTwF34V5E1Io1wMKiVhlM7UczdYaTXz3fElZvOs64kE94qoTAFGL5mAkkBG1YS0Potn1XU2EVw86401NzI2qNfa4i6L:lj0UHUU7kkXRnZ6T0pUo8YCOG9uC2dC2XYXH2zAfGJhjlcLWvB9ImNnBxMEkQH4bUoY5yERKURXaMX7IEkj3PdGB0:HFSukuckwF2bUAdxbcjwWz4TarBsdCIBhi0:mYJkdxFBswfEDZuwSjrepSgr;pyzTjjy2VH28MH3:25sKBUJcWsZ1e2Uwm4GY6jG5w4MsDvAbY0uc701B;diftNE7vYs18wh8FXUB4UY4Nd93c6jOk9aKpRjLvtxyKUlDncxDnxxT7luwjXNqkx;Y01BV2O6L8hqlRn7orU:bsH6ME3mmSd8N2ZPYsmB8gTrBAhMEXq68Q8Q8MM9:ZSpa7PX8TUEYULhVpRDniSbYu7G6FwSniQb9uQboxbwzAL;3wgfS04qQEqB4RTR6tBCud:ZWSQl2uFnUVzGb0rVFvdf;S7Cw2IHKEpVYmY0873dW71CKfm4pG9UihP7Xwya1sS;FPwVpni3ELzELlkyDdlBFcjtmSbHBlxcemOtkneO2it0El9jrRnMzcwYGIlPE9rcK1Mt:k2SQJC81hjK71pOF;mle3nYgCs:mEvWsT;3WmT7rSv1T:dIOYppq6zJatDFT3cS7En7kzbVYtRLM7t;rTq9ZE7wXz13s3Axk1:2brhBAc3Iq:JgsHO6sN6cYJMhwLaT:PH5YgXGMir34MvCHM4UutRDHouCdzDlM3MThNjJpbUsO3EJRHncxxFiinRN;1P7nxyiU0Cu:6HM436k2h4PwQ2ZxsBzom5VV3WB3EM80kBmsdUS2m28CldtDcXB2fVVA:eOOv0lvMyjlUqZBlaD1cBSfxhdG:pqfmgr1wBljuyotKNjTXFR74ub;pSqeP54Mkaald:;HTErUKy8RwVv7C4Cm2ApscOx8UgVMRThE5jGVP5NY0q87K6PGE1kTbbpteWSfvE6jI6fpKUpCyp6jJmgpVi3mKkqvBPYVbdkB1shpDP1qmg:bZIV;UqDpPYQF07C0F1Y1iWkD046mP:G2Rou1XDJ5FWgFQEkEVU4Y10t4xYszaWj7VyratJuexjjBFh:GqurdIkqZOypdsDNsIHC5mj:Q08ZRCHlqOh;Gcu17p8ZTINIcUgWI3eYN60kM3CSmHG7LUXrA87UU02Wa6g:XkD3iW:fV4DWdpQbYu7OYajBRazIOebxZe;KGwJ2dHAsVD6Bex5YeJOdZWdmcnItyTvh1tr92u9:k8UCCq2WtUdnwZUqiaO0BjUfJX9UX3d0NgLm6oAtz5IXGW7G8GeuVbLpv70uv7RYKKdrCh3ucBRdhZhpiOZoVd2yIcowWCM;WKEwISxqtsjXwqSjmCN3YZ24IyUTu;CinW0A8ugKLAFUOULngtVW8yNWTJXaIZj2MT0dw0C8XfbrtMiHcxBdex5gRfgHGJ87wp57OUzuPPIahIO3JabfLzusYQrivQPmbMDFwKmuC3axE5EWb0Bj0Z6eUnwncpu38E:m5qWL5eaXjRFMLo6aNt8E0YFL0bFURgU0k52iLYublsxa;OIx62kCZ9doT3XhhVGZrNIUYJNLXjriPnytZQdgPyt81zDSkQ5oAXkyLp839eAp3A5oE4H0iI51cNHE5dfl3BpQujeJdNBDAeeOdeVSUi:sx4R8MCKP5wyakybFoP3NuUvIQOxKY6RDdpqdJet8xIuvfPFfSvzxazxodt3MqMsp9Vp9DNdCSyCHZsP;UVNJn8:CHHdcAFq4OtVUJAV2EJX0DlnGNv1ayx8KsRAGBIw6Lgx7MBITXRHijBRf:p9BYdeBR3:jHUzOpJEoKqep1jqKL8bwumxzxIowbYuIZ6uZc4kLwACH9lxpKtEYG9V3sWz;B0Foql9F46lComoBa7AZgdwZYo13w7OP1G78XXKltlB5PeiRFepSnCTniI8waGortLlmRmCNOmWXMPRNnivxxMizr8pIugqCLBcf:cDNsjXcx8JCr1B0u8Y45SEHHcpr72MHkC5faXnyOBm4eSYg7s0:qpP0t0NjKTPetPGXhZGZLeuIwiZoB9u:dEjtR3mSX6vhttiBzaHEZYj5QbNr8xSeBMPxsZuWf1uSDHdObDsUQ9Rg;El8dY0w359lpc2l6KQJyWj7j79MMMMfC2jR4TkSJaUPCWE2CHkP:tpqFyofdKepK8l6cwZoedV8FN85:PcPZkSHAN2sAlkCZ4dPePJuzLkwISeAtfD1ODeCUFGd8UlS17qYUs8I4t7UZEtE2husN0dYYY6GSens3mmKys5bj9dow9wm7:XJIeZMGgIGyIkqaRWCNtJuBfNTDtVqtIdfRD9cAJ66PPaX:ha416meBOLiu2YHGM10m0I51E0Hh6tMEeEAk2FkkVKkRIIj0zC6MOloG9rNhuV6jyYKOdpCcu6cGXaRHVOHqKkaZMZhrxh85PAvYKFtoAaZQjLFczDdG97fNJaeN0d:5wON:wjxckhz1Tc4fg4wmJp70xN0m8G0nmPmzVIU5X4DbWVO3ZXQ0UrEDMMYwyBV9hvgswapSe4MWQEGgIUuYwwbhnzxxBjhbQqxO;OGqRd;GSfoNB:e5XDlJ26T;PPYOXeSm9EPYmQOGxeKmABUHUvv0sUy89vSXltSqXEt0M2IZA5Im0cjc2xsUevNeySxF4:OnbdGfNF9vASmoNqxjK:iZ8xwxbTzy202RswZhixgNJiXuLFEHQJHitgvaJlJPSLqhbSXeIfbw1INVAN:egx8tl1UYJ9WhNhf88maOO20V1wEByFQ05iExYh4b2j8k7erO5P:wb0uvg3psdjNp5tYBpYcs:2rTjTDKvbMPWEOTT0UYZTuYsJOniPmYSwqYiL6cBR8PRrTWAjhoTCZOOktBEA;4sWEiF0HSJW58;PwUkWx8gBZto6IioXVfBKXTfhHfOg7wD1G9VMfN6;9S2uTGeJHYHjTFOjdN2:SX2EmVJ9RvIfZMfqOrvWPPApC9ocdjbIz;TJatojmOsTyV2Eg40HSKzBcw7xkTqPRo0DykURgK20Y3ls0lr7ABqTxwJ2dG:pahJUjNh:tJ39NV9:rsj5ABdRfBOfZH;NGflGGqJEVZsJUQdhrgcr3lkCta8Z6mdr9kSAfJe9MV;R8zoXCPtU4AVhZoUGXk4YBYbnq78131b8EXSJUxwqHqKEqOPS0wzKuL4sLAh5sfZnBPXrQmpHYahnhRmidMbTMeeTHwNqRN69z;z9kexEx6;G:dL:ioYFYTbn1n9XN58hwBfKDZnSic2OWTaW:4VklaV5zGJqsm8JKyidwr9iR70kvIX7Te5LmmQHSvZsK8;lxPmhRf6M:JOZR:Ae3MPxNmALjr;unQKxXOmBN1mKhpagp40CpBrzmOWJ:88scktgYza3N;0J3zlMx3dk76PKVyw5Gdto2WxZqAGxS77KuUzaYIwgbodZQ:f6pRTSvvImZaBvPT;2TXCz5AgJwIKfryrqdKcXwxIxzyTevVxjFUX:PJIcZSHEy6;PJUoQjDbeCG;fAU6J49e5AY20CupdYJzXT8xVUAlcQlJddii3Q7vs7dbPIRW5qztjBK2emwz3SbPjrBiD9JDHVvOwSP6tgvKK;dLNze:dBiF3xxYyTzSLqkvqQdDOvIXtFJFS7WrtrB3yzMda;8NUhEJBox7kqB9QVCrQElHJs7eEV402wUvE90IZzSHePxqKd5DzmRvyuZGlZIsZ4MiTSRrQXgTpvzzfNfQqBypjFL;AxvOa3YR:8rDbumywSvaTf7OJJ:KFrAzL1mE8tkiVQ2pYjoUKyW8kgdASF3M5kavckTGWT4CVsGzm0u0jyySvFP3O2rmilnzzX9pwLtKN;OROmCzQS9dAvLzvV3vRrhqYBNOYv7:fxRbLjkRpvYG8khxCg5vDNu7ua2EKASyAbP5Ns;7H3g5WCE9s75i3mx52rkNXD3e3VaKkmu:Nc1Bj;vlSXMOTRIXf5SzzkqLOdotzClcpmCVPDd;NjzyKPSnjFzKUYJmnKCYenJ2X4xjOkd5n9pKfJ8cVEB5BehRLVOD6OvJaKFlXoFFT98fipF6LMo5M0CtxhFf3UpKeR2Sh;qztkB1lq5EJYjtpwi5SI6yr9oOlFGGRnpLlYSrBfBvfxsC56D9j9pCfZT3ORmCFn9IIdF6C5T26xjNqipqGdqSlXTFOhUA9YEYnVKOOxhgJfb1joMybknCn4gAe97AXJRTDRdBTdBRfhwPVPnxOINfZEuzOOpLUwKmiaRfSXwQHyfOyzifwHnlQ:aK8V5QzXu6cnhlJDdJ;lnMqsp5OeyN8uSKxGuX1xLl0DC82rfV2lAEr00vwW2iV6M2DXNB8BySWfJvBiIyrpiwVdyt8YpNCFJ;Ihtu9PoI8V5RjRHaFHxvvwyhvqNWGKGiGPyIWya2dI:jaxG2ORX29EhgQUEX5twEsYAz03IMUAqBFV4JdrFHQMiN2C94W7w5S0MxOEn12dhqCwCtycBEKo4lbqF:oLMhgvqNdQHOHqRi;UDh58d5WDP6t7YvgDMx5cEQv5g:5IAUpx518F4B7wM34cvqmKdVzNhPBjk;10fF3wLNMlL8QJE4FNZtpD4:qTCyrfPUl2sjh7m:hfnNMYBl5B:j7sJeHIYf;vyvhPCt54CV7N:nOehKkSg1199r;JL6Ev4coX09MeIXuJn9J:ui:UZMaJtmi7PAdabMqgygNWB1GIU0Ia97xOmBcnyFPWU4sUUfqwDll8XJ:lIerrtYxbgCu7iwJqDI:4XOPXaLkGsaXKuu3USz5ghZ1ADRmwQrgfbGZ:crsnZuXJueqSqacqqiRO07yvQQHdKJg4q6hfQiKnqEOcxuqJ0Tw8YFujQ7tKUDJLFoexLgfL2jLKu5HBFi;FjKkdhrbfqkT9H;pEUm5640q;iGHCbmooWt47RvztwnTPuJ9rQRmh5liR6W9KgnhSDBItwQ0Im6MG6f3Skcl8B99hpXv8wfIZ0l3ERwZGhaIOnkyuGeIAD2Z9ktsIXQFHSsZgvAvRqt6wr5CuUqNmvq5o8pt899:dIeJKW3mswxrLhzTmZQtsp93Ynf2bJ6eRwTH91sNRpU7KdiRmUcDx68MXY1:0XsqpBMqgXomA0LZZLnoOxjgmy7sx8wjZH3:uhvoTGOKrvqqbWz9sqCjLhVswT70jbgZYwvau8iKHxywzr4jZQUWIXJdJPgwDFxLuw62CwAjV0tOdFJDRM37NUOqnj2T:i2srMGlhugQmFRc9VnVdxENmcpOf9H;lK3dxvwxzjUQvqxaybt:POfhFmnmsTLxXSly6ZYtKZ7eZ4hrQeU7yeiJGjRp6GfkMhZexmS7Xes1u5TkL8MwpAMRZP3OOqGlbuRVVvQwrmLfd1w0UvSeoCqV;3I3DtgNSD1Dzsrzxt2zPwInWniTrAVKdIQviPqpgD809ZAi9bJ97OGXtbIWpdYUBiRVgBdGCcjF0qEzDLel4lsT8PsZSVUYKuVao1sAqEJVasJJIDxXrKH8tKrosarHZNeRPqfrpJOmYrDjYrzu7TvkTnSKyzKyzjthe:jJo4VjM:oeED49hiuTKd7EobEIVOIUhNAJReRLjRhgbtqwB5jtxAPRXYCa99XjfMeHO;gjYG39ohes43KEJ7j;ty6XQ;NNOnS;yBpxhBRfrzjsLzzaTjhghZ;QzzSrbSvJaeNlBFDTX5LLMYSJWfR6LWdJ:8V;9JCfJQfKQfzNuMAHXrgbHXu8f31Y7A6gVVrJ7XlIMoPpaERUIMlo6AyxpAR9RDFioOcJaclHNyDdiKRfwx3SzzhBxN7mdypxwYmlLEOy:lKGeCHsOheiNT5r9dD9G9NQ5zYMrxz;lEaDIatvAdxDjZltF7uGGwmJAyJnFAcTf2kwolN0J:2SPXelkgbaDb5BvUQVTFzkhvRzuNWyvwypbzzlhB5j89LRqBzAZ2;TR;1R;mh6X1RTDNt:vypKpKOqJxazzwlzjvgGOUz7FwSbFqQgfDv2QdFUbMG7;NaDPxHIqXoFPrl8XD87Vue;5EMlYGRVwTO0odA7VL8rTjPCxjzDhtpzRHlOfpJkFh;igXAMxeGv;vS5ofgcpUD2xithJhGALAXhTzD;jDviRY7hHNDyjbpykay7c8Duuu9JllgG0zvAtlk:H:qNCH6OOZcwYZ329X40nDdupegrFwTaYi0CwXxvtukBYRYKtfHG;gNG2X1w02vwT3ZaIW3qsgv5JOWi8l;4jDzYjjzwq;jI6cuDnZyxgAMr6z8ABas1BOZzo5RbT1hLmFOz;oAW;vQiZa89XqpFPDaz;QbRlAehaoz528PuP:9M:wa0lv9GrxVc7EubIP7TeWD7Z;C;RUvjveK9JedHfqRjzxDjDBkfhsKkkDLjqnUeQUAnTMjbHFOejgk5jgOdBh674Umhk0UDYSALgKslD6AP5guvQOjTuvJeiYAkr:jYWl3qN;LeBT2HFbDF;iOdI;xIPpSHyvgPKkyp88dSLah:kgbLvisp40rb3O7;wvA9Z:Ro:FIoRmtagFniW28UAGAlyoTt1EXHCkf1hFVM:X;VsRUXmJmsI:fJoihGKwvZ2SrlsC59fyKGaoFp82DGdzLUeasngDxnMrBuBNuehkKXO:qNHyIdPbFsS7PpsjS8M8MY6CkuWLKS;tcsdKW7EhegPciP6xccXoaxM8gjqmpSbrIsZ5sz;yLF:uYWljLWdSrEmPhNnuJmqral;yL;osLqYzhZITDjSNXGKfLGaFkipfIVJGJ9bVwT7Pt3DgBpAmyNQ0apRx;FUyKm5UKelKqKn1oFaWjQBe0NTojLZlOBKjNt9lZ9P6sKiIYlgDoUrSvqiL4WZQj5MjRJJeca7Lrpy;pPCNp:9zHHAgrwwDqWrSyp6LFYQn82xRg2q3hgwn6R4U07EShNuWc5B0BBXusjnFinQWrFIpm44HRASRKcJt;e9fzuOPFJmWTW3552b78gZgwW2:uqVahjssfSzzjFyAUzOKwybgeLyMeEqqXrE9bJqA7jo5AnDcdS9vcQZ9jHcOvuMdUDRxJpj:T17NxRF50Itng9WW:ZN5qShaWHJgZhTdujtMXuJm5P;eTpPhvSH27:BHYy9rDr3;rvlRrzQWdPIUrOdK:eoifpOgpajpecRsTsOcRFXNwoI0nAyW8x78nEwhdNQ5fd1jd5wyWkvO8l659X11AGoLVuoKdpC4wmyI5SP3OHUZPpPzz2vDqzJp5OxIZ;mhrznBzzaZrzMWhEbf41K:r97YaGtKecJ6hq3uTa5k7gEDnR4f7JMmEPIaVc7O5VSMnscVAya2oE04xExIOYJotTOqmCprShqmsJGLVaAiUVbtRrDTjKrjveROq6FOeiuzRhzxshTTvCPe7JPXKMtLqgfXJ93egeBdXeT7fw4fzGMxXaS;z0BGXM2IJOlJqkKalO7IbpXmJYLe8DXUEkCybfWJJgxvbTvOehQeVKJYqZLZajlPzzomPzztAhY;Jgc5wjtt1STzD9T7WMHwIedLAqb:r:roqkod4ubCnp5qYz2NP;J00BUPNhRI1cOWqy6lXsddyKQeuKMDfKg04akeFggm0Cc04OjNieU1v8XtRGncNH9F1vSyi;HrzninzjNuBtS;5pKMZxzTWSKX4FGlIkpZmt8koaj;G4VbNkxTzb3YcD1E5WC;8VlBcurgcIjgb63fJlC3M9w8C7HL35Dl4Y:mvc4NdV;IA:nsL0w6:iBObDGm2GrRbQrhizSyjmjarjPM5tmipB8NgeZEW:N:NO;m3iOowLFh2DpFcSbHnzcCjjam6VjB4u7oSajlJGBtLaaG4P4P8Sc2KA3v0YU1yBSXNL63WNcsDiHcxb1e:zKOxJ2BdhDld3wFXMrxeCJchkNx5jpFeQB;ZX8NqeJR1vYtyXowM4uLdlxzp:XCNiyPf:lO33SojgB4MVQJfo40oT:nRzH35Zqg4In2;u9204tK9TjLXyS3vi3XZkiZuJ69NQ4q1FmRFb4ShlHCyq62fndULoefJedL6wi7Xq6ngvCLpxkH8W74sF6HDPO;2mkfWq6OpkO0qRTMGIgxm;oLw;o0Ho8DtsMU6BPsjrrVsDSg2r9tPfOPlPmdPfIO0ru7LImu;GZSeKaR4MXhOfqlVqt1AojthD9zDir7lbFDRNuCRcf6:r8P7r28AQaF1C:bIouUaWp4Tj4n1vyaYm8fGLvtyySndKa;BQntJN7PhNOIfjPuTFeQfTRZIdtA;vakJWJCiDlf5xf3qOXoKnqtBK7pLfgFcm8aa9EOwbdZ83gll99VYMW9ZH1sF02XlVlB94EOu8AnlZcvCjenIarbeyK2XZ0GtCYJd5YdJNfBCgR9MxYi3OOR:iBmS7dfBAN7ooa1sTDTU3TMKyLPElmL:MTVWCuKdSLZwkvDCv9BHZ8lh30yFQC6b9u4yRaCt0HDLWAizdsDakf;7tL:uryw63QOxR:dL:ZIOad0naJmXG6otsgntuQ;kPRrjHlsR6HpmhCOrCan0llL0AoHxR57yxW5OsiHBwK4vs6Ix0ESCHnVP0r5cctE45U4h90NBHTbQxIhJD;doj:uCXYN:9:lLGaodEemZ2h5uLaO;7cR0ObdqSHTbxqxCH9qmL7YYJpVLJB9VKCgsFqjRKvwDzynvQfFsmGWbVYWm5TkPxy7delKEo78l:n;22iaa6yTvsMewVreyfVoSbVh5B9NI5yYD:o1vqaqVXAXaQkj9BH:;yvSDPiUWYRtrlBsef6iLqg0cfjLvoDzhzzSbxdgQELz3nNtetoAM;AwVW7FcY1vffzOUS6ncpd7tzCihJYiXtQXAPXYNlw6AyIM8S3vbUyu3OPwyCXoKVyyjnkcBxRj5wmi6XAhg0eT7mR4VLpnA1sVt3kEEwR0TpsWxa0mzMoVsHc11ej75WQmVFnTJEHc63pkuA3FJOu1yBKdxyH8pjPwK:X3qIQnBcRdHAtDJsgtiRbwxvcsALGLsz;CmiaBFm7hAJwe4P:SLZphH9omZVAWFcgVR3vlFG8i6IVle286zFFZgQ0pfeZjrsu6YtkyUv0IAeZIgK:B9kRDnsSBCKCoXguCnswD3sub1ozjk;Q6m5jSOnMjKBR5pOpQgHwXCJeGnP4iGtLlVcOCwAOt0KDd05OjAQ02Wec:8U87c1TaNQzD3ZwR;;cXlRnhGBJagpKMnktC3bc0LyvzT7wP7tsTDfYuLhH2lnCeX2dxU6yt1:6;SP93KOR732pCKv5F0D79X6blL5I7w2buqMUGYJgj:rLNokm;5qvyi75goSHUvAtF:tqJJKRb4uaYy6kVlEImTvwvCnv7mtVwmOArnDp5NjNBZgCBYJjW6g4F5qy1iPvX4W6a7w636dY7Ih8GqAQN1J2X06sj5NV2D0oJejZalTnyQblK5I71xrVsCXlqKmu67PJGOCY7XxtzivG4ACD3iVXs9aEf:QlcnI4uKDfEIls6eEYc;guit5YNI03nFO9207MF4t0zcILuwYPjg:6CMlsxT7BcmQjXbeXyK9kQ30tTLdoS3NLSvCCB7hqwT6GX8eJBRzkC;C2pEARo69ecj1gAhZVhQRRHqX1CGYS2g9SXpXMld:LBnUriQs7F:60Dsi2aKBRagPvXyzSbnxul8KDndsyDHjzzinlwzD7vrIYPWgu4nAcBXRs:E5DLUYVE9u2zEgGH0P0p9y3GSF2BbgExffwjqEzl7M3VkCZGA;KzKRGFAE3c8:poeyKmwjrPxswTzbmpSirPrzsw76tL5v1FnoUZGL6VJpC6nW2OSY2tolqy5SgRCWoRIBI06nRLsw3o2lBlVy7okM6qGbNiLZBimBGAMUuS9:jAHRQuL3hdPOwL5tRLacOPRKkExooS0L;xwEh70cI6ZXlG3fwaod0N7CiB4v467mCyLAKcXZ83bKHYti41NR4UIJUAHD1kyATHkQfp0JvhYISctianfYx4P5RIpgr33Y37EVR8xvMuzhXR2fM;UUpwqnFP1MgVnXjEqR8RZkC06DX6jrG5AmAgwW6jPuKtb043p2uQi0A9UC7mRm0VgqcPf:53e2633q8ZxRsEV9tN3tWD1:7w3Jx;FGeIMmdkVEF3rWRFAk:QfEQAMVLj3X6jes8QV9BtlkSFo30qU0gcYZgqYjCGTBvCfI2eB9sD1vLpLryn7kq57awPcbkGfTGC4x3BmCv2mpFNFPcHm;20GJi3gQ:C9L6KV2jaj5C62T4GNVtgMBQaTnA5cVhQqbCuvC;l;k2i6:GMT:O5:aJ:TlAX78MOzdjISxgvjAW0lU7tpNtEMY93ngnCfza29uyFaBKHSqZq1r1NFKkXwNs;X9tSeb9OrywyY3pw0TqRg1ng1RlcEXAKhnQs9sQLVgIVH1YUlfXfIYiMcY1;mB4;4;sdFOkIzP5:G2emzutAsq7CQE2GwEkIw058IxAmFDaOLC8f1Qsk8fkdUZ3Bsab17IY7lcKpHUuHZPAmmMWl78Dl2bCgEhim8YwFXtW1Lgnc68VAoWFmNgg5R94a3ivCWg6dVu:emeQbfTpmzzljuwzOXF3oWcCYVAPFSS;l9jThgJAdSLd8h10QgkxU9W4Ewv0QE;15KPafW6EDJBSCXD5W0HqGqibd5lSKAF7EgtN4ZpgPTbXzzbjelJPHOltamhKJtbj2ZDUQ0Y3DE5:o0wlreSHw74mZLBclgy46AOVQHHFtiIHGoE43WlkCq8OZhomFpxmO5qnSSD6tuUuS:MKqdcHoc5p3k673YS78dGNViyiNrEd5neoa3sE1G0CdCjfSuQgI960QbwutstBrY8ZMhX;xMR17HFPF16m9YiIwk1JMbXUwg:Yxv7Ig::hYkc8ki4NuxFTI3p;L7FkVGZ3KjmicSbk8Lc4lqtpQwJ;cG:3Q3UPyXCPAnaNG8TYW2omK8hu5tFWGKgopVWgWrPXwcAha1njGZWWj4d3xbZzmVBrL3Fl1Mota4ObQyppfMNrKLJnSSYl170vVV0vX81L97HFlOGgl8Dt6MApL8:De63nse2s2aM;AWAonVsMWu2Y0Hfx6H28hrmuXGjkl5ovckoat8evUDeG5milFK0ryy9E92pZ:H96KoEgBh;4T0i7;:a9Y8;VN;RUrxXMVQBPd;cPoCUtNwR2josQ4IIbgYHlbm7O4Q9AH85S3VFDOglcExZM0OAEm;JEgmNa9YWTON6whaK;Gk46qrb2pl2sb73ttgq5W2:ygq:9oyGgD0SyPBNtl0Uk690aY8VSgJvCMDvDEX07hgHYBFtb8Hlv;1WvEgVEiWvad10YRPlU8x5Rxt747GoSqrOL;tTjmAn44LH:b1Q8SAq4ZmYx08WsuMHB0ZgtyI0v5TQVMJIubR3FW8c06YzL2S;2wVWYGSf1q9mTqTeuV2RWa9XYhsH1q2yjR1PuKRcn355Zs3E02HW3XOXr0qsQ5XpgEJBNcxIwQFQP5VOgFnF4ZR;IF5XWOGViMPi4R5Ntpy36PEhKUr3B3R1XBITQ9l8BFos1WZYrrdAFAnzAAYHrUF87ORRsZQbYcRa8sGsAwVJHJB1QuyDGzTZm2QQ6e2CDb1RzbTLRNC6;7;S33P:oFSAomM;4FHsQ8x0EX9T2k6mCLm:gYE00FErSDKL9laSV145DH6HtN76gWY3eBvuq0UfEUbxapct8oxMU9cmIaGOR0o1bQw:A4RgVsJWbJY07v5jALuyjftCF;qZLH460J:n4iS32b44Z2GBXNaLM59QTa9sUVdY21hPMH9PeSVePqPnylpjX;CbfbDHUPbEly2Uu;tln4Zzb9Et0hjTz0GOjHEwl834k834UAG0XAHU:S9lnxspWm2wiGQpb000F2kAN
"
    unserialize. r. 128,128,1,1 nm. osteo
  endl v +
# osteo : v - l[] karo_dtpread ~/Images/Beispiele/tra005.cel,1 rm. nm osteo endl v +
#@cli osteo_ : Load osteoblast cell image and cell mask 128,128,1,1 (transmitted light)
osteo_ :
  e[^-1] "Load osteoblast nucleus example image and mask"
  v - l[]
    osteo
    str2uchar "1_324_1_1_AW1pPbBdNqtZN5xXO65m86ldR7FgNJxZPaFdMKs:AH8s834mC20l834U8n8oBEdsbCrNgE73A0k3ELjzdRAaVKqF0AL8yZzUc9Mu3W8W8W8W8W:uunnCruPW5zLeQlPQuSI;bj3O0GButM9KTlEjKV3WzLuAhoy8wpMzkHg7d7XTU2HjwfCwOI2ShzU2vz0JrX6UqRRsSM3:ekCOTNpTqXTkWizUVE4STZbTl:zeizXRzQqTXvyrbyHlry5bSTlLy6bSsyRtzDJxETy30QqwMI2n;z;mU6NTtXJTtxgDjyq7vzP3TzizGqu0oyzyRqjrckDASbG0bkwBeC0X0tfx6btoENYyh:1ITplEfhwia:9TPdWcTsyMnl8F4F4FGLo04goF934UAH4UAG0l82AlCEdsb7DrXK;8;mt9nMxb000IsUBs
"
    unserialize. r. 128,128,1,1 nm osteo,osteo_
  endl v +

#@cli follic : Load follicle cells image from thyroid (transmitted light)
follic :
  e[^-1] "Load thyroid follicle nuclei example image from http://karo03.bplaced.net/gmic/Repo/follic.pgm"
  v - l[] i http://karo03.bplaced.net/gmic/Repo/follic.pgm nm follic endl v +

#@cli follic_ : Load follicle cells image from thyroid (transmitted light)
follic_ :
  e[^-1] "Load thyroid follicle nuclei and mask example image"
  v - l[] follic str2uchar "1_1614_1_1_AW1pPbBdNqtZN5xXO65m86ldR7FgNJxZPaFdMKs:AXIq838pBW0l834U8n4pAnA:S9nhbRhKt3cAFCbzzybnQ801hqrRGdNWehu6m:fOGaUGdxSOXky:cWW:cWW:cWW:cWW:cWW:cWW:cWW:cYluTGfK11Haf5u30dpkcMtdd7QAs6hFxD:do0HTV86vS4colxRW16RLflKyWW:oi8LK13;2NipH9V0VqCAzMU0FUCjl1MGzlzy:;6scWK1UgC4zM00qVD78szZZzBSayjaz02PyqP4zl3wxe9xSGlbs5kSjtrxh:tzB7wMbzvCTU;HwawBDlhTmvkuHzqdyeIcuqZhlzjo5IAobGgAj55nB;xRosfRv0jV3yuRESKmXyBg;88ZH9b4iayNz1fzTyUfyU;SILiEDjXt3:6Ejd9TsplT0o04B;F74ZUjB5TnHpL3qHQ:lPDrrQPRIthzALkmJW;zQihsroTTzLa70HtX09hWWNhb7qDyvbTubSDthg7YBn62BiZhr2bzn9mlv0CQSWlLwoEUmzljjgKoF:ROu13e0cSPQheWM2r5rdg3zJLHklO2T7na0roI7Lkn;DdUE:dnjTsbsg054w96DmRMjFdnWZo;Mbd:IllHse074y5zXWRgtWLMJz97BmQw:YBIDd4TlculyB7gGDq:XOCmZkSz3fsqWvkEo3QM2Ljwe:BK6iR4sZFzYwviTURwFl1:gV5xRuMq2skTN31ppRO4omaEsTUrHJoRJKGlCOzvMZX5m0;Vh217dNoit29184yswjyML0;wpiakbNwrU3xmJbSF7CAmP2VKUH78ws3Pgbbdciez0VRf74s;43NNRxlLmSgU0l1kd0l2;gzP6drq0DVPwvGSwgYBg06;cK7itfFQzwa2cXy5kAT;DuxBT3MkhQ2NKzhY2kmMOGXUD:zzg8xbM0G6MUlLzPMaj1o2Uxdvckv4Gz7z6Y2O1v0fw97uAch6TnVyxcPmNDvXw6Tn1bMgmTZnjG6UBDdsTrHwEic0zkw7Rf0IylgHJu3HzeGa7wyEYCnJaG:9UfgbGMrDK:k7zrsvPyozOwIB3;RMfxW0;1k3PYdOu2DVpxtaMF58;2PzmDXgSG6MGyIgTB89dN2MNjzt1mtzY3bur550rwqiU;iNLIRr;fuAWTwg1l;qJI2rt4TN:ecPwa01Oeavwc0leeaPwe10kzha6GNtUdk78XuRoVUOqOgajXEnddPo3Hi1oFnOYUT4rCjpETbJd0eYjgGaBdJ4;T32zuOkyW1xp0KVfsNXSk9bw;RvzUTZhPp3ewQzmuwe1RA6wbYn6;fLoxTn32UmIEL1yxwRunMsTbfz5lvdOSDlpnlk2YxtH9D3bTOoddaaI3DvuDqiOH:iTEv9rkpxndS2DXN4coGkXKVPzdn4:8O8xKm9y3oZoZzD;S6TsemMew;yCv4IZnRHiD0LAtYwPewzPAc2w28XCPjDr96YVQqQPg1xmbCQzAU05zz:pH;czkW3Wjlr00Li8FGH090QqaQ4MueMBY7kWXjfCSvTa1lejSejsgkNkmbXHit;zYD6ySS40njU:rSjsnzW:rSzaZxhTnOzdHztfyLI6Ttrzq7q8BRkdzddRvYHynyhOTsTRbpwPsjRmhQBtT0izCgSsL6hEwMJ3BPsymxhufIL9FeEeb27BP;qCTzTpeknmJJsNTlBcqg7dwHqMD7dt0;NhxradUbxvg9HTYgfKEcRTCk3PZuJQSD87FBo0P5yKKtM:S09yyVuw1ryK:cizOU3KCt8ozdc1K5wBPEfrTIHwz;REIoRX:2xVpPDzCfo8B0rpPDsj11LEQTuGvrUNExr6PkqJmZwk0D;3yDQr4hTn2zxbYMfzy03AYLnwLT6lz9j7G1rygzZrqkXLw3gi0:JD1HuKTns0hR4XvbzACoZebuOrjmPyxk7cTNfmqlOA1EOX4bkkzwwucp4itZfaK5u8bjWCPKYjF4hwlrblIrH4RvmKwJAolDSwZjBHBAHrLAxyWbPooolWgU16BzcDrpINC8ihqDyLtrlqCsgVyQva;TEIFJ4IFJ4IFJ4IFJ4IFJ4IFJ4IFJ4IFJ4IFJ4IFJ5bxFzVdIJ0AG0lAW0l834U8n8k2bWQQzSBMYX;nwb9H8tb000MakD7" 
  unserialize. nm follic,follic_ endl v +

#@cli gwyddionread : _filename
#@cli : Read gwyddion ASCII file and produce image
#@cli : Data beginning after "Start of Data:" are imported
#@cli : [x-length, y-length, x-offset, y-offset, header lines] are returned in ${}
#@cli : gwyddion Example header
#@cli : |# File Format = ASCII
#@cli : |# Created by Gwyddion 2.48
#@cli : |# Original file: gwyddion_Example.asc
#@cli : |# x-pixels = 640
#@cli : |# y-pixels = 480
#@cli : |# x-length = 313789.96127244376
#@cli : |# y-length = 235219.70492879587
#@cli : |# x-offset = 0
#@cli : |# y-offset = 0
#@cli : |# Bit2nm = 1.0
#@cli : |# Start of Data:
gwyddionread : skip "${1=gwyddion_Example.asc}"
  e[^-1] "Read gwyddion ASCII text data: "$1
  v -
  l[]
    i raw:"$1",uchar nm={b}
    # Retrieve header information.
    s +,10
    size_x=-1 size_y=-1
    len_x=-1 len_y=-1
    offs_x=-1 offs_y=-1
    bit2nm=-1
    hend=-1
    repeat $!
      if   {same(['{$>,t}'],'"# x-pixels ="',12)} rows[$>] 12,100% size_x={{$>,t}}
      elif {same(['{$>,t}'],'"# y-pixels ="',12)} rows[$>] 12,100% size_y={{$>,t}}
      elif {same(['{$>,t}'],'"# x-length ="',12)} rows[$>] 12,100% len_x={{$>,t}}
      elif {same(['{$>,t}'],'"# y-length ="',12)} rows[$>] 12,100% len_y={{$>,t}}
      elif {same(['{$>,t}'],'"# x-offset ="',12)} rows[$>] 12,100% offs_x={{$>,t}}
      elif {same(['{$>,t}'],'"# y-offset ="',12)} rows[$>] 12,100% offs_y={{$>,t}}
      elif {same(['{$>,t}'],'"# Bit2nm ="',10)}   rows[$>] 10,100% bit2nm={{$>,t}}
      elif {same(['{$>,t}'],'"# Start of Data:"',16)} hend=$> break
      fi
    done
    if {$hend>0}
      rm[0-{$hend+1}] a y
       #e "Size = ("$size_x,$size_y,$len_x,$len_y,$hend")"
       # Save remaining data as a pure ascii file.
      discard 13
      file_tmp=${-file_rand}
      if {$!>1} o.. raw:$file_tmp,uchar rm.. i dlm:$file_tmp nm. $nm
        o.. raw:${file_tmp}_,uchar rm.. i dlm:${file_tmp}_ nm. ${nm}_ file_rm ${file_tmp}_
      else o raw:$file_tmp,uchar rm i dlm:$file_tmp nm. $nm
      fi
      file_rm $file_tmp
    else
      rm
    fi
    u [$len_x,$len_y,$offs_x,$offs_y,$bit2nm]
  endl
  v +

#@cli wykoread : _filename
#@cli : Read Wyko/Bruker/Vision ASCII file and produce image(s)
#@cli : Data preceded by "RAW_DATA" and/or "Intensity" are imported
#@cli : Wyko Example header
#@cli : |Wyko ASCII Data File Format 0	1	1
#@cli : |X Size	640
#@cli : |Y Size	480
#@cli : |Block Name	Type	Length	Value
#@cli : |Wavelength	7	4	71.992500
#@cli : |Aspect	7	4	1.000000
#@cli : |Pixel_size	7	4	0.000985
#@cli : |Magnification	8	8	10.050000
#@cli : |ScannerSpeed	7	4	2.315832
#@cli : |RAW_DATA	3	1228800
wykoread : skip "${1=Wyko_Example.ASC}"
  e[^-1] "Read Vision surface profilometry OPD text data: "$1
  v - l[]
    i raw:"$1",uchar nm={b}
    # Retrieve header information.
    s +,10
    size_x=-1 size_y=-1 hend=-1 rend=-1
    repeat $!
      if   {same(['{$>,t}'],'"X Size"',6)} rows[$>] 6,100% size_x={{$>,t}}
      elif {same(['{$>,t}'],'"Y Size"',6)} rows[$>] 6,100% size_y={{$>,t}}
      elif {same(['{$>,t}'],'"RAW_DATA"',8)} hend=$>
      elif {same(['{$>,t}'],'"Intensity"',9)} rend=$> break
      fi
    done
    if {$hend>0}
      rm[0-{$hend+1}]
      if {$rend>$hend} a[0-{$rend-$hend-3}] y rm[1,2] a[1--1] y else a y fi
      #-e "Size = ("$size_x,$size_y,$hend,$rend")"
      # Save remaining data as a pure ascii file.
      replace_str "Bad","nan"
      discard 13
      file_tmp=${-file_rand}
      if {$!>1} o.. raw:$file_tmp,uchar rm.. i dlm:$file_tmp nm. $nm
        o.. raw:${file_tmp}_,uchar rm.. i dlm:${file_tmp}_ nm. ${nm}_ file_rm ${file_tmp}_
      else o raw:$file_tmp,uchar rm i dlm:$file_tmp nm. $nm
      fi
      file_rm $file_tmp
      rotate -90,0
    else
      rm
    fi
  endl v +

#@cli pseudo_c : Pseudo coloring of greyscale image
pseudo_c : v - if {s!=1} to_gray. fi {iM},1,1,3,u(255) round. map.. . rm.  v +

#@cli sincos : _w(512), _h(512), _new(0)
#@cli : testimage
#@cli : $ sincos , +shift. 50%,0,0,0,2 +shift.. 0,50%,0,0,2 a c
sincos :
  skip "${1=512},${2=$1},${3=0}" v - l[]
  if {!!$3&&$_version>=216} $1,$2,1,1,'begin(a=pi*w;b=pi*h);i=sin(a/(x+1))*cos(b/(y+1));if(i<=0,i+=1,i);i*255'
  else
    $1,$2,1,1,'begin(a=pi*w;b=pi*h);sin(a/(x+1))*cos(b/(y+1))'
    +f. 'sign(i)' eq. 1 +neq. 1 *[1] ... *. ... n[-1,-2] 0,255
    f[-1,-2] 'if(i==255,0,i)' +[-1,-2] rm..
  fi
  nm. sincos endl v +

#@cli karo_luminance : _type = [itur1990 | itur1990-2 | gmic | gmic-2]
#@cli : Compute luminance of selected RGB images according
#@cli :   itur1990 | itur1990-2 sqr/sqrt | gmic luminance | sqr/sqrt gmic luminance.
#@cli : sRGB RGB and back only with gmic!
#@cli : Default _type=itur1990
#@cli : $ image.jpg +karo_luminance ,
karo_luminance : skip ${1=itur1990}
  e[^-1] "Compute luminance $1 of image$?."
  v - remove_opacity if {['"$1"']=='gmic'" || "['"$1"']=='gmic-2'} srgb2rgb fi
  repeat $! l[$>]
  if {s==3} sh 0,0 sh[0] 1,1 sh[0] 2,2
   if   {['"$1"']=='gmic'} *[1] 0.299 *[2] 0.587 *[3] 0.114 +[1-3] rm[1]
   elif {['"$1"']=='gmic-2'} sqr *[1] 0.299 *[2] 0.587 *[3] 0.114 +[1-3] sqrt rm[1]
   elif {['"$1"']=='itur1990-2'} sqr *[1] 0.212655 *[2] 0.715158 *[3] 0.072187 +[1-3] sqrt rm[1]
   else *[1] 0.212655 *[2] 0.715158 *[3] 0.072187 +[1-3] rm[1] fi
  elif {s!=1} norm n 0,255
  fi endl done
  channels 0
  if {['"$1"']=='gmic'" || "['"$1"']=='gmic-2'} rgb2srgb fi
  v +

#@cli karo_close : '_size>0','_shape=0|1|2' (square|octagon|circle),'_invert=0|1','_scale=0|1',
#@cli : '_channel=0..33' ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : Morphological closing (dilate and erode) of given size (only 2d)
#@cli :  with fx_morpho_v2 and implicitly apply_channels!
#@cli : $ image.jpg  +karo_close 15 +karo_close[0] 15,1 +karo_close[0] 15,2 rm[0]
karo_close :
  e "Compute closing image$?, with size $1 (only 2d)."
  skip ${1=5},${2=0},${3=0},${4=0},${5=0} check $2<3 v -
  if {$_version<175} fx_morpho 3,$1,$3,$2,$5,$4
  else fx_morpho_v2 3,$2,$1,"1,0,1; 0,1,0; 1,0,1",$3,1,$5,$4
  fi v +

#@cli karo_open : '_size>0', '_shape=0|1|2' (square|octagon|circle), '_invert=0|1', '_scale=0|1',
#@cli : '_channel=0..33 ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : Morphological opening (erode and dilate) of given size (only 2d)
#@cli :  with fx_morpho_v2 and implicitly apply_channels!
#@cli : $ image.jpg  +karo_open 15 +karo_open[0] 15,1 +karo_open[0] 15,2 rm[0]
karo_open :
  e "Compute opening image$?, with size $1 (only 2d)."
  skip ${1=5},${2=0},${3=0},${4=0},${5=0} check $2<3 v -
  if {$_version<175} fx_morpho 2,$1,$3,$2,$5,$4
  else fx_morpho_v2 2,$2,$1,"1,0,1; 0,1,0; 1,0,1",$3,1,$5,$4
  fi v +

#@cli karo_doc : '_size>0','_shape=0|1|2' (square|octagonal|circular),
#@cli : '_channel=0..33' ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : compute difference of open+close and original (only 2d)
#@cli : $ image.jpg +karo_doc 15,2,5
karo_doc :
  e "Compute difference of open/close and original image$?, with window size $1 (only 2d)." v -
  skip ${1=5},${2=1},${3=0}
  repeat $! l[$<]
    +karo_open[0] $1,$2,0,0,$3 +karo_close[0] $1,$2,0,0,$3
    +[-2,-1] /. 2 -
  endl done v +


#@cli karo_doo : _size1>0,_size2>0,_type=0..3 (ero/dil/open/close),_shape=0|1|2 (sqaure|octagon|circle),'_scale=0|1',
#@cli : '_channel=0..33' ("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@cli : Compute difference of math. morph operation on selected images (only 2d).
#@cli : $ image.jpg +karo_doo 10,15,2,2,0,3
karo_doo : skip ${1=5},${2=7},${3=2},${4=1},${5=0},${6=0}
  e[^-1] "Compute difference of mm op on image$?, with sizes $1 and $2 (only 2d)." v -
  repeat $! l[$<]
    +fx_morpho. $3,$1,0,$4,$6,0
     fx_morpho.. $3,$2,0,$4,$6,0
    if {{${3}&1}==0} rv[-2,-1] fi
    -[-2,-1]
    if {$5==1} n. 0,255 fi
  endl done v +

#@cli karo_label_sort :
#@cli : Rearrange a label image (the selected image) according to the region size
#@cli : $ 400,400 rand 0,1 b 3 ge 50% label 0,1 karo_label_sort threshold 50%
#@cli : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label_sort :
  e[^-1] "Sort labelled image$? by region size."
  v - repeat $! l[$>]
   nb={1+iM} mn={im} +histogram. $nb,0,{$nb-1}
   100%,1,1,1,x a[-2,-1] y sort. -,x rows. 1
   100%,1,1,1,x a[-2,-1] y sort. +,x rows. 1
   map.. . rm.
  endl done v +

#@cli karo_label : tolerance>=0,is_high_connectivity={ 0 | 1 },sort={ 0 | 1} : (+)
#@cli : Label connected components in selected images and possibly sort by region size.
#@cli : Default values: 'tolerance=0', 'is_high_connectivity=0' and 'sort=0'.
#@cli : $ image.jpg luminance threshold 60% label 0 normalize 0,255 map 0
#@cli : $ 400,400 set 1,50%,50% distance 1 mod 16 threshold 8 karo_label 0,,1 mod 255 map 2
#@cli : Author : <i>KaRo and David Tsch.</i>. Latest update : <i>2013/04/07</i>.
karo_label : check "$1>=0" skip ${2=0} skip ${3=0}
  e[^-1] "Label connected components on image$?, with tolerance $1, "${-arg\ 1+!$2,high,low}" connectivity and "${-arg\ 1+!$3,sorted,unsorted}
  v - repeat $! l[$>]
    label. $1,$2
    if {$3}
      nb={1+iM} +histogram. $nb,0,{iM}
      100%,1,1,1,x a[-2,-1] y sort. -,x rows. 1
      100%,1,1,1,x a[-2,-1] y sort. +,x rows. 1
      map.. . rm.
    fi
  endl done v +

#@cli karo_segmentarea : low
#@cli : Get all 4-connected non-zero regions of area>=low
#@cli : Delete small regions
#@cli : Number of remaining objects in status
karo_segmentarea :
  check "$1>0"
  v - repeat $! l[$>]
    neq. 0 label_fg. 0,0 +histogram. {iM+1},0,{iM} =. 0,0 ge. $1
    map.. . u {is} rm.
  endl done v +

#@cli karo_zerleg : Partition of binary image zero areas
#@cli : using pink watershed (https://pinkhq.com/hg/pink/file/tip/src/com/wshedtopo.c)
#@cli : $ sp 6 to_gray +threshold 140 +karo_zerleg. negate. label_fg. 0
#@cli : Author : <i>KaRo</i>. Latest update : <i>2017/11/30</i>.
karo_zerleg :
  e[^1] "Partition of binary image$? with pink watershed" v -
  repeat $! l[$>]
    +distance. 1 pink_wshed. 8,1 f. j(0,0)!=j(1,1)||j(1,0)!=j(0,1) skeleton. , or[0,-1]
  endl done v +

#@cli karo_threshold : _method={ triangle | yen | otsu | _otsu | bgt | intermeans | intera | rats | fixnnn | huang | huang2 | li },_delclass>0,_smooth>0
#@cli : Calculate threshold (from ImageJ) in range [0,255], evtl. normalization necessary.
#@cli : For each method user function _karo_"_method" is called!
#@cli : If {_delclass > 0} delete cluster {_delclass-1}.
#@cli : If {_smooth > 0} blur_x histogram with amplitude _smooth.
#@cli : No histogram processing for otsu, rats and intera!
#@cli : $ image.jpg luminance. karo_threshold. otsu
karo_threshold : skip ${1="triangle"} skip ${2=0} skip ${3=0}
  e[^-1] "Calculate "$1" thresholded mask from images$? with histogram in range [0,255] and binsize 1."
  v -
  if ${-strcontains\ $1,fix} meth=fix
  else meth=$1 fi
  if {['$meth']=='otsu'} otsu 256
  elif {['$meth']=='rats'} karo_rats ,
  elif {['$meth']=='intera'} threshold
  else repeat $!
    l[$>]
      if {['$meth']=='fix'} _karo_fix ,,$1
      else +histogram. 256,0,255
        if {$2>0} =. 0,{$2-1} fi
        if {$3!=0} tot={is} /. $tot blur_x. $3 /. {is} *. $tot round. fi
        +_karo_$meth. 0,1 rm.
      fi
      th=${}
      threshold[0] $th
# Concatenate results for image list
      if {$>==0} sres=$th else sres=$sres,$th fi
    endl done u $sres fi
  v +

#@cli _karo_fix : 0,1,fixnnn
#@cli : fix threshold nnn returned in status
_karo_fix :
  skip "${1=0} ${2=1} ${3=fix005}"
  u ${-strreplace\ $3,fix,\ }

#@cli _karo_triangle : _minval,_bins
#@cli : Calculate triangle threshold (from ImageJ auto thresholder)
#@cli : tested only with 256 classes from 0 to 255
#@cli : $ image.jpg luminance +histogram 256,0,255 _karo_triangle. , +threshold[0] ${}
_karo_triangle : skip "${1=0} ${2=1}"
  e[^-1] "Calculate triangle threshold from 1d histogram$? in range ["$1","{$1+(w-1)*$2}"]."
  v -
  repeat $! l[$>]
    ac=${-autocrop_coords.} wd={w}
    min={${-arg\ 1,$ac}} if {$min==1&&{@0}!=0} min=0 fi # corr autocrop_coords
    if {$min>0} min={$min-1} fi
    min2={${-arg\ 4,$ac}} if {$min2<{$wd-1}} min2={$min2+1} fi
    dmax={iM} max={xM}
    if {($max-$min)<($min2-$max)}
      inverted=1 mirror[0] x min={$wd-1-$min2} max={$wd-1-$max}
    else inverted=0 fi
    if {$min==$max} split=$min else
      nx={i($max)} ny={$min-$max}
      d={sqrt($nx*$nx+$ny*$ny)}
      nx={$nx/$d} ny={$ny/$d}
      d={$nx*$min+$ny*i($min)}
      +f. x *. $nx *.. $ny +[-1,-2] -. $d
      crop. {$min+1},$max
      if {$inverted} split={$wd-(xM+$min)} else split={xM+$min+1} fi
    fi
    res={$1+$split*$2}
# Concatenate results for image list
    if {$>==0} sres=$res else sres=$sres\,$res fi
    rm[0]
  endl done u $sres v +

#@cli _karo_yen : _minval,_bins
#@cli : Calculate yen threshold (from ImageJ auto thresholder)
_karo_yen :  skip "${1=0} ${2=1}" v -
  repeat $! l[$>]
    if $> r_yen=${} fi
    autocrop_coords. 0 range=${} mn=${-arg\ 1,$range} mx=${-arg\ 4,$range}
    /. {is}
    +cumulate.
    +sqr.. cumulate.
    +mirror... x sqr. cumulate. mirror[-1,-4] x
    *[-1,-2] log. replace_inf. {iM} *. -1
    +*.. -1.0 +. 1.0 *[-1,-3] log.. replace_inf.. {iM} *.. 2.0
    +[-1,-2] k.
    if {$mn>0} repeat $mn =. 0,$> done fi
    if {$mx<(w-1)} repeat {w-$mx} =. 0,{$mx+$>} done fi
    res={xM*$2+$1}
    rm.
    if $> u $r_yen,$res else u $res fi
  endl done v +

#@cli _karo__otsu : _minval(0) _bins(1)
#@cli : Calculate otsu threshold from a histogram
#@cli : with class o = _minval and bin size = _bins
#@cli : Threshold is stored in status
#@cli : $ image.jpg to_gray +histogram 256,0,255 _karo__otsu , threshold ${}
_karo__otsu : skip "${1=0} ${2=1}" v -
  l.
  /. {is}	#p
  +cumulate. x	#q_L
  ++. -1. negate.	#q_h
  +f. "x" +*[0] . rm.. cumulate. x
  ++. {-iM} negate.
  /.. [-4]	#miu_L
  /. ...	#miu_H
  -[-2,-1] sqr.
  *[-1--3] replace_nan. 0.0
  u {xM*$2+$1}
  rm
  endl
  v +

#@cli _karo_bgt : _minval,_bins
#@cli : Autothreshold using SD from whole image starting from the mode of the histogram (image range 0,255)
_karo_bgt: skip "${1=0} ${2=1}" v - fact=1.5
  l.
    hft=${-hist_feature\ -2} mn=${-arg\ 5,$hft} mx=${-arg\ 6,$hft} sd=${-arg\ 4,$hft} md=${-arg\ 1,$hft}
    if {($mx-$md)<=($md-$mn)} res={$md-$fact*$sd}
    else res={$md+$fact*$sd} fi
    u {$res*$2+$1} rm
  endl v +

#@cli _karo_intermeans : _minval,_bins
#@cli : Calculate intermeans threshold (from ImageJ autothreshold IsoData)
#@cli : from last selected data and store it in status
_karo_intermeans : skip "${1=0} ${2=1}"
  e[^-1] "Calculate intermeans threshold from last selected (1d) histogram$? in range ["$1","{$1+(w-1)*$2}"]." v -
  l. if {h>1||d>1||s>1} u "?" else
    split={"
      min=0; whiledo(i(min)==0,min++);
      max=w; whiledo(i(max)==0,max--);
      if(min>=max,res=w/2,
        mvI=min;
        dowhile(sum1=sum2=sum3=sum4=0.0;
        for(id=min,id<=mvI,id++,sum1+=id*i(id);sum2+=i(id));
        for(id=mvI+1,id<=max,id++,sum3+=id*i(id);sum4+=i(id));
        res=(sum1/sum2+sum3/sum4)/2.0;mvI++,
        (mvI+1)<=res&&mvI<(max-1)));
      round(res)"} rm
    u {$1+$split*$2} fi
  endl v +

#@cli karo_rats : _pow(0.5)
#@cli : Robust automatic threshold selection (Kittler et al. 1985)
#@cli : Input image (not histogram similar otsu!)
karo_rats :
  check ${1=0.5}>0
  e[^-1] "Calculate rats from image$? with power "$1"." v -
  repeat $! l[$>]
    +gradient_norm. pow. $1 gr={is} *. .. gri={is} res={$gri/$gr} rm.
    threshold. $res
# Concatenate results for image list
    if {$>==0} sres=$res else sres=$sres\,$res fi
  endl done
  u $sres v +

_karo_huang : skip "${1=0} ${2=1}"
# public static int Huang(int [] data ) {
# 	// Implements Huang's fuzzy thresholding method
# 	// Uses Shannon's entropy function (one can also use Yager's entropy function)
# 	// Huang L.-K. and Wang M.-J.J. (1995) "Image Thresholding by Minimizing
# 	// the Measures of Fuzziness" Pattern Recognition, 28(1): 41-51
# 	// M. Emre Celebi  06.15.2007
# 	// Ported to ImageJ plugin by G. Landini from E Celebi's fourier_0.8 routines
  huang={"
           threshold=-1;
           first_bin=0;
           for(ih=0,ih<w,if(i(ih)!=0,first_bin=ih;break());ih++);
           last_bin=w-1;
           for(ih=w-1,ih>=first_bin,if(i(ih)!=0,last_bin=ih;break());ih--);
           term = 1.0 / ( last_bin - first_bin );
           mu_0=["{^}"];
           sum_pix = num_pix = 0;
           for ( ih = first_bin, ih < w, sum_pix += ih * i(ih); num_pix += i(ih);
             mu_0[ih] = sum_pix / num_pix; ih++ );
           mu_1 = mu_0;
           sum_pix = num_pix = 0;
           for (ih = last_bin, ih > 0, sum_pix+=ih*i(ih);
             num_pix += i(ih);
             mu_1[ih-1] = sum_pix / num_pix; ih-- );
           min_ent = 1e31;
           for (it = 0, it < w,
             ent = 0.0;
             for (ih = 0,ih<=it,
               mu_x = 1.0 / ( 1.0 + term * abs(ih - mu_0[it]));
               if (!((mu_x  < 1e-06)||(mu_x > 0.999999)),
                 ent += i(ih) * ( -mu_x * log ( mu_x ) - ( 1.0 - mu_x ) * log ( 1.0 - mu_x )));
               ih++);
             for (ih = it + 1, ih < w,
               mu_x = 1.0 / ( 1.0 + term * abs (ih - mu_1[it]));
               if (!((mu_x  < 1e-06)||(mu_x > 0.999999)),
                 ent += i(ih) * ( -mu_x * log ( mu_x ) - ( 1.0 - mu_x ) * log ( 1.0 - mu_x )));
               ih++);
             if (ent < min_ent, min_ent = ent; threshold = it; _(print(min_ent,threshold)));
             it++ );
           threshold"}
  u {$huang*$2+$1} rm

_karo_huang2 : skip "${1=0} ${2=1}"
  huang2={"
#	// Implements Huang's fuzzy thresholding method
#	// Uses Shannon's entropy function (one can also use Yager's entropy function)
#	// Huang L.-K. and Wang M.-J.J. (1995) "Image Thresholding by Minimizing
#	// the Measures of Fuzziness" Pattern Recognition, 28(1): 41-51
#	// Reimplemented (to handle 16-bit efficiently) by Johannes Schindelin Jan 31, 2011
           for(first=0,first<w&&i(first)==0,first++);
           for(last=w-1,last>first&&i(last)==0,last--);
           if(first==last,break());
           S=["{^}"]; W=S;
           S[0]=i(0);
           for(ii=max(1,first),ii<=last,S[ii]=S[ii-1]+i(ii);W[ii]=W[ii-1]+ii*i(ii);ii++);
           C=last-first;
           Smu=S;
           for(ii=1,ii<(C+1),mu=1/(1+ii/C);Smu[ii]=-mu*log(mu)-(1-mu)*log(1-mu);ii++);
           bestThreshold = 0;
           bestEntropy = 1e31;
           for(threshold=first,threshold<=last,
             entropy=0; mu=round(W[threshold]/S[threshold]);
             for(ii=first,ii<=threshold,entropy+=Smu[abs(ii-mu)]*i(ii);ii++);
             mu=round((W[last] - W[threshold]) / (S[last] - S[threshold]));
             for(ii=threshold+1,ii<=last,entropy+=Smu[abs(ii-mu)]*i(ii);ii++);
             if(bestEntropy>entropy,bestEntropy=entropy;bestThreshold=threshold);
             threshold++);
           bestThreshold"}
           u {$huang2*$2+$1} rm

_karo_li : skip "${1=0} ${2=1}"
  li={"
#public static int Li(int [] data ) {
#// Implements Li's Minimum Cross Entropy thresholding method
#// This implementation is based on the iterative version (Ref. 2) of the algorithm.
#// 1) Li C.H. and Lee C.K. (1993) "Minimum Cross Entropy Thresholding"
#//    Pattern Recognition, 26(4): 617-625
#// 2) Li C.H. and Tam P.K.S. (1998) "An Iterative Algorithm for Minimum
#//    Cross Entropy Thresholding"Pattern Recognition Letters, 18(8): 771-776
#// 3) Sezgin M. and Sankur B. (2004) "Survey over Image Thresholding
#//    Techniques and Quantitative Performance Evaluation" Journal of
#//    Electronic Imaging, 13(1): 146-165
#//    http://citeseer.ist.psu.edu/sezgin04survey.html
#// Ported to ImageJ plugin by G.Landini from E Celebi's fourier_0.8 routines
      tolerance=0.5;
      num_pixels=0;
      mean = 0.0;
      for (ih = 0, ih < w, ih++, num_pixels += i(ih);mean += ih * i(ih));
      mean /= num_pixels;
      new_thresh = mean;
      dowhile(
        old_thresh = new_thresh;
        threshold = (old_thresh+0.5);
        sum_back = 0;
        num_back = 0;
        for ( ih = 0, ih<=threshold, ih++,
          sum_back += ih * i(ih);
          num_back += i(ih));
        if(num_back == 0,mean_back=0.0,mean_back=(sum_back/num_back));
        sum_obj = 0;
        num_obj = 0;
        for ( ih = threshold + 1, ih < w, ih++,
          sum_obj += ih * i(ih);
          num_obj += i(ih));
        if(num_obj == 0,mean_obj=0.0,mean_obj=(sum_obj/num_obj));
        temp = ( mean_back - mean_obj ) / ( log ( mean_back ) - log ( mean_obj ) );
        if (temp < -2.220446049250313e-16, new_thresh=floor(temp - 0.5),new_thresh=floor(temp + 0.5)),
        abs(new_thresh-old_thresh)>tolerance);
      threshold"}
  u {$li*$2+$1} rm

#@cli _kr_histogram : _nb_levels>0[%],_value0[%],_value1[%]
#@cli : Computes the histogram and returns in status the value of first class and the bin size
#@cli : _nb_levels
#@cli : _value0
#@cli : _value1
#@cli : Default values: 'nb_levels=256', '_value0=0%', '_value1=100%'
#@cli : $ sp barbara /. 2 +. 32 _kr_histogram , e ${} dg 600,300,3
_kr_histogram : skip "${1=256} ${2=0%} ${3=100%}" v -
  if ${-is_percent\ $2} mn={im+(iM-im)*$2} else mn=$2 fi
  if ${-is_percent\ $3} mx={im+(iM-im)*$3} else mx=$3 fi
  u {$mn},{($mx-$mn)/($1-1)}
  histogram. ${1-3} v +

#@cli _kr_histogram8 : _nb_levels>0[%],_value0[%],_value1[%]
#@cli : same as _kr_histogram, still defaults to byte data (256,0,255) instead of (256,0%,100%)
#@cli : $ sp dog _kr_histogram8 {iM-im+1},{im},{iM} e ${} dg 600,300,3
_kr_histogram8 : skip "${1=256} ${2=0} ${3=255}" v - _kr_histogram. ${1-3} v +

#@cli hist_percentile : _nth[%],_zero={0|1},_min0,_stepw
#@cli : Estimation of _nth percentiles (lower & upper) from histogram and returning value(s) in status (${})
#@cli : _zero Class 0 is zeroed if !=0
#@cli : _min0 value of class 0
#@cli : _stepw value of class width (bin size)
#@cli : Default values: 'nth=25%', '_zero=0', '_min0=0', '_stepw=1'
#@cli : $ image.jpg luminance +dh ,,256,0,255 histogram.. 256,0,255 hist_percentile.. , rm.. t=${} text $t,40,5,23,1,128
hist_percentile :
  check "${1=25%}>=0"
  skip ${2=0},${3=0},${4=1}
  e[^-1] "Calculate $1 percentile from 1d histogram$?."
  v - repeat $!
    l[$>]
      if {h>1||d>1||s>1} v + e[^-1] "Image "$>" seemingly not 1d!" v - continue fi
  # Delete class zero
      if {$2!=0} set. 0,0 fi
  # Calculate features
      m0={is}
      N={if(${"-is_percent $1"},$m0*$1,$1)}
      if {{$m0*$1}==0} N=1 O=$m0 else O={$m0-$N} fi
  #-echo_stdout $m0,$N
  # Percentile
      +cumulate.
      +ge. $N mn={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} rm.
      +ge. $O mx={${-arg\ 1,{[xM,yM,zM,cM]}}*$4+$3} rm[-1,-2]
  # Prepare result for one image
      res=$mn\,$mx
  # Concatenate results for image list
      if {$>==0} sres=$res else sres=$sres\,$res fi
    endl
  done u $sres v +

#@cli hist_feature : _nofeature>=-2,_nth>0,_zero={0|1},_min0,_stepw,_percent[%]>0
#@cli : Estimation from histogram (frequency dist, 1d image) the features
#@cli :  'mode','sum' (m0),'mean' (m1),'SD' (m2),'min','max','median','iqr' (hiq-loq+1),'loq','hiq' returned in status (${}).
#@cli : nofeature=-2 mode,m0,m1,m2,min,max,med,iqr,loq,hiq,
#@cli :   -1 mode,0 sum,1 mean,2 SD,3 min,4 max,5 median,
#@cli :    6 iqr (interquantile range),7 loq (lower quantile),8 hiq (higer qunatile)
#@cli : nth extreme value (nth+1 occurence!)
#@cli : zero Class 0 is zeroed if !=0
#@cli : min0 value of class 0
#@cli : stepw value of class width (bin size)
#@cli : percent quantile
#@cli : Default valalues: '_nofeature=-2', '_nth=1', '_zero=0', '_min0=0', '_stepw=1', '_percent=25%'
#@cli : Updated 140314 (smoothing replaced by nth selection)
#@cli : Updated 100817 (percent parameter and iqr,loq,hiq feature added)
#@cli : $ image.jpg luminance +histogram 256,0,255 dh.. ,,256,0,255 hist_feature , repeat 8 t={_arg($>+1${})} text $t,40,{$>*25+5},23,1,128 done rm.
hist_feature :
  check "${1=-2}>=-2&&$1<=8&&isint($1)&&isint(${2=1})&&$2>0"
  skip ${3=0},${4=0},${5=1},${6=25%}
  e[^-1] "Calculate md,m0,m1,m2,$2.min,$2.max,med,iqr,loq,hiq from 1d histogram$?."
  v -
  repeat $!
    l[$>]
      if {h>1||d>1||s>1} v + e[^-1] "Data["$>"] seemingly not 1d!" v - continue fi
  # Delete class zero
      if {$3!=0} =. 0,0 fi
  # Calculate features
      md={xM*$5+$4}
      m0={is}
      +*. 'x*$5+$4' m1={is/$m0} rm.
      +*. '(x*$5+$4)^2' m2={sqrt(is/$m0-$m1^2)} rm.
  # nth-min, nth-max, Median
      mn={"l=0; su=i(0); whiledo(su<"$2"&&l<w, l++; su+=i(l)); l*"$5"+"$4}
      mx={"l=w; su=0; whiledo(su<"$2"&&l>=0,l--; su+=i(l)); l*"$5"+"$4}
      med1={"l=0; su=0; whiledo(su<=(is/2)&&l<w, su+=i(l); l++); l"}
      med2={"l=w; su=0; whiledo(su<=(is/2)&&l>=0, l--; su+=i(l)); l"}
      med={($med1+$med2)/2*$5+$4}
  # iqr
      hist_percentile. $6,$3,$4,$5 qu=${}
      hiq=${-arg\ 2,$qu}
      loq=${-arg\ 1,$qu}
      iqr={${-arg\ 2,$qu}-${-arg\ 1,$qu}+1}
      if {$iqr<-1} iqr-=2 fi
  # Prepare result for one image
      res=$md\,$m0\,$m1\,$m2\,$mn\,$mx\,$med\,$iqr\,$loq\,$hiq
      if {$1>-2} res=${-arg\ {$1+2},$res} fi
  # Concatenate results for image list
     if {$>==0} sres=$res else sres=$sres\,$res fi
    endl
  done u $sres v +

#@cli hist_feature_demo : Parameters like in hist_feature
#@cli : (Plot) of features in blue into the histogram with Gaussian in green
#@cli : $ sp 0 luminance +threshold 40 * histogram 256,0,255 = 0,0 hist_feature_demo , dg 600,300,3
hist_feature_demo :
  check "${1=-2}>=-2&&$1<=8&&isint($1)&&isint(${2=1})&&$2>0"
  skip ${3=0},${4=0},${5=1},${6=25%}
  e[^-1] "Plot features from hist_feature into 1d histogram$?." v -
  l.
  hist_feature. -2,${2-6} vv=${}
  md=${-arg\ 1,$vv} m0=${-arg\ 2,$vv} m1=${-arg\ 3,$vv} m2=${-arg\ 4,$vv}
  mn=${-arg\ 5,$vv} mx=${-arg\ 6,$vv} med=${-arg\ 7,$vv}
  lo=${-arg\ 9,$vv} hi=${-arg\ 10,$vv}
  +gaussian. $m2,0,0 shift. {-w/2+$m1} *. {$m0/is} round. 1
  v={iM#-2}
  +*. 0
  =. $v,$md =. $v,$m1 =. {$v*0.25},$mn =. {$v*0.25},$mx =. $v,$med
  =. {$v*(1-$6)},$lo =. {$v*(1-$6)},$hi
  a c
  u $vv
  endl v +

#@cli karo_nth_max : _n(1),_ind(=0)
#@cli : Return in the status the _n-th max or the index of the n-th max of an image
#@cli : Possibility to fetch the index instead of the value (_ind=1)
karo_nth_max : check "isint(${1=1}) && $1>0" skip ${2=0}
  e[^-1] "Return in the status the $1-th max of image$?."
  v - repeat $! l[$>]
#     [0] repeat {$1-1} set. {im},{[xM,yM,zM,cM]} done
#     if $2 mx={xM} else mx={iM} fi rm.
     if {$2} eval argkth(-$1,{^}) u {${}-1} else eval kth(-$1,{^}) fi mx=${}
     if {$>==0} mx1=$mx else mx1=$mx1,$mx fi
  endl done u $mx1 v +

#@cli karo_nth_min : _n(1),_ind(=0)
#@cli : Return in the status the _n-th min of an image or the index of the _n-th min of an image
#@cli : Possibility to fetch the index instead of the value (_ind!=1)
karo_nth_min : check "isint(${1=1}) && $1>0" skip ${2=0}
  e[^-1] "Return in the status the $1-th min of image$?."
  v - repeat $! l[$>]
#     [0] repeat {$1-1} set. {iM},{[xm,ym,zm,cm]} done
#     if $2 mn={xm} else mn={-im} fi rm.
     if {$2} eval argkth($1,{^}) u {${}-1} else eval kth($1,{^}) fi mn=${}
     if {$>==0} mn1=$mn else mn1=$mn1,$mn fi
  endl done u $mn1 v +

#@cli karo_xcimg : programname ,parameterlist :
#@cli : Call external CImg Example 'programname'
#@cli : which has to be found in PATH by external call by
#@cli : 'programname' image_in 'parameterlist' image_out
#@cli : with writing image_in and reading after execution image_out
karo_xcimg :
  filename=${-file_rand}
  if {!${-is_windows}}
    x "which "$1" >/dev/null 2>&1"
    if ${} v + e "executable "$1" not found in PATH, status = "${}"!! Returning!!\n" v -
    {w},{h} fx_logo "exec Error !!" return fi
  fi
  o ${filename}.cimg
  x "$1 -i "${filename}".cimg $2 -o "${filename}".cimg"
  if ${} v + e "Status is "${}"." v - {w},{h} fx_logo "exec Error !!"
  else i ${filename}.cimg fi
  file_rm ${filename}.cimg

#@cli karo_li2st : p1,p2,...,pn
#@cli : Convert comma separated list to space separated string.
karo_li2st :
  v - u "" if {$#>=1} ({"'${1--1}'"}) replace. {','},{"' '"} u {t} rm. fi v +

#@cli karo_skeleton : _p1,..,p2n : (-median,0,-inv,0|1,-t,-0.3,-curve,0|1,-corr,0|1,-dlt,1)
#@cli : Execute use_skeleton (CImg demo) external.
karo_skeleton : v - if {$#>0} karo_li2st ${1--1} p=${} else p="" fi v +
  e "Compute use_skeleton exec with options "$p" on$?" v -
  repeat $! l[$>]
   s={s} if {$s>1} s. c fi
   repeat $! l[$>] karo_xcimg use_skeleton,${p}" -visu 0" mv. 0 k[0] endl done
   if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli karo_nlmeans : _p1,..,pn=-zoom,1,-ng,0|1,-nu,0|1,-ns,0|1,-p,1,-lambda,-1,-sigma,-1,-alpha,3,-sampling,1
#@cli : Execute use_nlmeans  (CImg demo) external. (see also q-nlmeans p=4,lambda=4,sigma=10)
karo_nlmeans : v - if {$#>0} karo_li2st ${1--1} p=${} else p="" fi v +
  e "Compute use_nlmeans exec with options "${p}" on$?" v -
  repeat $! l[$>]
   s={s} if {$s>1} s. c fi
   repeat $! l[$>] karo_xcimg use_nlmeans,${p}" -visu 0" mv. 0 k[0] endl done
   if {$s>1} a[-$s--1] c fi
  endl done v +

#@cli karo_VST : _inverse(=0)
#@cli : Variance Stabilizing Transformation
#@cli : following http://hal.archives-ouvertes.fr/docs/00/51/08/66/PDF/Burst_Hal.pdf
#@cli : $ image.jpg e ${-std_noise} karo_VST 0 e ${-std_noise} +karo_VST 1
karo_VST :
  v - skip ${1=0} if $1 inv=" (inverse)." else inv="." fi v +
  e[^-1] "Variance Stabilizing Transformation"$inv v -
  repeat $! l[$>]
    if $1 /[0] 2 sqr[0] -[0] {3/8} else +[0] {3/8} sqrt[0] *[0] 2 fi
  endl done v +

#@cli pearson_correlation
#@cli : Compute pearson-correlation using two-by-two selected images.
#@cli : $ image.jpg +shift -30,-20 pearson_correlation e ${}
pearson_correlation :
  e[^-1] "Compute pearson-correlation using two-by-two image$?."
  v - repeat {int($!/2)} l[{$>*2},{$>*2+1}]
    +-[0] {0,ia} +-[1] {1,ia} +*[2,3]
    sqr[2,3] #-*[2,3]
    r={ia/sqrt({2,ia}*{3,ia})}
    if {$>==0} u $r else u ${},$r fi
    rm[2-4]
  endl done v +

#@cli karo_extinction : _whitevalue[%]
#@cli : Convert (integer) transmission image into extinction with _whitevalue.
#@cli : Def. val.: '_whitevalue=100%'
karo_extinction : check "${1=100%}>0"
  e[^-1] "Convert transmission image$? into extinction with white value $1." v -
  repeat $! l[$>]
    if ${-is_percent\ $1} WW={iM*$1} else WW=$1 fi
    c. 1,{iM} /. $WW log10. *. -1
  endl done v +

#@cli karo_rndbit0 :
#@cli : Randomize in [0..255] (byte) image$? bit level 0. wow randomize numbers to even and odd"
karo_rndbit0 :
  e[^-1] "Randomize in [0..255] (byte) image$? bit level 0." v -
  repeat $! l[$>] and 254 +rand 0,1 round. or endl done v +

#@cli karo_dtpread : filename,_bit0
#@cli : Read dtp image file format
#@cli :   (512 byte header, col[22-24] x row[25-27] byte image)
#@cli : with _bit0 != 0 bit level 1 is extracted as binary mask
#@cli :   and bit level 1 in the gray image is randomized with karo_rndbit0
#@cli : Ex.: karo_dtpread Images/Beispiele/tra005.cel,1
karo_dtpread : check $1 check "${2=0}>=0"
  e[^-1] "Read dtp image file from $1." v -
  i raw:$1,uchar
  ({@22-24}) x={t} rm.
  ({@25-27}) y={t} rm.
  ({@0-79}) _dtph={t} rm.
  crop. 0,512,0,{h}
  resize. $x,$y,1,1,-1
  if $2
    +and. 1 karo_rndbit0..
  fi
  v +

#@cli _kr_ch2ch : number
#@cli : return alpha channel mode string from number in status
#@cli : Ex. v - repeat 51 _kr_ch2ach $> echo_stdout $>,${} done v +
_kr_ch2ch :
  if {isval("$1")} if {isint("$1")}
  u ${-arg\ 1+$1,all,rgba,rgba_r,rgba_g,rgba_b,rgba_a,rgb,rgb_r,rgb_g,rgb_b,\
  lrgb,lrgb_r,lrgb_g,lrgb_b,ycbcr,ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
  lab,lab_l,lab_ab,lab_a,lab_b,lch,lch_l,lch_ch,lch_c,lch_h,\
  hsv,hsv_h,hsv_s,hsv_v,hsi,hsi_h,hsi_s,hsi_i,hsl,hsl_h,hsl_s,hsl_l,\
  cmy,cmy_c,cmy_m,cmy_y,cmyk,cmyk_c,cmyk_m,cmyk_y,cmyk_k}
  else u "$1" fi else u "$1" fi

#@cli descriptive_feature :
#@cli : Estimation of features number(sum,m0),mean(m1),SD(m2),skewness(m3),kurtosis(m4),min,max,median
#@cli : from skalar images
#@cli : Ex.: image.jpg to_gray descriptive_feature e ${}
descriptive_feature :
  e[^-1] "Calculate m0,m1,m2,m3,m4,min,max,med from data$?."
  v -
  repeat $! l[$>]
    if {s>1} v + e[^-1] "Data ["$>"] seemingly not skalar! Break!" v - continue fi
# Calculate features
    if {$_version>=216} res={"
      ff=stats(); ff[3]=sqrt(ff[3]); _(print(ff));
      m3=0;m4=0;for(ip=0,ip<whds,ip++,m3+=(i[ip]-ff[2])^3;m4+=(i[ip]-ff[2])^4);
      res=[whds,ff[2,2],m3/(whds*(ff[3])^3),m4/(whds*(ff[3])^4)-3,ff[0,2],ic()];
      _(print(res)); res"}
    else
      m0={whds} m1={ia} m2={sqrt(iv)} med={ic} mx={iM} mn={im}
      +- $m1 pow. 3 m3={is/($m0*$m2^3)} rm.
      +- $m1 pow. 4 m4={is/($m0*$m2^4)-3} rm.
      res=$m0\,$m1\,$m2\,$m3\,$m4\,$mn\,$mx\,$med
    fi
# Concatenate results for image list
      if {$>==0} sres=$res else sres=$sres\,$res fi
  endl done u $sres v +

#@cli mmorpho : action, _kernel(0), _size(5), _ckernel("1,0,1; 0,1,0; 1,0,1")
#@cli : Mathematical morphology filter
#@cli : action={0=Ero | 1=Dil | 2=Open | 3=Close | 4=Ori-Ero | 5=Dil-Ori | 6=Ori-Open | 7=Close-Ori | 8=(Ori*2-(Open+Close))*0.5 | 9=Close-Open}
#@cli : _kernel={0=Square | 1=Octogon | 2=Circle | 3=Custom}
#@cli : _size>=2(5)
#@cli : _ckernel (custom kernel only if _kernel==3)
#@cli : Derived from D Tschumperle's fx_morpho_v2 (gmic_stdlib.gmic)
mmorpho :
  skip "${2=0} ${3=5} ${4=1,0,1; 0,1,0; 1,0,1}"
  v - ac=Ero,Dil,Open,Close,"Ori-Ero","Dil-Ori","Ori-Open","Close-Ori","(Ori*2-(Open+Close))*0.5","Close-Open"
  ke=Square,Octagon,Circle,Custom v +
  e[^-1] "Math. morph. filter "${-arg\ {$1+1},$ac}" with kernel "${-arg\ {$2+1},$ke}" and size "$3 v -
  ({'"$4"'}) f. "(i>=_'0' && i<=_'9') || i==_',' || i==_';'?i:-1" discard. -1 ckernel={t} rm.
  if {$2==0} m "my_erode: erode $""1" m "my_dilate: dilate $""1"
  elif {$2==1} m "my_erode: erode_oct $""1" m "my_dilate: dilate_oct $""1"
  elif {$2==2} m "my_erode: erode_circ $""1" m "my_dilate: dilate_circ $""1"
  else
  m "my_erode : ("$ckernel") erode[^-1] . skip $""1"" rm."
  m "my_dilate : ("$ckernel") dilate[^-1] . skip $""1"" rm."
  fi
  if {$1==0} m "my_action : my_erode $3"
  elif {$1==1} m "my_action : my_dilate $3"
  elif {$1==2} m "my_action : my_erode $3 my_dilate $3"
  elif {$1==3} m "my_action : my_dilate $3 my_erode $3"
  elif {$1==4} m "my_action : +my_erode $3 -"
  elif {$1==5} m "my_action : +my_dilate $3 rv -"
  elif {$1==6} m "my_action : +my_erode $3 my_dilate. $3 -"
  elif {$1==7} m "my_action : +my_dilate $3 my_erode. $3 rv -"
  elif {$1==8} m "my_action : +my_erode $3 my_dilate. $3 +- rm.. +my_dilate.. $3 my_erode. $3 rv[-1,-3] -[-1,-3] rv - / 2"
  elif {$1==9} m "my_action : +my_erode $3 my_dilate. $3 my_dilate.. $3 my_erode.. $3 -"
  else m "my_action : +my_dilate $3 my_erode. $3 rv -"
  fi
  repeat $! l[$>]
  my_action[0]
  endl done
  uncommand my_erode,my_dilate,my_action
  v +

#@gui CImg Skeleton : fx_karo_cimg_skel, fx_karo_cimg_skel_preview(0)
#@gui : Auto-threshold = bool(1)
#@gui : Threshold \% = float(50,0,100)
#@gui : Size Median = int(0,0,15)
#@gui : Invert = bool(false)
#@gui : Threshold on flux = float(-0.3,-5,5)
#@gui : Medial curve = bool(false)
#@gui : Torsello correction =bool(false)
#@gui : Discrete step = int(1,1,15)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Skeleton using CImg example plugin use_skeleton.)
#@gui : note = note{"CImg Skeleton: <i>use_skeleton</i> in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")
#@cli fx_karo_cimg_skel : auto_thresh(1),thresh(50\%),median(0),invert(0),thresh_flux(-0.3),medial_curve(0),Torsello corr(0),steps(1)
#@cli : Execute use_skeleton (CImg demo) external.
fx_karo_cimg_skel :
  skip "${1=1}","${2=50}","${3=0}","${4=0}","${5=-0.3}","${6=0}","${7=0}","${8=1}"
  if $1 otsu 256 else threshold ${2}% fi
  karo_skeleton median,$3,-inv,$4,-t,$5,-curve,$6,-corr,$7,-dlt,$8 n 0,255

fx_karo_cimg_skel_preview :
  gui_split_preview "-fx_karo_cimg_skel ${1-8}",${-3--1}

#@gui CImg nlmeans : fx_karo_cimg_nlmeans, fx_karo_cimg_nlmeans_preview(0)
#@gui : Add Gauss noise = float(0.0,0.0,30.0)
#@gui : Add uniform noise = float(0.0,0.0,30.0)
#@gui : Add Salt &amp; Pepper noise = float(0.0,0.0,30.0)
#@gui : Half size of patch = int(1,1,15)
#@gui : Band width lambda = float(-1,-1,25)
#@gui : Noise SD sigma = float(-1,-1,25)
#@gui : Neighborhood size alpha = int(3,1,15)
#@gui : Sampling step size = int(2,1,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Smoothing using CImg example plugin use_nlmeans.)
#@gui : note = note{"CImg nlmeans: <i>use_nlmeans</i> in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")
#@cli fx_karo_cimg_nlmeans : add_Gauss_noise(0),add_uniform_noise(0),add_salt_pepper(0),patch_size(0),lambda(-1),noise_sd(-1),alpha(3),steps(2)
#@cli : Execute use_nlmeans (CImg demo) external.
fx_karo_cimg_nlmeans :
  skip "${1=0}","${2=0}","${3=0}","${4=1}","${5=-1}","${6=-1}","${7=3}","${8=2}"
  karo_nlmeans -ng,$1,-nu,$2,-ns,$3,-p,$4,-lambda,$5,-sigma,$6,-alpha,$7,-sampling,$8

fx_karo_cimg_nlmeans_preview :
  gui_split_preview "-fx_karo_cimg_nlmeans ${1-8}",${-3--1}

#@gui mM Differences : fx_karo_mm_diff, fx_karo_mm_diff_preview(0)
#@gui : Size = int(5,1,25)
#@gui : Size2 = int(7,1,25)
#@gui : Operation = choice(2,"Erosion","Dilation","Open","Close")
#@gui : Shape = choice(1,"Square","Octagon","Circle")
#all,rgba,rgba_r,rgba_g,rgba_b,rgba_a,rgb,rgb_r,rgb_g,rgb_b,\
#lrgb,lrgb_r,lrgb_g,lrgb_b,ycbcr,ycbcr_y,ycbcr_cbcr,ycbcr_cb,ycbcr_cr,ycbcr_cg,\
#lab,lab_l,lab_ab,lab_a,lab_b,lch,lch_l,lch_ch,lch_c,lch_h,\
#hsv,hsv_h,hsv_s,hsv_v,hsi,hsi_h,hsi_s,hsi_i,hsl,hsl_h,hsl_s,hsl_l,\
#cmy,cmy_c,cmy_m,cmy_y,cmyk,cmyk_c,cmyk_m,cmyk_y,cmyk_k
#@gui : Channel(s) = choice(0,"all","rgba","rgba_r","rgba_g","rgba_b","rgba_a","rgb","rgb_r","rgb_g","rgb_b","lrgb","lrgb_r","lrgb_g","lrgb_b","ycbcr","ycbcr_y","ycbcr_cbcr","ycbcr_cb","ycbcr_cr","ycbcr_cg","lab","lab_l","lab_ab","lab_a","lab_b","lch","lch_l","lch_ch","lch_c","lch_h","hsv","hsv_h","hsv_s","hsv_v","hsi","hsi_h","hsi_s","hsi_i","hsl","hsl_h","hsl_s","hsl_l","cmy","cmy_c","cmy_m","cmy_y","cmyk","cmyk_c","cmyk_m","cmyk_y","cmyk_k")
#@gui : Scale = bool(true)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
##@gui : Best with odd sizes!
#@gui : sep = separator(), note = note("Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.")
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>. Latest update : <i>2012/10/26</i>.</small>")
#@cli fx_karo_mm_diff : _size,_size2,_operation,_shape,_channel,_scale
#@cli : Compute difference of math. morph. operation with two sizes on selected images.
#@cli : _size = int(5,1,25)
#@cli : _size2 = int(7,1,25)
#@cli : _operation = choice(2,"Erosion","Dilation","Open","Close")
#@cli : _shape = choice(1,"Square","Octagon","Circle")
#@cli : _channel = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@cli : _scale = bool(true)
##@cli : Best with odd sizes!
#@cli : Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.
#@cli : Author : <i>KaRo</i>. Latest update : <i>2013/07/09</i>.
fx_karo_mm_diff :
  skip "${1=5}","${2=7}","${3=2}","${4=1}","${5=0}","${6=1}"
  if {$2<=$1} s2={$1+2} else s2=$2 fi
  karo_doo $1,${s2},$3,$4,$6,$5
  to_rgb

fx_karo_mm_diff_preview :
  gui_split_preview "-fx_karo_mm_diff ${1-6}",${-3--1}

#@gui oC Differences : fx_karo_oc_diff, fx_karo_oc_diff_preview
#@gui : Size = int(5,2,25)
#@gui : Shape = choice(1,"Square","Octagon","Circle")
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : Scale =bool(true)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
##@gui : Best with odd sizes!
#@gui : sep = separator(), note = note("Difference of mean of morphological opening and closing with original.")
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2013/07/04</i>.</small>")
#@cli fx_karo_oc_diff : _size,_shape,_channel,_scale
#@cli : Compute difference of math. morph opening and closing on selected images.
#@cli : _size = int(5,1,25)
#@cli : _shape = choice(1,"Square","Octagon","Circle")
#@cli : _channel = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@cli : _scale = bool(true)
##@cli : Best with odd sizes!
#@cli : Arithmetical difference of a morphological operation of <i>size</i> and <i>size2</i>.
#@cli : Author : <i>KaRo</i>. Latest update : <i>2013/07/09</i>.
fx_karo_oc_diff :
  skip "${1=5}","${2=1}","${3=0}","${4=1}"
  apply_channels "-karo_doc $1,$2,0",$3,$4
  to_rgb

fx_karo_oc_diff_preview :
  gui_split_preview "-fx_karo_oc_diff ${1-4}",${-3--1}


#@cli fx_pink : Pink example, _operator(=11), _connect(=0), _smooth(=0), _param(=5), _channel(=0)
#@cli : _operator = 0..19 ("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima","grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg","dilatballnum","erosballnum","lintophat")
#@cli : _connect = 0..1 ("Four/x","Eight/y")
#@cli : _smooth = 0..
#@cli : _param = 0..25
#@cli : _channel = 0..22 ("All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@cli : $ image.jpg +fx_pink , +-
#@cli : $ image.jpg +fx_pink. 12,1,0.582524,10,0,0 +fx_pink.. 12,0,0.582524,10,0,0 +[-1,-2] # asflin in x and y
#@gui Pink operator : fx_pink, fx_pink_preview(1)
#@gui : Pink operator = choice("wshedtopo","wshedtopo inv","minima","maxima","heightminima","heightmaxima","grayskel","htkern","htkernu","lvkern","lvkernu","asf","asflin","asfr","asft","asftmed","asftndg","dilatballnum","erosballnum","lintophat")
#@gui : Connectivity / Dir = choice("Four/x","Eight/y")
#@gui : Smoothness = float(0,0,5)
#@gui : Height/Rep = int(5,0,25)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_pink :
  skip ${1=11},${2=0},${3=0},${4=5},${5=0} v -
  if   {$1==0}  apply_channels "b $3 pink heightminima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4}",$5,0
  elif {$1==1}  apply_channels "b $3 pink heightmaxima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4},i",$5,0
  elif {$1==2}  apply_channels "b $3 pink minima,{($2+1)*4}",$5,0
  elif {$1==3}  apply_channels "b $3 pink maxima,{($2+1)*4}",$5,0
  elif {$1==4}  apply_channels "b $3 pink heightminima,{($2+1)*4},$4",$5,0
  elif {$1==5}  apply_channels "b $3 pink heightmaxima,{($2+1)*4},$4",$5,0
  elif {$1==6}  apply_channels "b $3 pink grayskel,null,4,$4",$5,0
  elif {$1==7}  apply_channels "b $3 pink htkern,null,{($2+1)*4}",$5,0
  elif {$1==8}  apply_channels "b $3 pink htkernu,null,{($2+1)*4}",$5,0
  elif {$1==9}  apply_channels "b $3 pink lvkern,null,{($2+1)*4}",$5,0
  elif {$1==10} apply_channels "b $3 pink lvkernu,null,{($2+1)*4}",$5,0
  elif {$1==11} apply_channels "b $3 pink asf,$4",$5,0
  elif {$1==12}
     if {$2==0} apply_channels "b $3 [0]x2 a z pink asflin,x,$4 s z k.",$5,0
           else apply_channels "b $3 [0]x2 a z pink asflin,y,$4 s z k.",$5,0 fi
  elif {$1==13} apply_channels "b $3 pink asfr,$4",$5,0
  elif {$1==14} apply_channels "b $3 pink asft,null,null,{($2+1)*4},$4",$5,0
  elif {$1==15} apply_channels "b $3 pink asftmed,{($2+1)*4},$4",$5,0
  elif {$1==16} apply_channels "b $3 pink asftndg,null,null,{($2+1)*4},$4",$5,0
  elif {$1==17} apply_channels "b $3 pink dilatballnum,$4",$5,0
  elif {$1==18} apply_channels "b $3 pink erosballnum,$4",$5,0
  elif {$1==19} apply_channels "b $3 pink lintophat,$4",$5,0
  else          apply_channels "b $3 pink heightminima,{($2+1)*4},$4 pink wshedtopo,{($2+1)*4}",$5,0
  fi v +

fx_pink_preview :
  gui_split_preview "-fx_pink ${1-5}",${-3--1}

#@gui Pink operator binary: fx_karo_pink_bin, fx_karo_pink_bin_preview(1)
#@gui : Auto-threshold = bool(1)
#@gui : Threshold \% = int(50,0,100)
#@gui : Pink operator = choice(3,"skelpar","skelend","skelcurv","skeleton","barycentre","border","closeball","openball","convexhull","dist","distc","label pla","Lantuejoul")
#@gui : Connectivity / Dir = choice("Four/x","Eight/y")
#@gui : Height/Rep = int(5,-1,25)
#@gui : Algorithm = int(4,0,29)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Green chrominance","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Binary operations with Pink externals.)
#@gui : note = note{"Diverse Pink executables in search PATH"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2014/02/05</i>.</small>")
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_karo_pink_bin :
  skip ${1=1},${2=50},${3=3},${4=0},${5=5},${6=4},${7=0} v -
  if   {$3==0}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skelpar $6,$5 n 0,255",$7,0
  elif {$3==1}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skelend {($4+1)*4},$5 n 0,255",$7,0
  elif {$3==2}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skelcurv $6,{($4+1)*4} n 0,255",$7,0
  elif {$3==3}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink_skeleton $6,{($4+1)*4} n 0,255",$7,0
  elif {$3==4}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink barycentre,{($4+1)*4} n 0,255",$7,0
  elif {$3==5}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink border,{($4+1)*4} n 0,255",$7,0
  elif {$3==6}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink closeball,$5,$6 n 0,255",$7,0
  elif {$3==7}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink openball,$5,$6 n 0,255",$7,0
  elif {$3==8}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink convexhull,3 n 0,255",$7,0
  elif {$3==9}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink dist,$6 n 0,255",$7,0
  elif {$3==10}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink distc,$6 n 0,255",$7,0
  elif {$3==11}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink label,{($4+1)*4},pla",$7,0
  elif {$3==12}  apply_channels "if $1 otsu 256 else threshold ${2}% fi pink lantuejoul,$6 n 0,255",$7,0
  else
  fi

fx_karo_pink_bin_preview :
  gui_split_preview "-fx_karo_pink_bin ${1-7}",${-3--1}

#@gui Pink test operator bianca: fx_karo_pink_bianca, fx_karo_pink_bianca_preview(0)
#@gui : ASF smooth size = int(5,1,10)
#@gui : Threshold \% = int(60,0,100)
#@gui : Watershed height min = int(5,0,20)
#@gui : Opening radius = int(1,0,10)
#@gui : Invert = bool(0)
#@gui : Use G instead of B = bool(0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview split = point(50,50,0,0,200,200,200,0,10,0)
#@gui : sep = separator(), note = note(Pink test operator Bianca for RGB image; only B used.)
#@gui : note = note{"Pink executables in search PATH or C:\\Pink\\bin\\ for Windows"}
#@gui : sep = separator(), note = note("<small>Author : <i>KaRo</i>.           Latest update : <i>2012/10/26</i>.</small>")
#@gui : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
#@cli fx_karo_pink_bianca : Pink test operator bianca
#@cli : ASF smooth size = int(5,1,10)
#@cli : Threshold \% = int(60,0,100)
#@cli : Watershed height min = int(5,0,20)
#@cli : Opening radius = int(1,0,10)
#@cli : Invert = bool(0)
#@cli : Use G instead of B = bool(0)
#@cli : Pink test operator Bianca for RGB image; only B used.
#@cli : Pink executables in search PATH or C:\\Pink\\bin\\ for Windows
#@cli : Author : <i>KaRo</i>.           Latest update : <i>2012/11/18</i>
#@cli : note = link("https://perso.esiee.fr/~coupriem/Pink/doc/html/files.html")
fx_karo_pink_bianca :
  skip "${1=5}","${2=60}","${3=5}","${4=1}","${5=0}","${6=0}"
  if $5 negate fi
  if {!${-is_windows}} exe="label" else exe="C:\Pink\bin\label" fi
  s c if $6 k.. else k. fi
  +pink asf,$1 +- k[-1,-3] threshold. ${2}%
  +pink_wshed.. ,1,$3
  pink. $exe,4,max threshold. 1
  erode_oct.. {$4*2+1} dilate_oct.. {$4*2+1}
  +*[-1,-2] negate.. n[-1,-2] 0,255 a[-1,-2,-4] c k[0]

fx_karo_pink_bianca_preview :
  gui_split_preview "-fx_karo_pink_bianca ${1-6}",${-3--1}

#@gui _

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
