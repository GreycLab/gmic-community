#@gmic
#
#  File        : reptorian.gmic
#                ( G'MIC commands file )
#
#  Description : The author of these filter generally recreate
#  filters that exists in one or few softwares to break through
#  the software barrier.
#
#  No reverse engineering has been applied without permission.
#
#  Copyright   : Reptorian
#                ( https://discuss.pixls.us/u/reptorian/summary )
#
#  License     : CeCILL v2.0
#                ( http://cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#-------------------------------
#
#@cli :: Reptorian's CLI Commands
#
#-------------------------------

#@cli rep_txt2uints: string
#@cli : Return the numerical decoding representation of unicode from txt.
#@cli : _CODEPAGE variable should define your encoding approach. Otherwise, fallback on auto-finding encoding method.
#@cli : Author: Reptorian.
rep_txt2uints:
if narg($_CODEPAGE)
	if isint($_CODEPAGE,0,6)
		id=$_CODEPAGE
	elif isvarname($_CODEPAGE)||isint($_CODEPAGE)
		i65001,iutf8,iutf_8=1
		iibm437,i437=2
		iibm850,i850=3
		iibm858,i858=4
		iwin1252,i1252=5
		i28605,i8859_15=6
		if narg(${i$_CODEPAGE})
			id=${i$_CODEPAGE}
		else
			id=0
		fi
	else
		if same('$_CODEPAGE','utf-8') id=1
		else id=0
		fi
	fi
else # Fallback
	if same('$_host','cli')
		if same('$_os','windows')
			# 65001 = UTF-8
			# 28605 = ISO-8859-15
			#   858 = IBM 858
			#   850 = IBM 850
			#   437 = IBM 437
			#  1252 = Windows-1252
			exec 1,"powershell -Command \"exit [int]((chcp) -replace '\\D+(\\d+).*','"$"1')\""
			id={p=find([65001,437,850,858,1252,28605],${},0,1)+1}
		else
			exec 1,"bash -c 'enc=\$(locale charmap); declare -A m=([UTF-8]=1 [IBM437]=2 [IBM850]=3 [IBM858]=4 [WINDOWS-1252]=5 [ISO-8859-15]=6); exit \${m[\$enc]:0}'"
			id={${}>0xff?${}>>8:${}}
		fi
	else
		exec 1,"python -c \"import locale,sys;enc=locale.getpreferredencoding(False).upper();m={'UTF-8':1,'IBM437':2,'IBM850':3,'IBM858':4,'WINDOWS-1252':5,'ISO-8859-15':6};sys.exit(m.get(enc,0))\""
		id=${}
	fi
fi

_CODEPAGE=$id

if $id==1 # UTF-8
	utf8str2vint $1
	return
elif !$id
	u {'$1'}
	return
fi

id-=2
b64_codepage_map2unicode 1 crop. $id,$id
u {map('$1',crop(#-1))} rm.
#@cli rep_xp2b: base_pow2_a,base_pow2_b,str_a,str_b
#@cli : Convert between bases of power of 2 bases. Only binary, quaternary, octal, hexadecimal, and triacontadecimal number is supported.
#@cli : base_pow2_? can be number representing the base, or string.
#@cli : - Accepted arguments for base_pow2_? -
#@cli : - base - small_id - big_id
#@cli : - 2  - bin - binary
#@cli : - 4  - qua - quaternary
#@cli : - 8  - oct - octal
#@cli : - 16 - hex - hexadecimal
#@cli : - 32 - tca - triacontadecimal
#@cli : str_? are the number represented by base_pow2_a
rep_xp2b:
a,b,I,T,n0:=isnum($1),isnum($2),$!,$#-2,'0' # I = Number of Images ; T = Number of input strings to convert
check ($a?isin($1,2,4,8,16,32):1)&&($b?isin($2,2,4,8,16,32):1)&&isint($#,3)

base_bin,base_binary=2
base_qua,base_quaternary=4
base_oct,base_octal=8
base_hex,base_hexadecimal=16
base_tca,base_triacontadecimal=32

if $a
	base_a=$1
else
	base_a=${base_$1}
fi

if $b
	base_b=$2
else
	base_b=${base_$2}
fi

m "__$0_vars: $""=str"
__$0_vars ${3--1}
um __$0_vars

b2,b4,b8,b16,b32=1,2,3,4,5

if $base_a==$base_b
	if $base_a<$base_hex
		max_val:=_'0'+$base_a-1
		repeat $T {
			('${str{$>+1}}')
			if isint([im,iM],_'0',$max_val)!=[1,1] error non_val_char fi
			rm.
		}
	else
		max_lower,max_higher={[_'a',_'A']-2+$base_a}
		repeat $T {
			('${str{$>+1}}')
			f. isint(i,_'0',_'9')||isint(i,_'a',$max_lower)||isint(i,_'A',$max_higher)
			if !im error non_val_char fi
			rm.
		}
	fi
	u ${3--1}
	return
fi

is_base_b_bin={$base_b==$base_bin}
if $base_a>2
	is_base_a_hex={$base_a==$base_hex}

	step=${b$base_a}
	+rep_cartesian_product {vector(#$step,2)} => binaries
	if $is_base_b_bin +. $n0 fi

	repeat $T {
		('${str{$>+1}}')
		z. {repeat(w#-1,p,if(i[#-1,p]!=_'0',break();););p;},100%
		{w*$step}
		eval[-2] "begin(
				p=started=0;
				const _shift_lower=_'a'-10;
				const _shift_higher=_'A'-10;
			);
			started?(
				p+=$step;
			):(
				p=x*$step;
				started=1;
			);
			ind=isint(i,_'0',_'9')?(
					i-_'0';
				):
				isint(i,_'A',_'V')?(
					i-_shift_higher;
				):
				isint(i,_'a',_'v')?(
					i-_shift_lower;
				):(
					-1;
				);
			if(!isint(ind,0,w#$binaries-1),
				run('error inval_char');
			);
			copy(i[#-1,p],I[#$binaries,ind]);
			"
		if $is_base_b_bin
			z. {repeat(w-1,p,if(i[#-1,p]!=_'0',break();););p;},100%
			res.=$sep{t}
			sep=,
			rm[-2,-1]
		else
			rm[-2]
		fi
	}

	rm[binaries]

	if $is_base_b_bin
		u $res
		return
	fi
else
	repeat $T {
		('${str{$>+1}}')
		check isint([im,iM],_'0',_'1')==[1,1]
		z. {repeat(w#-1-1,p,if(i[#-1,p]!=_'0',break();););p;},100%
		-. $n0
	}
fi

chunks_size=${b$base_b}
foreach[$I--1] {
	{ceil(w/$chunks_size)},1,1,1,"begin(
			const off=-(w#-1-w*$chunks_size);
			const _0=_'0';
			const _offset=(_'a')-10;
			const _shift_lower=_'a'-10;
			shift_factor=reverse(expr('x',$chunks_size));
			p=started=0;
		);
		started?(
			p+=$chunks_size;
		):(
			p=x*$chunks_size-off;
		);
		v=sum(crop(#-1,p,$chunks_size)<<shift_factor);
		v<10?v+_0:v+_offset;
		"
	z. {repeat(w#-1-1,p,if(i[#-1,p]!=_'0',break();););p;},100%
	res.=$sep{t}
	sep=,
	rm
}

u $res
#@cli rep_pattern_str: 0<max_number_of_digits<=16,_use_padding={ 0=False | 1=True },_use_hex_ind={ 0=False | 1=True }
#@cli : Creates a string utilized for pattern.
#@cli : Default values: '_use_padding=0','_use_hex_ind=1'
rep_pattern_str:
skip ${2=0},${3=1}
check isint($1,1,16)&&isbool($2)&&isbool($3)
P={16-$1}
u {`$3?'0x'`}{`$2&&$1<16?vector(#$P,_'0')`}{`"
	chars='0123456789ABCDEF';
	str=vector(#$1);
	fill(str,(chars)[v(0,15)];);
	is_zero=1;
	repeat(size(str),p,
		if(str[p]!=_'0',
			is_zero=0;
			break();
		);
	);
	if(is_zero,
		str[size(str)-1]=(chars)[v(1,15)]
	);
	str;
"`}
#@cli rep_cs_arg: direction={ 0=backward | 1=forward | 2=bidirectional},cs_arg_num,cs_arg_0,cs_arg_1
#@cli : Generates strings for color space conversion.
rep_cs_arg:
skip "$*"
check isint($1,0,2)&&isint($2,0,$#-3)
if $1==2 S=, fi

$=a
selected_cs=${a{$2+3}}

if !($1&1)
	aL=${selected_cs}2rgb
fi

if $1
	aR=rgb2$selected_cs
fi

u $aL$S$aR
#@cli rep_zip: axis={ x=horizontal | y=vertical | z=depth },output_sections={ 0=false | 1=sections | 2=split_sections }
#@cli : Zips images. All images must have same spectrum size!
#@cli : $ (0,5,9,13,15,16) (1,6,10) (2,7,11) (3,8,12,14) (4) rep_zip x
#@cli : $ (0,3,6) (1,4,7) (2,5,8) rep_zip x
#@cli : $ (0,6,12,17) (1,7,13,18,21,23) (2,8,14) (3,9,15,19,22,24) (4,10) (5,11,16,20) rep_zip x
#@cli : $ sp cat,flower rep_zip x resize. 1360,525,1,100%,-1
#@cli : Author: Reptorian.
rep_zip:
skip ${2=0}
check "inrange(('$1')[0],_'x',_'z',1,1)&&isint($2,0,2)"

old_status=${}

arg0 $2,"."," and split by sections."," and split by split_sections."
e[^-1] "Zips image"$?" along $1-axis"${}

remove_empty

if $!<=1
	status $old_status
	return
fi

vol_of_images,info_image:=$!+[0,1]
axis:='$1'
axis_ind={$axis-_'x'}

check isint($!,2)&&!var(expr('s#x',$!))

eval "
	list_of_volumes=expr('whd#x',$!);
	sorted_list_of_volumes=sort(list_of_volumes);

	num_of_unique_volumes=1;

	for(p=1,p<size(list_of_volumes),++p,
		if(sorted_list_of_volumes[p]!=sorted_list_of_volumes[p-1],
			sorted_list_of_volumes[num_of_unique_volumes++]=sorted_list_of_volumes[p];
		);
	);

	set('sortset_volumes',v2s(sorted_list_of_volumes));
	set('num_of_unique_volumes',num_of_unique_volumes);
	set('final_dimensions',sum(list_of_volumes));
	"

sortset_volumes:=[$sortset_volumes][0,$num_of_unique_volumes]
0x$num_of_unique_volumes

eval "
	sorted_list_of_volumes=["$sortset_volumes"];
	list_of_starts=vector(#size(sorted_list_of_volumes)+1);
	const size_l=size(sorted_list_of_volumes);
	if($2,subsplit_size=vector(#size_l););

	repeat($vol_of_images,p,
		v=whd#p;
		repeat(size_l,q,
			if(v<sorted_list_of_volumes[q],break(););
			da_push(#$vol_of_images+q,p);
		);
	);

	rp=v=0;
	repeat($vol_of_images,p,
		list_of_starts[p]=v;
		ref=$vol_of_images+p;
		v+=(sorted_list_of_volumes[p]-rp)*i[#ref,h(#ref)-1];
		rp=sorted_list_of_volumes[p];
	);

	list_of_starts[p]=v;

	repeat(size_l,p,
		q=$vol_of_images+p;
		da_freeze(#q);
		if($2,subsplit_size[p]=h(#q););
	);

	set('list_of_starts',v2s(list_of_starts));
	if($2,
		set('split_positions',v2s(list_of_starts[1,size_l-1]));
		set('subsplit_size',v2s(subsplit_size));
	);
	"

+rep_mt_f32v_map $final_dimension,{$final_dimensions>>15},0

{D=vector(#3,1);D[$axis_ind]=$final_dimensions;[D,s#0]}

eval.. :"
	sortset_volumes=[0,"$sortset_volumes"];
	list_of_starts=["$list_of_starts"];

	const Vi=$vol_of_images;
	const target_volume=whd#-1;
	const start_right=size(list_of_starts)-1;

	O=J(-1);
	P=O[0]<<24|O[1];
	Q=i0<<24|i1;

	left=0;
	right=start_right;
	while(left<=right,
		p_c_start=left+((right-left)>>1);

		list_of_starts[p_c_start]<=P?(
			left=p_c_start + 1;
		):(
			right=p_c_start - 1;
		);
	);

	p_c_start=right;
	ref_img_ind=Vi+p_c_start;

	while(P<Q,
		S=list_of_starts[p_c_start];
		T=min(Q,list_of_starts[p_c_start+1]-1);

		H=h(#ref_img_ind);

		RP=P-S;
		relative_windows_idx=int([RP,T-S]/H);
		idx_W_diff=relative_windows_idx[1]-relative_windows_idx[0];
		offset_p=idx_W_diff*H;

		if(P+offset_p>T,
			--idx_W_diff;
			offset_p-=H;
		);

		img_ind=RP%H;
		reference_pos=sortset_volumes[p_c_start]+relative_windows_idx[0];

		p=P;
		q=0;
		total_copy_count=0;

		do(
			t_p=p+q;
			t_q=reference_pos;

			copy_count=idx_W_diff+((t_p+offset_p)<=T);

			selected_img=i[#ref_img_ind,img_ind];
			selected_volume=whd(#selected_img);

			repeat(s#0,
				copy(i[#-1,t_p],i[#selected_img,t_q],copy_count,H,1);
				t_p+=target_volume;
				t_q+=selected_volume;
			);

			if(++img_ind==H,
				++reference_pos;
				img_ind=0;
			);

			total_copy_count+=copy_count;
			++q;
		,p+total_copy_count<=T);

		P+=total_copy_count;

		if(P==list_of_starts[p_c_start+1],
			++p_c_start;
			++ref_img_ind;
		);
	);
	I;
	"

k.

if $2
	rep_multisplit $1,$split_positions
	name[0--1] $subsplit_size
	if $2==2 rep_multisplit -$1,$subsplit_size fi
fi

status $old_status
#@cli rep_multisplit: 'axis','split_point_a','split_point_b',....
#@cli : Split at nth points.
#@cli : Note: if 'axis' has 2 chars, then it will split different images with equal sized blocks.
rep_multisplit:
check "a='$1';S=size(a);
       set('S',S);
       b=a[S-1];
       set('axis_arg',b-_'x');
       isint(S,1,2)&&
       inrange(b,_'x',_'z',1,1)&&
       (sum(isint([${2--1}],1))==($#-1));"

old_status=${}

arg1 $S," at pixel indexes "," into different sized blocks - "
end_msg=${}${2--1}
e[^-1] "Split image"$?$end_msg

m __$0_vars:"$""=vars nargs=$""#"

if $S==2
	__$0_vars ${2--1}
	axis=${arg0\ $axis_arg,x,y,z}
	foreach { split $axis,-${vars{$>+1}} }
else
	eval "
		args=[${2--1}];
		args=sort(args);
		q=1;
		for(p=1,p<size(args),++p,
			if(args[p]!=args[p-1],
				args[q++]=args[p];
			);
		);
		set('count_of_uniques',q);
		args;"

	__$0_vars {[${}][0,$count_of_uniques]}

	mode=${arg0\ $axis_arg,columns,rows,slices}
	dim=${arg0\ $axis_arg,w,h,d}

	foreach {
		repeat $nargs {
			cut_point=${vars{$<+1}}
			l[0] {
				check isint($cut_point,0,$dim#0-1)
				+$mode $cut_point,100%
				$mode.. 0,{$cut_point-1}
			}
		}
	}
fi

um __$0_vars

status $old_status
#@cli rep_arg2freqsortvals: value_1,value_2,....
#@cli : Convert arguments into frequency of sorted values.
rep_arg2freqsortvals:
({'$*'}) _rep_freq_sortvals[-1] u {crop(#-1,0,1,0,0,1,h#-1-1,1,1)} rm.
#@cli rep_img2freqsortvals:
#@cli : Change images to frequency of sorted values.
rep_img2freqsortvals:
use_old_status=0 foreach { _rep_freq_sortvals } u $old_status
_rep_freq_sortvals:
if whd==1 1 rm.. return fi
sort.
0
eval.. >"begin(
		compare_num=i[#-2,0];
		da_push(#-1,0);
		pos=0;
	);

	if(i==compare_num
	,++i[#-1,pos];
	,da_push(#-1,1);++pos;compare_num=i;
	);
	i;

	end(da_freeze(#-1););
	"
rm..
#@cli rep_colormap : nb_levels>=0,_method={ 0:Median-cut | 1:K-means },_sort_vectors
#@cli : Estimate best-fitting colormap with 'nb_colors' entries, to index selected images.
#@cli : Set 'nb_levels==0' to extract all existing colors of an image.
#@cli : 'sort_vectors' can be { 0:Unsorted | 1:By increasing norm | 2:By decreasing occurrence }.
#@cli : Default value: 'method=1' and 'sort_vectors=1'.
rep_colormap:
check isint($1,0)&&isbool(${2=1})&&isint(${3=1},0,2)

m0,m1="median-cut","k-means"
s0,s1,s2="",", sorted by increasing norm",", sorted by decreasing occurrence"

if $1 e[0--3] "Estimate colormap with $1 entries for image$?, by "${m$2}" method"${s$3}"."
else e[0--3] "Estimate full colormap for image$?"${s$3}"."
fi

use_count_occurance={$3==2}
add_mode={$1>0&&$use_count_occurance}

if $add_mode p=+ fi

foreach {
	S={s}
	${p}_rep_colors_freqstat $1,$2,$use_count_occurance

	if $3
		if $use_count_occurance
			if s>$S
				rm..
				s c,-$S
				rv[-2,-1] a y
				sort -,x rows 1
			else
				index.. .,0,0 histogram.. {[w,0,w-1]} a y sort -,x rows 1 # Sort by decreasing occurrence
			fi
		else
			k. +norm rv a c sort +,x channels 1,100% # Sort by increasing norm
		fi
	fi
}
#@cli rep_uniq_cols: preserve_frequency={ 0=false | 1=true }
#@cli : Find all colors, with the option to preserve frequency
rep_uniq_cols:
check isbool($1)&&$#==1 _rep_colors_freqstat -$1
#@cli rep_mode: fill_with_mode_color={ 0=false | 1=true }
#@cli : Fill image with the most common color.
rep_mode:
check isbool($1)&&$#==1 _rep_colors_freqstat {$1-3}
_rep_colors_freqstat:
skip ${2=0},${3=0}
check "isint($1,-3)&&$1<inf"

col_cnt_mode,red_cols_mode:=$1<0||$3,$1>0 # color_count_mode / reduce color mode ;; mode de cuente de color / modo reducir color
original_status=${}

if $1<-1
	highest_color_frequency_mode=1
	mt_cmd=fill
else
	highest_color_frequency_mode=0
	mt_cmd=eval
fi

if $red_cols_mode
	m __$0_red_cols_mode:"
		keep[0]
		+_colormap_median_cut $1

		if $2 # Add k-means step
			max_diff={iM-im+1}/8192

			do
				+index.. . # Find nearest cluster for each color
				if $is_half
					..,1,1,{1,s}

					eval \"
						csum = vector(#w*s#0);
						cocc = vector(#w,0);
						repeat (w#2,k,
							ind = i[#2,k];
							repeat (s#0,c,csum[ind + c*w]+=i(#0,k,0,0,c));
							++cocc[ind];
						);
						off = 0;
						repeat (s#0,c,
							repeat (w,k,occ = cocc[k]; occ?(csum[off++]/=occ));
						);
						draw(#3,csum)\"
				else
					..,1,1,{1,s+1}
					f.. \">I[#3,i]+=[ I[#0,x],1 ]\" rm..
					f. \"s = i(x,0,0,s-1); s?I/s:[ I[#1,x],0]\"
				fi

				+-.. . abs. diff:=iM/w rm. # Compute colormap difference
				j.. . rm.
			while $diff>$max_diff
		fi

		rm.."
fi

foreach {
	# Skip processing images when not needed
	if whd<=1 continue fi

	# Set up important variables
	cpus_to_use,mt_mode,pxs_to_process_per_threads,bitshift_factor,dictionary_buckets_per_threads,bit_mask:="
		cpus_to_use=cut(int(whd#0/0x8000),1,$_cpus);
		mt_mode=cpus_to_use>1;
		pxs_to_process_per_threads=ceil(whd/cpus_to_use);
		bitshift_factor=cut(int(log2(sqrt(pxs_to_process_per_threads)))+1,8,16);
		dictionary_buckets_per_threads=1<<bitshift_factor;
		bit_mask=dictionary_buckets_per_threads-1;
		cpus_to_use,mt_mode,pxs_to_process_per_threads,bitshift_factor,dictionary_buckets_per_threads,bit_mask;
	"

	S={s}
	if $highest_color_frequency_mode
		if $1==-2
			od:=w,h,d
		else
			od={vector(#3,1)}
		fi
	fi

	if $red_cols_mode
		is_half=${-is_half}
		r[0] {whd},1,1,100%,-1
	fi

	# Create Hashmap
	100%,100%,100%,{1+$mt_mode}," # Second channel is used to post merge
		begin(
			const M=(1<<16)-1;
			const bf=$bitshift_factor;
			const bit_mask=$bit_mask;
			const seed="{v(0x1234,0xabcd)}";
			const S=$S;
			S==1?(
				const second_seed=seed<<1;
				const Z=0x45d9f;
				hash(v)=(
					nv=v;
					repeat(2,nv=xor(nv>>16,nv)*Z;);
					xor(nv>>16,nv);
				);
				hash_a(v)=hash(v+seed);
				hash_b(v)=hash(v+second_seed);
			):(
				hash(v)=(C=v;isint(C)?C:C*M);
				hash_a(v)=hash(v);
				hash_b(v)=hash(v);
			);

			s==2?(
				const lc=S-1;
				init()=(hash_value_a=hash_value_b=0);
				hash_color()=repeat(S,p,
					hash_value_a=xor(((hash_value_a<<1)-hash_value_a)*seed,hash_a(c[p]));
					hash_value_b=xor(((hash_value_b<<1)-hash_value_b)*seed,hash_b(c[lc-p]));
					hash_value_a&=bit_mask;
					hash_value_b&=bit_mask;
				);
				result()=[hash_value_a,hash_value_b];
				0;
			):(
				init()=hash_value=0;
				hash_color()=repeat(S,p,
					hash_value=xor(((hash_value<<1)-hash_value)*seed,hash_a(c[p]));
					hash_value&=bit_mask;
				);
				result()=hash_value;
				0;
			);
		);
		c=I#0;
		init();
		hash_color();
		result();"

	# Image to use for processing all the other images on the list
	+rep_mt_f32v_map {whd#-1},$cpus_to_use,0

	# Create dictionary buckets and reference image
	total_num_of_buckets_per_section={($cpus_to_use*$dictionary_buckets_per_threads)}
	0x$total_num_of_buckets_per_section
	$dictionary_buckets_per_threads,$cpus_to_use

	if $red_cols_mode
		1,1,1,1,1 rv[-2,-1]
	fi

	# Find Frequency of Colors

	eval[2] :"
		begin(
			const S=s#0;
			const mt_mode=$mt_mode;
			const urcmt=$red_cols_mode;
			const calc_max_freq_num_mode=!mt_mode&&$highest_color_frequency_mode;
			const col_cnt_mode=$col_cnt_mode;
			const vector_insertion_size=S+col_cnt_mode+mt_mode;
			const hash2_pos=S+col_cnt_mode;

			urcmt?(
				cond()=(++P<Q)&&i[#-2,0];
				iter_fin()=if(++i(#-1,key,x)==$1,
					i[#-2,0]=0;
				);
			):(
				cond()=++P<Q;
				iter_fin()=++i(#-1,key,x);
			);

			calc_max_freq_num_mode?(
				maxima_a=maxima_b=0;
				maxima_color=vector(#S,nan);
				str_NaN=v2s(maxima_color);
				chkfreq(count_value)=if((current_count=count_value)>=maxima_a,
					maxima_color=current_color;
					maxima_b=maxima_a;
					maxima_a=current_count;
				);
			):(
				chkfreq(count_value)=count_value;
			);

			P1_off()=P+whd#0;
		);

		list_of_ins_pos=vector(#$dictionary_buckets_per_threads);
		offset=$dictionary_buckets_per_threads*x+k+1;

		O=J(-1);
		P=O[0]<<24|O[1];
		Q=i0<<24|i1;

		last_color=I[#0,P];
		key=i[#1,P];
		door_pos=key+offset;
		resize(#door_pos,vector_insertion_size,8,1,1,-1);
		copy(i[#door_pos,0],last_color);
		list_of_ins_pos[key]=vector_insertion_size;
		i(#-1,key,x)=1;
		if(col_cnt_mode,
			if(calc_max_freq_num_mode,
				maxima_color=last_color;
				maxima_a=1;
			);
			i[#door_pos,count_pos=S]=1;
		);
		if(mt_mode,i[#door_pos,hash2_pos]=i[#1,P1_off()]);

		col_cnt_mode?(
			while(++P<Q,
				current_color=I[#0,P];
				same_color=same(current_color,last_color);
				same_color?(
					chkfreq(++i[#door_pos,count_pos]);
				):(
					key=i[#1,P];
					door_pos=key+offset;
					H=i(#-1,key,x);
					ins_pos=list_of_ins_pos[key];
					(H?(count_pos=find(#door_pos,current_color,ins_pos-vector_insertion_size,-vector_insertion_size))!=-1)?(
						count_pos+=S;
						chkfreq(++i[#door_pos,count_pos]);
					):(
						ch=h(#door_pos);
						if(H==ch,
							new_size=max(8,ch<<1);
							resize(#door_pos,vector_insertion_size,new_size,1,1,-1);
						);
						copy(i[#door_pos,ins_pos],current_color);
						count_pos=ins_pos+S;
						chkfreq(i[#door_pos,count_pos]=1);
						if(mt_mode,i[#door_pos,ins_pos+hash2_pos]=i[#1,P1_off()];);
						list_of_ins_pos[key]+=vector_insertion_size;
						++i(#-1,key,x);
					);
				);
				last_color=current_color;
			);
		):(
			while(cond(),
				current_color=I[#0,P];
				if(!same(current_color,last_color),
					key=i[#1,P];
					door_pos=key+offset;
					H=i(#-1,key,x);
					ins_pos=list_of_ins_pos[key];
					!H||find(#door_pos,current_color,ins_pos-vector_insertion_size,-vector_insertion_size)==-1?(
						ch=h(#door_pos);
						if(H==ch,
							new_size=max(8,ch<<1);
							resize(#door_pos,vector_insertion_size,new_size,1,1,-1);
						);
						copy(i[#door_pos,ins_pos],current_color);
						if(mt_mode,i[#door_pos,ins_pos+hash2_pos]=i[#1,P1_off()]);
						list_of_ins_pos[key]+=vector_insertion_size;
						iter_fin();
					);
				);
				last_color=current_color;
			);
		);

		I;
		end(
			if(calc_max_freq_num_mode,
				if(maxima_a>maxima_b
				,set('{}',v2s(maxima_color));
				,set('{}',str_NaN);
				);
			);
		);"

	if $red_cols_mode
		if i[#-2,0]?sum(expr('max(crop(#-1,x,0,0,0,h#-1,1,1,1))',w#-1))>$1:1
			__$0_red_cols_mode
			continue
		fi
	fi

	if $mt_mode
		if $red_cols_mode
			rm[1]
		else
			rm[0,1]
		fi

		L={max(1,min(int(is#-1/0x8000),$_cpus,$dictionary_buckets_per_threads))}

		r[$red_cols_mode] $L,100%,100%,{$highest_color_frequency_mode?$S+2:1},-1

		T=$!
		0x{$L*$dictionary_buckets_per_threads}

		$mt_cmd[$red_cols_mode] :"
			begin(
				const S=$S;
				const d_S=S-1;
				const cpus=$_cpus;
				const urcmt=$red_cols_mode;
				const calc_max_freq_num_mode=$highest_color_frequency_mode;
				const col_cnt_mode=$col_cnt_mode;
				const hash2_pos=S+col_cnt_mode;
				const D=$dictionary_buckets_per_threads;
				const T=$T;
				const img_ref=T-1;
				const offset_bucket_size=w#img_ref;
				const levels=h#img_ref;
				const current_bucket_vector_size=hash2_pos+1;
				const offset_2_bucket_start=k+1;

				urcmt?(
					urcmt_state=T-2;
					cond()=current_bucket<=D&&i[#urcmt_state,0];
					count_of_color=0;
				):(
					cond()=current_bucket<=D;
				);

				init_current_color=vector(#S);
				init_number_of_keys=vector(#D);

				if(calc_max_freq_num_mode,
					maxima_a=maxima_b=0;
					maxima_color=vector(#S,nan);
					str_NaN=v2s(maxima_color);
					chkfreq(count_value)=if((current_count=count_value)>=maxima_a,
						maxima_color=current_color;
						maxima_b=maxima_a;
						maxima_a=current_count;
					);
				);
			);
			img_ind_of_start_of_secondary_dictionary=D*x+T;
			for(current_bucket=x+offset_2_bucket_start,current_bucket<=D,current_bucket+=w,
				bucket_id=current_bucket-1;
				current_bucket_ins_pos=current_level=0;

				secondary_insert_positions_list=init_number_of_keys;

				current_color=init_current_color;

				count_per_current_level=i(#img_ref,bucket_id,current_level);

				current_bucket_pos=0;
				repeat(count_per_current_level,current_bucket_pos,
					copy(current_color,i[#current_bucket,current_bucket_ins_pos],S);

					secondary_hash_pos=current_bucket_ins_pos+hash2_pos;
					second_dictionary_key=i[#current_bucket,secondary_hash_pos];
					secondary_dictionary_ind=second_dictionary_key+img_ind_of_start_of_secondary_dictionary;

					current_secondary_ins_pos=secondary_insert_positions_list[second_dictionary_key];

					secondary_dictionary_dimension=wh(#secondary_dictionary_ind);
					if(current_secondary_ins_pos>=secondary_dictionary_dimension,
						new_size=max(8,h(#secondary_dictionary_ind)<<1);
						resize(#secondary_dictionary_ind,hash2_pos,new_size,1,1,-1);
					);

					copy(i[#secondary_dictionary_ind,current_secondary_ins_pos],current_color,S);

					if(col_cnt_mode,
						color_count_pos=current_bucket_ins_pos+S;
						if(calc_max_freq_num_mode,chkfreq(i[#current_bucket,color_count_pos]));
						i[#secondary_dictionary_ind,current_secondary_ins_pos+S]=color_count_pos;
					);

					secondary_insert_positions_list[second_dictionary_key]+=hash2_pos;
					current_bucket_ins_pos+=current_bucket_vector_size;
				);

				offset_bucket=current_bucket+offset_bucket_size;
				while(++current_level<levels,
					count_per_current_level=i(#img_ref,bucket_id,current_level);
					current_offset_bucket_pos=0;

					repeat(count_per_current_level,
						copy(current_color,i[#offset_bucket,current_offset_bucket_pos],S);
						if(col_cnt_mode,
							current_count_in_offset_bucket=i[#offset_bucket,current_offset_bucket_pos+S];
						);

						offset_hash_pos=current_offset_bucket_pos+hash2_pos;
						second_dictionary_key=i[#offset_bucket,offset_hash_pos];
						secondary_dictionary_ind=second_dictionary_key+img_ind_of_start_of_secondary_dictionary;

						current_secondary_ins_pos=secondary_insert_positions_list[second_dictionary_key];
						color_pos=find(#secondary_dictionary_ind,current_color,current_secondary_ins_pos-hash2_pos,-hash2_pos);

						col_cnt_mode?(
							color_pos!=-1?(
								calc_max_freq_num_mode?(
									chkfreq(i[#current_bucket,i[#secondary_dictionary_ind,color_pos+S]]+=current_count_in_offset_bucket;);
								):(
									i[#current_bucket,i[#secondary_dictionary_ind,color_pos+S]]+=current_count_in_offset_bucket;
								);
							):(
								if(calc_max_freq_num_mode,chkfreq(current_count_in_offset_bucket););
								secondary_dictionary_dimension=wh(#secondary_dictionary_ind);
								if(current_secondary_ins_pos>=secondary_dictionary_dimension,
									new_size=max(8,h(#secondary_dictionary_ind)<<1);
									resize(#secondary_dictionary_ind,hash2_pos,new_size,1,1,-1);
								);
								copy(i[#secondary_dictionary_ind,current_secondary_ins_pos],current_color,S);
								i[#secondary_dictionary_ind,current_secondary_ins_pos+S]=current_bucket_ins_pos+S;
								secondary_insert_positions_list[second_dictionary_key]+=hash2_pos;
								current_bucket_dimension=wh(#current_bucket);
								if(current_bucket_ins_pos>=current_bucket_dimension,
									new_size=max(8,h(#current_bucket)<<1);
									resize(#current_bucket,current_bucket_vector_size,new_size,1,1,-1);
								);
								copy(i[#current_bucket,current_bucket_ins_pos],current_color,S);
								i[#current_bucket,current_bucket_ins_pos+S]=current_count_in_offset_bucket;
								current_bucket_ins_pos+=current_bucket_vector_size;
								++current_bucket_pos;
							);
						):(
							color_pos==-1?(
								secondary_dictionary_dimension=wh(#secondary_dictionary_ind);
								if(current_secondary_ins_pos>=secondary_dictionary_dimension,
									new_size=max(8,h(#secondary_dictionary_ind)<<1);
									resize(#secondary_dictionary_ind,hash2_pos,new_size,1,1,-1);
								);
								copy(i[#secondary_dictionary_ind,current_secondary_ins_pos],current_color,S);
								secondary_insert_positions_list[second_dictionary_key]+=hash2_pos;
								current_bucket_dimension=wh(#current_bucket);
								if(current_bucket_ins_pos>=current_bucket_dimension,
									new_size=max(8,h(#current_bucket)<<1);
									resize(#current_bucket,current_bucket_vector_size,new_size,1,1,-1);
								);
								copy(i[#current_bucket,current_bucket_ins_pos],current_color,S);
								current_bucket_ins_pos+=current_bucket_vector_size;
								++current_bucket_pos;
							);
						);

						current_offset_bucket_pos+=current_bucket_vector_size;
					);

					offset_bucket+=offset_bucket_size;
				);

				if(current_bucket_pos,
					resize(#current_bucket,hash2_pos,current_bucket_pos,1,1,0);
				);

				if(urcmt,
					count_of_color+=current_bucket_pos;
					if(count_of_color>$1,
						i[#urcmt_state,0]=0;
					);
				);
			);
			calc_max_freq_num_mode?([maxima_color,maxima_a,maxima_b]):(I);
			end(
				if(urcmt&&i[#urcmt_state,0],
					merge(count_of_color,+);
					if(count_of_color>$1,
						i[#urcmt_state,0]=0;
					);
				);
			);
			"

		if $red_cols_mode
			if !i[#{$T-2},0]
				__$0_red_cols_mode
				continue
			fi
		fi

		if $highest_color_frequency_mode
			k[$red_cols_mode]
			$od,$S,[{"const s=$S;
				aM=argmax(crop(#0,0,0,0,s,w#0,1,1,1));
				am=argmax(crop(#0,0,0,0,s+1,w#0,1,1,1));
				vM=i(#0,aM,0,0,s);
				vm=i(#0,am,0,0,s+1);
				vM>vm?I[#0,aM][0,s]:vector(#s,nan);
			"}]
			k[1]
		else
			k[1-$dictionary_buckets_per_threads] a y permute yzcx
		fi
	else
		if $highest_color_frequency_mode
			if $1==-2
				k[0]
				f [${}]
			else
				rm
				1,1,1,$S,[${}]
			fi
		else
			if $red_cols_mode rm.. fi
			k[3--1]
			eval. if(i,resize(#x,{$S+$col_cnt_mode},i,1,1,-1));
			rm.
			a y
			permute yzcx
		fi
	fi
}

status $original_status
_colormap_median_cut: # Implementation of the median-cut algorithm done by David TschumperlÃ©.
  m _$0": repeat s { sh[$""1] $> =.. {iM-im},$""1,0,0,$> rm. }"
  1,1,1,{s} _$0 0 # Initialize image of box ranges
  repeat $1-1 {
    b,a:=xM,cM # b = box with highest range, a = axis with highest range
    l[$b] { shift 0,0,0,-$a,2 sort +,x shift 0,0,0,$a,2 xm:=int(w/2) }
    if {$b,w>1} +z[$b] $xm,100% z[$b] 0,{$xm-1} else 1,1,1,{$b,s} fi
    rv[-2,-1] r. {w+1},1,1,100%,0
    _$0 $b _$0 {$!-2} # Update box ranges
  }
  rm. r 1,1,1,100%,2 a x # Average value in each box and append as final colormap
  um _$0
#@cli rep_mode_blend
#@cli : Blend Layers via statistical mode of colors.
#@cli :
#@cli : Author: Reptorian
rep_mode_blend:

is_dimensions_valid={"
		v=[w#0,h#0,d#0,s#0];
		dimension_valid=1;
		!same(v[0,3],[0,0,0])?(
			for(p=1,p<$!,++p,
				nv=[w#p,h#p,d#p,s#p];
				if(same(v[0,3],[0,0,0]),
					dimension_valid=0;
					break();
				);
				if(!same(nv,v),
					dimension_valid=0;
					break();
				);
			);
		):(
			p=dimension_valid=0;
		);
		set('img_checked',p);
		dimension_valid;
	"}

if !$is_dimensions_valid
	error inv_dim_det@[$img_checked]
elif $!<3
	if $!==2
		100%,100%,100%,100%,I#-2==I#-1?I#-1:vector(#s,nan)
		rm[-3,-2]
	fi
	return
fi

use_hashmap_processing={$!>21}

if $use_hashmap_processing
	bf,layers,d_s:=8,$!,s-1
	dictionary_buckets,seed,bit_mask:=$_cpus<<$bf,v(0x1b3d,0xf1c3ef),(1<<$bf)-1

	100%,100%,100%,$!,:"begin(
			const M=(1<<16)-1;
			const S=s#0;
			const seed=$seed;
			const bit_mask=$bit_mask;
			V=vector(#S);
		);
		copy(V[0],i(#c,x,y,z,0),S,1,whd);
		hash_value=0;
		repeat(S,p,
			hash_value=xor(((hash_value<<1)-hash_value)*seed,C=V[p];isint(C)?C:C*M);
			hash_value&=bit_mask;
		);
		hash_value;
		"

	0x$dictionary_buckets

	f[$layers] :"begin_t(
			const S=s#0;
			const inc_S=S+1;
			const dec_S=S-1;
			const count_boundary=s>>1;
			offset=(t<<$bf)+k+1;
			const dictionary_buckets=$dictionary_buckets;
			current_color=v_NaN=last_color=maxima_color=vector(#S,nan);
			chval(count_value)=(
				current_count=count_value;
				if(current_count>=current_maxima,
					maxima_color=current_color;
					if(current_count>count_boundary,break(););
					old_maxima=current_maxima;
					current_maxima=current_count;
				);
			);
			last_ind=nan;
		);
		hash=I;
		sizes=vector(#dictionary_buckets);
		current_maxima=old_maxima=0;
		repeat(s,p,
			copy(current_color[0],i(#p,x,y,z,0),S,1,whd);
			current_hash=hash[p];
			H=sizes[current_hash];
			key=current_hash+offset;
			same_color=same(current_color,last_color);
			(H?(same_color?1:(last_ind=find(#key,current_color,(H-1)*inc_S,-inc_S)+1)))?(
				if(!same_color,last_ind+=dec_S);
				chval(++i[#key,last_ind]);
			):(
				if(H==h(#key),
					new_size=min(max(8,h(#key)<<1),s);
					resize(#key,inc_S,new_size,1,1,-1);
				);
				copy(i(#key,0,H,0,0),[current_color,1]);
				++sizes[current_hash];
				last_ind=(H+1)*inc_S-1;
			);
			last_color=current_color;
		);
		copy(i(#0,x,y,z,0),current_maxima>old_maxima?maxima_color:v_NaN,S,whd,1);
		I;"
else
	f[0] "begin(
			const layers="$!";
			const count_boundary=layers>>1;

			init_color_collection=vector(#s*layers);
			init_new_counts=vector(#layers);
			init_new_counts[0]=1;

			current_color=vector(#s);
			v_NaN=vector(#s,nan);
		);
		last_color=I;
		last_nonduplicate_pos=s;
		current_maxima=old_maxima=1;
		maxima_color=v_NaN;

		colors=init_color_collection;
		copy(colors[0],last_color);
		counts=init_new_counts;

		p=0;
		q=[0,0];
		while(++p<layers,
			copy(current_color[0],i(#p,x,y,z,0),s,1,whd);

			same(current_color,last_color)?(
				found_duplicate=1;
			):(
				found_duplicate=0;
				q=[0,0];
				while(q[0]<last_nonduplicate_pos,
					if(same(current_color,colors[q[0],s]),
						found_duplicate=1;
						break();
					);
					q+=[s,1];
				);
				0;
			);

			last_color=current_color;
			current_count=++counts[q[1]];

			if(current_count>count_boundary,
				current_maxima=current_count;
				maxima_color=current_color;
				break();
			);

			found_duplicate?(
				if(current_count>=current_maxima,
					maxima_color=current_color;
					old_maxima=current_maxima;
					current_maxima=current_count;
				);
			):(
				copy(colors[last_nonduplicate_pos],current_color);
				last_nonduplicate_pos+=s;
			);
		);

		current_maxima>old_maxima?maxima_color:v_NaN;"
fi

k[0]
#@cli rep_val2order: map_2_img={ 0=False | 1=True },value_mode={ 0=scalar | 1=vector },_keep_set_vals={ 0=no | 1=values | 2=values+count | 3=values+status_counts | 4=status_counts }
#@cli : This command can change images to order of appearance representation(s). map_2_img simply convert values to the order of their appearance starting from zero. set_vals can contain unique values with optional count of unique values.
rep_val2order:
check "$! && isint($#,2,3) && sum(isbool([${1-2}])) && $#==3?isint($-1,0,4):1"

if $#==3
	map_2_img,use_vector_values,set_val_mode=$*
else
	map_2_img,use_vector_values=$*
	set_val_mode={!$map_2_img}
fi

check "$map_2_img || $set_val_mode"

use_count,use_values,use_status,mode_4:=$set_val_mode>1,isint($set_val_mode,1,3),$set_val_mode>=3,$set_val_mode==4

if $use_status
	status_out,end=
else
	original_status=${}
fi

if $mode_4
	map_2_img=0
fi

remove_primary_image={!$map_2_img&&!$mode_4}
bitshift_factor=10
dictionary_size,end_hash_image_index,max_index={(1<<$bitshift_factor)+[0,1,-1]}

foreach {
	# Random Seed per iterations!
	seed={v(0xffff,0xffffff)}

	# Compute Hash Map
	100%,100%,100%,{$use_vector_values?1:s#-1},"
		begin(
			const M=(1<<16)-1;
			const seed=$seed;
			const bit_mask=$max_index;
			const multiplier=31*$seed;

			$use_vector_values?(
				hash_value(n)=(
					hash_value=0;
					repeat(s#-1,p,
						hash_value=xor(((hash_value<<1)-hash_value)*seed,C=n[p];isint(C)?C:C*M);
						hash_value&=bit_mask;
					);
					hash_value+2;
				);
				process()=hash_value(I#-1);
			):(
				const bitshift_factor=$bitshift_factor;
				n_start(n)=n>bit_mask?xor(n<<1,seed):n&bit_mask;
				hash_value(n)=(
					N=n_start(n);
					hash_value=0;
					while(N,
						hash_value=(hash_value*multiplier+N)&bit_mask;
						N>>=bitshift_factor;
					);
					hash_value+2;
				);
				process()=hash_value(i#-1);
			);
	    );
	    process();
	    "
	# Create Hash Table
	0x$dictionary_size

	# Optional image to store uniques values or counts of uniques values or both
	if $set_val_mode
		0
	fi

	f[0] >"
		begin(
			const map_2_img=$map_2_img;
			const uvv=$use_vector_values;
			const dict_size=$dictionary_size;

			sizes=vector(#dict_size,0);

			map_2_img?(
				uvv?(
					result_value()=[v];
				):(
					result_value()=v;
				);
			):(
				uvv?(
					result_value()=I;
				):(
					result_value()=i;
				);
			);

			uvv?(
				const step_size=s+1;
				const post_step=s-1;
				return_value()=I;
				last_value=vector(#s,nan);
				0;
			):(
				const step_size=2;
				const post_step=0;
				return_value()=i;
				last_value=vector(#1,nan);
				0;
			);

			const set_val_mode=$set_val_mode;
			set_val_mode?(
				const use_values=$use_values;
				const use_count=$use_count;
				use_values&&use_count?(
					action_1()=da_push(#-1,[return_value(),1]);
					uvv?(
						action_2()=++i(#-1,0,v,0,s);
					):(
						action_2()=++i(#-1,0,v,0,1);
					);
				):
				use_values?(
					action_1()=da_push(#-1,return_value());
					action_2()=0;
				):
				use_count?(
					action_1()=da_push(#-1,1);
					action_2()=++i[#-1,v];
				);
			):(
				action_1()=0;
				action_2()=0;
			);

			uvv?(
				process()=(
					ref_size_ind=key-2;
					size_of_dyn_img=sizes[ref_size_ind];
					(size_of_dyn_img?same(last_value,return_value()))?(
						action_2();
					):
					(size_of_dyn_img?(p=find(#key,return_value(),(size_of_dyn_img-1)*step_size,-step_size)+1))?(
						p+=post_step;
						v=i[#key,p];
						action_2();
					):(
						if(size_of_dyn_img==h(#key),
							new_size=max(8,h(#key)<<1);
							resize(#key,step_size,new_size,1,1,-1);
						);
						copy(i(#key,0,size_of_dyn_img,0,0),[return_value(),v=id++]);
						p=size_of_dyn_img*step_size+post_step+1;
						++sizes[ref_size_ind];
						action_1();
					);
					last_value=return_value();
				);
			):(
				process()=(
					if(da_size(#key),p=find(#key,i,0,2)+1;)?(
						v=i[#key,p];
						action_2();
					):(
						da_push(#key,i,v=id++);
						action_1();
					);
					result_value();
				);
			);

			id=0;p=-1;v=nan;
		);
		key=i#1;
		process();
		result_value();
		end(if($set_val_mode,da_freeze(#-1);););
		"

	rm[1-$end_hash_image_index]

	# Remove if not used
	if $remove_primary_image
		rm[0]
	fi

	# For multiple channel mapping
	if $map_2_img&&$use_vector_values
		channels[0] 0
	fi

	# Status output
	if $use_status
		part_status={crop(#-1,0,0,0,s#-1-1,1,h#-1,1,1)}

		if $set_val_mode==4 rm.
		else channels. 0,{s-2}
		fi

		if $output_status_mode
			status_out.=$end\"$part_status\"
			end=,
		else
			status_out=$part_status
		fi
	fi
}

if $use_status
	status $status_out
else
	status $original_status
fi
#@cli rep_cbsoo: eq. to 'rep_channels_overblur_overline_blur_sharpen'.
rep_cbsoo: rep_channels_blur_sharpen_overblur_overline $*
#@cli rep_channels_overblur_overline_blur_sharpen: method_a={ 0=blur | 1=sharpen | 2=overblur | 3=overline },0%<_effect_factor_a[%]<=100%,_multiplication_factor>0,_blending_mode,0<_blending_opacity[%]<=100%...
#@cli : Apply BSOO filtering over channels within images.
#@cli : 'blending_mode' can be { add | alpha | and | average | burn | darken | difference | divide | dodge | exclusion | freeze | grainextract | grainmerge | hardlight | hardmix | interpolation | lighten | linearburn | linearlight | multiply | normal | negation | or | overlay | pinlight | reflect | screen | shapeaverage | softburn | softdodge | softlight | stamp | subtract | vividlight | xor }.
#@cli : - Note on 3 Channels Color Spaces (RGB, HSV...) input -
#@cli : If you want to perform the same setting on all channel at once, simply use 5 arguments.
#@cli : If you want to perform same setting on all color channel at once, but separate for gray and alpha. Use 5*(contain_gray+contain_color+contain_alpha) arguments.
#@cli : If you want to perform separate setting on different channels. You can use '-' to disable individual channel, or empty space to skip color channels altogether. If you have enabled support for manipulating color channel, yes, you must consider the number of arguments.
#@cli : Special note: You can make this filter operate on CMYK space by writing cmyk as last argument.
#@cli : Author : Reptorian.
#@cli : Default values: '_effect_factor=100%','_multiplication_factor=100%','_blending_mode=21','_blending_opacity=100%','_effect_boundary=1'
#@cli : $ sp lena shape_cupid 512 blur. 10 *. 255 cut. 0,255 a c sp house rep_channels_blur_sharpen_overblur_overline 2,150,1.5,normal,100%,2,100,1,xor,100%,1,50,1,grainextract,100%
#@cli : $ sp lena shape_cupid 512 blur. 10 *. 255 cut. 0,255 a c sp house rep_channels_blur_sharpen_overblur_overline 2,150,1.5,normal,100%
#@cli : $ sp lena shape_cupid 512 blur. 10 *. 255 cut. 0,255 a c sp house rep_channels_blur_sharpen_overblur_overline 3,150,1.5,normal,100%,2,100,1,xor,20%,3,200,2,linearlight,100%,-,1,200,1,normal,100%
rep_channels_blur_sharpen_overblur_overline:
skip "$*"
check "!($#<5)"
$=arg

blur,sharpen,overblur,overline=0,1,2,3

list_of_blending_modes=add,alpha,and,average,burn,darken,difference,divide,dodge,exclusion,freeze,grainextract,grainmerge,hardlight,hardmix,interpolation,lighten,linearburn,linearlight,multiply,normal,negation,or,overlay,pinlight,reflect,screen,shapeaverage,softburn,softdodge,softlight,stamp,subtract,vividlight,xor
num_of_blending_modes={narg($list_of_blending_modes)}
$list_of_blending_modes={expr('x',$num_of_blending_modes)}

m $0_bsoo_edit:"
	pos,use_char={$""1>1?[$""1-1,1]:[$""1+1,0]}

	if $use_char char=+ fi

	$char${arg1\\ $pos,blur,sharpen} $""2

	if $""1>1
		+-[-2,-1] abs[-1]
		*[-1] $""3
		rm[-2]
		+[-2,-1]
	fi
	"

m +$0_bsoo_edit:"
	pos={$""1>1?$""1-1:$""1+1}
	+${arg1\\ $pos,blur,sharpen} $""2

	if $""1>1
		+-[-2,-1] abs[-1]
		*[-1] $""3
		rm[-2]
		+[-1] [-2]
	fi
	"

m $0_process_individual_channel_section:"
	method,effect_factor,multiplication,opacity:=[$""{2-5}]
	use_output=0

	blending_id=$""6
	use_blend_str:=!isnum($blending_id)

	if $effect_factor||$opacity>0
		use_output=1

		if ($use_blend_str?same('$blending_id','normal')||same('$blending_id','alpha'):$blending_id=="$normal"||$blending_id=="$alpha")&&($opacity==1)
			m $0_process_$""1:$0_bsoo_edit\\ $method,$effect_factor,$multiplication\\ cut\\ 0,255
		else
			if !$use_blend_str blending_id=${arg0\\ $blending_id,"$list_of_blending_modes"} fi
			m $0_process_$""1:+$0_bsoo_edit\\ $method,$effect_factor,$multiplication\\ _blend_$blending_id\\ if\\ $opacity<1\\ j..\\ .,0,0,0,0,$opacity\\ rm.\\ else\\ k.\\ fi\\ cut\\ 0,255
		fi
	fi

	status $use_output"

cmyk_mode,max_col_spec_size={m=same('$-1','cmyk');[m,3+(m?1)]}
user_cmyk_mode=$cmyk_mode

if same('$_host','cli')&&!narg($_pasted_from_gui)

	do
		eval "
			const num_of_imgs=$!;
			const cmyk_mode=$cmyk_mode;
			const max_col_spec_size=$max_col_spec_size;
			contain_gray=contain_alpha=0;
			continue_analyzing_color_space=0;
			cmyk_mode?(
				contain_rgb=contain_cmyk=0;
				repeat(num_of_imgs,p,
					current_spec_size=s#p;
					if(current_spec_size>5,run('exc_spec_found'););
					if(!contain_gray?current_spec_size<3,contain_gray=1;);
					if(!contain_cmy?current_spec_size==3,contain_cmy=1;);
					if(!contain_cmyk?current_spec_size>=4,contain_cmyk=1;);
					if(!contain_alpha?current_spec_size==2||current_spec_size>max_col_spec_size,contain_alpha=1;);
				);
				set('contain_gray',contain_gray);
				set('contain_cmy',contain_cmy);
				set('contain_cmyk',contain_cmyk);
				set('contain_alpha',contain_alpha);
			):(
				contain_color=0;
				repeat(num_of_imgs,p,
					current_spec_size=s#p;
					if(!contain_gray?current_spec_size<3,contain_gray=1;);
					if(!contain_color?current_spec_size>2,
						contain_color=1;
						if(current_spec_size>4,
							set('cmyk_mode',1);
							set('max_col_spec_size',4);
							continue_analyzing_color_space=1;
							break();
						);
					);
					if(!contain_alpha?current_spec_size==2||current_spec_size>max_col_spec_size,contain_alpha=1;);
				);
				if(!continue_analyzing_color_space,
					set('contain_gray',contain_gray);
					set('contain_color',contain_color);
					set('contain_alpha',contain_alpha);
				);
			);
			set('continue_analyzing_color_space',continue_analyzing_color_space);"
	while $continue_analyzing_color_space

else
	contain_gray,contain_alpha=$_gui_analysis_gray,$_gui_analysis_alpha
	contain_cmy=0
	contain_color,contain_cmyk=$_gui_analysis_color
fi

############################################
# Reference for code: Result of CMYK       #
# [gmic]./ g0,cmy0,cmyk1,alpha0 => 1,4     #
# [gmic]./ g0,cmy0,cmyk1,alpha1 => 2,5     #
# [gmic]./ g0,cmy1,cmyk0,alpha0 => 1,3     #
# [gmic]./ g0,cmy1,cmyk0,alpha1 => 2,4     #
# [gmic]./ g0,cmy1,cmyk1,alpha0 => 2,3,5,7 #
# [gmic]./ g0,cmy1,cmyk1,alpha1 => 3,5,6,8 #
# [gmic]./ g1,cmy0,cmyk0,alpha0 => 1,1     #
# [gmic]./ g1,cmy0,cmyk0,alpha1 => 2,2     #
# [gmic]./ g1,cmy0,cmyk1,alpha0 => 2,5     #
# [gmic]./ g1,cmy0,cmyk1,alpha1 => 3,6     #
# [gmic]./ g1,cmy1,cmyk0,alpha0 => 2,4     #
# [gmic]./ g1,cmy1,cmyk0,alpha1 => 3,5     #
# [gmic]./ g1,cmy1,cmyk1,alpha0 => 3,5,6,8 #
# [gmic]./ g1,cmy1,cmyk1,alpha1 => 4,6,7,9 #
############################################

#####################################
# Reference for code: Result of RGB #
# [gmic]./ g0,rgb1,alpha0 => 1,3    #
# [gmic]./ g0,rgb1,alpha1 => 2,4    #
# [gmic]./ g1,rgb0,alpha0 => 1,1    #
# [gmic]./ g1,rgb0,alpha1 => 2,2    #
# [gmic]./ g1,rgb1,alpha0 => 2,4    #
# [gmic]./ g1,rgb1,alpha1 => 3,5    #
#####################################

var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity:=expr('x+1',5)

if $cmyk_mode
	# Please factor in CMYK here. Find out how it should work #
	if ($#-$user_cmyk_mode)==5
		effect_factor,multiplication,opacity:=[${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity}]
		method,blending_id=${arg$var_method},${arg$var_blending}

		if !isint($method)&&('$method'!='-')
			method=${$method}
		fi

		if !$effect_factor||$opacity<=0
			return
		fi

		use_blend_str:=!isint($blending_id)

		if !$use_blend_str
			blending_id=${arg0\ $blending_id,$list_of_blending_modes}
		fi

		if $effect_factor||$opacity>0
			if $opacity==1?(same('$blending_id','normal')||same('$blending_id','alpha'))
				foreach {
					$0_bsoo_edit $method,$effect_factor,$multiplication
					cut 0,255
				}
			else
				foreach {
					+$0_bsoo_edit $method,$effect_factor,$multiplication
					_blend_$blending_id

					if $opacity<1
						j.. .,0,0,0,0,$opacity
						rm.
					else
						rm..
					fi

					cut 0,255
				}
			fi
		fi
	else
		use_gray,use_cmy,use_cmyk,use_alpha,use_cmy_channel_0,use_cmy_channel_1,use_cmy_channel_2,use_cmyk_channel_0,use_cmyk_channel_1,use_cmyk_channel_2,use_cmyk_channel_3=0

		if $contain_gray
			current_method=${arg$var_method}

			if !isint($current_method)&&('$current_method'!='-')
				current_method=${$current_method}
			fi

			if narg($current_method)?'$current_method'!='-'
				use_gray=${$0_process_individual_channel_section\ gray,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
			else
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
			fi
		fi

		if $contain_cmy
			current_method=${arg$var_method}
			if narg($current_method)
				repeat 3 {
					if !isint($current_method)&&('$current_method'!='-')
						current_method=${$current_method}
					fi

					if same('$current_method','-')
						var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
					elif narg($current_method)
						use_cmy_channel_$>=${$0_process_individual_channel_section\ cmy_channel_$>,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}

						if !$use_cmy
							use_cmy=${use_cmy_channel_$>}
						fi

						var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
					else
						error inval_arg
					fi
					current_method=${arg$var_method}
				}
			else
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
			fi
		fi

		if $contain_cmyk
			current_method=${arg$var_method}

			if narg($current_method)
				repeat 4 {
					if !isint($current_method)&&('$current_method'!='-')
						current_method=${$current_method}
					fi

					if same('$current_method','-')
						var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
					elif narg($current_method)
						use_cmyk_channel_$>=${$0_process_individual_channel_section\ cmyk_channel_$>,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}

						if !$use_cmyk
							use_cmyk=${use_cmyk_channel_$>}
						fi

						var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
					else
						error inval_arg
					fi

					current_method=${arg$var_method}
				}
			else
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
			fi
		fi

		if $contain_alpha
			current_method=${arg$var_method}

			if !isint($current_method)&&('$current_method'!='-')
				current_method=${$current_method}
			fi

			if narg($current_method)?'$current_method'!='-'
				use_alpha=${$0_process_individual_channel_section\ alpha,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
			fi
		fi

		foreach {
			contain_color,contain_alpha:=[s>2,s==2||s>4]

			if $use_alpha?$contain_alpha
				s c,-{s-1}

				if $use_alpha
					$0_process_alpha[-1]
				fi
			fi

			if $contain_color
				if s#0>3
					if $use_cmyk
						s[0] c
						foreach[0-3] { if ${use_cmyk_channel_$>} $0_process_cmyk_channel_$> fi }
					fi
				else
					if $use_cmy
						s[0] c
						foreach[0-2] { if ${use_cmy_channel_$>} $0_process_cmy_channel_$> fi }
					fi
				fi
			else
				if $use_gray
					$0_process_gray[0]
				fi
			fi

			a c
		}

	fi
else

	num_of_contains,num_of_set_args,gray_start={[sum($contain_gray,$contain_color,$contain_alpha),ceil($#/5)]},$contain_gray

	if $num_of_set_args!=$num_of_contains||(($#-$num_of_set_args*5)>0)
		use_gray,use_color,use_alpha,\
		use_channel_0,use_channel_1,use_channel_2=0

		if $contain_gray
			current_method=${arg$var_method}

			if !isint($current_method)&&('$current_method'!='-')
				current_method=${$current_method}
			fi

			if narg($current_method)?'$current_method'!='-'
				use_gray=${$0_process_individual_channel_section\ gray,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
			else
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
			fi
		fi

		if $contain_color
			current_method=${arg$var_method}
			if narg($current_method)
				repeat 3 {
					if !isint($current_method)&&('$current_method'!='-')
						current_method=${$current_method}
					fi

					if same('$current_method','-')
						var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
					elif narg($current_method)
						use_channel_$>=${$0_process_individual_channel_section\ channel_$>,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}

						if !$use_color
							use_color=${use_channel_$>}
						fi

						var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
					else
						error inval_arg
					fi
					current_method=${arg$var_method}
				}
			else
				var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=1
			fi
		fi

		if $contain_alpha
			current_method=${arg$var_method}

			if !isint($current_method)&&('$current_method'!='-')
				current_method=${$current_method}
			fi

			if narg($current_method)?'$current_method'!='-'
				use_alpha=${$0_process_individual_channel_section\ alpha,$current_method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
			fi
		fi

		if !sum($use_gray,$use_color,$use_alpha)
			return
		fi

		foreach {
			contain_color,contain_alpha:=[s>2,!(s&1)]

			if $use_alpha?$contain_alpha
				s c,-{s-1}
				if $use_alpha
					$0_process_alpha[-1]
				fi
			fi

			if $contain_color?$use_color
				s[0] c
				foreach[0-2] {
					if ${use_channel_$>}
						$0_process_channel_$>
					fi
				}
			elif $use_gray
				$0_process_gray[0]
			fi

			a c
		}
	elif $num_of_set_args==1
		effect_factor,multiplication,opacity:=[${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity}]

		method,blending_id=${arg$var_method},${arg$var_blending}

		if !isint($method)&&('$method'!='-')
			method=${$method}
		fi

		if !$effect_factor||$opacity<=0
			return
		fi

		use_blend_str:=!isint($blending_id)

		if !$use_blend_str
			blending_id=${arg0\ $blending_id,$list_of_blending_modes}
		fi

		if $effect_factor||$opacity>0
			if $opacity==1?(same('$blending_id','normal')||same('$blending_id','alpha'))
				foreach {
					$0_bsoo_edit $method,$effect_factor,$multiplication
					cut 0,255
				}
			else
				foreach {
					+$0_bsoo_edit $method,$effect_factor,$multiplication
					_blend_$blending_id

					if $opacity<1
						j.. .,0,0,0,0,$opacity
						rm.
					else
						rm..
					fi

					cut 0,255
				}
			fi
		fi

	elif !$num_of_set_args
		error needs_at_least_5_for_one_arg_set
	else
		if $contain_gray
			method=${arg$var_method}

			if !isint($method)&&('$method'!='-')
				method=${$method}
			fi

			use_gray=${$0_process_individual_channel_section\ gray,$method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
			var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
		fi

		if $contain_color
			method=${arg$var_method}

			if !isint($method)&&('$method'!='-')
				method=${$method}
			fi

			use_color=${$0_process_individual_channel_section\ color,$method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
			var_method,var_effect_factor,var_multiplication_factor,var_blending,var_opacity+=5
		fi

		if $contain_alpha
			method=${arg$var_method} if !isint($method)&&('$method'!='-') method=${$method} fi
			use_alpha=${$0_process_individual_channel_section\ alpha,$method,${arg$var_effect_factor},${arg$var_multiplication_factor},${arg$var_opacity},${arg$var_blending}}
		fi

		if !sum($use_gray,$use_color,$use_alpha)
			return
		fi

		foreach {
			contain_color,contain_alpha:=[s>2,!(s&1)]

			if $use_alpha?$contain_alpha
				shared[-1] {s-1}
				$0_process_alpha[-1]
				rm.
			fi

			if $contain_color?$use_color
				if $contain_alpha
					shared[-1] 0,{s-2}
				fi

				$0_process_color[-1]

				if $contain_alpha
					rm[-1]
				fi
			elif $use_gray

				if $contain_alpha
					shared[-1] 0,{s-2}
				fi

				$0_process_gray[-1]

				if $contain_alpha
					rm[-1]
				fi
			fi
		}
	fi
fi

um $0_bsoo_edit,+$0_bsoo_edit,$0_process_individual_channel_section,$0_process_gray,$0_process_color,$0_process_channel_0,$0_process_channel_1,$0_process_channel_1,$0_process_channel_2,$0_process_cmy_channel_0,$0_process_cmy_channel_1,$0_process_cmy_channel_2,$0_process_cmyk_channel_0,$0_process_cmyk_channel_1,$0_process_cmyk_channel_2,$0_process_cmyk_channel_3,$0_process_alpha
#@cli rep_decompose_bitplanes: _number_of_bits>0
#@cli : Decompose images into bitplanes.
#@cli : Default values: '_number_of_bits=8'
#@cli : Author : Reptorian.
rep_decompose_bitplanes:
l[] {
	check "${1=8}>1 && isint(${1=8})"
	d_bpi={$1-1}

	onfail
		if isnum($1)
			if !isint($1)||$1<2
				error inv_num_inp
			fi
		else
			noarg d_bpi=7
		fi
}

foreach {
	repeat $d_bpi {
		+>>[-1] 1
		&[-2] 1
	}

	&[-1] 1
}
#@cli rep_compose_bitplanes: _number_of_bits>0
#@cli : Compose bitplanes into images.
#@cli : Default values: '_number_of_bits=8'
#@cli : Author : Reptorian.
rep_compose_bitplanes:
l[] {
	check "${1=8}>1 && isint(${1=8})"
	d_bpi={$1-1}

	onfail
		if isnum($1)
			if !isint($1)||$1<2
				error inv_num_inp
			fi
		else
			noarg d_bpi=7
		fi
}

P,Q=-1,-2

repeat inf {
	repeat $d_bpi {
		<<[$P] 1
		|[$P,$Q]
	}

	if ($>+1)==$!
		break
	fi

	P,Q-=1
}
#@cli utf8str2vint: string
#@cli : Return vector of integer representation of UTF-8 byte string.
#@cli : Author : Reptorian.
utf8str2vint:
skip "${1=}"
if !$#
	status ""
	return
fi

eval "
	str = '$1';
	const size_str = size(str);
	code_points = vector(#size_str,0);
	num_of_code_points(v)=1+(v>=0b1110?v&0b11:v>0b111);

	pos = num_of_chars = 0;
	while( pos < size_str,
		current_code_point = str[pos] >> 4; # Extract first 4 bits of first byte. pos is used to select and extract the relevant numbers
		code_points[num_of_chars] = num_of_code_points(current_code_point);
		pos += code_points[num_of_chars];
		++num_of_chars;
	);

	if(pos!=size_str,
		run('error not_a_UTF-8_string!');
	);

	const N=0b11111111; # Base for the mathematics involving encoding or decoding UTF-8 strings
	const M=N>>2;       # Used to select binary numbers within x section of 10xxxxxx

	pos=0;
	repeat(num_of_chars,k,
		current_num_of_code_point = code_points[k];

		current_num_of_code_point == 4 ?(
			code_points[k] = ( str[pos] & (N>>5) ) << 18 | ( str[pos+1] & M ) << 12 | ( str[pos+2] & M ) << 6 | ( str[pos+3] & M );
		):
		current_num_of_code_point == 3 ?(
			code_points[k] = ( str[pos] & (N>>4) ) << 12 | ( str[pos+1] & M ) << 6  | ( str[pos+2] & M );
		):
		current_num_of_code_point == 2 ?(
			code_points[k] = ( str[pos] & (N>>3) ) << 6  | ( str[pos+1] & M );
		):(
			code_points[k] =   str[pos];
		);

		pos+=current_num_of_code_point;
	);

	set('num_of_chars',num_of_chars);
	code_points;
	"

status {([${}])[0,$num_of_chars]}
#@cli vint2utf8str: int_a>=0,...
#@cli : Return corresponding integer(s) representation of UTF-8 byte string.
#@cli : Author : Reptorian.
vint2utf8str:
skip "${1=}"
if !$#
	status ""
	return
fi

eval "
	list_of_ints = [$*];

	if( min(list_of_ints) < 0 || max(list_of_ints) > 0x10ffff,
		run('error range_exc');
	);

	const list_size = size(list_of_ints);
	const init_size = list_size<<2;

	new_list = vector(#init_size,0);

	const M  = 0b10000000;  # 10xxxxxx. x will be replaced by corresponding numbers associated with integer representation
	const N  = 0b11111111;  # Base for the mathematics involving encoding or decoding UTF-8 strings
	const S  = N>>2;        # Used to select binary numbers to insert into x section of 10xxxxxx
	const X1 = xor(N,S);    #110xxxxx
	const X2 = xor(N,S>>1); #1110xxxx
	const X3 = xor(N,S>>2); #11110xxx

	final_size=0;
	repeat(list_size,k,
		cv = list_of_ints[k];

		cv > 0x10000 ? ( LS=3;XC=X3; ): # LS is shorthand for loops, which will be used to aid into inserting values into x series
		cv > 0x800 ? (   LS=2;XC=X2; ):
		cv > 0x80 ? (    LS=1;XC=X1; ):
		(                LS=0;       );

		LS?(
			for( ind=final_size+LS, ind>final_size, --ind,
				new_list[ind] = M | ( cv&S );
				cv >>= 6;
			);
			new_list[final_size] = XC | cv;
		):(
			new_list[final_size] = cv;
		);

		final_size += LS+1;
	);

	set('final_size',final_size);
	new_list;
	"

status {`([${}])[0,$final_size]`}
#@cli rep_nonexistent_colors_pal: number_of_new_colors, _appended_into_palette={ 0=do_not_append | 1=append into palette },_method={ 0=random | 1=farthest (slow) },0<_mask_factor[%]<=1,_cube_size>=7
#@cli : Generates a palette of non-existent colors on each images. Either, appended onto the image, or as a new palette.
#@cli : '_appended_into_palette=1','_method=0','_mask_factor=1','_cube_size=16'
rep_nonexistent_colors_pal:
skip ${2=1},${3=0},${4=1},${5=64}
check "isint($1)&&$1>=1&&inrange($4,0,1,0,1)&&isint($5,7,256)"

number_of_new_colors,append_into_pal,cube_size=$1,$2,$5

if isint($3) far_mode={$3&1}
else
	r,rand,random,aleatoria=0 far,farthest,distant,lejos=1
	far_mode=$$3 if !narg($far_mode) error inval_arg fi
fi

if $far_mode
	# Unfortunately this code requires coordinates of vertexs in 4D+ dimensions via voronoi to actually be optimal
	mask_factor:=1/$4
	scale_factor:=255/($cube_size-1)
	/ $scale_factor # Normalize Palettes
	foreach { resize {whd},1,1,100%,-1 }
	num_of_imgs:=$!
	$num_of_imgs,1,1,1,s#x colormap. 0,1,1
	repeat w#-1 {
		size_of_channels:=i[#$num_of_imgs,$>]
		current_box_dimensions={vector(#$size_of_channels,$cube_size)}
		box_dimensions_$size_of_channels=$current_box_dimensions
		+rep_cartesian_product $current_box_dimensions => cube_$size_of_channels
	}
	rm[$num_of_imgs]
	repeat $num_of_imgs {
		current_index=$>
		repeat $number_of_new_colors {
			current_number_of_channels:=s#$current_index
			[${cube_$current_number_of_channels}]
			+index[-1] [$current_index],0,1
			-[-2,-1]
			sqr. compose_channels. +
			if $mask_factor!=1 sqrt. +n. 0,1 negate. ^. $mask_factor *[-2,-1] fi
			max_coords:=xM#-1
			(${rep_cartesian_product_index2list\ ${box_dimensions_$current_number_of_channels},$max_coords}) permute. yzcx
			a[$current_index,-1] x rm.
		}
	}
	rm[$num_of_imgs--1]
	if !$append_into_pal
		foreach { crop {w-$number_of_new_colors},100% }
	fi
	* $scale_factor round
else
	foreach {

		if !inrange(s#-1,1,6,1,1)
			error inv_chans_num@[$>]
		fi

		if $append_into_pal
			1,{$number_of_new_colors+$current_number_of_colors},1,1,y
			map[-1] [-2]
			rm[-2]
			1,1,1,100%
		else
			1,1,1,100%x2
		fi

		eval "  # Enter JIT compiler
			const number_of_new_colors=$number_of_new_colors;
			const number_of_channels=s#0;
			const current_number_of_colors=$current_number_of_colors;
			const append_into_pal=$append_into_pal;
			const maximum_integer_value=256^number_of_channels;

			bitshift_factors=expr('x?1<<(2+x)',number_of_channels);

			convert_color2int(color_values)=sum(color_values<<bitshift_factors);
			convert_int2color(value)=(value>>bitshift_factors)&0xff;

			min_pos_val=-1;
			max_pos_val=inf;

			state_check=mode=0;
			old_value=middle_pivot=pivot_value=-1;

			repeat(current_number_of_colors,p,
				current_color=I[#0,p];
				current_value=convert_color2int(current_color);

				mode==3?(
					state_check=0;
					current_value==min_pos_val||current_value==max_pos_val||current_value==pivot_value||current_value==old_value?(
						continue();
					):(
						old_value=current_value;

						current_value<min_pos_val?(
							min_pos_val=current_value;
							da_insert(#-1,0,current_color);
						):
						current_value>max_pos_val?(
							max_pos_val=current_value;
							da_push(#-1,current_color);
						):
						current_value>pivot_value?(
							for(q=middle_pivot+1,q<da_size(#-1),++q,
								test_value=convert_color2int(I[#-1,q]);
								test_value>current_value?(
									break();
								):
								test_value==current_value?(
									state_check=1;
									break();
								);
							);
							if(state_check
							,continue();
							,da_insert(#-1,q,current_color);
							);
						):( # current_value<pivot_value
							for(q=middle_pivot-1,q>0,--q,
								test_value=convert_color2int(I[#-1,q]);
								current_value>test_value?(
									break();
								):
								test_value==current_value?(
									state_check=1;
									break();
								);
							);
							if(state_check
							,continue();
							,da_insert(#-1,q+1,current_color);
							);
						);
						middle_pivot=da_size(#-1)>>1;
						pivot_value=convert_color2int(I[#-1,middle_pivot]);
					);
				):
				mode==2?(
					if(!state_check,
						min_pos_val=convert_color2int(I[#-1,0]);
						max_pos_val=convert_color2int(I[#-1,1]);
						state_check=1;
					);
					current_value==min_pos_val||current_value==max_pos_val?(
						continue();
					):(
						middle_pivot=1;
						mode=3;
						state_check=0;

						current_value<min_pos_val?(
							pivot_value=min_pos_val;
							min_pos_val=current_value;
							da_insert(#-1,0,current_color);
						):
						current_value<max_pos_val?(
							pivot_value=current_value;
							da_insert(#-1,1,current_color);
						):
						current_value>max_pos_val?(
							pivot_value=max_pos_val;
							max_pos_val=current_value;
							da_push(#-1,current_color);
						);
					);
				):
				mode?(
					current_value>old_value?(
						da_push(#-1,current_color);
						old_value=current_value;
						mode=2;
					):
					current_value<old_value?(
						da_insert(#-1,0,current_color);
						old_value=current_value;
						mode=2;
					);
				):(
					da_push(#-1,current_color);
					old_value=current_value;
					mode=1;
				);
			);

			append_into_pal?(
				insertion_pos=current_number_of_colors;
				insert_new_color(color)=I[#-2,insertion_pos++]=color;
			):(
				insert_new_color(color)=da_push(#-2,color);
			);

			last_rn=inf;
			q=0; # Inserted position
			repeat(number_of_new_colors,
				selec_u=v(0,maximum_integer_value-da_size(#-1),1,0);
				for(q=(selec_u>=last_rn?++q),q<da_size(#-1),++q,
					selec_u>=convert_color2int(I[#-1,q])?(
						++selec_u;
					):(break(););
				);
				new_color=convert_int2color(selec_u);
				da_insert(#-1,q,new_color);
				insert_new_color(new_color);
				last_rn=selec_u;
			);

			if(!append_into_pal,da_freeze(#-2););
			"

		keep[{!$append_into_pal}]
	}
fi
#@cli rep_van_neumann_condition_tiling: width,height,whole_number_count_starting_from_zero>=4
#@cli : Generate random tiles which meets van neumann condition.
+rep_van_neumann_condition_tiling:
check "$3>=2&&isint($3)"

${1-2},1,1,>"begin(
		const Ws=$3;
		rn_exlc(arg...)=(
			ref([arg],excl_num);
			repeat(size(excl_num),p,
				sel_rn>=excl_num[p]?(
					++sel_rn;
				):(break(););
			);
			sel_rn;
		);
		temp_num_a=temp_num_b=0;
	);
	paint_using_x=x?1;
	paint_using_y=y?1;

	if(paint_using_x,temp_num_a=j(-1,0););
	if(paint_using_y,temp_num_b=j(0,-1););
	if(paint_using_x&&paint_using_y,paint_using_y=temp_num_a!=temp_num_b);

	paint_using_x&&paint_using_y?(
		if(temp_num_b<temp_num_a,swap(temp_num_a,temp_num_b););
		sel_rn=v(0,Ws-2,1,0);
		rn_exlc(temp_num_a,temp_num_b);
	):
	paint_using_x||paint_using_y?(
		sel_rn=v(0,Ws-1,1,0);
		rn_exlc(paint_using_x?temp_num_a:temp_num_b);
	):(
		v(0,Ws,1,0);
	);"
#@cli rep_echo_image_data:
#@cli : Echo the data that represents the image.
rep_echo_image_data:
repeat $! {
	echo[^-1] ({$>,`"put_sep(s,_k)=(
						for(k=_k;p=find(s,_','),p>=0,p = find(s,_',',++p),
							s[p]=k%w?_',':k%wh?_';':k%whd?_'/':_'^';
							++k;
						);
						s;
					);
					s=v2s(crop(),-1);
					put_sep(s,1);
					"`}) # Code taken from print in G'MIC STDLIB
}
#@cli rep_cin: '_message'
#@cli : Allows users to input into status.
#@cli : Default values: '_message=G'MIC rep_cin output:'
#@cli : $ echo ${-rep_cin}
#@cli : $ rep_cin , echo "Status Output: "${}
#@cli : $ rep_cin "Input: " echo "Status Output: "${}
#@cli : $ m=${"rep_cin \"Test A: \""} echo "Status Output: "$m
rep_cin:
skip "${1=}"
screen_w,screen_h:={*,u},{*,v}>>1
stack_size,case,n0:=(1<<10)+1,_'A'-_'a',_'0'
insertion_pos,started,mode=0
old_insertion_pos,old_da_size=nan
message="$1"
1,$stack_size,1,1
iteration,break_all=0

do {
	if {*,ENTER}" || "{*,ESC} w[] 0,0 break fi
	use_key=1

	__rep_cin_nstr

	old_insertion_pos=$insertion_pos
	old_da_size:=da_size(#-1)

	if $arrow_pressed||$key
		w[] $screen_w,1,0,0,$message$M1
		wait
	elif {*,BACKSPACE}
		w[] $screen_w,1,0,0,$message$M1
		wait 150
	else
		do {
			if {*,k}
				__rep_cin_nstr

				w[] $screen_w,1,0,0,$message$M1

				if $arrow_pressed||$key
					wait
					w[] $screen_w,1,0,0,$message$M1
				elif {*,BACKSPACE}
					w[] $screen_w,1,0,0,$message$M1
					wait 150
				fi

				break
			fi

			if $started
				if $iteration==60
					w[] $screen_w,1,0,0,$message${M$mode}
					mode={!$mode}
					iteration=0
				fi
			else
				w[] $screen_w,1,0,0,0,$screen_h,$message$M0
				started=1
			fi

			iteration+=1
			wait 2
		} while !{*,k}&&{*}
	fi
} while {*}

rm.

u $M0
__rep_cin_nstr:
if {*,BACKSPACE}" && "da_size(#-1)&&$insertion_pos
	use_key=0
	eval da_remove(#-1,cut($insertion_pos-1,0,da_size(#-1)-1))
	insertion_pos:=cut($insertion_pos-1,0,da_size(#-1))
fi

arrow_pressed={{*,ARROWLEFT}||{*,ARROWRIGHT}}

if $arrow_pressed
	ARROWLEFT={*,ARROWLEFT}
	ARROWRIGHT={*,ARROWRIGHT}
	insertion_pos={cut($insertion_pos-$ARROWLEFT+$ARROWRIGHT,0,da_size(#-1))}
elif $use_key
	__rep_cin_key2int
	if ${}
		eval da_insert(#-1,$insertion_pos,${})
		insertion_pos+=1
	fi
fi

if $insertion_pos!=$old_insertion_pos||da_size(#-1)!=$old_da_size
	if !da_size(#-1)
		M0=
		M1=_
	else
		if ($insertion_pos>=(da_size(#-1)))||!$insertion_pos
			M0=${_rep_cin_values2str\ {crop(#-1,0,0,0,0,1,{da_size(#-1)},1,1)}}
			M1=$M0

			if $insertion_pos
				M1.=_
			else
				M1..=_
			fi
		else
			left=${_rep_cin_values2str\ {crop(#-1,0,0,0,0,1,$insertion_pos,1,1)}}
			right=${_rep_cin_values2str\ {crop(#-1,0,$insertion_pos,0,0,1,{da_size(#-1)-$insertion_pos},1,1)}}

			M0=$left$right
			M1=${left}_$right
		fi
	fi
fi

# Below is the reference I used to help create the above code:
# ;=,-./` [\]'
# 186,187,188,189,190,191,192,219,220,221,222
_rep_cin_values2str: ($*) replace_str. "\\","\\\\" u {t} rm.
__rep_cin_key2int:
shift_pressed:=({*,SHIFTLEFT}||{*,SHIFTRIGHT})
use_capitalization:=!$shift_pressed
key={*,k}

conditions={[inrange($key,186,192,1,1),inrange($key,219,222,1,1),inrange($key,_'A',_'Z',1,1),inrange($key,_'0',_'9',1,1),$key==_'\ ']}
in_char_set_1,in_char_set_2,is_letter,is_num_range,is_space=$conditions

if !same([$conditions],0)
	if $is_space
		u {_'\ '}
		return
	fi

	if $in_char_set_1   u {(';=,-./`:+<_>?~')[$key-186+($shift_pressed?7)]}
	elif $in_char_set_2 u {('[\\]\'\{\|\}\"')[$key-219+($shift_pressed?4)]}
	elif $is_num_range  u {$shift_pressed?(')!@#\$%^&*(')[$key-_'0']:$key}
	else                u {$key-(!$shift_pressed?$case)}
	fi
else
	u 0
fi
#@cli rep_bisect_num_list: ref_num,num_a,num_b,...
#@cli : Search closest number on list of numbers using binary search
#@cli : Use '~' at the beginning of ref_num to return index instead.
#@cli : List must be sorted ascending
rep_bisect_num_list:
use_index={('$1')[0]==_'~'}
num={`N=('$1');N[$use_index,size(N)-$use_index]`}

if $#==1 u nan return
elif $num==nan u nan return
fi

eval "
	const n2f=$num;

	ln=[${2--1}];

	left=0;
	right=size(ln)-1;

	while(left<=right,
		mid=left+((right-left)>>1);

		ln[mid]==n2f?(
			right=mid;
			break();
		):
		ln[mid]<=n2f?(
			left=mid+1;
		):(
			right=mid-1;
		);
	);

	index=right<0?0:right;
	$use_index?index:ln[index];"
#@cli rep_lcn: ref_num,num_a,num_b,...
#@cli : Find closest number on list of numbers. # localizer numero mas cercar
#@cli : Use '~' at the beginning of ref_num to return index instead.
rep_lcn:
use_index={('$1')[0]==_'~'}
num={`N=('$1');N[$use_index,size(N)-$use_index]`}

if $#==1 u nan return fi

eval "
	const N=$num;
	const use_idx=$use_index;
	ln=[${2--1}];

	isfinite(N)?(
		a=argminabs(ln-N);
		use_idx?a:ln[a];
	):(
		N==inf?(
			use_idx?argmax(ln):max(ln);
		):
		N==-inf?(
			use_idx?argmin(ln):min(ln);
		):(
			run('error nan_err');
		);
	);"
#@cli rep_digamma:
#@cli : Return the Logarithmic deritative of the Gamma function
#@cli : Original code has been made by Mark Johnson. Permission has been granted to use his code. Link to source - http://web.science.mq.edu.au/~mjohnson/code/digamma.c
rep_digamma:
eval "
	digamma(n)=(
		result=0;
		p=n;
		while(p<7,
			result-=1/p;
			++p;
		);
		x0=p-(1/2);
		xx=1/x0;
		xx2=sqr(xx);
		xx4=sqr(xx2);
		result+=log(x0)+(1./24)*xx2-(7/960)*xx4+(31/8064)*xx4*xx2-(127/30720)*xx4*xx4;
	);
	digamma($1);"
#@cli rep_color_region: _threshold[%]>0
#@cli : For use in images with large color blobs, this simplifies a image.
rep_color_region:
skip ${1=25%},${2=0%},${3=6}

check "inrange($1,0,1,0,1)&&inrange($2,0,1,1,1)&&$3>=0"
area_threshold,stray_threshold,color_distance_threshold=${1-3}

foreach {
	+round
	+colormap. 0,,1
	+index[-2] [-1],0,0
	+area. 0,0
	ge. {ia*$area_threshold}
	*.. .
	negate.
	-.. .
	rm.
	colormap. 0,,1

	if xM discard. -1
	else crop. 1,100%
	fi

	map. ..

	if $color_distance_threshold
		if h>1 dimensions=1,100%
		else 100%,1
		fi
		$dimensions,1,1,">begin(
				const color_distance_threshold=$color_distance_threshold;
				position=0;
				test_color=vector(#s#-1,-inf);
			);
			distance=norm(I#-1-test_color);
			if(distance>color_distance_threshold&&distance!=inf,
				++position;
			);
			test_color=I#-1;
			position;"
		blend[-2,-1] shapeaverage colormap. 0
	fi

	rm..
	index.. .,0,1
	rm. rv

	if $2

		100%,100%,100%,1

		1,1,1,2

		eval[0] >"
			begin(
				off_place=[-1,1];
			);

			pixel_in_place=0;

			repeat(4,position,
				xp=off_place[position&1];
				yp=off_place[position>>1];
				pixel_in_place=(I==J(xp,0,0,0,1))&&(I==J(0,yp,0,0,1));
				if(pixel_in_place,break(););
			);

			if(!pixel_in_place,
				pixel_position=[x,y];
				i(#-2,pixel_position)=1;
				da_push(#-1,pixel_position);
			);

			I;"

		if !iM#-2
			keep[0]
			continue
		fi

		+label[0] 0,0
		area. 0,0
		le. {$stray_threshold*iM}
		*[-3,-1]

		if !iM#-2
			keep[0]
			continue
		fi

		eval "
			size_da=da_size(#-1);
			point=size_da-1;
			repeat(size_da,
				if(!i(#-2,I[#-1,point],0,1),da_remove(#-1,point););
				--point;
			);
			da_freeze(#-1);
			"

		eval. :"begin(
				a_coordinates=[-1,0,1,-1,1,-1,0,1];
				b_coordinates=[-1,-1,-1,0,0,1,1,1];
			);

			number_of_valid_pixels=0;
			difference_vector=vector(#4,inf);

			repeat(8,position,
				offset_a=a_coordinates[position];
				offset_b=b_coordinates[position];
				offset=[offset_a,offset_b];
				test_pixel_position=I+offset;
				if(!i(#3,test_pixel_position,1),
					difference_vector[position]=norm(I(#0,I,0,1),I(#1,test_pixel_position,0,1));
					++number_of_valid_pixels;
				);
			);

			if(number_of_valid_pixels,
				position=argmin(difference_vector);
				offset_a=a_coordinates[position];
				offset_b=b_coordinates[position];
				offset=[offset_a,offset_b];
				pixel_position=I+offset;
				I(#0,I)=I(#0,pixel_position,0,1);
			);"

	fi

	keep[0]
}
#@cli rep_two_dimension_set_indices:
#@cli : Return images containing indexes.
rep_two_dimension_set_indices:
num_of_imgs:=$!

repeat $num_of_imgs {
	width:=w#$>
	height:=h#$>

	if narg(${image_dimension_${width}_${height}})
		eval da_push(#${image_dimension_${width}_${height}},$>)
	else
		1 => image_dimension_${width}_${height}
		eval da_push(#-1,$>)
	fi
}

foreach[$num_of_imgs--1] { eval da_freeze(#-1) }
#@cli rep_sort_images_by_images_name_order: name_a,name_b
#@cli Sort images accordingly to images name. Duplicates images name are not accepted!
#@cli : $ sample portrait2,duck,fruits,portrait1,portrait2,duck,duck,fruits rep_sort_images_by_images_name_order duck,portrait2,fruits,portrait1
rep_sort_images_by_images_name_order:
imgs_moved=0
$=arg

for $imgs_moved<$! {
	named[$imgs_moved--1] 0,${arg{$>+1}}
	t_arg:=narg(${})

	if $t_arg
		move[${}] $imgs_moved
		imgs_moved+=$t_arg
	else
		error missing_image_name
	fi
}
#@cli rep_sort_images_by_order: number_a,number_b,....
#@cli : Sort images accordingly to numerical arguments. The number of numerical arguments has to be equal to the number of images, and they have to be positive integer number starting from 0 until number that is equal to number of arguments minus one.
#@cli : $ sample cat,dog,lena,david,house,flower,waterfall,tiger name {expr('x',$!)} rep_sort_images_by_order 5,1,7,0,4,2,3,6
rep_sort_images_by_order:
if $#!=$! error invalid_image_count fi

input_v=[{[$*]%$#}]
sorted_v=[{expr('x',$#)}]

if $input_v==$sorted_v
	return
elif $input_v==reverse($sorted_v)
	reverse
else

	$#,1,1,1,>"begin(
			const max_index=w-1;
			offset_position=index_counter=vector(#w,0);
			order=[$*];
		);
		value_index=order[x]%w;
		if(++index_counter[value_index]>1,run('error dup_ind_inp'););
		off_position=value_index-offset_position[value_index];
		copy(offset_position[value_index],1,w-value_index,1,0,-1);
		off_position+x;
		"

	repeat $# {
		move[{i(#-1,$>)}] $>
	}

	remove[-1]

fi
#@cli rep_tuppers_self_K: apply_pre_negation={ 0=false | 1=true }
#@cli : Generate K values from images. Also, threshold image for users to check what it would look like.
#@cli : Default values: 'apply_pre_negation=1'
rep_tuppers_self_K:
skip ${1=1}

n0={'0'}

out,sep=

foreach {

	if !(s&1)
		to_graya
		s c
		/. 255
		*
	else
		to_gray
	fi

	if !iv?($1?im:!im)
		if $> out.=,0
		else out=0
		fi
		continue
	fi

	height={h}

	if $height<2
		error inv_dimension_[$>]
	fi

	gt {(im+iM)/2}
	+store. image

	if $1
		xor 1
	fi

	rotate 90
	unroll x

	rep_bin2dec_base ,

	f <"begin(
			const height=$height;
			const base=1e7;
			remainder=0;
		);
		new_val=i*height+remainder;
		remainder=int(new_val/base);
		new_val%base;
		end(
			set('remainder',remainder);
		);"

	if $remainder
		($remainder)
		rv[-2,-1]
		a[-2,-1] x
	fi

	out.=$sep${rep_base_10M_img2posdec[-1]}
	sep=,

	rm $image

}

status $out
#@cli rep_tuppers_self: _K>=h,_apply_negate={ 0=false | 1=true }
#@cli : Generates output of K onto a single image.
#@cli : Note: _K must be a integer number equal or greater to the height of image.
#@cli : Default values: '_K=96093937991.....','apply_negate=1'
rep_tuppers_self:
skip ${1=960939379918958884971672962127852754715004339660129306651505519271702802395266424689642842174350718121267153782770623355993237280874144307891325963941337723487857735749823926629715517173716995165232890538221612403238855866184013235585136048828693337902491454229288667081096184496091705183454067827731551705405381627380967602565625016981482083418783163849115590225610003652351370343874461848378737238198224849863465033159410054974700593138339226497249461751545728366702369745461014655997933798537483143786841806593422227898388722980000748404719},${2=1}

if $!!=1 error n_imgs_inv fi
if d>1 error imgs_dims_inv fi
if $1<h&&$1 error inv_inp fi

if $1>=h
	fill y+x*h mirror. x

	(${rep_posdec2altbase_num\ float_max,${rep_BIGINT_division\ $1,{h}}})
	{24*(w-1)+int(log2(i[#-1,0]))+1}
	eval[-2] "
		const mx=w-1;
		xp=mx-x;
		point=xp*24;
		digit=i;
		while(digit,
			i(#-1,point++)=digit&1;
			digit>>=1;
		);
		i;
		"

	map[-3] [-1] rm[-2,-1]
else
	fill 0
fi

if $2
	negate
fi
#@cli rep_bin2dec: binary_a,binary_b,....
#@cli : Return the converted binary numbers to decimal representating using an specialized algorithm which fits the restraint of G'MIC. Large binary number is supported here.
rep_bin2dec:
check "$#>0"

$=arg
out,sep=

repeat $# {
	p:=$>+1
	out.=$sep${rep_bin2dec_base\ ${arg$p}}
	sep=,
}

u $out
#@cli rep_bin2dec_base: {[binary_number_image] | binary_number },'_output={ 0=status | 1=base_10M_img }
#@cli : Used as base command to process binary-value images and to output decimal or base-10M images.
#@cli : Default values: '_mode_unicode=0','_output=0'
#@cli : Author : Reptorian.
rep_bin2dec_base:
skip "${1=}",${2=0}

output_mode:=$2
chunk_size:=0x1000

pass_img,alter_image=${is_image_arg\ $1},{!narg($1)}
process_image=$pass_img||$alter_image

if $pass_img
	pass$1 0
	output_mode=1
fi

if $process_image
	unroll. x
	if !(im==_'0'||iM==_'1') +. {_'0'} fi
else
	('$1')
fi

if im<_'0'||iM>_'1' error inv_char_det fi
crop. {xM},100%

# Directly convert if binary digits count is less than 53
if w<53
	value:=s2v([('0b'),crop(#-1)])
	if !$alter_image rm. fi

	if $output_mode||$alter_image
		{ceil(size('$value')/7)},1,1,1,<"begin(
				value=$value;
				remainder=0;
			);
			temp_value=value%10000000;
			value=int(value/10000000);
			temp_value;"

		if $alter_image rm.. fi
	else
		u $value
	fi

	return
fi

maximum_output_size={ceil(w#-1*0.043004285094854454)} # num_of_bin * log(2)/log(1e7)

# Convert binary to base 16777216 or base float
first_section:=$!-1
{ceil(w/24)},1,1,1,"begin(
		const offset=w*24-w#-1;
		const dist=24-offset;
		pos=started=output=0;
	);
	started?(
		pos+=24;
		output=s2v([('0b'),crop(#-1,pos,0,0,0,24,1,1,1)]);
	):(
		pos=x*24-offset;
		pos>=0?(
			output=s2v([('0b'),crop(#-1,pos,0,0,0,24,1,1,1)]);
		):(
			output=s2v([('0b'),crop(#-1,0,0,0,0,dist,1,1,1)]);
		);
		started=1;
	);
	output;"

rm[-2]
mirror[-1] x

#  This parts converts binary chunks directly to base 10M
if w#-1>$chunk_size
	s x,-$chunk_size
	__rep_bin2dec_base_convert_base_mul_sections[$first_section--1]
else
	__rep_bin2dec_base_convert_base_float2base_10M[-1]
	if !$output_mode&&!$alter_image
		rep_base_10M_img2posdec[-1]
		rm.
	fi
	return
fi

base_img=$!

# Below code creates images of power of (1<<(24*0x1000)) in base 10-Million
__rep_bin2dec_base_power_base_img
repeat $sections-2 {
	1
	eval[$base_img] :"begin(
			const last_digit_pos=w#-2-1;
			const new_two_to_the_power_of_24_by_0x1000_size=w+w#-2;
			output_vector=vector(#new_two_to_the_power_of_24_by_0x1000_size);
		);
		offset=w-x;
		pos=new_two_to_the_power_of_24_by_0x1000_size-offset;
		diff_pos=pos-w#-2;
		remainder=0;
		L=last_digit_pos;
		while(pos>diff_pos||remainder,
			new_val=output_vector[pos]+i[#-2,L--]*i+remainder;
			output_vector[pos--]=new_val%10000000;
			remainder=int(new_val/10000000);
		);
		end(
			merge(output_vector,+);
			pos=new_two_to_the_power_of_24_by_0x1000_size-1;
			remainder=0;
			do(
				new_val=output_vector[pos]+remainder;
				output_vector[pos--]=new_val%10000000;
				remainder=int(new_val/10000000);
			,remainder||pos>=0);
			contain_zero=!output_vector[0];
			resize(#-1,new_two_to_the_power_of_24_by_0x1000_size-contain_zero,1,1,1,-1);
			copy(i[#-1,0],output_vector[contain_zero],new_two_to_the_power_of_24_by_0x1000_size-contain_zero,1,1);
		);
		"
}

dec_sections:=$sections-1
iter_pos:=$!-$dec_sections

# Add in image to use and insertion position
do
	relative_pos={$iter_pos-$dec_sections}
	if w#$relative_pos
		{w#$iter_pos},1,1,2,[offset=w-x;$maximum_output_size-offset,$relative_pos]
		a[$iter_pos,-1] c
	else
		rm[$iter_pos]
		0
		move[-1] $iter_pos
	fi
	iter_pos+=1
while $iter_pos<$!

a[$base_img--1] x

# Initialize for final result
resize[$first_section] $maximum_output_size,1,1,$_cpus,0,0,1

# Multiply images and add them all per threads
$_cpus,1,1,1,:"begin(
		const result_image=$first_section;
	);
	for(position=t,position<w#-1,position+=$_cpus,
		data=I[#-1,position];
		insertion_position=data[1];
		selected_image_to_use=data[2];
		length_of_selected_image=w#selected_image_to_use;

		diff_pos=insertion_position-length_of_selected_image;

		digit_pos=length_of_selected_image-1;
		remainder=0;
		while(insertion_position>diff_pos||remainder,
			new_val=i(#selected_image_to_use,digit_pos--)*data[0]+i(#result_image,insertion_position,0,0,t)+remainder;
			i(#result_image,insertion_position--,0,0,t)=new_val%10000000;
			remainder=int(new_val/10000000);
		);
	);
	"

rm[{$first_section+1}--1]

# Add all the threads results and finalize the conversion
fill[-1] <begin(remainder=0;);new_val=sum(I)+remainder;remainder=int(new_val/10000000);[new_val%10000000];
channels[-1] 0
crop {!i[#-1,0]},100%

if !$output_mode&&!$alter_image
	rep_base_10M_img2posdec[-1]
	rm.
fi
__rep_bin2dec_base_convert_base_mul_sections:
	sections:=$!
	$sections,1,1,1,(iM#x)&&(w#x>1)?x:-1
	discard. -1
	selections={crop(#-1)}
	rm.
	n_selection:=narg($selections)

	if $n_selection==1 __rep_bin2dec_base_convert_base_float2base_10M[$selections]
	elif $n_selection>1 ap[$selections] __rep_bin2dec_base_convert_base_float2base_10M # Apply command to different chunk in parallel threads
	fi

	foreach[^$selections] { if !iM#-1 rm 0 fi }
__rep_bin2dec_base_convert_base_float2base_10M:
	crop 0,{for(p=w#-1-1,p>=0,--p,if(i[#-1,p],break()));p;}
	iterations,new_size:=w-1,ceil(w#-1*1.03210284228) # num_of_digits_in_base_float * log(1<<24)/log(1e7)
	$new_size

	eval.. >"begin(
			multiplier_vector=vector(#$new_size);
			const end_img_pos=w#-1-1;
			const end_pos=size(multiplier_vector)-1;
			multiplier_vector[end_pos]=1;
			digit_pos=end_pos;
			started=0;
		);
		started?(
			remainder=secondary_remainder=0;
			multiplier=i;
			q=end_img_pos;
			for(p=end_pos,p>=digit_pos||remainder,--p,
				new_val=(multiplier_vector[p]<<24)+remainder;
				multiplier_vector[p]=new_val%10000000;
				remainder=int(new_val/10000000);
				if(multiplier,
					secondary_new_val=i[#-1,q]+multiplier_vector[p]*multiplier+secondary_remainder;
					i[#-1,q]=int(secondary_new_val%10000000);
					secondary_remainder=int(secondary_new_val/10000000);
				);
				--q;
			);
			if(remainder,multiplier_vector[p]=remainder);
			if(secondary_remainder,i[#-1,q]=secondary_remainder);
			digit_pos=p;
		):(
			i[#-1,end_pos]=i%10000000;
			if(i>=10000000,i[#-1,end_pos-1]=int(i/10000000););
			started=1;
		);"
	rm[-2] crop {repeat(w#-1,p,if(i[#-1,p]>0,break()));p;},100%
#@cli rep_base_10M_img2posdec: [base_10_img_1],[base_10_img_2],...
#@cli : Return the conversion Base 10M images back to decimal.
rep_base_10M_img2posdec:

comma=
foreach {
	if s!=1&&im<0&&iM>=1e7 error inv_img fi

	{size('{i[#-1,0]}')+(whd#-1-1)*7},1,1,1,_'0'
	eval.. "begin(
			const offset=w*7-w#-1+1;
			const dist=7-offset;
			pos=started=0;
		);
		started?(
			pos+=7;
		):(
			pos=x*7+dist;
			started=1;
		);
		current_chars_of_num=v2s(i,0,7);
		for(m=6,m>=0,--m,if(current_chars_of_num[m],break();););
		copy(i[#-1,pos],current_chars_of_num[m],m+1,-1,-1);
		"
	status_out.=$comma{t}
	comma=,
	rm.
}

u $status_out
#@cli rep_posdec2base_10M_img: decimal_a,decimal_b,...
#@cli : Create images representing numbers in base 10M. Used for BIGINT supporting commands.
+rep_posdec2base_10M_img:
$=num

repeat $# {
	pos:=$>+1
	('${num$pos}')
	if im<_'0'||iM>_'9'
		error inv_arg_\$$pos
	fi

	crop[-1] {for(p=0,p<w#-1,++p,if(i!=_'0',break();););p;},100%

	if w<=7
		({s2v(crop(#-1))})
		rm..
		continue
	fi


	{ceil(w/7)},1,1,1,"begin(
			const offset=w*7-w#-1;
			const dist=7-offset;
			const ex=w-1;
			started=copy_pos=output=0;
		);
		started?(
			copy_pos+=7;
			output=s2v(crop(#-1,copy_pos,0,0,0,7,1,1,1));
		):(
			copy_pos=x*7-offset;
			copy_pos>=0?(
				output=s2v(crop(#-1,copy_pos,0,0,0,7,1,1,1));
			):(
				output=s2v(crop(#-1,0,0,0,0,dist,1,1,1));
			);
			started=1;
		);
		output;"
	rm..
}
#@cli rep_nearest_ratio: value_a>0,value_b>0,_maximum_proposition_number>0,output_whether_true_ratio={ 0=False | 1=True },force_proposition_number={ 0=False | True }
#@cli : Return nearest ratio from 2 different values. Proposition number is only used when force_fit_proposition_number is true.
#@cli : Note: The minimum number of arguments is 2. Maximum number of argument is 5. Defaults may change depending on the number of arguments.
rep_nearest_ratio:
size_of_vector:=max($#,3)
proposition_number:=vector(#$size_of_vector,${1--1})[2]

check "isint($1,1) &&
       isint($2,1) &&
       isint($proposition_number,0) &&
       ($#==5?isbool($-2)&&isbool($-1):
        $#==4?isbool($-1):
            1) &&
       isint($#,2,5)"

eval "
	ratio=[${1-2}];
	const proposition_number=$proposition_number;
	const force_fit_proposition_number=($1!=$2)&&($#==5?$-2:$#>2)&&(proposition_number>1);
	const final_vector_size=2+($#>3?bool($-1));

	minval=min(ratio);
	maxval=max(ratio);
	ratio_divisor=gcd(ratio);
	is_mode_force_fit=0;
	is_true_ratio=1;

	if(force_fit_proposition_number,
		if(proposition_number!=(maxval/ratio_divisor),
			is_mode_force_fit=1;
			is_true_ratio=0;
		);
	);

	is_mode_force_fit?(
		a=round(minval/maxval*proposition_number);
		ratio=ratio[0]<ratio[1]?[a,proposition_number]:[proposition_number,a];
		ratio/=gcd(ratio);
		if(!a,ratio=map(ratio,[1,proposition_number]));
	):(
		ratio/=ratio_divisor;
	);

	vector(#final_vector_size,ratio,is_true_ratio);
	"
#@cli rep_red_acrylic_filter: [source_image],_luminosity_blend_factor>=0%,_green_cut>=0%,_green_visibility>=0%
#@cli : Alter a image so that target image would be visible using a red acrylic plastic sheet as cover.
rep_red_acrylic_filter:
skip ${1=},${2=0%},${3=0%},${4=100%}

n_imgs,blend_factor,boost,green_chroma={$!},{cut($2,0,1)},{cut(abs($3),0,1)*255},{cut($4,0,1)}
import_img=${is_image_arg\ $1}

if $import_img||($n_imgs&1)

	eval "
		start_vector=[w#0,h#0,d#0];
		same_dim=1;
		repeat($n_imgs-1,p,
			q=p+1;
			if([w#q,h#q,d#q]!=start_vector,same_dim=0;break(););
		);
		same_dim;"

	eq_dims=${}

	if $import_img
		pass$1 0
	fi

	if s&1
		to_gray[-1]
	else
		to_graya[-1]
		split[-1] c
		/. 255
		*[-2,-1]
	fi

	if $!-$n_imgs>1 error inv_imp_count fi

	if $eq_dims

		target_dim={[w#0,h#0]}
		rep_aspect_crop_2d[-1] $target_dim
		resize[-1] $target_dim,100%,100%,3
		name[-1] channel

		repeat $!-1 {
			local[$>,channel] {
				if s#0&1 to_gray..
				else
					to_graya..
					split.. c
				fi

				100%,100%,100%,100%
				+negate[0] 255

				a[0,-2,-1] c
				image[0] [channel],0,0,0,1

				if $!==3 append[0,1] c fi

				shared[0] 0 shared[0] 1

				if $blend_factor
					image[-1] [-2],0,0,0,0,$blend_factor
				fi

				if $boost
					cut[-1] $boost,255
				fi

				if $green_chroma<1
					*[-1] $green_chroma
				fi

				rm[-2,-1]

			}
		}

		rm[channel]

	else

		store. channel

		foreach {

			contain_alpha=0

			target_dim={[w,h]}

			if s&1
				to_gray
			else
				to_graya
				split c
				contain_alpha=1
			fi

			$channel

			rep_aspect_crop_2d. $target_dim
			resize. $target_dim,100%,100%,3

			+negate[0] 255

			if $blend_factor
				image.. [0],0,0,0,0,$blend_factor
			fi

			if $boost
				cut.. $boost,255
			fi

			if $green_chroma<1
				mul.. $green_chroma
			fi

			if $contain_alpha
				append[0,2,3] c
			fi

			append c

		}

	fi

else

		source_pos,target_pos={[1,0]}

		repeat $!>>1 {

			contain_alpha,current_source_pos=0,$source_pos

			target_dim={[w#$target_pos,h#$target_pos]}

			if s#$source_pos&1
				to_gray[$source_pos]
			else
				to_graya[$source_pos]
				split[$source_pos] c
				/. 255
				*[$source_pos,{$source_pos+1}]
			fi

			if s#$target_pos&1
				to_gray[$target_pos]
			else
				to_graya[$target_pos]
				split[$target_pos] c
				contain_alpha,current_source_pos+=1
			fi

			rep_aspect_crop_2d[$current_source_pos] $target_dim
			resize[$current_source_pos] $target_dim,100%,100%,3

			+negate[$target_pos] 255

			if $blend_factor
				image[$current_source_pos] [$target_pos],0,0,0,0,$blend_factor
			fi

			if $boost
				cut[$current_source_pos] $boost,255
			fi

			if $green_chroma<1
				*[$current_source_pos] $green_chroma
			fi

			append[$target_pos,$current_source_pos] c
			append[$target_pos,-1] c

			if $contain_alpha
				append[$target_pos,{$target_pos+1}] c
			fi

			source_pos,target_pos+=1

		}
fi
#@cli rep_lavander_binary_map: _size_of_arr_by_power_of_two>0,_mode={ -3=xor | -2=or | -1=and | "-"=custom | 0=and | 1=or | 2=xor },_bin_a,_bin_b,_shift>0,custom_expression
#@cli : Create a texture that does the following steps:
#@cli : 1) Create an array of integer that matches index with size of 2^n.
#@cli : 2) Create another array which is the count of 'bin_a' in binary representation of the previous array.
#@cli : 3) Count sort the array of integer with the count of binary number array.
#@cli : 4) Delete all other array other than the sorted array.
#@cli : 5) Generate a surface with row and column the same size as the primary array, and use formula which takes values from the sorted value, and then find the count of 'bin_b' in binary representation of the found value.
#@cli : - Built-in Macros -
#@cli : flip(v) - Flips the bitwise values of number
#@cli : and(a,b) - a & b
#@cli : or(a,b) - a | b
#@cli : - End of Built-in Macros -
#@cli : Note : The idea comes from Lavander at discord/generative. Based on a Python code.
#@cli : Default values: '_size_of_arr_by_power_of_two=11','_mode=2','_bin_a=01','_bin_b','_shift=0',
+rep_lavander_binary_map:
skip ${1=11},${2=2},${3=01},${4=10},${5=0},${6=}

check "$1>0&&($1==int($1))&&(isint($2)||same('-','$2'))"

a6={size('$6')}
shift,length,mode:=int(abs($5)),1<<$1,v=same('-','$2');n=isint($2)?$2:0;v?0:(n>=0?n%3+1:-((abs(n)-1)%3+1))
size_of_arr={int(log2($length+$shift-1))+1}
str_code=n=init_num()
act_arr_sortclass={$mode>-1}

if !$mode&&!$a6 error custom_formula_required fi

$length,1,1,{1+$act_arr_sortclass},x
f. "begin(
		const shift_factor=$shift;
		const enable_shift_option=s==2&&shift_factor;
		const first_binary_to_search=0b$3;
		const second_binary_to_search=0b$4;
		const size_of_first_binary_to_search=size('$3');
		const size_of_second_binary_to_search=size('$4');
	);
	count=0;
	current_value=i;
	if(enable_shift_option,
		if(!c,
			current_value+=shift_factor;
		);
	);
	current_number_of_binary_digits_per_value=(current_value?int(log2(current_value)))+1;
	bit_mask=(1<<current_number_of_binary_digits_per_value)-1;
	c?(
		binary_to_search=second_binary_to_search;
		size_of_binary_to_search=size_of_second_binary_to_search;
	):(
		binary_to_search=first_binary_to_search;
		size_of_binary_to_search=size_of_first_binary_to_search;
	);
	while(current_number_of_binary_digits_per_value>=size_of_binary_to_search,
		test_section=current_value>>(current_number_of_binary_digits_per_value-size_of_binary_to_search);
		test_section==binary_to_search?(
			++count;
			bit_mask>>=size_of_binary_to_search;
			current_number_of_binary_digits_per_value-=size_of_binary_to_search;
		):(
			bit_mask>>=1;
			--current_number_of_binary_digits_per_value;
		);
		current_value&=bit_mask;
	);
	count;
	"

if $act_arr_sortclass

	if $shift
		shared. 0
		-. {im}
		rm.
	fi

	$length,1,1,1,x rv[-2,-1]

	+channels. 0 # Create copy as we will preserve the the generated output as lookup table

	# Pixel sort integer by count sort
	+histogram. 100%
	f[-1] >begin(n=0;);i?(v=n;n+=i;v;);
	f[-2] >v=i(#-1,i);++i(#-1,i);v;
	{w#-2},1,1,1
	eval[-3] i(#-1,i)=i(#-5,x);
	rm[-5,-3,-2]
	a[-2,-1] c

fi

if !$mode str_code..=ix=max_index-x;iy=max_index-y; fi

size_of_binary,binary_set_to_search:=$act_arr_sortclass?[size('$4'),0b$4]:[size('$3'),0b$3]

$length,$length,1,1,"begin(
		const shift_factor=$shift;
		const max_num_of_binary_digits = $size_of_arr;
		const max_index=w-1;
		const mode=$mode;
		const binary_set_to_search=$binary_set_to_search;
		const size_of_binary_set=$size_of_binary;
		const reference_channel=1+$act_arr_sortclass;
		const lookup_table_pos=$act_arr_sortclass;
		flip(v)=xor((1<<(int(log2(v))+1))-1,v);
		and(a,b)=a&b;
		or(a,b)=a|b;
		x()=i(#-1,x,0,0,reference_channel,2);
		y()=i(#-1,y,0,0,reference_channel,2);
		ix()=i(#-1,max_index-x,0,0,reference_channel,2);
		iy()=i(#-1,max_index-y,0,0,reference_channel,2);
		mode==3?(
			init_num()=xor(i(#-1,x,0,0,reference_channel),i(#-1,y,0,0,reference_channel));
		):
		mode==2?(
			init_num()=i(#-1,x,0,0,reference_channel)|i(#-1,y,0,0,reference_channel);
		):
		mode==1?(
			init_num()=i(#-1,x,0,0,reference_channel)&i(#-1,y,0,0,reference_channel);
		):
		mode==-1?(
			shift_factor?(
				init_num()=(x+shift_factor)&(y+shift_factor);
			):(
				init_num()=x&y;
			);
		):
		mode==-2?(
			shift_factor?(
				init_num()=(x+shift_factor)|(y+shift_factor);
			):(
				init_num()=x|y;
			);
		):
		mode==-3?(
			shift_factor?(
				init_num()=xor(x+shift_factor,y+shift_factor);
			):(
				init_num()=xor(x,y);
			);
		):(
			init_num()=int("$6");
		);
	);
	count=0;
	"$str_code";
	count=0;
	n=abs(n);
	!inrange(n,0,w,1,0)?(
		num_of_binary_digits_of_n=n?(int(log2(n))+1);
		bit_mask=(1<<num_of_binary_digits_of_n)-1;
		while(num_of_binary_digits_of_n>=size_of_binary_set,
			test_section=n>>(num_of_binary_digits_of_n-size_of_binary_set);
			test_section==binary_set_to_search?(
				++count;
				bit_mask>>=size_of_binary_set;
				num_of_binary_digits_of_n-=size_of_binary_set;
			):(
				bit_mask>>=1;
				--num_of_binary_digits_of_n;
			);
			n&=bit_mask;
		);
		count;
	):(i(#-1,n,0,0,lookup_table_pos));"

rm..

if !$act_arr_sortclass&&$shift -. {im} fi
#@cli rep_vibrance_ych: -100[%]<vibrance<=100[%]
#@cli : Increase/Decrease chroma of Image with minimal to no impact on high-chroma areas. Based on Darktable YCH "Vibrance" code.
rep_vibrance_ych:
vibrance_factor_ych={cut($1,-1,1)}

if !$vibrance_factor_ych return fi

if $vibrance_factor_ych>0
	m "cmd_$0_adj:
		f \"begin(
					const vibrance_factor="$vibrance_factor_ych";
				);
			v=vibrance_factor*(0.63235455751419067^vibrance_factor-i^vibrance_factor);
			chroma_factor=max(0,1+v);
			i*chroma_factor;
			\"
		"
else
	vibrance_factor_ych={1-abs($vibrance_factor_ych)}
	m "cmd_$0_adj: * "$vibrance_factor_ych""
fi

m "cmd_vibrance:
	f. 255*((I/255)^1.5)
	rgb2yuv.

	shared. 1,2
	f. [norm(I),atan2(i1,i0)] # Result into i0 is r and i1 is ang
	shared. 0
	cmd_$0_adj.
	rm.
	f. [i0*cos(i1),i0*sin(i1)] # Utilize the fact that i0 is r and i1 is ang
	rm.

	yuv2rgb.
	f. 255*((I/255)^0.66666666666666666)
	"

remove_shared=0
foreach {
	if inrange(s,3,4,1,1)
		if s==4
			shared. 0,2
			remove_shared=1
		fi
		cmd_vibrance.
		if $remove_shared
			remove.
			remove_shared=0
		fi
	fi
}

uncommand cmd_vibrance,cmd_$0_adj
#@cli rep_import_pal: file_a...file_z
#@cli : Import JASC-PAL Palette or Microsoft RIFF Palettes (.pal). What is imported is automatically based on header
#@cli : There can be as many files. This import file relative to your current directory.
+rep_import_pal:
check $#

old_status=${}

$=files

space,sep,newline,RIFF_pal_header_size:='\ ^\n',24
CRLF:=0xd,$newline

repeat $#
{
	0 => ${files{$>+1}}
	file_name={b}

	l[-1]
	{
		rm.
		ib ${file_name}
		onfail
			ib ${file_name}.pal
	}

	__$0_process_file[-1]
}

status $old_status
__rep_import_pal_process_file:
name_of_file={n}

if same(crop(#-1,0,0,0,0,1,8,1,1),'JASC-PAL')

	if same(crop(#-1,0,8,0,0,1,2,1,1),[$CRLF])
		split_parts=$CRLF
	else
		split_parts=$newline
	fi

	split -,$split_parts
	count_of_colors={2,t}
	images_indices_contains_colors=3-{2+$count_of_colors}
	count_of_channels=0

	foreach[$images_indices_contains_colors] {
		replace $space,$sep

		({t})

		rm..

		if $count_of_channels?s!=$count_of_channels
			error invalid_pal_file
		elif !$count_of_channels
			count_of_channels:=s#-1
		fi
	}

	k[$images_indices_contains_colors]
	a x
elif same(crop(#-1,0,0,0,0,1,4,1,1),'RIFF')
	crop 0,$RIFF_pal_header_size,0,{"
		pos=h#-1-4;
		empty_vector=crop(#-1,0,pos,0,0,1,4,1,1);
		pos-=4;
		while(pos>$RIFF_pal_header_size,
			if(crop(#-1,0,pos,0,0,1,4,1,1)!=empty_vector,
				break();
			);
			pos-=4;
		);
		pos+3;
		"}
	resize 4,{h>>2},1,1,-1
	crop 0,2
	permute yzcx
else
	invalid_pal_file
fi

name[-1] $name_of_file
#@cli rep_import_pdn_txt: file_a...file_z...,_discard_alpha={ 0=keep | 1=discard_alpha | 2=auto }
#@cli : Import PDN Palette (.txt)
#@cli : There can be as many files. This import file relative to your current directory.
#@cli : Default values: '_discard_alpha=2'
+rep_import_pdn_txt:
check $#

if narg($-1)&&$#>1&&isint($-1)
	alpha_mode={$-1%3}
	num_of_args:=$#-1
else
	alpha_mode=2
	num_of_args=$#
fi

max_spec={$alpha_mode==1?3:4}

newline,commentary:='\n;'

$=files

repeat $num_of_args
{
	0 => ${files{$>+1}}
	file_name={b}

	l[-1]
	{
		rm.
		it ${file_name}
		onfail
			it ${file_name}.txt
	}

	__$0_process_file[-1]
}
__rep_import_pdn_txt_process_file:
name_of_file={n}
0x512

96,1,1,$max_spec

eval "
	const commentary=$commentary;
	const new_line=$newline;
	const alpha_mode=$alpha_mode;
	const seed="{v(0x1234,0xabcd)}";
	const bit_mask=511;

	sizes=vector(#512);

	is_hex_character(character)=
		isint(character,_'0',_'9')||
		isint(character,_'a',_'f')||
		isint(character,_'A',_'F');

	alpha_mode==1?(
		const S=3;
		generate_color(pos)=(
			if(!s2v([('0x'),crop(#0,0,pos,0,0,1,2,1,1)]),break(););
			current_color=s2v([('0x'),crop(#0,0,pos+2,0,0,1,6,1,1)])>>[16,8,0]&0xff;
		);
		process_hex(pos)=generate_color(pos);
		last_color=vector(#3,nan);
		insert_color()=current_color;
		0;
	):(
		const S=4;
		generate_color(pos)=current_color=s2v([('0x'),crop(#0,0,pos,0,0,1,8,1,1)])>>[24,16,8,0]&0xff;
		alpha_mode?(
			contain_alpha=0;
			process_hex(pos)=(
				current_color=generate_color(pos);
				if(!current_color[0],break(););
				if(!contain_alpha,
					if(current_color[0]!=255,
						contain_alpha=1;
					);
				);
			);
		):(
			process_hex(pos)=(generate_color(pos);if(!current_color[0],break();););
		);
		last_color=vector(#4,nan);
		insert_color()=[current_color[1,3],current_color[0]];
		0;
	);

	p=number_of_colors=0;
	while((p=find(#0,new_line,p,1)+1)&&number_of_colors<96,
		current_char=i[#0,p];
		while(current_char!=new_line&&p<h#0,
			if(current_char==commentary,
				++p;
				break();
			);

			if(is_hex_character(current_char),
				process_hex(p);
				hash_value=0;
				repeat(S,q,
					hash_value=xor(((hash_value<<1)-hash_value)*seed,current_color[q]);
					hash_value&=bit_mask;
				);
				bucket_size_ind=hash_value;
				dictionary_index=bucket_size_ind+1;
				H=sizes[bucket_size_ind];
				!(H?(same(current_color,last_color)?1:find(#dictionary_index,current_color,(H-1)*S,-S)+1))?(
					if(H==h(#dictionary_index),
						new_size=max(8,h(#dictionary_index)<<1);
						resize(#dictionary_index,S,new_size,1,1,-1);
					);
					copy(i(#dictionary_index,0,H,0,0),current_color);
					I[#-1,number_of_colors++]=insert_color();
					++sizes[bucket_size_ind];
				);
				last_color=current_color;
				p+=8;
				break();
			);

			current_char=i[#0,++p];
		);
	);

	if(alpha_mode==2,
		set('contain_alpha',contain_alpha);
	);

	set('number_of_colors',number_of_colors);"

k[-1] => $name_of_file

if $alpha_mode==2&&!$contain_alpha
	resize[-1] $number_of_colors,1,1,3,0
else
	crop[-1] 0,{$number_of_colors-1}
fi
#@cli rep_correct_exp_ne: string
#@cli : Return corrected file name for exporting files.
#@cli : Note: Every single arguments applied to this command counts as a single string.
rep_correct_exp_ne:
('{``"$*"}':;) ({h}) a[-2,-1] y

eval "
	if(da_size(#-1)>=0x100,run('error \"Length exceeds maximum allowed (256 characters)\"'););

	for(p=da_size(#-1)-1,p>=-1,--p,
		char=i[#-1,p];
		if(isin(i[#-1,p],"{'\"#<>:/?*"\\"'}"),da_remove(#-1,p););
		if(same(char,_'~'),i[#-1,p]=_'-';);
		if(same(char,_'.'),i[#-1,p]=_'_';);
	);

	first_three_chars=uppercase(crop(#-1,0,0,0,0,1,3,1,1));
	fs=da_size(#-1);

	(
	 fs==3?(isin(first_three_chars,'AUX','CON','NUL','PRN') ):
     fs==4?(isin(first_three_chars,'COM','LPT') && inrange(i[#-1,3],_'0',_'9',1,1) );
	) ? run('error \"Cannot use Windows reserved filename.\"');

	da_freeze(#-1);"

u {t} rm.

if '$_host'=='cli'
	name_a:='"$*"'
	name_b:='"{t}"'
	if !same([$name_a],[$name_b])
		v + e[2] "File Name Changed!" v -
	fi
fi
#@cli rep_find_factors_of: num_0...
#@cli : Return the factors found in all numbers at once.
#@cli :
#@cli : Author : Reptorian.
#@cli : $ echo ${rep_find_factors_of\ 256}
#@cli : $ echo ${rep_find_factors_of\ 256,100}
#@cli : $ echo ${rep_find_factors_of\ 256,100,50}
rep_find_factors_of:
check "sum(inrange([$*],0,5000000000000000,0,1))==$# && sum(isint([$*]))==$# "

v:=$#>1?gcd($*):$1

if $v==1 u $v return fi

1,1,1,3 # Prime Value, Base, Error

eval "
	start_v=v=$v;
	square=int(sqrt(v));

	for(n=2,n<=square&&n<=v,++n,

		isPrime=1;

		for(p=0,p<da_size(#-1),++p,

			prime=(I[#-1,p])[0]-(I[#-1,p])[2];

			if(sqr(prime)>n,
				break();
			);

			if(!(n%prime),
				isPrime=0;
				break();
			);

		);

		if(isPrime,

			count=0;

			while(!(v%n),
					++count;
					v/=n;
			);

			if(count,
				da_push(#-1,[n,count,0]);
				diff=(da_back(#-1))[0]-n;
				if(diff,I[#-1,da_size(#-1)-1]=[n,count,diff]);
				square=int(sqrt(v));
			);

		);

	);

	if(v!=1,
		da_push(#-1,[v,1,0]);
		diff=(da_back(#-1))[0]-v;
		if(diff,I[#-1,da_size(#-1)-1]=[v,1,diff]);
	);

	output=da_size(#-1)==1&&v==start_v?v:0;
	da_freeze(#-1);

	if(output,
		set('pv',v);
	);

	output;
	"

if ${}
	remove.
	status 1,$pv
else
	{prod(crop(0,0,0,1,1,h,1,1)+1)},1,1,1,"begin(
			const num_of_primes=h#-1;
			primes_freq_choices=crop(#-1,0,0,0,1,1,num_of_primes,1,1)+1;
			primes_list=crop(#-1,0,0,0,0,1,num_of_primes,1,1)-crop(#-1,0,0,0,2,1,num_of_primes,1,1);
			modulo_list=vector(#num_of_primes,0);
			modulo_list[0]=tv=1;
			repeat(num_of_primes-1,p,
				tv*=primes_freq_choices[p];
				modulo_list[p+1]=tv;
			);
			prod_ref_values=vector(#num_of_primes,1);
			max_prod_ref_values=primes_list^(primes_freq_choices-1);
			factors=vector(#w,0);
			started=0;
		);
		started?(
			p=0;
			while(prod_ref_values[p]==max_prod_ref_values[p],
				prod_ref_values[p++]=1;
			);
			prod_ref_values[p]*=primes_list[p];
		):(
			x?(
				prod_ref_values=primes_list^(int(x/modulo_list)%primes_freq_choices);
			);
			started=1;
		);
		factors[x]=prod(prod_ref_values);
		end(
			merge(factors,+);
			set('{}',v2s(sort(factors)));
		);"
	remove[-2,-1]
fi
rep_sercirc: rep_serendipitous_circle $*
#@cli rep_serendipitous_circle: points>1,num_of_repeats>1,_muldiv_coeff_a,_muldiv_coeff_b,_muldiv_oper_a={ 0=mul | 1=div},muldiv_oper_b={ 0=mul | 1=mul},use_old_x={ 0=false | 1=true },_sublevel>=0,_seed,auto_norm,_sym_mode={0=mode_0 | 1=mode_1}
#@cli : Generates Circle Fractal. Serendipitous Circle was originally written in 6800 assembly by William F. Galway in December 1976.
#@cli : Note: The output of this command is 2 channel. The first channel is value from the Serendipitous Circle, and the second channel is the alpha value ranging from 0-1.
#@cli : Default values: '_sublevel=0','_seed=n/a'
rep_serendipitous_circle:
skip ${3=2},${4=2},${5=1},${6=1},${7=0},${8=0},${9=},${10=0},${11=1}

pts,num_of_repeats,muldiv_coeff_a,muldiv_coeff_b,muldiv_oper_a,muldiv_oper_b,use_old_x,sublevel,seed,auto_norm,sym_mode=${1-4},{$5%2},{$6%2},{$7%2},{abs($8)+1},$9,{int(abs($10))},{($11%2)*3}

command "rep_sercirc_autonorm: auto_norm=$""1 +erode. $auto_norm +dilate.. $auto_norm cut[-3] {iM#-2},{im#-1} rm[-2,-1]"

pts*=$sublevel

if $muldiv_coeff_a!=0

	if $muldiv_oper_a

		if $muldiv_coeff_a<0
			calc_xn_part=+yi/{abs($muldiv_coeff_a)}
		else
			calc_xn_part=-yi/$muldiv_coeff_a
		fi

	else

		if $muldiv_coeff_a<0
			calc_xn_part=+yi*{abs($muldiv_coeff_a)}
		else
			calc_xn_part=-yi*$muldiv_coeff_a
		fi

	fi

else

	if ('$muldiv_coeff_a')[0]==45
		calc_xn_part=+yi
	else
		calc_xn_part=-yi
	fi

fi

if $use_old_x
	old_x_expr=xo=xi;
	yn_part=xo
else
	yn_part=xn
fi

if $muldiv_coeff_b!=0

	if $muldiv_oper_b

		if $muldiv_coeff_b<0
			calc_yn_part=-$yn_part/{abs($muldiv_coeff_b)}
		else
			calc_yn_part=+$yn_part/$muldiv_coeff_b
		fi

	else

		if $muldiv_coeff_b<0
			calc_yn_part=-$yn_part*{abs($muldiv_coeff_b)}
		else
			calc_yn_part=+$yn_part*$muldiv_coeff_b
		fi

	fi

else

	if ('$muldiv_coeff_b')[0]==45
		calc_yn_part=-$yn_part
	else
		calc_yn_part=+$yn_part
	fi

fi

{ceil((w+1)/2)*$sublevel},{ceil((h+1)/2)*$sublevel},1,2 rm..

ratio={max(w,h)/min(w,h)}

$pts,1,1,1,:"begin_t(
		if(narg($seed),srand($seed+t););
		const ratio=$ratio;
		const sqr_ratio=sqr(ratio);
		const inv_ratio=1/ratio;
		const max_dimension=max(w#-1,h#-1)*ratio;
	);
	point=[v(0,max_dimension,1,0),v(0,max_dimension,1,0)];
	xi=point[0];
	yi=point[1];
	repeat($num_of_repeats,
		i(#-1,int(xi/sqr_ratio),int(yi/sqr_ratio),0,0)++;
		i(#-1,int(xi/sqr_ratio),int(yi/sqr_ratio),0,1)=1;
		"$old_x_expr"
		xn=(xi"$calc_xn_part")%max_dimension;
		yn=(yi"$calc_yn_part")%max_dimension;
		xi=xn;
		yi=yn;
	);"

rm. s. c

r.. {ceil(w/$sublevel)},{ceil(h/$sublevel)},1,1,2
r. {w#-2},{h#-2},1,1,5
f.. i/(i#-1?i#-1:1)

if $auto_norm
	rep_sercirc_autonorm.. $auto_norm
fi

a[-2,-1] c

rep_symmetrize_xy. $sym_mode
#@cli rep_mitchell_concatenation: startnum_a,startnum_b,_base,_base_2,_method_a={ 0=sub | 1=add | 2=mul},_method_b={ 0=sub | 1=add | 2=mul},_pixel_size,[palette],[palette],_auto_resize_pal,_shape_id,_shape_ratio,_shape_angle,shape_dir,shape_repeat_mode,shape_fit,_shape_sub,_shape_option_1..._shape_option_n
#@cli : Generates Kerry Mitchell Concatenation Art. Detailed explanation can be found at - http://www.kerrymitchell.art/spacefilling-blog/2013/11/concatenations.html
#@cli : Default values: '_int_base=10','_method_a=0','_method_b=1','_palette=n/a','hex_bg_col=n/a','_shape=n/a'
rep_mitchell_concatenation:
skip ${1=},${2=},${3=},${4=},${5=},${6=},${7=1},${8=},${9=},${10=1},${11=},${12=1},${13=0},${14=0},${15=0},${16=1},${17=1},${18=}

if narg($1)&&narg($2)
 startnum_a,startnum_b={max(1,int(abs($1)))},{max(1,int(abs($2)))}
elif narg($1)||narg($2)

 if narg($1)
  startnum_a,startnum_b={max(1,int(abs($1)))},{max(1,int(abs($1)))}
 else
  startnum_a,startnum_b={max(1,int(abs($2)))},{max(1,int(abs($2)))}
 fi

else
 startnum_a,startnum_b=1,1
fi

if narg($3)&&narg($4)
 base_a,base_b={max(2,int(abs($3)))},{max(2,int(abs($4)))}
elif narg($3)||narg($4)
 if narg($3)
  base_a,base_b={max(2,int(abs($3)))}
 else
  base_b,base_b={max(2,int(abs($4)))}
 fi
else base_a,base_b=10 fi

if narg($5)&&narg($6)
 method_a,method_b={abs(int($5))},{abs(int($6))}
elif narg($5)||narg($6)
 if narg($5)
  method_a,method_b={abs(int($5))}
 else
  method_a,method_b={abs(int($6))}
 fi
else method_a,method_b=1,1 fi

startnum_diff,base_diff,method_diff,shape_size={$startnum_a!=$startnum_b},{$base_a!=$base_b},{$method_a!=$method_b},{max(1,int(abs($7)))}

use_shape,double_concatenation_mode,use_different_dimensions,num_of_images={narg($11)?($shape_size>=4?1:0):0},{$startnum_diff||$base_diff||$method_diff},{$!>1?(use_diff=0;start_dim=[w#0,h#0];repeat($!-1,p,q=p+1;if([w#q,h#q]!=start_dim,use_diff=1;break();););use_diff;):0},{$!}

if $use_different_dimensions
 dim_list=[{expr('p=int(x/2);x%2?ceil(h#p/$shape_size)*$shape_size:ceil(w#p/$shape_size)*$shape_size',$!*2,1,1,1)}]
fi

width,height=${-max_w},${-max_h}
rm

{ceil($width/$shape_size)},{ceil($height/$shape_size)},1,2,vector(#2,-1)

if $use_shape

 ratio:=cut(abs($12),0,1)

 if $ratio

  shape_ang,mirror,tile_boundary,fit_size=$13,{$14%3},{$15%4},$17

  if ${is_image_arg\ $11}

   pass$11 0

   if s<=4&&s>1
    if s==3 to_gray.
    else
     s. c,{arg1(int(s/2,-3,-1)}
    fi
   elif s==5
    s. c,-4 cmyk2rgb.. to_gray.. *[-2,-1]
   elif s>5 error inv_chans_count
   fi

  else

   shape_sub:=abs($16)+1
   sid="$11"

   if isnum($11) if isint($11)
    sid=${"-arg0 "$sid"","australia,barbedwire,circle,crosshair,cupid,diamond,dragon,dragonfly,fern,flip,gear,gumleaf,heart,information,kookaburra,mail,mapleleaf,paint_splat,paw,phone,polygon,rooster,shopping_cart,snowflake,star"}
   fi fi

   if $#>17 shape_$sid {$shape_size*$shape_sub},${18--1}
   else shape_$sid {$shape_size*$shape_sub}
   fi

   r. {ceil(w/$shape_size)*$shape_size},{ceil(h/$shape_size)*$shape_size},100%,100%,0,0,.5,.5

  fi

  if $shape_ang-360*floor($shape_ang/360) rotate. $shape_ang fi

  if $mirror==1 mirror. x
  elif $mirror==2 mirror. y
  fi

  n. 0,1 autocrop. 0

  shape_dimensions_length={round($shape_size*$ratio)}

  if $fit_size
   rs. $shape_dimensions_length,$shape_dimensions_length,5
  else
   resize. $shape_dimensions_length,$shape_dimensions_length,100%,100%,5
  fi

  resize. $shape_size,$shape_size,100%,100%,0,0,.5,.5

  cut. 0,1 n. 0,1

  avgc={ia#-1}

  if $tile_boundary
   if $tile_boundary==1
    +mirror. x
    a[-2,-1] z
   elif $tile_boundary==2
    +mirror. y
    a[-2,-1] z
   else
    +mirror. x
    +mirror.. y
    +mirror. x
    a[-4--1] z
   fi
  fi

  store. shape

 fi

fi

# End of Initialization

if $double_concatenation_mode

 if $base_b!=10 rep_concat_conset_fill_alt_base $startnum_b,$base_b
 else rep_concat_conset_fill $startnum_b
 fi

 if $base_a!=10 +rep_concat_conset_fill_alt_base. $startnum_a,$base_a
 else +rep_concat_conset_fill $startnum_a
 fi

 out_method_a=${arg0\ $method_a,sub_concat_conset,add_concat_conset,mul_concat_conset}
 out_method_b=${arg0\ $method_b,sub_concat_conset,add_concat_conset,mul_concat_conset}

 rep_index_based_$out_method_a[-2] $startnum_a,$base_a
 rep_index_based_$out_method_b[-1] $startnum_b,$base_b

 a[-2,-1] z

 if ${is_image_arg\ $8}
  pass$8 0
  if h#-1>1||d#-1>1
   num_of_chans={s#-1}
   permute. cxyz
   unroll. x
   {w#-1/$num_of_chans},1,1,$num_of_chans,crop(#-1,x*$num_of_chans,0,0,0,$num_of_chans,1,1,1)
   rm..
  elif w#-1==1 error inv_dims
  fi
  if $10 r. $base_a,1,1,100%,5 fi
 fi

 if ${is_image_arg\ $9}
  pass$9 0

  if h#-1>1||d#-1>1
   num_of_chans={s#-1}
   permute. cxyz
   unroll. x
   {w#-1/$num_of_chans},1,1,$num_of_chans,crop(#-1,x*$num_of_chans,0,0,0,$num_of_chans,1,1,1)
   rm..
  elif w#-1==1 error inv_dims
  fi

  if $10 r. $base_b,1,1,100%,5 fi
 fi

 if $use_shape

  $shape

  {w#0*$shape_size},{h#0*$shape_size},1,{s#-2+1}

  img_count={$!}

  {w#0},{h#0},1,1,:"begin(
    const shape_size=$shape_size;
    const tile_boundary=$tile_boundary;
    const num_chan=s#1;
    const tchan=num_chan+1;
    const alpha_size=sqr(shape_size);
    const tile_size=alpha_size*num_chan;
    empty_vec=[-1,-1];
    filled_alpha=vector(#alpha_size,255);
    find_tile_mode()=(sv[0]>-1)&&(sv[1]>-1);
    $img_count==5?(
     generate_color_a()=I(#1,i(#0,x,y,0,0),0,0,0,2);
     generate_color_b()=I(#2,i(#0,x,y,1,0),0,0,0,2);
    ):
    $img_count==4?(
     generate_color_a()=I(#1,i(#0,x,y,0,0),0,0,0,2);
     generate_color_b()=I(#1,i(#0,x,y,1,0),0,0,0,2);
    ):(
     generate_color_a()=[sv[0]];
     generate_color_b()=[sv[1]];
    );
    tile_boundary==3?(

     shape_0=crop(#-2,0,0,0,0,shape_size,shape_size,1,1);
     shape_1=crop(#-2,0,0,1,0,shape_size,shape_size,1,1);
     shape_2=crop(#-2,0,0,2,0,shape_size,shape_size,1,1);
     shape_3=crop(#-2,0,0,3,0,shape_size,shape_size,1,1);
     tile_v0=resize(shape_0,tile_size,0,2);
     tile_v1=resize(shape_1,tile_size,0,2);
     tile_v2=resize(shape_2,tile_size,0,2);
     tile_v3=resize(shape_3,tile_size,0,2);

     const mx=w-1;
     const my=h-1;
     const startnum=$startnum_a;
     find_pos()=1+sum((mx-x)%2,2*((my-y+startnum)%2));

     generate_tile_b()=(
      shape_tile=arg1(find_pos(),tile_v0,tile_v1,tile_v2,tile_v3);
      color_tile=vc_0+vc_1*shape_tile;
      tile=[color_tile,filled_alpha];
      draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
     );

     generate_tile_a()=(
      shape_alp=arg1(find_pos(),shape_0,shape_1,shape_2,shape_3);
      sv[0]>=0?(
       color=generate_color_a();
       color_tile=resize(color,tile_size,1,0);
       tile=[color_tile,shape_alp*255];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      ):(
       color=generate_color_b();
       color_tile=resize(color,tile_size,1,0);
       tile=[color_tile,(1-shape_alp)*255];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      );
     );

    ):
    tile_boundary?(
     shape_0=crop(#-2,0,0,0,0,shape_size,shape_size,1,1);
     shape_1=crop(#-2,0,0,1,0,shape_size,shape_size,1,1);
     tile_v0=resize(shape_0,tile_size,0,2);
     tile_v1=resize(shape_1,tile_size,0,2);

     const max_index=(tile_boundary%2)?w-1:h-1;

     tile_boundary%2?(
      find_pos()=(max_index-x)%2;
     ):(
      const startnum=$startnum_a;
      find_pos()=(max_index-y+startnum)%2;
     );

     generate_tile_b()=(
      shape_tile=find_pos()?tile_v1:tile_v0;
      color_tile=vc_0+vc_1*shape_tile;
      tile=[color_tile,filled_alpha];
      draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
     );

     generate_tile_a()=(
      shape_alp=find_pos()?shape_1:shape_0;
      sv[0]>=0?(
       color=generate_color_a();
       color_tile=resize(color,tile_size,1,0);
       tile=[color_tile,shape_alp*255];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      ):(
       color=generate_color_b();
       color_tile=resize(color,tile_size,1,0);
       tile=[color_tile,(1-shape_alp)*255];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      );
     );

    ):(
     shape_alp=crop(#-2,0,0,0,0,shape_size,shape_size,1,1);
     alp_tile=resize(shape_alp,tile_size,0,2);
     generate_tile_b()=(
      color_tile=vc_0+vc_1*alp_tile;
      tile=[color_tile,filled_alpha];
      draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
     );
     generate_tile_a()=(
      sv[0]>=0?(
       color=generate_color_a();
       color_tile=resize(color,tile_size,1,0);
       tile=[color_tile,shape_alp*255];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      ):(
       color=generate_color_b();
       color_tile=resize(color,tile_size,1,0);
       tile=[color_tile,(1-shape_alp)*255];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      );
     );
    );
   );
   sv=[i(#0,x,y,0,0),i(#0,x,y,1,0)];
   if(sv!=empty_vec,
    find_tile_mode()?(
     c0=generate_color_b();
     c1=generate_color_a();
     diff=c1-c0;
     vc_0=resize(c0,tile_size,1,0);
     vc_1=resize(diff,tile_size,1,0);
     generate_tile_b();
    ):(
     generate_tile_a();
    );
   );
   "
  k..

  if $num_of_images>1
   r. 100%,100%,$num_of_digits,100%,1
  fi

  if $num_of_images>1 s. z fi

  if $use_different_dimensions
   repeat $num_of_images {
    new_width_height:=($dim_list)[$>*2,2]
    r[$>] $new_width_height,1,100%,0,0,1,1
   }
  fi

 else

  if $!==2
   {w#-2},{h#-2},2,{s#-1+1},"v=i(#-2,x,y,z,0);
    v>=0?[I(#-1,v,0,0,2,1),255]:vector(#s,0);"
    rm[-3,-2]
  elif $!==3
   {w#-3},{h#-3},2,{s#-1+1},"v=i(#-3,x,y,z,0);
    z?(v>=0?[I(#-2,v,0,0,2,1),255]:vector(#s,0);):
    (v>=0?[I(#-1,v,0,0,2,1),255]:vector(#s,0););"
    rm[0,-3,-2]
    display
  elif $!>3 error only_one_pal
  fi

  if ($shape_size>1)||($num_of_images>1)
   r. {w#-1*$shape_size},{h#-1*$shape_size},{2*$num_of_images},100%,1
  fi

  if $num_of_images s. z,-2 fi

  if $use_different_dimensions
   repeat $num_of_images {
    new_width_height:=($dim_list)[$>*2,2]
    r[$>] $new_width_height,2,100%,0,0,1,1
   }
  fi

 fi

else

 if $base_a!=10 rep_concat_conset_fill_alt_base $startnum_a,$base_a
 else rep_concat_conset_fill $startnum_a
 fi

 out_method=${arg0\ $method_a,sub_concat_conset,add_concat_conset,mul_concat_conset}

 rep_index_based_$out_method $startnum_a,$base_a

 if ${is_image_arg\ $8}

  pass$8 0

  if h#-1>1||d#-1>1
   num_of_chans={s#-1}
   permute. cxyz
   unroll. x
   {w#-1/$num_of_chans},1,1,$num_of_chans,crop(#-1,x*$num_of_chans,0,0,0,$num_of_chans,1,1,1)
   rm..
  elif w#-1==1 error inv_dims
  fi

  if $10 r. $base_a,1,1,100%,5 fi
 fi

 if ${is_image_arg\ $9}

  pass$9 0

  if h#-1>1||d#-1>1
   num_of_chans={s#-1}
   permute. cxyz
   unroll. x
   {w#-1/$num_of_chans},1,1,$num_of_chans,crop(#-1,x*$num_of_chans,0,0,0,$num_of_chans,1,1,1)
   rm..
  elif w#-1==1 error inv_dims
  fi

  if $10 r. $base_a,1,1,100%,5 fi
 fi

 if $use_shape

  $shape

  if $!>3 error only_one_pal
  else

   {w#0*$shape_size},{h#0*$shape_size},1,{s#-2+1}

   img_count={$!}

   eval[0] :"begin(
     const shape_size=$shape_size;
     const tile_boundary=$tile_boundary;
     const num_chan=s#1;
     const tchan=num_chan+1;
     const tile_size=sqr(shape_size)*num_chan;
     $img_count==4?(
      generate_color()=I(#-3,i,0,0,0,2);
     ):(
      generate_color()=[i];
     );
     tile_boundary==3?(
      alpha_0=crop(#-2,0,0,0,0,shape_size,shape_size,1,1)*255;
      alpha_1=crop(#-2,0,0,1,0,shape_size,shape_size,1,1)*255;
      alpha_2=crop(#-2,0,0,2,0,shape_size,shape_size,1,1)*255;
      alpha_3=crop(#-2,0,0,3,0,shape_size,shape_size,1,1)*255;
      const mx=w-1;
      const my=h-1;
      const startnum=$startnum_a;
      find_pos()=1+sum((mx-x)%2,2*((my-y+startnum)%2));
      generate_tile()=(
       alpha=arg1(find_pos(),alpha_0,alpha_1,alpha_2,alpha_3);
       color=generate_color();
       color_tile=resize(color,tile_size,1);
       tile=[color_tile,alpha];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      );
     ):
     tile_boundary?(
      alpha_0=crop(#-2,0,0,0,0,shape_size,shape_size,1,1)*255;
      alpha_1=crop(#-2,0,0,1,0,shape_size,shape_size,1,1)*255;
      const max_index=(tile_boundary%2)?w-1:h-1;
      tile_boundary%2?(
       find_pos()=(max_index-x)%2;
      ):(
       const startnum=$startnum_a;
       find_pos()=(max_index-y+startnum)%2;
      );
      generate_tile()=(
       alpha=find_pos()?alpha_1:alpha_0;
       color=generate_color();
       color_tile=resize(color,tile_size,1);
       tile=[color_tile,alpha];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      );
     ):(
      alpha=crop(#-2,0,0,0,0,shape_size,shape_size,1,1)*255;
      generate_tile()=(
       color=generate_color();
       color_tile=resize(color,tile_size,1);
       tile=[color_tile,alpha];
       draw(#-1,tile,x*shape_size,y*shape_size,0,0,shape_size,shape_size,1,tchan);
      );
     );
    );
    if(i>=0,generate_tile(););"

  fi
  k.

 else

  if $!==2

   {w#-2},{h#-2},1,{s#-1+1},"v=i(#-2,x,y,z,0);
    v>=0?[I(#-1,v,0,0,2,1),255]:vector(#s,0);"

   rm[-3,-2]
  elif $!>2 error only_one_pal
  fi

  if ($shape_size>1)||($num_of_images>1)
   r. {w#-1*$shape_size},{h#-1*$shape_size},$num_of_images,100%,1
  fi

 fi

 if $num_of_images>1 s. z fi

 if $use_different_dimensions
  repeat $num_of_images {
   new_width_height:=($dim_list)[$>*2,2]
   r[$>] $new_width_height,1,100%,0,0,1,1
  }
 fi

fi
rep_index_based_mul_concat_conset:
skip ${2=10}

+channels 0

1,{h},1,1,:"begin(
  const length=w#-1;
  const hh=h#-1-1;
  const startnum=int(abs($1));
  const start_x=length-1;
  const start_pos=start_x-1;
  const log_base=log(base);
  const base=int(abs($2));
  logb(n)=log(n)/log(base);
  concat_consec_digits_count(n)=n>=base?(t=floor(logb(n));n+(n+1)*t+(base*(1-base^t))/(base-1)):n;
 );

 N=hh-y+startnum;
 num_of_digits=concat_consec_digits_count(N);
 tx=max(0,length-num_of_digits);

 for(p=start_pos,p>=tx,--p,

  multiplier=i(#-2,p,y,0,1);
  off=0;
  carry_over=0;
  secondary_carry_over=0;

  multiplier?(
   for(q=start_x,q>=tx,--q,
    partial_result=multiplier*i(#-2,q,y,0,0)+carry_over;
    remainder=partial_result%base;
    carry_over=int(partial_result/base);
    new_num=max(0,i(#-1,p-off,y,0,0))+remainder+secondary_carry_over;
    secondary_remainder=new_num%base;
    secondary_carry_over=int(new_num/base);
    i(#-1,p-off,y,0,0)=secondary_remainder;
    ++off;
    if((p-off)<0,continue(););
   );
  ):(continue(););

  if(secondary_carry_over&&(q!=0),
   new_num=max(0,i(#-1,p-off,y,0,0))+secondary_remainder+secondary_carry_over;
   secondary_carry_over=int(new_num/base);
   secondary_remainder=new_num%base;
   i(#-1,p-off,y,0,0)=secondary_remainder;
  );

  if(p==tx&&(partial_result>base)&&(tx!=0),i(#-1,p-off,y,0,0)=int(partial_result/base););

 );"
rm[-3,-1]
rep_index_based_sub_concat_conset:
skip ${2=10}

{w},{h},1,1,-1

1,{h},1,1,:"begin(
  const length=w#-1;
  const hh=h#-1-1;
  const startnum=int(abs($1));
  const start_x=length-1;
  const base=int(abs($2));
  logb(n)=log(n)/log(base);
  concat_consec_digits_count(n)=n>=base?(t=floor(logb(n));n+(n+1)*t+(base*(1-base^t))/(base-1)):n;
  zero_fill=vector(#length,0);
 );
 N=hh-y+startnum;
 num_of_digits=concat_consec_digits_count(N);
 tx=max(0,length-num_of_digits);
 minuend=-1;
 if(num_of_digits>1,
  ux=tx;
  repeat(length,
   vd=I(#-2,ux,y);
   if(vd[1]>vd[0],minuend=1;break(););
   if(vd[0]>vd[1],minuend=0;break(););
   ++ux;
  );
  if(minuend!=-1,

   subtrahend=1-minuend;
   ix=start_x;

   repeat(num_of_digits,

    vd=I(#-2,ix,y);
    if(ix==tx,if(vd[minuend]==vd[subtrahend],break();););

    if(vd[minuend]<vd[subtrahend],
     vd[minuend]+=base;
     sx=ix;
     repeat(inf,
      --sx;
      if(sx<=tx,break(););
      if(i(#-2,sx,y,0,minuend),(i(#-2,sx,y,0,minuend)--;break();),i(#-2,sx,y,0,minuend)=base-1;);
     );
    );

    i(#-1,ix,y,0,0)=vd[minuend]-vd[subtrahend];

    --ix;
   );
  ,draw(#-1,zero_fill,0,y,0,0,length,1,1,1);0;
  );
 ,i(#-1,start_x,y,0,0)=0;
 );"

rm[-1,-3]
rep_index_based_add_concat_conset:
skip ${2=10}

{w},{h},1,1,-1

1,{h},1,1,:"begin(
  const length=w#-1;
  const hh=h#-1-1;
  const start_x=length-1;
  const startnum=int(abs($1));
  const base=int(abs($2));
  const s_size=s#-2;
  const ds_size=s_size-1;
  vz=vector(#s_size,0);
  logb(n)=log(n)/log(base);
  concat_consec_digits_count(n)=n>=base?(t=floor(logb(n));n+(n+1)*t+(base*(1-base^t))/(base-1)):n;
 );
 ix=start_x;
 carry_over=0;
 loop_break=0;
 N=hh-y+startnum;
 num_of_digits=concat_consec_digits_count(N);
 tx=max(0,length-num_of_digits);

 repeat(min(length,num_of_digits+ds_size),

  init_num_vec=I(#-2,ix,y);

  if(ix<tx,
   repeat(s_size,p,
    if(init_num_vec[p]<0,loop_break=1;break(););
    );
   if(!carry_over&&loop_break,break(););
  );

  num=sum(vmax(init_num_vec,vz))+carry_over;
  carry_over=int(num/base);

  i(#-1,ix,y)=num%base;
  if(loop_break,break(););

  --ix;
 );"

rm[-3,-1]
rep_concat_conset_fill:

check $!==1

startnum={max(abs($1),1)}
maxnum_a,maxnum_b,string_a,string_b=$startnum,{$startnum+(h-1)},"",""

repeat inf {
 string_a.=$maxnum_a
 maxnum_a-=1
 if $maxnum_a==1||size('$string_a')>=w#0
  startnum,string_a={max($maxnum_a,1)},""
  break
 fi
}

repeat inf {
 string_a..=$maxnum_b
 ({size('$maxnum_b')})
 if $> a[-2,-1] x fi
 maxnum_b-=1
 if $maxnum_b<$startnum break fi
}

ts,digits={is#-1},0

repeat inf {
 string_b..={$>+1}
 digits+={size('{$>+1}')}
 if $digits>=$ts||$digits>w#0 break fi
}

('$string_a') ('$string_b') -[-2,-1] 48

repeat h#0 {

 ns={w#-2-i(#-3,$>)}

 if w#-2>w#-1
  j[0] [-2],1~,$>,0,0
  j[0] [-1],1~,$>,0,1
 else
  r. {w#-2},100%,100%,100%,0,0,1
  j[0] [-2],1~,$>,0,0
  j[0] [-1],1~,$>,0,1
 fi

 if $ns r.. $ns,100%,100%,100%,-1
 else break
 fi

}

rm[-3--1]
rep_concat_conset_fill_alt_base:

check $!==1

startnum={max(abs($1),1)}
maxnum_a,maxnum_b=$startnum,{$startnum+(h-1)}

repeat inf {

 +rep_num2altbase $maxnum_a,$2

 if $> a[-2,-1] x fi

 maxnum_a-=1

 if $maxnum_a<=1||w#-1>=w#0
  startnum={max($maxnum_a,1)}
  rm.
  break
 fi

}

repeat inf {

 +rep_num2altbase $maxnum_b,$2

 nv={w#-1}

 if $> rv[-3,-1] a[-3,-1] x fi

 ($nv)

 if $> a[-2,-1] x fi

 maxnum_b-=1

 if $maxnum_b<$startnum break fi
}

ts={is#-1}

repeat inf {

 +rep_num2altbase {$>+1},$2

 if $> rv[-2,-1] a[-2,-1] x fi

 if w#-1>=$ts||w#-1>w#0 break fi

}

repeat h#0 {

 ns={w#-3-i(#-2,$>)}

 if w#-3>w#-1
  j[0] [-3],1~,$>,0,0
  j[0] [-1],1~,$>,0,1
 else
  r. {w#-3},100%,100%,100%,0,0,1
  j[0] [-3],1~,$>,0,0
  j[0] [-1],1~,$>,0,1
 fi

 if $ns r... $ns,100%,100%,100%,-1
 else break
 fi

}

rm[-3--1]
#@cli rep_BIGINT_division: decimal_number>=0,1<=divisor<=16777216
#@cli : Perform division on decimal number, then return the value. Supports 1000+ digits positive integer number for decimal_number only!
rep_BIGINT_division:
check m=1<<24;(inrange($1,0,m,1,1)?isint($1,0,m):1);isint($2,1,m)

if $1<(1<<53) status {int($1/$2)}
elif $2>$1    status 0
elif $2==1    status $1
elif $1==$2   status 1
else
	('$1')

	if im<_'0'||iM>_'9' error inv_num fi

	eval "
		const _0=_'0';
		const divisor=$2;
		const init_shift_num=int(log10(divisor));
		const start_digits_count=init_shift_num+1;
		const LenDecStr=w#-1;
		start_num=0;
		repeat(start_digits_count,p,
			start_num=start_num*10+i[#-1,p]-_0;
		);
		start_num>=divisor?(
			tmp=int(start_num/divisor);
			i[#-1,0]=tmp+_0;
			remainder=start_num-tmp*divisor;
			shift_num=init_shift_num;
		):(
			shift_num=init_shift_num+1;
			remainder=start_num;
		);
		for(p,p<LenDecStr,++p,
			tmp=remainder*10+i[#-1,p]-_0;
			new_num=int(tmp/divisor);
			remainder=tmp-new_num*divisor;
			i[#-1,p-shift_num]=new_num+_0;
		);
		set('trim_end_point',LenDecStr-shift_num-1);"

	crop. 0,$trim_end_point status {t} rm.

fi
#@cli rep_posdec2altbase_num: base,positive_decimal
#@cli : Return decimal into specified base using series of digits represented in base 10 separated by comma. Integers bigger than DOUBLE_MAX or 1.7976931348623157*10^308 is supported.
rep_posdec2altbase_num:
bfm={1<<24} # base_float_max
check isnum($1)?isint($1,2,$bfm):1

if isnum($1)
	base=$1
else
	base_bin,base_oct,base_dec,base_hex=2,8,10,16
	base=${base_$1}
fi

('$2')
check isint([im,iM],_'0',_'9')==[1,1]
crop_point={for(p=0,if(i[#-1,p]!=_'0',break(););,++p);p;}
if $crop_point
	unroll. x
	crop. $crop_point,100%
fi
+>>[-1] 0 !=[-1] [-2] if iM error non_dec_str else rm. fi

number_of_digits={size('$1')-1}
if $base==10^$number_of_digits
	unroll. x
	u {"expr('begin(
			const step_size=$number_of_digits;
			step=-(whd#-1%step_size);
		);
		selected_indice=crop(#-1,step,0,0,0,step_size,1,1,1);
		step+=step_size;
		s2v(selected_indice+(!selected_indice*_'0'));
		',ceil(whd#-1/$number_of_digits));
	"}
	rm.
elif $2<=(1<<53)
	w:=w rm.
	{ceil(($w*log(10))/log($base))},1,1,1,<"begin(
			const b=$base;
			v=$2;
			p=w;
		);
		if(v,
			r=v%b;
			v=int(v/b);
			--p;
			r;
		);
		end(set('p',p);set('q',w-p));"
	u {crop(#-1)[$p,$q]} rm.
else
	unroll. x

	digits_per_base_change:=int(log($bfm)/log($base))
	new_base:=$base^$digits_per_base_change
	{ceil((w*log(10))/log($new_base))+1},1,1,1,<"begin(
			const base_10M=10e7;
			const new_base=$new_base;
			temp_process_area=expr('begin(
					const step_size=8;
					step=(init_step=whd#-1%step_size;init_step?-(step_size-init_step):0);
				);
				selected_indice=crop(#-1,step,0,0,0,step_size,1,1,1);
				step+=step_size;
				s2v(selected_indice+(!selected_indice*_'0'));
			',ceil(whd#-1/8));
			valid_digit_end=0;
			start_of_res_digit=w;
			start_point=0;
			const end_point=size(temp_process_area)-1;
		);
		carry_over=0;
		if(start_point<end_point||temp_process_area[end_point],
			remainder=0;
			find_start_point=1;
			for(p=start_point,p<size(temp_process_area),++p,
				current_value=carry_over*base_10M+temp_process_area[p];
				carry_over=current_value%new_base;
				remainder=temp_process_area[p]=int(current_value/new_base);
				if(find_start_point,
					if(remainder,
						start_point=p;
						find_start_point=0;
					);
				);
			);
			--start_of_res_digit;
		);
		carry_over;
		end(
			set('start',start_of_res_digit);
		);"

	z. $start,100% rm[-2]

	if $digits_per_base_change>1
		length_non_first={$digits_per_base_change*(w-1)}
		{int(log(i[#-1,0])/log($base))+1+$length_non_first}
		eval[-2] "begin(
				insertion_pos=w#-1-$length_non_first-1;
				started=0;
			);
			started?(
				insertion_pos+=$digits_per_base_change;
			):(
				insertion_pos+=x*$digits_per_base_change;
				started=1;
			);
			v=i;current_pos=insertion_pos;
			while(v,
				i[#-1,current_pos--]=v%$base;
				v=int(v/$base);
			);
			insertion_pos;"
		u {crop(#-1)}
		rm[-2,-1]
	else
		u {crop(#-1)}
		rm[-1]
	fi
fi
#@cli rep_altbase_num2posdec: base,digit_a,digit_b,...
#@cli : Return the decimal number which corresponds to arguments. Accurately calculate the integer number for numbers bigger than the DOUBLE_MAX or 1.7976931348623157*10^308.
rep_altbase_num2posdec:
bfm={1<<24} # base_float_max
check isnum($1)?isint($1,2,$bfm):1

if isnum($1)
	base=$1
else
	base_bin,base_oct,base_dec,base_hex=2,8,10,16
	base=${base_$1}
fi

(${2--1})
check im>=0&&iM<$base&&isfinite(ia)
crop_point={for(p=0,!i[#-1,p],++p);p;}
if $crop_point
	unroll. x
	crop. $crop_point,100%
fi
+>>[-1] 0 !=[-1] [-2] if iM error non_int_det else rm. fi

if whd<=int(log((1<<53)-1)/log($base))+1
	eval. <"begin(
			M=1;
			total=0;
		);
		if(!isint(i),
			run('error non_int_det');
		);
		total+=i*M;M*=$base;
		end(
			set('{}',total);
		);"

	rm.
	return
else
	num_of_digits,n0:=size('$1'),_'0'
	if $1==10^($num_of_digits-1)
		if $num_of_digits==2
			u {`[${2--1}+_'0']`} return
		fi
		FDC={size('$2')}
		num_of_digits-=1
	else
		digits_per_base_change={int(log($bfm)/log($base))}
		new_base={$base^$digits_per_base_change}
		num_of_digits={size('$new_base')-1}
		base_power_of_10={10^$num_of_digits}

		# Convert into larger base
		if $new_base>$base
			{ceil(whd/$digits_per_base_change)},1,1,1,"begin(
					const dpbc=$digits_per_base_change;
					const scp=whd#-1%dpbc;   # Shift crop point;
					const fcs=dpbc-scp;      # First crop_point
					multipliers=expr('<begin(v=0;);v?(v*=$base):(v=1);',dpbc);
					started=crop_point=0;
					current_area=vector(#dpbc);
					scp?(
						first_multiplier=multipliers[fcs,scp];
						temp_small=vector(#scp);
					);
				);
				started?(
					crop_point+=dpbc;
					copy(current_area,i[#0,crop_point],dpbc,1,1);
					dot(multipliers,current_area);
				):(
					started=1;
					x?(
						crop_point=x*dpbc-fcs;
						copy(current_area,i[#0,crop_point],dpbc,1,1);
						dot(multipliers,current_area);
					):(
						crop_point=-fcs;
						scp?(
							copy(temp_small,i[#0,0],scp,1,1);
							dot(first_multiplier,temp_small);
						):(
							copy(current_area,i[#0,0],dpbc,1,1);
							dot(multipliers,current_area);
						);
					);
				);"

			rm..
		fi

		# Convert into base of power of 10
		{ceil(log($new_base)/log($base_power_of_10)*w)}
		eval "
			start_point=insertion_point=0;
			const divisor=$base_power_of_10;
			const end_point=w#-2-1;
			const operating_base=$new_base;
			insertion_pos=w#-1;
			temp_process_area=crop(#-2);
			insert_valid=0;
			while(start_point<end_point||temp_process_area[end_point],
				remainder=carry_over=0;
				find_start_point=1;
				for(p=start_point,p<w#-2,++p,
					current_value=carry_over*operating_base+temp_process_area[p];
					carry_over=current_value%divisor;
					remainder=temp_process_area[p]=int(current_value/divisor);
					if(find_start_point,
						if(remainder,
							start_point=p;
							find_start_point=0;
						);
					);
				);
				if(carry_over,
					insert_valid=1;
				);
				if(insert_valid,
					i[#-1,--insertion_pos]=carry_over;
				);
			);
			if(carry_over,i[#-1,--insertion_pos]=carry_over);
			insertion_pos+1;
			"

		rm.. crop. ${},100%

		# End of base conversion

		FDC={int(log10(i[#-1,0]))+1} # First Digits Count

	fi

fi

# Print out result!

{$FDC+(w#-1-1)*$num_of_digits},1,1,1,$n0

eval.. "begin(
		const FDC=$FDC;
		const NOD=$num_of_digits;
		const d_NOD=NOD-1;
		const off=NOD-FDC;
		insertion_point=started=count_of_insert=0;
	);
	started?(
		insertion_point+=NOD;
		count_of_insert=NOD;
	):(
		insertion_point=x*NOD-off+d_NOD;
		count_of_insert=x?NOD:FDC;
		started=1;
	);
	chars=v2s(i,NOD,NOD);
	ref_pos=chars[d_NOD]?d_NOD:argmin(chars)-1;
	copy(i[#-1,insertion_point],chars[ref_pos],ref_pos+1,-1,-1);
	"

u {`crop(#-1)`}
rm[-2,-1]
#@cli rep_num2altbase: abs_num,base
#@cli : Insert number in bases other than 10. Each numbers are represented as digits by themselves.
+rep_num2altbase:

####################################################################################
# Dear Reptorian,                                                                  #
# When you're done refactoring Mitchell Concatenation, please retire this command. #
# It is to be replaced with +rep_posdec2base_img command.                          #
# Thank you for reading your self-note,                                            #
# Reptorian                                                                        #
####################################################################################

number,base={int(abs([$1,$2]))}

{1+int(log($number)/log($base))},1,1,1,<"
 begin(
  const base=$base;
  n=$number;
 );
 remainder=n%base;
 n=int(n/base);
 remainder;
 "
#@cli rep_int2roman: 1<=num_a<=3999,...
#@cli : Return integer number(s) as Roman Numeral(s)
rep_int2roman:
check same(isint([$*],1,3999),1)

u {`"
	args=[$*];

	const S=size(args);
	const L=S*15+S-1;
	const _comma=_',';

	r=vector(#L);
	chars='IVXLCDM';

	q=0;
	repeat(S,a,
		if(q,r[q++]=_comma;);
		digits=int(args[a]/[1000,100,10,1])%10;
		c=6;

		repeat(4,p,
			if(digits[p],
				digit=digits[p];
				td=digit%5;

				td==4?(
					r[q++]=chars[c];
					r[q++]=chars[c+(digit>5?2:1)];
				):(
					if(digit>4,r[q++]=chars[c+1];);
					copy(r[q],chars[c],td,1,0);
					q+=td;
				);
			);
			c-=2;
		);
	);
	r;
"`}
#@cli rep_roman2int: roman_numeral_string_a,....,is_strict={ 0=false | 1=true }
#@cli : Return Roman Numeral(s) as integer number(s).
rep_roman2int:
if isnum($-1)
	check $#>1
	is_strict={bool($-1)}
	args=${1--2}
	roman_num_args_count={$#-1}
else
	check $#
	is_strict=1
	args=${1--1}
	roman_num_args_count=$#
fi

struppercase $args

u {"
	const _H=_'H';
	const is_strict=$is_strict;
	const roman_num_args_count=$roman_num_args_count;
	const reset_init_state_mode=roman_num_args_count>1;

	init_state()=(
		older_char_rank=char_rank=old_char_rank=is_odd_char_rank=ans=num=0;
		old_character_idx=-1;
		char_freq_list=vector(#chars_count,0);
		char_limits=expr('!(x&1)?3:1',7);
		thres_length=pos_in_roman_num_collection;
		if(is_strict,subtractive_mode=0;);
	);

	roman_num_collection='"${}"';

	roman_chars='IVXLCDM';
	const chars_count=size(roman_chars);
	symbol_vals=expr('(x&1?5:1)*10^(x>>1)',chars_count);
	ref_symbols_order=[2,0,3,4,5,6,1];

	pos_in_roman_num_collection=size(roman_num_collection);

	result=vector(#roman_num_args_count);
	r_pos=size(result);

	if(is_strict,subtractive_mode=0;);
	thres_length=pos_in_roman_num_collection;

	init_state();
	while(pos_in_roman_num_collection--,
		character_idx=roman_num_collection[pos_in_roman_num_collection];

		if(reset_init_state_mode,
			if(roman_num_collection[pos_in_roman_num_collection]==_',',
				result[--r_pos]=ans;
				init_state();
				continue();
			);
		);

		if(character_idx!=old_character_idx,
			sel=character_idx&0b111;
			if(sel==4,sel>>=character_idx>_H;);
			char_rank=ref_symbols_order[sel];

			if(character_idx!=roman_chars[char_rank],
				run('error inv_char_det');
			);

			if(is_strict,
				if(char_rank-old_char_rank<-2,
					run('error inv_char_gap');
				);
			);

			num=symbol_vals[char_rank];
		);

		if(++char_freq_list[char_rank]>char_limits[char_rank],
			run('error excess_char');
		);

		if(is_strict,
			if(subtractive_mode,
				if(char_rank==old_char_rank||char_rank==old_char_rank+1,
					run('error inval_sect_adj_sub');
				);
			);
		);

		(old_char_rank>char_rank)?(
			if(is_strict,
				subtractive_mode=1;
				if(char_rank&1,run('error inval_char_sub'););
			);

			if(!(old_char_rank&1),char_limits[old_char_rank]=4;);

			check_forward_pos_in_roman_str=pos_in_roman_num_collection+2;
			if(check_forward_pos_in_roman_str<thres_length,
				if(char_rank==old_char_rank||older_char_rank>=char_rank,
					run('error inval_sect_sub');
				);
			);

			older_char_rank=old_char_rank;
			ans-=num;
		):(
			if(is_strict,subtractive_mode=0;);
			ans+=num;
		);

		older_char_rank=old_char_rank;
		old_character_idx=character_idx;
		old_char_rank=char_rank;

		if(!isint(ans,1,3999),run('error out_of_bound_val'););
	);

	result[--r_pos]=ans;

	result;
"}
#@cli rep_output_jasc: filename
#@cli : Output selected image JASC-PAL files(s).(.pal)
rep_output_jasc:
e[^-1] "Output palettes$? as JASC-PAL palette files(s).(.pal)"
header=JASC-PAL\n0100\n

p=0
repeat $! {

	if $!>1 filename=${"filename \"$1\",$>"}
	else filename="$1"
	fi

	0 => $filename folder,basename,num_of_cols={f},{b},{whd#0}
	rm.

	output=$num_of_cols\n

	to_rgb[0]
	permute[0] cxyz
	unroll[0] x

	repeat $num_of_cols {
		r,g,b={crop(#0,$p,0,0,0,3,1,1,1)}
		output.=$r" "$g" "$b\n
		p+=3
	}

	('$header$output')

	ot. $folder$basename.pal

	rm[0,-1] p=0

}
#@cli rep_output_pdn_pal: filename
#@cli : Output selected images as Paint.NET palette file(s).(.txt)
rep_output_pdn_pal:
e[^-1] "Attempting to output palettes$? as Paint.NET palette file(s).(.txt)"
header="; paint.net Palette File: "

repeat $! {
	if $!>1 filename=${"filename \"$1\",$>"} else filename="$1" fi

	0 => $filename folder,basename,num_of_cols,palname={f},{b},{whd#0},{0,n} rm.

	if $num_of_cols>96 continue e[^-1] "Palette Limit Exceeded!Skipping!" fi

	start_header=$header$palname
	start_header.=\n"; Color Format - AARRGGBB"\n"; Colors: "$num_of_cols

	pal_info="\n"
	mp={$num_of_cols-1}

	to_rgba[0]
	permute[0] cxyz
	unroll[0] x

	visited=0

	repeat 96 {

		p=$>

		if $p<$num_of_cols
			rgba={crop(#0,$>*4,0,0,0,4,1,1,1)}
			rgb={([$rgba])[0,3]}
			alp={([$rgba])[3]}
			rgba=$alp,$rgb
			hex_rgba=${rep_int82hex\ $rgba}
			struppercase $hex_rgba
			pal_info.=${}
		else
			if !$visited pal_info.="; End of Palette List"\n visited=1 fi
			pal_info.=00808080
		fi

		if $p<95 pal_info.="\n" fi

	}

	('$start_header$pal_info')

	e[^-1] "Output palette"[$>]" as Paint.NET palette file(s).(.txt)"
header="; paint.net Palette File: "

	ot. $folder$basename.txt

	rm[0,-1]

}

rm
#@cli rep_output_gpl: filename
#@cli : Output selected images as GIMP palette file(s).(.gpl)
rep_output_gpl:
e[^-1] "Output palettes$? as GIMP palette file(s).(.gpl)"

init_header="GIMP Palette\n\#Palette Name: "
init_colors_info="\n#Colors: "

repeat $! {
	if $!>1 filename=${"filename \"$1\",$>"} else filename="$1" fi
	0 => $filename folder,basename,num_of_cols,palname,ss={f},{b},{whd#0},{0,n},{s#0} rm.

	header_info=$init_header$palname
	colors_info=$init_colors_info$num_of_cols
	start_header=$header_info$colors_info
	pal_info="\n"
	mp={$num_of_cols-1}

	permute[0] cxyz unroll[0] x

	if $ss==3||$ss==4

		repeat $num_of_cols {
			p=$>

			rgb={(crop(#0,$>*$ss,0,0,0,$ss,1,1,1))[0,3]}
			hex_rgb=${rep_int82hex\ $rgb}

			r={([$rgb])[0]}
			g={([$rgb])[1]}
			b={([$rgb])[2]}

			pal_info.=$r"	"$g"	"$b"	"$hex_rgb

			if $p<$mp pal_info.="\n" fi

		}

	elif s#0<3

		repeat $num_of_col {
			p=$>

			gray={(crop(#0,$>*$ss,0,0,0,$ss,1,1,1))[0]}

			hex_rgb=${rep_int82hex\ vector3($gray)}
			r,g,b=$gray

			pal_info.=$r"	"$g"	"$b"	"$hex_rgb

			if $p<$mp pal_info.="\n" fi
		}

	else
		e[^-1] "Invalid channels, skipping!"
		rm[0] continue
	fi

	('$start_header$pal_info')

	ot. $folder$basename.gpl

	rm[0,-1]

}
#@cli +rep_split_gradient : number_of_colors,splits,colors_per_split,_axis,_seed,_reverse_internal,_reverse_all,min_value_a...,maxvalue_a...
#@cli : Create split gradients
#@cli : Author : Reptorian.
#@cli : Default values: '_axis=x','_seed=n/a','_reverse_internal=0','_reverse_all=0'
+rep_split_gradient:
skip ${4=0},${5=},${6=0},${7=0}
$=p

if isnum($4) axis={$4%3}
else axis={_'$4'-_'x'}
fi

dir_axis=${arg0\ $axis,x,y,z}
len_axis=${arg0\ $axis,w,h,d}

ncol,u_string={narg(${8--1})/2},""

if $ncol>1 u_string.=[ fi

repeat $ncol {
	k=$>

	u_string.=u(${p{8+$k}},
	u_string.=${p{8+$k+1}})

	if $k<($ncol-1) u_string.=, fi
}

if $ncol>1 u_string.=] fi

{arg1($axis+1,[$1,1,1],[1,$1,1],[1,1,$1])},1

s. $dir_axis,$2

f[-$2--1] "begin(const scale=("$len_axis"#"-$2"-1)/($3-1););"$dir_axis"/scale"

$3,1,1,$ncol

repeat $2 {

	q=$>

	f. begin(if(narg($5),srand($5+$q);););[$u_string]

	if $6 mirror. $dir_axis fi

	rep_cubic_map[-{2+$q}] [-1],2

}

rm.

a[-$2--1] $dir_axis

if $7 mirror. $dir_axis fi
#@cli rep_hitomezashi : "str_a","str_b",_upscale_pixel>=1,[colors_a palette],[colors_b stray_palette],_shift_color,_boundary={ 0=Periodic | 1=Continuous },0<=_symmetry_mode<=3,_stray_color_seed,stray_col_a,...stray_col_n,border_size,border_col_a,...,border_col_n,frames : "str_a","str_b",upscale_pixel>=1,colors_a={ hex | value~ },colors_b={ hex | value~ },0<=_symmetry_mode<=3,border_size,border_col_a,...border_col_n
#@cli : Create Hitomezashi Stitch Pattern.
#@cli :
#@cli : Note: The number of stray_color and number of border color depends on the number of channels to be used. For example, in the case of palette, it depends on number of channels per palette. In case of hex, then it depends on number of characters divided by two. Finally, if you insert wave at the end, there is only one.
#@cli :
#@cli : Author : Reptorian.
#@cli : Default value : '_upscale_pixel=1','colors_a=n/a','colors_b=n/a','_shift_color=0','_boundary=0','_stray_color_seed=n/a','_symmetry_mode=n/a'
+rep_hitomezashi:

skip ${3=1},"${4=}","${5=}","${6=}","${7=}","${8=}","${9=}"

$=argpos

pixel_size,colors_a,colors_b,use_remove_image={max(int($3)*100,100)}%,${4-5},1
use_rescale={$pixel_size!=1}

command "cmd_$0_border :
 if narg($""*)>1 out_color=[$""*]
 else out_color=$""1
 fi
 eval.. :\"begin(
   const pixel_size="$pixel_size";
   const border_size=$_border_size;
   const ip=floor(border_size/2);
   const iq=ceil(border_size/2);
   color=\"$out_color\";
   const iex=w#-1-1;
   const iey=h#-1-1;
   const bpe=max(0,(border_size-1));
   const xbpe=w#-1-1-bpe;
   const ybpe=h#-1-1-bpe;
  );
  ix=x*pixel_size-ip;
  iy=y*pixel_size-ip;
  sx=(x+1)*pixel_size-ip;
  sy=(y+1)*pixel_size-ip;
  ex=(x+1)*pixel_size+max(iq-1,0);
  ey=(y+1)*pixel_size+max(iq-1,0);
  if(i!=j(1,0,0,0,0,1),
   polygon(#-1,4,
    sx,iy,
    ex,iy,
    ex,ey,
    sx,ey,
   1,color);
  );
  if(i!=j(0,1,0,0,0,1),
   polygon(#-1,4,
    ix,sy,
    ex,sy,
    ex,ey,
    ix,ey,
   1,color);
  );
# end(
#  polygon(#-1,4,
#   0,0,
#   iex,0,
#   iex,bpe,
#   0,bpe,
#   1,color
#  );
#  polygon(#-1,4,
#   0,0,
#   bpe,0,
#   bpe,iey,
#   0,iey,
#   1,color
#  );
#  polygon(#-1,4,
#   xbpe,0,
#   iex,0,
#   iex,iey,
#   xbpe,iey,
#   1,color
#  );
#  polygon(#-1,4,
#   ybpe,ybpe,
#   bpe,ybpe,
#   bpe,iey,
#   ybpe,iey,
#   1,color
#  );
# );
   \""

command "cmd_$0_border_depth :
 if narg($""*)>1 out_color=[$""*]
 else out_color=$""1
 fi
 eval.. :\"begin(
   const pixel_size="$pixel_size";
   const border_size=$_border_size;
   const l_length=(pixel_size+border_size);
   const depth=d#-1;
   const length=l_length*border_size*depth*s#-1;
   const edge_x_length=w#-1*border_size*depth*s#-1;
   const edge_y_length=h#-1*border_size*depth*s#-1;
   const ip=floor(border_size/2);
   const iq=ceil(border_size/2);
   color=\"$out_color\";
   const iex=w#-1-1;
   const iey=h#-1-1;
   const bpe=max(0,(border_size-1));
   const xbpe=w#-1-1-bpe;
   const ybpe=h#-1-1-bpe;
   vcol=resize(color,length,1,0);
   edge_x=resize(color,edge_x_length,1,0);
   edge_y=resize(color,edge_y_length,1,0);
  );
  ix=x*pixel_size-ip;
  iy=y*pixel_size-ip;
  sx=(x+1)*pixel_size-ip;
  sy=(y+1)*pixel_size-ip;
  if(i!=j(1,0,0,0,0,1),draw(#-1,vcol,sx,iy,0,0,border_size,l_length,depth,s#-1,1));
  if(i!=j(0,1,0,0,0,1),draw(#-1,vcol,ix,sy,0,0,l_length,border_size,depth,s#-1,1));
  # end(
  #  draw(#-1,edge_x,0,0,0,0,w#-1,border_size,depth,s#-1,1);
  #  draw(#-1,edge_y,0,0,0,0,border_size,h#-1,depth,s#-1,1);
  #  draw(#-1,edge_x,0,h#-1-border_size,0,0,w#-1,border_size,depth,s#-1,1);
  #  draw(#-1,edge_y,w#-1-border_size,0,0,0,border_size,h#-1,depth,s#-1,1);
  # );
  \""

+rep_binary_hitomezashi "$1","$2"

if ${is_image_arg\ $colors_a}||${is_image_arg\ $colors_b}

 shift_colors,boundary,sym_mode,seed=${6-9}

 np=0
 if narg($colors_a) pass$colors_a 1 np+=1 fi
 if narg($colors_b) pass$colors_b 1 np+=1 fi

 if narg(${argpos{10+s#-1}}) _border_size={($pixel_size)>1?min(max(0,($pixel_size)-1),abs(${argpos{10+s#-1}})):0}
 else _border_size=0
 fi

 if narg(${argpos{11+s#-1*2}}) depth=${argpos{11+s#-1*2}}
 else depth=1
 fi

 stray_color=""
 border_color=""
 sid={s#-1-1}

 repeat s#-1 {

  n=$>
  stray_color.=${argpos{10+$>}}
  border_color.=${argpos{11+s#-1+$>}}

  if $n<$sid
   stray_color.=,
   border_color.=,
  fi

 }

 if $np==2

  +_rep_colorize_binary_hitomezashi... [-2],[-1],$shift_colors,$boundary,$seed,$depth
  rm[-3,-2]
  if narg($sym_mode) rep_symmetrize_xy[-2,-1] $sym_mode fi
  r. {w#-1*$pixel_size},{h#-1*$pixel_size},{d#-1},{s#-1},1

  if $_border_size
   if $depth>1 cmd_$0_border_depth $border_color
   else cmd_$0_border $border_color
   fi
  fi

 else

  +_rep_colorize_binary_hitomezashi.. [-1],,$shift_colors,$boundary,$seed,$stray_color,$depth
  rm..
  if narg($sym_mode) rep_symmetrize_xy[-2,-1] $sym_mode fi
  r. {w#-1*$pixel_size},{h#-1*$pixel_size},{d#-1},{s#-1},1

  if $_border_size
   if $depth>1 cmd_$0_border_depth $border_color
   else cmd_$0_border $border_color
   fi
  fi

 fi

elif narg($colors_a)||narg($colors_b)
 sym_mode,_border_size=$6,{($pixel_size)>1?min(max(0,($pixel_size)-1),(narg($7)?abs($7))):0}

 if narg($sym_mode) rep_symmetrize_xy. $sym_mode fi

 wave_check_a={narg($colors_a)?${rep_contains_wave_at_end\ $colors_a}:0}
 wave_check_b={narg($colors_b)?${rep_contains_wave_at_end\ $colors_b}:0}
 wave_mode={$wave_check_a+$wave_check_b}

 if $wave_mode==2
  ('$colors_a') r. {w#-1-1} a={t}
  ('$colors_b') r. {w#-1-1} b={t}
  rm[-2,-1]
  +f. i?$b:$a

  if $use_rescale rs. $pixel_size,,1 fi

  if $_border_size
   v=$8
   cmd_$0_border $v
  fi

 elif $wave_mode==1
  if $wave_check_a ('$colors_a') r. {w#-1-1} a={t} fi
  if $wave_check_b ('$colors_b') r. {w#-1-1} a={t} fi
  rm.

  if $use_rescale {w*$pixel_size},{h*$pixel_size},1,1,$a fi

  if $_border_size
   v=$8
   cmd_$0_border $v
  fi

 else

  na={narg($colors_a)+narg($colors_b)}

  if $na==2

   rgb_a=${rep_hex2int8\ $colors_a}
   rgb_b=${rep_hex2int8\ $colors_b}
   check narg($rgb_a)==narg($rgb_b)
   {w},{h},1,{narg($rgb_a)},i#-1?[$rgb_b]:[$rgb_a]
   if $use_rescale rs. $pixel_size,,1 fi

   if $_border_size
    vc=${8--1}
    cmd_$0_border $vc
   fi

  else

   if narg($colors_a) rgb=${rep_hex2int8\ $colors_a} fi
   if narg($colors_b) rgb=${rep_hex2int8\ $colors_b} fi
   {w*$pixel_size},{h*$pixel_size},1,{narg($rgb)},[$rgb]
   if !$_border_size error no_border fi

   if $_border_size
    vc=${8--1}
    cmd_$0_border $vc
   fi

  fi

 fi

else

 sym_mode=$6
 use_remove_image=0
 if narg($sym_mode) rep_symmetrize_xy. $sym_mode fi
 if $use_rescale rs. $pixel_size,,1 fi

fi

if $use_remove_image rm.. fi

uncommand cmd_$0_border,cmd_$0_border_depth
+_rep_colorize_binary_hitomezashi:
skip "${1=}","${2=}","${3=0}","${4=0}","${5=}","${6=}"

if $!>1 error inv_img_cnt fi

ml={norm(w,h)}

+label.

{iM#-1+1},1,1,3,[x,0,0] sh. 1,2
{w#-2},1,1,1,$ml

eval[-4] >"
 i(#-2,i,0,0,0)=i(#-1,i,0,0)=min(norm(x,y),i(#-1,i,0,0));
 ++i(#-2,i,0,0,1);"

rm[-2,-1]

sh. 1 pixelsort.. +,x,[-1] rm.

=> ref_ind

sh. 1,2

ni=0

if ${is_image_arg\ $1}
 pass$1 1
 ni+=1
else no_pal_available fi

if ${is_image_arg\ $2}
 pass$2 1
 ni+=1
fi

if $ni==2

 if s#-2!=s#-1 error inv_chnl_cnt fi

 frame_count={narg($6)?$6:1}

 eval "
  if(narg($5),srand($5););
  const length=w#-3;
  const nc=w#-1;
  pos=0;
  t=-1;
  tv=inf;
  ind=-1;
  while(pos<length,
   i(#-3,pos,0,0,1)==1?(
    rpos=v(0,nc,1,0);
    if(rpos==t,rpos=u(1)<.5?(rpos+1)%nc:(rpos-1)%nc);
    t=rpos;
    I(#-3,pos,0,0)=[rpos,0];
    ++pos;
   ):(
    if(i(#-3,pos,0,0,0)!=tv,++ind;);
    tv=i(#-3,pos,0,0,0);
    I(#-3,pos,0,0)=[ind,1];
    ++pos;
   );
  );"

elif $ni==1

 $=frame_arg
 frame_count={narg(${frame_arg{6+s#-1}})?${frame_arg{6+s#-1}}:1}

 eval "
  if(narg($5),srand($5););
  const length=w#-2;
  pos=0;
  tv=inf;
  ind=-1;
  while(pos<length,
   i(#-2,pos,0,0,1)==1?(
    I(#-2,pos,0,0)=vector(#2,0);
    ++pos;
   ):(
    if(i(#-2,pos,0,0,0)!=tv,++ind;);
    tv=i(#-2,pos,0,0,0);
    I(#-2,pos,0,0)=[ind,1];
    ++pos;
   );
  );"
else
 error no_img_arg
fi

rm[{$ni==2?-3:-2}]

sh[ref_ind] 0 pixelsort[ref_ind] +,x,[-1] rm. sh[ref_ind] 1,2

tf={abs($frame_count)}
tf_max_id={$tf-1}

{w#-1},1,$tf,{s#-2},"begin(
  const bnd=$4%2+2;
  $ni==2?(
   bg_col()=I(#-3,pos+$3+z,0,0,0,bnd);
   str_col()=I(#-2,pos,0,0);
  ):(
   bg_col()=I(#-2,pos+$3+z,0,0,0,bnd);
   str_col()=vector(#s#-2,${6--1});
  );
 );
 pos=i(#-1,x,0,0,0);
 pal_mode=i(#-1,x,0,0,1);
 if(pal_mode,bg_col(),str_col());"

if abs($frame_count)<=1
 map[1] [-1] rm[{$ni==2?-5:-4}--1]
else
 direction=${arg0\ ($frame_count>0),$tf_max_id-z,z}
 {w#1},{h#1},$tf,{s#-1},I(#-1,i(#1,x,y,0,0),0,$direction)
 rm[1--2]
fi
#@cli rep_binary_hitomezashi : string_a,string_b,[_rules]
#@cli : Create a hitomezashi image. Strings inserted as argument are treated as unicode converted to binary based on rules. Rules has been pre-defined already.
#@cli :
#@cli : Note : Original Source Code is at found at the spreadsheet link within this link - https://aperiodical.com/2020/12/mobile-numbers-hitomezashi-stitching/
#@cli :
#@cli : Author: Reptorian.
+rep_binary_hitomezashi:
skip "${3=}"

if ${is_image_arg\ $3}
 pass$3 0
 gt[-1] {ia}
else
 (1,0,0,0,0,0,1,1,1,1,1,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,1,1,0,0,1,0,0,1,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,1,1,0,1,0,1,1,1,0,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,1,0,1,1,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,1)
fi # rules

('"$1"') # Get array of unicode value of input 1
('"$2"') # Get array of unicode value of input 2

map[-2,-1] [-3] # Convert unicode image/array to binary with rules

{w#-1},1,1,1,>begin(v=0;);v=x?(j(#-1,-1)+v)%2:0; rm.. # Process first column. Creates auxilatory surface and then remove reference surface

{w#-2},{w#-1},1,1 # Create a 2D surface to write on

eval.. "
 v=i(#-1,0,x)=i;
 row=x+1;
 repeat(w#-3-1,p,
  v=i(#-1,p+1,x)=sum(v,i(#-3,p,0),row,1)%2;
 );" # Generate value from spreadsheet rule

rm[-4--2] # Keep only the Hitomezashi Pattern
#@cli rep_contains_wave_at_end : "str"
#@cli : Return whether it contains a wave at end.
#@cli : Author: Reptorian.
rep_contains_wave_at_end: skip "${1=}" if narg($1) u {a=['$1'];(a)[size(a)-1]==_'~'} else u 0 fi
#@cli rep_random_bits: num_of_chars>0
#@cli : Return randomly generated string of bits.
#@cli :
#@cli : Author : Reptorian.
rep_random_bits: check "$1>0" u {`expr('v(_'0',_'1')',$1)`}
#@cli rep_sym_xy: eq. to 'rep_symmetrize_xy'.
rep_sym_xy: rep_symmetrize_xy $*
#@cli rep_symmetrize_xy: 0<=mode<=3,_border_size>=0
#@cli : Create copies and then append images to generate symmetry alongside xy-axis.
#@cli :
#@cli : Default values: '_border_size=1'
#@cli : Author: Reptorian.
rep_symmetrize_xy:
skip ${2=1}
mode,border={[$1&3,int(abs($2))]}

a_x,a_y,b_x,b_y:=xor(vector(#4,[0,0,1,1,1,0,0,1][$mode<<1,2]),[1,1,0,0])

foreach {
	{([w,h]<<1)-$border},100%,100%
	j[1] [0],$b_x~,$b_y~
	mirror[0] xy
	j[1] [0],$a_x~,$a_y~
	mirror[0] x
	j[1] [0],$b_x~,$a_y~
	mirror[0] xy
	j[1] [0],$a_x~,$b_y~
	rm[0]
}
#@cli rep_cellular_automata : int_rule,_min_arr_size
#@cli : Default values: '_min_arr_size=n/a'
rep_cellular_automata:
skip ${2=}

channels 0

rule_decimal,min_arr_size=${1-2}

# Create Binary Array From Decimal Input
dec2bin $1 ('${}')
-[-1] {_'0'}
name[-1] rules

if narg($min_arr_size)
	if w<$min_arr_size
		r. $2,1,1,1,0,0,1
	fi
fi

repeat $!-1 {

	local[$>,-1] {

		ow,oh={w#0},{h#0}

		unroll[0] x
		iter={ceil(w#0/w#-1)}

		$ow,1,1,1,v(0,2,1,0)

		repeat $iter {
			p=$>

			pos={$p*w}

			if !iv#-1 f. v(0,2,1,0) fi

			{w},1,1,1,"begin(
				state(n)=i(#-1,n,0,0,0);
			);
			k=4*state((x-1+w)%w)+2*state(x)+state((x+1)%w);
			i(#-2,k,0,0,0);"

			j[0] [-1],$pos,0

			rm..

		}

		r[0] $ow,$oh,1,1,-1
		rm.

	}

}

rm.
#@cli rep_er : eq. to 'rep_emboss_relief'
rep_er : rep_emboss_relief $*
#@cli rep_emboss_relief : int_radius>=4,-360>=_ang>=360,_sigma>0,_scale>0,_output={ 0=emboss | 1=relief },_color_out={ 0=gray | 1=color },_bias>0,_use_cmyka={ 0=non_cmyka_mode | 1=cmyka_mode }
#@cli : Generates effect of embossing onto image via convolution.
#@cli : Default values: '_ang=45','_sigma=.5','_scale=2','_output=1','_bias=128','_color_out=1','_use_cmyka=0'
rep_emboss_relief:
skip ${2=45},${3=.5},${4=2},${5=1},${6=1},${7=128},${8=0}

radius,angle,sigma,scale,relief_mode,gray_mode,bias,max_alp_ind=${1-5},{!$6},$7,{$8?4:3}
convolution_main_setting=$radius,$angle,$sigma,$scale,$gray_mode

if $gray_mode
	command "cmd_$0_process_emboss_alpha_case : split_opacity cmd_$0_process_emboss_filter.. a c"
	command "cmd_end_relief : +.. . rm."
else
	command "cmd_$0_process_emboss_alpha_case : sh 0,{s-2} cmd_$0_process_emboss_filter. rm."
	command "cmd_end_relief : add"
fi

if $relief_mode
	command "cmd_$0_process_emboss_filter : +_rep_steerable_gaussian_convolve "$convolution_main_setting" cmd_end_relief"
else
	command "cmd_$0_process_emboss_filter : +_rep_steerable_gaussian_convolve "$convolution_main_setting" +. "$bias" k."
fi

foreach {
	if s==2||s>$max_alp_ind cmd_$0_process_emboss_alpha_case
	else cmd_$0_process_emboss_filter
	fi
}

uncommand cmd_$0_process_emboss_alpha_case,cmd_$0_process_emboss_filter,cmd_end_relief
+_rep_steerable_gaussian_convolve:

sg,theta,sigma,M={max(5,int(abs($1)))},{deg2rad($2)},$3,{3*$3}

$sg,1,1,2,"begin(
		const center_index=(w-1)/2;
		const sigma_exp=2*$sigma^2;
		const sqrsig=$sigma*sqrt(2*pi);
	);
	nx=(x-center_index)/center_index*$M;
	g=exp(-(nx^2)/sigma_exp)/sqrsig;
	gp=(nx/$sigma^2)*g;
	[g,gp];"

sh. 0 ts={is#-1/$4} rm. /. $ts

+rotate. 90

s[-2,-1] c

+convolve[0] [-4]
convolve. [-2]
+convolve[0] [-3]
convolve. [-5]

*. {cos($theta)}
*.. {sin($theta)}

add.. .

k[0,-2]

if $5 ss={s} compose_channels. + /. $ss fi
#@cli rep_hsl2ryb2rgb
#@cli : Convert color representation of selected image from HSL to RYB to RGB
rep_hsl2ryb2rgb:

e[^-1] "Convert color representation of image$? from HSL to RYB to RGB."

f "H=(i0/60)%6;C=(1-abs(2*i2-1))*i1;X=C*(1-abs(H%2-1));
	m=i2-C/2;
	RYB=arg1(1+int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
	RYB+=m*=255;
	red=RYB[0];
	yellow=RYB[1];
	blue=RYB[2];
	white=min(RYB);
	red-=white;
	yellow-=white;
	blue-=white;
	maxyellow=max(red,yellow,blue);
	green=min(yellow,blue);
	yellow-=green;
	blue-=green;
	blue>0&&green>0?(
		blue*=2;
		green*=2
	);
	red+=yellow;
	green+=yellow;
	maxgreen = max(red,green,blue);
	maxgreen>0?(
		N=maxyellow/maxgreen;
		red*=N;
		green*=N;
		blue*=N;
	);
	red+=white;
	green+=white;
	blue+=white;
	[red,green,blue];"
#@cli rep_color_harmony_palette: -360<=ang<=360,0<=_saturation<=1,-100[%]<=shade_tint<=100[%],0<=choice<=10,ryb_mode={ -1=hsl_only | 0=rgb | 1=ryb | 2=hsl+rgb | 3=hsl+ryb }
#@cli : Create a harmony palette. In other word, create a palette based on the color wheel.
+rep_color_harmony_palette:
skip ${5=1}
check "inrange($2,0,1,1,1)&&inrange($3,-1,1,1,1)&&isint($4,0,10)&&isint($5,0,3)"

{([6,6,6,2,3,3,4,3,4,5,6])[$4]},1,1,3,">begin(
		const start_ang=$1%360;
		const saturation=$2;
		const shade_tint=(1+($3))/2;
		const mode=$4;
		ang=start_ang;
		mode<4?(
			const add_ang=arg1(mode+1,8,15,30,180);
			add2ang()=ang+=add_ang;
		):
		mode==4?(
			add2ang()=ang+=(x?60:150);
		):
		mode<7?(
			const add_ang=mode&1?120:90;
			add2ang()=ang+=add_ang;
		):(
			const ind=mode-7;
			add_ang_a=([90,60,120,30])[ind];
			const add_ang_b=arg1(ind+1,180,120,30,90);
			add2ang()=(
					if(x&1
					,ang+=add_ang_b;
					,ang+=add_ang_a;
					);
					if(mode==9,if(!x,add_ang_a=60;););
			);
		);
	);
	v=[ang,saturation,shade_tint];
	add2ang();
	v;"

if $5>1
	if $5&1 +rep_hsl2ryb2rgb. else +rep_hsl2ryb2rgb. fi
else
	if $5&1 rep_hsl2ryb2rgb. else hsl2rgb. fi
fi

round.
#@cli rep_cubic_map: [image],_mode={ 0=neumann | 1=periodic | 2=periodic_smooth | 3=continuous }
#@cli : Map palette into image with cubic interpolation.
#@cli : Argument for mode can also use string. The valid strings are next to equal sign.
#@cli : Source for base of code - https://www.paulinternet.nl/?page=bicubic
#@cli : Author: Reptorian.
#@cli : Default values: '_mode=2'
rep_cubic_map:
skip ${2=2}

init_imgs={$!}

pass$1 1

if $!>$init_imgs+1 error inv_img_arg fi

length,threading_threshold={[whd,sqr(256)]}

if isint($2) mode={int($2)%4}
else
	neumann,periodic,periodic_smooth,continuous=0,1,2,3
	mode=$$2 if !narg($mode) error invalid_arg fi
fi

repeat $!-1 {

	if !s#$> continue fi

	reference_spectrum_size={s#$>}

	if whd#$>>$threading_threshold ps_mode=:
	else ps_mode=>
	fi

	{w#$>},{h#$>},{d#$>},{s*$reference_spectrum_size},$ps_mode"
		begin(
			const reference_spectrum_size=$reference_spectrum_size;
			const img_pos=$>;
			const length=$length;
			const mi=length-1;
			const smi=mi-1;
			const mode=$mode;

			cubic_interpolation(p0,p1,p2,p3,v)=(
				(-.5*p0+1.5*p1-1.5*p2+.5*p3)*v^3
				+(p0-2.5*p1+2*p2-.5*p3)*v^2
				+(-.5*p0+.5*p2)*v
				+p1
			);

			cubic_map()=cubic_interpolation(
				I[#-1,p_s],
				I[#-1,p_0],
				I[#-1,p_1],
				I[#-1,p_e],
				interp
			);

			mode?(
				calc()=cubic_map();
			):(
				calc()=(
					inrange(pref,0,smi,1,1)?(
						cubic_map();
					):(
						pref>0?I[#-1,mi]:I[#-1,0];
					);
				);
			);

			mode==3?(
				const double_length=mi*2;
				calc_ps()=(
					a=[pref-1,pref,pref+1,pref+2]%double_length;
					mi-abs(mi-a);
				);
			):
			mode>1?(
				calc_ps()=[pref-1,pref,pref+1,pref+2]%length;
			):(
				calc_ps()=[pref-1,pref,pref+1,pref+2];
			);

			reference_spectrum_size>1?(

				const pal_spectrum_size=s#-1;
				const new_spectrum_size=pal_spectrum_size*reference_spectrum_size;
				mode==1?(
					calc_vp()=(
						v=i(#img_pos,x,y,z,channel_position);
						mv=v%mi;
						vp=!mv?v>0?mi:mv;
					);
				):(
					calc_vp()=i(#img_pos,x,y,z,channel_position);
				);
				output()=(
					color_output=vector(#new_spectrum_size,0);
					repeat(reference_spectrum_size,channel_position,
						vp=calc_vp();
						pref=floor(vp);
						interp=vp-pref;
						ps=calc_ps();
						p_s=ps[0]; #Start Point
						p_0=ps[1];
						p_1=ps[2];
						p_e=ps[3]; #End Point
						copy(color_output[channel_position*pal_spectrum_size],calc(),s);
					);
					color_output;
				);

			):(

				mode==1?(
					calc_vp()=(
						v=i(#img_pos,x,y,z,0);
						mv=v%mi;
						vp=!mv?v>0?mi:mv;
					);
				):(
					calc_vp()=i(#img_pos,x,y,z,0);
				);
				output()=(
					vp=calc_vp();
					pref=floor(vp);
					interp=vp-pref;
					ps=calc_ps();
					p_s=ps[0]; #Start Point
					p_0=ps[1];
					p_1=ps[2];
					p_e=ps[3]; #End Point
					calc();
				);

			);
		);
		output();"

		reverse[$>,-1]
		remove[-1]

}

remove[-1]
#@cli rep_tco_anim: eq. to 'rep_three_coupled_oscillators_animation'
rep_tco_anim: rep_three_coupled_oscillators_animation $*
#@cli rep_three_coupled_oscillators_animation: _max_iter>0,-2pi<=_k_a_1<=2pi,-2pi<=_k_b_1<=2pi,-2pi<=_k_a_2<=2pi,-2pi<=_k_b_2<=2pi,_sublevel>=0,-360<=_ang_a<=360,-360<=_ang_b<=360,_ox_a,_oy_a,_ox_b,_oy_b,_axis_scale_a>0,_axis_scale_b>0
#@cli : Animation-based version of Bifurcation diagram for two-parameters of torus-map or three-coupled oscillators. [1]
#@cli :
#@cli : --- Citation ---
#@cli : 1) C. Baesens, J. Guckenheimer, S. Kim, R.S. MacKay
#@cli : Three coupled oscillators: mode-locking, global bifurcations and toroidal chaos
#@cli : Physica D: Nonlinear Phenomena, Volume 49, Issue 3, 1991, Pages 387-475, ISSN 0167-2789
#@cli : ------
#@cli :
#@cli : _max_iter is the number of iterations within the bifurcation diagram.
#@cli : _k_a_1 is the a-variable that influence the output for first frame.
#@cli : _k_b_1 is the b-variable that influence the output for first frame.
#@cli : _k_a_2 is the a-variable that influence the output for last frame.
#@cli : _k_b_2 is the b-variable that influence the output for last frame.
#@cli : _sublevel defines the degree of subpixel processing. 0 means no subpixel sampling. Negative  number in here means it will not be resized (Useful for mapping before downsizing to original image size.).
#@cli : _ang_a defines the angle of function for first frame.
#@cli : _ang_b defines the angle of function for last frame.
#@cli : _ox_a defines the x-offset of function for first frame.
#@cli : _oy_a defines the y-offset of function for first fraime.
#@cli : _ox_b defines the x-offset of function for last frame.
#@cli : _oy_b defines the y-offset of function for last frame.
#@cli : _axis_scale_a defines the scale of each axis for first frame.
#@cli : _axis_scale_b defines the scale of each axis for last frame.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_max_iter=50','_k_a_1=u(-2*pi,2*pi)','_k_b_1=u(-2*pi,2*pi)','_k_a_2=u(-2*pi,2*pi)','_k_b_2=u(-2*pi,2*pi)','_sublevel=1','_ang_a=0','_ang_b=0','_ox_a=0','_oy_a=0','_ox_b=0','_oy_b=1','_axis_scale_a=1','_axis_scale_b=1'
rep_three_coupled_oscillators_animation:
skip ${1=50},${2=},${3=},${4=},${5=},${6=1},${7=0},${8=180},{$9=0},${10=0},${11=0},${12=0},${13=1},${14=1}
check ${-max_d}>1
_rep_three_coupled_oscillators ${1-14}
#@cli rep_tco: eq. to 'rep_three_coupled_oscillators'
rep_tco: rep_three_coupled_oscillators $*
#@cli rep_three_coupled_oscillators: _max_iter>0,-2pi<=_k_a<=2pi,-2pi<=_k_b<=2pi,_sublevel>=0,-360<=_ang<=360,_ox,_oy,_axis_scale>0
#@cli : Bifurcation diagram for two-parameters of torus-map or three-coupled oscillators. [1]
#@cli :
#@cli : --- Citation ---
#@cli : 1) C. Baesens, J. Guckenheimer, S. Kim, R.S. MacKay
#@cli : Three coupled oscillators: mode-locking, global bifurcations and toroidal chaos
#@cli : Physica D: Nonlinear Phenomena, Volume 49, Issue 3, 1991, Pages 387-475, ISSN 0167-2789
#@cli : ------
#@cli :
#@cli : _max_iter is the number of iterations within the bifurcation diagram.
#@cli : _k_a is a variable that influence the output.
#@cli : _k_b is a variable that influence the output.
#@cli : _sublevel defines the degree of subpixel processing. 0 means no subpixel sampling. Negative  number in here means it will not be resized (Useful for mapping before downsizing to original image size.).
#@cli : _ang defines the angle of function.
#@cli : _ox defines the x-offset of function.
#@cli : _oy defines the y-offset of function.
#@cli : _axis_scale defines the scale of each axis.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_max_iter=50','_k_a=u(-2*pi,2*pi)','_k_b=u(-2*pi,2*pi)','_sublevel=1','_ang=0','_ox=0','_oy=0','_axis_scale=1'
rep_three_coupled_oscillators:
skip ${1=50},${2=},${3=},${4=1},${5=0},${6=0},${7=0},${8=1}

check ${-max_d}==1
_rep_three_coupled_oscillators ${1-8}

_rep_three_coupled_oscillators:
skip ${1=50},${2=},${3=},${4=},${5=}

check "abs($1)!=0&&$8!=0"

animation_mode=0
if ${-max_d}>1 animation_mode=1 if $!>1 error "One image only for animation mode!" fi fi

tau={pi*2}

if $animation_mode
	if narg($2) __k_a_1=$2
	else __k_a_1={u(-$tau,$tau)}
	fi

	if narg($3) __k_a_2=$3
	else __k_b_1={u(-$tau,$tau)}
	fi

	if narg($4) __k_b_1=$4
	else __k_a_2={u(-$tau,$tau)}
	fi

	if narg($5) __k_b_2=$5
	else __k_b_2={u(-$tau,$tau)}
	fi

	rescale_back={$6>0}

	__sub={abs($6)+1}
	command "cmd_$0_generate: +_rep_three_coupled_oscillators_animation $1,$__k_a_1,$__k_b_1,$__k_a_2,$__k_b_2,$__sub,${7-14}"

else
	if narg($2) __k_a=$2
	else __k_a={u(-$tau,$tau)}
	fi

	if narg($3) __k_b=$3
	else __k_b={u(-$tau,$tau)}
	fi

	rescale_back={$4>0}
	__sub={abs($4)+1}

	command "cmd_$0_generate: +_rep_three_coupled_oscillators_static_out $1,$__k_a,$__k_b,$__sub,${5-8}"

fi

foreach {

	cmd_$0_generate

	if $rescale_back r. {w#0},{h#0},100%,100%,6 fi

	rm..

}

uncommand cmd_$0_generate
+_rep_three_coupled_oscillators_animation:
check "$13!=0&&$14!=0"

	{w*$6},{h*$6},{d},1,"*begin(
			const max_iter=abs($1);
			const ww=w-1;
			const hh=h-1;
			const dd=d-1;
			const sd=max(ww,hh)/min(ww,hh);
			const sx=w>h?sd:1;
			const sy=w>h?1:sd;
			const cx=ww/2;
			const cy=hh/2;
			const ox_a=($9+1)*cx;
			const oy_a=($10+1)*cx;
			const ox_b=(($11*-1)+1)*cy;
			const oy_b=(($12*-1)+1)*cy;
			const axis_scale_a=$13;
			const axis_scale_b=$14;
			const cxsx=cx/sx;
			const cysy=cy/sy;
			const cxsx_a=cxsx/axis_scale_a;
			const cxsx_b=cxsx/axis_scale_b;
			const cysy_a=cysy/axis_scale_a;
			const cysy_b=cysy/axis_scale_b;
			const ang_a=-$7;
			const ang_b=-$8;
			set_cos_ang=vectord();
			set_sin_ang=set_cos_ang;
			fill(set_cos_ang,p,cos(deg2rad(lerp(ang_a,ang_b,p/dd))));
			fill(set_sin_ang,p,sin(deg2rad(lerp(ang_a,ang_b,p/dd))));
			const tau=2*pi;
			const k_a_1=$2;
			const k_b_1=$3;
			const k_a_2=$4;
			const k_b_2=$5;
			const tc=.7/tau;
			rot_x(a,b,c)=a*set_cos_ang[c]-b*set_sin_ang[c];
			rot_y(a,b,c)=a*set_sin_ang[c]+b*set_cos_ang[c];
			oscil_a(a,b,c)=a+c-tc*sin(tau*b);
			oscil_b(a,b,c)=a+c-tc*sin(tau*b);
		);
		zp=z/dd;
		ix=(x-lerp(ox_a,ox_b,zp))/lerp(cxsx_a,cxsx_b,zp);
		iy=(y-lerp(oy_a,oy_b,zp))/lerp(cysy_a,cysy_b,zp);
		xp=rot_x(ix,iy,z);
		yp=rot_y(ix,iy,z);
		k_a=lerp(k_a_1,k_b_1,zp);
		k_b=lerp(k_a_2,k_b_2,zp);
		repeat(max_iter,
			txp=xp;
			xp=oscil_a(xp,yp,k_a);
			yp=oscil_b(yp,txp,k_b);
		);
		norm(xp,yp);"

+_rep_three_coupled_oscillators_static_out:
check "$8!=0"

	{w*$4},{h*$4},1,1,*"begin(
			const max_iter=abs($1);
			const ww=w-1;
			const hh=h-1;
			const sd=max(ww,hh)/min(ww,hh);
			const sx=w>h?sd:1;
			const sy=w>h?1:sd;
			const cx=ww/2;
			const cy=hh/2;
			const ox=($6+1)*cx;
			const oy=(($7*-1)+1)*cy;
			const axis_scale=abs($8);
			const cxsx=cx/sx/axis_scale;
			const cysy=cy/sy/axis_scale;
			const ang=-($5/180)*pi;
			const cos_ang=cos(ang);
			const sin_ang=sin(ang);
			const tau=2*pi;
			const k_a=$2;
			const k_b=$3;
			const tc=.7/tau;
			rot_x(a,b)=a*cos_ang-b*sin_ang;
			rot_y(a,b)=a*sin_ang+b*cos_ang;
			oscil_a(a,b)=a+k_a-tc*sin(tau*b);
			oscil_b(a,b)=a+k_b-tc*sin(tau*b);
		);
		ix=(x-ox)/cxsx;
		iy=(y-oy)/cysy;
		xp=rot_x(ix,iy);
		yp=rot_y(ix,iy);
		repeat(max_iter,
			txp=xp;
			xp=oscil_a(xp,yp);
			yp=oscil_b(yp,txp);
		);
		norm(xp,yp);"
#@cli rep_permutations: init_num,_axis={x,y,z}
#@cli : Return all the permutations of set of numbers as a image.
#@cli :
#@cli : Finding the next permutation has been adapted from this link -> https://www.techiedelight.com/find-permutations-string-cpp-java-iterative/
#@cli : Finding the permutation at point index within this code is of the author.
#@cli : Author : Reptorian.
#@cli : Default values: '_axis=x'
+rep_permutations:
skip ${2=x}

check "inrange($1,0,10,1,1)&&$1==int($1)&&inrange(('$2')[0],_'x',_'z',1,1)"

if $1==1 1 return fi

old_status=${}

axis,fact_size={_'$2'-_'x'},{fact($1)}

{v=vector(#3,1);v[$axis]=$fact_size;v},$1

if $1>7 mode=: else mode=> fi

+rep_mt_f32v_map {[whd#-1,(_'$mode'==_':'?whd#-1>>14)]},0
eval. $mode"
	const S=s#-2;
	const max_index=S-1;
	const dec_max_index=max_index-1;

	permutation=expr('x',S);

	reverse_array_starting_from(a)=(
		start=a;
		end=max_index;
		while(start<end,
			swap(permutation[start++],permutation[end--]);
		);
	);

	move_ind(a,b)=a!=b?(
		t_val=permutation[a];
		copy(permutation[b+1],permutation[b],a-b,1,1);
		permutation[b]=t_val;
	);

	t=J(-1);
	p=t[0]<<24|t[1];

	if(index=p,
		fn=max_index;
		repeat(fn,q,
			division_number=fact(fn);
			pos=int(index/division_number);
			move_ind(q+pos,q);
			index-=pos*division_number;
			--fn;
		);
	);

	I[#-2,p]=permutation;

	i=i0<<24|i1;
	while(++p<i,
		fn=b=max_index;
		while(permutation[fn-1]>=permutation[fn],--fn;if(!fn,break();););
		while(b>fn&&permutation[b]<=permutation[fn-1],--b;);
		swap(permutation[fn-1],permutation[b]);
		reverse_array_starting_from(fn);
		I[#-2,p]=permutation;
	);
	"

rm. u $old_status
#@cli rep_permutation_index2list: number_of_item,permutation_number
#@cli : Return permutation order at index permutation_number.
rep_permutation_index2list:

num_of_items={max(1,int(abs($1)))}

if $num_of_items==1 u 0
else
	eval "
		const num_of_items=$num_of_items;
		const num_of_possible_permutations=fact(num_of_items);
		permutation_position=$2%num_of_possible_permutations;

		output=expr('x',num_of_items);

		permutation_position==num_of_possible_permutations-1?(
			reverse(output);
		):(
			if(permutation_position,
				move_ind(a,b)=a!=b?(
						t_val=output[a];
						copy(output[b+1],output[b],a-b,1,1);
						output[b]=t_val;
					);

				fn=num_of_items-1;
				repeat(fn,p,
					division_number=fact(fn);
					pos=int(permutation_position/division_number);
					move_ind(p+pos,p);
					permutation_position-=pos*division_number;
					--fn;
				);
			);

			output;
		);"
fi
#@cli rep_permutation_list2index: number_list
#@cli : Return the lexicographic index in which this permutation is found within a list of all possible permutation.
#@cli :
#@cli : number_list must be in the form of 0,1,2,3.... , but can be in any order.
#@cli :
#@cli : Note: Not the derived source code, but really close to the original one and can be inferred to be operating on the same logic. Arguably the same after inspection. - https://www.geeksforgeeks.org/lexicographic-rank-of-a-string/ . Derived source code author is unknown.
rep_permutation_list2index:
if $#>1
	if sort([$*])==expr('x',$#)
		if [$*]==expr('x',$#) u 0
		else
			eval "
				const fn=$#-1;
				iv=[$*];
				p=0;
				repeat(fn,k,
					v=iv[k];
					repeat(k,m,
						if(iv[m]<iv[k],--v);
					);
					p+=v*fact(fn-k);
				);
				p;
				"
		fi
	else
		error inv_args
	fi
else
	u 0
fi
#@cli rep_npr_permutations: number_of_items,selected_items_count,_axis={x|y|z}
#@cli : Generates partial combination. P(n,k)
#@cli : Note - Code is taken from Alistairisrael pseudo-code - https://alistairisrael.wordpress.com/2009/09/22/simple-efficient-pnk-algorithm/
#@cli : Default values: '_axis=x'
+rep_npr_permutations:
skip ${3=x}

check "($1>=$2&&$1>0&&isint($1))&&($2>0&&isint($2))&&inrange(_'$3',_'x',_'z',1,1)"

if [${1-2}]==[1,1] 1 return fi

num_of_permutations,axis={perm($2,$1,1)},{_'$3'-_'x'}

if $axis==2   out_dim=1,1,$num_of_permutations
elif $axis==1 out_dim=1,$num_of_permutations,1
else          out_dim=$num_of_permutations,1,1
fi

if $2==1 $out_dim,1,${arg0\ $axis,x,y,z} return fi

old_status=${}

$out_dim,$2
+rep_mt_f32v_map {[whd#-1,whd#-1>>12]},0
eval. :"
	const s=s#-2;
	const edge=s-1;
	const n=$1;
	const dec_n=n-1;

	output=expr('x',n);

	reverse_array_starting_from(a)=(
		start=a;
		end=dec_n;
		while(start<end,
			swap(output[start++],output[end--]);
		);
	);

	move_ind(a,b)=a!=b?(
		t_val=output[a];
		copy(output[b+1],output[b],a-b,1,1);
		output[b]=t_val;
	);

	division_numbers_arr=expr('begin(
			const m=($1==$2?1:$1-$2)+1;
			v=m;
		);
		x>1?v=v*(m+x-1):(x?v:1);'
	,1+($1==$2?$1-2:min($1-1,$2-1)));

	const size_dna=size(division_numbers_arr);

	t=J(-1);
	p=t[0]<<24|t[1];

	if(index=p,
		divisor_position=size_dna-1;
		repeat(size_dna,q,
			division_number=division_numbers_arr[divisor_position];
			pos=int(index/division_number);
			move_ind(q+pos,q);
			index%=division_number;
			--divisor_position;
		);
	);

	I[#-2,p]=output[0,s];

	i=i0<<24|i1;
	while(++p<i,
		z=s;
		while(z<n && (output[edge]>=output[z]),++z;);

		z<n?(
			swap(output[edge],output[z]);
		):(
			reverse_array_starting_from(s);

			y=edge-1;
			while(y>=0 && output[y]>=output[y+1],--y;);

			z=dec_n;
			while(z>y && (output[y]>=output[z]),--z;);

			swap(output[y],output[z]);

			reverse_array_starting_from(y+1);
		);

		I[#-2,p]=output[0,s];
	);
	"
rm. u $old_status
#@cli rep_npr_permutation_index2list: number_of_item,selected_items_count,permutation_number
#@cli : Return permutation order at index permutation_number.
rep_npr_permutation_index2list:
check "$2<=$1&&$1>0&&$2>0"

if $1==1 status 0
elif $2==1 status {$3%$1}
else
	eval "
		output=expr('x',n);

		const possible_permutations=perm($2,$1,1);
		const dec_possible_permutations=possible_permutations-1;
		index=$3%perm($2,$1,1);

		!index?(
			(output)[0,$2];
		):
		index==dec_possible_permutations?(
			(reverse(output))[0,$2];
		):(
			division_numbers_arr=expr('begin(
					const m=($1==$2?1:$1-$2)+1;
					v=m;
				);
				x>1?v=v*(m+x-1):(x?v:1);'
				,1+($1==$2?$1-2:min($1-1,$2-1)));

			move_ind(a,b)=a!=b?(
				t_val=output[a];
				copy(output[b+1],output[b],a-b,1,1);
				output[b]=t_val;
			);

			const size_dna=size(division_numbers_arr);
			divisor_position=size_dna-1;
			repeat(size_dna,p,
				division_number=division_numbers_arr[divisor_position];
				pos=int(index/division_number);
				move_ind(p+pos,p);
				index%=division_number;
				--divisor_position;
			);

			(output)[0,$2];
		);"
fi
#@cli rep_npr_permutation_list2index: number_of_items,number_list
#@cli : Return the lexicographic index in which this permutation is found within a list of all possible permutations.
#@cli :
#@cli : number_list must be in the form of 0,1,2,3.... , but can be in any order. However, the size of it must be less than or equal to number_of_items. That means you can exclude some numbers.
rep_npr_permutation_list2index:
check "$1>0&&($#-1)<=$1"

n_items,n_list_size={[$1>1,$#-1]}

if $#==2&&$n_items status {$2%#1}
elif $#>2&&$n_items

	eval "
		const limit=$1-1;
		counters=vector(#$1,0);
		test_vector=[${2--1}];
		repeat(size(test_vector),p,
			v=test_vector[p];
			if(!isint(v),run('error all_todo_ints==F'););
			if(!inrange(v,0,limit,1,1),run('error int_lim_exc'););
			if(++counters[v]>1,run('error dups_found'););
		);
		"

	{1+($1==$n_list_size?$1-2:min($1-1,$n_list_size-1))},1,1,1,>"begin(
			const m=($1==$n_list_size?1:$1-$n_list_size)+1;
			v=m;
		);
		x>1?v=v*(m+x-1):(x?v:1);"

	eval "
			const n_list_size=min($n_list_size,$1-1);
			iv=[${2--1}];
			p=0;
			repeat(n_list_size,k,
				v=iv[k];
				repeat(k,m,
					if(iv[m]<iv[k],--v);
				);
				p+=v*i[#-1,(n_list_size-k-1)];
			);
			p;
		"

	rm.
else
	status 0
fi
#@cli rep_r_permutations: number_of_items, repetition,_axis={ x|y|z} : -number_of_items>0, occurance_per_items,_axis={ x|y|z}
#@cli : Create image representing permutations with repeating numbers.
+rep_r_permutations:
skip ${3=x}
+rep_cartesian_product {vector(#$2,$1)},$3
#@cli rep_r_permutation_index2list: times_items_can_repeat, repetition, position
#@cli : Return the list of numbers which correspond to the index provided based on permutations with repetition.
rep_r_permutation_index2list:
rep_cartesian_product_index2list {vector(#$2,$1)},$3
#@cli rep_r_permutation_list2index: number_of_items/occurance, item_index_a,item_index_b
#@cli : Return the lexicographic index in which the list of numbers corresponds to the lexicographically-ordered list of permutations with repetitions. Note that number_of_items and occurance is exchangeable.
rep_r_permutation_list2index:
rep_cartesian_product_list2index {vector(#$#-1,$1)},${2--1}
#@cli rep_ncr_combinations: number_of_items>0,choices>0,_axis={x,y,z} : choices>0, number_of_items>0,_axis={x,y,z}
#@cli : Generates all combinations that fits nCr. The algorithm used for this is based on Algorithm 515 (Buckles and Lybanon 1977) which allows index-based generation of combinations.
#@cli :
#@cli : Code has been adapted from sleeepjack's Python 2 code executing Algorithm 515 only in case when non-zero index is used to find combination at a point - https://github.com/sleeepyjack/alg515/blob/master/python/alg515.py
#@cli :
#@cli : Note: If $2 is greater than $1, then $2 is number of items and $1 is choices. Only positive integer numbers are accepted!
#@cli : Default values: '_axis=x'
+rep_ncr_combinations:
skip ${3=x}

check "($1>0&&$2>0)&&(isint($1)&&isint($2))&&inrange(_'$3',_'x',_'z',1,1)"

if $1==$2 1,1,1,$1,c return fi

choices,n_items:=sort([$1,$2])

if $choices==1 $n_items,1,1,1,x return fi

old_status=${}

num_combs,axis:=perm($choices,$n_items,0),_'$3'-_'x'

if $num_combs>33554432 error excess_combs fi

{v=[1,1,1];v[$axis]=$num_combs;v},$choices
+rep_mt_f32v_map {[whd#-1,whd#-1>>13]},0
eval. :"
	const S=s#-2;
	const n_items=$n_items;
	const start_K=n_items-2;
	const max_index=S-1;
	const dec_max_index=max_index-1;
	const IR=perm(max_index,n_items-1,0);

	comb=vector(#S,0);
	ref_comb=expr('x+1',n_items-1);
	copy(comb[1],ref_comb[0],S-1);

	t=J(-1);
	p=t[0]<<24|t[1];

	if(index=p,
		V=1;
		R=IR;
		K=R;

		while(K<=index,
			++V;
			R=perm(max_index,n_items-V,0);
			K+=R;
		);

		K-=R;
		comb[0]=V-1;

		for(q=2,q<S,++q,
			sp=S-q;
			++V;
			R=perm(sp,n_items-V,0);
			K+=R;
			while(K<=index,
				++V;
				R=perm(sp,n_items-V,0);
				K+=R;
			);
			K-=R;
			comb[q-1]=V-1;
		);

		comb[max_index]=V+index-K;
	);

	I[#-2,p]=comb;

	i=i0<<24|i1;
	while(++p<i,
		++comb[max_index]==n_items?(
			K=start_K;
			for(R=dec_max_index,comb[R]==K,--K;--R;);
			copy(comb[R],ref_comb[comb[R]],S-R);
		);
		I[#-2,p]=comb;
	);
	"
rm. u $old_status
#@cli rep_ncr_combination_index2list: number_of_items,choices,index : choices, number_of_items,index
#@cli : Return ncr combination at index. The algorithm used for this is based on Algorithm 515 (Buckles and Lybanon 1977) which allows index-based generation of combinations.
#@cli :
#@cli : Code has been adapted from sleeepjack's Python 2 code executing Algorithm 515 - https://github.com/sleeepyjack/alg515/blob/master/python/alg515.py
#@cli :
#@cli : Note: If $2 is greater than $1, then $2 is number of items and $1 is choices. Only positive integer numbers are accepted!
rep_ncr_combination_index2list:
check "($1>0&&$2>0)&&(isint($1)&&isint($2))"

if $1==$2 u {expr('x',$1)} return fi

if $1>$2 n_items,choices=$1,$2
else n_items,choices=$2,$1
fi

num_combs={perm($choices,$n_items,0)}
index={$3%$num_combs}

eval "
	const n_items=$n_items;
	const choices=$choices;
	const index=$index;

	comb=vector(#choices,0);
	V=1;
	R=perm(choices-1,n_items-V,0);
	K=R;

	while(K<=index,
		++V;
		R=perm(choices-1,n_items-V,0);
		K+=R;
	);
	K-=R;
	comb[0]=V-1;

	for(p=2,p<choices,++p,
		++V;
		R=perm(choices-p,n_items-V,0);
		K+=R;
		while(K<=index,
			++V;
			R=perm(choices-p,n_items-V,0);
			K+=R;
		);
		K-=R;
		comb[p-1]=V-1;
	);

	comb[choices-1]=V+index-K;

	comb;"
#@cli rep_ncr_combination_list2index: number_items,position_a...position_n
#@cli : Return the lexicographic index in which this ncr combination is found within a list of all possible ncr combination. Code is based off the author's code here - https://stackoverflow.com/questions/14455634/find-the-index-of-a-given-combination-of-natural-numbers-among-those-returned
#@cli :
#@cli : position(s) variable(s) must not have repeating number. Order does not matter.
rep_ncr_combination_list2index:
pos_args={$#-1}

eval "
	const number_of_items=int(abs($1));
	const v_size=min(number_of_items,$pos_args);

	v_pos_args=vector(#v_size,${2--1})%number_of_items;
	v_test=vector(#number_of_items,0);

	n=number_of_items+1;
	pos=idx=last_c=0;
	k=v_size;

	repeat(v_size,p,
		pos=v_pos_args[p];
		if(!v_test[pos],v_test[pos]++;,run('error dup_args'););
	);

	v_pos_args=sort(v_pos_args);
	++v_pos_args;

	repeat(v_size,ind,
		c=v_pos_args[ind];
		idx+=perm(k,n-1,0)-perm(k,n-c+last_c,0);
		n-=c-last_c;
		--k;
		last_c=c;
	);

	idx;"
#@cli rep_r_combinations: number_of_items>0,choices>0,_axis={x,y,z}
#@cli : Create image representing combinations given number of items and choices with repeating numbers. Empty item is a item by itself.
#@cli : Code to find combinations given index is taken from Joseph Wood at codereview.stackexchange - https://codereview.stackexchange.com/questions/285415/find-the-list-of-combination-with-repetition-given-rank-and-number-of-items/287944#287944
#@cli : Author : Reptorian.
+rep_r_combinations:
skip ${3=x}

check "($1>0&&$2>0)&&(isint($1)&&isint($2))&&inrange(_'$3',_'x',_'z',1,1)"

old_status=${}

n_items,choices=$1,$2
num_combs,axis:=perm($choices,$n_items+$choices-1,0),_'$3'-_'x'

out_dim={D=[1,1,1];D[$axis]=$num_combs;D;}

$out_dim,$choices
+rep_mt_f32v_map {[whd#-1,whd#-1>>13]},0
eval. :"
	const S=s#-2;
	const n_items=$n_items;
	const max_ind=S-1;
	comb=vector(#S,0);

	t=J(-1);
	p=t[0]<<24|t[1];

	if(m_index=p,
		m_items=n_items;
		m_choices=$choices;
		temp=perm(m_choices-1,m_items+m_choices-2,0);
		--m_choices;
		item_choice=0;
		repeat($choices,k,
			while(temp<=m_index,
				m_index-=temp;
				temp*=m_items-1;
				temp=int(temp/(m_items+m_choices-1));
				--m_items;
				++item_choice;
			);
			temp*=m_choices;
			if((m_items+m_choices)>2,temp=int(temp/(m_items+m_choices-1)););
			comb[k]=item_choice;
			--m_choices;
		);
	);

	I[#-2,p]=comb;

	i=i0<<24|i1;
	while(++p<i,
		if(++comb[max_ind]==n_items,
			for(q=max_ind-1,q>-1,--q,
				if(++comb[q]<n_items,
					break();
				);
			);
			copy(comb[q+1],comb[q],max_ind-q,1,0);
		);
		I[#-2,p]=comb;
	);
	"
rm. u $old_status
#@cli rep_r_combination_index2list: n,k,index
#@cli : Return the list of numbers which correspond to the index provided based on a list of all possible combinations with repetition.
#@cli : Code is taken from Joseph Wood at codereview.stackexchange - https://codereview.stackexchange.com/questions/285415/find-the-list-of-combination-with-repetition-given-rank-and-number-of-items/287944#287944
#@cli : Author : Reptorian.
rep_r_combination_index2list:
check "sum(isint([${1-2}]))==2&&$1>1&&$2>0&&$#==3"

eval "
	m_items=$1;
	m_choices=$2;
	m_index=$3%perm(m_choices,m_items+m_choices-1,0);
	output_list=vector(#$2,0);
	temp=perm(m_choices-1,m_items+m_choices-2,0);
	--m_choices;
	item_choice=0;
	repeat($2,k,
		while(temp<=m_index,
			m_index-=temp;
			temp*=m_items-1;
			temp=int(temp/(m_items+m_choices-1));
			--m_items;
			++item_choice;
		);
		temp*=m_choices;
		if((m_items+m_choices)>2,temp=int(temp/(m_items+m_choices-1)););
		output_list[k]=item_choice;
		--m_choices;
	);
	output_list;"
#@cli rep_r_combination_list2index: number_of_items,index_a,index_b,...
#@cli : Return the index which correspond to the list of numbers provided based on a list of all possible combinations with repetition.
#@cli : Note: All numbers must be in range [0,number_of_items). They must be in integer only.
#@cli : Author : Reptorian.
rep_r_combination_list2index:
check "const v=$#;sum(isint([$*]))==v&&$1>-1&&(sum(inrange([${2--1}],0,$1,1,0))==v-1)"

if !$1
	status nan return
elif $#-1==1
	status {$2%$1} return
elif !sum(${2--1})
	status 0 return
fi

eval "
	const n_items=$1;
	const max_ind=n_items-1;
	const kv=$#-1;
	series_of_indexes=sort([${2--1}]);
	Tc=kv;
	index=0;
	a=perm(kv,n_items+kv-1,0);
	repeat(kv-1,p,
		v_ind_p=series_of_indexes[p];
		diff=kv-v_ind_p;
		sum_nd=n_items+diff-p;
		b=perm(Tc,sum_nd-1,0);
		index+=a-b;
		if(v_ind_p==max_ind,break(););
		a=b-perm(Tc,sum_nd-2,0);
		--Tc;
	);
	index+=series_of_indexes[kv-1]-series_of_indexes[kv-2];
	index;"
#@cli rep_cartesian_product: number_of_items_a,number_of_items_b,...,_axis
#@cli : Output image representing cartesian product based on input.
#@cli : Default values: '_axis=x'
+rep_cartesian_product:
if isnum($-1)&&isint($-1)
	axis,user_xyz=0
elif inrange(_'$-1',_'x',_'z',1,1)
	axis,user_xyz={_'$-1'-_'x'},1
else
	error invalid_char
fi

vars2chk={$#-$user_xyz}
v_list={abs(([$*])[0,$vars2chk])}
n_vars_isint,all_valid={v=[$v_list];[sum(isint(v)),min(v)]}

if !$all_valid error var_0_error fi
if $n_vars_isint!=$vars2chk invalid_var_inp fi

dims,s_size={v=[$v_list];[prod(v),size(v)];}

if $dims>33554432 error dims_lim_exc fi

dims={v=vector(#3,1);v[$axis]=$dims;v;}

if max($v_list)==1 1,1,1,$s_size return
elif $s_size==1 $dims,1,${arg0\ $axis,x,y,z} return
fi

old_status=${}

$dims,$s_size
+rep_mt_f32v_map {[whd#-1,whd#-1>>12]},0
eval. :"
	const S=s#-2;
	const d_s=S-1;
	const dec_d_s=d_s-1;
	items_list=["$v_list"];

	t=J(-1);
	p=t[0]<<24|t[1];

	p?(
		div_list=vector(#S,1);
		tv=1;
		repeat(d_s,q,
			div_list[dec_d_s-q]=tv*=items_list[d_s-q];
		);
		v=int(p/div_list)%items_list;
	):(
		v=vector(#S,0);
	);

	--items_list;

	I[#-2,p]=v;

	i=i0<<24|i1;
	while(++p<i,
		q=d_s;
		while(v[q]==items_list[q],
			v[q]=0;
			--q;
		);
		++v[q];
		I[#-2,p]=v;
	);"

rm. u $old_status
#@cli rep_cartesian_product_index2list: number_of_items_a,number_of_items_b,...,index
#@cli : Return the list of numbers which correspond to the index provided. Every arguments must be a integer.
rep_cartesian_product_index2list:
check "sum(isint([$*]))==$#"

max_int={max(abs([${1--2}]))}

if $max_int==1
	status {vector(#($#-1),0)} return
elif !$max_int
	error var_0_error
fi

eval "
	const size_of_array=$#-1;
	const d_s=size_of_array-1;
	const dec_d_s=d_s-1;
	items_list=abs([${1--2}]);
	position=$-1%prod(items_list);
	div_list=vector(#size_of_array,1);
	tv=1;
	repeat(d_s,p,
		div_list[dec_d_s-p]=tv*=items_list[d_s-p];
	);
	int(position/div_list)%items_list;"
#@cli rep_cartesian_product_list2index: number_of_items_a,number_of_items_b,...,coordinate_a,coordinate_b,...
#@cli : Return the index in which the coordinates is seen in a box of size number_of_items_a*number_of_items_b....
rep_cartesian_product_list2index:
if $#&1 error inv_args_count fi

eval "
	const half_list_size=$#>>1;
	m=half_list_size-1;
	items_count=int(abs([${1--1}][0,half_list_size]));
	positions=int(abs([${1--1}])[half_list_size,half_list_size])%items_count;
	items_count=shift(items_count,-1,0);
	++items_count[m];
	while(m--,items_count[m]*=items_count[m+1];);
	dot(positions,items_count);"
#@cli rep_rde_permutations: item_0_count,item_1_count,...,_axis={x,y,z}
#@cli : Generate all of the unique permutations of repeated distinct elements of different count as a image.
#@cli :
#@cli : Algorithm is based on the implementation of Narayana Pandita's algorithm by PM 2Ring at stackoverflow.
#@cli : Implementation of Narayana Pandita's algorithm -  https://stackoverflow.com/questions/8306654/finding-all-possible-permutations-of-a-given-string-in-python
#@cli : Description of Narayana Pandita's algorithm - https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order
#@cli : Author : Reptorian.
#@cli : Default values: '_axis=x'
+rep_rde_permutations:
check "$#>=1"

old_status=${}

if isnum($-1)
	items_count=${1--1}
	axis=0
else
	check "inrange(_'$-1',_'x',_'z',1,1)"
	items_count=${1--2}
	axis={_'$-1'-_'x'}
fi

check "items_counts=["$items_counts"];
       ( sum( isint(items_counts,1) ) == size(items_counts) );"

total_items_count,number_of_possible_permutations={"
		groups_of_items_counts=["$items_count"];
		total_items_count=sum(groups_of_items_counts);
		[total_items_count,fact(total_items_count)/prod(fact(groups_of_items_counts))]"}

if $number_of_possible_permutations>(1<<24)
	error exc_permut_val:$number_of_string_permutations
fi

if ($number_of_possible_permutations*$total_items_count)>0x20000
	p_mode=:
else
	p_mode=>
fi

out_dim={v=vector(#3,1);v[$axis]=$number_of_possible_permutations;v}

$out_dim,$total_items_count
+rep_mt_f32v_map {[whd#-1,(_'$p_mode'==_':'?$_cpus:1)]},0
eval. :"
	const S=s#-2;

	const max_index=S-1;
	const dec_max_index=max_index-1;

	const t_items=$total_items_count;
	const n_perms=$number_of_possible_permutations;

	items_group_count=["$items_count"];
	permutation=vector(#t_items);

	q=0;
	repeat(size(items_group_count),p,
		count=items_group_count[p];
		copy(permutation[q],p,count,1,0);
		q+=count;
	);

	reverse_array_starting_from(a)=(
		start=a;
		end=max_index;
		while(start<end,
			swap(permutation[start++],permutation[end--]);
		);
	);

	move_ind(a,b)=(
		t_val=permutation[a];
		a!=b?(
			copy(permutation[b+1],permutation[b],a-b,1,1);
			permutation[b]=t_val;
		);
	);

	t=J(-1);
	p=t[0]<<24|t[1];

	if(index=p,
		level_length=n_perms;
		for(V=[0,t_items],index,V+=[1,-1],
			section_size=level_length/V[1];
			selected_indice=int(index/section_size);

			move_ind(V[0]+selected_indice,V[0]);

			level_length=section_size*items_group_count[t_val];
			--items_group_count[t_val];

			repeat(t_val,q,
				index-=items_group_count[q]*section_size;
			);
		);
	);

	I[#-2,p]=permutation;

	i=i0<<24|i1;
	while(++p<i,
		for(jp=dec_max_index,jp>-1,--jp,
			if(permutation[jp]<permutation[jp+1],break(););
		);

		v=permutation[jp];
		for(kp=max_index,kp>jp,--kp,
			if(v<permutation[kp],break(););
		);

		swap(permutation[kp],permutation[jp]);
		reverse_array_starting_from(jp+1);

		I[#-2,p]=permutation;
	);
	"
rm. u $old_status
#@cli rep_rde_permutation_index2list: item_0_count>=1,item_1_count>=1,...,index
#@cli : Return permutations of repeated distinct elements of different count which correspond to the index.
#@cli :
#@cli : Author: Reptorian.
rep_rde_permutation_index2list:
check "($#>1) && (sum([${1--2}]>1)==($#-1))"

total_items_count={sum(${1--2})}
if $total_items_count>18 error exec_items_count fi
number_of_possible_permutations={fact($total_items_count)/prod(fact([${1--2}]))}

eval "
	const tic=$total_items_count;
	items_group_count=[${1--2}];
	all_items=vector(#tic);
	q=0;
	repeat(size(items_group_count),p,
		count=items_group_count[p];
		copy(all_items[q],p,count,1,0);
		q+=count;
	);

	const perms_possible=$number_of_possible_permutations;
	const dec_perms_possible=perms_possible-1;
	level_length=perms_possible;
	index=$-1%perms_possible;

	!index?(
		all_items;
	):
	index==dec_perms_possible?(
		reverse(all_items);
	):(
		move_ind(a,b)=(
			t_val=all_items[a];
			a!=b?(
				copy(all_items[b+1],all_items[b],a-b,1,1);
				all_items[b]=t_val;
			);
		);

		for(V=[0,tic],index,V+=[1,-1],
			section_size=level_length/V[1];
			selected_indice=int(index/section_size);

			move_ind(V[0]+selected_indice,V[0]);

			level_length=section_size*items_group_count[t_val];
			--items_group_count[t_val];

			repeat(t_val,q,
				index-=items_group_count[q]*section_size;
			);
		);

		all_items;
	);"
#@cli rep_rde_permutation_list2index: item_group_index_0,item_group_index_1,...
#@cli : Return the index which corresponds to the permutation of multiple repeated different elements of different counts.
#@cli : Code adapted from rahul sharma at geeksforgeeks - https://ide.geeksforgeeks.org/6YsMwFEHpH
#@cli :
#@cli : Note: Group_index are often multiple number of the same number. All number must be a integer within boundary [0,$#). All integers within those range must show up at least once.
#@cli :
#@cli : Author: Reptorian.
rep_rde_permutation_list2index:
check "
	list2check=[$*];
	temp_list=vector(#$#);
	min_val=min(list2check);
	max_val=max(list2check);
	!min_val&&max_val<$#?(
		repeat(size(list2check),p,++temp_list[list2check[p]];);
		repeat(max_val,p,if(!(valid=temp_list[p]),break();););
		set('size',max_val+1);
		set('list',v2s(temp_list););
		valid;
	);"

eval "
	item_group_counts=(["$list"])[0,$size];
	list_of_number_arguments=[$*];
	mul=fact($#);
	index=0;
	repeat($#,p,
		mul/=$#-p;
		sum=0;
		d_fac=1;
		loc=list_of_number_arguments[p];
		repeat(size(item_group_counts),q,
			t=item_group_counts[q];
			q<loc?(sum+=t);
			d_fac*=fact(t);
		);
		index+=(mul*sum)/d_fac;
		--item_group_counts[loc];
	);
	index;
	"
#@cli rep_rde_combinations: selected_count,item_0_count>=1,item_1_count>=1,...,_axis={x,y,z}
#@cli : Generates all possible combinations of repeated distinct elements of different counts, and the total number of elements is equal to the selected_count.
#@cli :
#@cli : Default values: '_axis=x'
+rep_rde_combinations:
check "isint($1,1)&&$#>1"

if isnum($-1)
	items_counts=${2--1}
	axis=0
else
	check "inrange(_'$-1',_'x',_'z',1,1)"
	items_counts=${2--2}
	axis={_'$-1'-_'x'}
fi

check "items_counts=["$items_counts"];
       ( sum( isint(items_counts,1) ) == size(items_counts) ) && ($1 <= sum(items_counts) );"

number_of_possible_combinations={([${_rep_rde_combination_sizes_from_right\ $1,$items_counts}])[0]}
if $number_of_possible_combinations>(1<<24) error exc_combin_size:$number_of_possible_combinations fi

out_dim={v=vector(#3,1);v[$axis]=$number_of_possible_combinations;v}

$out_dim,$1,>"begin(
		items_count=["$items_counts"];
		const number_of_sets_of_items=size(items_count);
		const last_item_pos=number_of_sets_of_items-1;

		result_vector=end_vector=vector(#$1);

		const size_result_vector=size(result_vector);
		const last_result_vector_pos=size_result_vector-1;
		const start_compare_pos=last_result_vector_pos-1;

		inserted_current_element_count=temp_pos=0;

		repeat(size_result_vector,pos,
			result_vector[pos]=temp_pos;

			if(++inserted_current_element_count==items_count[temp_pos],
				++temp_pos;
				inserted_current_element_count=0;
			);
		);

		pos=last_result_vector_pos;
		temp_pos=last_item_pos;
		inserted_current_element_count=0;

		repeat(size_result_vector,
			end_vector[pos--]=temp_pos;

			if(++inserted_current_element_count==items_count[temp_pos],
				--temp_pos;
				inserted_current_element_count=0;
			);
		);

		--result_vector[last_result_vector_pos];
	);

	if(++result_vector[last_result_vector_pos]==number_of_sets_of_items,
		compare_pos=start_compare_pos;

		do(if(result_vector[compare_pos]!=end_vector[compare_pos],break(););
			--compare_pos;
		,compare_pos>=0);

		selected_item=result_vector[compare_pos]+1;
		inserted_current_element_count=0;

		do(
			result_vector[compare_pos++]=selected_item;

			if(++inserted_current_element_count==items_count[selected_item],
				++selected_item;
				inserted_current_element_count=0;
			);
		,compare_pos<size_result_vector);
	);

	result_vector;"
#@cli rep_rde_combination_index2list: selected_count,item_0_count,item_1_count,...,index
#@cli : Return combination of repeated distinct elements found at index.
rep_rde_combination_index2list:
item_count=${2--2}
item_group_count={$#-2}

check "item_count=["$item_count"];
       ( sum( isint(item_count,1) ) == size(item_count) ) && ($1 <= sum(item_count) ) && (isint($1,1)&&$#>2);
       "

if $1==1
	u {$-1%$#-2}
	return
fi

distance_from_right=${_rep_rde_combination_sizes_from_right\ $1,$item_count}
selected_items,number_of_possible_combinations=$1,{[$distance_from_right][0]}
index,selected_index:=$-1%$number_of_possible_combinations,0

$selected_items

({vmin([$item_count],$selected_items)})

total_offset=0
repeat $selected_items {
	index,t_selected_offset=${_rep_rde_combination_offset_from_index_and_distance_from_right\ $index,$distance_from_right}

	crop. $t_selected_offset,100%

	set.. {$total_offset+$t_selected_offset},$>
	set. {i[#-1,0]-1},0

	if !i[#-1,0]
		crop. 1,100%
		t_selected_offset+=1
	fi

	cut. 0,{max($<,1)}

	distance_from_right=${_rep_rde_combination_sizes_from_right\ $<,{crop(#-1)}}
	total_offset+=$t_selected_offset
}

u {crop(#-2)} rm[-2,-1]
#@cli rep_rde_combination_list2index: selected_count,item_1_count,...,selected_item_1,...
#@cli : Return the lexicographic index in which this combination is found within all possible combinations of multi-set of possibly different size.
#@cli : Author: Reptorian.
rep_rde_combination_list2index:
m __$0_args:${_rep_rde_validate_frequency\ $*}
__$0_args um __$0_args

($item_count_groups) ($item_selection) sort. f. +max(i-j(-1),0)

index=0
repeat w#-1 {
	selection={i[#-1,$>]}
	distance_from_right=${_rep_rde_combination_sizes_from_right\ {$<+1},{crop(#-2)}}
	crop[-2] $selection,100%
	set[-2] {i[#-2,0]-1},0
	if !i[#-2,0]
		crop[-2] 1,100%
		set[-1] {[i[#-1,$>+1]-1,$>+1]}
	fi
	cut[-2] 0,{max($<,1)}
	index+=V=[$distance_from_right];V[0]-V[$selection]
}

rm[-2,-1]
u $index
_rep_rde_combination_offset_from_index_and_distance_from_right:
eval "distance_from_right=[${2--1}];
      size_of_combinations=distance_from_right[0];
      index=$1;

      differential=nan;
      for(selected_offset=size(distance_from_right)-1,selected_offset>=0,--selected_offset,
          differential=size_of_combinations-distance_from_right[selected_offset];
          if(index>=differential,break(););
      );

      index-=differential;

      [index,selected_offset];"
_rep_rde_combination_sizes_from_right:
list_of_items_counts={vmin(reverse([${2--1}]),$1)}
sum_items_counts={sum($list_of_items_counts)}
check $sum_items_counts>=$1

if $1==$sum_items_counts
	u 1
	return
elif $1==1
	u {expr('$#-x-1',$#-1)}
	return
fi

post_insert_zero={"
		V=["$list_of_items_counts"];
		contain_1=items_count=0;
		repeat(size(V),p,
			items_count+=V[p];
			if(items_count>=$1,
				contain_1=items_count==$1;
				break();
			);
		);
		contain_1;
	"}

($list_of_items_counts) +. 1
+f. >begin(p=0;);x?(p+=i-1;):(p=i);p;

eval. >"
	begin(
		const maximum_possible_distance=$#-2;
		distance_from_right=vector(#maximum_possible_distance);
		polynomial_multiplications_vector=vector(#is#-1);
		last_size=last_position=position_insertion=started=0;
		insert_distance_pos=size(distance_from_right);
		insert_distance_mode=0;
	);
	started?(
		p=last_position;
		copy_length=i[#-2,x];
		repeat(last_size,q,
				copy(polynomial_multiplications_vector[position_insertion+q],polynomial_multiplications_vector[p],copy_length,1,0,-1);
				++p;
		);
		if(!insert_distance_mode?(polynomial_multiplications_vector[position_insertion+$1]>1),
			insert_distance_mode=1;
		);
		if(insert_distance_mode,
			distance_from_right[--insert_distance_pos]=polynomial_multiplications_vector[position_insertion+$1];
		);
	):(
		copy(polynomial_multiplications_vector[0],1,i,1,0);
		started=1;
	);
	last_size=i;
	last_position=position_insertion;
	position_insertion+=i;
	end(
		set('distance_from_right',v2s(distance_from_right));
		set('insert_distance_pos',insert_distance_pos);
	);
	"

rm[-2,-1]

u {[$distance_from_right][$insert_distance_pos,$#-2-$insert_distance_pos]}{`$post_insert_zero?',1'`}
#@cli rep_rde_npr_permutations: selected_count,item_0_count>=1,item_1_count,...,_axis={x,y,z}
#@cli : Generates all possible permutations of repeated distinct elements of different counts, and the total number of elements is equal to the selected_count.
#@cli :
#@cli : Default values: '_axis=x'
+rep_rde_npr_permutations:
check "isint($1,1)&&$#>1"

if isnum($-1)
	items_counts=${2--1}
	axis=0
else
	check "inrange(_'$-1',_'x',_'z',1,1)"
	items_counts=${2--2}
	axis={_'$-1'-_'x'}
fi

check "items_counts=["$items_counts"];
       ( sum( isint(items_counts,1) ) == size(items_counts) ) && ($1 <= sum(items_counts) );"

number_of_possible_permutations=${_rep_rde_npr_permutations_length\ $1,$items_counts}
if $number_of_possible_permutations>(1<<24) error exc_combin_size:$number_of_possible_permutations fi

out_dim={v=vector(#3,1);v[$axis]=$number_of_possible_permutations;v}

$out_dim,$1,>"begin(
		quantity_of_items_in_group=vmin(["$items_counts"],$1);
		const cardinality_of_groups=size(quantity_of_items_in_group);
		const last_group_id=cardinality_of_groups-1;
		final_modify_pos=0;

		result=vector(#$1);
		const result_size=size(result);
		const last_result_indice=result_size-1;

		current_item_index=insertion_pos=0;
		while(insertion_pos<result_size,
			copy_count=min(quantity_of_items_in_group[current_item_index],result_size-insertion_pos);
			copy(result[insertion_pos],current_item_index,copy_count,1,0);
			quantity_of_items_in_group[current_item_index]-=copy_count;
			if(!quantity_of_items_in_group[current_item_index],++current_item_index;);
			insertion_pos+=copy_count;
		);

		started=0;
	);
	started?(
		break_out=0;
		for(insertion_pos=last_result_indice,insertion_pos>-1,--insertion_pos,
			current_item_index=previous_item_index=result[insertion_pos];
			while(++current_item_index<cardinality_of_groups,
				if(quantity_of_items_in_group[current_item_index],
					++quantity_of_items_in_group[previous_item_index];
					--quantity_of_items_in_group[current_item_index];
					result[insertion_pos]=current_item_index;
					break_out=1;
					break();
				);
			);
			if(break_out,break(););
			++quantity_of_items_in_group[previous_item_index];
		);
		if(++insertion_pos<result_size,
			current_item_index=0;
			while(insertion_pos<result_size,
				while(current_item_index<cardinality_of_groups,
					if(quantity_of_items_in_group[current_item_index],
						copy_count=min(quantity_of_items_in_group[current_item_index],result_size-insertion_pos);
						break();
					);
					++current_item_index;
				);
				copy(result[insertion_pos],current_item_index,copy_count,1,0);
				quantity_of_items_in_group[current_item_index]-=copy_count;
				++current_item_index;
				insertion_pos+=copy_count;
			);
		);
	):(
		started=1;
	);
	result;"
#@cli rep_rde_npr_permutation_index2list: selected_count,item_0_count,item_1_count,...,index
#@cli : Return permutation of repeated distinct elements found at index.
rep_rde_npr_permutation_index2list:
item_count:=${2--2}

check "item_count=["$item_count"];
       ( sum( isint(item_count,1) ) == size(item_count) ) && ($1 <= sum(item_count) ) && (isint($1,1)&&$#>2);
       "

item_group_count,result_ind,selected_items,index:=$#-2,$!,$1,$-1
dyn_img_ind,length_ind,new_dyn_ind={$result_ind+[1,2,3]}

$selected_items
1,{$#-1},1,2,>begin(v=vmin([$item_count,$selected_items]););y<h-1?[v[y],y]:[h-1,0]

total_length=${_rep_rde_npr_permutations_length\ $selected_items,$item_count}
index%=$total_length

repeat $selected_items {
	{da_size(#$dyn_img_ind)}
	current_level=$<

	repeat w#-1 {
		[$dyn_img_ind]
		eval i[#-1,$>]==1?da_remove(#-1,$>):--i[#-1,$>]
		da_size={da_size(#-1)}
		if $<
			set[$length_ind] ${_rep_rde_npr_permutations_length\ $current_level,{crop(#-1,0,0,0,0,1,$da_size,1,1)}},{$>+1}
		fi
	}

	p,index={"
		v=cumulate(crop(#$length_ind));
		index=$index;
		for(p=size(v)-1,p>-1,--p,
			if(index>=v[p],break(););
		);
		[p,index-v[p]];
		"}

	set[$result_ind] {i[#$dyn_img_ind,$p+h#$dyn_img_ind]},$>
	reverse[$dyn_img_ind,{$new_dyn_ind+$p}]
	rm[$length_ind--1]
}

u {crop(#$result_ind)} rm[$result_ind--1]
#@cli rep_rde_npr_permutation_list2index: selected_count,item_0_count,item_1_count,...,item_id_0,item_id_1
#@cli : Return the index which corresponds to the permutation of multiple repeated different elements of different counts given selected items counts being equal or less than  the sum of cardinalities of items.
#@cli :
#@cli : Note: There must be integer arguments in which the cardinality of integer arguments is less than or equal to the sum of cardinalities of items.
#@cli :
#@cli : Author: Reptorian.
rep_rde_npr_permutation_list2index:
m __$0_args:${_rep_rde_validate_frequency\ $*}
__$0_args um __$0_args

($item_count_groups,{narg($item_count_groups)}:;) dyn_img_ind={$!-1}
{h#-1-1} => offset
($item_selection) => item_selection final_item={i[#-1,w#-1-1]}

current_index=0
repeat w#-1-1 {
	old_index,new_index=0

	selected_item={i[#-1,$>]}

	drf,rf:=($selected_item+i[#$offset,$selected_item])+[0,1]

	current_level={$<+1}

	repeat $rf {
		old_index=$new_index

		[$dyn_img_ind]

		current_value={i[#-1,$>]}
		eval i[#-1,$>]==1?da_remove(#-1,$>):--i[#-1,$>]

		if $>==$drf

			if $current_value==1
				if $>
					eval copy(i[#$offset,$selected_item],-1,w#$offset-$selected_item,1,0,-1)
				else
					eval copy(i[#$offset,$selected_item],1,$selected_item+1,-1,0,-1)
				fi
			fi

			rv[$dyn_img_ind,-1] rm. break
		fi

		da_size={da_size(#-1)}
		new_index+=${_rep_rde_npr_permutations_length\ $current_level,{crop(#-1,0,0,0,0,1,$da_size,1,1)}}

		rm.
	}

	current_index+=$old_index
}

u {$current_index+$final_item+i[#$offset,$final_item]}
rm[$dyn_img_ind--1]
_rep_rde_npr_permutations_length:
(${2--1})
eval. <"begin(
		const sec_size=$1+1;
		dp=vector(#sec_size);
		dp[0]=1;
	);
	new_dp=vector(#sec_size,0);
	repeat(sec_size,t,
		if(!dp[0],continue(););
		maxj=min(i,$1-t);
		repeat(maxj+1,j,
			comb=perm(j,t+j,0);
			new_dp[t+j]+=comb*dp[t];
		);
	);
	dp=new_dp;
	end(
		set('{}',dp[$1]);
	);
	"
rm.
_rep_rde_validate_frequency:
check "
	const item_groups_and_selections_arg_count=$#-1;
	const selected_count=$1;
	const item_groups_set_cardinality=item_groups_and_selections_arg_count-selected_count;
	const max_item_index=item_groups_set_cardinality-1;

	if((item_groups_and_selections_arg_count-selected_count>=1)&&isint(selected_count,1),
		item_group_and_selection=[${2--1}];

		frequency_of_items_per_group=item_group_and_selection[0,item_groups_set_cardinality];
		total_number_of_items_to_choose_from=sum(frequency_of_items_per_group);

		if(total_number_of_items_to_choose_from>=selected_count,

			selected_items=item_group_and_selection[item_groups_and_selections_arg_count-selected_count,selected_count];
			amount_of_items=sum(frequency_of_items_per_group);

			is_valid_items_freq=min(frequency_of_items_per_group)>=1;
			is_valid_selected_items=same(isint(selected_items,0,max_item_index),1);

			is_valid_items_freq&&is_valid_selected_items?(
				is_all_ints_valid=1;
				frequency_checker=vector(#item_groups_set_cardinality);

				repeat(selected_count,p,
					item_selected=selected_items[p];
					if(++frequency_checker[item_selected]>frequency_of_items_per_group[item_selected],
						is_all_ints_valid=0;
						break();
					);
				);

				if(is_all_ints_valid,
					set('A',v2s(vmin(frequency_of_items_per_group,selected_count)));
					set('B',v2s(selected_items));
					1; # <- Confirms all conditions is valid
				);
			);
		);
	);"

u item_count_groups,item_selection=\"$A\",\"$B\"
#@cli rep_inc_combinations: size,_axis={x,y,z}
#@cli : Generate all of the possible incremental combination.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_axis=x'
+rep_inc_combinations:
skip ${2=x}
check "isint($1,1,24)&&inrange(_'$2',_'x',_'z',1,1)"

old_status=${}

size,axis={[1<<($1-1),_'$2'-_'x']}
out_dim={v=vector(#3,1);v[$axis]=$size;v}

$out_dim,$1
+rep_mt_f32v_map {[whd#-1,whd#-1>>12]},0
eval. :"
	const S=s#-2;
	const end_ind=S-1;
	const dec_end_ind=end_ind-1;

	v=vector(#S);

	t=J(-1);
	p=t[0]<<24|t[1];

	if(index=p,
		binary=vector(#end_ind);

		pos=end_ind;
		while(index,
			binary[--pos]=index&1;
			index>>=1;
		);

		q=0;
		repeat(end_ind-pos,
			if(binary[pos++],++q;);
				v[pos]=q;
		);
	);

	I[#-2,p]=v;

	i=i0<<24|i1;
	while(++p<i,
		positions=[end_ind,dec_end_ind];

		while( ( ++v[positions[0]] ) - v[positions[1]]  == 2,
			positions--;
		);

		if(positions[0]<end_ind,
			m=v[positions[0]];
			copy(v[positions[0]],m,S-positions[0],1,0);
		);

		I[#-2,p]=v;
	);
	"

rm. u $old_status
#@cli rep_inc_combination_index2list: size,index
#@cli : Return the incremental combination at index.
#@cli : Note: Untested with high size values.
rep_inc_combination_index2list:
check "(isint($1,1,52)&&isint($2))?inrange($2,0,1<<($1-1),1,0)"
eval "
	const s=$1;
	const d_s=s-1;
	index=$2;

	result=vector(#s);
	binary=vector(#d_s);

	pos=d_s;
	while(index,
		binary[--pos]=index&1;
		index>>=1;
	);

	p=0;
	repeat(d_s-pos,
		if(binary[pos++],++p;);
		result[pos]=p;
	);

	result;
	"
#@cli rep_inc_combination_list2index: number_list
#@cli : Return the lexicographic index in which this incremental combination is found within a list of all possible incremental combination.
#@cli : Note: Untested with high size of number_list.
rep_inc_combination_list2index:
check "
	number_list=sort([$*]);
	const max_index=size(number_list)-1;
	valid=1;
	v=0;
	if(size(number_list)<53,
		for(p=1,p<size(number_list),++p,
			diff=number_list[p]-number_list[p-1];
			diff==1?(
				v|=1<<(max_index-p);
			):
			diff>1?(
				valid=0;
				break();
			);
		);
		if(valid,
			set('{}',v);
			valid;
		);
	);
	"
#@cli rep_sum_permutations: limit>=0,size>0,_axis={x,y,z}
#@cli : Create a image representing every possible fixed-size vector which sum of non-negative integers is up to integer limit.
+rep_sum_permutations:
skip ${3=x}
check "isint($1,0)&&isint($2,1)&&$#>3?inrange(_'$-1',_'x',_'z',1,1):1"
sum_permutations_size:=$1?perm($2,$1+$2,0):$2

if $sum_permutations_size>(1<<24) error exc_size fi

if $#>2
	axis={_'$-1'-_'x'}
else
	axis=0
fi

dims={v=vector(#3,1);v[$axis]=$sum_permutations_size;v;}

if !$1
	$dims
	return
fi

old_status=${}

if $sum_permutations_size>0x10000 mode=: else mode=> fi

$dims,$2
+rep_mt_f32v_map {[whd#-1,whd#-1>>12]},0
eval. :"
	const S=s#-2;

	const max_sum=$1;
	const dec_max_sum=max_sum-1;
	const end_pos=S-1;
	const dec_end_pos=end_pos-1;

	v=vector(#S);

	t=J(-1);
	index=p=t[0]<<24|t[1];

	index?(
		check_scanline=use_index=1;
		sections_count=max_sum;
		level_id=end_pos;
		t_sum=0;

		repeat(end_pos,q,
			left_blocks_group_size=total_block_length=0;

			repeat(sections_count,r,
				left_blocks_group_size=total_block_length;
				total_block_length+=perm(level_id,level_id+(sections_count-r),0);
				if(total_block_length>index,break(););
			);

			--level_id;
			index-=left_blocks_group_size;
			sections_count-=r;
			v[q]=r;

			if(check_scanline?r,
				scanline_pos=q;
				check_scanline=0;
			);

			if(q<end_pos,
				t_sum+=r;
			);

			if(!sections_count,
				use_index=0;
				break();
			);
		);

		if(use_index,
			v[end_pos]=index;
		);

		sum_v=t_sum+v[end_pos];
		limit=max_sum-t_sum;
		mode=sum_v!=max_sum;
	):(
		scanline_pos=end_pos;
		mode=1;
		limit=max_sum;
	);

	I[#-2,p]=v;

	i=i0<<24|i1;
	while(++p<i,
		mode?(
			if((++v[end_pos]) == limit,
				mode=0;
			);
		):(
			v[scanline_pos] == max_sum?(
				copy(v[scanline_pos],0,S-scanline_pos,1,0);
				v[--scanline_pos] = 1;
				mode = 1;
				limit = dec_max_sum;
			):(
				boundary = inf;
				mode = found_number_pos = previous_numbers_sum = 0;

				# The for loop is used to find the sum of previous numbers before modified numbers. It is also used to scan where to modify the number.
				for( q = end_pos , q>=scanline_pos, --q,
					if(!found_number_pos?v[q],
						found_number_pos = q;
						boundary = q-1;
					);
					if(q<boundary,
						previous_numbers_sum += v[q];
					);
				);

				# This section modifies the first and second last number.
				v[found_number_pos--]=0;
				( total = (++v[found_number_pos])+previous_numbers_sum ) != max_sum ?(
					mode = 1;
					limit = max_sum-total;
				);
			);
		);

		I[#-2,p]=v;
	);
	"
rm. u $old_status
#@cli rep_sum_permutation_index2list: limit>=0,size>0,index
#@cli : Return the list of non-negative integers values which adds up to limit at lexicographic index.
rep_sum_permutation_index2list:
check "isint($1,0)&&isint($2,1)"

if !$1 u {vector(#$2)} return fi

eval "
	const size=$2;
	const d_size=size-1;
	const level_length=perm($2,$1+$2,0);
	index=$3%level_length;
	sections_count=$1;
	level_id=$2-1;
	output=vector(#size);

	use_index=1;
	repeat(d_size,p,
		left_blocks_group_size=total_block_length=0;

		repeat(sections_count,q,
			left_blocks_group_size=total_block_length;
			total_block_length+=perm(level_id,level_id+(sections_count-q),0);
			if(total_block_length>index,break(););
		);

		--level_id;
		index-=left_blocks_group_size;
		sections_count-=q;
		output[p]=q;

		if(!sections_count,
			use_index=0;
			break();
		);
	);

	if(use_index,
		output[d_size]=index;
	);

	output;
	"
#@cli rep_sum_permutation_list2index: limit,number_a,number_b,...
#@cli : Return the lexicographic index in which the list of number is found within the list of  arrays which sums up to the limit.
#@cli : Note: Code was generated from ChatGPT, and modified from it. So, I do not know who the source is, nor do I see a better alternative in terms of efficiency. So, beware if you want to use this code for your coding project. It does work, however.
rep_sum_permutation_list2index:
check "isint($1,0)?(
		v=[${2--1}];
		sum(isint(v),0)==($#-1)?(
			sum(v)<=$1;
		);
	);"

eval "
	const size_of_arr=$#-1;
	const dec_size_of_arr=size_of_arr-1;
	const max_int_sum=$1;
	list_of_num=[${2--1}];

	total=current_sum=0;

	repeat(size_of_arr,p,
		repeat(list_of_num[p],q,
			remaining_sum=max_int_sum-current_sum-q;
			remaining_sum?(
				r=size_of_arr-p-1;
				total+=perm(r,remaining_sum+r,0);
			):(
				break();
			);
		);
		current_sum+=list_of_num[p];
	);

	total;
	"
#@cli rep_total_sum_permutations: sum_total>=0,size>0,_axis={x,y,z}
#@cli : Create a image representing every possible fixed-size vector which sum of non-negative integers is equal to the total of sum.
+rep_total_sum_permutations:
skip ${3=x}
check "isint($1,0)&&isint($2,1)&&$#>3?inrange(_'$-1',_'x',_'z',1,1):1"
total_sum_permutations_size={d_s=$2-1;perm(d_s,d_s+$1,0)}

if $#>2
	axis={_'$-1'-_'x'}
else
	axis=0
fi

dims={v=vector(#3,1);v[$axis]=$total_sum_permutations_size;v;}

if !$1
	$dims
	return
fi

old_status=${}

$dims,$2
+rep_mt_f32v_map {[whd#-1,whd#-1>>12]},0
eval. :"
	const S=s#-2;

	const ep=S-1;
	const d_ep=ep-1;

	v=vector(#S);

	t=J(-1);
	index=p=t[0]<<24|t[1];

	index?(
		level_length=perm(ep,$1+ep,0);
		level_id=$2-2;
		sections_count=$1;
		N=sections_count;
		find_scanline_pos=1;
		q=0;
		while(N,
			left_blocks_group_size=total_block_length=0;
			repeat(sections_count,r,
				left_blocks_group_size=total_block_length;
				total_block_length+=perm(level_id,level_id+(sections_count-r),0);
				if(total_block_length>index,break(););
			);
			--level_id;
			index-=left_blocks_group_size;
			sections_count-=r;
			if(find_scanline_pos?r,
				scanline_pos=q;
				find_scanline_pos=0;
			);
			v[last_p_found=q++]=r;
			N-=r;
		);
	):(
		last_p_found=d_ep;
		scanline_pos=ep;
		v[ep]=$1;
	);

	I[#-2,p]=v;

	i=i0<<24|i1;
	while(++p<i,
		v[scanline_pos]==$1?(
			copy(v[scanline_pos],0,$2-scanline_pos,1,0);
			v[--scanline_pos]=1;
			v[ep]=$1-1;
		):
		!v[ep]?(
			end_pos=last_p_found+1;
			last_p_found=last_val_found=sum=0;
			for(q=scanline_pos,q<end_pos,++q,
				cv=v[q];
				if(cv,
					sum+=cv;
					last_p_found=q;
					last_val_found=cv;
				);
			);
			previous_sum_total=sum-last_val_found+1;
			v[last_p_found]=0;
			++v[last_p_found-1];
			v[ep]=$1-previous_sum_total;
		):(
			++v[d_ep];
			--v[ep];
			last_p_found=d_ep;
		);

		I[#-2,p]=v;
	);
	"
rm. u $old_status
#@cli rep_total_sum_permutation_index2list: sum>=0,size>0,index
#@cli : Return the list of non-negative integers values which adds up to sum at lexicographic index.
rep_total_sum_permutation_index2list:
check "isint($1,0)&&isint($2,1)"

if !$1 u {vector(#$2)} return fi

eval "
	const size=$2;
	const d_size=size-1;
	const level_length=perm(d_size,$1+d_size,0);
	level_id=$2-2;
	sections_count=$1;
	index=$3%level_length;
	N=sections_count;
	output=vector(#size);

	p=0;
	while(N,
		left_blocks_group_size=total_block_length=0;

		repeat(sections_count,q,
			left_blocks_group_size=total_block_length;
			total_block_length+=perm(level_id,level_id+(sections_count-q),0);
			if(total_block_length>index,break(););
		);

		--level_id;
		index-=left_blocks_group_size;
		sections_count-=q;
		output[p++]=q;
		N-=q;
	);

	output;
	"
#@cli rep_total_sum_permutation_list2index: number_a,number_b,...
#@cli : Return the lexicographic index in which the list of number is found within the list of  arrays which adds up to a sum.
#@cli : Note: Code was generated from ChatGPT, and modified from it. So, I do not know who the source is, nor do I see a better alternative in terms of efficiency. So, beware if you want to use this code for your coding project. It does work, however.
rep_total_sum_permutation_list2index:
check "sum(isint([$*],0))==$#"

eval "
	L=[$*];
	S=sum(L);
	const L_s=size(L);
	const d_L_s=L_s-2;

	index=0;
	repeat($#-1,p,
		current_value=L[p];
		repeat(current_value,value,
			(remaining_sum=S-value)?(
				tv=d_L_s-p;
				index+=perm(tv,remaining_sum+tv,0);
			):(break(););
		);
		S-=current_value;
		if(!S,break(););
	);
	index;
	"
#@cli rep_string_permutations: string,_axis,_sort_string={ 0=do_not_sort_string | 1=sort_string | 2=logical_sort_string }
#@cli : Return all the unique permutations of characters of string as a image with values representing the unicode representation of characters in input string. Permutations is dependent on character appearance order.
#@cli :
#@cli : Algorithm is based on the implementation of Narayana Pandita's algorithm by PM 2Ring at stackoverflow.
#@cli : Implementation of Narayana Pandita's algorithm -  https://stackoverflow.com/questions/8306654/finding-all-possible-permutations-of-a-given-string-in-python
#@cli : Description of Narayana Pandita's algorithm - https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order
#@cli : Author : Reptorian.
#@cli : Default values: '_axis=x','_sort_string=0'
+rep_string_permutations:
skip ${2=x},${3=0}
check "inrange(_'$2',_'x',_'z',1,1)"

1,1,1,2

eval "
 const sort_string=$3%3;
 reference_information='$1';

 sort_string==2?(
  const str_size=size(reference_information);
  sort_indexes=[242,243,0,1,2,3,4,26,27,244,245,84,56,246,5,6,7,8,51,52,53,54,55,247,248,249,250,251,252,253,254,18,96,70,89,99,17,85,74,88,62,63,77,80,90,81,91,92,108,109,110,111,112,113,114,115,116,117,94,95,64,83,65,73,97,119,127,128,130,132,137,138,139,140,145,146,147,148,149,151,158,159,160,161,163,165,170,171,172,173,175,58,93,59,76,57,86,176,184,185,187,188,193,194,195,196,201,202,203,204,205,207,215,216,217,218,220,222,227,228,229,230,233,60,75,61,69,255,107,28,162,29,30,31,32,34,35,24,36,37,38,40,41,42,39,43,44,48,33,45,46,47,49,50,9,10,11,12,13,14,238,71,19,21,22,20,239,25,118,15,237,66,68,240,16,100,98,82,105,106,87,23,241,234,235,104,236,67,101,102,103,72,120,121,122,123,124,125,126,129,133,134,135,136,141,142,143,144,131,150,152,153,154,155,156,78,157,166,167,168,169,174,164,219,177,178,179,180,181,182,183,186,189,190,191,192,197,198,199,200,213,206,208,209,210,211,212,79,214,223,224,225,226,231,221,232];
  sort_reference=resize(reference_information,str_size<<1,1,0);
  repeat(str_size,ind,
   pos=ind<<1;
   current_char=sort_reference[pos];
   sort_reference[pos]=sort_indexes[current_char];
  );
  sort_reference=sort(sort_reference,1,str_size,2);
  reference_information=(sort_reference)[1,str_size,2];
 ):
 sort_string==1?(
  reference_information=sort(reference_information);
 );

 char_position=vector(#256,-1); # Enable O(1) index retrieval as G'MIC lack Python-like dictionary

 ind=0;
 fill(reference_information,char_ind,
  char=reference_information[char_ind];
  is_char_found=char_position[char]>-1;
  if(is_char_found
  ,pos=char_position[char];++i(#-1,0,pos,0,1);
  ,pos=char_position[char]=ind++;da_push(#-1,[char,1]);
  );
  pos;
 );

 da_freeze(#-1);
 set('size_of_string',size(reference_information));
 sort(reference_information);
 "

axis,number_of_string_permutations={v=crop(#-1,0,0,0,1,1,h,1,1);[_'$2'-_'x',fact(sum(v))/prod(fact(v))]}
out_dim={v=vector(#3,1);v[$axis]=$number_of_string_permutations;v}

if $number_of_string_permutations>(1<<24) error exc_permut_val:$number_of_string_permutations fi

$out_dim,$size_of_string,>"begin(
  unicode=crop(#-1,0,0,0,0,1,h#-1,1,1);

  out_vector=["${}"];

  const max_index=s-1;
  const dec_max_index=max_index-1;

  started=0;

  reverse_array_starting_from(a)=(
   start=a;
   end=max_index;
   while(start<end,
    swap(out_vector[start++],out_vector[end--]);
   );
  );

 );

 if(started,

  for(jp=dec_max_index,jp>-1,--jp,
   if(out_vector[jp]<out_vector[jp+1],break(););
  );

  v=out_vector[jp];
  for(kp=max_index,kp>jp,--kp,
   if(v<out_vector[kp],break(););
  );

  swap(out_vector[kp],out_vector[jp]);
  reverse_array_starting_from(jp+1);
 ,
  started=1;
 );

 out_vector;"

channels[-2] 0
map[-1] [-2]
remove[-2]
#@cli rep_string_permutation_index2str: reference_string,index,_sort_reference_string={ 0=do_not_sort_string | 1=sort_string | 2=logical_sort_string }
#@cli : Return the string which is of the lexicographic index given reference string. The index is based on character appearance order unless sorting is activated. This is the first time an algorithm has been made to address this.
#@cli : Author : Reptorian.
#@cli : Default values: '_sort_reference_string=0'
rep_string_permutation_index2str:
check "isint($2)&&isint($3)"
skip ${3=0}

sort_string={$3%3}

if !$2
 if $sort_string==2
  status {`"
   target_string='$1';
   const str_size=size(target_string);
   sort_indexes=[242,243,0,1,2,3,4,26,27,244,245,84,56,246,5,6,7,8,51,52,53,54,55,247,248,249,250,251,252,253,254,18,96,70,89,99,17,85,74,88,62,63,77,80,90,81,91,92,108,109,110,111,112,113,114,115,116,117,94,95,64,83,65,73,97,119,127,128,130,132,137,138,139,140,145,146,147,148,149,151,158,159,160,161,163,165,170,171,172,173,175,58,93,59,76,57,86,176,184,185,187,188,193,194,195,196,201,202,203,204,205,207,215,216,217,218,220,222,227,228,229,230,233,60,75,61,69,255,107,28,162,29,30,31,32,34,35,24,36,37,38,40,41,42,39,43,44,48,33,45,46,47,49,50,9,10,11,12,13,14,238,71,19,21,22,20,239,25,118,15,237,66,68,240,16,100,98,82,105,106,87,23,241,234,235,104,236,67,101,102,103,72,120,121,122,123,124,125,126,129,133,134,135,136,141,142,143,144,131,150,152,153,154,155,156,78,157,166,167,168,169,174,164,219,177,178,179,180,181,182,183,186,189,190,191,192,197,198,199,200,213,206,208,209,210,211,212,79,214,223,224,225,226,231,221,232];
   sort_reference=resize(target_string,str_size<<1,1,0);
   repeat(str_size,ind,
    pos=ind<<1;
    current_char=sort_reference[pos];
    sort_reference[pos]=sort_indexes[current_char];
   );
   sort_reference=sort(sort_reference,1,str_size,2);
   (sort_reference)[1,str_size,2];
  "`}
 elif $sort_string==1
  status {`sort('$1')`}
 else
  status $1
 fi
 return
fi

1,1,1,1x3

eval "
 values_of_chars_in_string='$1';
 const size_of_info=size(values_of_chars_in_string);
 const sort_string=$sort_string;

 sort_string==2?(
  const str_size=size(values_of_chars_in_string);
  sort_indexes=[242,243,0,1,2,3,4,26,27,244,245,84,56,246,5,6,7,8,51,52,53,54,55,247,248,249,250,251,252,253,254,18,96,70,89,99,17,85,74,88,62,63,77,80,90,81,91,92,108,109,110,111,112,113,114,115,116,117,94,95,64,83,65,73,97,119,127,128,130,132,137,138,139,140,145,146,147,148,149,151,158,159,160,161,163,165,170,171,172,173,175,58,93,59,76,57,86,176,184,185,187,188,193,194,195,196,201,202,203,204,205,207,215,216,217,218,220,222,227,228,229,230,233,60,75,61,69,255,107,28,162,29,30,31,32,34,35,24,36,37,38,40,41,42,39,43,44,48,33,45,46,47,49,50,9,10,11,12,13,14,238,71,19,21,22,20,239,25,118,15,237,66,68,240,16,100,98,82,105,106,87,23,241,234,235,104,236,67,101,102,103,72,120,121,122,123,124,125,126,129,133,134,135,136,141,142,143,144,131,150,152,153,154,155,156,78,157,166,167,168,169,174,164,219,177,178,179,180,181,182,183,186,189,190,191,192,197,198,199,200,213,206,208,209,210,211,212,79,214,223,224,225,226,231,221,232];
  sort_reference=resize(values_of_chars_in_string,str_size<<1,1,0);
  repeat(str_size,ind,
   pos=ind<<1;
   current_char=sort_reference[pos];
   sort_reference[pos]=sort_indexes[current_char];
  );
  sort_reference=sort(sort_reference,1,str_size,2);
  values_of_chars_in_string=(sort_reference)[1,str_size,2];
 ):
 sort_string==1?(
  values_of_chars_in_string=sort(values_of_chars_in_string);
 );

 char_position=vector(#256,-1); # Enable O(1) index retrieval as G'MIC lack Python-like dictionary

 ind=0;
 repeat(size_of_info,char_ind,
  char=values_of_chars_in_string[char_ind];
  char_position[char]>-1?(
   ++i[#-2,pos=char_position[char]];
  ):(
   pos=char_position[char]=ind++;
   da_push(#-2,1);
   da_push(#-1,char);
  );
  values_of_chars_in_string[char_ind]=pos;
 );

 size_of_last_array=da_size(#-1);
 da_freeze(#-1);

 dividier=1;
 repeat(da_size(#-2),ind,
  dividier*=fact(i[#-2,ind]);
 );

 level_length=fact(size_of_info)/dividier;
 index=$2%level_length;
 max_index=level_length-1;

 if(!sort_string,values_of_chars_in_string=sort(values_of_chars_in_string););

 !index?(
  values_of_chars_in_string;
 ):
 index==max_index?(
  reverse(values_of_chars_in_string);
 ):(
  repeat(size_of_info,ind,
   da_push(#-3,values_of_chars_in_string[ind]);
  );

  size_of_last_array==size_of_info?(
   fn=size_of_info-1;
   repeat(size_of_info,iter,
    division_number=fact(fn);
    pos=int(index/division_number);
    values_of_chars_in_string[iter]=i[#-3,pos];
    da_remove(#-3,pos);
    index-=pos*division_number;
    --fn;
   );
  ):(
   repeat(size_of_info,ind,
    section_size=level_length/da_size(#-3);
    selected_indice=int(index/section_size);

    char=i[#-3,selected_indice];
    da_remove(#-3,selected_indice);

    level_length=section_size*i[#-2,char];
    --i[#-2,char];

    for(count_of_letters_index=0,count_of_letters_index<char,count_of_letters_index++,
     index-=i[#-2,count_of_letters_index]*section_size;
    );

    values_of_chars_in_string[ind]=char;
   );
  );

  values_of_chars_in_string;
 );
 "

status {`map([${}],crop(#-1))`} remove[-3--1]
#@cli rep_string_permutation_str2index: test_string : reference_string,test_string,_sort_reference_string={ 0=do_not_sort_string | 1=sort_string | 2=logical_sort_string }
#@cli : Return the lexicographic rank in which the permutation of string is found. The rank is based on character appearance order. If you provide only one argument, then rank is dependent on alphabetical order.
#@cli :
#@cli : Algorithm to find the lexicographic rank of string has been made by egoista of GeeksForGeeks and source code can be found here - https://www.geeksforgeeks.org/lexicographic-rank-string-duplicate-characters/
#@cli : Author : Reptorian.
#@cli : Default values: '_sort_reference_string=0'
rep_string_permutation_str2index:
skip "${2=}",${3=0}

1,1,1,1

eval "
 reference_information='$1';
 const size_ref_str=size(reference_information);
 const contain_arg_2=narg($2);

 contain_arg_2?(
  test_string='$2';
  const sort_string=$3%3;

  if(size(test_string)!=size_ref_str,run('error diff_str_dims'););

  sort_string==2?(
   sort_indexes=[242,243,0,1,2,3,4,26,27,244,245,84,56,246,5,6,7,8,51,52,53,54,55,247,248,249,250,251,252,253,254,18,96,70,89,99,17,85,74,88,62,63,77,80,90,81,91,92,108,109,110,111,112,113,114,115,116,117,94,95,64,83,65,73,97,119,127,128,130,132,137,138,139,140,145,146,147,148,149,151,158,159,160,161,163,165,170,171,172,173,175,58,93,59,76,57,86,176,184,185,187,188,193,194,195,196,201,202,203,204,205,207,215,216,217,218,220,222,227,228,229,230,233,60,75,61,69,255,107,28,162,29,30,31,32,34,35,24,36,37,38,40,41,42,39,43,44,48,33,45,46,47,49,50,9,10,11,12,13,14,238,71,19,21,22,20,239,25,118,15,237,66,68,240,16,100,98,82,105,106,87,23,241,234,235,104,236,67,101,102,103,72,120,121,122,123,124,125,126,129,133,134,135,136,141,142,143,144,131,150,152,153,154,155,156,78,157,166,167,168,169,174,164,219,177,178,179,180,181,182,183,186,189,190,191,192,197,198,199,200,213,206,208,209,210,211,212,79,214,223,224,225,226,231,221,232];
   sort_reference=resize(reference_information,size_ref_str<<1,1,0);
   repeat(size_ref_str,ind,
    pos=ind<<1;
    current_char=sort_reference[pos];
    sort_reference[pos]=sort_indexes[current_char];
   );
   sort_reference=sort(sort_reference,1,size_ref_str,2);
   reference_information=(sort_reference)[1,size_ref_str,2];
  ):
  sort_string==1?(
   reference_information=sort(reference_information);
  );
 ):(
  test_string='$1';
  reference_information=sort(reference_information);
 );

 test_string==reference_information?(
  0;
 ):(
  char_position=vector(#256,-1); # Enable O(1) index retrieval as G'MIC lack Python-like dictionary

  ind=0;
  repeat(size_ref_str,char_ind,
   char=reference_information[char_ind];
   char_position[char]>-1?(
    ++i[#-1,char_position[char]];
   ):(
    char_position[char]=ind++;
    da_push(#-1,1);
   );
  );

  test_string==reverse(reference_information)?(
   dividier=1;
   repeat(da_size(#-1),ind,
    dividier*=fact(i[#-1,ind]);
   );

   fact(size_ref_str)/dividier-1;
  ):(

   fill(test_string,char_ind,
    new_val=char_position[test_string[char_ind]];
    if(new_val<0,run('error inval_char'););
    if(--i[#-1,new_val]==-1,run('error exec_chars_det'););
    new_val;
   );

   str_index=0;

   repeat(size_ref_str,ind,
    count_of_less_index_value=0;

    for(alt_ind=ind+1,alt_ind<size_ref_str,++alt_ind,
     if(test_string[ind]>test_string[alt_ind],++count_of_less_index_value;);
    );

    if(count_of_less_index_value,
     for(alt_ind=ind,alt_ind<size_ref_str,++alt_ind,++i[#-1,test_string[alt_ind]];);

     dividier_factorial=1;
     repeat(da_size(#-1),element,
      dividier_factorial*=fact(i[#-1,element]);
      i[#-1,element]=0;
     );

     str_index+=(fact(size_ref_str-ind-1)*count_of_less_index_value)/dividier_factorial;
    );

   );

   str_index;
  );

 );"

remove[-1]
#@cli rep_inverse_permutation: number_list
#@cli : Return the inverse permutation.
#@cli :
#@cli : number_list must be in the form of 0,1,2,3.... , but can be in any order.
rep_inverse_permutation:
if $#>1
	ordered={expr('x',$#)}

	if sort([$*])==[$ordered]
		if [$*]==[$ordered]
			u $ordered
		else
			($*)
			{$#}
			eval.. i(#-1,i)=x
			u {crop(#-1)}
			rm[-2,-1]
		fi
	else
		error inv_args
	fi
else
	u 0
fi
#@cli rep_inverse_permute_str: permutation_string
#@cli : Return the inverse permutation_string for command permute
#@cli : 'permutation_string' is a combination of the character set {x|y|z|c},
#@cli : e.g. 'xycz', 'cxyz', ...
rep_inverse_permute_str:
status {`"
	start_string='xyzc';
	input_string='$1';
	start_string==input_string?(
		start_string;
	):(
		if(size(input_string)!=4,run('error inv_str_len_det'););
		const _c=_'c';
		const _x=_'x';
		const _z=_'z';
		xyz_counter=vector(#3,0);
		c_counter=0;
		new_string=vector(#4,0);
		repeat(4,ind,
			char=input_string[ind];
			inrange(char,_x,_z,1,1)?(
				if(xyz_counter[p=char-_x]++,run('error exc_char_det'););
			):
			char==_c?(
				if(c_counter++,run('error exc_char_det'););
				p=3;
			):(
				run('error inv_char_det');
			);
			new_string[p]=start_string[ind];
		);
		new_string;
	);"`}
#@cli rep_permute_args: permute_index,arg_1,arg_2,...
#@cli : Return the permutations of arguments.
rep_permute_args:
check $#>1

num_of_args:=$#-1

m __$0_order:"$""=a"
m __$0_args:"$""=args"

__$0_order {[${rep_permutation_index2list\ $num_of_args,$1}]+1}
__$0_args ${2--1}

um __$0_order,__$0_args

end=
p=1
for $p<$# {
	output.=$end${args${a$p}}
	end=,
	p+=1
}

u $output
#@cli rep_chars_repetition: str_containing_chars,char_1_repeat,char_2_repeat,...
#@cli : Generate string with characters to repeat and number of repeat per characters. The number of repetition must be integer!
#@cli : $ echo ${rep_chars_repetition\ ABC,5,2,3}
rep_chars_repetition:
size_of_str:=size('$1')

{sum(vector$size_of_str(${2--1}))},1,1,1,">begin(
		characters='$1';

		number_of_repeats=vector$size_of_str(${2--1});

		if(!(isint(number_of_repeats)==number_of_repeats>0),
			run('error inval_repet_num');
		);

		current_index=position=0;
	);

	char=characters[current_index];

	++position;
	if(position==number_of_repeats[current_index],
		++current_index;
		position=0;
	);

	char;
	"

status {t} rm.
#@cli rep_generate_all_images_combinations:[images]
#@cli : Generates all combinations of images.
rep_find_all_images_combinations:
if $!==1 return
elif !$! error no_imgs
else timg={$!}
fi

if ${-max_d}>1
	error inv_dim_d
fi

eval "
	valid_dim=1;
	refer_dim=[w#-1,h#-1];
	repeat($timg-1,p,
		[w#p,h#p]!=refer_dim?(valid_dim=0;break(););
	);
	valid_dim;"

if !${}
	error inv_dims
fi

a z

+rep_r_permutations $timg,$timg,z
permute. cyzx

{w#0*d#0},{h#0},{d#-1},{s#0}

eval.. "
	const img_w=w#0;
	const img_h=h#0;
	const img_s=s#0;
	crop_image=crop(#0,0,0,i,0,img_w,img_h,1,img_s);
	draw(#-1,crop_image,img_w*x,0,z,0,img_w,img_h,1,img_s,1);
	"

k[-1]
s z
#@cli rep_mt_f32v_map: max_ref_val,num_of_cpus,_use_max_double={ 0=false | 1=true }
#@cli : Generates a helper image that encodes work ranges into a float32 vector.
#@cli : The generated image is intended to be used as a scheduling/map structure for
#@cli : dynamic, thread-countâdependent processing.
#@cli :
#@cli : Note:
#@cli : - This command does NOT process image data.
#@cli : - All values are user-defined and represent abstract work units
#@cli :   (e.g., number of pixels or scalar elements to be processed).
#@cli : - The command itself is single-threaded.
#@cli : - The resulting image is meant to be consumed by custom multi-threaded
#@cli :   code that adapts to varying CPU/thread counts.
#@cli :
#@cli : Parameters:
#@cli : - max_ref_val : Total number of work units to distribute.
#@cli : - num_of_cpus : Number of logical processing units to map against.
#@cli : - _use_max_double : Enables extended-precision packing.
#@cli :
#@cli : Default values: '_use_max_double=0'
+rep_mt_f32v_map:
check isbool(${3=0})
+__rep_mt_f32v_map_$3 $1,{cut($2,1,$_cpus)}
+__rep_mt_f32v_map_1:
$2,1,1,3,v=$1-(w-1-x)*int($1/w);[v>>48&0xffff,v>>24&0xffffff,v&0xffffff]
+__rep_mt_f32v_map_0:
$2,1,1,2,v=$1-(w-1-x)*int($1/w);[v>>24,v&0xffffff]
#@cli rep_rrd: eq. to 'rep_random_rectangular_division'
rep_rrd: rep_random_rectangular_division $*
#@cli rep_random_rectangular_division: split>1,_additional_thickness>=0,_max_iter>=2,_probability[%]>0,_loop_limit>1,0<=_border[%]>=100%,_seed,_normalize,border_color,palette_mode
#@cli : Generate random division of rectangle as in random number of division and varying thickness within rectangle.
#@cli : _additional_thickness refers to the excess pixel thickness.
#@cli : _max_iter limits the number of iterations per rectangle.
#@cli : _probability determines the probability that a rectangle will be permitted to be utilized for further iteration.
#@cli : _loop_limit limits the number of time the process of subdivision is done.
#@cli : _seed generates the output based on defined parameter.
#@cli : Default values: '_gen_thick=0','_max_iter=5','_probability[%]=95%','_loop_limit=5000','_border=0%','_seed=n/a'
rep_random_rectangular_division:
skip ${2=0},${3=5},${4=95%},${5=5000},${6=0},${7=},${8=0},${9=},${10=},${11=},${12=},${13=}

check "$4>0"

foreach { _rep_random_rectangular_division $* }

_rep_random_rectangular_division:
skip ${2=0},${3=5},${4=95%},${5=5000},${6=0},${7=},${8=0},${9=},${10=},${11=},${12=},${13=}

border_size={max(0,round(abs($2)*cut($6,0,1)))}
contain_palette=0
dims={w},{h}
ns=1
col=0
activate_code_block=1

if narg($10)

	ms=3
	contain_palette=1

	if same('$10','pal')
	elif ${is_image_arg\ $10} pass$10 0 ms={s#-1} rm.
	else contain_palette=0
	fi

fi

if narg($10)

	ms=3
	contain_palette=1

	if same('$10','pal')
	elif ${is_image_arg\ $10} pass$10 0 ms={s#-1} rm.
	else

		contain_palette=0

		if !narg($11)||(narg($11)?abs($11)==0)

			activate_code_block=0

			if narg($9)&&$border_size
				col=${rep_hex2int8\ $9}
				ns={narg($col)}
				col=vector(#$ns,$col)
			else
				ns=3
			fi

		fi

	fi

else

	if narg($9)&&$border_size
		col=${rep_hex2int8\ $9}
		ns={narg($col)}
		col=vector(#$ns,$col)
	fi

fi

rm.

$dims,1,$ns,$col

1,1,1,5 #Modifiable Rectangle Array
1,1,1,5 #Unmodifiable Rectangle Array

eval "
	if(narg($7),srand($7););
	const ww=w#-3-1;
	const hh=h#-3-1;
	const max_split=max(1,int(abs($1)));
	const internal_space=int(abs($2));
	const test_boundary=internal_space?(internal_space+1);
	const max_iter=max(2,round(abs($3)));
	const odd=cut($4,0,1);
	const arr_limit=round(abs($5));

	diff_check(a)=(
		mri=max_split;
		ds=a/mri;
		if(mri>1&&ds<1,
			while(mri>1&&ds<1,
				--mri;
				ds=a/mri;
			);
		);
		ds>1;
	);

	width_check=diff_check(ww-internal_space*2);
	height_check=diff_check(hh-internal_space*2);

	!(width_check||height_check)?run('error inv_dim');

	da_push(#-2,[0,ww,0,hh,0]);

	sub_column(info_vector,point)=(
		ri=v(1,max_split,1,0)+1;
		mri=ri-1;
		sx=info_vector[0]+test_boundary;
		ex=info_vector[1]-test_boundary;
		diff=ex-sx;
		bound_check=diff>test_boundary;
		skip=0;
		da_remove(#-2,point);
		if(bound_check,
			ds=diff/mri;
			if(mri>1&&ds<=test_boundary,
				while(mri>1&&ds<=test_boundary,
					--ri;
					--mri;
					ds=diff/mri;
				);
			);
			if(test_boundary||diff?(ds>test_boundary):1,
				py=[info_vector[2],info_vector[3]];
				iter=info_vector[4]+1;
				p=info_vector[0];
				repeat(ri,ri_ind,
					rb=odd<1?u(0,1)>odd;
					ri_ind==mri?(
						if(p>info_vector[1],
							p=info_vector[1];
							if(!(info_vector[3]-info_vector[2]),rb=1;);
						);
						(rb||(iter==max_iter))?(
							da_push(#-1,[p,info_vector[1],py,iter]);
						):(
							da_push(#-2,[p,info_vector[1],py,iter]);
						);
					):
					!ri_ind?(
						mx=sx+ds;
						np=min(max(sx,round(u(p,mx))),ex);
						vp=[p,np];
						(rb||(iter==max_iter))?(
							da_push(#-1,[vp,py,iter]);
						):(
							da_push(#-2,[vp,py,iter]);
						);
						p=np+1;
						if(p>=ex,skip=1;);
					):(
						if(skip,continue(););
						mx+=ds;
						np=min(max(p+internal_space,round(u(p,mx))),ex);
						vp=[min(p,ex),np];
						(rb||(iter==max_iter))?(
							da_push(#-1,[vp,py,iter]);
						):(
							da_push(#-2,[vp,py,iter]);
						);
						p=np+1;
					);
				);
			,da_push(#-1,info_vector);
			);
		,da_push(#-1,info_vector);
		);
	);

	sub_row(info_vector,point)=(
		ri=v(1,max_split,1,0)+1;
		mri=ri-1;
		sy=info_vector[2]+test_boundary;
		ey=info_vector[3]-test_boundary;
		diff=ey-sy;
		bound_check=diff>test_boundary;
		skip=0;
		da_remove(#-2,point);
		if(bound_check,
			ds=diff/mri;
			if(mri>1&&ds<=test_boundary,
				while(mri>1&&ds<=test_boundary,
					--ri;
					--mri;
					ds=diff/mri;
				);
			);
			if(test_boundary||diff?(ds>test_boundary):1,
				px=[info_vector[0],info_vector[1]];
				iter=info_vector[4]+1;
				p=info_vector[2];
				repeat(ri,ri_ind,
					rb=odd<1?u(0,1)>odd;
					ri_ind==mri?(
						if(p>info_vector[3],
							p=info_vector[3];
							if(!(info_vector[1]-info_vector[0]),rb=1;);
						);
						(rb||(iter==max_iter))?(
							da_push(#-1,[px,p,info_vector[3],iter]);
						):(
							da_push(#-2,[px,p,info_vector[3],iter]);
						);
					):
					!ri_ind?(
						my=sy+ds;
						np=min(max(sy,round(u(p,my))),ey);
						vp=[p,np];
						(rb||(iter==max_iter))?(
							da_push(#-1,[px,vp,iter]);
						):(
							da_push(#-2,[px,vp,iter]);
						);
						p=np+1;
						if(p>=ey,skip=1;);
					):(
						if(skip,continue(););
						my+=ds;
						np=min(max(p+internal_space,round(u(p,my))),ey);
						vp=[min(p,ey),np];
						(rb||(iter==max_iter))?(
							da_push(#-1,[px,vp,iter]);
						):(
							da_push(#-2,[px,vp,iter]);
						);
						p=np+1;
					);
				);
			,da_push(#-1,info_vector);
			);
		,da_push(#-1,info_vector);
		);
	);

	info_vector=I[#-2,0];

	width_check&&height_check?(
		u(0,1)<=.5?(
			sub_row(info_vector,0);
		):(
			sub_column(info_vector,0);
		);
	):
	width_check?(
		sub_column(info_vector,0);
	):
	height_check?(
		sub_row(info_vector,0);
	);

	arr_point=0;

	while(da_size(#-2),
		p_ind=v(0,da_size(#-2),1,0);
		cv=I[#-2,p_ind];

		u(0,1)<.5?(
			sub_row(cv,p_ind);
		):(
			sub_column(cv,p_ind);
		);

		++arr_point;
		if(arr_point>=arr_limit,break());
	);

	da_freeze(#-2);
	da_freeze(#-1);"

a[-2,-1] y

eval. :"begin_t(
		const ww=w#-2-1;
		const hh=h#-2-1;
		const border_size=$border_size;
		const b_a=floor(border_size/2);
		const b_b=ceil(border_size/2);
		const contain_border=$border_size?1;

		hsv2rgb(I)=(
			ref(I,_I);
			_I[0]%=360;
			_I[1]=cut(_I[1],0,1);
			_I[2]=cut(_I[2],0,1);
			_c=_I[2]*_I[1];
			_x=_c*(1-abs((_I[0]/60)%2-1));
			(arg1(1 + int(_I[0]/60),[_c,_x,0],[_x,_c,0],[0,_c,_x],[0,_x,_c],[_x,0,_c],[_c,0,_x])+=_I[2] - _c)*=255;
		);

		$8&&!narg($10)?(
			$ns>1?(
				const rescale_factor=(h-1)/255;
				calc_out()=vector(#$ns,y/rescale_factor);
			):(
				const rescale_factor=(h-1+contain_border)/255;
				calc_out()=vector(#$ns,(y+contain_border)/rescale_factor);
			);
		):(
			$activate_code_block?(
				calc_out=calc_out()=y+contain_border;
			):(
				if(narg($12),srand($12+t););
				$10==1?(
					calc_out()=hsv2rgb(vector(#3,u(360),u(1),u(1)));
				):(
					calc_out()=vector(#3,u(255),u(255),u(255));
				);
			);
		);

		convert2coords(c)=(
			sx=c[0]+(!(c[0]==0)?b_a);
			sy=c[2]+(!(c[2]==0)?b_a);
			ex=c[1]-(!(c[1]==ww)?b_b);
			ey=c[3]-(!(c[3]==hh)?b_b);
			tl=[sx,sy];
			tr=[ex,sy];
			bl=[sx,ey];
			br=[ex,ey];
			[tl,tr,br,bl];
		);

	);
	polygon(#-2,4,convert2coords(I),1,calc_out());
	end(
		if(contain_border,
			const sub_border=border_size-1;
			const bh=hh-sub_border;
			const bw=ww-sub_border;
			col="$col";
			polygon(#-2,4,[0,0, ww,0, ww,sub_border, 0,sub_border],1,col);
			polygon(#-2,4,[0,border_size,sub_border,border_size,sub_border,hh,0,hh],1,col);
			polygon(#-2,4,[bw,border_size,ww,border_size,ww,hh,bw,hh],1,col);
			polygon(#-2,4,[border_size,bh,bw,bh,bw,hh,border_size,hh],1,col);
		);
	);"

rm.

if narg($10)&&$activate_code_block

	if $contain_palette

		orientation=0

		if $border_size
			col=${rep_hex2int8\ $9}
			1,1,1,$ms,vector(#3,$col);
			if same('$10','pal')

				+pal $11
				if narg($12)
					{w},1,1,1,begin(srand($12););u
					pixelsort.. +,x,[-1]
					rm.
				fi

			elif ${is_image_arg\ $10}

				pass$10 1

				if h>w orientation=1 fi

				if narg($11)
					if $orientation
						{h},1,1,1,begin(srand($11););u
						pixelsort.. +,y,[-1]
						rm.
					else
						{w},1,1,1,begin(srand($11););u
						pixelsort.. +,x,[-1]
						rm.
					fi
				fi

			fi

			r. {iM#-3-1},1,1,3,0,2

			if $orientation
				r. 1,{iM#-3-1},1,3,0,2
				a[-2,-1] y
			else
				r. {iM#-3-1},1,1,3,0,2
				a[-2,-1] x
			fi

		else
			if same('$10','pal')

				+pal $11

				if narg($12)
					{w},1,1,1,begin(srand($12););u
					pixelsort.. +,x,[-1]
					rm.
				fi

			elif ${is_image_arg\ $10}

				pass$10 1

				if h>w orientation=1 fi

				if narg($11)

					if $orientation
						{h},1,1,1,begin(srand($11););u
						pixelsort.. +,y,[-1]
						rm.
					else
						{w},1,1,1,begin(srand($11););u
						pixelsort.. +,x,[-1]
						rm.
					fi

				fi

			fi

			if $orientation
				r. 1,{iM#-2-1},1,3,0,2
			else
				r. {iM#-2-1},1,1,3,0,2
			fi

		fi

	else

		if $border_size

			col=${rep_hex2int8\ $9}

			1,1,1,3,vector(#3,$col);

			if $10==1
				{narg($11)?max(abs($11),2):iM#-2-1},1,1,3,${-math_lib}begin(if(narg($12),srand($12);););hsv2rgb(vector(#3,u(360),u(1),u(1)));
			else
				{narg($11)?max(abs($11),2):iM#-2-1},1,1,3,begin(if(narg($12),srand($12);););vector(#3,u(255),u(255),u(255));
			fi
			if narg($11) r. {iM#-3-1},100%,100%,100%,0,2 fi

			a[-2,-1] x

		else

			if $10==1
				{narg($11)?max(abs($11),2):iM#-1-1},1,1,3,${-math_lib}begin(if(narg($12),srand($12);););hsv2rgb(vector(#3,u(360),u(1),u(1)));
			else
				{narg($11)?max(abs($11),2):iM#-1-1},1,1,3,begin(if(narg($12),srand($12);););vector(#3,u(255),u(255),u(255));
			fi

			if narg($11) r. {iM#-2-1},100%,100%,100%,0,2 fi

		fi

	fi

	map.. .
	rm.

fi
#@cli rep_custom_map: _shift_value>0,_negate={ 0=no_negation | 1=negate },_[palette],_seed_a...
#@cli : Custom mapping function with more options than default map.
#@cli : _shift_value defines the shift of base values used for mapping of color. This can be either percentage of integer.
#@cli : _[palette] is used to map into image.
#@cli : _seed defines the seed per image. Note: If you had inserted no argument, but a comma before, then it will pick random. If there is no argument and no comma, then it will use default map method. If this is your only argument, then the seed will defines the output. Sequentive arguments will also be used as seed for output for each images.
#@cli : Default values: '_shift_value=n/a','_[palette]','_seed=n/a'
#@cli :
#@cli : Author: Reptorian.
rep_custom_map:
skip "${1=}","${2=0}","${3=}","${4=}"
check narg($1)||(narg(${2--1})>1)

if narg($1)

	if ispercentage($1)

		f "begin(
				const num_val=iM+1;
				const shift_val=round(iM*$1);
				nv=expr('x',num_val);
				shift(nv,-shift_val,2);
			);
			nv[i];"

	else

		f "begin(
				const num_val=iM+1;
				nv=expr('x',num_val);
				shift(nv,-$1,2);
			);
			nv[i];"

	fi

fi

if $2 negate fi

if narg($3)

	if ${is_image_arg\ $3}

		pass$3 0

		check "w#-1==1||h#-1==1"

		store. ordered

		if narg($*)==4

			if narg($4)

				$ordered

				if w>h
					{w#-1},1,1,1,begin(if(narg($4),srand($4)));u
					pixelsort.. +,x,[-1]
				else
					1,{h#-1},1,1,begin(if(narg($4),srand($4)));u
					pixelsort.. +,y,[-1]
				fi

				map[0--3] [-2],2
				rm[-2,-1]

			else

				repeat $! {

					$ordered

					if w>h
						{w#-1},1,1,1,u
						pixelsort.. +,x,[-1]
					else
						1,{h#-1},1,1,u
						pixelsort.. +,y,[-1]
					fi

					map[$>] [-2],2
					rm[-2,-1]

				}
			fi
		elif narg($*)>4

			$=seed
			repeat $! {
				$ordered

				if w>h
					{w#-1},1,1,1,begin(srand(${seed{4+$>}}));u
					pixelsort.. +,x,[-1]
				else
					1,{h#-1},1,1,begin(srand(${seed{4+$>}}));u
					pixelsort.. +,y,[-1]
				fi

				map[$>] [-2],2
				rm[-2,-1]
			}

		else
			$ordered map[^-1] [-1] rm.
		fi

	else error \$\2!=[img]
	fi
fi
#@cli rep_exp_sig_adj : eq. to 'rep_exponential_sigmoid_adjustment'
rep_exp_sig_adj: rep_exponential_sigmoid_adjustment $*
#@cli rep_exponential_sigmoid_adjustment: -1>=midpoint_shift>=1,sigmoid_level>=0,_sigmoid_shift,_endval
#@cli : Assign exponential-sigmoid function into image.
#@cli :
#@cli : midpoint_shift defines the center value point. If it at .5, then the center value point will between the largest value and the middle value.
#@cli : sigmoid_level influence how much S-Curve will be applied. If 0, then there is no sigmoid function.
#@cli : _sigmoid_shift shifts value
#@cli : _endval determines the maximum value of output. Negative value will return a image where the maximum image is the positive value of the negative input. Positive value will return a image where the maximum value is the maximum value multiplied by it input.
#@cli :
#@cli : Default values: '_sigmoid_shift=0','_endval=1'
#@cli :
#@cli : Author: Reptorian.
rep_exponential_sigmoid_adjustment:
skip ${2=0},${3=0},${4=1}

check {abs($4)!=0}

sig_scale={abs($2)}
check_sig_scale={$sig_scale==0}

if ($1!=0)||($2!=0)||($3!=0)

	f ":begin(
		const sig_scale=$sig_scale;
		const midpoint_shift=min(1-abs($1),1);
		const maxval_mul_by_factor=$4>0?iM*$4:abs($4);

		$1>=0?(
			calc_exp_shift(n)=n^midpoint_shift;
		):(
			calc_exp_shift(n)=1-((1-n)^midpoint_shift);
		);

		$check_sig_scale?(
			calc(n)=calc_exp_shift(n);
		):(

			sigmoid_curve(a)=(ne=e^a;ne/(ne+1));

			$3==0?(
				change_slope(a)=(a-.5)*sig_scale;
				const start_point=change_slope(0);
				const val_ref=(e^start_point)/(e^start_point+1);
				const min_height=abs(val_ref);
				const max_height=1-2*min_height;
			):(
				const shift_point=-.5+$3;
				change_slope(a)=(a+shift_point)*sig_scale;
				const start_point=change_slope(0);
				const start_ref=(e^start_point)/(e^start_point+1);
				const end_point=change_slope(1);
				const end_ref=(e^end_point)/(e^end_point+1);
				const min_height=abs(start_ref);
				const max_height=end_ref-start_ref;
			);

			calc(n)=(
				new_curve=calc_exp_shift(n);
				(sigmoid_curve(change_slope(new_curve))-min_height)/max_height;
			);

		);
	);

	start_slope=I/iM;
	calc(start_slope)*maxval_mul_by_factor;"

fi
#@cli rep_ekb: eq. to 'rep_ellsworth_board'
rep_ekb: rep_ellsworth_kelly_board $*
#@cli rep_ellsworth_board: sqr_size,_border_size[%],_border_value[%],_distribution,_{pal_id,[image]},_background_hex,fit_mode,_color_space,_exterior_border_color...
#@cli : Outputs a color board based on colored square tiles art made by Ellsworth Kelly with transparent areas.
#@cli :
#@cli : (eq. to 'rep_ekb')
#@cli : sqr_size defines the painted square size.
#@cli : _border_size defines the size of border. Negative number will take away areas from the painted squares. Positive number will separate painted areas by this amount.
#@cli : _border_value defines the gray level of border.
#@cli : _distribution defines the probability of a square to be painted.
#@cli : _{pal_id,[image]} defines the color. If you choose a name of a existing palette, then this will be the base of the colors of the square. Otherwise, it will be based off the palette.
#@cli : _background_hex defines the background color. This is based on RGB-Hex value.
#@cli : _fit_mode defines whether the resulting board should exceed the size of the original image.
#@cli : _color_space defines the color space of the board.
#@cli : _border_color defines the color of the border. Dependent on color space.
#@cli : Default values: '_border_size=10%','_border_value=50%','_distribution=50%','{pal_id,[image]}=120','_background_hex=n/a',_fit_mode=0,'_color_space=0','_exterior_border_color=n/a'
#@cli :
#@cli : Author: Reptorian
rep_ellsworth_kelly_board:
skip "${2=10%},${3=50%},${4=50%},${5=120},${6=},${7=0},${8=0},${9=}"

check "($1==int(abs($1)))&&(int(abs($1))>=1)&&$4>0"

cs={$8%17}
if $cs convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$cs,,ryb,cmy,cmyk,hcy,hsi,hsl,hsv,lab,lch,ycbcr,ycbcrglic,yiq,yuv,xyz,yes} fi

ref_sqr_size={abs($1)}

mode=1

border_direction={$2>=0}

('$2')

if i(#-1,w-1)==37 use_percent=1 else use_percent=0 fi

rm.

if $border_direction&&$ref_sqr_size>1

 if $use_percent border_size={round(($ref_sqr_size)*abs($2))}
 else border_size={round(abs($2))}
 fi

 if $border_size>0
  sqr_size={$ref_sqr_size+$border_size}
 else
  sqr_size=$ref_sqr_size
 fi

elif !$border_direction||$ref_sqr_size==1

 if $use_percent border_size={round(($ref_sqr_size-1)*abs($2))}
 else border_size={min(round(abs($2)),$ref_sqr_size-1)}
 fi
 sqr_size=$ref_sqr_size

else
 border_size=0
 sqr_size=$ref_sqr_size
fi

border_value={cut($3,0,1)}

if ${is_image_arg\ $5}

 pass$5 0

 if !((w>1&&h==1)||(w==1&&h>1)) error dim_inv fi

 local[-1] {

  if w>h
   s x
  else
   s y
  fi

  remove_duplicates
  a x
 }

else

 +pal $5

 cs=0

fi

if w#-1<5 error min_cols>=5==F fi

if narg($6)

 test_color=${rep_hex2int8\ $6}

 1,1,1,{s},"vectors("$test_color")"

 if $8 $convert_colors_fwd. fi

 eval.. "begin(test_color=I(#-1,0,0,0););if(I==test_color,run('error inval_bant'));"

 empty_color=[{[crop(#-1),255]}]

 rm.

else
 empty_color=vector(#s,0)
fi

if $border_size
 condition_text=condition=(nx>=border_size)&&(ny>=border_size);
 result=condition?color:border_color
else
 result=color
fi

mode={$7%2}

border_value={cut($3,0,1)}

if ${is_image_arg\ $5}

 1,1,1,3,[{vector3($border_value*255)}]

 if $cs $convert_colors_fwd. fi

 init_border_color={crop(#-1)}

 rm.

else init_border_color={vector3($border_value*255)}
fi

use_bg_color=0

if narg($9)&&!$mode bg_color=${9--1},255 use_bg_color=1 fi

repeat $!-1 l[$>,-1]

 if $mode
  mini_w={ceil(w#0/$sqr_size)}
  mini_h={ceil(h#0/$sqr_size)}
 else
  mini_w={int(w#0/$sqr_size)}
  mini_h={int(h#0/$sqr_size)}
 fi

 large_w={$mini_w*$sqr_size+$border_size}
 large_h={$mini_h*$sqr_size+$border_size}

 if $mode

  if ($large_w-$sqr_size)>w#0
   large_w-=$sqr_size
   mini_w-=1
  fi

  if ($large_h-$sqr_size)>h#0
   large_h-=$sqr_size
   mini_h-=1
  fi

 else

  if $large_w>w#0
   large_w-=$sqr_size
   mini_w-=1
  fi

  if $large_h>h#0
   large_h-=$sqr_size
   mini_h-=1
  fi

 fi

 $mini_w,$mini_h,1,1,"begin(
   const probability=cut($4,0,1);
   if(probability==1,
    calc_result()=v(0,w#-1,1,0);,
    calc_result()=u(1)<probability?v(0,w#-1,1,0):-1;
   );
  );
  calc_result();"

 f. >"begin(
   const num_of_colors=w#-2;
   const mx=w-1;
   const my=h-1;
   find_new_color()=(
    new_col_id=v(0,num_of_colors,1,0);
    do(++new_col_id;,cols[new_col_id%num_of_colors]);
    new_col_id%num_of_colors;
   );
  );
  cols=vector(#num_of_colors,0);
  (i+1)?(
   (x==0&&y==0)?(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    find_new_color();
   ):
   (x==mx&&y==0)?(
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    find_new_color();
   ):
   (x==0&&y==my)?(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (x==mx&&y==my)?(
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (x==0)?(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (x==mx)?(
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (y==0)?(
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    find_new_color();
   ):
   (y==my)?(
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    find_new_color();
   ):(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   );
  ):-1"

  $large_w,$large_h,1,{s#-2+1},*"begin(
   const col_s=s#-2;
   const border_size=$border_size;
   modv(a)=a-int(a/$sqr_size)*$sqr_size;
   mini(a)=int(a/$sqr_size);
   border_color=["$init_border_color",255];
   empty_color="$empty_color";
  );
  nx=modv(x);
  ny=modv(y);
  mx=mini(x);
  my=mini(y);
  "$condition_text"
  color_pos=i(#-1,mx,my,0,0);
  color=(color_pos+1)?[I(#-2,color_pos,0,0),255]:empty_color;
  "$result";"

 if $use_bg_color
  {w#0},{h#0},1,{s#-3+1},"["$bg_color"]"
  j[-1] [-2],.5~,.5~
  rv[0,-1]
  rm[-3--1]
 else
  if !$mode
   r. {w#0},{h#0},1,100%,0,0,.5,.5
  fi
  rv[0,-1]
  rm[-2--1]
 fi

 if $cs
  if $cs!=3
   $convert_colors_bwd[0]
  else
   if s#0==5
    s[0] c,-4 cmyk2rgb[0] a[0,1] c
   else
    cmyk2rgb[0]
   fi
  fi
 fi

done done

rm.
#@cli rep_compb : eq. to 'rep_complexion_burst'
rep_compb: rep_complexion_burst $*
#@cli rep_complexion_burst: _points>0,_density>0,_H,_K,_zoom,_rotation_angle,_origin_x,_origin_y,_numbers_extraction_mode={ 0=Individual | 1=Additive },_mode={ 0=C-4 | C=C-6},_f1={ 0=csin | 1=ccos | 2=ctan | 3=clog},...
#@cli : Complex-Plane adaptation of the Pickover Popcorn Fractal. Discovered By Reptorian.\n
#@cli : _points defines the maximum number of points to be added on image based on pixel location.
#@cli : _density defines the frequency of points to be added along row and height of image. A value of one implies n points to be added per pixel.
#@cli : _H is the function multiplier used to subtract from the new found values from each iteration. Use "[H_A,H_B]" and replace
#@cli : _K is the inner multiplier for the inside function. Use "[K_A,K_B]" and replace each K_ with a number. See popcorn_x(a,b), and popcorn_y(a,b) embedded within the code of rep_popcorn_fractal for more information.
#@cli : _zoom defines the magnification of image. A negative value will "shrink" the structure of generated fractal.
#@cli : _rotation_angle defines the function angle of fractal.
#@cli : _origin_x defines the position of fractal. Center of image row will be treated as zero, and the ranges for image row are treated as -1,1.
#@cli : _origin_y defines the position of fractal. Center of image column will be treated as zero, and the ranges for image column are treated as -1,1.
#@cli : _mode defines whether to use 4 trigonometric functions or 6 complex-plane trigonometric functions. Each halves of functions are used on 2 functions used by different axis.
#@cli : _fn defines individual function used for the popcorn fractal.\n
#@cli : Author: Reptorian.
#@cli : Default values: '_points=50','density=1','H=[.05,1]','_K=[3,1]','_rotation_angle=0','_origin_x=0','_origin_y=0','_mode=0',...\n
#@cli : \ \ \ \ If _mode=0: ... = '_f1=_f3=0','_f2=_f4=2'
#@cli : \ \ \ \ If _mode=1: ... = '_f1=_f4=0','_f2=_f5=1','_f3=_f6=2'\n
rep_complexion_burst:
skip ${1=50},${2=1},${3=[.05,1]},${4=[3,1]},${5=.25},${6=0},${7=0},${8=0},${9=0},${10=1},${11=0},${12=},${13=},${14=},${15=},${16=},${17=}

if $9
	xnew_text=(plane_a+plane_b)[0]
	ynew_text=(plane_a+plane_b)[1]
else
	xnew_text=(plane_a)[0]
	ynew_text=(plane_b)[1]
fi

if ($6-360*floor($6/360))?1
	fvx=((rot_x($xnew_text,$ynew_text)-osx)*icx_zoom+cxsx)/sx
	fvy=((rot_y($xnew_text,$ynew_text)-osy)*icy_zoom+cysy)/sy
else
	fvx=(($xnew_text-osx)*icx_zoom+cxsx)/sx
	fvy=(($ynew_text-osy)*icy_zoom+cysy)/sy
fi

tmx={w-1}
tmy={h-1}

channels. 0 f. 0

{int(w*abs($2))},{int(h*abs($2))},1,1,":begin_t(
		const max_x=w-1;
		const max_y=h-1;
		const target_max_x=$tmx;
		const target_max_y=$tmy;
		const icx=target_max_x/2;
		const icy=target_max_y/2;
		const pts=$1;
		H=$3;
		K=$4;
		const zoom=1/$5;
		const ang=($6/180)*pi;
		const origin_x=$7*-1*zoom;
		const origin_y=$8*zoom;
		const sd=max(w,h)/min(w,h);
		const sx=w>h?sd:1;
		const sy=w>h?1:sd;
		const sx_zoom=sx*zoom;
		const sy_zoom=sy*zoom;
		const cx=(max_x-1)/2;
		const cy=(max_y-1)/2;
		const osx=origin_x*sx;
		const osy=origin_y*sy;
		const icx_zoom=icx/zoom;
		const icy_zoom=icy/zoom;
		const cxsx=icx*sx;
		const cysy=icy*sy;
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		$10?(
			if(narg($11),
				const argpos10=$11%4;
				argpos10==0?func_a(a)=csin(a):
				argpos10==1?func_a(a)=ccos(a):
				argpos10==2?func_a(a)=ctan(a):
				argpos10==3?func_a(a)=clog(a);
				,func_a(a)=csin(a);
			);
			if(narg($12),
				const argpos11=$12%4;
				argpos11==0?func_b(a)=csin(a):
				argpos11==1?func_b(a)=ccos(a):
				argpos11==2?func_b(a)=ctan(a):
				argpos11==3?func_b(a)=clog(a);
				,func_b(a)=ccos(a);
			);
			if(narg($13),
				const argpos12=$13%4;
				argpos12==0?func_c(a)=csin(a):
				argpos12==1?func_c(a)=ccos(a):
				argpos12==2?func_c(a)=ctan(a):
				argpos12==3?func_c(a)=clog(a);
				,func_c(a)=ctan(a);
			);

			if(!narg($14),
				if(narg($11),
					argpos10==0?func_d(a)=csin(a):
					argpos10==1?func_d(a)=ccos(a):
					argpos10==2?func_d(a)=ctan(a):
					argpos10==3?func_d(a)=clog(a);
					,func_d(a)=csin(a);
				);,
			const argpos13=$14%4;
			argpos13==0?func_d(a)=csin(a):
			argpos13==1?func_d(a)=ccos(a):
			argpos13==2?func_d(a)=ctan(a):
			argpos13==3?func_d(a)=clog(a);
			);
			if(!narg($15),
				if(narg($12),
					argpos11==0?func_e(a)=csin(a):
					argpos11==1?func_e(a)=ccos(a):
					argpos11==2?func_e(a)=ctan(a):
					argpos11==3?func_e(a)=clog(a);
					,func_e(a)=ccos(a);
				);,
			const argpos14=$15%4;
			argpos14==0?func_e(a)=csin(a):
			argpos14==1?func_e(a)=ccos(a):
			argpos14==2?func_e(a)=ctan(a):
			argpos14==3?func_e(a)=clog(a);
			);
			if(!narg($16),
				if(narg($13),
					argpos12==0?func_f(a)=csin(a):
					argpos12==1?func_f(a)=ccos(a):
					argpos12==2?func_f(a)=ctan(a):
					argpos12==3?func_f(a)=clog(a);
					,func_f(a)=ctan(a);
				);,
			const argpos15=$16%4;
			argpos15==0?func_f(a)=csin(a):
			argpos15==1?func_f(a)=ccos(a):
			argpos15==2?func_f(a)=ctan(a):
			argpos15==3?func_f(a)=clog(a);
			);

			popcorn_x(a,b)=(Kb=K**b;a-H**func_a(b+func_b(Kb+func_c(Kb))));
			popcorn_y(a,b)=(Ka=K**a;b-H**func_d(a+func_e(Ka+func_f(Ka))));

		):(
			if(narg($11),
				const argpos10=$11%4;
				argpos10==0?func_a(a)=csin(a):
				argpos10==1?func_a(a)=ccos(a):
				argpos10==2?func_a(a)=ctan(a):
				argpos10==3?func_a(a)=clog(a);
				,func_a(a)=csin(a);
			);
			if(narg($12),
				const argpos11=$12%4;
				argpos11==0?func_b(a)=csin(a):
				argpos11==1?func_b(a)=ccos(a):
				argpos11==2?func_b(a)=ctan(a):
				argpos11==3?func_b(a)=clog(a);
				,func_b(a)=ctan(a);
			);

			if(!narg($13),
				if(narg($11),
					argpos10==0?func_c(a)=csin(a):
					argpos10==1?func_c(a)=ccos(a):
					argpos10==2?func_c(a)=ctan(a):
					argpos10==3?func_c(a)=clog(a);
					,func_c(a)=csin(a);
				);,
			const argpos12=$13%4;
			argpos12==0?func_c(a)=csin(a):
			argpos12==1?func_c(a)=ccos(a):
			argpos12==2?func_c(a)=ctan(a):
			argpos12==3?func_c(a)=clog(a);
			);
			if(!narg($14),
				if(narg($12),
					argpos11==0?func_d(a)=csin(a):
					argpos11==1?func_d(a)=ccos(a):
					argpos11==2?func_d(a)=ctan(a):
					argpos11==3?func_d(a)=clog(a);
					,func_d(a)=ctan(a);
				);,
			const argpos13=$14%4;
			argpos13==0?func_d(a)=csin(a):
			argpos13==1?func_d(a)=ccos(a):
			argpos13==2?func_d(a)=ctan(a):
			argpos13==3?func_d(a)=clog(a);
			);

			popcorn_x(a,b)=a-H**func_a(b+func_b(K**b));
			popcorn_y(a,b)=b-H**func_c(a+func_d(K**a));

		);
	);
	real=sx_zoom*(x-cx)/cx;
	imag=sy_zoom*(y-cy)/cy;
	real+=origin_x;
	imag+=origin_y;
	z_plane_a=[real,0];
	z_plane_b=[0,imag];
	repeat(pts,
		plane_a=popcorn_x(z_plane_a,z_plane_b);
		plane_b=popcorn_y(z_plane_a,z_plane_b);
		zn=sum(sqr((plane_a)[0]),sqr((plane_b)[1]));
		plane_a/=zn;
		plane_b/=zn;
		real_val="$fvx";
		imag_val="$fvy";
		rpos=round(real_val);
		ipos=round(imag_val);
		i(#-1,rpos,ipos)++;
		z_plane_a=plane_a;
		z_plane_b=plane_b;
	);"
rm.
#@cli rep_rainbowify: -360<_hue_shift<360,-360<_gradient_angle<360,_gradient_scale[%]>0
#@cli : Apply rainbowify effect into image. Inspired by Rainbowify effect made by Jonathan Frech. The original source of the Rainbowify effect is found in the following URL - https://blog.jfrech.com/180/.
#@cli : Default values: '_hue_shift=0','_gradient_angle=0','_gradient_angle=100%'
#@cli : Author: Reptorian.
rep_rainbowify:
skip ${1=0},${2=0},${3=100%}

foreach {

	if s>4 continue fi
	if s==4 sh 0,2 fi

	if s<3
		command "cmd_rainbowify : {w},{h},100%,{s==2?4:3},\"$""1\""
		command "cmd_$0_end_out : k."
		calc_v="i(#0,x,y,z,0)"
	else
		command "cmd_rainbowify : fill. \"$""1\""
		command "cmd_$0_end_out : k[0]"
		calc_v=avg(I)
	fi

	if s==2 calc_rainbow="[hue2rgb(fmod(v+pos+shift_hue)),i(#0,x,y,z,1)]"
	else calc_rainbow=hue2rgb(fmod(v+pos+shift_hue))
	fi

	cmd_rainbowify. "begin(
		const shift_hue=$1+180;
		const ang=($2/180)*pi;
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		const sd=max(w,h)/min(w,h);
		const sx=w>h?sd:1;
		const sy=w>h?1:sd;
		const ww=w-1;
		const hh=h-1;
		const cx=ww/2;
		const cy=hh/2;
		const cxsx=cx/sx;
		const cysy=cy/sy;
		const m=360/255;
		const rescale_pos=180*$3;
		fmod(a)=a-360*floor(a/360);
		hue2rgb(h)=(
			H=(h/60)%6;
			K=(1-abs(H%2-1))*255;
			arg1(1+int(H),[255,K,0],[K,255,0],[0,255,K],[0,K,255],[K,0,255],[255,0,K]);
		);
	);
	px=(x-cx)/cxsx;
	py=(y-cy)/cysy;
	pos=rot_y(px,py)*rescale_pos;
	v="$calc_v"*m;
	"$calc_rainbow";
	"

	cmd_$0_end_out

	uncommand cmd_rainbowify,cmd_$0_end_out

}
#@cli rep_w_rgb82gray: eq. to 'rep_weighted_rgb82gray'
rep_w_rgb82gray: rep_weighted_rgb82gray $*
#@cli rep_weighted_rgb82gray: 0%<=red_weight<=100%,0%<=green_weight<=100%,0%<=blue_weight<=100%,_use_weighted_ratio={ 0=no | 1= yes },0<=_minval_weight[%]<=100%,,0<=_maxval_weight[%]<=100%,,0<=_balance_minmax<=1,0<=_endvaladj<=255,-1<=_midgrayadj<=1
#@cli : Convert images to grayscale image based on different weights, the usage of min/max val, and post-process value adjustment.
#@cli : Default values: '_use_weighted_ratio=1','_minval_weight=0%','_maxval_weight=0%','_balance_minmax=50%','_endvaladj=0','_midgrayadj=0'
#@cli : Author: Reptorian.
#@cli : $ sp car rep_weighted_rgb82gray 10%,50%,70%,,,,,,-.25
rep_weighted_rgb82gray:
skip ${4=1},${5=0%},${6=0%},${7=50%},${8=0},${9=0}
use_merge_back=0

single_channel_mode=0

foreach {

	if s==4
		split_opacity
		store. alpha_image
		use_merge_back=1
	elif s==2
		split_opacity
		store. alpha_image
		use_merge_back=1
	elif s>4 continue
	fi

	if s==1
		command "cmd_$0_calc_gray_image : fill. \"$""1\""
		single_channel_mode=1
	else
		command "cmd_$0_calc_gray_image : {w},{h},100%,1,\"$""1\""
	fi

	cmd_$0_calc_gray_image "
		begin(
			const red_weight_init=$1;
			const green_weight_init=$2;
			const blue_weight_init=$3;
			const total_weight=red_weight_init+green_weight_init+blue_weight_init;
			if($4,
				const red_weight=red_weight_init/total_weight;
				const green_weight=green_weight_init/total_weight;
				const blue_weight=blue_weight_init/total_weight;
			,
				const red_weight=red_weight_init;
				const green_weight=green_weight_init;
				const blue_weight=blue_weight_init;
			);
			rescale_color=[red_weight,green_weight,blue_weight];
			(!$5&&!$6)?(
				calc_gray()=sum(I#-1*rescale_color);
			):
			$5&&$6?(
				calc_gray()=(
					col_ref=I#-1;
					start_col_ref=col_ref*rescale_color;
					minval=cut(lerp(sum(start_col_ref),min(col_ref),$5),0,255);
					maxval=cut(lerp(sum(start_col_ref),max(col_ref),$6),0,255);
					balval=lerp(minval,maxval,$7);
				);
			):(
				$6?(
					calc_gray()=(
						col_ref=I#-1;
						start_col_ref=col_ref*rescale_color;
						maxval=cut(lerp(sum(start_col_ref),max(col_ref),$6),0,255);
					);
				):(
					calc_gray()=(
						col_ref=I#-1;
						start_col_ref=I#-1*rescale_color;
						minval=cut(lerp(sum(start_col_ref),min(col_ref),$5),0,255);
					);
				);
			);
			abs($9)?(
				calc_gray_output()=cut(calc_gray(),0,255);
			):(
				calc_gray_output()=cut(calc_gray()+$8,0,255);
			);
		);
		calc_gray_output();"

	if abs($9)
		if $9>0
			f. "begin(
				const expf=cut(1-abs($9),0,1);
			);
			cut(((i/255)^expf)*255+$8,0,255)"
		else
			f. "begin(
				const expf=cut(1-abs($9),0,1);
			);
			cut(255-(((255-i)/255)^expf)*255+$8,0,255)"
		fi
	fi

	if !$single_channel_mode
		k.
		if $use_merge_back
			$alpha_image a c
		fi
	fi

	use_merge_back=0

	uncommand cmd_$0_calc_gray_image
}
#@cli rep_hex8args2pal: hex_a,hex_b...
#@cli : Convert 8-bit hexadecimal arguments into palette representation.
+rep_hex8args2pal:
if size('$-1')==1
	axis,axis_arg={_'$-1'-_'x'},1
	if $#==1 error no_hex_arg fi
else
	axis,axis_arg=0,0
fi

('$*':,)

{L=$#-$axis_arg;v=[1,1,1];v[$axis]=L;[v,size('$1')>>1]},"
	begin(p=0;);
	current_color=vector(#s);
	!p?(
		pos=([x,y,z])[$axis];
		step=((s<<1)+1);
		p=pos*step;
	);
	repeat(s,pos,
		current_color[pos]=s2v([('0x'),crop(#-1,p,2)]);
		p+=2;
	);
	++p;
	current_color;"

rm[-2]
#@cli rep_int8args2hexargs: num_of_hexadecimal_numbers_per_values,value_1,value_2,....
#@cli : Return the hexadecimal representations of numberical arguments.
#@cli :
#@cli : Author: Reptorian.
#@cli : $ echo ${rep_int8args2hexargs\ 3,250,100,220,255,85,110}
#@cli : $ echo ${rep_int8args2hexargs\ 2,250,100,220,255,85,110}
#@cli : $ echo ${rep_int8args2hexargs\ 1,250,100,220,255,85,110}
rep_int8args2hexargs:
check "$#>2&&isint($1)&&$1>0"
number_of_int_args={$#-1}

if $number_of_int_args%$1 error !(narg(\$\{2--1\})%"$"1)==F fi

{($number_of_int_args<<1)+int($number_of_int_args/$1)-1},1,1,1,"begin(
		const color_size=$1;
		const separator_position=color_size<<1;
		const section_size=separator_position+1;
		const comma=_',';
		const _0=_'0';
		const char_ref_val=_'a'-10;
		vints=[${2--1}];
		if(min(vints)<0||max(vints)>0xff,run('error inval_num'););
		to_char(v)=if(inrange(v,0,9,1,1),_0+v,char_ref_val+v);
	);
	color_section=int(x/section_size);
	val_pos=x%section_size;
	val_pos!=separator_position?(
		num_arg_pos=(val_pos>>1)+color_section*color_size;
		decimal_number=vints[num_arg_pos];
		val_pos&1?to_char(decimal_number%16):to_char(decimal_number>>4);
	):comma;
	"

status {t} rm.
#@cli rep_hex2int8: hexadecimal_string
#@cli : Convert a hexadecimal argument into 8-bit representation, and then return the converted value.
#@cli :
#@cli : Author: Reptorian.
rep_hex2int8:
eval "
	str_hex='$1';
	const s_str_hex=size(str_hex);
	if(s_str_hex&1,run('error inv_arg'));
	result=vector(#s_str_hex>>1);
	q=0;
	repeat(size(result),p,
		result[p]=s2v([('0x'),str_hex[q,2]]);
		q+=2;
	);
	result;"
#@cli rep_int82hex: 0<=8-bit_value<=255...
#@cli : Convert 8-bit numberical argument(s) into hexadecimal representation.
#@cli :
#@cli : Author: Reptorian.
rep_int82hex:
{narg($*)<<1},1,1,1,"begin(
		const _0=_'0';
		const char_ref_val=_'a'-10;
		vchar=[$*];
		if(min(vchar)<0||max(vchar)>255,run('error invalid_number'););
		to_char(v)=if(inrange(v,0,9,1,1),_0+v,char_ref_val+v);
	);
	p=x>>1;
	x&1?(
		to_char(vchar[p]&0b1111);
	):(
		to_char(vchar[p]>>4);
	);"

u {t} rm.
#@cli rep_mlfrac_anim: eq. to 'rep_markus_lyapunov_fractal_animation
rep_mlfrac_anim: rep_markus_lyapunov_fractal_animation $*
#@cli rep_markus_lyapunov_fractal_animation: abc_string,abc_string_repeats,_sublevel>=0,0%<_view_size[%]<=100%,0%<=_pos_x[%]<=100%,0%<=_pos_y[%]<=100%,0%<=_pos_z_a[%]<=100%,0%<=_pos_z_b[%]<=100%,additional_arguments(see below)
#@cli : Generate an animation of Markus-Lyapunov Fractal or in other words, creates an animation demonstrating mapping of Lyapunov exponent within three values. Each frame represent a cross-section of a 3D Markus-Lyapunov Fractal.
#@cli :
#@cli : [1] http://charles.vassallo.pagesperso-orange.fr/en/lyap_art/lyapdoc.html
#@cli :
#@cli : (eq. to 'rep_mlfrac_anim')
#@cli : Note: Input for abc_string is case-insensitive. Only valid characters are A,a,B,b,C,c.
#@cli : Additional note: Depth of target image defines number of frames.
#@cli :
#@cli : --- Information on 'additional_arguments' ---
#@cli : The following set of arguments are accepted as additional arguments for the command:
#@cli :
#@cli : 1 - use_inversion={ 0=do_not_use_inversion | 1=use_inversion }
#@cli : 2* - hex_color_a,hex_color_b
#@cli : 3** - 'u',color_count>0,color_space={ 0=hsl | 1=lab | 2=lch }
#@cli : 4** - 'u','u',n_colors_a>0,n_colors_b>0,cs={ 0=hsl | 1=lab | 2=lch }
#@cli : 5*** - [image],order={ 0=default | 1=random | 2=mirrored },color_count
#@cli : 6*** - [image],[image],order_a={ 0=default | 1=random | 2=mirrored },use_randomize_b={ 0=default | 1=random | 2=mirrored },color_count_a,color_count_b
#@cli :
#@cli : * = No special characters or space! Only 0-9 and a-f case-insensitive.
#@cli : ** = 'u' means that the input you assigned is exactly 'u'.
#@cli : *** = If you assign a image with width and height both larger than 1, then you need to assign color_count in the respective place. use_randomize is used to randomize the colors in palette.
#@cli :
#@cli : Notes: See examples for usage of these additional variables.
#@cli :
#@cli : --- End of Information on 'additional_arguments' ---
#@cli : Default values: '_sublevel=1','_view_size=100%','_pos_x=50%','_pos_y=50%'
#@cli :
#@cli : Author: Reptorian.
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,1
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,0000ff,ffff00
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,u,8,1
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,u,u,5,8,2
#@cli : $ 50,50,50 +pal 71 rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[1],0 rm.
#@cli : $ 50,50,50 +pal 20 +pal 50 rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[1],[2],0,0 rm[-2,-1]
#@cli : $ 50,50,50 sp cat rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[1],0,9 rm.
#@cli : $ 50,50,50 sp cat sp lena rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[-2],[-1],1,1,8,8 rm[-2,-1]
rep_markus_lyapunov_fractal_animation:
skip "${3=1}","${4=100%}","${5=50%}","${6=50%}","${7=0%}","${8=100%}","${9=0}","${10=}","${11=}","${12=}","${13=}","${14=}"
check (abs($4)!=0)&&($!==1)&&(w#-1>1&&h#-1>1&&d#-1>1)

strlowercase $1
ab_string=${}
a:=_'a'

('$ab_string') -. $a

include_a,\
include_b,\
include_c\
={[im==0,find(crop(#-1),1,0,1)!=-1,iM==2]}

if im#-1<0||iM#-1>2 error invalid_char_found! fi
if !($include_a&&$include_b&&$include_c) error invalid_string fi

ab_string={crop(#-1)}
rm.

mode,use_double_u,use_hex_mode,sub=0,{abs($3)+1}

ow,oh,od,nw,nh={[w,h,d,round([w,h]*$sub)]}

if narg($9)||narg($10)

 if ${is_image_arg\ $9} mode+=1
  pass$9 0
 fi
 if ${is_image_arg\ $10} mode+=1
  pass$10 0
 fi

 if $mode==2

  if w#-2>1&&h#-2>1
   colormap.. $13
   if ($11%3)==1
    {w#-2},1,1,1,u(0,1)
    pixelsort... +,x,[-1]
    rm.
   elif ($11%3)==2
    mirror.. x
   fi
   find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
  else
   if w#-2>1
    if ($11%3)==1
     {w#-2},1,1,1,u(0,1)
     pixelsort... +,x,[-1]
     rm.
    elif ($11%3)==2
     mirror.. x
    fi
    find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
   else
    if ($11%3)==1
     1,{h#-2},1,1,u(0,1)
     pixelsort... +,y,[-1]
     rm.
    elif ($11%3)==2
     mirror.. y
    fi
    find_color_a=I(#-1,0,lyapunov_surface/minv*v_length_b,0,1);
   fi
  fi

  if w#-1>1&&h#-1>1
   colormap. $14
   if ($12%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($12%3)==2
    mirror. x
   fi
   find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
  else
   if w#-1>1
    if ($12%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($12%3)==2
     mirror. x
    fi
    find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
   else
    if ($12%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($12%3)==2
     mirror. y
    fi
    find_color_b=I(#-2,0,lyapunov_surface/maxv*v_length_a,0,1);
   fi
  fi

  store. ref_colors_b
  store. ref_colors_a

 elif $mode==1

  if w>1&&h>1
   colormap. $11
   if ($10%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($10%3)==2
    mirror. x
   fi
   find_color_a=I(#-1,lyapunov_surface,0,0,1)
  else
   if w>1
    if ($10%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($10%3)==2
     mirror. x
    fi
    find_color_a=I(#-1,lyapunov_surface,0,0,1)
   else
    if ($10%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($10%3)==2
     mirror. y
    fi
    find_color_a=I(#-1,0,lyapunov_surface,0,1)
   fi
  fi
  store. ref_gradient

 else

  if same('$9','u')&&same('$10','u')

   mode=3
   use_double_u=1
   if narg($11)&&narg($12)
    if narg($13)
     if ($13%3)==2 cs_out=lch82rgb
     elif ($13%3)==1 cs_out=lab82rgb
     else cs_out=hsl82rgb
     fi
    else cs_out=hsl82rgb
    fi
    $11,1,1,3,u(0,255)
    $12,1,1,3,u(0,255)
    store. ref_rand_col_a
    store. ref_rand_col_b
   else error needs size_arg
   fi

  else

   if same('$9','u')&&same('$10','u')
    mode=3
    if narg($11)
     if ($11%3)==2 cs_out=lch82rgb
     elif ($11%3)==1 cs_out=lab82rgb
     else cs_out=hsl82rgb
     fi
    else cs_out=hsl82rgb
    fi
    if narg($12) srand $12 fi
    if same('$9','u')
     $10,1,1,3,u(0,255)
     store. ref_colors
    else
     $9,1,1,3,u(0,255)
     store. ref_colors
    fi
   else
    if (!(size('$9')%2))&&(!(size('$10')%2))
     use_hex_mode=1
     hex_color_a=${rep_hex2int8\ $9}
     hex_color_b=${rep_hex2int8\ $10}
    fi
   fi
  fi
 fi
fi

out_lyapunov=limit
if !$mode&&!$use_hex_mode if $9 out_lyapunov=-limit fi fi

$nw,$nh,100%,1,":begin(
  const sqr_size=cut(abs($4),0,1);
  const gap=1-sqr_size;
  const px=cut($5,0,1)*gap;
  const py=cut($6,0,1)*gap;
  const pz_a_init=cut($7,0,1);
  const pz_b_init=cut($8,0,1);
  const pz_a=min(pz_a_init,pz_b_init)*2+2;
  const pz_b=max(pz_a_init,pz_b_init)*2+2;
  const lx=px*2+2;
  const ly=py*2+2;
  const rx=(px+sqr_size)*2+2;
  const ry=(py+sqr_size)*2+2;
  const inc_w=w+1;
  const inc_h=h+1;
  const inc_d=d+1;

  v_sequence=["$ab_string"];
  const seqsize=size(v_sequence);
  const vsize=round(max(1,abs($2))*seqsize);
 );
 ix=lerp(lx,rx,(x+1)/inc_w);
 iy=lerp(ry,ly,(y+1)/inc_h);
 iz=lerp(pz_a,pz_b,(z+1)/inc_d);
 vn=0.5;
 limit=0;
 repeat(vsize,n,
  sp = n % seqsize;
  rn=arg1(v_sequence[sp]+1,ix,iy,iz);
  vn=rn*vn*(1-vn);
  limit+=log(abs(rn*(1-2*vn)));
 );
 "$out_lyapunov";
 "

if $mode==3

 if $use_double_u

  $ref_rand_col_a
  $ref_rand_col_b

  $nw,$nh,$od,3,"begin_t(
    const minv=im#-3;
    const maxv=iM#-3;
    const ww_a=w#-2-1;
    const ww_b=w#-1-1;
   );
   lyapunov_surface=i0#-3;
   use_b=lyapunov_surface>=0;
   use_b?(I(#-1,lyapunov_surface/maxv*ww_b,0,0,1);)
        :(I(#-2,lyapunov_surface/minv*ww_a,0,0,1););"

  cs_out.
 else

  $ref_colors

  $nw,$nh,$od,3,"begin(
    const minv=im#-2;
    const maxv=iM#-2;
    const vs=w#-1-1;
    const diff=(maxv-minv)/vs;
   );
   lyapunov_surface=(i0#-2-minv)/diff;
   I(#-1,lyapunov_surface,0,0,1);"

  cs_out.
 fi

elif $mode==2

 $ref_colors_a
 $ref_colors_b

 $nw,$nh,$od,{max(s#-2,s#-1)},"begin_t(
   const minv=im#-3;
   const maxv=iM#-3;
   const v_length_a=max(w#-2-1,h#-2-1);
   const v_length_b=max(w#-1-1,h#-2,-1);
  );
  lyapunov_surface=i0#-3;
  use_b=lyapunov_surface>=0;
  use_b?("$find_color_b")
       :("$find_color_a");"

elif $mode==1

 $ref_gradient

 $nw,$nh,$od,{s#-1},"begin_t(
   const minv=im#-2;
   const maxv=iM#-2;
   const v_length=max(w#-1-1,h#-1-1);
   const diff=(maxv-minv)/v_length;
  );
  lyapunov_surface=(i0#-2-minv)/diff;
  "$find_color_a";"

elif $use_hex_mode
  $nw,$nh,$od,3,"begin_t(

   hex_a=["$hex_color_a"];
   hex_b=["$hex_color_b"];

   const minv=im#-1;
   const maxv=iM#-1;

   const hpi=pi/2;

   contrast(a)=(
    b=a*pi-hpi;
    .5*a^2+.5*(sin(b)+1)/2;
   );
  );
  v=i0#-1;
  shade=v>=0?v/maxv:contrast((1-(v/minv)^(1/2)))^2;
  col=v>=0?hex_a:hex_b;
  col*shade;"
fi

k.

s z r $ow,$oh,1,100%,6
#@cli rep_mlfrac: eq. to 'rep_markus_lyapunov_fractal'.
rep_mlfrac: rep_markus_lyapunov_fractal $*
#@cli rep_markus_lyapunov_fractal: abc_string,abc_string_repeats,_sublevel>=0,0%<_view_size[%]<=100%,0%<=_pos_x[%]<=100%,0%<=_pos_y[%]<=100%,0%<=_pos_z[%]<=100%,additional_arguments(see below)
#@cli : Generate Markus-Lyapunov Fractal or in other words, creates a mapping of Lyapunov exponent within two or three values.[1] Discovered by Mario Markus of the Max Planck Institute for Nutrition. Alexander Lyapunov was the one that discovered Lyapunov exponent.
#@cli :
#@cli : [1] http://charles.vassallo.pagesperso-orange.fr/en/lyap_art/lyapdoc.html
#@cli :
#@cli : (eq. to 'rep_mlfrac')
#@cli : Note: Input for abc_string is case-insensitive. Only valid characters are A,a,B,b,C,c.
#@cli :
#@cli : --- Information on 'additional_arguments' ---
#@cli : The following set of arguments are accepted as additional arguments for the command:
#@cli :
#@cli : 1 - use_inversion={ 0=do_not_use_inversion | 1=use_inversion }
#@cli : 2* - hex_color_a,hex_color_b
#@cli : 3** - 'u',color_count>0,color_space={ 0=hsl | 1=lab | 2=lch }
#@cli : 4** - 'u','u',n_colors_a>0,n_colors_b>0,cs={ 0=hsl | 1=lab | 2=lch }
#@cli : 5*** - [image],order={ 0=default | 1=random | 2=mirrored },color_count
#@cli : 6*** - [image],[image],order_a={ 0=default | 1=random | 2=mirrored },use_randomize_b={ 0=default | 1=random | 2=mirrored },color_count_a,color_count_b
#@cli :
#@cli : * = No special characters or space! Only 0-9 and a-f case-insensitive.
#@cli : ** = 'u' means that the input you assigned is exactly 'u'.
#@cli : *** = If you assign a image with width and height both larger than 1, then you need to assign color_count in the respective place. use_randomize is used to randomize the colors in palette.
#@cli :
#@cli : Notes: See examples for usage of these additional variables.
#@cli :
#@cli : --- End of Information on 'additional_arguments' ---
#@cli : Default values: '_sublevel=1','_view_size=100%','_pos_x=50%','_pos_y=50%'
#@cli :
#@cli : Author: Reptorian.
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,1
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,0000ff,ffff00
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,u,8,1
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,u,u,5,8,2
#@cli : $ 500,500 +pal 71 rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[1],0 rm.
#@cli : $ 500,500 +pal 20 +pal 50 rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[1],[2],0,0 rm[-2,-1]
#@cli : $ 500,500 sp cat rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[1],0,9 rm.
#@cli : $ 500,500 sp cat sp lena rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[-2],[-1],1,1,8,8 rm[-2,-1]
rep_markus_lyapunov_fractal:
skip "${3=1}","${4=100%}","${5=50%}","${6=50%}","${7=50%}","${8=0}","${9=}","${10=}","${11=}","${12=}","${13=}"
check "abs($4)!=0"

strlowercase $1
ab_string=${}
a:=_'a'

('$ab_string') -. $a

if im<0||iM>2 error invalid_char_found! fi

include_a,\
include_b,\
include_c\
={[im==0,find(crop(#-1),1,0,1)!=-1,iM==2]}

case_d1={!($include_a&&$include_b)}
case_dn={!(!$case_d1&&$include_c)}

ab_string={crop(#-1)}
rm.

mode,use_double_u,use_hex_mode=0
sub={abs($3)+1}

if narg($8)||narg($9)

 if ${is_image_arg\ $8} mode+=1
  pass$8 0
 fi

 if ${is_image_arg\ $9} mode+=1
  pass$9 0
 fi

 if $mode==2

  if w#-2>1&&h#-2>1
   colormap.. $12
   if ($10%3)==1
    {w#-2},1,1,1,u(0,1)
    pixelsort... +,x,[-1]
    rm.
   elif ($10%3)==2
    mirror.. x
   fi

   find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
  else
   if w#-2>1

    if ($10%3)==1
     {w#-2},1,1,1,u(0,1)
     pixelsort... +,x,[-1]
     rm.
    elif ($10%3)==2
     mirror.. x
    fi

    find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
   else

    if ($10%3)==1
     1,{h#-2},1,1,u(0,1)
     pixelsort... +,y,[-1]
     rm.
    elif ($10%3)==2
     mirror.. y
    fi

    find_color_a=I(#-1,0,lyapunov_surface/minv*v_length_b,0,1);
   fi
  fi

  if w#-1>1&&h#-1>1

   colormap. $13

   if ($11%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($11%3)==2
    mirror. x
   fi

   find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
  else

   if w#-1>1
    if ($11%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($11%3)==2
     mirror. x
    fi

    find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
   else

    if ($11%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($11%3)==2
     mirror. y
    fi

    find_color_b=I(#-2,0,lyapunov_surface/maxv*v_length_a,0,1);
   fi
  fi

  store. ref_colors_b
  store. ref_colors_a

 elif $mode==1

  if w>1&&h>1

   colormap. $10

   if ($9%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($9%3)==2
    mirror. x
   fi

   find_color_a=I(#-1,lyapunov_surface,0,0,1)
  else
   if w>1

    if ($9%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($9%3)==2
     mirror. x
    fi

    find_color_a=I(#-1,lyapunov_surface,0,0,1)
   else

    if ($9%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($9%3)==2
     mirror. y
    fi

    find_color_a=I(#-1,0,lyapunov_surface,0,1)
   fi
  fi
  store. ref_gradient

 else

  if same('$8','u')&&same('$9','u')

   mode=3
   use_double_u=1

   if narg($10)&&narg($11)
    if narg($12)
     if ($12%3)==2 cs_out=lch82rgb
     elif ($12%3)==1 cs_out=lab82rgb
     else cs_out=hsl82rgb
     fi
    else cs_out=hsl82rgb
    fi

    $10,1,1,3,u(0,255)
    $11,1,1,3,u(0,255)

    store. ref_rand_col_a
    store. ref_rand_col_b

   else error needs size_arg
   fi

  else

   if same('$8','u')&&same('$9','u')

    mode=3

    if narg($10)
     if ($10%3)==2 cs_out=lch82rgb
     elif ($10%3)==1 cs_out=lab82rgb
     else cs_out=hsl82rgb
     fi
    else cs_out=hsl82rgb
    fi

    if narg($11) srand $11 fi

    if same('$8','u')
     $9,1,1,3,u(0,255)
     store. ref_colors
    else
     $8,1,1,3,u(0,255)
     store. ref_colors
    fi

   else

    if (!(size('$8')%2))&&(!(size('$9')%2))
     use_hex_mode=1
     hex_color_a=${rep_hex2int8\ $8}
     hex_color_b=${rep_hex2int8\ $9}
    fi

   fi
  fi
 fi
fi

out_lyapunov=limit
if !$mode&&!$use_hex_mode if $8 out_lyapunov=-limit fi fi

foreach {

 ow,oh,od={[w,h,d]}
 nw,nh={round([w,h]*$sub)}
 nd={d>1?d*$sub:1}

 if d>1

  if $case_dn error "At least one of the abc character is not found!" fi

  pz_text="const pz=cut($7,0,1)*gap;"
  lz_text="const lz=pz*2+2;"
  rz_text="const rz=(pz+sqr_size)*2+2;"
  inc_d="const inc_d=d+1;"
  calc_iz_text="iz=lerp(lz,rz,(z+1)/inc_d);"

 else

  if $case_d1 error "At least one of the ab character is not found!" fi

  const_iz_text="const iz=lerp(2+1/(max(w,h,d)+1),2+max(w,h,d)/(max(w,h,d)+1)*2,$7);"

 fi

 $nw,$nh,$nd,1,":begin_t(

  const sqr_size=cut(abs($4),0,1);
  const gap=1-sqr_size;
  const px=cut($5,0,1)*gap;
  const py=cut($6,0,1)*gap;
  "$pz_text"
  const lx=px*2+2;
  const ly=py*2+2;
  "$lz_text"
  const rx=(px+sqr_size)*2+2;
  const ry=(py+sqr_size)*2+2;
  "$rz_text"
  const inc_w=w+1;
  const inc_h=h+1;
  "$inc_d"
  "$const_iz_text"

  v_sequence=["$ab_string"];
  const seqsize=size(v_sequence);
  const vsize=round(max(1,abs($2))*seqsize);

 );
 ix=lerp(lx,rx,(x+1)/inc_w);
 iy=lerp(ry,ly,(y+1)/inc_h);
 "$calc_iz_text"
 vn=0.5;
 limit=0;
 repeat(vsize,n,
  sp = n % seqsize;
  rn=arg1(v_sequence[sp]+1,ix,iy,iz);
  vn=rn*vn*(1-vn);
  limit+=log(abs(rn*(1-2*vn)));
 );
 "$out_lyapunov";
 "

 if $mode==3

  if $use_double_u
   $ref_rand_col_a
   $ref_rand_col_b
   $nw,$nh,$nd,3,"begin_t(
     const minv=im#-3;
     const maxv=iM#-3;
     const ww_a=w#-2-1;
     const ww_b=w#-1-1;
    );
    lyapunov_surface=i0#-3;
    use_b=lyapunov_surface>=0;
    use_b?(I(#-1,lyapunov_surface/maxv*ww_b,0,0,1);)
         :(I(#-2,lyapunov_surface/minv*ww_a,0,0,1););
    "
    cs_out.
  else
   $ref_colors
   $nw,$nh,$nd,3,"begin(
    const minv=im#-2;
    const maxv=iM#-2;
    const vs=w#-1-1;
    const diff=(maxv-minv)/vs;
   );
   lyapunov_surface=(i0#-2-minv)/diff;
   I(#-1,lyapunov_surface,0,0,1);
   "
   cs_out.
  fi

 elif $mode==2

  $ref_colors_a
  $ref_colors_b
  $nw,$nh,$nd,{max(s#-2,s#-1)},"begin_t(
    const minv=im#-3;
    const maxv=iM#-3;
    const v_length_a=max(w#-2-1,h#-2-1);
    const v_length_b=max(w#-1-1,h#-2,-1);
   );
   lyapunov_surface=i0#-3;
   use_b=lyapunov_surface>=0;
   use_b?("$find_color_b")
        :("$find_color_a");
   "

 elif $mode==1

  $ref_gradient
  $nw,$nh,$nd,{s#-1},"begin_t(
    const minv=im#-2;
    const maxv=iM#-2;
    const v_length=max(w#-1-1,h#-1-1);
    const diff=(maxv-minv)/v_length;
   );
   lyapunov_surface=(i0#-2-minv)/diff;
   "$find_color_a";
   "

 elif $use_hex_mode
   $nw,$nh,$nd,3,"begin_t(

    hex_a=["$hex_color_a"];
    hex_b=["$hex_color_b"];

    const minv=im#-1;
    const maxv=iM#-1;

    const hpi=pi/2;

    contrast(a)=(
     b=a*pi-hpi;
     .5*a^2+.5*(sin(b)+1)/2;
    );
   );
   v=i0#-1;
   shade=v>=0?v/maxv:contrast((1-(v/minv)^(1/2)))^2;
   col=v>=0?hex_a:hex_b;
   col*shade;
  "
 fi

 r. $ow,$oh,$od,100%,6
 k.

 pz_text=""
 lz_text=""
 rz_text=""
 inc_d=""
 calc_iz_text=""
 const_iz_text=""

}

status {$include_c+1}
#@cli rep_randgradbar : eq. to 'rep_random_gradient_bars'
rep_randgradbar:rep_random_gradient_bars $*
#@cli rep_random_gradient_bars: width>0,spacing>0,-360<=_angle<=360,-90<_skew_angle<90,-1<=_pos_x<=1,-1<=_pos_y<=1,_sublevel>=0,_gradient_shift,_gradient_mul_a,gradient_mul_b,_bar_modulo={ -1=random | 0=cut | 1=periodic | 2=continuous },_random_modulo_out={ 0=cut_and_periodic | 1=cut_and_continuous | 2=periodic_and_continuous },_gradient_color={ 0=B&W | 1=Duotone | 2=Rand-RGB | 3=Rand-HSV },_space_color={ 0=Alpha | 1=Binary Duotone | 2=Gradient Duotone },_symmetry_mode={ 0=none | 1=sym_a | 2=sym_b },_inversion_mode={ 0=n/a | 1=random-inverse | 2=complete-inverse},_bar_hex_rgb_color_a,_bar_hex_rgb_color_b : width>0,spacing>0,-360<=_angle<=360,-90<_skew_angle<90,-1<=_pos_x<=1,-1<=_pos_y<=1,_sublevel>=0,_gradient_shift,_gradient_mul_a,gradient_mul_b,_bar_modulo={ -1=random | 0=cut | 1=periodic | 2=continuous },_random_modulo_out={ 0=cut_and_periodic | 1=cut_and_continuous | 2=periodic_and_continuous },_gradient_color={ 0=B&W | 1=Duotone | 2=Rand-RGB | 3=Rand-HSV },_space_color={ 0=Alpha | 1=Binary Duotone | 2=Gradient Duotone },_symmetry_mode={ 0=none | 1=sym_a | 2=sym_b },_inversion_mode={ 0=n/a | 1=random-inverse | 2=complete-inverse},red_1,green_1,blue_1,red_2,green_2,blue_3
#@cli : Create image filled with random bars.
#@cli :
#@cli : (eq. to 'rep_randgradbar')
rep_random_gradient_bars:
skip ${3=0},${4=0},${5=0},${6=0},${7=1},${8=0},${9=1},${10=100},${11=-1},${12=},${13=0},${14=0},${15=0},${16=0},${17=000000},${18=ffffff}
check "(abs($4)<90)&&((narg($*)==22)||(narg($*)==18))"

sub={abs($7)+1}

if narg(${17--1})==2
	color_a=${rep_hex2int8\ $17}
	color_b=${rep_hex2int8\ $18}
else
	color_a=${17-19}
	color_b=${20-22}
fi

foreach {

	ow,oh={[w,h]}

	{w*$sub},{h*$sub},1,{$13?4:2},"*begin(
			const ww=w-1;
			const hh=h-1;
			const sd=max(ww,hh)/min(ww,hh);
			const sx=ww>hh?sd:1;
			const sy=ww>hh?1:sd;
			eucl_norm(a,b)=sqrt(a^2+b^2);
			const diag_img=eucl_norm(ww,hh);
			const ww_div_sx=ww/sx;
			const hh_div_sy=hh/sy;
			const cx=ww/2;
			const cy=hh/2;
			const ox=cx-(ww*-$5);
			const oy=cy-(hh*$6);
			const skew_ang=-($4/180)*pi;
			const mdist=tan(skew_ang)*diag_img;
			const ang=-($3/180)*pi;
			const cos_ang=cos(ang);
			const sin_ang=sin(ang);
			const cut_ang=atan2(cy,cx);
			const cut_ang2=pi-cut_ang;
			const symmetry_mode=$15%3;
			const inversion_mode=($16+2)%3;

			ispercentage($1)?(
				const bar_width=max($sub,round((abs($1)*diag_img/4)));
			):(
				const bar_width=max($sub,round(abs($1)*$sub));
			);
			ispercentage($2)?(
				const space_width=abs($2)>0?max($sub,round((abs($2)*diag_img/4)));
			):(
				const space_width=round(abs($2)*$sub);
			);

			const total_width=bar_width+space_width;
			const half_total_width=total_width>1?int(total_width/2);

			(bar_width==1&&space_width<2)?(
				const spacing=space_width>0?.5:0;
				abs(space_width)?(calc_spacing()=int(point_x)%2?1;):(calc_spacing()=1;);
			):(
				const spacing=1-(space_width/(total_width-1));
				calc_spacing()=abs(1-fmod(point_x,total_width)/total_width-.5)*2<=spacing;
			);

			rot_x(a,b)=a*cos_ang-b*sin_ang;
			rot_y(a,b)=a*sin_ang+b*cos_ang;
			fmod(a,b)=a-b*floor(a/b);
			fmod_cont(a,b)=floor(a/b)%2?b-fmod(a,b):fmod(a,b);
			fcut(a,b)=(cut(a,-b,b)+b)/2;

			const number_of_bars=ceil(eucl_norm(ww,hh)/total_width);
			const shift_bars=int(number_of_bars/2);

			symmetry_mode==1?(calc_bar()=(-1*abs(floor(point_x/total_width))+shift_bars)%number_of_bars;):
			symmetry_mode==2?(calc_bar()=(abs(floor(point_x/total_width))+shift_bars)%number_of_bars;):
			                 (calc_bar()=(floor(point_x/total_width)+shift_bars)%number_of_bars;);

			v_mult=expr('u($9,$10)',number_of_bars,1,1,1);
			$8!=0?v_shift=expr('u(-$8,$8)',number_of_bars,1,1,1):v_shift=vectornumber_of_bars(0);

			v_use_invert=expr('round(u(0,1))',number_of_bars,1,1,1);
			inversion_mode==1?(v_use_invert=vectornumber_of_bars(0);):(
			inversion_mode==2?(v_use_invert=vectornumber_of_bars(1);););

			const use_only_one_mode=$11>=0;

			use_only_one_mode?(
				const modulo_out=$11%3;
				v_modulo_mode=vectornumber_of_bars(modulo_out);
			):(
				narg($12)?(
					const modulo_out=$12%3;
					modulo_out==0?(v_modulo_mode=expr('round(u(0,1))',number_of_bars,1,1,1);):
					modulo_out==1?(v_modulo_mode=expr('round(u(0,1))*2',number_of_bars,1,1,1);):
					              (v_modulo_mode=expr('round(u(0,1))+1',number_of_bars,1,1,1););
				):(
					v_modulo_mode=expr('round(u(0,2))',number_of_bars,1,1,1);
				);
			);

			rgb2hsv(a)=(
				R=a[0];
				G=a[1];
				B=a[2];
				M = max(R,G,B);
				C = M - min(R,G,B);
				H = 60*(C==0?0:M==R?((G - B)/C)%6:M==G?(B - R)/C + 2:(R - G)/C + 4);
				S = M<=0?0:C/M;
				[H,S,M/255];
			);

			($14||$13==1)?(
				color_a=["$color_a"];
				color_b=["$color_b"];
				$13==3?(
					color_a=rgb2hsv(color_a);
					color_b=rgb2hsv(color_b);
				);
			);

			const bc=$13%4; #bc==bar color mode#
			const sc=$14%3; #sc==space color mode#

			bc==3?(
				v_hue=expr('u(0,360,1,0)',number_of_bars,1,1,1);
				sc==2?(
					calc_gradient()=spaces?[v_hue[bar],1,final_gradient,255]:[lerp(color_b,color_a,cut(gradient*2+.5,0,1)),255];
				):
				sc==1?(
					calc_gradient()=spaces?[v_hue[bar],1,final_gradient,255]:[gradient>=0?color_a:color_b,255];
				):(
					calc_gradient()=[v_hue[bar],1,final_gradient,255*spaces];
				);
			):
			bc==2?(
				v_rgb_r=expr('u(0,255)',number_of_bars,1,1,1);
				v_rgb_g=expr('u(0,255)',number_of_bars,1,1,1);
				v_rgb_b=expr('u(0,255)',number_of_bars,1,1,1);
				sc==2?(
					calc_gradient()=spaces?[final_gradient*v_rgb_r[bar],final_gradient*v_rgb_g[bar],final_gradient*v_rgb_b[bar],255]:[lerp(color_b,color_a,cut(gradient*2+.5,0,1)),255];
				):
				sc==1?(
					calc_gradient()=spaces?[final_gradient*v_rgb_r[bar],final_gradient*v_rgb_g[bar],final_gradient*v_rgb_b[bar],255]:[gradient>=0?color_a:color_b,255];
				):(
					calc_gradient()=[final_gradient*v_rgb_r[bar],final_gradient*v_rgb_g[bar],final_gradient*v_rgb_b[bar],255*spaces];
				);
			):
			bc==1?(
				sc==2?(
					calc_gradient()=spaces?[lerp(color_a,color_b,final_gradient),255]:[lerp(color_b,color_a,cut(gradient*2+.5,0,1)),255];
				):
				sc==1?(
					calc_gradient()=spaces?[lerp(color_a,color_b,final_gradient),255]:[gradient>=0?color_a:color_b,255];
				):(
					calc_gradient()=[lerp(color_a,color_b,final_gradient),255*spaces];
				);
			):(
				sc==2?(
					calc_gradient()=spaces?[final_gradient,255]:[cut(gradient*2+.5,0,1),255];
				):
				sc==1?(
					calc_gradient()=spaces?[final_gradient,255]:[gradient>=0,255]
				):(
					calc_gradient()=[final_gradient,255*spaces];
				);
			);
		);

		initial_x=(x-ox)/ww*sx;
		initial_y=(y-oy)/hh*sy;
		gradient=-rot_y(initial_x,initial_y)*hh_div_sy/diag_img;
		point_x=rot_x(initial_x,initial_y)*ww_div_sx+gradient*mdist+half_total_width;
		bar=calc_bar();
		spaces=calc_spacing();
		new_gradient=gradient*v_mult[bar]+v_shift[bar];
		use_modulo_out=v_modulo_mode[bar];
		use_modulo_out==2?(final_gradient=v_use_invert[bar]?1-fmod_cont(new_gradient,1):fmod_cont(new_gradient,1);):
		use_modulo_out==1?(final_gradient=v_use_invert[bar]?1-fmod(new_gradient,1):fmod(new_gradient,1);):
		                  (final_gradient=v_use_invert[bar]?1-fcut(new_gradient,1):fcut(new_gradient,1););
		calc_gradient();"

		rm..
		if $13==3 hsv2rgb. fi
		if $sub!=1 r. $ow,$oh,100%,100%,5 fi
}
#@cli rep_shear: combined_axis={ 0,xy | 1,xz | 2,xc | 3,yx | 4,yz | 5,yc | 6,zx | 7,zy | 8,zc | 9,cx | 10,cy | 11,cz },angle,centre,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest | 1=linear | 2=bicubic },_output_mode={ 0=cropped | 1=full }
#@cli : Shear Image Based on angle.
#@cli : Default values: '_boundary=2','_interpolation=2','_output_mode=0'
rep_shear:
skip ${4=2},${5=2},${6=0}

check inrange($2,-90,90,0,0)&&isfinite($3)&&isint($4,0,3)&&isint($5,0,2)&&isbool($6)
if !$2 return fi

x,y,z,c,centre=0,1,2,3,{ispercentage($3)?$3:($3+1)/2}

check inrange($centre,0,1,1,1)

if isnum($1)
	check isint($1,0,11)
	loc=${arg0\ $1,xy,xz,xc,yx,yz,yc,zx,zy,zc,cx,cy,cz}
else
	loc={'xyzc'}
	check v='$1';size(v)==2?(isin(v[0],$loc)&&isin(v[1],$loc)&&v[0]!=v[1]);
	loc=$1
fi

d,l={`v='$loc';[v[0],_',',v[1]]`} # distance/distancia & line/linea

t_length,t_mult=${arg0\ ${$l},w,h,d,s},{tan($2Â°)}
ref_length,shift_scale=$t_length-1,$t_mult*half_ref_length
c_interpolation_mode={${$d}==3}

# Workaround as G'MIC JIT compiler doesn't support interpolation within non-spatial dimension c
if $c_interpolation_mode&&$5
	p_arg,s_arg=${arg0\ ${$l},xczy,cyzx,xycz},${arg0\ ${$l},yx,xy,zc}
	permute $p_arg
	rep_shear $s_arg,${2-6}
	permute $p_arg
	return
fi

contain_c={same(_'$d',_'c')||same(_'$l',_'c')}

c0,c1,c2,c3=0
d0,d1,d2,d3=w,h,d,s

if $6
	ins_l=#-1,
	t_dim=${arg0\ ${$d},w,h,d,s}
	df=ceil($t_dim+(abs($t_mult)*$t_length))
	c${$d}=($l-half_ref_length)/half_ref_length*shift_scale-offset
else
	c${$d}=($l-centre)/half_ref_length*shift_scale
fi

if $contain_c
	skew_expr=j($ins_l$c0,$c1,$c2,$c3,$5,$4)
else
	skew_expr=J($ins_l$c0,$c1,$c2,$5,$4)
fi

if $6
	foreach {
		dist={$df}
		d${$d}=$dist
		offset={($dist-$t_dim)/2}

		if prod($d0,$d1,$d2,$d3)/$_cpus>0x400000 error exc_dim_lim fi

		{[$d0,$d1,$d2,$d3]},"begin(
				const ref_length=max(1,"$ref_length");
				const half_ref_length=ref_length/2;
				const offset=$offset;
				const shift_scale="$shift_scale";
			);
			"$skew_expr";
			"

		rm..
	}
else
	fill "begin(
			const ref_length="$ref_length";
			const half_ref_length=ref_length/2;
			const centre=ref_length*$centre;
			const shift_scale="$shift_scale";
		);
		"$skew_expr";"
fi
#@cli rep_hpd: eq. to 'rep_henon_phase_diagram'
rep_hpd:rep_henon_phase_diagram $*
#@cli rep_henon_phase_diagram: a,_scale>0,-180>=_rotation>=180,_posx,_posy,_lines>0,1<_pts_per_line<=500,_start_x0,_end_x0,_steps_x0,_multiple_map
#@cli : Creates Henon Phase Diagram on existing image. Multiple Map option is used to make it easier to create more interesting image via coding.
#@cli :
#@cli : (eq. to 'rep_hpd')\n
#@cli : TODO: Add more description here.
rep_henon_phase_diagram:
skip ${2=1},${3=0},${4=50%},${5=50%}${6=600},${7=1750},${8=-.5},${9=.5},${10=8},${11=0}

if $2==0 error "$"2!=0==F fi

output_mode={$11%4}

if $1!=0

	if s#-1!=1&&d#-1!=1 100%,100%,1,1,-1
	else
		if !iv#-1&&iM#-1!=-1 f. -1 fi
	fi

	if ($3-360*floor($3/360))?1
		out_xi=rot_x(xi,yi)
		out_yi=rot_y(xi,yi)
	else
		out_xi=xi
		out_yi=yi
	fi

	steps={round((max(1,abs($10))-1))}
	lines={max(1,round(abs($6)))}

	if $output_mode==3 calc_out=i(#-1,cx,cy)=1
	else calc_out=cv=i(#-1,cx,cy);i(#-1,cx,cy)=max(cv,y)
	fi

	$steps,$lines,1,1,":begin_t(
			const a=$1;
			const c=cos(a);
			const s=sin(a);
			const pts=max(1,round(abs($7)));
			const ex=w#-1-1;
			const ey=h#-1-1;
			const posx=ex*$4;
			const posy=ey*$5;
			const hex=ex/2;
			const hey=ey/2;
			const dist=min(hex,hey)*abs($2);
			const tau=2*pi;
			const start_x0=$8;
			const end_x0=$9;
			const ang=($3/180)*pi*-1;
			const cos_ang=cos(ang);
			const sin_ang=sin(ang);
			if(abs($10)
			,const end_step=w-1;
			,const end_step=1;
			);
			rot_x(a,b)=a*cos_ang-b*sin_ang;
			rot_y(a,b)=a*sin_ang+b*cos_ang;
		);
		t=lerp(start_x0,end_x0,x/end_step);
		xi=t;
		yi=y/h*tau;
		repeat(pts,
			m=xi;
			n=yi-sqr(xi);
			xn=xi*c-n*s;
			yn=xi*s+n*c;
			if(isinf(xn)||isinf(yn),break(););
			xi=xn;yi=yn;
			if(m!=t,
				cx=round(posx+"$out_xi"/2*dist);
				cy=round(posy-"$out_yi"/2*dist);
				"$calc_out";
			);
		);
		"

	rm.

	if $output_mode==2
		+eq. -1
		+negate.
	elif $output_mode==1
		+gt. -1
	fi

else

	f. 0

fi
#@cli rep_dynamic_contrast: -64<=amount<=64,0<=_threshold<=255,0<=_intensity<=255
#@cli : Apply dynamic contrast using formula found by Remake at forums.getpaint.net. Original source code - https://forums.getpaint.net/topic/117538-dynamic-contrast/?tab=comments#comment-578867 . It is similar to Photoshop's Dynamic Contrast.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_threshold=128','_intensity=255'
rep_dynamic_contrast:
skip ${2=128},${3=255}

repeat $! {

		sh[$>] {s#$>>=3?[0,2]:0}

		if s>=3 calcval=v=I;lum=0.296875*v[0]+0.5859375*v[1]+0.11328125*v[2];(I-sqrt(abs(threshold-lum))*(lum>threshold?na:a))*fi+I*ifi;
		else calcval=(i-sqrt(abs(threshold-i))*(i>threshold?na:a))*fi+i*ifi
		fi

		f. "begin(
				const a=$1;
				const threshold=$2;
				const intensity=$3;
				const na=1-a;
				const fi=intensity/255;
				const ifi=1-fi;
			);
			"$calcval"
			"

		cut. 0,255
		rm.

}
#@cli rep_cstdmap: eq. to 'rep_chirikov_taylor'
rep_cstdmap:rep_chirikov_taylor $*
#@cli rep_chirikov_taylor: size!=0,_lines>0,_pts_per_line>0,_k,_chirikov_mode={ 0=standard | 1=chirikov_karimov },_offmode={ 0=default | 1=center },_orientation={ 0=xy | 1=yx },_use_parallel={ 0=serial | 1=parallel }
#@cli : Creates Chirikov discrete map. Chirikov map can be the standard version which is created by Boris Chirikov or modification done by Artur I. Karimov.\n
#@cli : (eq. to 'rep_cstdmap')\n
#@cli : 'size' can be either in percent or integer. It can be negative or positive. Percentage mode is always based on the size of image. Positive values will lead to square value regardless of initial image. Negative value will create a new image based on whether the width or height is smaller, and scale based on the ratio of max dim vs min dim.
#@cli : '_lines' defines the number of lines created within image. It defaults to 1 if the user inputs a value in which the absolute of value is less than 1.
#@cli : '_pts_per_line' defines how much points is generated per lines.
#@cli : '_k' can be considered distortion factor. It can be negative.
#@cli : '_chirikov_mode' defines whether to apply a symmetric modification to the original version of chirikov standard map. The symmetric modification is based on the paper 'The Study of the Modified Chirikov Map' by Artur I.Karimov, Denis N. Butusov,Vyacheslav G. Rybin, Timur I.Karimov within Department of Computer Aided Design at Saint Petersburg Electrotechnical University.
#@cli : '_offmode' defines whether the main rotor will be centered.
#@cli : '_orientation' defines whether to switch axis for generation of chirikov map.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_lines=500','_pts_per_line=5000','_k=1','_chirikov_mode=0','_offmode=0','_orientation=0','_use_parallel=1'
rep_chirikov_taylor:
skip ${2=500},${3=5000},${4=1},${5=0},${6=0},${7=0},${8=1}

if ispercentage($1)
	if $!
		if $1>0
			mw=${-max_w}
			mh=${-max_h}
			md={max($mw,$mh)}
			chirikov_w,chirikov_h={$md*$1}
		else
			mw=${-max_w}
			mh=${-max_h}
			sd={max($mw,$mh)/min($mw,$mh)}
			if $mh>$mw
				chirikov_w={$mw*abs($1)}
				chirikov_h={$sd*$chirikov_w}
			else
				chirikov_h={$mh*abs($1)}
				chirikov_w={$sd*$chirikov_h}
			fi
		fi
	else error \$\!>0==F
	fi
else
	if $1>0
		chirikov_w,chirikov_h=$1
	elif $1<0
		if $!
			mw=${-max_w}
			mh=${-max_h}
			sd={max($mw,$mh)/min($mw,$mh)}
			if $mh>$mw
				chirikov_w={abs($1)}
				chirikov_h={$sd*$chirikov_w}
			else
				chirikov_h={abs($1)}
				chirikov_w={$sd*$chirikov_h}
			fi
		else error \$\!>0==F
		fi
	else error \$\1!=0==F
	fi
fi

if $5
	chirikov_mode=txi=fmod(xi+.5*yi);yi=fmod(yi-k*sin(txi));xi=fmod(txi+.5*yi)
else
	chirikov_mode=yi=fmod(yi+k*sin(xi));xi=fmod(xi+yi)
fi

if $7
	coordinates=[round(yi/tau*width),round(xi/tau*height)]
else
	coordinates=[round(xi/tau*width),round(yi/tau*height)]
fi

lines={min(100*$chirikov_h,abs($2))+1}

$chirikov_w,$chirikov_h,1,1

$lines,1,1,1,"begin(const ww=w-1;const tau=2*pi;);x/w*tau;"

if $8 start_char=:
else start_char=>
fi

f. $start_char"
	begin(
		const width=w#-2;
		const height=h#-2;
		const pts=max(1,abs(round($3)));
		const k=$4;
		const tau=2*pi;
		fmod(a)=a-tau*floor(a/tau);
		xi=0;
	);
	yi=i;
	px=x+1;
	repeat(pts,
		"$chirikov_mode";
		coordinates="$coordinates";
		cv=i(#-2,coordinates[0],coordinates[1]);
		i(#-2,coordinates[0],coordinates[1])=max(cv,px);
	);"

rm.

if $6
	if $7
		if $5 +s. y,2 rv[-2,-1] a[-2,-1] y a[-2,-1] x
		else s. x,2 rv[-2,-1] a[-2,-1] x
		fi
	else
		if $5 +s. x,2 rv[-2,-1] a[-2,-1] x a[-2,-1] y
		else s. y,2 rv[-2,-1] a[-2,-1] y
		fi
	fi
fi
#@cli rep_rd : eq. to 'rep_reverse_digits'
rep_rd: rep_reverse_digits ${1-3}
#@cli rep_reverse_digits: base>1,number_bounary_mode={ 0=regular | 1=periodic | 2=mirror },max_number_boundary>0
#@cli : Reverse digits of image.
#@cli : (eq. to 'rep_rd')
#@cli : Default values: 'base=10','number_boundary_mode=0','max_number_boundary=255'
rep_reverse_digits:
skip ${1=10},${2=0},${3=255}
check "($1>1)&&(isint($3)&&$3>0)"

num_of_imgs={$!}

# 1. Check if image contain negative values, if so, shift negative values by -1

$num_of_imgs,1,1,2,min_val=im#x;[min_val,min_val<0?x:-1]; s. c
abs_min_img_val={min_img_val=im#-2;min_img_val<0?abs(min_img_val)}

if $abs_min_img_val

	discard[-1] -1

	neg_img_list_pos,inc_neg_img_list_pos,number_of_negatives={neg_img_pos=$!-1;[neg_img_pos,neg_img_pos+1,h#-1]}
	neg_img_list={crop(#-1)}

	+lt[$neg_img_list] 0
	+store[$inc_neg_img_list_pos--1] negative_images

	repeat $number_of_negatives {
		img_pos={i(#$neg_img_list_pos,0,$>)}

		-[$img_pos] [$inc_neg_img_list_pos]
		remove[$inc_neg_img_list_pos]
	}

	store[-1] neg_img_list
else
	remove[-1]
fi

# 2. Create image to find the minimum and maximum values

$num_of_imgs,1,1,2,"begin(
		const abs_min_img_val=$abs_min_img_val;
	);

	min_img_val=i(#-1);
	max_img_val=iM#x;

	if(abs(min_img_val)>max_img_val
	,[0,abs_min_img_val]
	,[max(0,min_img_val),max_img_val]
	);"

diff={ceil(iM-im+1)}

rm[-2]

# 3. Create reverse digit image map
$diff,1,1,1,"begin(

		const min_val=int(im#-1);
		const base=$1;
		const number_boundary_choice=int($2)%3;

		number_boundary_choice?(

			const boundary_number=$3;

			number_boundary_choice==2?(

				const m2_boundary_number=boundary_number<<1;

				output(v)=(
					va=v%m2_boundary_number;
					boundary_number-abs(boundary_number-va);
				);

			):(
				output(v)=v%boundary_number;
			);

		):(
			output(v)=v;
		);

	);
	rv=0;
	n=x+min_val;
	while(n,
		rv*=base;
		rv+=n%base;
		n=int(n/base);
	);
	output(int(rv));
	"

# 4. Map reverse digit image map onto target images

-[^-2,-1] {im#-2}
remove[-2]

map[^-1] [-1],3
remove[-1]

# 5. If the input contains negative values, simply convert some pixels back to negatives

if $abs_min_img_val

	$neg_img_list
	neg_img_list_pos,inc_neg_img_list_pos={[$neg_img_list_pos,$inc_neg_img_list_pos]-1}

	$negative_images

	(1,-1)

	map[$inc_neg_img_list_pos--2] [-1]
	rm[-1]

	repeat $number_of_negatives {
		img_pos={i(#$neg_img_list_pos,0,$>)}

		*[$img_pos] [$inc_neg_img_list_pos]
		remove[$inc_neg_img_list_pos]
	}

	remove[-1]
fi
#@cli rep_tz: eq. to 'rep_tiled_zoom'
rep_tz:rep_tiled_zoom $*
#@cli rep_tiled_zoom: sqr_w>=0,_sqr_h>=0,_scale>=1,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror }
#@cli : Zoom per tiles using information that exists.\n
#@cli : (eq. to 'rep_tz')\n
#@cli : Author: Reptorian\n
#@cli : Default values: '_sqr_h=sqr_w','_scale=2','_boundary=3'
rep_tiled_zoom:
skip ${2=$1},${3=2},${4=3}

sqr_w={max(round(abs($1)),1)}
sqr_h={max(round(abs($2)),1)}
sd={max(1,abs($3))}

if $sd!=1
	foreach {
		columns={ceil(w/$sqr_w)}
		rows={ceil(h/$sqr_h)}
		offx={($sqr_w*$columns)-w}
		offy={($sqr_h*$rows)-h}
		offx/=2
		offy/=2
		offx=int($offx)
		offy=int($offy)

		f "begin(
			px=expr('begin(const cen=(w-1)/2;);cv=x-cen;nv=cv*$sd;nv-cv;',$sqr_w);
			py=expr('begin(const cen=(w-1)/2;);cv=x-cen;nv=cv*$sd;nv-cv;',$sqr_h);
			const boundary=abs($4)%4;
		);
		coords=[px[(x+$offx)%$sqr_w],py[(y+$offy)%$sqr_h]];
		J(coords[0],coords[1],0,2,boundary);"

	}
fi
#@cli rep_hsx_p_i: eq. to 'rep_hsx_poster_index'
rep_hsx_p_i:rep_hsx_poster_index $*
#@cli rep_hsx_poster_index: if $4<0 <=hue_bands<=360,saturation_bands,luminosity_bands,n/a,_colorspace={ 0=hsi | 1=hsl | 2=hsv | 3=hcy } : else 0<=hue_bands<=360,saturation_bands,luminosity_bands,0<=_dithering<=1,0<=start_hue<360,_colorspace={ 0=hsi | 1=hsl | 2=hsv | 3=hcy }
#@cli : Posterize images using indexing and several variants of hsx models.\n
#@cli : (eq. to 'rep_hsx_p_i')\n
#@cli : Author: Reptorian\n
#@cli : Default values: '_dithering=50%','start_hue=0','_colorspace=3'
rep_hsx_poster_index:
skip ${4=50%},${5=0},${6=2}

check "last_args=[${2-3}];inrange($1,2,360,1,1)&&!isin(0,(isint(last_args)&last_args>1))"

hue_scale,\
sat_scale,\
lum_scale,\
dithering,\
start_hue,\
cs_mode\
={[360/$1,[${2-3}]-1,cut($4,0,1),$5%360,int($6)%4]}

convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$cs_mode,hsi,hsl,hsv,hcy}

if $4

	# Floyd-Steinberg Dithering Array

	fs_1R0D,\
	fs_1L1D,fs_M01D,fs_1R1D\
	={([7,3,5,1]/16)*$dithering}

	foreach {
		if !(s==3||s==4) continue fi

		$convert_colors_fwd

		if $start_hue
			shared. 0
			-. $start_hue
			%. 360
			rm.
		fi

		if s==4 shared 0,2 fi

		fill. >"begin(

				const width=w;
				const height=h;

				const hue_scale=$hue_scale;
				const sat_scale=$sat_scale;
				const lum_scale=$lum_scale;

				const fs_1R0D=$fs_1R0D;
				const fs_1L1D=$fs_1L1D;
				const fs_M01D=$fs_M01D;
				const fs_1R1D=$fs_1R1D;

			);

			old_color=I;

			new_hue=round(old_color[0]/hue_scale)*hue_scale;
			new_sat=round((old_color[1]*sat_scale))/sat_scale;
			new_lum=round((old_color[2]*lum_scale))/lum_scale;

			new_color=[new_hue,new_sat,new_lum];

			diff_color=old_color-new_color;

			J(#-1, 1,0)+=diff_color*fs_1R0D;

			J(#-1,-1,1)+=diff_color*fs_1L1D;
			J(#-1, 0,1)+=diff_color*fs_M01D;
			J(#-1, 1,1)+=diff_color*fs_1R1D;

			new_color;
			"

		keep[0]

		if $start_hue
			shared 0
			+. $start_hue
			%. 360
			rm.
		fi

		$convert_colors_bwd
	}

else # No dithering

	360,1,1,1,x

	if $1!=360
		/. $hue_scale
		round.
		*. $hue_scale
	fi

	store. hue_bands

	foreach {

		if !(s==3||s==4) continue fi

		$convert_colors_fwd

		repeat 3 {

			if $>
				scale_val=${arg1\ $>,$sat_scale,$lum_scale}

				shared $>
				*. $scale_val
				round.
				/. $scale_val

				rm.
			else
				shared 0
				$hue_bands

				if $start_hue
					-.. $start_hue
					%.. 360
				fi

				map.. .

				if $start_hue
					+.. $start_hue
					%.. 360
				fi

				rm[-2,-1]
			fi

		}

		$convert_colors_bwd

	}

fi
#@cli rep_mj_prn : eq. to 'rep_mj_pseudorandom_noise'
rep_mj_prn:rep_mj_pseudorandom_noise $*
#@cli rep_mj_pseudorandom_noise : _k1,_k2,_internal_shift,_ang,_px_size,_cx,_cy,_color_output,_kmode,_grid,_gridcol,_axis_thickness
#@cli : Render regular noise. Filter is a extended version of MadJik's Regular Noise PDN plugin and based off MadJik's code. The G'MIC version has been extended.\n
#@cli : (eq. to 'rep_mj_prn').\n
#@cli : '_k1' defines value for k-1
#@cli : '_k2' defines value for k-2
#@cli : '_internal_shift' shift rows based on this value. The more, the more distortion there will be.
#@cli : '_ang' defines the color/shade angle.
#@cli : '_px_size' defines how big the pixels are.
#@cli : '_cx' refers to the x-position of center based on world coordinate of -1,1
#@cli : '_cy' refers to the y-position of center based on world coordinate of -1,1
#@cli : '_color_output' is the function used to color the output.
#@cli : '_kmode' defines how the noise will be processed.
#@cli : '_grid' option is used to whether to output a grid.
#@cli : '_gridcol' defines the value of grid. Only gray color is supported.
#@cli : '_axis_thickness' defines whether the axis has 2 pixel instead of 1.\n
#@cli : Default values: '_k1=8','_k2=2','_internal_shift=1','_ang=0','_px_size=1','_cx=0','_cy=0','_coloroutput=1','_grid=0','_gridcol=0','_axis_thickness=0'\n
#@cli : Author: Reptorian.
#@cli : $ 512,512 rep_mj_pseudorandom_noise 8,2,1,95,4,0,0,1,0,,,0
#@cli : $ 1024,1024 rep_mj_pseudorandom_noise 34,2,30,95,4,0,0,2
rep_mj_pseudorandom_noise:
skip ${1=8},${2=2},${3=1},${4=0},${5=1},${6=0},${7=0},${8=1},${9=0},${10=0},${11=0},${12=0}

r 100%,100%,1,{$8?3:1}

3000,100,1,1,round((1-(x*(x^2*15731+789221)+1376312589&2147483647)/1073741824)*100000)/100000;

if $8%4==2

	outmode=i(#-1,num+($4/180*3000),0,0,0,0,2)
	formulachoice=DoubleToColorRGB(noise_gen)

else

	outmode=i(#-1,num%3000,0,0,0,0,2)

	if $8%4==3 formulachoice=DoubleToColorTan(noise_gen)%256
	elif $8%4==1 formulachoice=formulachoice=DoubleToColorSin(noise_gen)
	else formulachoice=(((ang/pi*256)+noise_gen)/3000*256)%256
	fi

fi

if $10

	tempval={abs($5)+1}

	if $8 gridcol=[$11,$11,$11]
	else gridcol=$11
	fi

	temp_formulachoice=((x%$tempval)&&(y%$tempval))?
	temp_formulachoice.=$formulachoice:$gridcol
	formulachoice=$temp_formulachoice

fi

f[0--2] "
		begin(
			const ww=w/2;
			const halfh=h/2;
			const zoom=1/round(abs(abs($5)+($10?1:0)));
			if($9
			,const k_one=$1/2;
			,const k_one=$1/10;
			);
			if($9
			,const k_two=$2/4;
			,const k_two=($2*-1)/10;
			);
			noise2d(nx,ny)=(
				a=int(nx);b=int(ny);
				num=abs(a+b*$3)%3000;
				"$outmode";
			);
			const ang=$4/180*pi;
			smoothnoise(nx,ny)=(
				a=int(nx);b=int(ny);
				num=(noise2d(a-1,b-1)*4)/$1;
				num2=(noise2d(a-1,b)*4)/k_one;
				num3=noise2d(a,b)/k_two;
				num4=num+num2+num3;
				num4*256;
			);
			DoubleToColorSin(v)=(
				num=ceil((v*1/pi*10^3))/10^3;
				num2=int(128+127*sin(num+ang));
				num3=int(128+127*sin(pi/2+num+ang));
				num4=int(128+127*sin(pi+num+ang));
				[num4,num3,num2];
			);
			DoubleToColorRGB(t)=(
				num=int(t*65536.0);
				num2=(num&16711680)>>16;
				num3=(num&65280)>>8;
				num4=num&255;
				[num4,num3,num2];
			);
			DoubleToColorTan(w)=(
				num=ceil((w*1/pi)*10^3)/10^3;
				num2=int(128+127*tan(num+ang));
				num3=int(128+127*tan(num+pi/2+ang));
				num4=int(128+127*tan(num+pi+ang));
				[num4,num3,num2];
			);
		);
		xx=abs(int(zoom*(x+0.5)));
		yy=abs(int(zoom*(y+0.5)));
		noise_gen=smoothnoise(xx,yy);
		"$formulachoice";"

if $12&&(($6!=-1)||($7!=-1))

	if $10

		f[0--2] "begin(
				const sfx=int(($6*.5+.5)*w)+($10?1:0);
				const sfy=int(($7*.5+.5)*h)+($10?1:0);
			);
			psfx=x-sfx;
			psfy=y-sfy;
			i(
				psfx>=0?x-sfx:x-sfx-1,
				psfy>=0?y-sfy:y-sfy-1,z,c,0,3
			);"

	else

		f[0--2] "begin(
				const sfx=($6*.5+.5)*w+($10?1:0);
				const sfy=($7*.5+.5)*h+($10?1:0);
			);
			i(x-sfx,y-sfy,z,c,0,3);"

	fi

elif $6!=-1||$7!=-1

	f[0--2] "begin(
		const gridfix=($10?1:0);
		const pxlsize=abs($5)+gridfix;
		const errfix=abs($5)==1?!(pxlsize%2):1-gridfix;
		const sw=int(w-pxlsize);
		const sfx=int(($6*.5+.5)*sw);
		const sh=int(h-pxlsize);
		const sfy=int(($7*.5+.5)*sh);
		const errfix2=abs($5)==1;
	);
	psfx=x-sfx;
	psfy=y-sfy;
	i(
	psfx>=0?psfx+errfix2:psfx*-1+pxlsize-errfix,
	psfy>=0?psfy+errfix2:psfy*-1+pxlsize-errfix,
	z,c,
	0,2
	);"

fi

rm.
#@cli rep_dla : eq. to 'rep_diffusion_limited_aggregation'
rep_dla: rep_diffusion_limited_aggregation $*
#@cli rep_diffusion_limited_aggregation: _attempts>1,_mode,0<=_spread_factor<=1,_stem_color={ 0=dark | 1=light },_border,_initial_point_mode={ 0=less_dense | 1=more_dense },_preserve_silhouette={ 0=maskless | 1=mask }
#@cli : Generate Diffusion Limited Aggregation
#@cli : (eq. to 'rep_dla').
#@cli :
#@cli : '_attempts' defines how much attempts on filling the aggregation form before finishing.
#@cli : '_mode' defines how particles aggregate on the aggregation form.
#@cli : '_spread_factor' defines how much times a particle will be created upon appending. The algorithm for this may not be the correct implementation, but it works for what it describes.
#@cli : '_stem_color' defines where the aggregation form will fill on.
#@cli : '_border' is only applicable if there is a planting seed map. It is used to limit particles based on proximity away from existing structure.
#@cli : '_initial_point_mode' defines whether to use less dense or more dense point coordinates map.
#@cli : '_preserve_silhouette' is only applicable on images with variance.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_attempts=100','_mode=0','_spread_factor=0','_stem_color=0','_border=0','_initial_point_mode=0','_preserve_silhouette=1'
rep_diffusion_limited_aggregation:
skip ${1=100},${2=0},${3=0},${4=0},${5=0},${6=0},${7=1}

maximum_iterations,pixel_detection_mode,spread_factor,stem_color,border_size,initial_coordinates_map_mode,preserve_silhouette_mode={[abs($1),int($2)%4,cut(abs($3),0,1),!$4,round(abs($5)),$6?1,$7?1]}
inv_stem_color,use_altern_text,n_threads={[!$stem_color,$pixel_detection_mode==3]},$_cpus

command "dla_target_1s: ge {avg(iM,im)}"

command "dla_target_2s:
	normalize 0,1
	split[-1] c *
	ge {avg(iM,im)}"

command "dla_target_3s:
	normalize 0,1
	split c
	add / 3
	ge {avg(iM,im)}"

command "dla_target_4s:
	normalize 0,1
	ts={s-1}
	split c
	add[^-1]
	/[-1] $ts *
	ge {avg(iM,im)}"

command "dla_target:
	if s==1   dla_target_1s
	elif s==2 dla_target_2s
	elif s==3 dla_target_3s
	else      dla_target_4s
    fi"

command "dla_check_variance:
	tv=0

	repeat s {
		shared $>
		tv+={iv#-1}
		rm.

		if $tv
			break
		fi
	}

	status {$tv?1:0}"

command "dla_clear_image:
	{w#0},{h#0},1,1,"$stem_color"
	rv[-1,0]
	rm."

if $use_altern_text
	altern_text_a=altern=v(0,2,1,0)
	altern_text_b=altern=++altern%2
fi

foreach {

	if s>4||d#0>1 continue fi

	+dla_create_coordinate_map $initial_coordinates_map_mode
	shuffle.

	use_dla_map=${dla_check_variance[0]}

	if $use_dla_map

		dla_target[0]

		if $border_size
			+distance.. $inv_stem_color,2
			1,{h#-2},1,1,v=i(#-1,I(#-2));v?(v<=$border_size?y:-1):-1
			discard. -1
			map. ...
			1,100%,1,1,i(#2,I(#-1))
			rm[-4,-3]
			pixelsort.. +,y,.
			rm.
			1,100%,1,1,:"begin_t(const n_threads=$n_threads;n=t;);v=n;n+=n_threads;v;"
			map. ..
			rm..

			if !$preserve_silhouette_mode
				if $stem_color
					replace[0] 0,.999
				else
					*[0] .001
				fi
			fi

		else
			if $stem_color val_check=>.999
			else 	val_check=<.001
			fi

			1,{h},1,1,y
			eval.. :if(!(i(#0,I)$val_check),i(#-1,0,y)=-1;);I;
			discard. -1
			map. ..
			rm..

			+distance[-2] $inv_stem_color,2
			1,{h#-2},1,1,i(#-1,I(#-2))
			rm[-2]
			pixelsort[-2] +,y,[-1]
			rm[-1]
			1,100%,1,1,:"begin_t(const n_threads=$n_threads;n=t;);v=n;n+=n_threads;v;"
			map. ..
			rm..

			if !$preserve_silhouette_mode
				if $stem_color
					replace[0] 0,.999
				else
					*[0] .001
				fi
			fi

		fi

	else

		center_x,center_y={[(w#0-1)>>1,(h#0-1)>>1]}
		minimum_circle_radius={norm($center_x,$center_y)}

		1,{h},1,2,"begin(
				const sqrt_of_two=sqrt(2);
				const minimum_circle_radius=$minimum_circle_radius;
				const center_x=$center_x;
				const center_y=$center_y;
			);
			distance_from_center=norm(I#-1-[$center_x,$center_y]);
			distance_from_center<=minimum_circle_radius?(
				relative_position=distance_from_center/minimum_circle_radius;
				valid_point=lerp(1,u^.625,relative_position)>=relative_position?y:-1;
			):(
				valid_point=-1;
			);
			[distance_from_center,valid_point];
			"

		split[-1] c
		discard[-1] -1
		[-1]
		repeat 2 { map[{$>-2}] [{$>-4}] }
		remove[-4,-3]
		pixelsort[-2] +,y,[-1]
		remove[-1]
		1,100%,1,1,:"begin_t(const n_threads=$n_threads;n=t;);v=n;n+=n_threads;v;"
		map[-1] [-2]
		remove[-2]

		dla_clear_image
		set[0] $inv_stem_color,50%,50%
	fi

	a[^0] y

	eval[1] :"begin_t(
			const width=w#0;
			const height=h#0;

			const spread_factor=$spread_factor;
			const use_spread=spread_factor?1;

			const limit_of_attempts=$maximum_iterations;
			const pixel_detection_mode=$pixel_detection_mode;
			const target_mode=$inv_stem_color;

			new_pos_x=[-1, 0, 1,
			           -1,    1,
			           -1, 0, 1];
			new_pos_y=[-1,-1,-1,
			            0,    0,
			            1, 1, 1];

			if(!target_mode
			,det_px(pixel)=pixel<1;
			,det_px(pixel)=pixel;
			);

			pixel_detection_mode==3?(
				pixel_detected(xp,yp)=
					altern?(
						det_px(i(#0,xp-1,yp-1,0,0,0,2))||
						det_px(i(#0,xp-1,yp+1,0,0,0,2))||
						det_px(i(#0,xp+1,yp-1,0,0,0,2))||
						det_px(i(#0,xp+1,yp+1,0,0,0,2))
					):(
						det_px(i(#0,xp-1,yp,0,0,0,2))||
						det_px(i(#0,xp+1,yp,0,0,0,2))||
						det_px(i(#0,xp,yp-1,0,0,0,2))||
						det_px(i(#0,xp,yp+1,0,0,0,2))
					);
				):
			pixel_detection_mode==2?(
				pixel_detected(xp,yp)=
					det_px(i(#0,xp-1,yp-1,0,0,0,2))||
					det_px(i(#0,xp-1,yp+1,0,0,0,2))||
					det_px(i(#0,xp+1,yp-1,0,0,0,2))||
					det_px(i(#0,xp+1,yp+1,0,0,0,2))||
					det_px(i(#0,xp-1,yp,0,0,0,2))||
					det_px(i(#0,xp+1,yp,0,0,0,2))||
					det_px(i(#0,xp,yp-1,0,0,0,2))||
					det_px(i(#0,xp,yp+1,0,0,0,2));
			):
			pixel_detection_mode==1?(
				pixel_detected(xp,yp)=
					det_px(i(#0,xp-1,yp,0,0,0,2))||
					det_px(i(#0,xp+1,yp,0,0,0,2))||
					det_px(i(#0,xp,yp-1,0,0,0,2))||
					det_px(i(#0,xp,yp+1,0,0,0,2));
			):(
				pixel_detected(xp,yp)=
					det_px(i(#0,xp-1,yp-1,0,0,0,2))||
					det_px(i(#0,xp-1,yp+1,0,0,0,2))||
					det_px(i(#0,xp+1,yp-1,0,0,0,2))||
					det_px(i(#0,xp+1,yp+1,0,0,0,2));
			);

			"$altern_text_a"
		);

		temp_vec=I;

		xp=temp_vec[0];
		yp=temp_vec[1];

		repeat(limit_of_attempts,
			pv=v(0,8,1,0);

			xp+=new_pos_x[pv];
			yp+=new_pos_y[pv];

			if(pixel_detected(xp,yp),
				i(#0,xp%width,yp%height)=target_mode;

				if(use_spread,

					txp=xp;
					typ=yp;

					if(u<spread_factor,
						tpv=v(0,8,1,0);

						txp+=new_pos_x[tpv];
						typ+=new_pos_y[tpv];
						count=0;

						repeat(limit_of_attempts,

							if(pixel_detected(txp,typ),
								if(u<spread_factor,
									i(#0,txp%width,typ%height)=target_mode;
								);
								++count;
								if(count==7,break(););
							);

							tpv=v(0,8,1,0);

							txp+=new_pos_x[tpv]*2;
							typ+=new_pos_y[tpv]*2;
						);

					);

				);

				break();
			);

			"$altern_text_b"
		);

		I;
		"

	k[0]

	if $use_dla_map&&!$preserve_silhouette_mode round fi

}

uncommand dla_target,dla_target_1s,dla_target_2s,dla_target_3s,dla_target_4s,dla_check_variance,dla_clear_image
+dla_create_coordinate_map:
if $1
	row_a={ceil(h/2)}
	row_b={h-$row_a}
	counts_per_row_a,counts_per_row_b={[w,w+1]>>1}

	1,{$row_a*$counts_per_row_a+$row_b*$counts_per_row_b},1,2,:"begin(
			const row_length=w#-1;
			const half_row_length=row_length>>1;
		);
		pos_y=int(y/half_row_length);
		ny=y<<1;
		pos_x=pos_y&1?(ny%row_length):((ny+1)%row_length);
		[pos_x,pos_y];"
else
	1,{(w>>1)*(ceil(h/2))},1,2,:"begin(
			const row_length=w#-1;
			const half_row_length=row_length>>1;
		);
		y_pos=int(y/half_row_length)<<1;
		[(y<<1)%row_length,y_pos];"
fi
#@cli rep_blur_splinter: _length,_duplicates,_angle,_thickness,-1<=_balance<=1,_contrast,_boundary={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_bisided={ 0=one-line | two-line }
#@cli : Apply Splinter Blur to Image. Based off observation from using Splinter Blur plugin within Paint.NET made by Ed Harvey, and it is inspired by this filter. Note that convolution result is different.
#@cli : Default values: '_length=10%','_duplicates=5','_angle=0','_thickness=0','_balance=0','_contrastr=0','_boundary=1','_bisided=0'
rep_blur_splinter:
skip ${1=10%},${2=5},${3=0},${4=0},${5=0},${6=0},${7=2},${8=0}

if $2<3 error \$\2>2==F fi

start_ang={$3}
angs_per_dups={360/$2}

command "average_output: ti=$! add / $ti"

if $5==-1 command "output_splinter : min"
elif $5<0&&$5>-1 command "output_splinter : +average_output +min[^-1] f. lerp(i#-2,i,abs($5)) k."
elif $5==0 command "output_splinter : average_output"
elif $5>0&&$5<1 command "output_splinter : +average_output +max[^-1] f. lerp(i#-2,i,$5) k."
elif $5==1 command "output_splinter : max"
else error (-1<=\$\6<=1)=F
fi

foreach {

	half_img_diag={norm(w,h)/2}
	if ispercentage($1) length={round(abs($1)*$half_img_diag)}
	else length={round(abs($1))}
	fi

	if ispercentage($4) thickness={round(abs($4)*$half_img_diag)}
	else thickness={round(abs($4))}
	fi

	img_dims={w},{h}

	repeat $2 {
		ang={$start_ang+$angs_per_dups*$>}
		rep_splinter_blur_convolve_map[^0--1] $length,$thickness,$ang,$6,$8,$img_dims
		+convolve_fft[0] [-1],$7
		rm..
	}

	rm[0]

	output_splinter

}
uncommand output_splinter
#@cli rep_splinter_blur_convolve_map: _length,_thickness,_angle,_contrast,_bisided={ 0=one-line | two-line }
#@cli : Create a convolve map for directional blur. This enables one to create a convolve map for one-direction motion blur.
#@cli : Default values: '_length=10%','_thickness=5%','_angle=0','_bisided=1'
rep_splinter_blur_convolve_map : skip ${1=10%},${2=5%},${3=0},${4=0},${5=1},${6=w},${7=h}

ang={($3/180)*pi*-1}
cos_ang={cos($ang)};
sin_ang={sin($ang)};
diag={norm($6,$7)/2}
if ispercentage($1) length={round($1*$diag)} else length={round($1)} fi
if ispercentage($2) thickness={max(round($2*$diag),1)} else thickness={max(round($2),1)} fi

point_b_x=0
point_b_y={$length/2}
point_c_x={$thickness/2}
max_dim={max($point_b_y,$point_c_x)}
min_dim={min($point_b_y,$point_c_x)}
point_c_y={sqrt(sqr($max_dim)-sqr($min_dim))}
point_a_x=-$point_c_x
point_a_y=$point_c_y

n_pax={abs($point_a_x*$cos_ang+$point_a_y*$sin_ang)}
n_pay={abs($point_a_x*$sin_ang+$point_a_y*$cos_ang)}
n_pbx={abs($point_b_x*$cos_ang+$point_b_y*$sin_ang)}
n_pby={abs($point_b_x*$sin_ang+$point_b_y*$cos_ang)}
n_pcx={abs($point_c_x*$cos_ang+$point_c_y*$sin_ang)}
n_pcy={abs($point_c_x*$sin_ang+$point_c_y*$cos_ang)}

rect_width={ceil(max($n_pax,$n_pbx,$n_pcx)*2)}
rect_height={ceil(max($n_pay,$n_pby,$n_pcy)*2)}

{max(1,$rect_width)},{max(1,$rect_height)},1,1,"
	begin(
		const strokelength=$length;
		const sx=w/strokelength;
		const sy=h/strokelength;
		const sides=$5;
		const thickness=$thickness;
		const hw=(w-1)/2;
		const hh=(h-1)/2;
		const ang=($3/180)*pi*-1;
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		cutval(v)=v<0?0:v;
		maxcutval(v)=v>1?1:v;
	);
	xx=(x/w-.5)*sx;
	yy=(y/h-.5)*sy;
	lx=x-hw;
	ly=y-hh;
	radial_grad=1-norm(xx,yy)*2;
	radial_grad=cutval(radial_grad);
	line=1-maxcutval(abs(rot_x(lx,ly))/thickness);
	sides?(line?radial_grad*line):(rot_y(lx,ly)<=0?(line?radial_grad*line));
	"

/. {is}

if $4
	avgstat={ia}
	+*. 2 -. $avgstat
	f.. lerp(i,i#1,min(1,min(abs($4),1)))
	rm.
fi
#@cli rep_bgfill: eq. to 'rep_fill_background'
rep_bgfill: rep_fill_background $*
#@cli rep_fill_background: color,alpha,max_alp
#@cli : Fill image with values.\n
#@cli : (eq. to 'rep_bgfill')\n
#@cli : For RGBA images, 3 values are used in place of color. That means 5 values are to be inserted.
#@cli : For GA Image, only 1 value are used in place of color. That means 3 values are to be used.
rep_fill_background:
if $-2>0

	$!,1,1,1,s#x

	val_test={iv#-1}
	rm.

	if !$val_test

		foreach {
			if s==2||s>3
				sh 0,{s-2}
				sh.. {s}
				f.. I*(i0#-1/$-1)*($-2/$-1)+I*(1-($-2/255))+[${1--3}]*(1-i0#-1/$-1)
				f. $-1*(i/$-1*$-2/$-1)+i*(1-$-2/$-1)+$-2*(1-i/$-1)
				rm[-2,-1]
			fi
		}

	else error !var(chans)==F
	fi

fi
#@cli rep_pfrac_t_rs : eq. to 'rep_popcorn_fractal_transformative_regular_and_swirling'
rep_pfrac_t_rs: rep_popcorn_fractal_transformative_regular_and_swirling $*
#@cli rep_popcorn_fractal_transformative: _points>0,_density>0,_H,_K,_zoom,_rotation_angle,_origin_x,_origin_y,_trig_mode={ 0=Trig-4 | 1=Trig-6 },set_arg_a,set_arg_b
#@cli : Generates Swirling Hall which is forked from Transformative Pickover Popcorn Fractal. Discovered by T.Gangopadhyay at XLRI in C.H.Area(E),Jamshedpur,India in 2012.
#@cli :
#@cli : Source: International Journal of Computer Applications(0975-8887) Volume 50-No.8, July 2012.
#@cli :
#@cli : _points defines the maximum number of points to be added on image based on pixel location. Negative Mode
#@cli : _density defines the frequency of points to be added along row and height of image. A value of one implies n points to be added per pixel.
#@cli : _H is the function multiplier used to subtract from the new found values from each iteration.
#@cli : _K is the inner multiplier for the inside function. See popcorn_x(a,b), and popcorn_y(a,b) embedded within the code of rep_popcorn_fractal for more information.
#@cli : _zoom defines the magnification of image. A negative value will "shrink" the structure of generated fractal.
#@cli : _rotation_angle defines the function angle of fractal.
#@cli : _origin_x defines the position of fractal. Center of image row will be treated as zero, and the ranges for image row are treated as -1,1.
#@cli : _origin_y defines the position of fractal. Center of image column will be treated as zero, and the ranges for image column are treated as -1,1.
#@cli : _set_arg defines complex trigometric functions to utilize to define the complex popcorn fractal.
#@cli :
#@cli : Note: See below note for more details on _set_arg
#@cli :
#@cli : ---- Set of arguments for each _set_arg -----
#@cli :
#@cli : There can be up to 6 set of arguments. If any of first two set of arguments are specified, then the default arguments for the first two set of arguments are overrided with the first two set of arguments. If any of the last two arguments are not specified, then it will take the last two set of arguments before it, otherwise, it will override it with the specified arguments.
#@cli :
#@cli : Note: Use the examples provided to make it easier to generate. See examples for clarification on what is meant by set of arguments.
#@cli :
#@cli : if _set_arg_n_1==0: 0,_function
#@cli :
#@cli : Output - func_a(v)
#@cli :  _function={0=sin|1=sinh|2=cos|3=cosh|4=tan|5=tanh}
#@cli :
#@cli : elif _set_arg_n_1==1: 1,_function_a,_function_b
#@cli :
#@cli : Output - func_a(v)+func_b(v)
#@cli :  _function_a={0=v|1=sin|2=sinh|3=cos|4=cosh|5=tan|6=tanh}
#@cli :  _function_b={0=v|1=sin|2=sinh|3=cos|4=cosh|5=tan|6=tanh}
#@cli :
#@cli : elif _set_arg_n_1==2: 2,_function_a,_function_b,_include_v
#@cli :
#@cli :  Output - func_a((include_v?v:0)+func_b(v))
#@cli :  _function_a={0=sin|1=sinh|2=cos|3=cosh|4=tan|5=tanh}
#@cli :  _function_b={0=sin|1=sinh|2=cos|3=cosh|4=tan|5=tanh}
#@cli :  _include_v={0=FALSE|1=TRUE}
#@cli :
#@cli : fi
#@cli :
#@cli : ---- End ----
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_points=50','density=1','H=.05','_K=3','zoom=.5','_rotation_angle=45','_origin_x=0','_origin_y=0'
#@cli : $ set_arg_a=0,0 set_arg_b=0,4 512,512 rep_popcorn_fractal_transformative_regular_and_swirling 50,2,.05,3,.5,45,0,0,0,$set_arg_a,$set_arg_b cut 0,1000
#@cli : $ set_arg_a=2,1,4,1 set_arg_b=1,4,2 set_arg_c=0,4 512,512 rep_popcorn_fractal_transformative_regular_and_swirling 50,2,.05,3,.5,45,0,0,1,$set_arg_a,$set_arg_b,$set_arg_c cut 0,1000
rep_popcorn_fractal_transformative_regular_and_swirling:

skip ${1=50},${2=1},${3=.05},${4=3},${5=.5},${6=45},${7=0},${8=0},${9=0},${10=},${11=},${12=},${13=},${14=},${15=},${16=},${17=},${18=},${19=},${20=},${21=},${22=},${23=},${24=},${25=}

use_default={!(narg($10)&&narg(${11-1}))}

if ($6-360*floor($6/360))?1
	fvx=((rot_x(ix,iy)-osx)*icx_zoom+cxsx)/sx
	fvy=((rot_y(ix,iy)-osy)*icy_zoom+cysy)/sy
else
	fvx=((ix-osx)*icx_zoom+cxsx)/sx
	fvy=((iy-osy)*icy_zoom+cysy)/sy
fi

if !$use_default
	$=funarg
	fp,argval=10,{$10%3}

	if $argval==0
		fp+=2
		fun_a=${rep_pfrac_t_and_swrlhall_str_a\ $11}
	elif $argval==1
		fp+=3
		fun_a=${rep_pfrac_t_and_swrlhall_str_b\ $11,$12}
	else
		fp+=4
		fun_a=${rep_pfrac_t_and_swrlhall_str_c\ ${11-13}}
	fi

	if narg(${funarg{$fp}})
		tv=${funarg{$fp}}
		mode_2={$tv%3}
		if $mode_2==0
			fun_b=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_2==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_b=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_b=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi
	elif !$use_default
		mode_2={$10%3}
		if $mode_2==0
			fun_b=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_2==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_b=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_b=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi
		echo $fun_b
	fi

	if $9

		if narg(${funarg{$fp}})

			tv=${funarg{$fp}}
			mode_3={$tv%3}

			if $mode_3==0
				fun_c=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
				fp+=2
			elif $mode_3==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_c=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_c=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi

		else

			mode_3={$10%3}
			if $mode_3==0
				fun_c=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
				fp+=2
			elif $mode_3==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_c=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_c=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi

		fi

		if narg(${funarg{$fp}})

			tv=${funarg{$fp}}
			mode_4={$tv%3}

			if $mode_4==0
				fun_d=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
				fp+=2
			elif $mode_4==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_d=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_d=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi

		else

			fp+={arg1($mode_3+1,2,3,4)}
			fun_d=$fun_a

		fi

		if narg(${funarg{$fp}})

			tv=${funarg{$fp}}
			mode_5={$tv%3}

			if $mode_5==0
				fun_e=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
				fp+=2
			elif $mode_5==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_e=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_e=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi

		else

			fp+={arg1($mode_4+1,2,3,4)}
			fun_e=$fun_b

		fi

		if narg(${funarg{$fp}})
			tv=${funarg{$fp}}
			mode_6={$tv%3}

			if $mode_5==0
				fun_f=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			elif $mode_6==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_f=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_f=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi
		else
			fun_f=$fun_c
		fi

		all_func=fun_a(v)=$fun_a;fun_b(v)=$fun_b;fun_c(v)=$fun_c;fun_d(v)=$fun_d;fun_e(v)=$fun_e;fun_f(v)=$fun_f

	else

		if narg(${funarg{$fp}})

			tv=${funarg{$fp}}
			mode_3={$tv%3}

			if $mode_3==0
				fun_c=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
				fp+=2
			elif $mode_3==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_c=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_c=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi

		else

			fp+={arg1($mode_2+1,2,3,4)}
			fun_c=$fun_a

		fi

		if narg(${funarg{$fp}})
			tv=${funarg{$fp}}
			mode_4={$tv%3}

			if $mode_4==0
				fun_d=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			elif $mode_4==1
				args=${funarg{$fp+1}},${funarg{$fp+2}}
				fun_d=${rep_pfrac_t_and_swrlhall_str_b\ $args}
				fp+=3
			else
				args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
				fun_d=${rep_pfrac_t_and_swrlhall_str_c\ $args}
				fp+=4
			fi
		else
			fun_d=$fun_b
		fi

		all_func=fun_a(v)=$fun_a;fun_b(v)=$fun_b;fun_c(v)=$fun_c;fun_d(v)=$fun_d

	fi

else
	all_func=fun_a(v)=sin(v);fun_b(v)=tan(v);fun_c(v)=sin(v);fun_d(v)=tan(v)
fi

iw,ih={w-1},{h-1}

channels. 0 f. 0

if $1>0
	output=ix=nx/zn;iy=ny/zn
else
	output=nx/=zn;ny/=zn;r=norm(nx,ny);t=2*atan(ny/nx);ix=r*cos(t);iy=r*sin(t)
fi

{int(w*abs($2))},{int(h*abs($2))},1,1,":begin_t(
		const nw=w-1;
		const nh=h-1;
		const ww=$iw;
		const hh=$ih;
		const icx=ww/2;
		const icy=hh/2;
		const sd=max(w,h)/min(w,h);
		const sx=w>h?sd:1;
		const sy=w>h?1:sd;
		const cx=(nw-1)/2;
		const cy=(nh-1)/2;
		const cxsx=icx*sx;
		const cysy=icy*sy;
		const pts=abs($1);
		const H=$3;
		const K=$4;
		const zoom=1/$5;
		const ang=($6/180)*pi;
		const origin_x=$7*-1*zoom;
		const origin_y=$8*zoom;
		const sx_zoom=sx*zoom;
		const sy_zoom=sy*zoom;
		const osx=origin_x*sx;
		const osy=origin_y*sy;
		const icx_zoom=icx/zoom;
		const icy_zoom=icy/zoom;
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		cnorm(a,b)=sum(sqr(a),sqr(b));
		"$all_func";
		$9?(
			out_x(a,b)=(Kb=K*b;a-H*fun_a(b+fun_b(Kb+fun_c(Kb))));
			out_y(a,b)=(Ka=K*a;b-H*fun_d(a+fun_e(Ka+fun_f(Ka))));
		):(
			out_x(a,b)=a-H*fun_a(b+fun_b(K*b));
			out_y(a,b)=b-H*fun_c(a+fun_d(K*a));
		);
	);
	ix=sx_zoom*(x-cx)/cx;
	iy=sy_zoom*(y-cy)/cy;
	ix+=origin_x;
	iy+=origin_y;
	repeat(pts,
		nx=out_x(ix,iy);
		ny=out_y(ix,iy);
		zn=cnorm(nx,ny);
		"$output";
		xval="$fvx";
		yval="$fvy";
		xpos=round(xval);
		ypos=round(yval);
		i(#-1,xpos,ypos)++;
	);"
rm.
rep_popcorn_fractal_transformative_regular_and_swirling_animated:

#gmic set_arg_a=1,2,4 set_arg_b=1,3,5 set_arg_c=1,1,2 512,512,512 rep_popcorn_fractal_transformative_regular_and_swirling_animated 50,2,.05,.25,3,-3,.5,1,45,45,0,-1,0,-1,1,$set_arg_a,$set_arg_b,$set_arg_c cut 0,500

fvx=((rot_x(ix,iy)-osx)*icx_zoom+cxsx)/sx
fvy=((rot_y(ix,iy)-osy)*icy_zoom+cysy)/sy

$=funarg
fp=16
argval={$16%3}

if $argval==0
	fp+=2
	fun_a=${rep_pfrac_t_and_swrlhall_str_a\ $17}
elif $argval==1
	fp+=3
	fun_a=${rep_pfrac_t_and_swrlhall_str_b\ $17,$18}
else
	fp+=4
	fun_a=${rep_pfrac_t_and_swrlhall_str_c\ ${17-19}}
fi

if narg(${funarg{$fp}})
	tv=${funarg{$fp}}
	mode_2={$tv%3}
	if $mode_2==0
		fun_b=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
		fp+=2
	elif $mode_2==1
		args=${funarg{$fp+1}},${funarg{$fp+2}}
		fun_b=${rep_pfrac_t_and_swrlhall_str_b\ $args}
		fp+=3
	else
		args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
		fun_b=${rep_pfrac_t_and_swrlhall_str_c\ $args}
		fp+=4
	fi
else
	mode_2={$16%3}
	if $mode_2==0
		fun_b=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
		fp+=2
	elif $mode_2==1
		args=${funarg{$fp+1}},${funarg{$fp+2}}
		fun_b=${rep_pfrac_t_and_swrlhall_str_b\ $args}
		fp+=3
	else
		args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
		fun_b=${rep_pfrac_t_and_swrlhall_str_c\ $args}
		fp+=4
	fi
fi

if $15

	if narg(${funarg{$fp}})

		tv=${funarg{$fp}}
		mode_3={$tv%3}

		if $mode_3==0
			fun_c=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_3==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_c=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_c=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	else

		mode_3={$16%3}
		if $mode_3==0
			fun_c=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_3==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_c=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_c=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	fi

	if narg(${funarg{$fp}})

		tv=${funarg{$fp}}
		mode_4={$tv%3}

		if $mode_4==0
			fun_d=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_4==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_d=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_d=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	else

		fp+={arg1($mode_3+1,2,3,4)}
		fun_d=$fun_a

	fi

	if narg(${funarg{$fp}})

		tv=${funarg{$fp}}
		mode_5={$tv%3}

		if $mode_5==0
			fun_e=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_5==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_e=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_e=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	else

		fp+={arg1($mode_4+1,2,3,4)}
		fun_e=$fun_b

	fi

	if narg(${funarg{$fp}})
		tv=${funarg{$fp}}
		mode_6={$tv%3}

		if $mode_5==0
			fun_f=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
		elif $mode_6==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_f=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_d=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	else

		fun_f=$fun_c

	fi

	all_func=fun_a(v)=$fun_a;fun_b(v)=$fun_b;fun_c(v)=$fun_c;fun_d(v)=$fun_d;fun_e(v)=$fun_e;fun_f(v)=$fun_f

else

	if narg(${funarg{$fp}})

		tv=${funarg{$fp}}
		mode_3={$tv%3}

		if $mode_3==0
			fun_c=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
			fp+=2
		elif $mode_3==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_c=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_c=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	else

		fp+={arg1($mode_2+1,2,3,4)}
		fun_c=$fun_a

	fi

	if narg(${funarg{$fp}})

		tv=${funarg{$fp}}
		mode_4={$tv%3}

		if $mode_4==0
			fun_d=${rep_pfrac_t_and_swrlhall_str_a\ ${funarg{$fp+1}}}
		elif $mode_4==1
			args=${funarg{$fp+1}},${funarg{$fp+2}}
			fun_d=${rep_pfrac_t_and_swrlhall_str_b\ $args}
			fp+=3
		else
			args=${funarg{$fp+1}},${funarg{$fp+2}},${funarg{$fp+3}}
			fun_d=${rep_pfrac_t_and_swrlhall_str_c\ $args}
			fp+=4
		fi

	else

		fun_d=$fun_b

	fi

	all_func=fun_a(v)=$fun_a;fun_b(v)=$fun_b;fun_c(v)=$fun_c;fun_d(v)=$fun_d

fi

iw,ih={w-1},{h-1}

channels. 0 f. 0

if $1>0
	output=ix=nx/zn;iy=ny/zn
else
	output=nx/=zn;ny/=zn;r=norm(nx,ny);t=2*atan(ny/nx);ix=r*cos(t);iy=r*sin(t)
fi

{int(w*abs($2))},{int(h*abs($2))},{d},1,":begin_t(
		const nw=w-1;
		const nh=h-1;
		const ww=$iw;
		const hh=$ih;
		const icx=ww/2;
		const icy=hh/2;
		const sd=max(w,h)/min(w,h);
		const sx=w>h?sd:1;
		const sy=w>h?1:sd;
		const cx=(nw-1)/2;
		const cy=(nh-1)/2;
		const cxsx=icx*sx;
		const cysy=icy*sy;
		const zz=d-1;
		const pts=abs($1);
		const H_a=$3;
		const H_b=$4;
		const K_a=$5;
		const K_b=$6;
		const zoom_a=1/$7;
		const zoom_b=1/$8;
		const ang_a=($9/180)*pi;
		const ang_b=($10/180)*pi;
		const origin_x_a=$11*-1*zoom_a;
		const origin_y_a=$12*zoom_a;
		const origin_x_b=$13*-1*zoom_b;
		const origin_y_b=$14*zoom_b;
		const sx_zoom_a=sx*zoom_a;
		const sy_zoom_a=sy*zoom_a;
		const sx_zoom_b=sx*zoom_b;
		const sy_zoom_b=sy*zoom_b;
		const osx_a=origin_x_a*sx;
		const osy_a=origin_y_a*sy;
		const osx_b=origin_x_b*sx;
		const osy_b=origin_y_b*sy;
		const icx_zoom_a=icx/zoom_a;
		const icy_zoom_a=icy/zoom_a;
		const icx_zoom_b=icx/zoom_b;
		const icy_zoom_b=icy/zoom_b;
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		cnorm(a,b)=sum(sqr(a),sqr(b));
		"$all_func";
		$15?(
			out_x(a,b)=(Kb=K*b;a-H*fun_a(b+fun_b(Kb+fun_c(Kb))));
			out_y(a,b)=(Ka=K*a;b-H*fun_d(a+fun_e(Ka+fun_f(Ka))));
		):(
			out_x(a,b)=a-H*fun_a(b+fun_b(K*b));
			out_y(a,b)=b-H*fun_c(a+fun_d(K*a));
		);
	);
	pz=z/zz;
	H=lerp(H_a,H_b,pz);
	K=lerp(K_a,K_b,pz);
	zoom=lerp(zoom_a,zoom_b,pz);
	origin_x=lerp(origin_x_a,origin_x_b,pz);
	origin_y=lerp(origin_y_a,origin_y_b,pz);
	sx_zoom=lerp(sx_zoom_a,sx_zoom_b,pz);
	sy_zoom=lerp(sy_zoom_a,sy_zoom_b,pz);
	osx=lerp(osx_a,osx_b,pz);
	osy=lerp(osy_a,osy_b,pz);
	icx_zoom=lerp(icx_zoom_a,icx_zoom_b,pz);
	icy_zoom=lerp(icy_zoom_a,icy_zoom_b,pz);
	ang=lerp(ang_a,ang_b,pz);
	cos_ang=cos(ang);
	sin_ang=sin(ang);
	ix=sx_zoom*(x-cx)/cx;
	iy=sy_zoom*(y-cy)/cy;
	ix+=origin_x;
	iy+=origin_y;
	repeat(pts,
		nx=out_x(ix,iy);
		ny=out_y(ix,iy);
		zn=cnorm(nx,ny);
		"$output";
		xval="$fvx";
		yval="$fvy";
		xpos=round(xval);
		ypos=round(yval);
		i(#-1,xpos,ypos,z)++;
	);"
rm.
rep_pfrac_t_and_swrlhall_str_a:
skip ${1=0}

mode={str='$1';str[0]==45}

argval={abs($1)%6}

str_out=${arg0\ $argval,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}

if $mode str_out..=- fi

u $str_out

rep_pfrac_t_and_swrlhall_str_b:
skip ${1=1},${2=3}

modes=[{str_a='$1';str_b='$2';[str_a[0]==45,str_b[0]==45]}]

argval={abs($1)%7}

str_out=${arg0\ $argval,v,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}

if ($modes)[0] str_out..=- fi

argval={abs($2)%7}

add_str_out=${arg0\ $argval,v,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}

if ($modes)[1]
	add_str_out..=-
else
	add_str_out..=+
fi

str_out.=$add_str_out

u $str_out

rep_pfrac_t_and_swrlhall_str_c:
skip ${1=1},${2=0},${3=1}

modes=[{str_a='$1';str_b='$2';str_c='$3';[str_a[0]==45,str_b[0]==45,str_c[0]==45]}]

argval={abs($1)%6}

str_out=${arg0\ $argval,sin(,sinh(,cos(,cosh(,tan(,tanh(}

if ($modes)[0] str_out..=- fi

if $3

	add_str_out=v

	if ($modes)[2] add_str_out..=- fi

	argval={abs($2)%6}
	add_str_out_2=${arg0\ $argval,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}

	if ($modes)[1] add_str_out_2..=- else add_str_out_2..=+ fi

	add_str_out.=$add_str_out_2

else

	argval={abs($2)%6}
	add_str_out=${arg0\ $argval,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}

	if ($modes)[1] add_str_out..=- fi

fi

str_out.=$add_str_out

u $str_out
#@cli rep_pfrac : eq. to 'rep_popcorn_fractal'
rep_pfrac: rep_popcorn_fractal $*
#@cli rep_popcorn_fractal: _points>0,_density>0,_H,_K,_zoom,_rotation_angle,_origin_x,_origin_y,_mode,_f1={ 0=sin | 1=cos | 2=tan | 3=atan},...
#@cli : Generates Pickover Popcorn Fractal. Code was adapted from Paul Bourke's c code, and extended for more possibilities. Fractal is attributed to Clifford Pickover.\n
#@cli : _points defines the maximum number of points to be added on image based on pixel location.
#@cli : _density defines the frequency of points to be added along row and height of image. A value of one implies n points to be added per pixel.
#@cli : _H is the function multiplier used to subtract from the new found values from each iteration.
#@cli : _K is the inner multiplier for the inside function. See popcorn_x(a,b), and popcorn_y(a,b) embedded within the code of rep_popcorn_fractal for more information.
#@cli : _zoom defines the magnification of image. A negative value will "shrink" the structure of generated fractal.
#@cli : _rotation_angle defines the function angle of fractal.
#@cli : _origin_x defines the position of fractal. Center of image row will be treated as zero, and the ranges for image row are treated as -1,1.
#@cli : _origin_y defines the position of fractal. Center of image column will be treated as zero, and the ranges for image column are treated as -1,1.
#@cli : _mode defines whether to use 4 trigonometric functions or 6 trigonometric functions. Each halves of functions are used on 2 functions used by different axis.
#@cli : _fn defines individual function used for the popcorn fractal.\n
#@cli : Author: Reptorian.
#@cli : Default values: '_points=50','density=1','H=.05','_K=3','zoom=1','_rotation_angle=0','_origin_x=0','_origin_y=0','_mode=0',...\n
#@cli : \ \ \ \ If _mode=0: ... = '_f1=_f3=0','_f2=_f4=2'
#@cli : \ \ \ \ If _mode=1: ... = '_f1=_f4=0','_f2=_f5=1','_f3=_f6=2'\n
rep_popcorn_fractal:
skip ${1=50},${2=1},${3=.05},${4=3},${5=1},${6=0},${7=0},${8=0},${9=0},${10=},${11=},${12=},${13=},${14=},${15=}

if ($6-360*floor($6/360))?1
	fvx=((rot_x(xnew,ynew)-osx)*icx_zoom+cxsx)/sx
	fvy=((rot_y(xnew,ynew)-osy)*icy_zoom+cysy)/sy
else
	fvx=((xnew-osx)*icx_zoom+cxsx)/sx
	fvy=((ynew-osy)*icy_zoom+cysy)/sy
fi

iw={w-1}
ih={h-1}

channels. 0 f. 0

{int(w*abs($2))},{int(h*abs($2))},1,1,":begin_t(
		const nw=w-1;
		const nh=h-1;
		const ww=$iw;
		const hh=$ih;
		const icx=ww/2;
		const icy=hh/2;
		const pts=$1;
		const H=$3;
		const K=$4;
		const zoom=1/$5;
		const ang=($6/180)*pi;
		const origin_x=$7*-1*zoom;
		const origin_y=$8*zoom;
		const sd=max(w,h)/min(w,h);
		const sx=w>h?sd:1;
		const sy=w>h?1:sd;
		const sx_zoom=sx*zoom;
		const sy_zoom=sy*zoom;
		const cx=(nw-1)/2;
		const cy=(nh-1)/2;
		const osx=origin_x*sx;
		const osy=origin_y*sy;
		const icx_zoom=icx/zoom;
		const icy_zoom=icy/zoom;
		const cxsx=icx*sx;
		const cysy=icy*sy;
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;

		$9?(
			if(narg($10),
				const argpos10=$10%4;
				argpos10==0?func_a(a)=sin(a):
				argpos10==1?func_a(a)=cos(a):
				argpos10==2?func_a(a)=tan(a):
				argpos10==3?func_a(a)=atan(a);
				,func_a(a)=sin(a);
			);
			if(narg($11),
				const argpos11=$11%4;
				argpos11==0?func_b(a)=sin(a):
				argpos11==1?func_b(a)=cos(a):
				argpos11==2?func_b(a)=tan(a):
				argpos11==3?func_b(a)=atan(a);
				,func_b(a)=cos(a);
			);
			if(narg($12),
				const argpos12=$12%4;
				argpos12==0?func_c(a)=sin(a):
				argpos12==1?func_c(a)=cos(a):
				argpos12==2?func_c(a)=tan(a):
				argpos12==3?func_c(a)=atan(a);
				,func_c(a)=tan(a);
			);

			if(!narg($13),
				if(narg($10),
					argpos10==0?func_d(a)=sin(a):
					argpos10==1?func_d(a)=cos(a):
					argpos10==2?func_d(a)=tan(a):
					argpos10==3?func_d(a)=atan(a);
					,func_d(a)=sin(a);
				);,
			const argpos13=$13%4;
			argpos13==0?func_d(a)=sin(a):
			argpos13==1?func_d(a)=cos(a):
			argpos13==2?func_d(a)=tan(a):
			argpos13==3?func_d(a)=atan(a);
			);
			if(!narg($14),
				if(narg($11),
					argpos11==0?func_e(a)=sin(a):
					argpos11==1?func_e(a)=cos(a):
					argpos11==2?func_e(a)=tan(a):
					argpos11==3?func_e(a)=atan(a);
					,func_e(a)=cos(a);
				);,
			const argpos14=$14%4;
			argpos14==0?func_e(a)=sin(a):
			argpos14==1?func_e(a)=cos(a):
			argpos14==2?func_e(a)=tan(a):
			argpos14==3?func_e(a)=atan(a);
			);
			if(!narg($15),
				if(narg($12),
					argpos12==0?func_f(a)=sin(a):
					argpos12==1?func_f(a)=cos(a):
					argpos12==2?func_f(a)=tan(a):
					argpos12==3?func_f(a)=atan(a);
					,func_f(a)=tan(a);
				);,
			const argpos15=$15%4;
			argpos15==0?func_f(a)=sin(a):
			argpos15==1?func_f(a)=cos(a):
			argpos15==2?func_f(a)=tan(a):
			argpos15==3?func_f(a)=atan(a);
			);

			popcorn_x(a,b)=(Kb=K*b;a-H*func_a(b+func_b(Kb+func_c(Kb))));
			popcorn_y(a,b)=(Ka=K*a;b-H*func_d(a+func_e(Ka+func_f(Ka))));
		):(
			if(narg($10),
				const argpos10=$10%4;
				argpos10==0?func_a(a)=sin(a):
				argpos10==1?func_a(a)=cos(a):
				argpos10==2?func_a(a)=tan(a):
				argpos10==3?func_a(a)=atan(a);
				,func_a(a)=sin(a);
			);
			if(narg($11),
				const argpos11=$11%4;
				argpos11==0?func_b(a)=sin(a):
				argpos11==1?func_b(a)=cos(a):
				argpos11==2?func_b(a)=tan(a):
				argpos11==3?func_b(a)=atan(a);
				,func_b(a)=tan(a);
			);

			if(!narg($12),
				if(narg($10),
					argpos10==0?func_c(a)=sin(a):
					argpos10==1?func_c(a)=cos(a):
					argpos10==2?func_c(a)=tan(a):
					argpos10==3?func_c(a)=atan(a);
					,func_c(a)=sin(a);
				);,
			const argpos12=$12%4;
			argpos12==0?func_c(a)=sin(a):
			argpos12==1?func_c(a)=cos(a):
			argpos12==2?func_c(a)=tan(a):
			argpos12==3?func_c(a)=atan(a);
			);
			if(!narg($13),
				if(narg($11),
					argpos11==0?func_d(a)=sin(a):
					argpos11==1?func_d(a)=cos(a):
					argpos11==2?func_d(a)=tan(a):
					argpos11==3?func_d(a)=atan(a);
					,func_d(a)=tan(a);
				);,
			const argpos13=$13%4;
			argpos13==0?func_d(a)=sin(a):
			argpos13==1?func_d(a)=cos(a):
			argpos13==2?func_d(a)=tan(a):
			argpos13==3?func_d(a)=atan(a);
			);

			popcorn_x(a,b)=a-H*func_a(b+func_b(K*b));
			popcorn_y(a,b)=b-H*func_c(a+func_d(K*a));
		);
	);
	xx=sx_zoom*(x-cx)/cx;
	yy=sy_zoom*(y-cy)/cy;
	xx+=origin_x;
	yy+=origin_y;
	repeat(pts,
		xnew=popcorn_x(xx,yy);
		ynew=popcorn_y(xx,yy);
		xval="$fvx";
		yval="$fvy";
		++i(#-1,xval,yval);
		xx=xnew;
		yy=ynew;
	);"
rm.
#@cli rep_x_graphical_tiling: [Images],_insertion_rate,_back_r,_back_g,_back_b
#@cli : Launch the interactive graphical tiling window.\n
#@cli : Details: The main purpose of this filter is to stimulate graphical tiling glitch observed in older operating system and computers. However, you can also use it to tile images by hand to artistic purpose.\n
#@cli : '[Images]' are images to be assigned to be tiled.
#@cli : '_insertion_rate' defines the rate of insertion per milliseconds.
#@cli : '_back_' defines the background color in the one of the preview mode.
#@cli : Default values: '_insertion_rate=0','_back_r=0','_back_g=0','_back_b=0'
rep_x_graphical_tiling:
skip ${2=0},${3=0},${4=0},${5=0}
is_windows_tileset=${"is_image_arg $1"}

e[] "\n Instruction on how to work with interactive windows.\n
	\ ---------------------------------------------------------\n\n
	\ - All Modes -\n\n
	\   * O: Change Preview Mode\n
	\   * SPACE: Switch Mode\n
	\   * ESC: End Interactive Window\n\n
	\ Important Note: Check the message in the title bar.\n\n
	\ - Image Placement Mode -\n\n
	\   * D: Display Overlay Image\n
	\   * H: Flip Image Horizontally\n
	\   * V: Flip Image Vertically\n
	\   * Mouse Click: Move/Place Image\n
	\   * ARROW UP/DOWN:Change Tiling Image\n
	\   * ARROW LEFT/RIGHT:Rotate Image\n
	\ - Tiling Mode - \n\n
	\   * Mouse Move: Place Tile at Insertion Rate\n
	\   * ARROW UP/DOWN: Add/Subtract Insertion Rate by 100 ms\n
	\   * ARROW LEFT/RIGHT: Add/Subtract Insertion Rate by 10 ms\n\n
	\ Additional Note: Type in 'h rep_x_graphical_tiling' for more information.\n\n
	\ ---------------------------------------------------------"

insertion_rate={max(0,$2)}

__r_back={max(0,abs($3))}
__g_back={max(0,abs($4))}
__b_back={max(0,abs($5))}

if $!!=1 error imgs!=1 fi
if !$is_windows_tileset error tile_imgs>0==F fi

pass$1 0

timg={$!}

ms=${-max_s}

if $ms>=3&&$ms<5 to_rgba
elif $ms==1&&$ms<3 to_graya
else error max_chan<5==F
fi

tnimg={$timg-1}

u {expr('w#(x+1)',$tnimg-1)} vec_w=[${}]
u {expr('h#(x+1)',$tnimg-1)} vec_h=[${}]

r {w#0},{h#0},100%,100%,0

{w},{h},1,{s},0

__w={w#0}
__h={h#0}
cx={w#0/2}
cy={h#0/2}
px=$cx
py=$cy
cpx=$cx
cpy=$cy
nx=0
ny=0

__display_mode=0
display_overlay_image=1

util_insertion=0
__ci=1

command "pass2endimage : pass[{$__ci}] 0 shift. $""1,$""2 blend alpha"

paint_mode=0
insert_duplicate_start=1
move_window=0
old_window=0
start_move=0
current_image=0
start=0
ex=-1
ey=-1

do

	if {*,SPACE}
		if $paint_mode paint_mode=0
		else paint_mode=1
		fi
		wait 50
	fi

	activate_preview=0

	if {*,O} __display_mode+=1 __display_mode={$__display_mode%3} activate_preview=1 wait 200 fi

	if !$start activate_preview=1 fi

	x,y,b,ww,wh={*,x,y,b,w,h}

	window_title=""

	if $paint_mode
		window_title.="Painting Mode [ Press SPACE TO Escape Painting Mode]"
		window_title.="- Insertion Rate - "
		window_title.=$insertion_rate
		window_title.=" ms"
		if {*,ARROWUP}" || "{*,ARROWRIGHT}
			if {*,ARROWUP} insertion_rate+=100
			else insertion_rate+=10
			fi
		elif {*,ARROWDOWN}" || "{*,ARROWLEFT}
			if {*,ARROWDOWN} insertion_rate-=100
			else insertion_rate-=10
			fi
			insertion_rate={max(0,$insertion_rate)}
		fi
	else
		if $display_overlay_image
			window_title.="Window Overlay Mode [ON]"
		else
			window_title.="Window Overlay Mode [OFF]"
		fi
		if {*,D} display_overlay_image+=1 display_overlay_image={$display_overlay_image%2} fi
		if {*,ARROWUP}" || "{*,ARROWDOWN}
			if {*,ARROWUP} current_image+=1
			else current_image-=1
			fi
			current_image={$current_image%($timg-1)}
			__ci={$current_image+1}
			wait 50
			activate_preview=1
		elif {*,ARROWLEFT}" || "{*,ARROWRIGHT}
			activate_preview=1
			r[$__ci] {($vec_w)[$__ci-1]},{($vec_h)[$__ci-1]},100%,100%,0
			if {*,ARROWRIGHT}
				rotate[$__ci] 90
			else
				rotate[$__ci] -90
			fi
			temp1={($vec_w)[$__ci-1]}
			temp2={($vec_h)[$__ci-1]}
			vec_w=[{"v=["$vec_w"];v["$__ci"-1]="$temp2";v"}]
			vec_h=[{"v=["$vec_h"];v["$__ci"-1]="$temp1";v"}]
			r[$__ci] {w#0},{h#0},100%,100%,0
		elif {*,H}" || "{*,V}
				r[$__ci] {($vec_w)[$__ci-1]},{($vec_h)[$__ci-1]},100%,100%,0
				if {*,H} mirror[$__ci] x
				elif {*,V} mirror[$__ci] y
				fi
				r[$__ci] {w#0},{h#0},100%,100%,0
		fi
	fi

	if {*,b}
		move_window+=1 move_window={$move_window%2}
		wait 50
		if !$start_move ox={$x} oy={$y} start_move=1 tpx=$px tpy=$py fi
	fi

	if !$paint_mode
		if $move_window
			if {*,C} tpx=$cx tpy=$cy ox={$x} oy={$y} fi
		else
			if {*,C} cpx=$cx cpy=$cy px=$cx py=$py fi
		fi
	fi

	if $move_window
		cpx={$tpx+$x-$ox}
		cpy={$tpy+$y-$oy}
		activate_preview=1
	fi

	if !$move_window&&$old_window
		px=$cpx
		py=$cpy
		start_move=0
		paint_mode=0
	fi

	old_window=$move_window

	if $paint_mode
		if ($ex!=$x)||($ey!=$y)
			spx={$cpx-(($vec_w)[$__ci-1]/2)}
			spy={$cpy-(($vec_h)[$__ci-1]/2)}
			pass2endimage[-1] $spx,$spy
			activate_preview=1
			wait $insertion_rate
		fi
		if $activate_preview
			if $__display_mode==0
				+blend[0,-1] alpha drgba.
			elif $__display_mode==1
				+drgba. $__r_back,$__g_back,$__b_back
			else
				+drgba.
			fi
			w[-1] {w#0},{h#0},0,$window_title
			k[0-$timg]
		fi
		ex=$x
		ey=$y
	else
		if $activate_preview
			spx={$cpx-(($vec_w)[$__ci-1]/2)}
			spy={$cpy-(($vec_h)[$__ci-1]/2)}
			if $display_overlay_image
				+shift[{$__ci}] $spx,$spy
				if $__display_mode==0
					+blend[0,-2,-1] alpha drgba.
				elif $__display_mode==1
					+blend[-2,-1] alpha drgba. $__r_back,$__g_back,$__b_back
				else
					+blend[-2,-1] alpha drgba.
				fi
			else
				if $__display_mode==0
					+blend[0,-1] alpha drgba.
				elif $__display_mode==1
					+drgba. $__r_back,$__g_back,$__b_back
				else
					+drgba.
				fi
			fi
			w[-1] {w#0},{h#0},0,$window_title
			k[0-$timg]
		fi
	fi

	insert_duplicate_start=1
	start=1
	activate_preview=0
	wait
while {*}" && "!{*,ESC}

uncommand pass2endimage k[-1]
#@cli rep_bitplane_shuffle: direction={ 0=backward | 1=forward },color_channel_only={ 0=all_channels | 1=color_channel_only },index_0...index_inf
#@cli : Shuffle Bit Planes according to the order of index specified by user.
rep_bitplane_shuffle:
skip ${2=0}
number_of_images={$!}
if !$number_of_images error no_imgs fi

num_of_ind,direction,all_channels={$#-2},{$1&1},{!$2}
size_of_map={1<<$num_of_ind}

whole_numbers=[{expr('x',$num_of_ind)}]
order=[${3--1}]

if $#<=3 error insuf_args fi
if sort($order)!=$whole_numbers error inv_ind_args fi
if $order==$whole_numbers return fi

if !$direction order=[${rep_inverse_permutation\ ${3--1}}] fi

eval "
	const size_of_map=$size_of_map;
	const nimg=$number_of_images;

	if(nimg==1,
		use_map=whds>size_of_map;
	,
		use_map=sum=0;
		repeat(nimg,img_index,
			sum+=whds#img_index;
			if(sum>size_of_map,
				use_map=1;
				break();
			);
		);
	);

	set('use_map',use_map);
	"

if $use_map
	$size_of_map,1,1,1,sum((x>>$whole_numbers&1)<<$order);
	if $all_channels
		map[^-1] [-1]
		rm.
	else
		store. bin_map
		foreach {
			if !(s&1) sh 0,{s-2} fi
			$bin_map
			map[-2] [-1]
			k[0]
		}
	fi
else
	if $all_channels f sum((i>>$whole_numbers&1)<<$order);
	else
		foreach {
			if !(s&1) sh 0,{s-2} fi
			f. sum((i>>$whole_numbers&1)<<$order);
			k[0]
		}
	fi
fi
#@cli rep_edgefade: radius>0,_exponential_factor>0 : radius>0,_exponential_factor>0,_nl_amplitude>0,0<_n_smooth<=1,0<_a_smooth<=1
#@cli : Fade edges on alpha. Only applicable for images with 2 channels or 4+ channels. The last channel is the alpha channel.\n
#@cli : Note: Execute 'gmic h normalize_local' for more information on '_nl_amplitude','_n_smooth', and '_a_smooth'. nl is short for normalize_local.\n
#@cli : Default values: '_exponential_factor=0','_nl_amplitude=0','_n_smooth=4%','_a_smooth=5%'
rep_edgefade:
skip ${2=1},${3=0},${4=4%},${5=2%}
percent_mode=0 if ispercentage($1) percent_mode=1 fi
foreach {
	if s==2||s>=4

		sh. {s-1} Mval={iM#-1}
		n. 0,1
		rm.

		+channels {s-1}

		rs. 200%,,3

		local[-1] {

			if $3
				+normalize_local. $3,{$1*200%},$4,$5,1,0,1
				n. 0,1
			fi

			+f. i?1
			+distance[{$3?1:0}] 0,2

			if $percent_mode
				f. "begin(const valcheck=min(abs($1),1)*iM#-1;);i>=valcheck?1"
			else
				f. "begin(const valcheck=min(abs($1)*2,iM#-1););i>=valcheck?1"
			fi

			+f[{$3?1:0}] i#0!=0?(i#-2!=i#-1?1):0

			inpaint_pde.. [-1]

			f.. i^$2

			replace_nan.. 0

			f[0] i*i#-2

			k[0]

			rs 50%,,3
		}

		sh[0] {s#0-1}
		*. .. *. $Mval rm[-2,-1]
	fi
}
#@cli rep_kodl: eq. to 'rep_keep_original_dimension_and_or_layer'
rep_kodl:
_gmic_s="$?" v + _rep_keep_original_dimension_and_or_layer $"*"
#@cli rep_keep_original_dimension_and_or_layer: "command",_mode={ 0=old_dim | 1=old_dim_and_layer | 2=new_dim_and_layer},_interpolation, _boundary_conditions, _ax, _ay, _az
#@cli : Apply command to image(s), then have the option to preserve dimensions and/or resized layer.
#@cli : (eq. to 'rep_kodl').\n
#@cli : Default values: _preserve_resized_layer=0,_interpolation=0,_boundary_conditions=3,_ax=0.5,_ay=0.5,_az=0\n
#@cli : Author: Reptorian.
rep_keep_original_dimension_and_or_layer:
_gmic_s="$?" v + _$0 $"*"
_rep_keep_original_dimension_and_or_layer:
skip ${2=0},${3=0},${4=3},${5=.5},${6=.5},${7=0}

if $2==0||$2==1
	image_count={$!*3}
	dimensions_info=[{expr('p=int(x/3);arg1(x%3+1,w#p,h#p,d#p);',$image_count);}]
fi

command "apply_filter:$1"

if abs($2)>=0&&abs($2)<=2
	foreach {

		if abs($2)>=1
			+apply_filter
			r[0] {w#-1},{h#-1},{d#-1},100%,${3-7}
		fi

		if abs($2)==1||!$2
			if !$2 apply_filter fi
			r {($dimensions_info)[$<*3+0]},{($dimensions_info)[$<*3+1]},{($dimensions_info)[$<*3+2]},100%,${3-7}
		fi
	}
fi
uncommand apply_filter
#@cli rep_lpasc_ordith: 'eq to. rep_loupasc_ordered_dither'
rep_lpasc_ordith: rep_loupasc_ordered_dither $*
#@cli rep_loupasc_ordered_dither : _dither_method={ 0=checkerboard | 1=dispersed | 2=arcade | 3=ordered | 4=lines | 5=custom | 6=random }, _palette={ 0=Binary | 1= EGA | 2= Web-safe | 3=12-bit }
#@cli: Color reduction with dithering using algorithm provided by Pascal Ollive.
rep_loupasc_ordered_dither:
f "begin(
	color_count=[2,4,6,16];
	custom_matrix=[34,14,3,22,6,27,21,8,26,13,30,1,29,18,33,5,20,12,9,0,19,28,10,32,16,31,7,17,2,25,4,24,15,35,23,11];
	line_matrix=[8,9,6,7,1,0,3,2,4,5,9,8,2,3,0,1,4,5,7,6,1,0,3,2,4,5,8,9,6,7,0,1,4,5,7,6,9,8,2,3,4,5,8,9,6,7,1,0,3,2,7,6,9,8,2,3,0,1,4,5,6,7,1,0,3,2,4,5,8,9,2,3,0,1,4,5,7,6,9,8,3,2,4,5,8,9,6,7,1,0,4,5,7,6,9,8,2,3,0,1];
	mat_rev(n)=(
		v = (n & 0x55555555) << 1 | (n >> 1) & 0x55555555;
		v = (v & 0x33333333) << 2 | (v >> 2) & 0x33333333;
		v = (v & 0x0f0f0f0f) << 4 | (v >> 4) & 0x0f0f0f0f;
		v = (v << 24) | ((v & 0xff00) << 8) | ((v >> 8) & 0xff00) | (v >> 24);
	v;
	);
	orddith(ipx,cc,coefcount,ditherpattern)=int((((cc-1)*coefcount+1)*ipx+255*ditherpattern-1)/(255*coefcount));
	randdit(ipx,cc,nx,ny)=(
		sd=(mat_rev(ny)>>23)<<22|mat_rev(nx)>>10;
		ditp=(48271*sd)%2147483647;
		int(((cc - 1) * ipx + (ditp / 8421506)) / 255);
	);
	$1==0?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,2,xor(nx,ny)&0x1):
	$1==1?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,4,((xor(nx,ny)&0x1)<<1)|(ny&0x1)):
	$1==2?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,8,2+(ny&0x3)):
	$1==3?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,5,line_matrix[20*(ny%5)+2*(nx%5)]>>1):
	$1==4?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,10,line_matrix[10*(ny%10)+(nx%10)]):
	$1==5?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,36,custom_matrix[6*(ny%6)+(nx%6)]):
	      appdit(ipx,cc,nx,ny)=randdit(ipx,cc,nx,ny);
	cc=color_count[$2];
	cs=255/(cc-1);
);
appdit(i,cc,x,y)*cs;
"
#@cli rep_sptbwgp_recpoltrans: eq. to 'rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation'
rep_sptbwgp_recpoltrans: rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation $*
#@cli rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation: -1<=_fxy_position<=1,0<=_influence_factor<=1, _threshold>=0,-1>=_ptxy_xpos<=1,-1>=_ptxy_ypos<=1,'_channel_mode='
#@cli : Apply 'rep_shift_pixel_to_boundary_with_group_pixels' effect with 'rep_rectangular_polar_transformation'\n
#@cli : (eq. to 'rep_sptbwgp_recpoltrans').\n
#@cli : '_fx_position' determines the location of pixel relative to ptxy points.
#@cli : '_influence_factor' determines how much influence the effect have on pixels.
#@cli : '_threshold' is used to eliminate alpha below the value.
#@cli : '_ptxy_xpos' assigns the location on point of influence
#@cli : '_ptxy_ypos' assigns the location on point of influence
#@cli : '_channel_mode' is a special variable. See 'gmic h rep_sptbwgp' for more information.\n
#@cli : Default values: '_fxy_position=-1','_influence_factor=1','_threshold=0','_ptxy_xpos=0','_ptxy_ypos=0','_channel_mode=N/A'\n
#@cli : Author: Reptorian.
rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation:
skip ${1=-1},${2=1},${3=0},${4=0},${5=0},${6=}

point,tcr={[$4,$5,3]}

if narg($6)
	if $6>=0
		tcr+=1
	else
		any_channels=1
	fi
fi

foreach {

	if h>w orientation=1
	else orientation=0
	fi

	if s==2||s>$tcr sh. {s-1} mina={im#-1} maxa={iM#-1} rm. fi

	rep_recpoltrans $point,-3

	if s==2||s>$tcr sh. {s-1} n. $mina,$maxa rm. fi

	rep_sptbwgp {$1*-1},1,$2,$3,$6

	rep_recpoltrans $point,2,$orientation
}
#@cli rep_tiler_n: eq. to 'rep_tiler_nonisometric'
rep_tiler_n:
skip ${4=16},${5=16},${6=},${7=0},${8=},${9=},${10=},${11=0},${12=50}
include_tileset_image=${"is_image_arg $1"}
include_tile_img=${"is_image_arg $6"}
if $include_tile_img&&$include_tileset_image pass$1 0 pass$6 0 rep_tiler_nonisometric[0] [-2],${2-5},[-1],${7--1} rm[-2,-1]
elif $include_tileset_image pass$1 0 rep_tiler_nonisometric[0] [-1],${2--1} rm.
elif $include_tile_img pass$6 0 rep_tiler_nonisometric[0] ${1-5},[-1],${7--1} rm.
else rep_tiler_nonisometric $*
fi
#@cli rep_tiler_nonisometric: { filename | [tileset] },min_tile>=3,increment>=0,_tileset_iw_width>=1,_tileset_ih_width>=1,{ _filename | [placed_tiles] },_preserve_bgout={ 0=eliminate_bg | 1=preserve_bg },_drgba_r>=0,_drgba_g>=0,_drgba_b>=0,_gridcol>=0,_trackpadcol>=0
#@cli : Launch the interactive non-isometric tiling toolkit. Mandatory variables are the first 3 ones!
#@cli : More info: The interactive non-isometric tiling toolkit is a near final version. Final version will have tiledata import and export. Perhaps with a master developer editor to make overworld art.\n
#@cli : (eq. to 'rep_tiler_n').\n
#@cli : Note: This is meant to enable artists to make artwork based on non-isometric RPG games or even world. It is not meant to be a tool to aid into making RPG games. If you want that, then you need to look into other solutions. Of course, there might be the off-chance that this tool is suitable for you.\n
#@cli : '{ filename | [tileset] }' can be either location of the tileset in text form, or as a image argument. If using image argument, you must do rep_tiler_nonisometric[target] [tile] to make it work.
#@cli : '__min_tile' defines the size of tiles.
#@cli : 'increment' defines the maximum possible selection length by number of tiles added by 1. 0 means maximum possible selection length by tile within axis is exactly 1.
#@cli : '_tileset_iw_width' defines the width of tileset visible within interactive window.
#@cli : '_tileset_ih_width' defines the width of tileset visible within interactive window.
#@cli : '_preserve_bgout' can be used to keep or erase image after painting tiles.
#@cli : '{ filename | [placed_tiles] }' can be either location of the tile in text form, or as a image argument. If using image argument, you must do rep_tiler_nonisometric[target] [tile] to make it work.
#@cli : '_dbrga_r' is the color of transparent background. If a value is assigned to this, then transparent areas are replaced with colored background instead of a checkerboard.
#@cli : '_dbrga_g' is the color of transparent background. If a value is assigned to this, then transparent areas are replaced with colored background instead of a checkerboard.
#@cli : '_dbrga_b' is the color of transparent background. If a value is assigned to this, then transparent areas are replaced with colored background instead of a checkerboard.
#@cli : '_gridcol' defines the color of grid within interactive window. Only grayscale value.
#@cli : '_trackpadcol' defines the color of tracker pad within interactive window. Only grayscale value.\n
#@cli : Default values: '_tileset_iw_width=16','_tileset_ih_width=16','_filename=""','_preserve_bgout=0','_drgba_r=','_drgba_g=','_drgba_b=','_gridcol=0','_trackpadcol=0'\n
#@cli : Author: Reptorian
##@cli : $ 640,480,1,4 rep_tileset_n generic_platform rep_tiler_n[0] [-1],32,3,16,16,,0,,,,0,0
##@cli : $ 640,480,1,4 rep_tiler_n[0] tile.png,16,1
rep_tiler_nonisometric:
skip ${4=16},${5=16},${6=},${7=0},${8=},${9=},${10=},${11=0},${12=50}
include_tileset_image=${"is_image_arg $1"}
include_tile_img=${"is_image_arg $6"}

__min_tile={abs($2)}
if $__min_tile<3 error "$"2>=3==F"" fi
max_increment={abs($3)}

tile_width=$__min_tile
tile_height=$__min_tile

gridcol={abs($11)}
trackpadcol={abs($12)}
__trackpadcol_alt=$trackpadcol

if narg($8)||narg($9)||narg($10)
 if narg($8) __r_col={min(abs($8),255)} else __r_col=0 fi
 if narg($9) __g_col={min(abs($9),255)} else __g_col=0 fi
 if narg($10) __b_col={min(abs($10),255)} else __b_col=0 fi
 command "xalp : drgba $__r_col,$__g_col,$__b_col"
else
 command "xalp : drgba"
fi

command "xalpa: xalp to_a"

command "out2display : skip ${""1=},${""2=},${""3=},${""4=1},${""5=1},${""6=},${""7=},${""8=},${""9=},${""10=} if narg($""1) if $""1 $__bg rv blend alpha fi fi xalp if narg($""6) if narg($""2)&&narg($""3)&&narg($""4)&&narg($""5) {$""4},{$""5},1,{s#0},i(#-1,$""2+x,$""3+y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],$""2,$""3 rm. if narg($""8)&&narg($""9)&&narg($""10) if $""8==0||$""8>2 {$""4},{$""5},1,{s#0},i(#0,$__nw+($__min_tile*$""9)-$""2+x-$""4,$""3+y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],{$__nw+($__min_tile*$""9)-$""2-$""4},$""3 rm. fi if $""8==1||$""8>2 {$""4},{$""5},1,{s#0},i(#0,$""2+x,$__nh+($__min_tile*$""10)-$""3+y-$""5) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],$""2,{$__nh+($__min_tile*$""10)-$""3-$""5} rm. fi if $""8==2||$""8>2 {$""4},{$""5},1,{s#0},i(#0,$__nw+($__min_tile*$""9)-$""2+x-$""4,$__nh+($__min_tile*$""10)-$""3+y-$""5) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],{$__nw+($__min_tile*$""9)-$""2-$""4},{$__nh+($__min_tile*$""10)-$""3-$""5} rm. fi fi fi fi if narg($""7) f[0] begin(ww=w-1;hh=h-1;);(x%$__min_tile==0||y%$__min_tile==0)||(x==ww||y==hh)?$""7:i fi"

command "pass2tile : skip ${""4=2} pass$""1 $""4 f[0] i(#-1,$""2+x,$""3+y) rm."

command "tile2canvas : skip ${""4=0} pass$""1 0 +f. i(#0,$""2+x,$""3+y) if !$""4 rv[-2,-1] fi blend[-2,-1] alpha j[0] [-1],$""2,$""3 rm."

command "tile2canvas_r : +f. 0 j[0] [-1],$""1,$""2 rm. tile2canvas[0] [-1],$""1,$""2,$""3"

if $!==1
    ttw={ceil(w#0/$__min_tile)}
    tth={ceil(h#0/$__min_tile)}
    isw={$ttw}
    ish={$tth}
    $ttw,1,1,1 iscl={$ttw-1} store. __isc
    $tth,1,1,1 isrl={$tth-1} store. __isr
    __nw={$ttw*$__min_tile}
    __nh={$tth*$__min_tile}
    ttw-=2
    tth-=2
    to_a r $__nw,$__nh,100%,100%,0,0,.5,.5
    +store[0] obg
    xalpa
    cs={s#-1}
    +store[0] __bg
    if narg($6)
        if $include_tile_img pass$6 0
        else i $6
        fi
        if ((w#-1!=w#-2)||(h#-1!=h#-2)) error "Invalid Tile Image!" fi
        rm[0]
        to_a.
        start=1
    else
        f 0
        start=0
    fi
    +store[0] current_image
    +store[0] undo_image
else
    error "$!==1=F"
fi

command "tile2canvas_sym : pass$""1 0 +f. i(#0,$""2+x,$""3+y) if $""8==0||$""8==3 [1] if $""7 mirror. x fi +f. i(#0,$__nw+($__min_tile*$""9)-$""4-$""2+x,$""3+y) fi if $""8==1||$""8==3 [1] if $""7 mirror. y fi +f. i(#0,$""2+x,$__nh+($__min_tile*$""10)-$""5-$""3+y) fi if $""8==2||$""8==3 [1] if $""7 rotate. 180 fi +f. i(#0,$__nw+($__min_tile*$""9)-$""4-$""2+x,$__nh+($__min_tile*$""10)-$""5-$""3+y) fi if $""8==3 if !$""6 rv[-8,-7] rv[-6,-5] fi blend[-8,-7] alpha blend[-6,-5] alpha fi if !$""6 rv[-4,-3] rv[-2,-1] fi blend[-4,-3] alpha blend[-2,-1] alpha if $""8==3 j[0] [-4],$""2,$""3 j[0] [-3],{$__nw+($__min_tile*$""9)-$""4-$""2},$""3 j[0] [-2],$""2,{$__nh+($__min_tile*$""10)-$""5-$""3} j[0] [-1],{$__nw+($__min_tile*$""9)-$""4-$""2},{$__nh+($__min_tile*$""10)-$""5-$""3} k[0] else j[0] [-2],$""2,$""3 if $""8==0 j[0] [-1],{$__nw+($__min_tile*$""9)-$""4-$""2},$""3 elif $""8==1 j[0] [-1],$""2,{$__nh+($__min_tile*$""10)-$""5-$""3} elif $""8==2 j[0] [-1],{$__nw+($__min_tile*$""9)-$""4-$""2},{$__nh+($__min_tile*$""10)-$""5-$""3} fi rm[-2,-1] fi"

command "tile2canvas_r_sym : +f. 0 j[0] [-1],$""1,$""2 if $""6==3||$""6==0 j[0] [-1],{$__nw+($__min_tile*$""7)-$""3-$""1},$""2 fi if $""6==3||$""6==1 j[0] [-1],$""1,{$__nh+($__min_tile*$""8)-$""4-$""2} fi if $""6==3||$""6==2 j[0] [-1],{$__nw+($__min_tile*$""7)-$""3-$""1},{$__nh+($__min_tile*$""8)-$""4-$""2} fi rm. if $""5&&($""6==3||$""6==0) +mirror[1] x fi if $""5&&($""6==3||$""6==1) +mirror[1] y fi if $""5&&($""6==3||$""6==2) +rotate[1] 180 fi if $""6==3 tile2canvas[0] [{$""5?-4:1}],$""1,$""2 tile2canvas[0] [{$""5?-3:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},$""2 tile2canvas[0] [{$""5?-2:1}],$""1,{$__nh+($__min_tile*$""8)-$""4-$""2} tile2canvas[0] [{$""5?-1:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},{$__nh+($__min_tile*$""8)-$""4-$""2} k[0,1] else tile2canvas[0] [1],$""1,$""2 if $""6==0 tile2canvas[0] [{$""5?2:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},$""2 elif $""6==1 tile2canvas[0] [{$""5?2:1}],$""1,{$__nh+($__min_tile*$""8)-$""4-$""2} elif $""6==2 tile2canvas[0] [{$""5?2:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},{$__nh+($__min_tile*$""8)-$""4-$""2} fi k[0,1] fi"

command "addsym2display : tlx={w#0/2+($""2/2)*$""3-2} tly={h#0/2+($""2/2)*$""4-2} if $""1<2 if $""1==0 4,{h#0},1,{s#0},begin(ww=w-1;dp=$""1<2?0:1;lp=dp+1;);x==0||x==ww?dp:lp elif $""1==1 {w#0},4,1,{s#0},begin(hh=h-1;dp=$""1<2?0:1;lp=dp+1;);y==0||y==hh?dp:lp fi *. 255 if $""1==0 j[0] [-1],$tlx,0 else j[0] [-1],0,$tly fi k[0] else ntlx={$tlx+3} ntly={$tly+3} f[0] ((x>=$tlx&&x<=$ntlx)||(y>=$tly&&y<=$tly+3))?((x==$tlx||x==$ntlx)||(y==$tly||y==$ntly)?0:255):i fi"

command "filter_to_selected_row_column: if $__altmode_orientation $__isr f[0] i(#-1,floor((y+$__pmin*$__min_tile)/$__min_tile),0,0,0)?i:0 else $__isc f[0] i(#-1,floor((x+$__pmin*$__min_tile)/$__min_tile),0,0,0)?i:0 fi k[0]"

command "out2display_alt : skip ${""1=},${""2=},${""3=},${""4=},${""5=} if $__altmode_orientation?$__vmax_y:$__vmax_x sh {s-1} if $__altmode_orientation $__isr f.. i(#-1,floor(y/$__min_tile),0,0,0)?i:i*.625 else $__isc f.. i(#-1,floor(x/$__min_tile),0,0,0)?i:i*.625 fi rm[-2,-1] fi if narg($""1) if $""1 $__bg rv blend alpha fi fi xalp if narg($""2) if $__altmode_orientation $__isr {w#0},{h#0},1,1,i(#-1,floor(y/$__min_tile),0,0,0)?1:0 else $__isc {w#0},{h#0},1,1,i(#-1,floor(x/$__min_tile),0,0,0)?1:0 fi f. ($__altmode_orientation?i(#-2,floor(y/$__min_tile),0,0,0):i(#-2,floor(x/$__min_tile),0,0,0))?!(i&&(j(-2,-2,0,0)&&j(-2,-1,0,0)&&j(-2,0,0,0)&&j(-2,1,0,0)&&j(-2,2,0,0)&&j(-1,-2,0,0)&&j(-1,-1,0,0)&&j(-1,0,0,0)&&j(-1,1,0,0)&&j(-1,2,0,0)&&j(1,-2,0,0)&&j(1,-1,0,0)&&j(1,0,0,0)&&j(1,1,0,0)&&j(1,2,0,0)&&j(2,-2,0,0)&&j(2,-1,0,0)&&j(2,0,0,0)&&j(2,1,0,0)&&j(2,2,0,0)&&j(0,-2,0,0)&&j(0,-1,0,0)&&j(0,1,0,0)&&j(0,2,0,0))) if narg($""3) f. !($__altmode_orientation?i(#-2,floor(x/$__min_tile),0,0,0):i(#-2,floor(y/$__min_tile),0,0,0))?(i?(j(-1,0)||j(0,-1))):i fi rm.. f[0] i(#-1,x,y,z,0)?(xor(i(#-1,x,y,z,0)*$__trackpadcol_alt,i)>128?0:255):i rm. fi if narg($""4)||narg($""5) if $__altsymmetry_mode if $__altmode_orientation {w#0},{$__min_tile},1,{s#0},i(#0,x,$""5+y) {w#0},{$__min_tile},1,{s#0},i(#0,x,$__nh+($__altsymmetry_posy-1)*$__min_tile-$""5+y) f[-2,-1] begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j... [-2],0,$""5 j... [-1],0,{h#0+($__altsymmetry_posy-1)*$__min_tile-$""5} else {$__min_tile},{h#0},1,{s#0},i(#0,$""4+x,y) {$__min_tile},{h#0},1,{s#0},i(#0,$__nw+($__altsymmetry_posx-1)*$__min_tile-$""4+x,y) f[-2,-1] begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j... [-2],$""4,0 j... [-1],{w#0+($__altsymmetry_posx-1)*$__min_tile-$""4},0 fi rm[-2,-1] else if $__altmode_orientation {w#0},{$__min_tile},1,{s#0},i(#0,x,$""5+y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j.. [-1],0,$""5 else {$__min_tile},{h#0},1,{s#0},i(#0,$""4+x,y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j.. [-1],$""4,0 fi rm. fi fi if narg($""3) f. begin(ww=w-1;hh=h-1;);(x%$__min_tile==0||y%$__min_tile==0)||(x==ww||y==hh)?$""3:i fi"

command "out2display_alt_perp : skip ${""3=},${""4=} if narg($""3) if $""3 $__bg rv blend alpha fi fi xalp if $__altmode_orientation $__isr {w#0},{$__pdiff*$__min_tile},1,{s#0},i(#-1,floor(y/$__min_tile)+$__pmin,0,0,0) f. i?(!(j(-2,-2)&&j(-2,-1)&&j(-2,0)&&j(-2,1)&&j(-2,2)&&j(-1,-2)&&j(-1,-1)&&j(-1,0)&&j(-1,1)&&j(-1,2)&&j(0,-2)&&j(0,-1)&&j(0,1)&&j(0,2)&&j(1,-2)&&j(1,-1)&&j(1,0)&&j(1,1)&&j(1,2)&&j(2,-2)&&j(2,-1)&&j(2,0)&&j(2,1)&&j(2,2))?(xor($__trackpadcol_alt,i(#0,x,$""2+y))>128?0:255):i(#0,x,$""2+y)):i(#0,x,$""2+y); j[0] [-1],0,$""2 else $__isc {$__pdiff*$__min_tile},{h#0},1,{s#0},i(#-1,floor(x/$__min_tile)+$__pmin,0,0,0) f. i?(!(j(-2,-2)&&j(-2,-1)&&j(-2,0)&&j(-2,1)&&j(-2,2)&&j(-1,-2)&&j(-1,-1)&&j(-1,0)&&j(-1,1)&&j(-1,2)&&j(0,-2)&&j(0,-1)&&j(0,1)&&j(0,2)&&j(1,-2)&&j(1,-1)&&j(1,0)&&j(1,1)&&j(1,2)&&j(2,-2)&&j(2,-1)&&j(2,0)&&j(2,1)&&j(2,2))?(xor($__trackpadcol_alt,i(#0,$""1+x,y))>128?0:255):i(#0,$""1+x,y)):i(#0,$""1+x,y); j[0] [-1],$""1,0 fi rm[-2,-1] if narg($""4) f. begin(ww=w-1;hh=h-1;);(x%$__min_tile==0||y%$__min_tile==0)||(x==ww||y==hh)?$""4:i fi"

command "keeperase_rowcolumn : if $__altmode_orientation $__isr if $""1 f.. i(#-1,floor(y/$__min_tile),0,0,0)?i:0 else f.. i(#-1,floor(y/$__min_tile),0,0,0)?0:i fi else $__isc if $""1 f.. i(#-1,floor(x/$__min_tile),0,0,0)?i:0 else f.. i(#-1,floor(x/$__min_tile),0,0,0)?0:i fi fi rm."

command "shift_rowcolumn : if $__altmode_orientation $__isr if !($__shiftboundary>0&&$__shiftboundary<4) f[0] i(#-1,floor(y/$__min_tile),0,0,0)?j(-$""1,0,0,0,0,$__shiftboundary-($__shiftboundary?2)):i; else f[0] begin(ww=w-1;);i(#-1,floor(y/$__min_tile),0,0,0)?i(x-$""1>ww?((w-$__min_tile)+($__shiftboundary==3?(floor((x-$""1-w)/$__min_tile)%2?(x-w)%$__min_tile:$__min_tile-(x-w)%$__min_tile-1):(($__shiftboundary-1)?($__min_tile-(x-w)%$__min_tile-1):(x-w)%$__min_tile))):(x-$""1>=0?x-$""1:($__shiftboundary==3?(floor((x-$""1)/$__min_tile)%2?($__min_tile-x%$__min_tile):x%$__min_tile):(($__shiftboundary-1)?($__min_tile-x%$__min_tile):x%$__min_tile))),y):i; fi else $__isc if !($__shiftboundary>0&&$__shiftboundary<4) f[0] i(#-1,floor(x/$__min_tile),0,0,0)?j(0,-$""2,0,0,0,$__shiftboundary-($__shiftboundary?2)):i; else f[0] begin(hh=h-1;);i(#-1,floor(x/$__min_tile),0,0,0)?i(x,y-$""2>hh?((h-$__min_tile)+($__shiftboundary==3?(floor((y-$""2-h)/$__min_tile)%2?(y-h)%$__min_tile:$__min_tile-(y-h)%$__min_tile-1):(($__shiftboundary-1)?($__min_tile-(y-h)%$__min_tile-1):(y-h)%$__min_tile))):(y-$""2>=0?y-$""2:($__shiftboundary==3?(floor((y-$""2)/$__min_tile)%2?($__min_tile-y%$__min_tile):y%$__min_tile):(($__shiftboundary-1)?($__min_tile-y%$__min_tile):y%$__min_tile)))):i; fi fi rm."

command "place_rowcolumn : if $__altmode_orientation if $__altplace_replacemode $__isr pass$""1 0 {w#-1},{h#-1},1,1,i(#-2,floor(y/$__min_tile)+$__pmin,0,0,0) j[0] [-2],0,$""3,0,0,1,[-1],1 else pass$""1 0 {w#0},{h#0},1,{s#0},j(#-1,0,-$""3) rm.. if $__altplacebackmode rv fi blend alpha fi else if $__altplace_replacemode $__isc pass$""1 0 {w#-1},{h#-1},1,1,i(#-2,floor(x/$__min_tile)+$__pmin,0,0,0) j[0] [-2],$""2,0,0,0,1,[-1],1 else pass$""1 0 {w#0},{h#0},1,{s#0},j(#-1,-$""2,0) rm.. if $__altplacebackmode rv fi blend alpha fi fi k[0]"

command "fill_tiles2canvas : if $__fill_boundary==0 f[0] i(#-1,x%w#-1,y%h#-1) elif $__fill_boundary==1 f[0] i(#-1,int(x/w#-1)%2?w#-1-1-x%w#-1:x%w#-1,int(y/h#-1)%2?h#-1-1-y%h#-1:y%h#-1) elif $__fill_boundary==2 f[0] i(#-1,int(x/w#-1)%2?w#-1-1-x%w#-1:x%w#-1,y%h#-1) elif $__fill_boundary==3 f[0] i(#-1,x%w#-1,int(y/h#-1)%2?h#-1-1-y%h#-1:y%h#-1) fi"

v +
e[] "\n Instruction on how to work with interactive windows.\n
 \ ---------------------------------------------------------\n\n
 \ Press Escape on Canvas Window to exit!\n\n
 \ *** MAIN EDITING MODE ***\n\n
 \ - On any window - \n
 \   * D: Switch between Place/Eraser Mode\n
 \   * R: Activate Replace Mode\n
 \   * W: Restore All Windows\n
 \   * SPACEBAR: Switch Mode\n\n
 \ - On Canvas window - \n
 \   * C: Activate Copy Mode On/Off\n
 \   * X: Activate Cut Mode On/Off\n
 \   * Z: Undo Canvas Changes\n
 \   * F: Activate/Deactivate Background Tile Layering Mode\n
 \   * G: Activate Canvas Grid Mode On/Off\n
 \   * Q: Remove/Restore Background\n
 \   * A: Enable/Disable Tracker\n
 \   * S: Activate Symmetry Mode\n\n
 \   -- On Canvas [Symmetry Mode] --\n
 \     * 1: Switch Symmetry Axis to X-Axis\n
 \     * 2: Switch Symmetry Axis to Y-Axis\n
 \     * 3: Switch Symmetry Axis to Cross XY-Axis\n
 \     * 4: Switch Symmetry Axis to Mirror XY-Axis\n
 \     * ARROWKEY: Move Symmetry Line\n
 \     * B: Switch Axis in Symmetry Mode\n
 \     * M: Switch between Periodic/Mirror boundary mode in Symmetry Mode\n
 \     * J: Symmetry Line(s) to Center\n
 \     * S: Deactivate Symmetry Mode\n\n
 \ - On Tileset window - \n
 \   * G: Activate Tileset Grid Mode On/Off\n
 \   * CTRL+ARROWKEY: Resize Tile Selection Box\n
 \   * ARROWKEY: Scroll through tileset\n\n
 \ - On Tile window - \n
 \   * CTRL+ARROWKEY: Mirror alongside axis\n
 \   * ARROWKEY: Rotate Tile\n
 \   * MOUSE BUTTON: Switch between Place/Eraser Mode\n\n
 \   -- On Tile [No Symmetry Mode] --\n
 \     * 1: Switch Fill Boundary to Periodic\n
 \     * 2: Switch Fill Boundary to Mirror\n
 \     * 3: Switch Fill Boundary to Mirror X\n
 \     * 4: Switch Fill Boundary to Mirror Y\n
 \     * B: Increment Fill Boundary Mode\n\n
 \ *** ROW/COLUMN EDITING MODE ***\n\n
 \ - On any window - \n
 \   * W: Restore All Windows\n
 \   * SPACEBAR: Switch Mode\n\n
 \ - On Canvas window - \n
 \   * Z: Undo Canvas Changes\n
 \   * T: Enable Row/Column Shifting Mode\n
 \   * E: Activate Place Mode\n
 \   * G: Activate Canvas Grid Mode On/Off\n
 \   * Q: Remove/Restore Background\n
 \   * A: Enable/Disable Tracker\n
 \   * S: Activate Symmetrical Selection Mode\n\n
 \   -- On Canvas [Selection Mode] --\n
 \     * C: Keep Selected Row/Column\n
 \     * X: Delete Selected Row/Column\n
 \     * D: Select/Deselect Row/Column\n
 \     * R: Clear Selection\n
 \     * V: View Selection Box/Hide Selection Box\n
 \     * Mouse Button: Select or Deselect\n
 \     * ARROWKEY: Switch between Row/Column Selection Mode\n\n
 \   -- On Canvas [Selection Mode](Symmetry Mode)--\n
 \     * J: Symmetry Line to Center\n
 \     * ARROWKEY: Move Symmetry Line\n
 \     * S: Deactivate Symmetrical Selection Mode\n\n
 \   -- On Canvas [Row/Column Shifting Mode] --\n
 \     * Mouse Button (First Click): Activate Shifting\n
 \     * Mouse Button (Second Click): Finalize Shifting\n
 \     * 0: Shift Boundary Mode - None\n
 \     * 1: Shift Boundary Mode - Neumann (Periodic)\n
 \     * 2: Shift Boundary Mode - Neumann (Mirror)\n
 \     * 3: Shift Boundary Mode - Neumann (Alternating)\n
 \     * 4: Shift Boundary Mode - Periodic\n
 \     * 5: Shift Boundary Mode - Mirror\n
 \     * ARROWKEY: Switch between row/column\n
 \     * T: Disable Row/Column Shifting Mode\n\n
 \   -- On Canvas [Place Mode] --\n
 \     * Mouse Button: Place Row/Column\n
 \     * B: Switch between Replacement/Placement Mode\n
 \     * F: In Placement Mode, switch between background/foreground placement mode\n
 \     * E: Deactivate Place Mode\n\n
 \   -- On Tile window - \n
 \     * ARROWKEY: Flip Row/Column\n
 \ ---------------------------------------------------------\n"
v -

if $include_tileset_image
    pass$1 0
else
    i $1
fi

local[-1] {
    xr={ceil(w#-1/(abs($4)*$__min_tile))}
    yr={ceil(h#-1/(abs($5)*$__min_tile))}
    split_tiles. {-abs($4)*$__min_tile},{-abs($5)*$__min_tile}
    mw=${-max_w}
    mh=${-max_h}
    tsw={$mw-$__min_tile}
    tsh={$mh-$__min_tile}
    ti={$!}
}

$__min_tile,$__min_tile,1,4,0
fti={$!}

$__bg
+xalp.

dw0c={w#0}
dh0c={h#0}

dwm0=0
dwm1=0
dwm2=0

d2rw=196

w[-1] {w#0},{h#0},0,"Canvas"
rm[-2,-1]
+xalp[1]
w1[-1] {w#1},{h#1},0,"Tileset" rm.
w2[-1] $d2rw,$d2rw,0,"Tile"

+store. switchmode_tile

fti={$!}

mode=0

 icx=0
 icy=0
 ci=0
 lr=0
 tb=0
 tbc=0
 ni=1

 cutcopymode=0
 erasemode=0
 replacemode=0
 editmode=0

 symmetrymode=0
 symmetryaxis=0
 symmetrybound=0
 symmetry_posx=0
 symmetry_posy=0

 canvas_background=1
 canvas_gridmode=0
 canvas_tracker=1

 tileset_gridmode=0
 temp_tileset_gridmode=0

 select_from_tileset=0

 resize_tile_from_tileset=0
 resize_tile_from_canvas=0
 transform_tile=0
 switch_tile_set=0

 tile_placement_mode=0

 current_csx=-1
 current_csy=-1
 optinsert=1

 __fill_boundary=0
 __corner_fill=0

#mode=1#

 activated_switched_twice=0
 modeswitched=0
 mainaltmode=1
 viewselectionbox=1
 selectionboxmode=0
 deselectmode=0
 activate_deselect_select=0
 movemode=0
 delmode=0
 transfermode=0

 rowcolumnshiftmode=0
 shiftplacecount=0
 __shiftboundary=1
 altrcx1=-1
 altrcy1=-1
 altrcx2=-1
 altrcx2=-1

 current_acsx=-1
 current_acsy=-1
 altx=-1
 alty=-1
 tempaltx=-1
 tempalty=-1
 activate_altpreview=0
 activate_altpass2tile=0

 __altsymmetry_mode=0
 __altsymmetry_posx=0
 __altsymmetry_posy=0
 __altmode_orientation=0

 __vmax_x=0
 __vmax_y=0
 pmax=0
 __pmin=0
 __pdiff=0

 place_rowcolumn_mode=0
 __altplacebackmode=0
 __altplace_replacemode=1

do
 main_w_title="Canvas"
 if $start
  if $mode main_w_title.=" [Row/Column Editing Mode]"
  else main_w_title.=" [Main Editing Mode] -" fi
 fi

 modeswitched=0
 if {*,SPACE}" || "{*1,SPACE}" || "{*2,SPACE}" && "$start mode+=1 mode={$mode%2} modeswitched=1 wait 100 fi

 if $modeswitched
  +store. temp_switch_tile
  $switchmode_tile
  rv[-2,-1]
  rm.
  $temp_switch_tile
  store. switchmode_tile
  if $mode
   +out2display. , w2[-1] {w#-1},{h#-1},-1,-1,"Tile" rm.
   w1[] 0
  else
   +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
   +out2display[$ni] , w1[-1] {w#$ni+$dwm1*w#$ni},{h#$ni+$dwm1*h#$ni} rm.
  fi
 fi

 if $start&&$mode
  if {*,G} canvas_gridmode+=1   canvas_gridmode={$canvas_gridmode%2} wait 100 activate_altpreview=1 fi
  if {*,Q} canvas_background+=1 canvas_background={$canvas_background%2} wait 100 activate_altpreview=1 fi
  if {*,A} canvas_tracker+=1 canvas_tracker={$canvas_tracker%2} wait 100 activate_altpreview=1 fi
  if {*,S} __altsymmetry_mode+=1 __altsymmetry_mode={$__altsymmetry_mode%2} wait 200 activate_altpreview=1 fi
  if {*,E} mainaltmode+=1 mainaltmode={$mainaltmode%2} wait 200 activate_altpreview=1 fi
  if {*,V} viewselectionbox+=1 viewselectionbox={$viewselectionbox%2} wait 200 activate_altpreview=1 fi

  if $mainaltmode if {*,D} deselectmode+=1 deselectmode={$deselectmode%2} wait 200 activate_altpreview=1 activate_deselect_select=1 fi fi

  undo_state=0
  if {*,Z} undo_state=1 fi
  if $undo_state
   +store[0] temp_undo
   $undo_image
   rv[0,-1]
   rm.
   activate_altpreview=1
   $temp_undo
   store. undo_image
  fi

  if {*,T} rowcolumnshiftmode+=1 rowcolumnshiftmode={$rowcolumnshiftmode%2} wait 200 activate_altpreview=1 if $shiftplacecount shiftplacecount=0 fi fi

  if $rowcolumnshiftmode
   if {*,0} __shiftboundary=0 wait 200 activate_altpreview=1 fi
   if {*,1} __shiftboundary=1 wait 200 activate_altpreview=1 fi
   if {*,2} __shiftboundary=2 wait 200 activate_altpreview=1 fi
   if {*,3} __shiftboundary=3 wait 200 activate_altpreview=1 fi
   if {*,4} __shiftboundary=4 wait 200 activate_altpreview=1 fi
   if {*,5} __shiftboundary=5 wait 200 activate_altpreview=1 fi
   if {*,M} __shiftboundary+=1 __shiftboundary={$__shiftboundary%6} wait 200 activate_altpreview=1 fi
  fi

  if {*,W} w[] 1 w2[] 1 fi

  if {*2,ARROWLEFT}" || "{*2,ARROWRIGHT} mirror. x transform_tile=1 wait 100
  elif {*2,ARROWUP}" || "{*2,ARROWDOWN} mirror. y transform_tile=1 wait 100
  fi

  if $transform_tile
   +out2display. , w2[-1] rm.
   transform_tile=0
  fi

  if !$mainaltmode
   if {*,B} __altplace_replacemode+=1 __altplace_replacemode={$__altplace_replacemode%2} wait 200 activate_altpreview=1 fi
   if !$__altplace_replacemode&&{*,F} __altplacebackmode+=1 __altplacebackmode={$__altplacebackmode%2} wait 200 activate_altpreview=1 fi
  fi

  if {*,R}
   if $__altmode_orientation
    $__isr f. 0 store. __isr __vmax_y=0
   else
    $__isc f. 0 store. __isc __vmax_x=0
   fi
   activate_altpreview=1
  fi

  if $mainaltmode&&!$rowcolumnshiftmode
   if $__altsymmetry_mode
    if $__altmode_orientation
     if {*,ARROWUP} __altsymmetry_posy-=1  __altsymmetry_posy={max(-$tth,$__altsymmetry_posy)} activate_altpreview=1 wait 200 fi
     if {*,ARROWDOWN} __altsymmetry_posy+=1 __altsymmetry_posy={min($tth,$__altsymmetry_posy)} activate_altpreview=1 wait 200 fi
     if {*,ARROWLEFT}||{*,ARROWRIGHT} __altmode_orientation=0 activate_altpreview=1 wait 200 fi
     if {*,J} __altsymmetry_posy=0 activate_altpreview=1 wait 200 fi
    else
     if {*,ARROWLEFT} __altsymmetry_posx-=1  __altsymmetry_posx={max(-$ttw,$__altsymmetry_posx)} activate_altpreview=1 wait 200 fi
     if {*,ARROWRIGHT} __altsymmetry_posx+=1 __altsymmetry_posx={min($ttw,$__altsymmetry_posx)} activate_altpreview=1 wait 200 fi
     if {*,ARROWUP}||{*,ARROWDOWN} __altmode_orientation=1 activate_altpreview=1 wait 200 fi
     if {*,J} __altsymmetry_posx=0 activate_altpreview=1 wait 200 fi
    fi
   else
     if {*,ARROWLEFT}||{*,ARROWRIGHT}||{*,ARROWUP}||{*,ARROWDOWN} __altmode_orientation+=1 __altmode_orientation={$__altmode_orientation%2} activate_altpreview=1 wait 200 fi
   fi
  elif $mainaltmode&&$rowcolumnshiftmode
   if {*,ARROWLEFT}||{*,ARROWRIGHT} __altmode_orientation+=1 __altmode_orientation={$__altmode_orientation%2} activate_altpreview=1 wait 200 fi
  fi

  if $mainaltmode&&!$rowcolumnshiftmode
   if $deselectmode main_w_title.=" - [Deselection]"
   else main_w_title.=" - [Selection]"
   fi
  elif $mainaltmode&&$rowcolumnshiftmode
   main_w_title.=" - [Shift] (Boundary Condition - "
   if $__shiftboundary==0 main_w_title.="None)"
   elif $__shiftboundary==1 main_w_title.="Neumann (Periodic))"
   elif $__shiftboundary==2 main_w_title.="Neumann (Mirror))"
   elif $__shiftboundary==3 main_w_title.="Neumann (Alternating))"
   elif $__shiftboundary==4 main_w_title.="Periodic)"
   else main_w_title.="Mirror)"
   fi
  else
   main_w_title.=" - [Place] "
   if $__altplace_replacemode
    main_w_title.="(Replacement Mode)"
   else
    if $__altplacebackmode main_w_title.="(Background)"
    else main_w_title.="(Foreground)"
    fi
   fi
  fi

  if $viewselectionbox&&$canvas_gridmode
   canvas_set=$canvas_background,$viewselectionbox,$gridcol,
  elif $viewselectionbox
   canvas_set=$canvas_background,$viewselectionbox,,
  elif $canvas_gridmode
   canvas_set=$canvas_background,,$gridcol,
  fi

  x,y,b,ww,wh={*,x,y,b,w,h}

  if $b" && "$x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0" && "!{*,G}
   acsx={floor($x/$__min_tile)} acsy={floor($y/$__min_tile)}
   if $mainaltmode&&!$rowcolumnshiftmode
    if ($__altmode_orientation?(($current_acsy!=$acsy)||$__vmax_y==0):(($current_acsx!=$acsx)||$__vmax_x==0))||$activate_deselect_select
     if !$deselectmode
      if !$__altmode_orientation
       $__isc
       f. x==$acsx?1:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posx;);x==(ww-$acsx)?1:i; fi
       __vmax_x={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$iscl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isc
      else
       $__isr
       f. x==$acsy?1:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posy;);x==(ww-$acsy)?1:i; fi
       __vmax_y={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$isrl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isr
      fi
     else
      if !$__altmode_orientation
       $__isc
       f. x==$acsx?0:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posx;);x==(ww-$acsx)?0:i; fi
       __vmax_x={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$iscl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isc
      else
       $__isr
       f. x==$acsy?0:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posy;);x==(ww-$acsy)?0:i; fi
       __vmax_y={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$isrl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isr
      fi
     fi
     activate_altpreview=1
     activate_altpass2tile=1
    fi
   elif $mainaltmode&&$rowcolumnshiftmode
    if $shiftplacecount==0
     altrcx1={$acsx*$__min_tile}
     altrcy1={$acsy*$__min_tile}
     activate_altpreview=1
     shiftplacecount+=1
    elif $shiftplacecount==1
     altrcx2={$acsx*$__min_tile}
     altrcy2={$acsy*$__min_tile}
     activate_altpreview=1
     shift_rowcolumn[0] {$altrcx2-$altrcx1},{$altrcy2-$altrcy1}
     if $__altmode_orientation
      if abs($altrcy2-$altrcy1)
       +store[0] undo_image
      fi
     else
      if abs($altrcx2-$altrcx1)
       +store[0] undo_image
      fi
     fi
     shiftplacecount=0
    fi
    wait 100
   else
    if $__altmode_orientation?($current_acsy!=$acsy):($current_acsx!=$acsx)
     +store[0] undo_image
     place_rowcolumn[0] [-1],{min($acsx,$isw-$__pdiff)*$__min_tile},{min($acsy,$ish-$__pdiff)*$__min_tile}
     activate_altpreview=1
    fi
   fi
   current_acsx=$acsx current_acsy=$acsy
  fi

  if $__altmode_orientation?$__vmax_y>0:$__vmax_x>0
   if $activate_altpass2tile
    if !$__altmode_orientation
     r. {$__pdiff*$__min_tile},{h#0}
     pass2tile. [0],{$__pmin*$__min_tile},0
    else
     r. {w#0},{$__pdiff*$__min_tile}
     pass2tile. [0],0,{$__pmin*$__min_tile}
    fi
    filter_to_selected_row_column.
    +out2display. , w2[-1] {w#-1},{h#-1},-1,-1,"Tile" rm.
   fi
   activate_altpass2tile=0
   if {*,K}||{*,C}
    +store[0] undo_image
    keeperase_rowcolumn[0] 1
    wait 200
    activate_altpreview=1
   fi
   if {*,X}
    +store[0] undo_image
    keeperase_rowcolumn[0] 0
    wait 200
    activate_altpreview=1
   fi
  else
   r. 1,1
   f. 0
   +out2display. , w2[-1] {$d2rw},{$d2rw},-1,-1,"Tile" rm.
   mainaltmode=1
   rowcolumnshiftmode=0
   deselectmode=0
  fi

  if $mainaltmode
   if !$rowcolumnshiftmode
    if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0" && "$canvas_tracker" && "($canvas_tracker||$activate_altpreview)
     altx={floor($x/$__min_tile)*$__min_tile} alty={floor($y/$__min_tile)*$__min_tile}
     if ($__altmode_orientation?($alty!=$tempalty):($altx!=$tempaltx))||$activate_altpreview
      canvas_set.=$altx,$alty
      +out2display_alt[0] $canvas_set if $__altsymmetry_mode addsym2display. $__altmode_orientation,$__min_tile,$__altsymmetry_posx,$__altsymmetry_posy fi w[-1] {w#0},{h#0},0,$main_w_title rm.
     fi
     tempaltx=$altx tempalty=$alty
    else
     +out2display_alt[0] $canvas_set if $__altsymmetry_mode addsym2display. $__altmode_orientation,$__min_tile,$__altsymmetry_posx,$__altsymmetry_posy fi w[-1] {w#0},{h#0},0,$main_w_title rm.
    fi
    activate_altpreview=0
   else
    if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
     if $activate_altpreview
      altx={floor($x/$__min_tile)*$__min_tile} alty={floor($y/$__min_tile)*$__min_tile}
      if $shiftplacecount
       if (!$__altmode_orientation?($alty!=$tempalty):($altx!=$tempaltx))||$activate_altpreview
        +shift_rowcolumn[0] {$altx-$altrcx1},{$alty-$altrcy1}
        out2display_alt. $canvas_set
        w[-1] {w#0},{h#0},0,$main_w_title rm.
       fi
       tempaltx=$altx tempalty=$alty
      else
       +out2display_alt[0] $canvas_set
       w[-1] {w#0},{h#0},0,$main_w_title rm.
       activate_altpreview=0
      fi
     fi
    fi
   fi
  else
   if $canvas_gridmode
     perp_end=$canvas_background,$gridcol
   else
     perp_end=$canvas_background
   fi
   if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
    altx={min(floor($x/$__min_tile),$isw-$__pdiff)*$__min_tile} alty={min(floor($y/$__min_tile),$ish-$__pdiff)*$__min_tile}
    if ($__altmode_orientation?($alty!=$tempalty):($altx!=$tempaltx))||$activate_altpreview
     +out2display_alt_perp[0] $altx,$alty,$perp_end w[-1] {w#0},{h#0},0,$main_w_title rm.
    fi
    tempaltx=$altx tempalty=$alty
    activate_altpreview=0
   fi
  fi

 else
  if {*,G}
   canvas_gridmode+=1
   canvas_gridmode={$canvas_gridmode%2} fi
  if {*,Q}
   canvas_background+=1
   canvas_background={$canvas_background%2} fi
  if {*,A}
   canvas_tracker+=1
   canvas_tracker={$canvas_tracker%2} fi

  undo_state=0
  canvas_set=""

  if {*,W}" || "{*1,W}" || "{*2,W} w[] w1[] w2[] fi

  if {*,Z} undo_state=1 fi

  if {*,F} tile_placement_mode+=1 tile_placement_mode={$tile_placement_mode%2} fi
  if {*,R}" || "{*1,R}" || "{*2,R}
   replacemode+=1 replacemode={$replacemode%2} optinsert=1
  fi

  if {*,S} symmetrymode+=1 symmetrymode={$symmetrymode%2} optinsert=1 fi

  if $symmetrymode
   if {*,1} symmetryaxis=0 wait 200 fi
   if {*,2} symmetryaxis=1 wait 200 fi
   if {*,3} symmetryaxis=2 wait 200 fi
   if {*,4} symmetryaxis=3 wait 200 fi
   if {*,B} symmetryaxis+=1 symmetryaxis={$symmetryaxis%4} wait 200 fi
   if {*,M} symmetrybound+=1 symmetrybound={$symmetrybound%2} wait 200  fi
   if {*,J} symmetry_posx=0 symmetry_posy=0 wait 200 fi
   if {*,ARROWLEFT} symmetry_posx-=1 wait 200 fi
   if {*,ARROWRIGHT} symmetry_posx+=1 wait 200 fi
   if {*,ARROWUP} symmetry_posy-=1 wait 200 fi
   if {*,ARROWDOWN} symmetry_posy+=1 wait 200 fi
   symmetry_posx={$symmetry_posx>=0?min($ttw,$symmetry_posx):max(-$ttw,$symmetry_posx)}
   symmetry_posy={$symmetry_posy>=0?min($tth,$symmetry_posy):max(-$tth,$symmetry_posy)}
  else
   if {*2,1} __fill_boundary=0 wait 200
   elif {*2,2} __fill_boundary=1 wait 200
   elif {*2,3} __fill_boundary=2 wait 200
   elif {*2,4} __fill_boundary=3 wait 200
   fi
   if {*2,B} __fill_boundary={($__fill_boundary+1)%4} wait 200 fi
  fi

  if $canvas_gridmode
   if $canvas_tracker canvas_endset=,$trackpadcol,$gridcol,
   else canvas_endset=,,$gridcol,
   fi
  else
   if $canvas_tracker canvas_endset=,$trackpadcol,
   else canvas_endset=",,"
   fi
  fi
  if {*,C}" || "{*,X}
   if {*,X} cutcopymode=1
   else cutcopymode=2
   fi
  fi

  if {*,D}" || "{*1,D}" || "{*2,D}
   erasemode+=1
   erasemode={$erasemode%2}
   if $erasemode  +f. 0 w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
   else +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
   fi
   optinsert=1
  fi

  if {*1,G} tileset_gridmode+=1 tileset_gridmode={$tileset_gridmode%2} wait 200 temp_tileset_gridmode=1 fi

  x,y,b,ww,wh={*,x,y,b,w,h}
  x1,y1,b1,ww1,wh1={*1,x,y,b,w,h}
  x2,y2,b2,ww2,wh2={*2,x,y,b,w,h}

  if $start
   if $undo_state
    +store[0] temp_undo
    $undo_image
    rv[0,-1]
    rm.
    $temp_undo
    store. undo_image
   fi

   if {{*2,CTRLLEFT}" || "{*2,CTRLRIGHT}}" && "{{*2,ARROWLEFT}" || "{*2,ARROWRIGHT}}
    mirror. x transform_tile=1
    wait 100
   elif {{*2,CTRLLEFT}" || "{*2,CTRLRIGHT}}" && "{{*2,ARROWUP}" || "{*2,ARROWDOWN}}
    mirror. y transform_tile=1
    wait 100
   elif {*2,ARROWLEFT}||{*2,ARROWRIGHT}
    temp_tile_width=$tile_width
    temp_tile_height=$tile_height
    temp_icx=$icx
    temp_icy=$icy
    icx=$temp_icy
    icy=$temp_icx
    tile_width=$temp_tile_height
    tile_height=$temp_tile_width

    if {*2,ARROWRIGHT} rotate. 90 else rotate. -90 fi
    transform_tile=1

    wait 100
   fi

   if {*2,O}" && "!$symmetrymode
    +store[0] undo_image
    fill_tiles2canvas
    wait 100
   fi

   if $transform_tile
    +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
    transform_tile=0
    optinsert=1
   fi

   if {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWRIGHT}}
    if $select_from_tileset
     icx+=1
     icx={min($icx,$max_increment)}
     tile_width={$__min_tile+($icx*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWLEFT}}
    if $select_from_tileset
     icx-=1
     icx={max($icx,0)}
     tile_width={$__min_tile+($icx*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWDOWN}}
    if $select_from_tileset
     icy+=1
     icy={min($icy,$max_increment)}
     tile_height={$__min_tile+($icy*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWUP}}
    if $select_from_tileset
     icy-=1
     icy={max($icy,0)}
     tile_height={$__min_tile+($icy*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {*1,ARROWRIGHT}
    select_from_tileset=0
    lr+=1
    lr={$lr%$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    switch_tile_set=1
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    wait 625
   elif {*1,ARROWLEFT}
    select_from_tileset=0
    lr-=1
    lr={$lr%$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    switch_tile_set=1
    wait 625
   elif {*1,ARROWDOWN}
    select_from_tileset=0
    tbc+=1
    tbc={$tbc%$yr}
    tb={$tbc*$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    switch_tile_set=1
    wait 625
   elif {*1,ARROWUP}
    select_from_tileset=0
    tbc-=1
    tbc={$tbc%$yr}
    tb={$tbc*$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    switch_tile_set=1
    wait 625
   fi

   if $switch_tile_set
    +out2display[$ni] , w1[-1] {w#$ni+$dwm1*w#$ni},{h#$ni+$dwm1*h#$ni} rm.
    switch_tile_set=0
   fi

   if $resize_tile_from_tileset
     r. $tile_width,$tile_height,100%,100%,0
     tsx={min($tsx,$tsw-($icx*$__min_tile))} tsy={min($tsy,$tsh-($icy*$__min_tile))}
     pass2tile. [$ni],$tsx,$tsy
     +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
     if $tileset_gridmode
      +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol,$gridcol
     else
      +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol
     fi
     w1[-1] rm.
     resize_tile_from_tileset=0
   fi

   if $b" && "$x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
    csx={min(floor($x/$__min_tile)*$__min_tile,($iscl-$icx)*$__min_tile)} csy={min(floor($y/$__min_tile)*$__min_tile,($isrl-$icy)*$__min_tile)}
    if !$cutcopymode&&!$erasemode
     if (($current_csx!=$csx)||($current_csy!=$csy))||$optinsert
      +store[0] undo_image
      if $replacemode
       if $symmetrymode
        tile2canvas_r_sym[0,-1] $csx,$csy,$tile_width,$tile_height,$symmetrybound,$symmetryaxis,$symmetry_posx,$symmetry_posy
       else
        tile2canvas_r[0,-1] $csx,$csy,$tile_placement_mode
       fi
      else
       if $symmetrymode
        tile2canvas_sym[0] [-1],$csx,$csy,$tile_width,$tile_height,$tile_placement_mode,$symmetrybound,$symmetryaxis,$symmetry_posx,$symmetry_posy
       else
        tile2canvas[0] [-1],$csx,$csy,$tile_placement_mode
       fi
      fi
     fi
     optinsert=0
    elif $cutcopymode&&!$erasemode
     if $cutcopymode==1
      +store[0] undo_image
      pass2tile. [0],$cx,$cy {w#-1},{h#-1},1,{s#-1} j[0] [-1],$cx,$cy rm.
     else
      pass2tile. [0],$csx,$csy optinsert=0
     fi
     +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
     cutcopymode=0
     optinsert=1
     temp_tileset_gridmode=1
     select_from_tileset=0
    else
     +store[0] undo_image
     cutcopymode=0
     if (($current_csx!=$csx)||($current_csy!=$csy))||$optinsert
      if $symmetrymode
       $tile_width,$tile_height,1,{s#0}
       j[0] [-1],$csx,$csy
       if $symmetryaxis==3||$symmetryaxis==0 j[0] [-1],{$__nw+($__min_tile*$symmetry_posx)-$tile_width-$csx},$csy fi
       if $symmetryaxis==3||$symmetryaxis==1 j[0] [-1],$csx,{$__nh+($__min_tile*$symmetry_posy)-$tile_height-$csy} fi
       if $symmetryaxis==3||$symmetryaxis==2 j[0] [-1],{$__nw+($__min_tile*$symmetry_posx)-$tile_width-$csx},{$__nh+($__min_tile*$symmetry_posy)-$tile_height-$csy} fi
       rm.
      else
       $tile_width,$tile_height,1,{s#0} j[0] [-1],$csx,$csy rm.
      fi
     fi
    fi
    current_csx=$csx current_csy=$csy
   fi

  fi

  if $b1" && "$x1>=0" && "$y1>=0" && "$x1<w#1" && "$y1<h#1
   cutcopymode=0
   start=1
   optinsert=1
   select_from_tileset=1
   erasemode=0
   tsx={min(floor($x1/$__min_tile)*$__min_tile,$tsw-($icx*$__min_tile))} tsy={min(floor($y1/$__min_tile)*$__min_tile,$tsh-($icy*$__min_tile))}
   pass2tile. [$ni],$tsx,$tsy
   +out2display. , w2[-1] rm.

   if $tileset_gridmode
    +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol,$gridcol
   else
    +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol
   fi
   w1[-1] rm.

   wait 50
  fi

  if $temp_tileset_gridmode
   if $select_from_tileset
    if $tileset_gridmode
     +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol,$gridcol
    else
     +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol
    fi
    w1[-1] rm.
   else
    if $tileset_gridmode
     +out2display[$ni] 0,0,0,1,1,,$gridcol
    else
     +out2display[$ni] 0,0,0,1,1
    fi
    w1[-1] rm.
   fi
   temp_tileset_gridmode=0
  fi

  if !$start
   if $canvas_gridmode
    +out2display[0] $canvas_background,0,0,1,1,,$gridcol
   else
    +out2display[0] $canvas_background
   fi
   if $symmetrymode addsym2display. $symmetryaxis,$__min_tile,$symmetry_posx,$symmetry_posy fi
   w[-1] rm.
  else
   if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
    cx={min(floor($x/$__min_tile)*$__min_tile,($iscl-$icx)*$__min_tile)} cy={min(floor($y/$__min_tile)*$__min_tile,($isrl-$icy)*$__min_tile)}
    canvas_set=$canvas_background,$cx,$cy,$tile_width,$tile_height
    canvas_set.=$canvas_endset
    if $symmetrymode
     if $canvas_gridmode canvas_set.=$symmetryaxis,$symmetry_posx,$symmetry_posy
     else canvas_set.=,$symmetryaxis,$symmetry_posx,$symmetry_posy
     fi
    fi
    +out2display[0] $canvas_set
    if $symmetrymode addsym2display. $symmetryaxis,$__min_tile,$symmetry_posx,$symmetry_posy fi
    w[-1]
    rm.
   else
    if $canvas_gridmode
     +out2display[0] $canvas_background,0,0,1,1,,$gridcol
    else
     +out2display[0] $canvas_background
    fi
    if $symmetrymode addsym2display. $symmetryaxis,$__min_tile,$symmetry_posx,$symmetry_posy fi
    w[-1] rm.
   fi
  fi

  if $start
   if $erasemode main_w_title.=" (Eraser Mode) - "
   else
    if $cutcopymode
     if $cutcopymode==2 main_w_title.=" (Copy Mode) - "
     else main_w_title.=" (Cut Mode) - "
     fi
    else
     if $replacemode main_w_title.=" (Replacement Mode) - "
     else
      if $tile_placement_mode main_w_title.=" (Place Tile [Background]) - "
      else main_w_title.=" (Place Tile [Foreground]) - "
      fi
     fi
    fi
   fi

   if !$symmetrymode
    if $__fill_boundary==0 main_w_title.=" Fill Boundary [Periodic] - "
    elif $__fill_boundary==1 main_w_title.=" Fill Boundary [Mirror] - "
    elif $__fill_boundary==2 main_w_title.=" Fill Boundary [Mirror X] - "
    elif $__fill_boundary==3 main_w_title.=" Fill Boundary [Mirror Y] - "
    fi
   fi

   if $canvas_tracker main_w_title.="(Tracker)" fi
   if $canvas_gridmode main_w_title.="(Grid)" fi
   if $symmetrymode
    if $symmetryaxis==0
     if $symmetrybound main_w_title.="(Symmetry-X (Mirror))"
     else main_w_title.="(Symmetry-X (Periodic))"
     fi
    elif $symmetryaxis==1
     if $symmetrybound main_w_title.="(Symmetry-Y (Mirror))"
     else main_w_title.="(Symmetry-Y (Periodic))"
     fi
    elif $symmetryaxis==2
     if $symmetrybound main_w_title.="(Symmetry-XY (Corner) (Mirror))"
     else main_w_title.="(Symmetry-XY (Corner)(Periodic))"
     fi
    else
     if $symmetrybound main_w_title.="(Symmetry-XY (Reflected) (Mirror))"
     else main_w_title.="(Symmetry-XY (Reflected) (Periodic))"
     fi
    fi
   fi
  fi
  w[] -1,-1,-1,-1,$main_w_title
 fi
 wait 100
while {*}" && "!{*,ESC}
uncommand xalp,xalpa,out2display,pass2tile,tile2canvas,tile2canvas_r,tile2canvas_sym,tile2canvas_r_sym,fill_tiles2canvas,addsym2display,filter_to_selected_row_column,out2display_alt,out2display_alt_perp,keeperase_rowcolumn,shift_rowcolumn,place_rowcolumn
w1[] 0
w2[] 0
k[0]
if $7 $obg rv blend alpha fi
#@cli rep_trsa: eq. to 'rep_technorobbo_strange_attractor'
rep_trsa: rep_technorobbo_strange_attractor $*
#@cli rep_technorobbo_strange_attractor: _algorithm,_density,_scalefactor,_attractor_var_1,_attractor_var_2,_attractor_var_3,_attractor_var_4,_attractor_var_5,_attractor_var_6,_attractor_var_7,_attractor_var_8,_attractor_var_9
#@cli : Generates Attractor Fractal with equations provided by TechnoRobbo.
#@cli : (eq. to 'rep_trsa').\n
#@cli : Default values: '_density=7','_scalefactor=1','_attractor_var_1=u(0,1)','_attractor_var_2=u(0,1)','_attractor_var_3=u(0,1)','_attractor_var_4=u(0,1)','_attractor_var_5=u(0,1)','_attractor_var_6=u(0,1)','_attractor_var_7=u(0,1)','_attractor_var_8=u(0,1)','_attractor_var_9=u(0,1)'
rep_technorobbo_strange_attractor:
skip ${2=7},${3=1},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=0}

if same('$_host','cli') if narg($*)>12 error narg(\$"13")<13==F fi fi

max_width=${-max_w}
max_height=${-max_h}
if $!>1 $max_width,$max_height,1,1 else channels 0 f 0 fi

cv_0={narg($4)?$4:u(0,1)}
cv_1={narg($5)?$5:u(0,1)}
cv_2={narg($6)?$6:u(0,1)}
cv_3={narg($7)?$7:u(0,1)}
cv_4={narg($8)?$8:u(0,1)}
cv_5={narg($9)?$9:u(0,1)}
cv_6={narg($10)?$10:u(0,1)}
cv_7={narg($11)?$11:u(0,1)}
cv_8={narg($12)?$12:u(0,1)}

1,1,1,1

eval ${-math_lib}"
interpolate(a,b)=a*-b+(1-a)*b;
eucl_norm(a,b)=sqrt(a^2+b^2);

const use_run=$13;

const mw=w#-2;
const mh=h#-2;
const cenx=mw/2;
const ceny=mh/2;
const cenf=(eucl_norm(cenx,ceny)/2.5)*$3;

xc=yc=zc=0;

const cv_0=$cv_0;
const cv_1=$cv_1;
const cv_2=$cv_2;
const cv_3=$cv_3;
const cv_4=$cv_4;
const cv_5=$cv_5;
const cv_6=$cv_6;
const cv_7=$cv_7;
const cv_8=$cv_8;

if($1<=4,
 const a=interpolate(cv_0,3);
 const b=interpolate(cv_1,3);

 if($1!=3&&$1<4,
  const c=interpolate(cv_2,3);
  const d=interpolate(cv_3,3);
 ,
  const c=interpolate(cv_2,3);
  const d=interpolate(cv_3,3);
  const e=interpolate(cv_4,3);
  const f=interpolate(cv_5,3);
 );

 if($1<2,xc=-.5;yc=-.5;,
 if($1==2,xc=-1;
 );
 );
,
 if($1==5,
  const a=interpolate(cv_0,2);
  const b=interpolate(cv_1,2);
  const c=interpolate(cv_2,2);
  const d=interpolate(cv_3,2);
  const e=interpolate(cv_4,2);
  const f=interpolate(cv_5,2);
  const l=interpolate(cv_6,2);
  const h=interpolate(cv_7,2);
  const j=interpolate(cv_8,2);
  ,
  const a=interpolate(cv_0,3);
  const b=interpolate(cv_1,3);
  const c=interpolate(cv_2,3);
  const d=interpolate(cv_3,3);
  const e=interpolate(cv_4,3);
  const f=interpolate(cv_5,3);
 );
);

if($1==0,
 xnf(cx,cy)=sin(cy*b)+c*sin(b*cx);
 ynf(cx,cy)=sin(a*cx)+d*sin(a*cy);,
if($1==1,
 xnf(cx,cy)=sin(cy*a)+cos(c*cx);
 ynf(cx,cy)=sin(c*cx)-cos(d*cy);,
if($1==2,
 xnf(cx,cy)=abs(sin(cy*a)^3)+cos(c*cx);
 ynf(cx,cy)=abs(sin(c*cx)^2)-cos(d*cy)^2;,
if($1==3,
 xnf(cx,cy)=sin(cy*a)+cos(a*cx);
 ynf(cx,cy)=sin(b*cx)-cos(b*cy);,
if($1==4,
 xnf_3d(cx,cy,cz)=cy*sin(a*cx)+sin(b*cy);
 ynf_3d(cx,cy,cz)=cz*cos(c*cy)-cos(d*cz);
 znf_3d(cx,cy,cz)=cx*sin(e*cz)+cos(f*cx);,
if($1==5,
 xnf_3d(cx,cy,cz)=cy*sin(a*cx)+cos(b*cy)+sin(c*cz);
 ynf_3d(cx,cy,cz)=cz*sin(d*cx)+cos(e*cy)+sin(f*cz);
 znf_3d(cx,cy,cz)=cx*sin(l*cx)+cos(h*cy)+sin(j*cz);,
#if[$1==6,#
 xnf_3d(cx,cy,cz)=cz*sin(a*cx)+cos(b*cy);
 ynf_3d(cx,cy,cz)=cx*sin(c*cy)+cos(d*cz);
 znf_3d(cx,cy,cz)=cy*sin(e*cz)+cos(f*cx);
);
);
);
);
);
);

const td=abs($2)*10^6;
pixcount=0;

if($1<4,
 repeat(td,n,
  xn=xnf(xc,yc);
  yn=ynf(xc,yc);
  xc=xn;
  yc=yn;
  nx=xn*cenf*.75;
  ny=yn*cenf*.75;
  fnx=nx>=0?nx:mw+nx;
  fny=ny>=0?ny:mh+ny;
  if(!i(#-2,fnx,fny),++pixcount;);
  i(#-2,fnx,fny)+=1;
  if(use_run,if(!(n%200000),run('progress ',100*(n/td))););
 );
,
 repeat(td,n,
  xn=xnf_3d(xc,yc,zc);
  yn=ynf_3d(xc,yc,zc);
  zn=znf_3d(xc,yc,zc);
  xc=xn;
  yc=yn;
  zc=zn;
  nx=xn*cenf*1;
  ny=yn*cenf*1;
  fnx=nx>=0?nx:mw+nx;
  fny=ny>=0?ny:mh+ny;
  if(!i(#-2,fnx,fny),++pixcount;);
  i(#-2,fnx,fny)+=1;
  if(use_run,if(!(n%200000),run('progress ',100*(n/td))););
 );
);

pixcount;
"
shift.. 50%,50%,0,0,2 rm.
#@cli rep_tg3: eq. to 'rep_trigonometry_three_channel_gradient'
rep_tg3: rep_trigonometry_three_channel_gradient $*
#@cli rep_trigonometry_three_channel_gradient: _resolution,_chan_order={ 0=0,1,2 | 1=0,2,1 | 2=1,0,2 | 3=1,2,0 | 4=2,0,1 | 5=2,1,0 },_chan_form_a={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier_a>0,_valueshift_a,0>=_midgray_expf_a>=1,_lightness_merge_factor_a>=1,_lightness_end_expf_a>0,0>=_gray2col_end_a>=1,_chan_form_b={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier_b>0,_valueshift_b,0>=_midgray_expf_b>=1,_lightness_merge_factor_b>=1,_lightness_end_expf_b>0,0>=_gray2col_end_b>=1,_chan_form_c={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier_c>0,_valueshift_c,0>=_midgray_expf_c>=1,_lightness_merge_factor_c>=1,_lightness_end_expf_c>0,0>=_gray2col_end_c>=1
#@cli : Creates trigonometry gradients or map images with trigonometry coloring.
#@cli : (eq. to 'rep_tg3').\n
#@cli : '_resolution' defines the length of gradient or the way it is going to be mapped. See below for more information on _resolution.
#@cli : '_chan_order' defines the order of channel of gradient
#@cli : '_chan_form' refers to the formula each channels use
#@cli : '_multiplier' defines the multiplication of base gradient used to map formula based on trigonometry.
#@cli : '_valueshift' refers to the value shift of base gradient
#@cli : '_midgray_expf' refers to the middle-point of base gradient used to map formula based on trigonometry relative to middle.
#@cli : '_lightness_merge_factor' refers to the merging of lightness gradient with color gradient. Used to add white and black to gradient ends.
#@cli : '_lightness_end_expf' defines the magnitude of shades and tind of each end of end gradient
#@cli : '_gray2col_end' defines how much the end gradient overrides the base gradient\n
#@cli : '_resolution' values and processing info
#@cli : -----
#@cli : Info #1: If '_resolution' is a number: If _resolution is negative, create a 3-channel trigonometry vertical gradient, else create 3-channel trigonometry horizontal gradient.
#@cli : Info #2: If '_resolution' is "8i", then map trigonometry function by first dividing by 255, then perform trigonometry function, finally multiply by 255.
#@cli : Info #3: If '_resolution' is "8il", then image will be converted into RGBA luminosity format, then perform trigonometry function, finally multiply by 255.
#@cli : Info #4: If '_resolution' is empty, then directly map trigonometry function.
#@cli : -----\n
#@cli : Default values: 'resolution=256','_chan_order=0','_chan_form_a=0','_multiplier_a=1','_valueshift_a=0','_midgray_expf_a=1','_lightness_merge_factor_a=1','_lightness_end_expf_a=0','_gray2col_end_a=1','_chan_form_b=_chan_form_a','_multiplier_b=_multiplier_a','_valueshift_b=_valueshift_a','_midgray_expf_b=_midgray_expf_a','_lightness_merge_factor_b=_lightness_merge_factor_a','_lightness_end_expf_b=_lightness_end_expf_a','_gray2col_end_b=_gray2col_end_a','_chan_form_c=_chan_form_b','_multiplier_c=_multiplier_b','_valueshift_c=_valueshift_b','_midgray_expf_c=_midgray_expf_b','_lightness_merge_factor_c=_lightness_merge_factor_b','_lightness_end_expf_c=_lightness_end_expf_b','_gray2col_end_c=_gray2col_end_b'\n
#@cli : Author: Reptorian.
rep_trigonometry_three_channel_gradient:
echo "Map trigonometry function within image"("s")""
skip ${1=},${2=0},${3=},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=},${16=},${17=},${18=},${19=},${20=},${21=},${22=},${23=}

v + e "\nMap trigonometry function within image"("s")"" v -

if narg($3) channel_formula_a=$3    else channel_formula_a=0    fi
if narg($4) multiplier_a=$4      else multiplier_a=1      fi
if narg($5) valueshift_a=$5      else valueshift_a=0      fi
if narg($6) midgray_expf_a=$6    else midgray_expf_a=1    fi
if narg($7) lightness_merge_factor_a=$7   else lightness_merge_factor_a=1   fi
if narg($8) lightness_end_expf_a=$8    else lightness_end_expf_a=0    fi
if narg($9) gray2col_end_a=$9    else gray2col_end_a=1    fi

if narg($10) channel_formula_b=$10  else channel_formula_b=$channel_formula_a     fi
if narg($11) multiplier_b=$11    else multiplier_b=$multiplier_a         fi
if narg($12) valueshift_b=$12    else valueshift_b=$valueshift_a         fi
if narg($13) midgray_expf_b=$13     else midgray_expf_b=$midgray_expf_a        fi
if narg($14) lightness_merge_factor_b=$14 else lightness_merge_factor_b=$lightness_merge_factor_a   fi
if narg($15) lightness_end_expf_b=$15  else lightness_end_expf_b=$lightness_end_expf_a     fi
if narg($16) gray2col_end_b=$16     else gray2col_end_b=$gray2col_end_a        fi

if narg($17) channel_formula_c=$17  else channel_formula_c=$channel_formula_b     fi
if narg($18) multiplier_c=$18    else multiplier_c=$multiplier_b         fi
if narg($19) valueshift_c=$19    else valueshift_c=$valueshift_b         fi
if narg($20) midgray_expf_c=$20     else midgray_expf_c=$midgray_expf_b        fi
if narg($21) lightness_merge_factor_c=$21 else lightness_merge_factor_c=$lightness_merge_factor_b   fi
if narg($22) lightness_end_expf_c=$22  else lightness_end_expf_c=$lightness_end_expf_b     fi
if narg($23) gray2col_end_c=$23     else gray2col_end_c=$gray2col_end_b        fi

channel_formula=[$channel_formula_a,$channel_formula_b,$channel_formula_c]
multiplier=[$multiplier_a,$multiplier_b,$multiplier_c]
valueshift=[$valueshift_a,$valueshift_b,$valueshift_c]
midgray_expf=[$midgray_expf_a,$midgray_expf_b,$midgray_expf_c]
lightness_merge_factor=[$lightness_merge_factor_a,$lightness_merge_factor_b,$lightness_merge_factor_c]
lightness_end_expf=[$lightness_end_expf_a,$lightness_end_expf_b,$lightness_end_expf_c]
gray2col_end=[$gray2col_end_a,$gray2col_end_b,$gray2col_end_c]

channel_order=${arg0\ $2,\"[0,1,2]\",\"[0,2,1]\",\"[1,0,2]\",\"[1,2,0]\",\"[2,0,1]\",\"[2,1,0]\"}

repeat $! {
	img_id=$>
	if s#$img_id<3||s#$img_id>4 error s#$img_id>2&&s#$img_id<4==F fi
}

if isnum($1)
	if $1>0   $1,1,1,3,"begin(ww=w-1;);x/ww"
	elif $1<0 1,abs($1),1,3,"begin(hh=h-1;);y/hh"
	else error _$1!=0==F
	fi

	repeat 3 {
		sh. {($channel_order)[$>]}
		rep_trigmap. ,{($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
		rm.
	}
else
	if narg($1)
		if same('$1','8i')

			foreach {
				repeat 3 {
					sh. {($channel_order)[$>]}
					rep_trigmap_8i. {($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
					rm.
				}
			}

		elif same('$1','8il')

			foreach {

				if s==3 to_gray to_rgb
				else to_graya to_rgba
				fi

				repeat 3 {
					sh. {($channel_order)[$>]}
					rep_trigmap_8i. {($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
					rm.
				}

			}

		else error ""(""$"1==8i")"||"(""$"1==8il")"==F"
		fi

	else

		foreach {

			repeat 3 {
				sh. {($channel_order)[$>]}
				rep_trigmap. ,{($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
				rm.
			}

		}

	fi
fi
#@cli rep_trigmap: eq. to 'rep_trigonometry_map'
rep_trigmap: rep_trigonometry_map $*
#@cli rep_trigonometry_map: _image_value_divide,_chan_form={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier>0,_valueshift,0>=_midgray_expf>=1,_lightness_merge_factor>=1,_lightness_end_expf>0,0>=_gray2col_end>=1
#@cli : Map trigonometry function into image.
#@cli :
#@cli : (eq. to 'rep_trigmap').
#@cli :
#@cli : '_image_value_divide' defines how much the image should be divided by. Of course, 0 is not valid.
#@cli : '_chan_form' refers to the formula each channels use. Number higher than 4 will use a slight different formula, but still follow the pattern of formulas named above.
#@cli : '_multiplier' defines the multiplication of base gradient used to map formula based on trigonometry.
#@cli : '_valueshift' refers to the value shift of base gradient
#@cli : '_midgray_expf' refers to the middle-point of base gradient used to map formula based on trigonometry relative to middle.
#@cli : '_lightness_merge_factor' refers to the merging of lightness gradient with color gradient. Used to add white and black to gradient ends.
#@cli : '_lightness_end_expf' defines the magnitude of shades and tind of each end of end gradient
#@cli : '_gray2col_end' defines how much the end gradient overrides the base gradient
#@cli :
#@cli : Note: Add 5 or 10 to '_chan_form' for another variation of the specified formula.
#@cli : Default values: '_image_value_divide=1','_multiplier_mode=1','_valueshift=0','_midgray_expf=1','_lightness_merge_factor=1','_lightness_end_expf=0','_gray2col_end=1'\n
#@cli : Author: Reptorian.
rep_trigonometry_map:
skip ${1=1},${2=0},${3=1},${4=0},${5=1},${6=1},${7=0},${8=1}
if $1==0 error ""$"1!=0==f" fi
f "begin(
		const trigmode=$2%15;
		trigmode==0? chan_form(a)=(sin(a*pi)+1)/2:
		trigmode==1? chan_form(a)=(cos(a*pi)+1)/2:
		trigmode==2? chan_form(a)=(sin(a*pi+pi)^3+1)/2:
		trigmode==3? chan_form(a)=(cos(a*pi+pi)^3+1)/2:
		trigmode==4? chan_form(a)=((cos(a*pi+pi/2)*sin(a*pi+pi/2))^3+.125)*4:
		trigmode==5? chan_form(a)=(sin(a*pi+pi/2)+1)/2:
		trigmode==6? chan_form(a)=(cos(a*pi+pi/2)+1)/2:
		trigmode==7? chan_form(a)=(sin(a*pi+pi/2)^3+1)/2:
		trigmode==8? chan_form(a)=(cos(a*pi+pi/2)^3+1)/2:
		trigmode==9? chan_form(a)=((cos(a*pi+pi/4)*sin(a*pi+pi/4))^3+.125)*4:
		trigmode==10?chan_form(a)=(sin(a*pi+pi)+1)/2:
		trigmode==11?chan_form(a)=(cos(a*pi+pi)+1)/2:
		trigmode==12?chan_form(a)=(sin(a*pi)^3+1)/2:
		trigmode==13?chan_form(a)=(cos(a*pi)^3+1)/2:
		trigmode==14?chan_form(a)=((cos(a*pi)*sin(a*pi))^3+.125)*4;
	);
	slope=i/$1;
	midslope=(max(1-slope,slope)-.5)*2;
	col_chan_zero=chan_form($3*(slope^$5+$4));
	mul_chan_zero=lerp(col_chan_zero,lerp(slope*col_chan_zero,slope,midslope^(abs($7+1))),midslope^(abs($7+1))*$6);
	lerp(slope,mul_chan_zero,$8)*$1;"
#@cli rep_trigmap_8i: eq. to 'rep_trigonometry_map_8bit_integer'
rep_trigmap_8i: rep_trigonometry_map 255,${1-7}
#@cli rep_trigonometry_map_8bit_integer: _level_formula={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier>0,_valueshift,0>=_midgray_expf>=1,_lightness_merge_factor>=1,_lightness_end_expf>0,0>=_gray2col_end>=1
#@cli : Map trigonometry function using 8-bit values. Remove _8i for non-8 bit values.
#@cli : (eq. to rep_trigmap_8i).\n
#@cli : Note: Add 5 or 10 to '_level_formula' for another variation of the specified formula.
#@cli : Default values: '_multiplier_a=1','_valueshift_a=0','_midgray_expf_a=1','_lightness_merge_factor_a=1','_lightness_end_expf_a=0','_gray2col_end_a=1'
rep_trigonometry_map_8bit_integer: rep_trigonometry_map 255,${1-7}
#@cli rep_lerp_rgb_gray: eq. to rep_linear_interpolation_rgb_gray
rep_lerp_rgb_gray: rep_linear_interpolation_rgb_gray $*
#@cli rep_linear_interpolation_rgb_gray: 0%>=_red_factor(%)<=100%,0%>=_green_factor(%)<=100%,0%>=_blue_factor(%)<=100%,_gray_mode={ 0=luminosity | 1=luminosity_alternative | 2=lightness | 3=minimum_channel | 4=maximum_channel | 5=average } : 0%>=_red_factor(%)<=100%,0%>=_green_factor(%)<=100%,0%>=_blue_factor(%)<=100%,_red_weight,green_weight,blue_weight\n
#@cli : Author: Reptorian.
rep_linear_interpolation_rgb_gray:
skip ${4=0},${5=},${6=}

total_arg=0

if isnum($1) total_arg+=1 fi
if isnum($2) total_arg+=1 fi
if isnum($3) total_arg+=1 fi
if isnum($4) total_arg+=1 fi
if isnum($5) total_arg+=1 fi
if isnum($6) total_arg+=1 fi
if $total_arg==5 error "valid_args!=5=F" fi

if abs($1)>2 error "|"$"1|<=2=F" fi
if abs($2)>2 error "|"$"2|<=2=F" fi
if abs($3)>2 error "|"$"3|<=2=F" fi

f "begin(
		const rlvl=abs($1);
		const glvl=abs($2);
		const blvl=abs($3);

		if(narg($*)>5,
			const tw=abs($4)+abs($5)+abs($6);
			const c1f=abs($4)/tw;
			const c2f=abs($5)/tw;
			const c3f=abs($6)/tw;
			graymode(a,b,c)=a*c1f+b*c2f+c*c3f;
		,
			$4==0?graymode(a,b,c)=a*0.22248840+b*0.71690369+c*0.06060791:
			$4==1?graymode(a,b,c)=a*0.2990+b*0.5870+c*0.1140:
			$4==2?graymode(a,b,c)=(max(a,b,c)+min(a,b,c))/2:
			$4==3?graymode(a,b,c)=min(a,b,c):
			$4==4?graymode(a,b,c)=max(a,b,c):
			      graymode(a,b,c)=avg(a,b,c);
		);
	);
	gl=graymode(i0,i1,i2);
	[lerp(gl,i0,rlvl),lerp(gl,i1,glvl),lerp(gl,i2,blvl)];"
#@cli rgb2ohta8
#@cli : Convert color representation of selected images from RGB to Ohta8.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg rgb2ohta split c
rgb2ohta8:
e[^-1] "Convert color representation of image$? from RGB to Ohta8."
f [avg(i0,i1,i2),(i0-i2+255)/2,(-i0+i1-i2+255)/3]
#@cli ohta82rgb
#@cli : Convert color representation of selected images from Ohta8 to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg ohta82rgb split c
ohta82rgb:
e[^-1] "Convert color representation of image$? from Ohta8 to RGB."
f c0=i0*3;c1=i1*2-255;c2=i2*3-255;[.25*c0+.5*c1-.25*c2,.5*c0+.5*c2,.25*c0-.5*c1-.25*c2]
#@cli rgb2ohta
#@cli : Convert color representation of selected images from RGB to Ohta.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg rgb2ohta split c
rgb2ohta:
e[^-1] "Convert color representation of image$? from RGB to Ohta."
f [i0+i1+i2,i0-i2,-i0+i1-i2]
#@cli ohta2rgb
#@cli : Convert color representation of selected images from Ohta to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg ohta2rgb split c
ohta2rgb:
e[^-1] "Convert color representation of image$? from Ohta to RGB."
f [.25*i0+.5*i1-.25*i2,.5*i0+.5*i2,.25*i0-.5*i1-.25*i2]
#@cli rgb2ydbdr
#@cli : Convert color representation of selected images from RGB to YDbDr.
#@cli : Source: https://hbfs.wordpress.com/2018/05/15/ydbdr-colorspaces-vi/#more-6355
#@cli : $ image.jpg rgb2ydbdr split c
rgb2ydbdr:
e[^-1] "Convert color representation of image$? from RGB to YDbDr."
f [.299*i0+.587*i1+.114*i2,-.45*i0-.883*i1+1.333*i2,1.333*i0-1.109*i1-.217*i2]
#@cli rgb2ydbdr
#@cli : Convert color representation of selected images from YDbDr to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/05/15/ydbdr-colorspaces-vi/#more-6355
#@cli : $ image.jpg rgb2ydbdr split c
ydbdr2rgb:
e[^-1] "Convert color representation of image$? from YDbDr to RGB."
f [1*i0+.525*i2,1*i0-.129*i1-.268*i2,1*i0+.665*i1]
#@cli rgb2k1
#@cli : Convert color representation of selected images from RGB to Kodak 1.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg rgb2k1 split c
rgb2k1:
e[^-1] "Convert color representation of image$? from RGB to Kodak 1."
f begin(third=1/3;);r=third*i0;g=third*i1;b=third*i2;[r+g+b,b-r-g,r-g-b]
#@cli k12rgb
#@cli : Convert color representation of selected images from Kodak 1 to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg k12rgb split c
k12rgb:
e[^-1] "Convert color representation of image$? from Kodak 1 to RGB."
f [1.5*i0+1.5*i2,-1.5*i1-1.5*i2,1.5*i0+1.5*i1];
#@cli rgb2k18
#@cli : Convert color representation of selected images from RGB to Kodak 1 in 8I.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg rgb2k18 split c
rgb2k18:
e[^-1] "Convert color representation of image$? from RGB to Kodak 1 - 8I."
f begin(third=1/3;);r=third*i0;g=third*i1;b=third*i2;[r+g+b,(b-r-g)+170,(r-g-b)+170]
#@cli k182rgb
#@cli : Convert color representation of selected images from Kodak 1 in 8I to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg k182rgb split c
k182rgb:
e[^-1] "Convert color representation of image$? from Kodak 1 - 8I to RGB."
f c1=i1-170;c2=i2-170;[1.5*i0+1.5*c2,-1.5*c1-1.5*c2,1.5*i0+1.5*c1];
#@cli rgb2yes
#@cli : Convert color representation of selected images from RGB to YES.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg rgb2yes split c
rgb2yes:
e[^-1] "Convert color representation of image$? from RGB to YES."
f [.253*i0+.684*i1+.063*i2,.5*i0-.5*i1,.25*i0+.25*i1-.5*i2]
#@cli yes2rgb
#@cli : Convert color representation of selected images from RGB to YES.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg yes2rgb split c
yes2rgb:
e[^-1] "Convert color representation of image$? from YES to RGB."
f [i0+1.431*i1+.126*i2,i0-.569*i1+.126*i2,i0+.431*i1-1.874*i2]
#@cli rgb2yes8
#@cli : Convert color representation of selected images from RGB to Yes8.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg rgb2yes8 split c
rgb2yes8:
e[^-1] "Convert color representation of image$? from RGB to Yes8."
f [.253*i0+.684*i1+.063*i2,(.5*i0-.5*i1)+127.5,(.25*i0+.25*i1-.5*i2)+127.5]
#@cli yes82rgb
#@cli : Convert color representation of selected images from Yes8 to RGB.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg yes82rgb split c
yes82rgb:
e[^-1] "Convert color representation of image$? from Yes8 to RGB."
f [i0+1.431*(i1-127.5)+.126*(i2-127.5),i0-.569*(i1-127.5)+.126*(i2-127.5),i0+.431*(i1-127.5)-1.874*(i2-127.5)]
#@cli rgb2ycocgr:
#@cli : Convert color representation of selected images from RGB to YCoCg-R.
#@cli : Source: https://en.wikipedia.org/wiki/YCoCg
#@cli : $ image.jpg rgb2ohta split c
rgb2ycocgr:
e[^-1] "Convert color representation of image$? from RGB to YCoCg-R."
f "
Co=i0-i2;
tmp=B+Co/2;
Cg=i1-tmp;
Y=tmp+Cg/2;
[Y,Co,Cg];
"
#@cli ycocgr2rgb:
#@cli : Convert color representation of selected images from YCoCg-R to RGB.
#@cli : Source: https://en.wikipedia.org/wiki/YCoCg
#@cli : $ image.jpg rgb2ohta split c
ycocgr2rgb:
e[^-1] "Convert color representation of image$? from YCoCg-R To RGB."
f "
tmp=i0-i2/2;
G=i2+tmp;
B=tmp-i1/2;
[B+i1,G,B];
"
#@cli rgb2ycocg:
#@cli : Convert color representation of selected images from RGB to YCoCg.
#@cli : Source: https://en.wikipedia.org/wiki/YCoCg
#@cli : $ image.jpg rgb2ohta split c
rgb2ycocg:
e[^-1] "Convert color representation of image$? from RGB to YCoCg."
f [i0/4+i1/2+i2/4,i0/2-i2/2,-i0/4+i1/2-i2/4]
#@cli ycocg2rgb:
#@cli : Convert color representation of selected images from YCoCg to RGB.
#@cli : Source: https://en.wikipedia.org/wiki/YCoCg
#@cli : $ image.jpg rgb2ohta split c
ycocg2rgb:
e[^-1] "Convert color representation of image$? from YCoCg To RGB."
f [i0+i1-i2,i0+i2,i0-i1-i2]
#@cli rep_rbtt: eq. to 'rep_rotate_by_torus_top'
rep_rbtt: rep_rotate_by_torus_top $*
#@cli rep_rotate_by_torus_top: 0<=_torus_circu_min_dimension_percent_1(%)<=100,0<=_torus_circu_min_dimension_percent_2(%)<=100,_distort_ang,_mode_1={ 0=softmode | 1=midmode | 2=hardmode | 3=hardmode_alt | 4=distroymode | 5=invdistroymode | 6=quadextrudemode | 7=hexextrudemode },_mode_2={ 0=softmode | 1=midmode | 2=hardmode | 3=hardmode_alt | 4=distroymode | 5=invdistroymode | 6=quadextrudemode | 7=hexextrudemode },0<=_mode_percent_comb(%)<=100,_offx(%),_offy(%),_off_dup={ 0=no_duplicate_dist | 1=duplicate_dist },_bgremove={ 0=keep_background | 1=remove_background },_cent_isolat_torus_mode={ 0=do_not_center | 1=center },_interpolation={ 0=nearest | 1=linear },_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror }
#@cli : Inspired by the Donut Distortion plugin made by MadJik for Paint.NET, this version of donut distortion adds new features such as more modes, mode blending, isolated torus mode.
#@cli : (eq. to 'rep_rbtt')\n
#@cli : _torus_circu_min_dimension_percent_1 refers to the primary circumference of circle relative to the minimum image dimension.
#@cli : _torus_circu_min_dimension_percent_2 refers to the secondary circumference of circle relative to the minimum image dimension.
#@cli : _distort_ang refers to the maximum angle of distortion.
#@cli : _mode_1 refers to the first mode of donut distortion.
#@cli : _mode_1 refers to the second mode of donut distortion.
#@cli : _mode_percent_comb refers to the weighed average of combination of modes. This only works if and only if _mode_1 and _mode_2 are specified!
#@cli : _offx refers to the offset of donut distortion relative to the center in -1,1 x-coordinates. 100% means the center will be located in 1.
#@cli : _offy refers to the offset of donut distortion relative to the center in -1,1 y-coordinates. 100% means the center will be located in 1.
#@cli : _off_dup option defines whether distortion will wrap around when it reach out of bound.
#@cli : _bgremove defines whether the background is removed.
#@cli : _cent_isolat_torus_mode is a special mode used to aid into creating torus from image. This only works if _bgremove is active.
#@cli : _interpolation defines the smoothness of the image.
#@cli : _boundary defines how out-of-range values are wrapped as.
#@cli : Default values: '_torus_circu_min_dimension_percent_1=1','_torus_circu_min_dimension_percent_2=.5','_distort_ang=45','_mode_1=0','_mode_2=','_mode_percent_comb=50%','_offx=0%','_offy=0%','_off_dup=1','_bgremove=0','_cent_isolat_torus_mode=0','_interpolation=1','_boundary=2'
rep_rotate_by_torus_top:
skip ${1=1},${2=0},${3=45},${4=0},${5=},${6=.5},${7=0},${8=0},${9=1},${10=1},${11=0}${12=1},${13=2}

if $1==$2 error ""$"1!="$"2=F" fi
if ($1>1||$1<0)||($2>1||$2<0) error "(0>="$"1<=1)||(0>="$"2<=1)=F" fi
if $4<0||$4>7 error "0<="$"4<=7=F" fi
if narg($5) if $5<0||$5>7 error "0<="$"5<=7=F" fi fi
if $6<0||$6>1 error "0<="$"6<=1=f" fi

mode_1=${arg0\ $4,(cos(v*(2*pi)-pi)+1)/2,abs(cos(v*pi+pi/2)),sqrt(1-(abs(v-.5)*2)^2),(1-(abs(v-.5)*2)^2)^(1/(2+(1-v))),cos(v*pi)*boundary,(cos(v*pi)*-1)*boundary,1-abs(v-.5)*2,(r=(1-abs(v-.5)*2)*2;r>1?1:r)}

if narg($5)
	mode_2=${arg0\ $5,(cos(v*(2*pi)-pi)+1)/2,abs(cos(v*pi+pi/2)),sqrt(1-(abs(v-.5)*2)^2),(1-(abs(v-.5)*2)^2)^(1/(2+(1-v))),cos(v*pi)*boundary,(cos(v*pi)*-1)*boundary,1-abs(v-.5)*2,(r=(1-abs(v-.5)*2)*2;r>1?1:r)}
fi

include_alp_cut={$10&&(s==2||s>3)}

if $include_alp_cut
	vnull=[vectors(0)]
	outcolor=vnull
else outcolor=I
fi

if $12>0

	boundary=avg(bndcut(radial_gradient_v[0]),bndcut(radial_gradient_v[1]),bndcut(radial_gradient_v[2]),bndcut(radial_gradient_v[3]))

	calc_antialias=ox=sur_x(start_x(x+.5));oy=sur_y(start_y(y+.5));radial_gradient_v=[nm(norm(xx,yy)),nm(norm(ox,yy)),nm(norm(xx,oy)),nm(norm(ox,oy))];

else
	boundary=bndcut(radial_gradient)
fi

f "
begin(
	boundary=0;

	const s_id=s-1;

	const sd=max(w,h)/min(w,h);
	const sx=w>h?sd:1;
	const sy=w>h?1:sd;

	const ww=w-1;
	const hh=h-1;
	const cx=ww/2;
	const cy=hh/2;
	const offx=cx*$7*-1;
	const offy=cy*$8;
	const eps=10^-10;

	const interpolation=abs($12)?2:0;
	const outboundary=$13;

	vallim_x(v)=v-ww*floor(v/(ww+eps));
	vallim_y(v)=v-hh*floor(v/(hh+eps));

	if($9,
		start_x(v)=vallim_x(v+offx);
		start_y(v)=vallim_y(v+offy);
	,
		start_x(v)=v+offx;
		start_y(v)=v+offy;
	);

	const torus_val_1=$1;
	const torus_val_2=$2;
	const new_min=min(torus_val_1,torus_val_2);
	const new_max=max(torus_val_1,torus_val_2);
	const end_diff=(1/(new_max-new_min));
	nm(v)=(v-new_min)*end_diff;
	limcut(v)=max(min(1,v),0);
	bndcut(v)=v>1||v<0?0:1;

	const iang=$3*-1;
	ang2rad(v)=pi*(v/180);
	const maxang=ang2rad(iang);
	rot_x(a,b,c)=a*cos(c)-b*sin(c);
	rot_y(a,b,c)=a*sin(c)+b*cos(c);

	sur_x(v)=(v/ww-.5)*2*sx;
	sur_y(v)=(v/hh-.5)*2*sy;
	unsur_x(v)=(v/(2*sx)+.5)*ww;
	unsur_y(v)=(v/(2*sy)+.5)*hh;

	if(narg($5),

		if($6==0||$6==1
		,if($6,mode(v)="$mode_2";,mode(v)="$mode_1";);
		,mode(v)=lerp("$mode_1","$mode_2",$6);
		);
	,
		mode(v)="$mode_1";
	);

	if($include_alp_cut
		,out(a,b)=[vectors_id(J(a,b,z,interpolation,$13)),j(a,b,z,s_id,0,outboundary)*boundary];vnull="$vnull";
		,out(a,b)=lerp(I,J(a,b,z,interpolation,outboundary),boundary);
	);
);
nxx=start_x(x);
nyy=start_y(y);
xx=sur_x(nxx);
yy=sur_y(nyy);
"$calc_antialias"
radial_gradient=nm(norm(xx,yy));
norm_gradient=limcut(radial_gradient);
boundary="$boundary";
z_depth=mode(norm_gradient)*maxang;
XX=rot_x(xx,yy,z_depth);
YY=rot_y(xx,yy,z_depth);
XX=unsur_x(XX);
YY=unsur_y(YY);
diff_x=XX-nxx;
diff_y=YY-nyy;
out(diff_x,diff_y);"

if $11&&$10
	offx={($7/2)*100*-1}
	offy={($8/2)*100}

	foreach {
		if s==2||s>3
			shift $offx%,$offy%,0,0,2,0
		fi
	}
fi
#@cli rep_pxpush: eq. to 'rep_pixel_push'
rep_pxpush: rep_pixel_push $*
#@cli rep_pixel_push: -1<=_push_x<=1,-1<=_push_y<=1
#@cli : Pushes pixel relative to coordinate from the center. CLI filter is recreated from source code to TR's Pixel Push plugin for Paint.NET. Currently only Bezier option is supported until the secondary option is figured out.
#@cli : (eq. to 'rep_pxpush')\n
#@cli : Default values: '_push_x=0','_push_y=0'\n
#@cli : Author: Reptorian.
rep_pixel_push:
f "begin(
		const ww=w-1;
		const hh=h-1;
		cx=cut( ($1+1)/2 ,0,1);
		cy=cut( ($2+1)/2 ,0,1);
	);
	spanx=x/ww;
	spany=y/hh;
	nx=(1-((cx*(1-spanx))*spanx+(1-spanx)*(cx*spanx+(1-spanx))))*ww;
	ny=(1-((cy*(1-spany))*spany+(1-spany)*(cy*spany+(1-spany))))*hh;
	I(nx,ny,z,2);"
#@cli rep_pw: eq. to 'rep_point_warp'
rep_pw: rep_point_warp $*
#@cli rep_point_warp: 0%<=_pointwidth(%)<=100%,0%<=_distance(%)<=100%,0%,_radialInfluence<=100%,-1>=_distortion_center_x>=1,-1>=_distortion_center_y>=1,-360>=_distortion_angle>=360,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror }
#@cli : Distorts image around a point. If you're using large radius, radialInfluence is not recommended to be set to 100%.
#@cli : (eq. to 'rep_pw')\n
#@cli : Default values: '_pointwidth=10%','_distance=10%','_radialInfluence=0%','_distortion_center_x=0','_distortion_center_y=0','_distortion_angle=0','_boundary=3'
rep_point_warp:
skip ${1=10},${2=10},${3=0},${4=0},${5=0},${6=0},${7=3}
f "begin(
		eucl_norm(a,b)=sqrt(a^2+b^2);
		const scaled_img_diagonal=eucl_norm(w,h)*$2;
		const radius=log2((10^(abs($3)*300))*1000)*e;
		const lograd=log(radius^($1*(.25*min(w,h))));
		const hw=w/2;
		const hh=h/2;
		const angle=($6/180)*pi+pi;
		const ox=cos(angle)*scaled_img_diagonal;
		const oy=sin(angle)*scaled_img_diagonal;
		const dx=$4*hw;
		const dy=$5*hh;
	);
	xd=x-dx;
	yd=y+dy;
	radinf=radius^(-(((xd-hw)/lograd)^2+((yd-hh)/lograd)^2)^2);
	rx=(ox*radinf)+x;
	ry=(oy*radinf)+y;
	I(rx,ry,z,2,$7);"
#@cli rep_rand_sqrrecfill: eq. to 'rep_random_square_rectangle_fill'
rep_rand_sqrrecfill: rep_random_square_rectangle_fill $*
#@cli rep_random_square_rectangle_fill: _palette,square_dimension>0,_rectangle_max_length_1>0,_rectangle_max_length_2>0,_erode,_output={ 0=none | 1=line },_reduce_nonrectangles={ 0=do_not_reduce_nonrectagles | 1=reduce_nonrectangles },_remove_black_from_palette={ 0=preserve | 1=remove },_seed,_colourspace,
#@cli : Create texture with aligned rectangle and squares with colors being optional.
#@cli : (eq. to 'rep_rand_sqrrecfill')
#@cli : Default values: '_palette=0','_rectangle_length_2=1','_frequency_of_rectangle=1','_erode=0','_output=1','_reduce_nonrectangles=1','_remove_black_from_palette=1','_seed=','_colourspace=6',
#@cli : Author: Reptorian.
rep_random_square_rectangle_fill:
skip ${1=0},${3=2},${4=1},${5=1},${6=0},${7=1},${8=1},${9=1},${10=},${11=0}

cs2rgb=${arg0\ $11,,ryb2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb}

bool_state_pal=0
rand_pal=0

if narg($1)
	if isint($1)&&isnum($1)
		if $1>0||$1<0
			bool_state_pal=1
			text_mode=0
		fi
	else
		if narg($1)
			bool_state_pal=1
			text_mode=1
		fi
	fi
fi

rep_rand_sqrrectex ${2-6},{$bool_state_pal?(($1>0||$1<0)&&abs($7)?3:1):2},$8,$10

if $bool_state_pal
	if narg($10) srand $10 fi

	r. 100%,100%,100%,3

	if $text_mode
		+pal $1
	else

		if $1<0 {iM},1,1,3,u(0,255)
			if $11 $cs2rgb fi
			rand_pal=1
		else +pal $1
		fi

	fi

	if $9
		local[-1] {
			s x
			foreach { if !{ia} rm fi }
			a x
		}
	fi

	if !$rand_pal
			{w#-1},1,1,1,u(0,1)
			pixelsort.. +,x,.
			rm.
	fi

	if !$7 +.. 1 fi
	f.. i0?i(#-1,i0-1,y,0,c,0,2)
	rm.
fi
#@cli rep_rand_sqrrecart: eq. to 'rep_random_square_rectangle_texture'
rep_rand_sqrrecart: rep_random_square_rectangle_artistic $*
#@cli rep_random_square_rectangle_artistic: square_dimension>0,_rectangle_max_length_1>0,_rectangle_max_length_2>0,_frequency_of_rectangle>0,_erode,_output={ 0=none | 1=line },_reduce_nonrectangles={ 0=do_not_reduce_nonrectagles | 1=reduce_nonrectangles },_distance_mode={ 0=regular_output | 1=distance_output },_seed,_output_resized={ 0=do_not_output_resized_original | 1=output_resized },_colourspace
#@cli : Create artistic rendering of image with aligned rectangle and squares.
#@cli : (eq. to 'rep_rand_sqrrecart')
#@cli : Default values: '_rectangle_max_length_1=2','_rectangle_length_2=1','_frequency_of_rectangle=1','_erode=0','_output=2','_reduce_nonrectangles=0','_seed=','_output_resized=0',_colourspace=0'
#@cli : Author: Reptorian.
rep_random_square_rectangle_artistic:
skip ${2=2},${3=1},${4=1},${5=0},${6=1},${7=1},${8=0},${9=},${10=0},${11=0}
convert_back=0
tcr=3
different_dimension=0

converts_colors_fwd=${arg1\ $11,rgb2ryb,error,rgb2hcy,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch,rgb2ycbcr,rgb2ycbcrglic,rgb2yiq,rgb2yuv,rgb2xyz}

if $!>1

	cw={w#1}
	ch={h#1}
	iter=1

	do
		iter-=1
		if (w#$iter!=$cw)||(h#$iter!=$ch) different_dimension=1 fi
		iter+=2
		cw={w#$iter}
		ch={h#$iter}
	while !$different_dimension&&$iter<$!

fi

if $different_dimension
	foreach { rep_rand_sqrrectex ${1-5},{$6?2:1},$7,$9 }
else
	rep_rand_sqrrectex ${1-5},{$6?2:1},$7,$9
	rep_aspect_crop_2d[^-1] {w#-1},{h#-1}

	r[^.] {w#-1},{h#-1},100%,100%,2,2,.5,.5

	if $8
		+distance.. 0
		+blend[-2,-1] shapemax0
		/.. .
		rm.
		store. distance
	fi
	store. art_shape
	repeat $! {
		local [$<] {
			if (s==3||s==4)&&$11
				convert_back=1
				if $11!=2
					sh 0,2
					$convert_colors_fwd.
					rm.
				else
					if s==3 rgb2cmyk tcr+=1
					elif s==4 s c,-3 rgb2cmyk.. a c
					fi
				fi
			fi

			if $10 +store output_resized fi

			$art_shape
		}
	}
fi
#@cli rep_rand_sqrrectex: eq. to 'rep_random_square_rectangle_texture'
rep_rand_sqrrectex: rep_random_square_rectangle_texture $*
#@cli rep_random_square_rectangle_texture: square_dimension>0,_rectangle_max_length_1>0,_rectangle_max_length_2>0,_frequency_of_rectangle>0,_erode,_output={ 0=none | 1=filled_gray | 2=filled_line | 3=labeled_filled_line },_reduce_nonrectangles={ 0=do_not_reduce_nonrectagles | 1=reduce_nonrectangles },_seed
#@cli : Create a texture with aligned rectangle and squares.
#@cli : (eq. to 'rep_rand_sqrrectex')
#@cli : Note: '_reduce_nonrectangles' cannot be used to completely clear vectors of nonrectangle due to the algorithm provided, and no solution in context of vector exist as of now.
#@cli : Default values: '_rectangle_max_length=1','_rectangle_max_length=2','_frequency_of_rectangle=1','_erode=0','_output=2','_reduce_nonrectangles','_seed='
#@cli : Author: Reptorian.
##@cli : $ rep_random_square_rectangle_texture 20,3,3,2,,0
rep_random_square_rectangle_texture:
skip ${2=2},${3=1},${4=1},${5=0},${6=2},${7=1},${8=}
if narg($8) srand $8 fi
square_size=$1
rf=0

if abs($5)
	if $5>0 square_size+={abs($5)}
	else square_size+=1
	fi
fi

if $1<2 error ""$"1>1==F" fi

mw=${-max_w}
mh=${-max_h}
nvw={ceil($mw/$square_size)}
nvh={ceil($mh/$square_size)}

$nvw,$nvh,1,1,"x+y*w"
if abs(round($2))==1&&abs(round($3))==1 error ""$"2>1||"$"3>1==F" fi

msize={abs($2)+sqr(round(abs($3)))}

if $1<2 error ""$"2>1==F" fi

freq={int(avg(1/$msize,$4,.5)*(iM+1))}
val={iM+1}

repeat round($freq) {
	orientation={round(u(0,1))}
	nsl_1={round(u(1,abs($2)))}
	nsl_2={round(u(1,abs($3)))}
	min_nsl={min($nsl_1,$nsl_2)}
	max_nsl={max($nsl_1,$nsl_2)}

	if $min_nsl==1&&$max_nsl==1 max_nsl={round(u(2,abs(max($2,$3))))} fi

	px={round(u(0,w#-1-1))}
	py={round(u(0,h#-1-1))}

	if $orientation $min_nsl,$max_nsl,1,1,$val j.. .,$px,$py rm.
	else $max_nsl,$min_nsl,1,1,$val j.. .,$px,$py rm.
	fi

	val+=1
}

label. 0,0

if $7&&($2>1&&$3>1)
	if max($2,$3)>2
	rf={max($2,$3)-2}
	fi
	repeat 2+$rf {
		mirror. x
		f. "
			topleft   = j(-1,-1);
			topmiddle = j(0,-1);
			topright  = j(1,-1);

			middleleft  = j(-1,0);
			middle      = i;
			middleright = j(1,0);

			bottomleft   = j(-1,1);
			bottommiddle = j(0,1);
			bottomright  = j(1,1);

			F=i;

			if(

				(  (avg(topmiddle,middleleft)==middle)
				|| (avg(topmiddle,middleright)==middle)
				|| (avg(bottommiddle,middleleft)==middle)
				|| (avg(bottommiddle,middleright)==middle)
				)

				||

				(  (avg(middleleft,topmiddle,middleright)==middle)
				|| (avg(middleleft,bottommiddle,middleright)==middle)
				|| (avg(bottommiddle,middleleft,topmiddle)==middle)
				|| (avg(bottommiddle,middleright,topmiddle)==middle)
				)

				||

				(  (avg(bottommiddle,bottomright,middleright)==middle)
				|| (avg(bottommiddle,bottomleft,middleleft)==middle)
				|| (avg(topmiddle,topright,middleright)==middle)
				|| (avg(topmiddle,topleft,middleleft)==middle)
				)

				,F*=-1;
			);

			F;"
		label. 0,0
	}
fi

if $6

	{$nvw*$square_size+2},{$nvh*$square_size+2},1,1,i(#-1,floor(x/$square_size),floor(y/$square_size),z,0,0,1) rm.. r. {w-1},{h-1}

	if $6>1 rs {(($1+1)/$1)*100}%,,1 fi

	if $6>1 f. "(x!=0&&x!=w-1&&y!=0&&y!=h-1)?(i(x-1,y-1,z,c,0,1)==i(x,y))*((i(x-1,y,z,c,0,1)==i(x,y))&&(i(x,y-1,z,c,0,1)==i(x,y))):0"
		if $5 erode. {$5<0?(abs($5)>$1?$1:abs($5)):abs($5)} expand. xy,{int(abs($5)/2)},1 if !($5%2) r. {w-1},{h-1} fi fi
	fi

	if $6>2 label_fg. 0,0 fi
	if $6<2 r. {w-1},{h-1} fi

fi
#@cli rep_gradf: eq. to 'rep_graduated_filter'
rep_gradf: rep_graduated_filter $*
#@cli rep_graduated_filter: 0<strength<=1,0<=_lumastrength<=1,0<=_placement<=1,-360<=_ang<=360,_gradiated_colorspace= { 0=RGB | 1=HSV | 2=YUV },_color1,_color2,_color3
#@cli : Apply graduated filter on the YUV color space.
#@cli : (eq. to 'rep_gradf')
#@cli : Default values: '_lumastrength=0','_offset=0','_ang=0','_gradiated_colorspace=0','_color1=0','_color2=0','_color3=0'\n
#@cli : Author: Reptorian.
rep_graduated_filter:
skip ${2=1},${3=.75},${4=0},${5=0},${6=0},${7=0},${8=0},${9=0}

num_imgs={$!}

rgb2yuv

if $5==2 ($6^$7^$8)
elif $5==1 ($6^$7^$8) hsv2rgb. rgb2yuv.
else ($6^$7^$8) rgb2yuv.
fi

yl,ul,vl={yuv=crop(#-1);yuv[0]=1-yuv[0];yuv;}

rm.

foreach {
	if !(s==3||s==4)
		if $num_imgs==1 error "Not RGB/RGBA imgs!"
		else continue
		fi
	else sh. 0,2 fi

	f. "begin(
		const shorter_side=min(w,h);
		const center_x=(w-1)/2;
		const center_y=(h-1)/2;
		const ang=($4+180)Â°;
		const offset=$3-.5;
		const sin_ang=sin(ang);
		const cos_ang=cos(ang);
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		yuv_arr=[$yl*$2,-$ul,-$vl];
	);
	pos_x=cut(rot_y(x-center_x,y-center_y)/shorter_side+offset,0,1);
	new_arr=yuv_arr*pos_x;
	I-new_arr*$1;
	"

	yuv2rgb.

	rm.
}
#@cli rep_mj_newf: eq. to 'rep_madjik_newton_fractal'
rep_mj_newf:rep_madjik_newton_fractal $*
#@cli rep_madjik_newton_fractal: _zoom>0,_xpan,_ypan,_colrange>0,_factor_a,_factor_b,_factor_c,_factor_d,_expf>0,_depth>0,_bgfreq>0,-360<=_colang<360,_alternate_colfunc={ 0=Regular | 1=Alternate },_symmetry={ 0=Regular | 1=Symmetrical },_alternate_channels
#@cli : Near direct conversion of MadJik's Newton Fractal Paint.NET plugin. This is a early beta filter. Unlike Paint.NET version, every variables are float-based except for last two.
#@cli : (eq. to 'rep_mj_newf')
#@cli : Default values: '_zoom=16','_xpan=0','_ypan=0','_colrange=128','_factor_a=9','_factor_b=0','_factor_c=75','_factor_d=5','_expf=10','_depth=50','_bgfreq=50','_colang=45','_alternate_colfunc=0','_symmetry=0'
rep_madjik_newton_fractal:
skip ${1=16},${2=0},${3=0},${4=128},${5=9},${6=0},${7=75},${8=5},${9=10},${10=50},${11=50},${12=45},${13=0},${14=0},${15=0}
foreach {
 ww,hh={[w,h]}

 r {max(w,h)*2},{max(w,h)*2},1,3

 f "
 begin(
  const zoom=$1/100;
  const fvar_b=8/9+$6/1000;
  const fvar_c=$7/10;
  const fvar_d=$8/10;
  const afc=fvar_c*$5;
  const afd=afc*fvar_d;
  const bgfreq=$11/100;
  const ang=$12/180*pi;
  const fexp=10^-$9;
  funcb(w,t)=128+$4*sin(($15?(2-c)/2:c/2)*pi+(bgfreq*(ang+t+w*pi/180)));
  func(w,t)=128+$4*sin(($15?(2-c)/2:c/2)*pi+(bgfreq*(ang+(t+w)*pi/180)));
 );
 ex=sqr((x-w/2)-$2/100);
 ey=sqr((y-h/2)-$3/100);
 ix=(x-w/2)*100/(zoom*w)-$2/100;
 iy=(y-h/2)*100/(zoom*h)-$3/100;
 for(k=1,k<$10,++k,
  ix_2=ix*ix;
  ix_3=ix_2*ix;
  ix_4=ix_3*ix;
  ix_5=ix_4*ix;
  ix_6=ix_5*ix;
  ix_7=ix_6*ix;
  ix_8=ix_7*ix;
  iy_2=iy*iy;
  iy_3=iy_2*iy;
  iy_4=iy_3*iy;
  iy_5=iy_4*iy;
  iy_6=iy_5*iy;
  iy_7=iy_6*iy;
  iy_8=iy_7*iy;
  endval=(ix_2+iy_2)/2;
  repeat(3,m,endval*=endval;);
  ny=fvar_b*iy-($5*ix_7*iy-afc*ix_5*iy_3+afc*ix_3*iy_5-$5*ix*iy_7)/endval;
  nx=fvar_b*ix+(ix_8-afd*ix_6*iy_2+2.5*afd*ix_4*iy_4-afd*ix_2*iy_6+iy_8)/endval;
  if((abs(nx-ix)<fexp)&&(abs(ny-iy)<fexp),break());
  ix=nx;
  iy=ny;
 );
 v=k;
 if($14,
  jx=(w-x-w/2)*100/(zoom*w)-$2/100;
  jy=(h-y-h/2)*100/(zoom*h)-$3/100;
  for(k=1,k<$10,++k,
   jx_2=jx*jx;
   jx_3=jx_2*jx;
   jx_4=jx_3*jx;
   jx_5=jx_4*jx;
   jx_6=jx_5*jx;
   jx_7=jx_6*jx;
   jx_8=jx_7*jx;
   jy_2=jy*jy;
   jy_3=jy_2*jy;
   jy_4=jy_3*jy;
   jy_5=jy_4*jy;
   jy_6=jy_5*jy;
   jy_7=jy_6*jy;
   jy_8=jy_7*jy;
   endval=(jx_2+jy_2)/2;
   repeat(3,m,endval*=endval;);
   ny=fvar_b*jy-($5*jx_7*jy-afc*jx_5*jy_3+afc*jx_3*jy_5-$5*jx*jy_7)/endval;
   nx=fvar_b*jx+(jx_8-afd*jx_6*jy_2+2.5*afd*jx_4*jy_4-afd*jx_2*jy_6+jy_8)/endval;
   if((abs(nx-jx)<fexp)&&(abs(ny-jy)<fexp),break());
   jx=nx;
   jy=ny;
  );
  v+=k;
  v/=2;
 );
 $13?func(sqrt(ex+ey),v):funcb(sqrt(ex+ey),v);"

 r {$ww*2},{$hh*2},100%,100%,0,0,.5,.5
 rs 50%,,3

}
#@cli rep_major: eq. to 'rep_majority'
rep_major:rep_majority $*
#@cli rep_majority: kernel_size>1,_mode={ 0=soft_regular | 1=soft_average_channels | 2=hard_regular | 3=hard_average_channels },_colourspace,_alpha
#@cli : Calculate whether to erode or dilate pixels using average.
#@cli : (eq. to 'rep_major_t').\n
#@cli : Custom Colour Space values can be specified with negative number for $3\n
#@cli : Primary Source: https://web.archive.org/web/20080214191501/http://interstices.info/display.jsp?id=c_27035
#@cli : Secondary Source: https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/\n
#@cli : Default values: '_mode=0','_colourspace=0','_alpha=0'
#@cli : Author: Reptorian.
rep_majority:
skip ${2=0},${3=0},${4=0}

if ($3>=0&&$3<=4)||($3==13||$3==14) colour="0,255"
elif $3>=5||$3<=8 colour="0,360,0,1,0,1"
elif $3==9        colour="0,100,-100,100,-100,100"
elif $3==10       colour="0,100,0,100,-pi,pi"
elif $3==11       colour="0,255,-100,100,-100,100"
elif $3==12       colour="0,1,-1,1,-1,1"
elif $3==15       colour="0,1,0,1,0,1"
elif $3==16       colour="0,255,-127.5,127.5,-127.5,127.5"
elif $3==17       colour="0,255,-170,85,-170,85"
elif $3==18       colour="0,765,-255,255,-510,255"
elif $colour<0    colour=${5--1}
fi

tcr=3
mergeback=0

if $3 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$3,,srgb,ryb,cmy,cmyk,hcy,hsi,hsl,hsv,lab,lch,yiq,yuv,ycbcr,xyz,yes,k1,ohta} fi

foreach {

	ss={s}

	if (s==3||s==4)&&$3

		convert_back=1

		if $3!=4
			$convert_colors_fwd.
		else
			if s==3 rgb2cmyk tcr+=1
			elif s==4 s c,-3 rgb2cmyk.. a c
			fi
		fi

	fi

	if $4&&(s>$tcr||s==2) s c,-{s-1} mergeback=1 fi

	l[0] {

		+boxfilter[0] $1

		if $2==1||$2==3 compose_channels. add /. $ss fi

		+erode[0] $1
		+dilate[0] $1

		if $2==3   f[0] "begin(const ts=s*2;if("$4",mm=vectorts("$colour",0,255);,mm=vectorts("$colour");););i<i0#1?mm[c*2]:mm[c*2+1];"
		elif $2==2 f[0] "begin(const ts=s*2;if("$4",mm=vectorts("$colour",0,255);,mm=vectorts("$colour");););i<i#1?mm[c*2]:mm[c*2+1];"
		elif $2==1 f[0] i<i0#1?i#2:i#3
		else f[0] i<i#1?i#2:i#3
		fi

		k[0]

	}

	if $mergeback a c fi

	if $convert_back

		if $3!=4
			$convert_colors_bwd.
		else
			if s==4 cmyk2rgb tcr-=1
			elif s==5 s c,-4 cmyk2rgb.. a c
			fi
		fi

	fi
}
#@cli rep_major_t: eq. to 'rep_majority_threshold'
rep_major_t:rep_majority_threshold $*
#@cli rep_majority_threshold: kernel_size>=2,0<=tolerance[%]<=100,_booldir={ 0=less_than | 1=greater_than },_alpha,_mode={ 0=soft | 1=hard },_colorspace
#@cli : Calculate whether to erode or dilate based on specified threshold.
#@cli : (eq. to 'rep_major_t').\n
#@cli : Custom Colour Space values can be specified with negative number for $6\n
#@cli : Primary Source: https://web.archive.org/web/20080214191501/http://interstices.info/display.jsp?id=c_27035
#@cli : Secondary Source: https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/\n
#@cli : Default values: '_booldir=0','_mode=1','_alpha','_colourspace',
rep_majority_threshold:
skip ${3=0},${4=1},${5=0},${6=0}
remove_image=0

if $1<2 error ""$1">2==F" fi
if ($5>=0&&$5<=4)||($5==13||$5==14) colour="0,255"
elif $5>=5||$5<=8       colour="0,360,0,1,0,1"
elif $5==9        colour="0,100,-100,100,-100,100"
elif $5==10       colour="0,100,0,100,-pi,pi"
elif $5==11       colour="0,255,-100,100,-100,100"
elif $5==12       colour="0,1,-1,1,-1,1"
elif $5==15       colour="0,1,0,1,0,1"
elif $5==16       colour="0,255,-127.5,127.5,-127.5,127.5"
elif $5==16       colour="0,255,-127.5,127.5,-127.5,127.5"
elif $5==17       colour="0,255,-170,85,-170,85"
elif $5==18       colour="0,765,-255,255,-510,255"
elif $5<0         colour=${7--1}
fi

if $5<0 if $#<6 error ""$#">6==F" fi fi

tcr=3

if $5 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$5,,srgb,ryb,cmy,error,hcy,hsi,hsl,hsv,lab,lch,yiq,yuv,ycbcr,ycbcrglic,xyz,yes,k1,ohta} fi

foreach {
	if (s==3||s==4)&&$5
		convert_back=1
		if $5!=4
			$convert_colors_fwd.
		else
			if s==3 rgb2cmyk tcr+=1
			elif s==4 s c,-3 rgb2cmyk.. a c
			fi
		fi
	fi

	if !$6&&(s>$tcr||s==2) sh. 0,{s-2} remove_image=1 fi

	f. "begin(
			const dc=($1-1)/2;
			const kern=dc*2+1;
			const ts=s*2;
			NEW_COL=vectors(0);
			if($6,mm=vectorts("$colour",0,255);,mm=vectorts("$colour"););
			skip=1;
		);
		repeat(s,ss,
			N=crop(x-dc,y-dc,0,ss,kern,kern,1,1,1);
			min_val=min(mm[ss*2],mm[ss*2+1]);
			max_val=max(mm[ss*2],mm[ss*2+1]);
			tolerance=$2*(max_val-min_val)+min_val;
			if(skip,
				if($3,
					if($4
					,calc_newcol()=i(x,y,z,ss)<tolerance?min_val:max_val;
					,calc_newcol()=i(x,y,z,ss)<tolerance?min(N):max(N);
					);
				,
					if($4
					,calc_newcol()=i(x,y,z,ss)>tolerance?min_val:max_val;
					,calc_newcol()=i(x,y,z,ss)>tolerance?min(N):max(N);
					);
				);
			--skip;
			);
			NEW_COL[ss]=calc_newcol();
		);

		NEW_COL;

		end(if(!skip,
			if($3,
					if($4
					,calc_newcol()=i(x,y,z,ss)<tolerance?min_val:max_val;
					,calc_newcol()=i(x,y,z,ss)<tolerance?min(N):max(N);
					);
				,
					if($4
					,calc_newcol()=i(x,y,z,ss)>tolerance?min_val:max_val;
					,calc_newcol()=i(x,y,z,ss)>tolerance?min(N):max(N);
					);
				);
			);
		);"

	if $remove_image rm. fi

	if $convert_back

		if $5!=4
			$convert_colors_bwd.
		else
			if s==4 cmyk2rgb tcr-=1
			elif s==5 s c,-4 cmyk2rgb.. a c
			fi
		fi

	fi

}
#@cli rep_pstrk: eq. to 'rep_perspective_streak'
rep_pstrk: rep_perspective_streak $*
#@cli rep_perspective_streak: -1<=_xpos<=1,-1<=_ypos<=1,-1<=_alpha_exponential_factor,0<_distance_threshold<=1,0<_distance_start<=1,_direction={ 0=in | 1=out },_streak_mode={ 0=color | 1=gray | 2=binary | 3=gray+binary },_preserve_edges={ 0=do_not_preserve_edges | 1=preserve_edges },_alpval
#@cli : Create perspective streak effect. _preserve_details only is applicable on non-binary mode.
#@cli : (eq. to 'rep_pstrk').\n
#@cli : Default values: '_xpos=0','_ypos=0','_alpha_exponential_factor=1','_distance_threshold=1','_distance_start=0','_direction=0','_streak_mode=0','_preserve_edges=1','_alpval'\n
#@cli : Author: Reptorian.
rep_perspective_streak:
skip ${1=0},${2=0},${3=0},${4=1},${5=0},${6=0},${7=0},${8=1},${9=}

point={[$1,$2]}

if !$4 error "$4|"$"4>0" fi

foreach
 if s!=3
  echo "Applying perspective streak at coordinate point $point!"

  if h>w orientation=1
  else orientation=0
  fi

  if s>1
   sh. 0,{s-2}
   sh.. {s}
   f. ":begin(
    const cols=s#-2;
    );
    targ=0;
    !i?(
     v=vectorcols(0);
     vb=J(#-2,0,-1);
     vd=J(#-2,-1,0);
     vf=J(#-2,1,0);
     vh=J(#-2,0,1);
     j(0,-1)?(++targ;v+=vb;);
     j(-1,0)?(++targ;v+=vd;);
     j(1,0)?(++targ;v+=vf;);
     j(0,1)?(++targ;v+=vh;);
     targ?(v/=targ;I(#-2)=v;);
     0;
    ):i;"
   rm[-2,-1]
  fi
  rep_recpoltrans $point,-3
   if $5>0&&$5<1 f begin(sy=1/(((1-$5)*h)/h););i(x,y*sy,z,c,2); fi
   if $7||s==1
    channels {s-1}
    if $8
     if $7==3||$7==1 . n. 0,1 l. +f 1 rv a c done store. details
     else echo "Details cannot be preserved using binary mode!"
     fi
    fi
    rep_axis_streak 1,!$6,$3,$9
    if $4>0&&$4<1
     f i>(1-$4)?i:(1-$4)
     n 0,1
    fi
    if $7==2 f i>0?1:0
    elif $7==3 +f i>0?1:0 a c fi
    if $8
     if $7==3||$7==1
      $details
      s. c,-{s-1}
      j[-3] [-2],0,0,0,0,1,[-1],1
      rm[-2,-1]
     fi
    fi
   else
    if $8 +store details fi
    if $4>0&&$4<1
     +channels {s-1}
     rep_axis_streak. 1,!$6,$3,$9
     f. i>(1-$4)?i:(1-$4)
     f. i>im#-1?1:0
    fi
    rep_axis_streak[0] 1,!$6,$3,$9
    if $4>0&&$4<1
     sh[0] {s#0-1}
     f. i0#-2*i
     k[0]
    fi
    if $8
     $details
     s. c,-{s-1}
     j[-3] [-2],0,0,0,0,1,[-1],{iM#-1}
     rm[-2,-1]
    fi
   fi
  rep_recpoltrans $point,2,$orientation
 else echo "Not applicable to images with 3 channels!"
 fi
done
#@cli rep_axis_streak: orientation,direction,_alpha_exponential_factor,_maxval>0_cmykmode={ 0=non-cmyk | 1=cmyka_mode }
#@cli : Streaks pixels based on distance away from center and placement of visible objects.
#@cli : '_alpha_exponential_factor' is used to manipulate the alpha mixing within pixels. The more power that is assigned to the alpha, the more mixing there would be.
#@cli : '_maxval' divides the alpha channel internally to normalize ranges to 0-1. A error will appear if not normalized. By default, it used the max alpha channel value.
#@cli : '_cmykmode' is only used in case of using only cmyk images. Not needed in normal cases at all.
#@cli : Default values: '_alpha_exponential_factor=0','_maxalp=n/a','_cmykmode=0'
#@cli :
#@cli : Author: Reptorian.
rep_axis_streak:

skip ${3=0},${4=},${5=0}

foreach {
 if s==1 rep_axis_streak_distance $*
 else rep_axis_streak_color $*
 fi
}
#@cli rep_axis_streak_distance: orientation,direction,_alpha_exponential_factor,_maxval
#@cli : Extract the alpha, then streaks pixels based on distance away from center and placement of visible objects.
#@cli : '_alpha_exponential_factor' is used to manipulate the alpha mixing within pixels. The more power that is assigned to the alpha, the more mixing there would be.
#@cli : '_maxval' divides the alpha channel internally to normalize ranges to 0-1. A error will appear if not normalized. By default, it used the max alpha channel value.
#@cli : Default values: '_alpha_exponential_factor=0','_maxalp=n/a'
#@cli :
#@cli : Author: Reptorian.
rep_axis_streak_distance:
skip ${3=0},${4=}

foreach {

	sh {s-1}
	if !iv#-1 rm. break else rm. fi

	if s>1 channels {s-1} fi

	if narg($4) alp={abs($4)}
	else alp={iM#-1}
	fi
	/ $alp
	if iM>1||im<0 error alpval(valid)==F fi
	if $3<=-1 exp_f=-{1-10^-8} else exp_f=$3 fi
	f i^(1+$exp_f)

	if $1
		outdata_dim={w},1,{d},1
		outdata_coords=x,yy,z
		outdata_dimref=hh
		outdata_pos=yy
		if $2
			direction=yy=hh,yy>0,--yy
			end_level=yy
		else
			direction=yy=0,yy<hh,++yy
			end_level=(hh-yy)
		fi
	else
		outdata_dim=1,{h},{d},1
		outdata_coords=xx,y,z
		outdata_dimref=ww
		outdata_pos=xx
		if $2
			direction=xx=0,xx<ww,++xx
			end_level=(ww-xx)
		else
			direction=xx=ww,xx>0,--xx
			end_level=xx
		fi
	fi

	$outdata_dim,":begin(
		const ww=w#0-1;
		const hh=h#0-1;
	);
	mode=0;
	for("$direction",
		imgval=i(#-1,"$outdata_coords");
		!mode?(imgval?mode=1;);
		mode==1?(z_level="$outdata_dimref";mode=2;alp=imgval;);
		mode==2?(
			alp=alp+(1-alp)*imgval;
			z_level="$end_level"*imgval+(1-imgval)*z_level;
			i(#-1,"$outdata_coords")="$end_level"/z_level*alp;
		);
	);"
	rm.

}
#@cli rep_axis_streak_color: orientation,direction,_alpha_exponential_factor,_maxval>0,_add2new={ 0=add2old | 1=add2new },_cmykmode={ 0=non-cmyk | 1=cmyka_mode }
#@cli : Streaks colored pixels taking into account of opacity.
#@cli : '_alpha_exponential_factor' is used to manipulate the alpha mixing within pixels. The more power that is assigned to the alpha, the more mixing there would be.
#@cli : '_maxval' divides the alpha channel internally to normalize ranges to 0-1. A error will appear if not normalized. By default, it used the max alpha channel value.
#@cli : '_add2new' defines whether to streak data on old image or to streak pixel data onto a new image. Used for Perspective Streak.
#@cli : '_cmykmode' is only used in case of using only cmyk images. Not needed in normal cases at all.
#@cli : Default values: '_alpha_exponential_factor=0','_maxalp=n/a','_cmykmode=0'
#@cli :
#@cli : Author: Reptorian.
rep_axis_streak_color:
skip ${3=0},${4=},${5=0},${6=0}

tcr=3

if $6 tcr+=1 fi

if narg($4) if $4==0 return fi fi

foreach {

	if s==1||s==$tcr break fi

	vv=0

	repeat s {
		sh $>
		vv+={iv#-1}
		rm.
	}

	if !$vv break fi

	sh. 0,{s-2}
	sh.. {s}
	f.. i#-1?I
	if narg($4) alp={abs($4)}
	else alp={iM#-1}
	fi
	/. $alp
	if iM#-1>1||im#-1<0 error alpval(valid)==F fi
	if $3<=-1 exp_f=-{1-10^-8} else exp_f=$3 fi
	f. i^(1+$exp_f)

	if $1
		outdata_dim={w},1,{d},{s#0}
		outdata_coords=x,yy
		if $2 direction=yy=hh-1,yy>=0,--yy
		else direction=yy=0,yy<hh,++yy
		fi
	else
		outdata_dim=1,{h},{d},{s#0}
		outdata_coords=xx,y
		if $2 direction=xx=0,xx<ww,++xx
		else direction=xx=ww-1,xx>=0,--xx
		fi
	fi

	if $5 {w#0},{h#0},{d#0},{s#0}
		col_info=-3
		alp_info=-2
		targ_info=#-1
		outdata_gen_1=I($targ_info,$outdata_coords,z)=temp;
	else
		col_info=-2
		alp_info=-1
		targ_info=#0
		outdata_gen_0=I($targ_info,$outdata_coords,z)=temp;
	fi

	$outdata_dim,":begin(
			const ww=w#0;
			const hh=h#0;
		);
		start_val=1;
		for("$direction",
			start_val?(
				start_val=0;
				col=I(#"$col_info","$outdata_coords",z);
				alp=i(#"$alp_info","$outdata_coords",z,0);
				temp=[col,alp];
			):(
				newcol=I(#"$col_info","$outdata_coords",z);
				newalp=i(#"$alp_info","$outdata_coords",z,0);
				newinfo=[newcol,newalp];
				!newalp?(I("$targ_info","$outdata_coords",z)=temp;):
				newalp==1?(temp=newinfo;
				):(
						"$outdata_gen_1"
						col=newcol*newalp+(1-newalp)*col;
						alp=alp+newalp*(1-alp);
						temp=[col,alp];
						"$outdata_gen_0"
				);
			);
		);"

	if $5 rm[^-2]
	else rm[1-3]
	fi

	sh. {s-1}
	*. $alp
	rm.

}
#@cli rep_mn: eq. to 'rep_multinormalize'
rep_mn: rep_multinormalize $*
#@cli rep_multinormalize: values
#@cli : Normalize based on channels using values.
#@cli : (eq. to 'rep_mn').\n
#@cli : Author: Reptorian.
rep_multinormalize:

$=a

foreach {
	repeat s {

		val_a=${a{$>*2+1}}
		val_b=${a{$>*2+2}}

		sh $>

		normalize. $val_a,$val_b

		rm.
	}
}
#@cli rep_mc: eq. to 'rep_multicut'
rep_mc: rep_multicut $*
#@cli rep_multicut: values
#@cli : Cut based on channels using values.
#@cli : (eq. to 'rep_mc').\n
#@cli : Author: Reptorian.
rep_multicut:

$=a

foreach {
	repeat s {

		val_a=${a{$>*2+1}}
		val_b=${a{$>*2+2}}

		sh $>

		cut. $val_a,$val_b

		rm.
	}
}
#@cli rep_cr: eq. to 'rep_cr'.
rep_cr: rep_channels_range
#@cli rep_channels_range:
#@cli : Return the minimal and maximum values per channels in a image.\n
#@cli : Author: Reptorian.
rep_channels_range:
if $!>1 error "Cannot be used on more than 1 images!" fi
num_chans={s}

repeat $num_chans { shared[0] $> }

u {expr('p=1+(x>>1);x&1?iM#p:im#p;',$num_chans<<1)}

rm[-$num_chans--1]
#@cli rep_ol: eq. to 'rep_orientation_list'.
#@cli : Return orientation of selected images based on standard 2D dimensions.
rep_ol: rep_orientation_list
#@cli rep_orientation_list:
#@cli : Return orientation of selected images.
#@cli : (eq. to rep_ol).
rep_orientation_list: u {expr('h#x>w#x',$!)}
#@cli rep_recpoltrans: eq. to 'rep_rectangular_polar_transformation'.
rep_recpoltrans: rep_rectangular_polar_transformation $*
#@cli rep_rectangular_polar_transformation : -1>=_xpos<=1,-1>=_ypos<=1,_from_to={ -3=to_inverted_rectangular_polar_preserved_details | -2=from_rectangular_polar_preserved_details_to_cartesian | -1=to_inverted_rectangular_polar | 0=to_rectangular_polar | 1=to_rectangular_polar_preserved_details| 2=from_preserved_details_inverted_rectangular_polar },orientation_0={ 0=landscape | 1=portrait },...,orientation_n
#@cli : Converts images to inversion of rectangular polar format or to rectangular polar format. Adapted for development of perspective filters. The first two variables defines the coordinates of revolution based on -1,1 ranges. 1,1 means the point of revolution is on top-right part of the image.
#@cli : (eq. to rep_recpoltrans).\n
#@cli : Note: When using 2 for $3, you need to define the orientation of every images. For every images, insert one argument per image after $3.
#@cli : Default values: '_xpos=0','_ypos=0','_from_to=0'
#@cli :
#@cli : Author: Reptorian.
rep_rectangular_polar_transformation:
skip ${1=0},${2=0},${3=0}
if $1<-1||$1>1 error "($1>=-1&&$1<=1)=0" fi
if $2<-1||$2>1 error "($2>=-1&&$2<=1)=0" fi

foreach {
	ov=${-rep_cr}
	if $3==-3
		maxlength={max(w,h)}
		perimeter={(w+h)*2}
		{$perimeter*2},{$maxlength*2},{d},{s},":begin(
			const ww=w#0;
			const hh=h#0;
			const point_x=(($1*-1)*.5+.5)*ww;
			const point_y=($2*.5+.5)*hh;
			const inv_point_x=ww-point_x;
			const inv_point_y=hh-point_y;
			const cut_ang_s0=abs(atan2(inv_point_y,inv_point_x)*180/pi);
			const cut_ang_s1=180-abs(atan2(inv_point_y,point_x)*180/pi);
			const cut_ang_s2=180+abs(atan2(point_y,point_x)*180/pi);
			const cut_ang_s3=360-abs(atan2(point_y,inv_point_x)*180/pi);
			distanceaway(value)=(
				value==0?ww-point_x:
				value==1?hh-point_y:
				value==2?point_x:
				point_y;
				);
			);
			surface_angle=(x/w)*360;
			surface_angle>cut_ang_s0&&surface_angle<=cut_ang_s1?side=1:
			surface_angle>cut_ang_s1&&surface_angle<=cut_ang_s2?side=2:
			surface_angle>cut_ang_s2&&surface_angle<=cut_ang_s3?side=3:
			side=0;
			mdist=abs(side%2?1/sin((surface_angle/180)*pi):1/cos((surface_angle/180)*pi));
			dix=(point_x+cos((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((ww-1)/ww);
			diy=(point_y+sin((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((hh-1)/hh);
			I(#0,ww-(dix+1),hh-(diy+1),z,2);"

		k.
	elif $3==-1||$3==-2
		f ":begin(
				const point_x=(($1*-1)*.5+.5)*w;
				const point_y=($2*.5+.5)*h;
				const inv_point_x=w-point_x;
				const inv_point_y=h-point_y;
				const cut_ang_s0=abs(atan2(inv_point_y,inv_point_x)*180/pi);
				const cut_ang_s1=180-abs(atan2(inv_point_y,point_x)*180/pi);
				const cut_ang_s2=180+abs(atan2(point_y,point_x)*180/pi);
				const cut_ang_s3=360-abs(atan2(point_y,inv_point_x)*180/pi);
				distanceaway(value)=(
					value==0?ww-point_x:
					value==1?hh-point_y:
					value==2?point_x:
					point_y;
					);
			);
			surface_angle=(x/w)*360;
			surface_angle>cut_ang_s0&&surface_angle<=cut_ang_s1?side=1:
			surface_angle>cut_ang_s1&&surface_angle<=cut_ang_s2?side=2:
			surface_angle>cut_ang_s2&&surface_angle<=cut_ang_s3?side=3:
			side=0;
			mdist=abs(side%2?1/sin((surface_angle/180)*pi):1/cos((surface_angle/180)*pi));
			dix=(point_x+cos((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((w-1)/w);
			diy=(point_y+sin((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((h-1)/h);
			I(w-(dix+1),h-(diy+1),z,2);"
		if $3<-1 rs 50%,,6 fi
	elif $3==0||$3==1
		if $3>0 rs 200%,,6 fi

		f ":begin(
				const ww=w-1;
				const hh=h-1;
				const sd=max(w,h)/min(w,h);
				const sx=w>h?sd:1;
				const sy=w>h?1:sd;
				const cx=.5+$1*.5;
				const cy=.5+$2*.5;
				const px=cx*w;
				const py=(1-cy)*h;
				const sxl=(w/2)/px;
				const sxr=(w/2)/(w-px);
				const syt=(h/2)/py;
				const syb=(h/2)/(h-py);
			);
			atx=(x/ww-cx)*sx;
			aty=(y/hh-(1-cy))*sy;
			sur_atan=(atan2(aty,atx)+pi)/(2*pi);
			xl=-1+(x/ww)*2*sxl;
			xr=1-(1-x/ww)*2*sxr;
			yt=-1+(y/hh)*2*syt;
			yb=1-(1-y/hh)*2*syb;
			xx=x>=px?xr:xl;
			yy=y>=py?yb:yt;
			sur_max=max(abs(xx),abs(yy));
			I(sur_atan*w,sur_max*h,z,2,2);"
		if $3>0 sharpen 2 fi
	elif $3==2
		$=val
		orientation=${val{$>+4}}
		half_perimeter={w/2}
		length_1={$half_perimeter-h}
		length_2={$half_perimeter-$length_1}

		if $orientation
			width={min($length_1,$length_2)}
			height={max($length_1,$length_2)}
		else
			width={max($length_1,$length_2)}
			height={min($length_1,$length_2)}
		fi

		$width,$height,{d},{s},":begin(
				const ww=w#0;
				const hh=h#0;
				const ox=$width;
				const oy=$height;
				const sd=max(ox,oy)/min(ox,oy);
				if(w>h,
					const sxf=ox>oy?sd:1;
					const syf=ox>oy?1:sd;
				,
					const sxf=ox<oy?1:sd;
					const syf=ox<oy?sd:1;
				);
				const cx=.5+$1*.5;
				const cy=.5+$2*.5;
				const px=cx*ww;
				const py=(1-cy)*hh;
				const sxl=(ww/2)/px;
				const sxr=(ww/2)/(ww-px);
				const syt=(hh/2)/py;
				const syb=(hh/2)/(hh-py);
			);
			xx=(x/(w-1))*ww;
			yy=(y/(h-1))*hh;
			xl=-1+(xx/ww)*2*sxl;
			xr=1-(1-xx/ww)*2*sxr;
			yt=-1+(yy/hh)*2*syt;
			yb=1-(1-yy/hh)*2*syb;
			nxx=xx>px?xr:xl;
			nyy=yy>py?yb:yt;
			ay=max(abs(nxx),abs(nyy));
			ax=(atan2((yy/hh-(1-cy))*syf,(xx/ww-cx)*sxf)+pi)/(2*pi);
			I(#0,abs(ax*ww),abs(ay*hh),z,2,1);"
		rs. 50%,,6
		k.
	else error "$3|"$"3!=intnum[-3,2]"
	fi

	rep_multicut $ov
}
#@cli rep_sd: eq. to 'rep_spiral_distort'.
rep_sd: rep_spiral_distort $*
#@cli rep_spiral_distort: _revolution!=0,_height!=0,_refraction>0,_direction={ 0=clockwise | 1=counterclockwise },_angle,_continuous_spiral={ 0=periodic | 1=continuous },-1<=_preshift_x<=1,-1<=_preshift_y<=1,_preshift_boundary={ 0=periodic | 1=mirror },_skew_x,_skew_y,_skew_m,_scale_coord_x,_scale_coord_y,_offx,_offy,_spiral_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest | 1=average | 2=linear | 3=bicubic | 4=lanczos }
#@cli : Transform images into spiral by using spiral gradient for x coordinate, and radial gradient for y coordinate.
#@cli : (eq. to 'rep_sd').\n
#@cli : '_revolution' defines the number of revolution within the spiral assuming coordinates range of [-1,1].
#@cli : '_height' is the height of spiral. The higher the height of the spiral, the more duplicates will repeat within one revolution.
#@cli : '_refraction' refers to the logarithmic distortion within spiral.
#@cli : '_direction' determines if it clockwise or counter-clockwise.
#@cli : '_angle' determines the function angle.
#@cli : '_continuous_spiral' determines whether the spiral distortion is continuous or not.
#@cli : '_preshift_x' shifts the images before the spiral distortion along the x-axis.
#@cli : '_preshift_y' shifts the image before the spiral distortion along the y-axis.
#@cli : '_preshift_boundary' determines the boundary within the preliminary shift.
#@cli : '_skew_x' skews the distortion alongside the x-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_skew_y' skews the distortion alongside the y-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_skew_m' is the multiplier for skewing.
#@cli : '_scale_x' scales the coordinates alongside the x-axis.
#@cli : '_scale_y' scales the coordinates alongside the y-axis.
#@cli : '_offx' determines the offset-placement of the distortion alongside the x-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_offy' determines the offset-placement of the distortion alongside the y-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_spiral_boundary' determines how the out-of-bound values is to be evaluated.
#@cli : '_interpolation' determines the interpolation of the spiral distortion.\n
#@cli : Default values: '_frequency=1','_height=1','_refraction=0','_direction=0','_angle=0','_continuous_spiral=0','_preshift_x=0','_preshift_y=0','_preshift_boundary=0','_skew_x=0','_skew_y=0','_skew_m=1','_scale_x=1','_scale_y=1','_offx=0','_offy=0','_spiral_boundary=3','_interpolation=4'\n
#@cli : Author: Reptorian.
#@cli : $ sp car rep_spiral_distort 1,2,2,1,30,1,50%,50%,1,1,.25
rep_spiral_distort:
skip ${1=1},${2=1},${3=0},${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=0},${12=1},${13=1},${14=1},${15=0},${16=0},${17=3},${18=4}

if !$! v + error "No images to perform spiral distortion on" v - fi
if $1==0 v + error ""$"1/_revolution cannot be 0!" v - fi
if $2==0 v + error ""$"2/_height cannot be 0!" v - fi
if $3==-1 v + error ""$"3/_refraction cannot be -1!" v - fi
if !$13||!$14 v + error ""$"13/_scale_x and "$"14/_scale_y cannot be 0!" v - fi
v -
skew_m={abs(2*$12)}

direction=${arg0\ $4,counterclockwise,clockwise}
spiral_mode=${arg0\ $6,continuous,periodic}
periodic_boundary=${arg0\ (abs($9)?1),mirror,periodic}
spiral_boundary=${arg0\ abs($17),none,neumann,periodic,mirror}
interpolation=${arg0\ abs($18),nearest,average,linear,bicubic,lanczos}

if abs($7)||abs($8) preshift="Preshift of {$7*100}% alongside the x-axis, and {$8*100}% alongside the y-axis has been applied before the distortion using "$preshift_boundary" boundary condition."
else preshift=""
fi

v +

e[] "Apply spiral distortion at coordinates $15,$16 with scale factor of $13 within x-axis and $14 within y-axis and skew-"$skew_m" distortion utilizing factor of $10 within x-axis and factor of $11 within y-axis to images using "$direction" "$spiral_mode" spiral with revolution of $1, height of $2, refraction factor of $3 using "$spiral_boundary" boundary condition and "$interpolation" interpolation. "$preshift""

v +

if abs($18)>1 rs 200%,,{abs($18)>2?abs($18)+2:abs($18)+1} fi
if abs($7)||abs($8)
	e[] "Apply of {$7*100}% alongside the x-axis, and {$8*100}% alongside the y-axis"
	f "begin(
			const offx=(w/2)*$7*-1;
			const offy=(h/2)*$8;
			const interpolation=abs($18)>2?2:abs($18);
			const boundary=(abs($9)+2);
		);
		J(offx,offy,z,interpolation,boundary);"
fi
if $4 mirror x fi
f "begin(
		const sd=max(w,h)/min(w,h);
		const sx=w>h?sd:1;
		const sy=w>h?1:sd;
		const ang=pi*($5*-1/180);
		const skew_x=($10*-1)/abs($13);
		const skew_y=$11/abs($14);
		const skew_m=abs(2*$12);
		const offx=-.5+($15*-1/2);
		const offy=-.5+($16*-1/2);
		const nw=abs(w*sin(ang))+abs(h*cos(ang));
		const nh=abs(w*cos(ang))+abs(h*sin(ang));
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		const interpolation=abs($18)>2?2:abs($18);
		const boundary=abs($17);
	);
	XX=(x/w+offx)*sx*$13;
	YY=(y/h+offy)*sy*$14;
	xx=(rot_x(XX,YY)*(skew_m^(rot_x(XX,YY)*skew_x)))*2;
	yy=(rot_y(XX,YY)*(skew_m^(rot_y(XX,YY)*skew_y)))*2;
	radial=norm(xx,yy);
	if($4,sur_atan=1-(atan2(xx,yy)+pi)/(2*pi);,sur_atan=(atan2(xx,yy)+pi)/(2*pi););
	es=sur_atan+radial*$1;
	es=es-floor(es);
	if($6,es=(es>.5?1-es:es)*2;);
	I((es^(1+$3))*w*$2,radial*h,z,interpolation,boundary);"
	if abs($18)>1 rs 50%,,{abs($18)>2?abs($18)+2:abs($18)+1} fi
v -
#@cli rep_fibo_fill: eq. to 'rep_fibonacci_fill'
rep_fibo_fill: rep_fibonacci_fill $*
#@cli rep_fibonacci_fill: stack={ 0= top-left | 1= top-right | 2= bottom-left | 3= bottom-right },output_mode={ 0=corner | 1=spiral }, _initial_orientation={ 0=landscape | 1=portrait },_iteration>=0,_int_scale>0,{ boundary={0=periodic | 1=mirror} | -1<=spiral_location_x<=1 },{ append_mode={ 0=x | 1=y } | -1<=spiral_location_y<=1 },_palette_cycle,negate,_[palette],_seed_a...
#@cli : Generated filled image of fibonacci. If you need a complete fibonacci to use as a base, then execute 'gmic h +rep_fibonacci' for more information.
#@cli :
#@cli : (eq. to 'rep_fibo_fill')
#@cli : 1) stack defines the stacking of the fibonacci spiral. The options that are provided represent initial vector or orientation of the fibonacci spiral.
#@cli : 2) output_mode defines the style of stacking of the fibonacci base. If it is 1, then it's a spiral, otherwise, corner stacking.
#@cli : 3) _initial_orientation defines the initial stacking of the first two iteration of the fibonacci.
#@cli : 4) _iteration defines the number of iteration. 0 will automatically find the number of iterations requires for the maximum 2 dimensions to fit in.
#@cli : 5) If _iteration==0, and _output_mode==1, this option would be spiral_location_x. Otherwise, it would become boundary which is only applicable for _iteration>0.
#@cli : 6) If _iteration==0, and _output_mode==1, this option would be spiral_location_y. Otherwise, it would become append_mode which is only applicable for _iteration>0.
#@cli : 7) _palette_cycle* defines the shift of palette.
#@cli : 8) _negate defines whether to invert the order of palette.
#@cli : 9) _[palette]* defines the palette to be used for filling the fibonacci.
#@cli : 10) _seed* would define the seed to be used for generating order.
#@cli :
#@cli : *=See rep_custom_map for more details on how these options would work.
#@cli : Default values: '_initial_orientation=0','_iteration=0','{ boundary={0=periodic | 1=mirror} | -1<=spiral_location_x<=1 }=0','{ append_mode={ 0=x | 1=y } | -1<=spiral_location_y<=1 }}=0','_palette_cycle=n/a','_[palette]=n/a','seed=n/a'
#@cli :
#@cli : Author: Reptorian
rep_fibonacci_fill:
skip ${3=1},${4=0},${5=1},${6=0},${7=0},${8=},${9=0},${10=}

check $!>0

r 100%,100%,100%,1,-1

timg={$!}

mw=${-max_w}
mh=${-max_h}

+rep_fibonacci ${1-5}

fibo_id={$!-1}

if $4
 if narg(${10--1})>1
  .
  pass$10 0
  rep_custom_map[-3,-2] ${8--1}
  rm.
 else
  +negate.
  if $7<0 rv[-2,-1] fi
  if narg($8,$9) rep_custom_map[-2,-1] $8,$9 fi
 fi

 if $6
  r.. 200%,200%,1,100%,0,3,1,1
  r. 200%,200%,1,100%,0,3,1,0
 fi

 if ($7+($7<0))%2 a[-2,-1] x
 else a[-2,-1] y
 fi

 nw={ceil($mw/w#-1)*w#-1}
 nh={ceil($mh/h#-1)*h#01}

 r. $nw,$nh,100%,100%,0,2,.5,.5

 repeat $!-1 {
  +r. {w#$>},{h#$>},100%,100%,0,0,.5,.5
  rv[$>,-1]
  rm.
 }

else

 if $2
  f[^-1] "begin(
    const ww=w-1;
    const hh=h-1;
    const ox=(1+cut($6,-1,1))/2;
    const oy=(1+cut($7,-1,1))/2;
    const center_point=int($5/2);
    const px=int(xm#-1+center_point-ww*ox);
    const py=int(ym#-1+center_point-hh*oy);
   );
   i(#-1,px+x,py+y,z,0);"
 else
  if $1==0   j[^-1] [-1],0~,0~
  elif $1==1 j[^-1] [-1],1~,0~
  elif $1==2 j[^-1] [-1],0~,1~
  else       j[^-1] [-1],1~,1~
  fi
 fi

 if narg(${8--1})
  if narg($10)
   pass$10 0
   rep_custom_map[0--3] $8,$9,[-1],${11--1}
   rm.
  else
   rep_custom_map[^-1] $8,$9
  fi
 fi

fi

rm.
#@cli +rep_fibonacci: stack={ 0= top left | 1= top right | 2= bottom left | 3= bottom right }, output_mode={ 0=corner | 1=spiral }, _start_orientation={ 0=landscape | 1=portrait },_iteration>=0,int_scale>0
#@cli : stack defines the way that the fibonacci generator will stack within iterations.
#@cli : output_mode defines the style of stacking.
#@cli : _start_orientation defines the orientation of the first two iteration.
#@cli : _iteration defines the number of iteration. 0 means it will auto-find the number of generation.
#@cli :
#@cli : Author: Reptorian
+rep_fibonacci:
skip ${3=0},${4=0},${5=1}
check "$5&&($5==int($5))"
# _stack=={ 0= top left | 1= top right | 2= bottom left | 3= bottom right }
# _spiral_mode={ 0= non-spiral | 1= spiral_fill }
# _start_pos
# _iteration

dir={$1%4}

if $4==1 1 return fi

use_dim_lim={!$4}

if $4
 iter_lim=$4
else
 iter_lim=inf
 mw=${-max_w}
 mh=${-max_h}
fi

__size_n=2
size_1=1
size_2=2

__iter=2

command "swap: rv[-2,-1]"
command "join: a[-2,-1] $""1"

center_point={$5>1?int($5/2)}

if $5>1
 command "ins_north: ns={$__size_n*$5} $ns,$ns,1,1,$__iter swap join y"
 command "ins_south: ns={$__size_n*$5} $ns,$ns,1,1,$__iter join y"
 command "ins_west: ns={$__size_n*$5} $ns,$ns,1,1,$__iter swap join x"
 command "ins_east: ns={$__size_n*$5} $ns,$ns,1,1,$__iter join x"
else
 command "ins_north: $__size_n,$__size_n,1,1,$__iter swap join y"
 command "ins_south: $__size_n,$__size_n,1,1,$__iter join y"
 command "ins_west: $__size_n,$__size_n,1,1,$__iter swap join x"
 command "ins_east: $__size_n,$__size_n,1,1,$__iter join x"
fi

na={$2?4:2}

if $3
 if $2 #Spiral Mode#

  if $1%2 1,2,1,1,1-y
  else    1,2,1,1,y
  fi

  if $5>1 rs. {$5*100}%,,1 fi
  if $dir==0   ins_arg=ins_west,ins_south,ins_east,ins_north
  elif $dir==1 ins_arg=ins_west,ins_north,ins_east,ins_south
  elif $dir==2 ins_arg=ins_east,ins_south,ins_west,ins_north
  else         ins_arg=ins_east,ins_north,ins_west,ins_south
  fi
 else #Corner Mode#

  if $dir<2 1,2,1,1,y
  else      1,2,1,1,1-y
  fi

  if $5>1 rs. {$5*100}%,,1 fi
  if $dir==0   ins_arg=ins_east,ins_south
  elif $dir==1 ins_arg=ins_west,ins_south
  elif $dir==2 ins_arg=ins_east,ins_north
  else         ins_arg=ins_west,ins_north
  fi
 fi
else
 if $2 #Spiral Mode#

  if $1%2 2,1,1,1,x
  else    2,1,1,1,1-x
  fi

  if $5>1 rs. {$5*100}%,,1 fi
  if $dir==0   ins_arg=ins_north,ins_west,ins_south,ins_east
  elif $dir==1 ins_arg=ins_north,ins_east,ins_south,ins_west
  elif $dir==2 ins_arg=ins_south,ins_west,ins_north,ins_east
  else         ins_arg=ins_south,ins_east,ins_north,ins_west
  fi
 else #Corner Mode#

  if $1%2 2,1,1,1,1-x
  else      2,1,1,1,x
  fi

  if $5>1 rs. {$5*100}%,,1 fi
  if $dir==0   ins_arg=ins_south,ins_east
  elif $dir==1 ins_arg=ins_south,ins_west
  elif $dir==2 ins_arg=ins_north,ins_east
  else         ins_arg=ins_north,ins_west
  fi
 fi
fi

do

 if $__iter==$iter_lim break fi

 if $use_dim_lim
  if w#-1>$mw&&h#-1>$mh
   if $2
    if {"
     center_point=$center_point;
     mw=$mw;
     mh=$mh;
     xp=xm#-1+center_point;
     yp=ym#-1+center_point;
     lxp=xp-mw;
     rxp=xp+mw;
     typ=yp-mh;
     byp=yp+mh;
     cond_a=i(#-1,lxp,typ,0,0,0,0);
     cond_b=i(#-1,rxp,typ,0,0,0,0);
     cond_c=i(#-1,lxp,byp,0,0,0,0);
     cond_d=i(#-1,rxp,byp,0,0,0,0);
     cond_a&&cond_b&&cond_c&&cond_d;
    "} break fi
   else break
   fi
  fi
 fi

 ${arg0\ ($__iter%$na),$ins_arg}

 __size_n={$size_1+$size_2}
 size_1=$size_2
 size_2=$__size_n

 __iter+=1
while $__iter<$iter_lim
uncommand swap,join,ins_north,ins_south,ins_west,ins_east
#@cli rep_gv: eq. to 'rep_glass_vignette'.
rep_gv: rep_glass_vignette $*
#@cli rep_glass_vignette: refraction,_refraction_power,_len_size=1,_chromatic_aberration,-100%<=_preliminary_shift_x<=100%,-100%<=_preliminary_shift_y<=100%,_image_additional_zoom>0,-360<=_image_angle<=360,_distortion_scale_x,_distortion_scale_y,_distortion_scale_xy>0,-360<=_distortion_angle<=360,_distortion_offset_x,_distortion_offset_y,_subpixel>0,0<=_colorspace<=1,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest | 1=average | 2=linear | 3=grid | 4=bicubic | 5=lanczos }
#@cli : Distorts images as if it is based from the view of a bulged car mirror or camera len. This G'MIC filter is a heavily extended version of TR's Glass Vignette plugin made for Paint.NET by TechnoRobbo. It can also be used for generating abstract art as well.
#@cli : (eq. to 'rep_gv').
#@cli :
#@cli : 'refraction' defines the strength of distortion. The farther the values from 0, the greater the distortion is. It is recommended to use percentage alongside a number.
#@cli : '_refraction_power' defines the distortion factor within the refraction. The farther the values from 0, the greater the distortion is. It is recommended to use percentage alongside a number.
#@cli : '_len_size' is the size of distortion accordingly to the terminal ends of the lens distortion.
#@cli : '_chromatic_aberration' is the degree of aberration within channels. The farther the values from 0, the greater the distortion per channels would be. It is recommended to use percentage alongside a number.
#@cli : '_preliminary_shift_x' is the preshift of images before the distortion effect. This is used in the original plugin. It is recommended to use percentage alongside a number.
#@cli : '_preliminary_shift_y' is the preshift of images before the distortion effect. This is used in the original plugin. It is recommended to use percentage alongside a number.
#@cli : '_image_additional_zoom' defines the scaling based on scaling of coordinates of image within the distortion effect. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_image_angle' defines the angle of image within the distortion.
#@cli : '_distortion_scale_x' is the scaling of distortion within the x-axis. When this is set to 0, the ratio of image is used instead. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_distortion_scale_y' is the scaling of distortion within the y-axis. When this is set to 0, the ratio of image is used instead. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_distortion_scale_xy' is the scaling of distortion within the x and y axis at the same time.
#@cli : '_distortion_angle' is the angle of distortion effect. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_distortion_offset_x' is the displacement of distortion within the x-axis. It is recommended to use percentage alongside a number.
#@cli : '_distortion_offset_y' is the displacement of distortion within the y-axis. It is recommended to use percentage alongside a number.
#@cli : '_subpixel' is the level of subpixel sampling to be used.
#@cli : '_colorspace' defines the color space of the image to process distortion on.
#@cli : '_boundary' defines how the out-of-bound areas is to be behave.
#@cli : '_interpolation' defines the interpolation within distortion.
#@cli : Default values: '_refraction_power=0','_lensize=1','_chromatic_aberration=0','_preliminary_shift_x=0','_preliminary_shift_y=0','_image_zoom=0','_image_angle=0','_distortion_scale_x=1','_distortion_scale_y=1','_distortion_scale_xy=1','_distortion_angle=0','_distortion_offset_x=0','_distortion_offset_y=0','_subpixel=1','_colorspace=0','_boundary=3','_interpolation=5',
#@cli :
#@cli : Author: Reptorian.
rep_glass_vignette:
skip ${1=100%},${2=0%},${3=100%},${4=0%},${5=0},${6=0},${7=0},${8=0},${9=100%},${10=100%},${11=100%},${12=0},${13=100%},${14=100%},,${15=1}${16=0},${17=3},${18=2}

if $16 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$16,,srgb,ryb,cmy,,hcy,hsi,hsl,hsv,lab,lch,yiq,yuv,ycbcr,ycbcrglic,xyz,yes,k1} fi

convert_back=0

sub={1+abs($15)}

foreach {

	v +
		e[^-1] "Distorts image at angle of $12 with refraction factor of $1, chromatic aberration of $4, zoom factor of $7, preliminary shift of $5, preliminary shift of $6, scale x-axis distortion by $9 multiplied by $11, scale y-axis distortion by $10 multiplied by $11, refraction index by power of $2 placed at $13,$14 at angle of $8."
	v -

	if (s==3||s==4)&&$16
		convert_back=1
		if $16!=4
			$convert_colors_fwd.
		else
			if s==3 rgb2cmyk
			elif s==4 s c,-3 rgb2cmyk.. a c
			fi
		fi
	fi

	shift $5,$6,0,0,$17

	rs {$sub*100}%,,1

	f "*begin(
			const abr=((1-$1)-.001)/.999;
			const aberate=sqr(1*abr+(1-$4)*(1-abr));
			const offset_x=w/2*(1-$13);
			const offset_y=h/2*(1-$14);
			$9&&$10?(
				const mx=1/($9*(1/$11));
				const my=1/($10*(1/$11));
			):(
				w>h?(
					const mx=1/(1*(1/$11));
					const my=1/((h/w)*(1/$11));
				):(
					const mx=1/((w/h)*(1/$11));
					const my=1/(1*(1/$11));
				);
			);
			const ang=pi*($8/180);
			const dang=pi*($12/180);
			const distrad=1*10^($2/10);
			const cos_ang=cos(ang);
			const sin_ang=sin(ang);
			const cos_dang=cos(dang);
			const sin_dang=sin(dang);
			rot_x(a,b)=a*cos_ang-b*sin_ang;
			rot_y(a,b)=a*sin_ang+b*cos_ang;
			dist_rot_x(a,b)=a*cos_dang-b*sin_dang;
			dist_rot_y(a,b)=a*sin_dang+b*cos_dang;
			const sd=max(w,h)/min(w,h);
			const sx=w>h?sd:1;
			const sy=w>h?1:sd;
			rx(a)=((a/2+.5*sx)/sx)*w;
			ry(a)=((a/2+.5*sy)/sy)*h;
			eucl_norm(a,b)=sqrt(a^2+b^2);
			const cv=(eucl_norm(rot_x(sx,sy)/2,rot_y(sx,sy)/2))*(pi/2)*(max(w,h)/min(w,h))*$3;
			off_x_primary(a,b)=cos(a)*b*(abs($7)+1);
			off_y_primary(a,b)=sin(a)*b*(abs($7)+1);
			off_secondary(a,b,c)=a*(1-c)+b*c;
			const interpolation=min(abs($18),2);
			const mxsx=mx*sx;
			const mysy=my*sy;
			const expf=1-$1;
			s==1?result()=vectors(i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17)):
			s==2?result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17)):
			s==3?result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17),i(fax,fay,0,2,interpolation,$17)):
			s==4?result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17),i(fax,fay,0,2,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,3,interpolation,$17)):
			     result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17),i(fax,fay,0,2,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,3,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,4,interpolation,$17));
		);
		XX=((x+offset_x)/w-.5)*2;
		YY=((y+offset_y)/h-.5)*2;
		xx=dist_rot_x(XX,YY);
		yy=dist_rot_y(XX,YY);
		xx*=mxsx;
		yy*=mysy;
		XX=rot_x(xx,yy);
		YY=rot_y(xx,yy);
		far=norm(XX,YY);
		rad=atan2(YY*distrad,XX);
		eff=far/cv;
		RB=far^expf;
		RA=RB*aberate;
		off_xS=off_x_primary(rad,far);
		off_xA=off_x_primary(rad,RA);
		off_xB=off_x_primary(rad,RB);
		off_yS=off_y_primary(rad,far);
		off_yA=off_y_primary(rad,RA);
		off_yB=off_y_primary(rad,RB);
		offxA=off_secondary(off_xS,off_xA,eff);
		offyA=off_secondary(off_yS,off_yA,eff);
		offxB=off_secondary(off_xS,off_xB,eff);
		offyB=off_secondary(off_yS,off_yB,eff);
		fax=rx(offxA);
		fay=ry(offyA);
		fbx=rx(offxB);
		fby=ry(offyB);
		avg_fax_fbx=avg(fax,fbx);
		avg_fay_fby=avg(fay,fby);
		result();"

	rs {(1/$sub)*100}%,,{abs($18%6)+1}

	if $convert_back
		if $16!=4
			$convert_colors_bwd.
		else
			if s==4 cmyk2rgb
			elif s==5 s c,-4 cmyk2rgb.. a c
			fi
		fi
	fi

}
#@cli rep_cube2equi: eq. to 'rep_cube_map_to_equirectangular_panorama'.
rep_cube2equi: rep_cube_map_to_equirectangular_panorama $*
#@cli rep_cube_map_to_equirectangular_panorama: 0<=_top_face_placement<=3,0<=_bottom_face_placement<=3
#@cli : An extension of a code provided by 'Bartosz' at stackoverflow to solve conversion from cube map to equirectangular panorama. Source: https://stackoverflow.com/questions/34250742/converting-a-cubemap-into-equirectangular-panorama
#@cli : (eq. to 'rep_cube2equi').\n
#@cli : Default values: '_top_face_placement=1','_bottom_face_placement=_top_face_placement'\n
#@cli : Author: Reptorian.
rep_cube_map_to_equirectangular_panorama:
skip ${1=1}

if $#>2 error narg(\$\*)<3==F fi

if $1<0||$-1<0||$1>3||$-1>3||!isint($1)||!isint($-1) error intargs(\$\*)==F\ ||\ (\ (\$"1"<3==F||\$"2"<3==F)\ ||\ absargs(\$\*)==F\ ) fi

foreach {

	v + e[^-1] "Convert cube map to equirectangular panorama using face $1 for top placement and face $-1 for bottom placement!" v -

	ratio={h/w}

	if $ratio<1.5 r {w},{.75*w},100%,100%,5
	else r {1.5*h},{h},100%,100%,5
	fi

	f "begin(
				const a1=$1;
				const a2=$1+1;
				const b1=$-1;
				const b2=$-1+1;
				const edge=h/3;
				const tl_edge=edge*a1;
				const tr_edge=edge*a2;
				const bl_edge=edge*b1;
				const br_edge=edge*b2;
				const bottom_edge=edge*2;
		);
		(y>=edge&&y<bottom_edge)||(y<bottom_edge?(x>=tl_edge&&x<tr_edge):(x>=bl_edge&&x<br_edge))?(i):(
			(j(0,-1)&&j(1,0))?(avg(j(0,-1),j(1,0))):
			(j(-1,0)&&j(0,-1))?(avg(j(-1,0),j(0,-1))):
			(j(-1,0)&&j(0,1))?(avg(j(-1,0),j(0,1))) :
			(j(0,1)&& j(1,0))?(avg(j(0,1),j(1,0))) :
			j(1,0)?j(1,0):
			j(-1,0)?j(-1,0):
			j(0,1)?j(0,1):
			j(0,-1)?j(0,-1)
			;
		);"

	{w},{w/2},100%,100%,"
		begin(
			const ww=w-1;
			const hh=h-1;
			const cubeface_w=w#0/4;
			const cubeface_h=(h#0-.5)/3;
			const xpb=$-1<2;
			const ypb=!($-1%3)?1;
			const xpt=$1<2;
			const ypt=($1%3)?1;
			yp=-1;
		);
		if(y!=yp,v=1-y/hh;theta=v*pi;++yp;);
		u=x/ww;
		phi=u*2*pi;
		xc=cos(phi)*sin(theta);
		yc=cos(theta);
		zc=sin(phi)*sin(theta)*-1;
		a=max(abs(xc),abs(yc),abs(zc));
		xa=xc/a;
		ya=yc/a;
		za=zc/a;
		xa==1?(
			xp=((za+1)/2-1)*cubeface_w;
			xo=0;
			yp=((ya+1)/2)*cubeface_h;
			yo=cubeface_h;
		):
		xa==-1?(
			xp=((za+1)/2)*cubeface_w;
			xo=cubeface_w*2;
			yp=((ya+1)/2)*cubeface_h;
			yo=cubeface_h;
		):
		ya==1?(
			xp=((($-1%2?xa:za)+1)/2-xpb)*cubeface_w;
			xo=cubeface_w*$-1;
			yp=((($-1%2?za:xa)+1)/2-ypb)*cubeface_h;
			yo=2*cubeface_h;
		):
		ya==-1?(
			xp=((($1%2?xa:za)+1)/2-xpt)*cubeface_w;
			xo=cubeface_w*$1;
			yp=((($1%2?za:xa)+1)/2-ypt)*cubeface_h;
			yo=0;
		):
		za==1?(
			xp=((xa+1)/2)*cubeface_w;
			xo=cubeface_w*3;
			yp=((ya+1)/2)*cubeface_w;
			yo=cubeface_h;
		):
		za==-1?(
			xp=((xa+1)/2-1)*cubeface_w;
			xo=cubeface_w;
			yp=((ya+1)/2)*cubeface_w;
			yo=cubeface_h;

		):(
			nan;
		);
		xp=abs(xp)+xo;
		yp=abs(yp)+yo;
		I(#0,xp,yp,z,1,1);
		"

	rm..

}
#@cli rep_equi2cube: eq. to 'rep_equirectangular_panorama_to_cube_map'.
rep_equi2cube: rep_equirectangular_panorama_to_cube_map $*
#@cli rep_equirectangular_panorama_to_cube_map: 0<=_top_face_placement<=3,0<=_bottom_face_placement<=3
#@cli : An extension of a code provided by 'Salix alba' at stackoverflow to solve conversion from equirectangular panorama to cube map. Source: https://stackoverflow.com/questions/29678510/convert-21-equirectangular-panorama-to-cube-map
#@cli : (eq. to 'rep_equi2cube').\n
#@cli : Note: _bottom_face_placement will use placement of _top_face_placement when not specified.
#@cli : Default values: '_top_face_placement=1','_bottom_face_placement=_top_face_placement'\n
#@cli : Author: Reptorian.
rep_equirectangular_panorama_to_cube_map:
skip ${1=1}

if $#>2 error narg(\$\*)<3==F fi
if $1<0||$-1<0||$1>3||$-1>3||!isint($1)||!isint($-1) error intargs(\$\*)==F\ ||\ (\ (\$"1"<3==F||\$"2"<3==F)\ ||\ absargs(\$\*)==F\ ) fi

v + e[^-1] "Convert equirectangular panorama to cube map using face $1 for top placement and face $-1 for bottom placement!" v -

foreach {

	ratio={w/h}

	if $ratio<2 r {w},{.5*w},100%,100%,5
	else r {2*h},{h},100%,100%,5
	fi

	{w},{.75*w},100%,100%,"begin(
			edge=w/4;
			outImgToXYZ(xc,yc,face,edge)=(
				a=2*xc/edge;b=2*yc/edge;
				if(face==0,ret=[-1,1-a,3-b];); #Left Face#
				if(face==1,ret=[a-3,-1,3-b];); #Front Face#
				if(face==2,ret=[1,a-5,3-b];); #Right Face#
				if(face==3,ret=[7-a,1,3-b];); #Back Face#

				if($1==0,if(face==4,ret=[1-b,1-a,1];); #Top Face#
				,if($1==1,if(face==4,ret=[a-3,1-b,1];);
				,if($1==2,if(face==4,ret=[b-1,a-5,1];);
				,if($1==3,if(face==4,ret=[7-a,b-1,1];);
				);
				);
				);
				);

				if($-1==0,if(face==5,ret=[b-5,1-a,-1;]); #Bottom Face#
				,if($-1==1,if(face==5,ret=[a-3,b-5,-1;]);
				,if($-1==2,if(face==5,ret=[5-b,a-5,-1;]);
				,if($-1==3,if(face==5,ret=[7-a,5-b,-1;]);
				);
				);
				);
				);
				ret;
			);
		);
		face2=int(x/edge);
		if(y<edge,face2=4;);
		if(y>edge*2,face2=5;);
		coord3=outImgToXYZ(x,y,face2,edge);
		theta=atan2(coord3[1],coord3[0]);
		r=norm(coords3[0],coords3[1]);
		phi=atan2(coord3[2],r);
		uf=((theta+pi)/pi)*edge*2;
		vf=((pi/2-phi)/pi)*edge*2;
		if($1==$-1,if((x>=edge*$1&&x<edge*($1+1))||(y>=edge&&y<edge*2),i(#0,uf,vf,z,c,2,2););, #If first and last variable are the same, then visible output will show top and bottom faces along the same face#
		if(y<edge*2,if((x>=edge*$1&&x<edge*($1+1))||(y>=edge&&y<edge*2),i(#0,uf,vf,z,c,2,2););,if((x>=edge*$-1&&x<edge*($-1+1))||(y>=edge&&y<edge*2),i(#0,uf,vf,z,c,2,2);););); #If first and last variable are not the same, then visible output will show top and bottom faces along the same face#"

	rm..
}
#@cli rep_trps: eq. to 'rep_tr_pixel_sharpener'.
rep_trps: rep_tr_pixel_sharpener $*
#@cli rep_tr_pixel_sharpener: sharpen,_internal_blur>=0,_type= { 0=Photo | 1= Horizontal | 2= Vertical | 3= One-Axis Angle | 4= Two-Axis Angle | 5= Two-Axis Disconnected},-360<=_sharpening_angle_a<=360,-360<=_sharpening_angle_b<=360
#@cli : Extended version of the original TR's Pixel Sharpener for Paint.NET. Some code were changed to make more sense or is more practical. Negative values are enabled for first variable in the G'MIC version. The original code this was based on was created by TechnoRobbo. Source code - https://forums.getpaint.net/topic/26783-trs-pixel-sharpener-plugin-v20-dec-21-2014/
#@cli : (eq. to 'rep_trps').\n
#@cli : Default values: '_internal_blur=0','_blur_type=0','_sharpening_angle=0'\n
#@cli : Author: Reptorian.
rep_tr_pixel_sharpener:
skip ${2=0},${3=0},${4=0},${5=0}
f "begin(
		const ang=pi*($4/180);
		const ang2=pi*($5/180);
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		const cos_ang2=cos(ang2);
		const sin_ang2=sin(ang2);
		rot_x(a,b)=a*cos_ang-b*sin_ang;
		rot_y(a,b)=a*sin_ang+b*cos_ang;
		rot_y_alt(a,b)=a*sin_ang2+b*cos_ang2;
		const blur=(round(abs($2)+1)-1)*2+3;
		const qblur=sqr(blur);
		const eblur=floor(blur/2);
		const sblur=floor(blur/-2);
		const coeff=$1/100;
		const mult=qblur*coeff+eblur/round(abs($2)+1);
		const choice=abs($3)<=2?abs($3):0;

		$3==5?(
			fnx()=x+rot_x(j,k);
			fny()=y+rot_y_alt(j,k);
		):
		$3==4?(
			fnx()=x+rot_x(j,k);
			fny()=y+rot_y(j,k);
		):
		$3==3?(
			fnx()=x+rot_x(j,0);
			fny()=y+rot_y(j,0);
		):
		$3==2?(
			fnx()=x;
			fny()=y+k;
		):
		$3==1?(
			fnx()=x+j;
			fny()=y;
		):(
			fnx()=x+j;
			fny()=y+k;
		);

	);

	sum=i*mult;

	for(k=int(sblur),k<=eblur,++k,

		for(j=int(sblur),j<=eblur,++j,

			if(k!=0&j!=0,
				nx=fnx();
				ny=fny();
				nfcalc=i(nx,ny,z,c,0,1);
				sum-=nfcalc*coeff;
			);

		);

	);
	sum;"
#@cli rep_trif: eq. to 'rep_technorobbo_intense_filtering'.
rep_trif: rep_technorobbo_intense_filtering $*
#@cli rep_technorobbo_intense_filtering: 0<=hue<=360,_gain,_mix,_style_based_on={ 0=Original | 1=Grayscale | 2=Hue },_use_255={ 0=1 | 1=255 }
#@cli : This command is a color filter and augmenter. The code is based from TechnoRobbo's Intense Filtration source code - https://forums.getpaint.net/topic/30148-trs-intense-filtration-v-13-oct-092014/
#@cli : (eq. to 'rep_trif').\n
#@cli : Warning: This command only works on images with 3 or 4 channel image. It doesn't discriminate between CMYK and RGBA image! So, make sure they're all RGB/RGBA images before using this command!\n
#@cli : 'hue' defines the color to augment.
#@cli : '_gain' defines the coefficient of image or number to multiple on data based on original image.
#@cli : '_mix' defines the strength of the filter.
#@cli : '_style_based_on' defines the style output of the filter based on corresponding name for number defined by filter.
#@cli : '_use_255' defines the maximum value for RGB image. If using float values from 0-1 range, then set to 0, else set to 1.\n
#@cli : Default values: '_gain=2','_mix=1','_style_based_on=0','_use_255=1'\n
#@cli : Author: Reptorian.
rep_technorobbo_intense_filtering:
skip ${2=2},${3=1},${4=0},${5=1}
hue={abs($1)-floor(abs($1)/360)*360}
($hue^1^1)
hsv2rgb. /. 255

repeat $!-1 {
	if s#$>==3||s#$>==4
		sh[$>] 0,2

		f. "begin(
			endval(a,b)=(a*mix+(b-b*mix));
			const mv=$5?255:1;
			const mixval=abs($3)>1?1:abs($3);
			const mix=1-mixval;
			const thresh=abs($2)>1?mv/2:mv;
			const himax=mv*abs($2)-thresh;
			$4==2?result()=endval(gv,tmpv):
			$4==1?result()=endval(gray,tmpv):
					result()=endval(cv,tmpv);
			);
			tmpv=i*abs($2)*i(#-2,0,0);
			tmpv=tmpv>mv?mv:tmpv;
			gray=((i0+i1+i2)/3)*abs($2);
			gray=gray>mv?mv:gray;
			cv=i*abs($2);
			cv=cv>thresh?(cv-thresh)*(mv-thresh)/himax+thresh:cv;
			graymix=gray/mv;
			gv=i(#-2,0,0)*graymix*mv*abs($2);
			gv>mv?mv:gv;
			result()"

		rm.
	else
		v + error "Image \["$>"\] contains "{s#$>}" channels which does not meet the requirement of 3 or 4 channels!" v -
	fi
}
rm.
#@cli rep_colmt: eq. to 'rep_color_modulo_texture'.
rep_colmt: rep_color_modulo_texture $*
#@cli rep_color_modulo_texture: colorspace={ 0=rgb | 1=ryb | 2=cmy | 3=cmyk | 4=hsi | 5=hsl | 6=hsv | 7=lab | 8=lch | 9=yiq | 10=yuv | 11=ycbcr | 12=ycbcrglic | 13=xyz | 14=yes },_include_alpha={ 0=no_alpha | 1=alpha},0<=_channel_order<{ 6 | 24 },_flip_diagonal={ 0=do_not_flip | 1=flip },sublevel>=0,interpolation>=0,_modulo_method_1= { 0=Mod | 1=Reflected Mod | 2=Divmod | 3=Reflected Divmod },_modulo_value_a_1>0,_modulo_value_b_1>0,_angle_1<=360,_value_shift_1>0,_centered_1= { 0=Not centered | 1=Centered },_negate_mod_1= { 0=Not Negated | 1=Negated },_normalize_bool_1= { 0=Do not Normalize | 1=Normalize }..._negate_mod_3
#@cli : Inspired by MadJik's Color Modulo Texture for Paint.NET, this is a extension of that filter converted into G'MIC form. New features is being able to change color space, allow alpha, and anti-aliasing.
#@cli : (eq. to 'rep_colmt').\n
#@cli : '_modulo_method' defines what method of modulo operation would be applied to each channel.
#@cli : '_modulo_value_a' and 'modulo_value_b' is value used for calculation of modulo of function per channel.
#@cli : '_angle' defines the function angle.
#@cli : '_centered' defines if the function are centered.
#@cli : '_value_shift' adds value to function before modulo calculation.
#@cli : '_centered' is used to define whether the modulo is center.
#@cli : '_negate_mod' negates the end modulo value.
#@cli : '_normalize_bool' is used to normalize values. Note - This can be used to make the filter behave similar to Madjik's Color Modulo Texture filter.
#@cli : '_diagonal_flip' is used to flip diagonal function.
#@cli : '_colorspacemode' defines the color space of modulo.
#@cli : '_contain_alpha' adds alpha value to modulo. In the case of CMYK, this option is nullified, and K is used to replace alpha instead.
#@cli : '_subpixel_processing_level' defines the subpixel processing level.
#@cli : '_interpolation' defines the method of interpolation.
#@cli : '_channel_num' defines the order of channel.
#@cli : Default values: '_include_alpha=0','_channel_order=0','_flip_diagonal=0','_sublevel=1','_interpolation=1','_modulo_method_n=3','_modulo_value_a_n=196','_modulo_value_b_n=255','_angle_n=0','_value_shift_n=0','_center_n=0','_negate_n=0','_normalize_n=0'
rep_color_modulo_texture:
skip ${2=0},${3=0},${4=0},${5=1},${6=5},\
${7=3},${8=196},${9=255},${10=0},${11=0},${12=1},${13=0},${14=0},\
${15=$7},${16=$8},${17=$9},${18=$10},${19=$11},${20=$12},${21=$13},${22=$14},\
${23=$15},${24=$16},${25=$17},${26=$18},${27=$19},${28=$20},${29=$21},${30=$22},\
${31=$23},${32=$24},${33=$25},${34=$26},${35=$27},${36=$28},${37=$29},${38=$30}

cs={$1%15} # Color Space
if $cs bwd_cs=${arg1\ $cs,ryb2rgb,cmy2rgb,cmyk2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,ycbcr2rgb,ycbcrglic2rgb,xyz82rgb,yes82rgb} fi
kalp={$2||$cs==3} # Keep Alpha
ts:=3+$kalp
flip_diag,sublevel,interpolation={m=abs($6);[$4&1,abs($5)+1,max(1,m+(m>3?1))]}

old_status=${}

m cmd_modargs:"
	check inrange($""1,0,inf,1,0)&&inrange($""2,0,inf,1,0)&&$""1!=$""2
	u {\"mod_a=$""1;
		 mod_b=$""2;
		 mod_diff=abs(mod_a-mod_b);
		 mod_b>mod_a?(
		 	min_mod=mod_a;
		 	max_mod=mod_b;
		 ):(
		 	min_mod=mod_b;
		 	max_mod=mod_a;
		 );
		 mod_div=max_mod/(max_mod-min_mod);
		 [min_mod,max_mod,mod_diff,mod_div];
		 \"}"

m __$0_vars:"vars_$""1={$""2&3},${cmd_modargs\\ $""{3-4}},{[cos($""5Â°),sin($""5Â°)]},$""{6-9}"

c0,c1,c2,c3:=vector(#4,[${rep_permutation_index2list\ $ts,$3},3])

__$0_vars $c0,${7-14}
__$0_vars $c1,${15-22}
__$0_vars $c2,${23-30}
__$0_vars $c3,${31-38}

um __$0_vars,cmd_modargs
status $old_status

vector_args=$c0,$vars_0,\
            $c1,$vars_1,\
            $c2,$vars_2,\
            $c3,$vars_3

foreach {
	od:=w,h rm

	{[$od]*$sublevel},1,$ts,:"begin(
			const max_x=w-1;
			const max_y=h-1;
			const cx=max_x/2;
			const cy=max_y/2;
			const sublevel=$sublevel;
			const flip_diag=$flip_diag;

			const base_surface=0;
			const modulo_method=1;
			const minmod=2;
			const maxmod=3;
			const moddiff=4;
			const moddiv=5;
			const cos_ang=6;
			const sin_ang=7;
			const value_shift=8;
			const center=9;
			const negate=10;
			const normalize=11;

			rot_x(a,b,cos_ang,sin_ang)=a*cos_ang-b*sin_ang;
			rot_y(a,b,cos_ang,sin_ang)=a*sin_ang+b*cos_ang;

			calc_surface_axis(x,y,current_center,current_cos_ang,current_sin_ang,current_value_shift,is_y_axis)=(
				current_center?(
						ix=x-cx+current_value_shift;
						iy=y-cy+current_value_shift;
				):(
						ix=x+current_value_shift;
						iy=y+current_value_shift;
				);
				if(is_y_axis
				,rot_x(ix,iy,current_cos_ang,current_sin_ang);
				,rot_y(ix,iy,current_cos_ang,current_sin_ang);
				);
			);

			calc_surface_diag(x,y,current_center,current_cos_ang,current_sin_ang,current_value_shift,is_secondary_diag)=(
				current_center?(
					ix=x-cx;
					iy=y-cy;
				):(
					ix=x;
					iy=y;
				);
				xx=rot_x(ix,iy,current_cos_ang,current_sin_ang);
				yy=rot_y(ix,iy,current_cos_ang,current_sin_ang);
				current_value_shift+(is_secondary_diag?abs(abs(xx)+abs(yy)):abs(abs(xx)-abs(yy)));
			);

			rm(a,current_mod_diff,current_negate,current_normalize)=( # Regular Modulo
				result=a%(current_mod_diff+eps);
				if(current_negate,result=current_mod_diff-result;);
				if(current_normalize&&current_mod_diff>255,result*255/current_mod_diff,cut(result,0,255));
			);
			cm(a,current_mod_diff,current_negate,current_normalize)=( # Continuous Modulo
				result=a%(current_mod_diff*2);
				result=current_mod_diff-abs(current_mod_diff-result);
				if(current_negate,result=current_mod_diff-result;);
				if(current_normalize&&current_mod_diff>255,result*255/current_mod_diff,cut(result,0,255));
			);
			rdm(a,max_modulo,current_mod_div,current_negate,current_normalize)=( # Regular Divisive Modulo
				result=(a*current_mod_div)%(max_modulo+eps);
				if(current_negate,result=max_modulo-result;);
				if(current_normalize&&max_modulo>255,result*255/max_modulo,cut(result,0,255));
			);
			cdm(a,max_modulo,current_mod_div,current_negate,current_normalize)=( # Continuous Divisive Modulo
				temp=(a*current_mod_div)%(max_modulo*2);
				result=max_modulo-abs(max_modulo-temp);
				if(current_negate,result=max_modulo-result;);
				if(current_normalize&&max_modulo>255,result*255/max_modulo,cut(result,0,255));
			);

			all_vars=["$vector_args"];    # Array of vector_args
			start_indexes=expr('x*12',4); # Tells us the position of subarray
			vars=vector(#12,nan);         # Initialize vars. Used for building modulo effect
			old_c=-1;
		);
		if(c!=old_c,vars=all_vars[start_indexes[c],12]);
		old_c=c;
		surface=(
			surface_index=vars[base_surface];
			surface_index<2?(
				calc_surface_axis(x,y,vars[center],vars[cos_ang],vars[sin_ang],vars[value_shift],surface_index);
			):(
				diagonal_mode=xor(flip_diag,surface_index&1);
				calc_surface_diag(x,y,vars[center],vars[cos_ang],vars[sin_ang],vars[value_shift],diagonal_mode);
			);
		)/sublevel;
		modulo_method_index=vars[modulo_method];
		modulo_method_index==3?cdm(surface,vars[maxmod],vars[moddiv],vars[negate],vars[normalize]):
		modulo_method_index==2?rdm(surface,vars[maxmod],vars[moddiv],vars[negate],vars[normalize]):
		modulo_method_index==1? cm(surface,vars[moddiff],vars[negate],vars[normalize]):
		                        rm(surface,vars[moddiff],vars[negate],vars[normalize]);
		"

	if $cs $bwd_cs fi
	if $sublevel>1 r $od,1,100%,$interpolation fi
}
#@cli rep_shape_brick: brick_width>0,brick_height>0,_mortar_width>0,_mortar_height>0,_outline>=0,_bevel>=0,_bevel_style= { 0=round | 1=inverse_round | 2=diamond },-1>=_shift_val>=1,_shift_direction= { 0=horizontal | 1=vertical },_flip_offset= { 0= Do Not Flip | 1= Flip },_subpixel_processing_level>=0
#@cli : 'brick_width' - Width of brick(s)
#@cli : 'brick_height' - Height of brick(s)
#@cli : '_mortar_width' - Filling width between brick(s)
#@cli : '_mortar_height' - Filling height between brick(s)
#@cli : '_outline' - Thickness of outline of brick(s)
#@cli : '_bevel' - Beveling of corners of brick(s)
#@cli : '_bevel_style' - Form of beveling of brick(s)
#@cli : '_shift_val' - Shift of bricks
#@cli : '_shift_direction' - Direction of shift
#@cli : '_flip_offset' - Determines which order the offset from original, to original.
#@cli : '_subpixel_level' - Degree of antialiasing of brick(s)\n
#@cli : Default values: '_mortar_width','_mortar_height','_outline'\n
#@cli : Author: Reptorian.
rep_shape_brick:
skip ${3=10},${4=10},${5=0},${6=0},${7=0},${8=1},${9=0},${10=0},${11=0}
v -
	sublevel={abs($11)}
	sublevel+=1
	brick_width={abs($1)*$sublevel}
	brick_height={abs($2)*$sublevel}
	mortar_width={abs($3)*$sublevel}
	mortar_height={abs($4)*$sublevel}
	outline={abs($5)*$sublevel}
	bevel={abs($6)*$sublevel}
	bevel_style={abs($7)>2?2:abs($7)}
	shift_val=$8
	shift_direction=$9
	flip_offset=$10

	if $bevel_style==2 brick_bevel_style="Diamond"
	elif $bevel_style==1 brick_bevel_style="Inverse-Round"
	else brick_bevel_style="Round"
	fi

	if $shift_direction dir="Every two column has displacement of"
	else dir="Every two row has displacement of"
	fi

	if abs($shift_val) no={$shift_val*100} offset=""$dir" "$no""%" from original point."
	else offset=""
	fi

	if $outline linethick={abs($5)} linethick=" with outline of "$linethick" px"
	else linethick=""
	fi
v +

e[] "Generate brick of "$brick_width" px and "$brick_height" px with mortar width of "$mortar_width" px and mortar height "$mortar_height" px"$linethick". "$offset""

v +

if !(($brick_width&&$brick_height)||$bevel) v + error "Brick Area must be greater than 0!" v - fi

if $bevel

	if $bevel_style==0||$bevel_style==1 shape_circle {$bevel*2}
	else shape_diamond {$bevel*2} fi

	*. 2

	if $outline
		if $bevel_style==0||$bevel_style==1 shape_circle {($bevel+$outline)*2}
		else shape_diamond {floor($bevel+($outline*(cos(45/180*pi)+sin(45/180*pi))))*2} r. {($bevel+$outline)*2},{($bevel+$outline)*2},100%,100%,0,0,.5,.5 fi
		j[-1] [-2],.5~,.5~,0,0,.5,[-2]
		rm..
	fi

	s. x,2
	s[-2,-1] y,2

fi

{$brick_width<$bevel*2?$bevel*2:$brick_width},{$brick_height<$bevel*2?$bevel*2:$brick_height},1,1,1

if $outline expand. xy,$outline fi +. 1

if $bevel if $bevel_style==1 negate[-5--2] +f[-5--2] i==2?0:1 fi fi

if $bevel

	if $bevel_style==1
		j[-5] [-9],1~,1~,0,0,1,[-4]
		j[-5] [-8],1~,0~,0,0,1,[-3]
		j[-5] [-7],0~,1~,0,0,1,[-2]
		j[-5] [-6],0~,0~,0,0,1,[-1]
		rm[-4--1]
	else
		j[-1] [-5],0~,0~
		j[-1] [-4],0~,1~
		j[-1] [-3],1~,0~
		j[-1] [-2],1~,1~
	fi

	rm[-5--2]

fi

r. {w+$mortar_width},{h+$mortar_height},100%,100%,0,0,{!$flip_offset},{!$flip_offset}

if $shift_val
	if $shift_direction +shift. 0,{($shift_val/2)*100}%,0,0,2 a[-2,-1] x if $flip_offset mirror. x fi
	else +shift. {($shift_val/2)*100}%,0,0,0,2 a[-2,-1] y if $flip_offset mirror. y fi
	fi
fi

if $sublevel-1 rs. {(1/$sublevel)*100}%,,5 fi

v -
#@cli rep_z_render: _reverse_z_layer={ 0=first_layer | last_layer },_z_depth_value>0,_mirror_order={ 0=do_not_mirror | 1=mirror },_color_z_render={ 0=image_z_per_luminosity | 1=image_z_per_channel }
#@cli : Generates the resulting image based on z-map layer.\n
#@cli : '_reverse_z_layer' determines whether the first or last layer should be used to determine the "frame" to use.
#@cli : '_z_depth_value' can be described as how smooth the transition between images should be
#@cli : '_mirror_order' can be used to reorder the image transition
#@cli : '_color_z_render' sets whether the transition are separated by channels or not.
#@cli : Note: Try to use gradient as the z-layer.\n
#@cli : Default values: '_reverse_layer=0','_z_depth_value=255','_mirror_order=0','_color_z_render=0'\n
#@cli : Author: Reptorian.
rep_z_render:
skip ${1=0},${2=255},${3=0},${4=0}
if $!<3 v + error "You need at least 3 images!" v - fi

if $1 rv[0,-1] rv[0,-2] fi

if !$4 to_gray[0] fi

a[^0] z
n[0] 0,$2
r[^0] 100%,100%,$2,100%,3

if $3 negate[0] fi

r[0] 100%,100%,100%,{s#-1}
f[0] i(#-1,x,y,i,c,3,1)
k[0]
#@cli rep_acb: (eq. to rep_autofill_coloring_book)
rep_acb: rep_autofill_coloring_book $*
#@cli rep_autofill_coloring_book: 0<threshold<1,_dilate_erode>=0,_color_mode={ 0=hard | 1= soft },0<=_alpha_threshold<1,_seed
#@cli : rep_autofill_coloring_book is used for automatically coloring pictures with lines.\n
#@cli : _threshold defines the value that is to be split into binary values. If it over _threshold, then it becomes 1.
#@cli : _dilate_erode defines the increase/decrease in line. Values over 0 implies increase in thickness while values less than 1 implies decrease in thickness.
#@cli : _color_mode defines whether the black line is going to be black or smooth.
#@cli : _alpha threshold defines the value of alpha to be cutoff by percentage
#@cli : _seed can be seen as premade random result.\n
#@cli : Default values: '_threshold=128','_dilate_erode=0','_color_mode=1','_alpha_threshold=0','_seed='
rep_autofill_coloring_book:
skip ${2=0},${3=1},${4=0},${5=}
if narg($5) srand $5 fi

foreach {
 sh 0,2
 if s#0==4 sh.. {s} vv={iv#-1} fi
 rep_acb_color[1] ${1-3}

 if s#0==4
  if ($4>0&&$4<1)&&$vv f. i>(iM*$4)?255:0 fi
 fi

 k[0]

}

rep_acb_color:
if $1<=0 v + error "threshold must be greater than 0" v - fi
if $1>=1 v + error "threshold must be less than 1" v - fi

to_gray n 0,1

if !iv#-1 v + error "Invalid Image!" v - fi
if $3 +store line fi

f i>=$1?1:0

if abs($2)
 if $2<0 dilate {abs($2)}
 else erode {abs($2)}
 fi
fi

label_fg 0,1

cv={iM}
min_t=1
max_t={round(16777215/$cv)}
nt={$min_t}
ntt={$max_t}

1

repeat $cv {
 1,1,1,1,round(u($nt,$ntt))
 nt={iM#-1+1}
 ntt={$nt+$max_t}
 a[-2,-1] x
}

repeat $cv {
 temp_1={i(round(u(1,$cv)))}
 temp_2={i(round(u(1,$cv)))}
 if $temp_1!=$temp_2
  f. i==$temp_1?$temp_2:(i==$temp_2?$temp_1:i)
 fi
}

{w},1,1,3,[i0#-1%256,floor(i0#-1/256)%256,floor(i0#-1/(256^2))]

map... . rm[-2,-1]

if $3
 +select_color 0,0,0
 inpaint_pde [1],0,0,0
 rm.
 $line
 f.. i*i0#-1
 rm.
fi
#@cli rep_recc: eq. to 'rep_reverse_engineer_color_curves'.
rep_recc: rep_reverse_engineer_color_curves $*
#@cli rep_reverse_engineer_color_curves: _array_size>0
#@cli : Automatically reverse engineer color curves. All images after [0] will be converted into color curve map while [0] is the reference image.
#@cli : (eq. to 'rep_recc').
#@cli : '_array_size' is used to define the depth of gradient map, if you're using float, then you need to scale image to something higher than 256. If array size is not inserted, then this filter will automatically find the array size.
#@cli : Default values: '_array_size=n/a'
#@cli :
#@cli : Author: Reptorian.
rep_reverse_engineer_color_curves:
skip ${1=}

if !$!>1 error n(imgs)>2==F fi

ww={w#0}
hh={h#0}
dd={d#0}
ss={s#0}

if narg($1)
	if im#0<0 mv={abs(im#0)+abs($1)} -[0] {im#0}
	else mv={abs($1)} fi
else
	if im#0<0 -[0] {im#0} fi
	mv={iM#0}
fi

store[0] refimg

repeat $! {
	img_id=$>
	pos={$img_id+1}
	if w#$img_id!=$ww||h#$img_id!=$hh||d#$img_id!=$dd||s#$img_id!=$ss error dims(#$pos)!=dims(ref) fi
}

foreach {
	$refimg
	_rep_recc[0,-1] $mv
}

_rep_recc:
rv

$1,1,1,100% .

repeat s {
	sh $>
	rm[-4--1]
	f[-4] i(#-2,i,0,0)+=i#-3-i#-4;i(#-1,i,0,0)+=1;i
}

+eq. 0
+.. .
/... ..
rm..

repeat s {
	sh.. $>
	sh.. $>
	inpaint_pde.. .
	rm[-2,-1]
}

f.. i+x
cut.. 0,{$1-1}

k..
#@cli rep_regm: eq. to 'rep_reverse_engineer_gradient_map'.
rep_regm: rep_reverse_engineer_gradient_map $*
#@cli rep_reverse_engineer_gradient_map: _array_size>0,_norm={ 0=do_not_norm | 1=norm }
#@cli : Automatically reverse engineer gradient map. All images after [0] will be converted into gradient map while [0] is the gray reference.
#@cli : (eq. to 'rep_regm').
#@cli : '_array_size' is used to define the depth of gradient map, if you're using float, then you need to scale image to something higher than 256. If array size is not inserted, then this filter will automatically find the array size.
#@cli : '_normalize' is used to normalize image to max array id number. Useful when using float as reference.
#@cli : Default values: '_array_size=n/a','_normalize=0'
#@cli :
#@cli : Author: Reptorian, Garagecoder.
rep_reverse_engineer_gradient_map:
skip ${1=},${2=0}

if !$!>1 error n(imgs)>2==F fi

ww={w#0}
hh={h#0}
dd={d#0}

if s#0==2 s[0] c rm[1]
elif s#0==3 to_rgb[0] rgb2hsl8[0] channels[0] 2
elif s#0==4 s[0] c,-3 to_rgb[0] rm[1] rgb2hsl8[0] channels[0] 2
fi

if narg($1)
 if im#0<0 mv={abs(im#0)+abs($1)} -[0] {im#0}
 else mv={abs($1)} fi
else
 if im#0<0 -[0] {im#0} fi
 mv={iM#0}
fi

if $2&&narg($1) n[0] 0,{$mv-1} fi

store[0] refimg

repeat $! {
 pos={$>+1}
 if w#$>!=$ww||h#$>!=$hh||d#$>!=$dd error dims(#$pos)!=dims(ref) fi
}

foreach {
 $refimg
 gcd_regm[0,-1] $mv
}

gcd_regm:
rv

round.. 1

$1,1,1,{s#-1}

f[0] "I[#-1,i]+=I(#1,x,y,z);i"

+histogram[0] $1,0,$1
+eq. 0
add[-2] [-1]
div[-3,-2]

inpaint_pde.. .

rm[-4,-3,-1]
#@cli rep_primelist:
#@cli : Return vector of boolean values up to the maximum image value rounded. Values are found by whether the argument number within vector is a prime.
rep_primelist:

maxn=0

repeat $! maxn={ceil(max($maxn,max(abs(im#$>),iM#$>)))} done

u {"const mv="$maxn";
	prime=vectormv(1);
	prime[0]=prime[1]=0;
	for(p=2,sqr(p)<=mv,++p,
		if(prime[p],
			for(v=sqr(p),v<=mv,v+=p,
				prime[v]=0;
			);
		);
	);
	(prime)"}
#@cli rep_isprime:
#@cli : Values of image are changed to either 1 or 0 depending on the value is a prime number.
rep_isprime:
f "begin(prime=["${-rep_primelist}"];);
	prime[round(abs(i))];"
#@cli rep_prime_surface: _width,_height,_negate={ 0=do_not_negate | 1=negate },_mirror
#@cli : Creates a simple prime surface by combining rep_primelist and spiralbw.
#@cli : Default values: '_width=last_image_width','_height=last_image_height'
rep_prime_surface:
skip ${1=w},${2=h},${3=1},${4=0}

spiralbw {abs($1)},{abs($2)}

local[-1] {

	if $3 negate. fi

	if abs($4)==1 mirror. x
	elif abs($4)==2 mirror. y
	fi

	f "begin(prime=["${-rep_primelist}"];);
		prime[round(abs(i))];"

}
#@cli rep_ced8: eq. to 'rep_color_existence_distribution_rgb8'.
rep_ced8: rep_color_existence_distribution_rgb8 $*
#@cli rep_color_existence_distribution_rgb8: _bool_found= { 0=colour_nonexistence | colour_existence }
#@cli : This cli command is used to find which colors exist within the color lookup table generated from 8-bit positive-only colors that ranges from 0-255. Millions of colors that does not exist within a image can be picked from a image generated with this command.
#@cli : (eq. to 'rep_ced8').\n
#@cli : Author: Reptorian.
rep_color_existence_distribution_rgb8:

nk=$1
nk_1={$nk?255:0}
nk_2={$nk?0:255}

foreach {
	256,256,256 eval.. "++i(#-1,R,G,B)" k.
	4096,4096,1,4,[x%256,y%256,floor(x/256)+(floor(y/256)*16),i(#-1,x%256,y%256,floor(x/256)+(floor(y/256)*16))?$nk_1:$nk_2]
	k.
}
#@cli rep_sdaxy: eq. to 'rep_shift_distance_angle_xy'.
rep_sdaxy: rep_shift_distance_angle_xy $*
#@cli rep_shift_distance_angle_xy: _offset>0,_angle,_boundary_condition={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_interpolation={ 0=nearest_neighbor | 1=linear }
#@cli : Offset images at angle and distance.
#@cli : (eq. to 'rep_sdaxy').\n
#@cli : _offset refers to the displacement of image.\n
#@cli : Default value: 'boundary_condition=3','interpolation=1'\n
#@cli : Author: Reptorian.
rep_shift_distance_angle_xy:
skip ${3=3},${4=1}
rad_ang={$2/180*pi}
shift {cos($rad_ang)*$1},{sin($rad_ang)*$1},0,0,$3,$4
#@cli rep_dupsdaxy: eq. to 'rep_duplicate_by_shift_distance_angle_xy'.
rep_dupsdaxy: rep_duplicate_by_shift_distance_angle_xy $*
#@cli rep_duplicate_by_shift_distance_angle_xy: duplicates_count>=2,_radius_offset>0,_offset_angle,_keep_original={ 0=remove_original | 1=keep_original },_boundary_condition={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_interpolation={ 0=nearest_neighbor | 1=linear }
#@cli : Creates copies of image at a distance from original point.
#@cli : (eq. to 'rep_dupsdaxy').\n
#@cli : _radius_offset refers to the distance the duplicates are from the original image. Each circular duplicates are of the same distance. radius_offset can be in percentage form, or in integer form. When it is in percentage form, the length of each duplicates offset is equal to the percentage of diagonal of image.
#@cli : _offset_angle refers to the starting angle the original duplicate is at. The primary duplicate starts from the right.\n
#@cli : Default value: '_radius_offset={sqrt(w^2+h^2)*.05}','_offset_angle=0','_keep_original=0','_boundary_condition=0','_interpolation=1'\n
#@cli : Author: Reptorian.
rep_duplicate_by_shift_distance_angle_xy:
skip ${2={norm(w,h)*.05}},${3=0},${4=0},${5=1},${6=1}
if $1<2 v + error "Invalid duplicate numbers!" fi
aang={360/$1}
repeat $1 { +rep_shift_distance_angle_xy[0] $2,{$>*$aang+$3},$5,$6 }
if !$4 rm[0] fi
#@cli rep_frblur: eq. to 'rep_fragment_blur'.
rep_frblur: rep_fragment_blur $*
#@cli rep_fragment_blur: duplicates_count>=2,_radius_offset>0,_offset_angle,_keep_original={ 0=remove_original | 1=keep_original },_boundary_condition={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_interpolation={ 0=nearest_neighbor | 1=linear },_color_space={ 0=RGB | 1=SRGB | 2=RYB | 3=CMYK | 4=HCY | 5=HSI | 6=HSL | 7=HSV | 8=LAB | 9=LCH }
#@cli : Fragment Blur is a effect that originated from the Windows software named Paint.NET. Copies or "fragments" of images are superimposed over their respective images. Copies are redrawn at a distance, and starting copy starts from the right at 0.
#@cli : (eq. to 'rep_frblur').\n
#@cli : _radius_offset refers to the distance the duplicates are from the original image. Each circular duplicates are of the same distance. radius_offset can be in percentage form, or in integer form. When it is in percentage form, the length of each duplicates offset is equal to the percentage of diagonal of image.
#@cli : _offset_angle refers to the starting angle the original duplicate is at. The primary duplicate starts from the right.
#@cli : _keep_original options is to keep the original image as a duplicate without offsetting it.\n
#@cli : Default values: '_radius_offset=5%','_offset_angle=0','_keep_original=0','_boundary_condition=1','_interpolation=1','_color_space=0'\n
#@cli : Author: Reptorian.
rep_fragment_blur:
skip ${2=5%},${3=0},${4=0},${5=1},${6=0},${7=0}

if $7 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$7,,srgb,ryb,,hcy,hsi,hsl,hsv,lab,lch} fi

_frblur_iter_ang,_frblur_shift_ang,_ti,_frblur_dist={(2*pi)/$1},{deg2rad($3)},{abs($1)+($4?1)},1

if $6

	command "rep_frblur_sdaxy_add :
		100%,100%,100%,100% .

		$1,1,1,2,\"begin(
				const iter_ang=$_frblur_iter_ang;
				const shift_ang=$_frblur_shift_ang;
			);
			[cos(x*iter_ang+shift_ang)*$""1,sin(x*iter_ang+shift_ang)*$""1];\"

		repeat $1 {
			j.. [0]
			shift.. {I(#-1,$>)},0,0,$5,1
			add... ..
		}

		if $4 k[0,-3] add else k... fi
		"

else

	if $5 # Boundary

		command "rep_frblur_sdaxy_add :
			dist={ceil($""1)}

			100%,100%,100%,100%

			+expand[0] xy,$dist,$5

			$1,1,1,2,\"begin(
					const offset=$dist;
					const iter_ang=$_frblur_iter_ang;
					const shift_ang=$_frblur_shift_ang;
				);
				[round(cos(x*iter_ang+shift_ang)*$""1-offset),round(sin(x*iter_ang+shift_ang)*$""1-offset)];\"

			repeat $1 { j[1] [-2],{I(#-1,$>)},0,0,-1 }

			if $4
				k[0,1]
				add
			else
				k[1]
			fi
		"

	else # No Boundary

		command "rep_frblur_sdaxy_add :
			100%,100%,100%,100%

			$1,1,1,2,\"begin(
					const iter_ang=$_frblur_iter_ang;
					const shift_ang=$_frblur_shift_ang;
				);
				[round(cos(x*iter_ang+shift_ang)*$""1),round(sin(x*iter_ang+shift_ang)*$""1)];\"

			repeat $1 { j[1] [0],{I(#-1,$>)},0,0,-1 }

			if $4 k[0,1] add else k[1] fi"

	fi

fi

command "rep_frblur_alp :
	sh 0,{s-2}
	sh.. {s}

	maxa={iM#-1}

	/. $maxa
	*.. .

	rm[-2,-1]

	rep_frblur_sdaxy_add $""1

	sh 0,{s-2} sh.. {s} f.. I/(i0#-1?i0#-1:1) *. {$maxa/iM#-1} rm[-2,-1]"

command "rep_frblur_nalp : rep_frblur_sdaxy_add $""1 / $_ti"

foreach {
	if ispercentage($2) dist={abs($2)*norm(w,h)/2}
	else dist={abs($2)} fi

	tcr,convert_back=3,0

	if (s==3||s==4)&&$7
		convert_back=1
		if $7!=3
			$convert_colors_fwd.
		else
			if s==3 tcr+=1 rgb2cmyk
			elif s==4 s c,-3 rgb2cmyk.. a c
			fi
		fi
	fi

	if !(s==1||s==$tcr)
		rep_frblur_alp $dist
	else
		rep_frblur_nalp $dist
	fi

	if $convert_back
		if $7!=3
			$convert_colors_bwd.
		else
			if s==4 cmyk2rgb
			elif s==5 s c,-4 cmyk2rgb.. a c
			fi
		fi
	fi

}

uncommand rep_frblur_sdaxy_add,rep_frblur_alp,rep_frblur_nalp
#@cli rep_ncee: _distance>0,0<=_angle<=360,boundary_condition={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest_neighbor | 1=linear },_contrast>=0,_process_alpha={ 0=do_not_process_alpha | 1=process_alpha },_color_space,_blend_mode,0<=_blend_opacity[%]<=1
#@cli : Default value: 'boundary_condition=3','interpolation=1','contrast=1','process_alpha=1','color_space=0','blend_mode=1','blend_opacity=100%'\n
#@cli : Author: Reptorian.
rep_ncee:
skip ${3=3},${4=1},${5=1},${6=1},${7=0},${8=1},${9=1}

if $7 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$7,,ryb,cmy,cmyk,hsi8,hsl8,hsv8,lab8,lch8,yiq8,yuv8,xyz8,yes8,k18,ohta8} fi

-command "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"

to_a

split_opacity

local[0] {
 $convert_colors_fwd

 [0]

 local[1] {
  rep_dupsdaxy 2,$1,$2,0,$3,$4

  tci={$!}

  f. "255-i"

  add / $tci
  - 127.5
  * {2*$5}
  + 127.5

  cut 0,255

 }

 if $7!=3
  blend ${_mode{$8+1}},$9
  $convert_colors_bwd
 elif $7==3
  s c
  repeat 4 {
   local[$>,{$!-1}] {
    to_rgb
    blend ${_mode{$8+1}},$9
   }
  }
  a c
  cmyk2rgb
 fi
}

local[1] {
 if $6 rep_dupsdaxy 0,2,$1,$2,$3,$4 tai={$!} add / $tai fi
}
a c
#@cli pal: 0<="palette_id"<=384 : *,_name_pals_as_id={ 0=use_full_name | 1=use_id_name }
#@cli : Inserts pre-made user-made palette or palette that are based off older consoles or software or old paintings.
#@cli : Note 1 : Duplicate inputs can be ignored by inserting a '-' in the very beginning of arguments.
#@cli : Note 2 : +pal * generates every single palettes that are available for this command.
#@cli :
#@cli : \- The following list contains valid inputs directly next to their name, but anything after dashes is only for information purpose. Equal sign means that the commands are identical. -
#@cli :
#@cli : +pal 0 = +pal bw -- Black & White
#@cli : +pal 1 = +pal rgb -- Red-Green-Blue
#@cli : +pal 2 = +pal b_rgb -- Black with Red-Green-Blue
#@cli : +pal 3 = +pal bw_rgb -- Black & White with Red-Green-Blue
#@cli : +pal 4 = +pal cmy -- Cyan-Magenta-Yellow
#@cli : +pal 5 = +pal cmyk -- Cyan-Magenta-Yellow-Black
#@cli : +pal 6 = +pal w_cmyk -- White-Cyan-Magenta-Yellow-Black
#@cli : +pal 7 = +pal rgbcmy -- Red-Green-Blue with Cyan-Magenta-Yellow
#@cli : +pal 8 = +pal 1bitrgb -- 1-Bit RGB
#@cli : +pal 9 = +pal aurora -- Aurora by GrafxKid
#@cli : +pal 10 = +pal zenit -- Zenit-241 by Zenit40
#@cli : +pal 11 = +pal gbg -- Game Builder Garage: Texture-Sprite Editor Palette
#@cli : +pal 12 = +pal duel -- Duel by Arilyn
#@cli : +pal 13 = +pal hocuspocus -- Hocus Pocus Palette by Apogee Software,Ltd.
#@cli : +pal 14 = +pal playpal -- PLAYPAL by id Tech 1 | DOOM Engine
#@cli : +pal 15 = +pal srb2 -- Sonic Robo Blast 2
#@cli : +pal 16 = +pal uzebox -- Uzebox from Uzebox console
#@cli : +pal 17 = +pal kens16 -- Andrew Kensler - 16 by Andrew Kensler
#@cli : +pal 18 = +pal kens32 -- Andrew Kensler - 32 by Andrew Kensler
#@cli : +pal 19 = +pal kens54 -- Andrew Kensler - 54 by Andrew Kensler
#@cli : +pal 20 = +pal aap12 -- AAP-Micro 12 by Adigun A. Polack
#@cli : +pal 21 = +pal aap16 -- AAP-16 by Adigun A. Polack
#@cli : +pal 22 = +pal aap64 -- AAP-64 by Adigun A. Polack
#@cli : +pal 23 = +pal aap96 -- AAP-RadiantPLUS by Adigun A. Polack
#@cli : +pal 24 = +pal aap128 -- AAP-SPLENDOR128 by Adigun A. Polack
#@cli : +pal 25 = +pal aap_dga16 -- AAP-DGA16 by Adigun A. Polack
#@cli : +pal 26 = +pal cheerful -- Cheerful-32 by SoundsDotZip
#@cli : +pal 27 = +pal db8 -- DB8 by DawnBringer
#@cli : +pal 28 = +pal db16 -- DB16 by DawnBringer
#@cli : +pal 29 = +pal db32 -- DB32 by DawnBringer
#@cli : +pal 30 = +pal db_iso22 -- DB-ISO22 by DawnBringer
#@cli : +pal 31 = +pal dimwid17 -- DimWiddy 17 by DimWiddy
#@cli : +pal 32 = +pal dimwid23 -- DimWiddy 23 by DimWiddy
#@cli : +pal 33 = +pal edg4 -- Endesga-4 by Endesga
#@cli : +pal 34 = +pal edg8 -- Endesga-8 by Endesga
#@cli : +pal 35 = +pal edg16 -- Endesga-16 by Endesga
#@cli : +pal 36 = +pal edg32 -- Endesga-32 by Endesga
#@cli : +pal 37 = +pal edg36 -- Endesga-36 by Endesga
#@cli : +pal 38 = +pal edg64 -- Endesga-64 by Endesga
#@cli : +pal 39 = +pal famicube -- Famicube by Arne
#@cli : +pal 40 = +pal juicy32 -- Juicy-32 by Real Juice
#@cli : +pal 41 = +pal juicy56 -- Juicy-56 by Real Juice
#@cli : +pal 42 = +pal xaiue -- XAIUE-22 by xaiue
#@cli : +pal 43 = +pal 15pdx -- 15P-DX by GrafxKid
#@cli : +pal 44 = +pal 20pdx -- 20P-DX by GrafxKid
#@cli : +pal 45 = +pal 24pdx -- 24P-DX by GrafxKid
#@cli : +pal 46 = +pal cabana -- Cabana-64 by Crabby
#@cli : +pal 47 = +pal fantasy16 -- Fantasy 16 by Brettybooop
#@cli : +pal 48 = +pal fantasy24 -- Fantasy 24 by Gabriel C.
#@cli : +pal 49 = +pal tranquil_fantasy_23 -- Tranquil Fantasy 23 by windfall.apples
#@cli : +pal 50 = +pal tfp39 -- Tranquility Plus 39 by windfall.apples
#@cli : +pal 51 = +pal faraway -- Faraway 48 by Igor Ferreira.
#@cli : +pal 52 = +pal fleja -- Fleja Master Palette by Fleja
#@cli : +pal 53 = +pal koni -- Koni32 by Konic
#@cli : +pal 54 = +pal linearbasic -- Linear Color Palette Basic by GrafxKid
#@cli : +pal 55 = +pal legowiki -- LEGO colors from LEGO wiki
#@cli : +pal 56 = +pal lego2021 -- Lego Colours 2021 by Six Pies
#@cli : +pal 57 = +pal vinelinear -- Vines Flexible Linear Ramps by Vine 2D
#@cli : +pal 58 = +pal arcade -- Arcade Standard 29 by GrafxKid
#@cli : +pal 59 = +pal arq -- ARQ16 by Endesga
#@cli : +pal 60 = +pal atom -- Atom-8 by polyphrog
#@cli : +pal 61 = +pal blk36 -- BLK 36 by BlackedIRL.
#@cli : +pal 62 = +pal blkneo -- BLK-NEO by BlackedIRL.
#@cli : +pal 63 = +pal broken_facility -- Broken Facility by telepathic-melon
#@cli : +pal 64 = +pal bubblegum -- Bubblegum-16 by PineTreePizza
#@cli : +pal 65 = +pal cpcboy -- CPC BOY by Arne Niklas Jansson
#@cli : +pal 66 = +pal cade -- Cade 15 by MonstersGoBoom
#@cli : +pal 67 = +pal calder -- Calder 8 by Philip Dodderige
#@cli : +pal 68 = +pal cdbac -- CD-BAC by DimWiddy
#@cli : +pal 69 = +pal cgarne -- CG Arne by Arne Niklas Jansson
#@cli : +pal 70 = +pal dinoknight -- DinoKnight 16 by Retrospec
#@cli : +pal 71 = +pal llll -- ||||-22 by ||||
#@cli : +pal 72 = +pal fzt_ethereal -- FZT Ethereal 16 by Fusionnist
#@cli : +pal 73 = +pal indecision -- Indecision by Nelson SMG
#@cli : +pal 74 = +pal island -- Island Joy 16 by Kerrie Lake
#@cli : +pal 75 = +pal journey -- Journey by PineTreePizza
#@cli : +pal 76 = +pal shallowmarsh -- Shallowmarsh26 by archer
#@cli : +pal 77 = +pal lago_nenufar -- Lago Nenufar (Lake Water Lily) by Popxel Art
#@cli : +pal 78 = +pal juicy -- Juicy 17 by JerryPie
#@cli : +pal 79 = +pal chocolate -- ChocolateGanache by Ladybug
#@cli : +pal 80 = +pal brightwinter1 -- Bright Winter 1 by Nai
#@cli : +pal 81 = +pal brightwinter2 -- Bright Winter 2 by Nai
#@cli : +pal 82 = +pal kawaii -- Kawaii16 by Arisuki
#@cli : +pal 83 = +pal xdb -- 0xdb-01 by 0xDB
#@cli : +pal 84 = +pal gzxp -- GZXP by GrafxKid
#@cli : +pal 85 = +pal chromatic -- Chromatic16 by DragonDePlatino
#@cli : +pal 86 = +pal piet_code -- Piet Coding Language
#@cli : +pal 87 = +pal boltbait_matrix -- Matrix by BoltBait
#@cli : +pal 88 = +pal material_design -- Material Design by Ruchir L. Sharma
#@cli : +pal 89 = +pal thehamster_rainbow -- Rainbow by thehamster
#@cli : +pal 90 = +pal boltbait_rainbow -- Rainbow by BoltBait
#@cli : +pal 91 = +pal scrj_xxxvi -- SCRJ-XXXVI by StudioCRJ
#@cli : +pal 92 = +pal pxls_space -- Pxls Default from pxls.space
#@cli : +pal 93 = +pal lospec -- Lospec500 by the Lospec community
#@cli : +pal 94 = +pal moderna -- Moderna by yedamameday
#@cli : +pal 95 = +pal oak -- Oak21 by Dan Oak
#@cli : +pal 96 = +pal nature -- Nature's Embrace 55 by GrafxKid
#@cli : +pal 97 = +pal rbypgo -- RBYPGO by Marilynx
#@cli : +pal 98 = +pal new_worlds -- New Worlds 46 by Count Moriarty
#@cli : +pal 99 = +pal nauris -- Nauris-16 by Nauris
#@cli : +pal 100 = +pal dynamite -- Dynamite by Pixi
#@cli : +pal 101 = +pal interstate -- Interstate 28 by maine
#@cli : +pal 102 = +pal downgraded -- Downgraded 32 by daniel
#@cli : +pal 103 = +pal pear36 -- Pear 36 by PineTreePizza
#@cli : +pal 104 = +pal pineapple -- Pineapple 32 by PineTreePizza
#@cli : +pal 105 = +pal peachy -- Peachy Pop 16 by Kerrie Lake
#@cli : +pal 106 = +pal resurrect -- Resurrect 32 by Kerrie Lake
#@cli : +pal 107 = +pal rosy42 -- Rosy 42 by PineTreePizza
#@cli : +pal 108 = +pal slso_clr17 -- SLSO-CLR17 by Luis Miguel Maldonado
#@cli : +pal 109 = +pal softy -- Softy 15 by Eggy
#@cli : +pal 110 = +pal spec12 -- SPEC12 by Smalls
#@cli : +pal 111 = +pal the_roarin_80s -- The Roarin 80's by Malo
#@cli : +pal 112 = +pal starmancer -- Starmancer by Ominux Games
#@cli : +pal 113 = +pal superfuture -- SuperFuture25 by Endesga
#@cli : +pal 114 = +pal sunshine -- SUNSHINE 35 by mysunnyrose
#@cli : +pal 115 = +pal sweetie16 -- Sweetie 16 by GrafxKid
#@cli : +pal 116 = +pal calm -- Calm 48 by Xina
#@cli : +pal 117 = +pal optimism -- Optimism by mingapur
#@cli : +pal 118 = +pal taffy -- Taffy 16 by PineTreePizza
#@cli : +pal 119 = +pal todayland -- Todayland Palette V2 by GrafxKid
#@cli : +pal 120 = +pal trirampo -- TriRampo by ANoob
#@cli : +pal 121 = +pal reddit_place_2022 -- r|place 2022
#@cli : +pal 122 = +pal tropical -- Tropical Cone 24 by yedamameday
#@cli : +pal 123 = +pal vivid -- Vivid-17 by Irenaart
#@cli : +pal 124 = +pal shido -- SHIDO50+ by Shidoengie
#@cli : +pal 125 = +pal intacto -- Intacto14 by Anoob
#@cli : +pal 126 = +pal itatsi -- Itatsi by SoundsDotZip
#@cli : +pal 127 = +pal enos -- ENOS16 by Endesga
#@cli : +pal 128 = +pal grixel -- Grixel Grotto by Northernite
#@cli : +pal 129 = +pal superb -- Superb 8 by BigPotato
#@cli : +pal 130 = +pal undertones -- Undertones-17 by Irenaart
#@cli : +pal 131 = +pal tango -- Tango by Duck
#@cli : +pal 132 = +pal cheese -- Cheese Palette by Gors
#@cli : +pal 133 = +pal equpix15 -- Equpix 15 by Night
#@cli : +pal 134 = +pal zughy -- Zughy 32 by Zughy
#@cli : +pal 135 = +pal voodo -- Voodo34 by Shamaboy
#@cli : +pal 136 = +pal franzston -- Franzston 30 by Virus610
#@cli : +pal 137 = +pal night -- Night 16 by Night
#@cli : +pal 138 = +pal star29 -- Star 29 by Starlane
#@cli : +pal 139 = +pal star34 -- Star 34 by Starlane
#@cli : +pal 140 = +pal still_life -- Still-Life by cure
#@cli : +pal 141 = +pal simple_jpc_16 -- SimpleJPC-16 by Adigun A. Polack
#@cli : +pal 142 = +pal acid -- Acid 15 by pyrometal
#@cli : +pal 143 = +pal battery -- Battery 24 by Battery Jellyfish
#@cli : +pal 144 = +pal clumpy -- Clumpy 18 by windfall.apples
#@cli : +pal 145 = +pal cthul -- Cthulhu by Starlane
#@cli : +pal 146 = +pal crimso11 -- Crimso 11 by Crimso
#@cli : +pal 147 = +pal copper_tech -- Copper-Tech by Arne Niklas Jansson
#@cli : +pal 148 = +pal drz15a -- DRZ15A by Drazille
#@cli : +pal 149 = +pal eggy -- Eggy 15 by Eggy
#@cli : +pal 150 = +pal europa -- Europa 16 by Starlane
#@cli : +pal 151 = +pal greyt_bit -- GreyT-bit by Sam Keddy
#@cli : +pal 152 = +pal jewel -- Jewel by AprilSundae
#@cli : +pal 153 = +pal polar -- Polar 11 by Smalls
#@cli : +pal 154 = +pal sheltzy -- Sheltzy 32 by NatTorpedia
#@cli : +pal 155 = +pal wyrm -- Wyrm 24 by FrogWyrm
#@cli : +pal 156 = +pal yume_nikki -- Yume Nikki by Space Sandwich
#@cli : +pal 157 = +pal rube_goldberg -- Rube-Goldberg
#@cli : +pal 158 = +pal boomboom -- BoomBoom by Salman_Shh
#@cli : +pal 159 = +pal generic_8 -- Generic-8 by GrafxKid
#@cli : +pal 160 = +pal crayola -- Crayola Blind
#@cli : +pal 161 = +pal funky -- FunkyFuture8 by ShamaBoy
#@cli : +pal 162 = +pal golden_wall -- The Golden Wall Palette by Hans Hofmann
#@cli : +pal 163 = +pal matriax8c -- Matriax8c by Davit Masia
#@cli : +pal 164 = +pal nt1h -- NT1H by NatTorpedia
#@cli : +pal 165 = +pal jerrypie -- JerryPie 22 by JerryPie
#@cli : +pal 166 = +pal nineties_nine -- Nineties Nine by Cubby Crazes
#@cli : +pal 167 = +pal on70 -- On70 by By8Bits
#@cli : +pal 168 = +pal anb16 -- ANB16 by Anoob
#@cli : +pal 169 = +pal retrocal -- Retrocal-8 by polyphrog
#@cli : +pal 170 = +pal punolit -- Punolit by Punoli
#@cli : +pal 171 = +pal luap -- Luap 40 by Luap
#@cli : +pal 172 = +pal autum_villan -- Autum Villan 6 by Chase Stemel
#@cli : +pal 173 = +pal autum_15 -- Autum 15 by jok
#@cli : +pal 174 = +pal autum_15_yellow -- Autum 15 [Yellow] by jok
#@cli : +pal 175 = +pal galaxy_flame -- Galaxy Flame by Rhoq
#@cli : +pal 176 = +pal cretaceous -- Cretaceous-16 by Joao Vasconcelos
#@cli : +pal 177 = +pal antiquity -- Antiquity16 by ILTA
#@cli : +pal 178 = +pal mushroom -- Mushroom by Jimison3
#@cli : +pal 179 = +pal aerugo -- Aerugo by Lizalot
#@cli : +pal 180 = +pal hotel_paintings -- Hotel Paintings 6 by Chase Stemel
#@cli : +pal 181 = +pal nopal -- Nopal-12 by BlackedIRL.
#@cli : +pal 182 = +pal brightness_gpy -- Brightness GPY by rickthepalette
#@cli : +pal 183 = +pal blessing -- Blessing by Maruki
#@cli : +pal 184 = +pal fairy_dust -- Fairydust 8 by Yousurname
#@cli : +pal 185 = +pal milkshake -- Vanilla MilkShake by Space Sandwich
#@cli : +pal 186 = +pal fuzzy -- Fuzzy Four by P-Tux7
#@cli : +pal 187 = +pal fairy -- Fairy Tales by lollige
#@cli : +pal 188 = +pal naji16 -- Naji 16 by Naji
#@cli : +pal 189 = +pal easter -- Easter Island by skamocore
#@cli : +pal 190 = +pal pastel_and_darks -- Pastel and Darks 58 Palette by Glxss
#@cli : +pal 191 = +pal pastel_irena -- 17 Pastels by Irenaart
#@cli : +pal 192 = +pal nostalgia -- NOSTALGIA15 by Arisuki
#@cli : +pal 193 = +pal ocaso -- Ocaso by Minord
#@cli : +pal 194 = +pal pastel_starlitsunset -- Oh Hell, Pastel by StarlitSunset
#@cli : +pal 195 = +pal pollen -- Pollen-8 by Conker
#@cli : +pal 196 = +pal kule -- KULE-16 by Cuymacu
#@cli : +pal 197 = +pal hydrangea -- Hydrangea 11 by Dinchen's Art
#@cli : +pal 198 = +pal fluffy -- Fluffy8 by vee
#@cli : +pal 199 = +pal st_8_red_and_blue -- ST 8 R&B Remake by Skiller Thomson
#@cli : +pal 200 = +pal neon -- Neon Space by Jimison3
#@cli : +pal 201 = +pal cyclope -- Cyclope6 by Royal_Naym
#@cli : +pal 202 = +pal sy17 -- Sy17 by xaiue
#@cli : +pal 203 = +pal syz15 -- Syz15 by Fusionnist
#@cli : +pal 204 = +pal tui15 -- TUI-15 by Jeremy
#@cli : +pal 205 = +pal cave -- Cave by PineTreePizza
#@cli : +pal 206 = +pal psygnosia -- Psygnosia by Arne Niklas Jansson
#@cli : +pal 207 = +pal marshmellow -- MarshMellow32 by FormalPrejudice
#@cli : +pal 208 = +pal lost_century -- Lost Century 24 by CalmRadish
#@cli : +pal 209 = +pal finlal -- Finlal 11 by Finlal
#@cli : +pal 210 = +pal industrial -- Industrial Factory 16 by Toby_Yasha
#@cli : +pal 211 = +pal murder_mystery -- Murder Mystery 16 by Toby_Yasha
#@cli : +pal 212 = +pal fate_and_destiny -- Fate & Destiny 12 by Toby_Yasha
#@cli : +pal 213 = +pal vinik -- Vinik 24 by Vinik
#@cli : +pal 214 = +pal ykb -- YKB-22 by yahkehbu
#@cli : +pal 215 = +pal halloween -- Halloween by Mememellow
#@cli : +pal 216 = +pal graveyard -- Graveyard-21 by AprilSundae
#@cli : +pal 217 = +pal steamlords -- Steam Lords by Slynyrd
#@cli : +pal 218 = +pal frostical -- Frostical by yedamameday
#@cli : +pal 219 = +pal deuterospill -- DeuteroSpill by Royal_Naym
#@cli : +pal 220 = +pal cool_bone -- Cool Bone 7 by Chase Stemel
#@cli : +pal 221 = +pal muted_ally -- Muted Ally 6 by Chase Stemel
#@cli : +pal 222 = +pal ephemera -- EPHEMERA by K C
#@cli : +pal 223 = +pal ink -- Ink by AprilSundae
#@cli : +pal 224 = +pal violet_dreams -- Violet Dreams by Solitaire
#@cli : +pal 225 = +pal tinyfolks -- Tinyfolks by Pierr Vandermaesan
#@cli : +pal 226 = +pal old_gold -- Old Gold 7 by Chase Stemel
#@cli : +pal 227 = +pal rose_moss_8 -- Rosemoss-8 by polyphrog
#@cli : +pal 228 = +pal aap_radiant_xv -- AAP-RadiantXV by Adigun A. Polack
#@cli : +pal 229 = +pal aap_majesty_xvii -- AAP-Majesty XVII by Adigun A. Polack
#@cli : +pal 230 = +pal dead_weight -- Dead Weight-8 by polyphrog
#@cli : +pal 231 = +pal mojave -- Mojave20 by magodellepercussioni
#@cli : +pal 232 = +pal petite_8 -- Petite-8 by Adigun A. Polack
#@cli : +pal 233 = +pal petite_8_afterdark -- Petite-8 Afterdark by Adigun A. Polack
#@cli : +pal 234 = +pal xaiue_radiant -- XAIUE-Radiant by xaiue
#@cli : +pal 235 = +pal daruda -- Daruda 22 by daruda
#@cli : +pal 236 = +pal firestorm -- Firestorm by theartistjulian
#@cli : +pal 237 = +pal borkfest -- Borkfest by ã¾ãã
#@cli : +pal 238 = +pal spicy -- Spicy 07 by green guy
#@cli : +pal 239 = +pal rust -- Rust-6 by Blue Phoenix
#@cli : +pal 240 = +pal apricot -- Apricot by Chase Stemel
#@cli : +pal 241 = +pal supernova -- SuperNova 7 by Blue Phoenix
#@cli : +pal 242 = +pal pastry -- Pastry by MirruTatep
#@cli : +pal 243 = +pal sandy -- Sandy 06 by green guy
#@cli : +pal 244 = +pal illumination -- Illumination by MirruTatep
#@cli : +pal 245 = +pal nyx -- NYX8 by Javier Guerrero
#@cli : +pal 246 = +pal dream_haze -- Dream Haze 8 by Klafooty
#@cli : +pal 247 = +pal oil -- OIL6 by GrafxKid
#@cli : +pal 248 = +pal regal -- Regal10 by JRiggles
#@cli : +pal 249 = +pal soft_demon -- Soft Demon 7 by Chase Stemel
#@cli : +pal 250 = +pal sgm -- SGM-Palette 2 by s.g.m
#@cli : +pal 251 = +pal midnight_ablaze -- Midnight ablaze by Inkpendude
#@cli : +pal 252 = +pal black_cherry -- Black Cherry by MirruTatep
#@cli : +pal 253 = +pal sunset_red -- Sunset Red by Cabezinu
#@cli : +pal 254 = +pal inkpink -- INKPINK by Inkpendude
#@cli : +pal 255 = +pal brash_pink -- Brash Pink by ItzFred
#@cli : +pal 256 = +pal pink_neon_sign -- Pink Neon Sign 6 by Chase Stemel
#@cli : +pal 257 = +pal enchanted_purple -- Enchanted Purple by Kaiburn
#@cli : +pal 258 = +pal arch -- Arch by Poltergasm
#@cli : +pal 259 = +pal spacey_easter -- Spacey Easter by Spark Norris
#@cli : +pal 260 = +pal fornax_void_1 -- Fornax Void I by Fornax Void
#@cli : +pal 261 = +pal fornax_void_2 -- Fornax Void II by Fornax Void
#@cli : +pal 262 = +pal pixelwave -- Pixelwave by Reptorian
#@cli : +pal 263 = +pal s1_6 -- S1-6 by Blyzz
#@cli : +pal 264 = +pal berry_nebula -- Berry Nebula by LostInIndigo
#@cli : +pal 265 = +pal abyss -- ABYSS-9 by Jusiv
#@cli : +pal 266 = +pal moonlight -- Moonlight 15 by Tofu
#@cli : +pal 267 = +pal moon39 -- Moonlit-39 by theartistjulian
#@cli : +pal 268 = +pal h2o -- H2O by maine
#@cli : +pal 269 = +pal magic_waters -- Magic Waters 9 by Chase Stemel
#@cli : +pal 270 = +pal bluemold -- Bluem0ld by warpixel
#@cli : +pal 271 = +pal moss -- Moss by Zetomis
#@cli : +pal 272 = +pal deep_maze -- DEEP MAZE by Ryosuke
#@cli : +pal 273 = +pal toxic_slime -- Toxic Slime by MirruTatep
#@cli : +pal 274 = +pal lush_green -- Lush Green by EerieJam
#@cli : +pal 275 = +pal tsunami -- Tsunami by MirruTatep
#@cli : +pal 276 = +pal cryptic_ocean -- Cryptic Ocean by Klafooty
#@cli : +pal 277 = +pal marsh_madness -- Marsh Madness by MirruTatep
#@cli : +pal 278 = +pal oxyd -- OXYD by ItzFred
#@cli : +pal 279 = +pal pink_green -- Pink&Green by q1
#@cli : +pal 280 = +pal woodwalk -- Walking in the Woods 8 by Chase Stemel
#@cli : +pal 281 = +pal paper8 -- Paper 8 by Frosty Rabbid
#@cli : +pal 282 = +pal sahara_pastell -- Sahara Pastell by wermz
#@cli : +pal 283 = +pal sunflower -- Sunflower Painting 7 by Chase Stemel
#@cli : +pal 284 = +pal arthoe -- Art Hoe Aesthetic 7 by Chase Stemel
#@cli : +pal 285 = +pal sky -- Sky5 by MiniTe
#@cli : +pal 286 = +pal ocean_glass -- Ocean Glass by Solitaire
#@cli : +pal 287 = +pal royal -- RoyalGuard by Royal_Naym
#@cli : +pal 288 = +pal eulbink -- Eulbink by Inkpendude
#@cli : +pal 289 = +pal winter_wonderland -- Winter Wonderland by Jimison3
#@cli : +pal 290 = +pal moon_squid -- Moon Squid 7 by Chase Stemel
#@cli : +pal 291 = +pal stratus -- Stratus by MirruTatep
#@cli : +pal 292 = +pal arctic_dust -- Arctic Dust by MirruTatep
#@cli : +pal 293 = +pal clouds_sunset -- CL8UDS by _Nicola
#@cli : +pal 294 = +pal lilac_skies -- Lilac Skies 5 by Chase Stemel
#@cli : +pal 295 = +pal sea_of_fire -- Sea of Fire by TATA-PIXEL
#@cli : +pal 296 = +pal autochrome3 -- Autochrome 3 by Reptorian
#@cli : +pal 297 = +pal autochrome5 -- Autochrome 5 by Reptorian
#@cli : +pal 298 = +pal gb_default_1 -- GB Default 1
#@cli : +pal 299 = +pal gb_default_2 -- GB Default 2
#@cli : +pal 300 = +pal gb_andrade -- GB Andrade by Andrade
#@cli : +pal 301 = +pal gb_blue -- GB Blue Seni by WildLeoKnight
#@cli : +pal 302 = +pal gb_blackzone -- GB Blackzone
#@cli : +pal 303 = +pal gb_suburb -- GB Suburb by Poppysalmon
#@cli : +pal 304 = +pal gb_crimson -- GB Crimson by WildLeoKnight
#@cli : +pal 305 = +pal gb_didi -- GB Didi by DidiGameboy
#@cli : +pal 306 = +pal gb_dirty -- GB Dirty by WildLeoKnight
#@cli : +pal 307 = +pal gb_arne -- GB Arne by Arne
#@cli : +pal 308 = +pal gb_easy -- GB Easy by GrafxKid
#@cli : +pal 309 = +pal gb_forest -- GB Forest
#@cli : +pal 310 = +pal gb_harsh_green -- GB Harsh Green by WildLeoKnight
#@cli : +pal 311 = +pal gb_light_green -- GB Light Green by WildLeoKnight
#@cli : +pal 312 = +pal gb_nostalgia -- GB Nostalgia by WildLeoKnight
#@cli : +pal 313 = +pal gb_platinum -- GB Platinum by WildLeoKnight
#@cli : +pal 314 = +pal gb_kirokaze -- GB Kirokaze by Kirokaze
#@cli : +pal 315 = +pal gb_cyber -- GB Cyber
#@cli : +pal 316 = +pal gb_wish -- GB Wish by Kerrie Lake
#@cli : +pal 317 = +pal gb_grapefruit -- GB Grapefruit by GrafxKid
#@cli : +pal 318 = +pal gb_ice_cream -- GB Ice Cream by Kerrie Lake
#@cli : +pal 319 = +pal gb_red_blue -- GB Red_Blue
#@cli : +pal 320 = +pal gb_gold -- Gold GB by Isa
#@cli : +pal 321 = +pal gb_choco -- GB Chocolate by GrafxKid
#@cli : +pal 322 = +pal gb_gray -- GB Gray by GrafxKid
#@cli : +pal 323 = +pal gb_space -- GB Spacehaze by WildLeoKnight
#@cli : +pal 324 = +pal gb_purple_dawn -- GB Purple Dawn by WildLeoKnight
#@cli : +pal 325 = +pal moon_crystal -- Moon Crystal by Doph
#@cli : +pal 326 = +pal arne -- ARNE4 by Arne
#@cli : +pal 327 = +pal autumn_chill -- Autumn Chill by Doph
#@cli : +pal 328 = +pal cherrymelon -- CherryMelon by WildLeoKnight
#@cli : +pal 329 = +pal hal4 -- HallowPumpkin by WildLeoKnight
#@cli : +pal 330 = +pal hollow -- Hollow by Poltergasm
#@cli : +pal 331 = +pal lavender -- Lavender4 by Solitaire
#@cli : +pal 332 = +pal maw -- MAW by bloo
#@cli : +pal 333 = +pal voltage_warning -- Voltage Warning by Wuchta
#@cli : +pal 334 = +pal tritanopia -- Tritanopia by Allappini
#@cli : +pal 335 = +pal rabbit -- Rabbit 7 by GrafxKid
#@cli : +pal 336 = +pal amiga2600_ntsc -- Amiga 2600 NTSC
#@cli : +pal 337 = +pal amiga2600_pal -- Amiga 2600 PAL
#@cli : +pal 338 = +pal amiga2600_secam -- Amiga 2600 SECAM
#@cli : +pal 339 = +pal amiga7800_mess -- Amiga 7800 M.E.S.S by Nabuko78
#@cli : +pal 340 = +pal amiga7800 -- Amiga 7800
#@cli : +pal 341 = +pal amstrad_cpc -- Amstrad CPC
#@cli : +pal 342 = +pal apple -- Apple II
#@cli : +pal 343 = +pal atari -- Atari 8-Bit Series - GTIA by PixelCrunch
#@cli : +pal 344 = +pal cga -- CGA
#@cli : +pal 345 = +pal cga00 -- CGA Mode 0 [Low]
#@cli : +pal 346 = +pal cga01 -- CGA Mode 0 [High]
#@cli : +pal 347 = +pal cga10 -- CGA Mode 1 [Low]
#@cli : +pal 348 = +pal cga11 -- CGA Mode 1 [High]
#@cli : +pal 349 = +pal cga20 -- CGA Mode 2 [Low]
#@cli : +pal 350 = +pal cga21 -- CGA Mode 2 [High]
#@cli : +pal 351 = +pal c64_pepto -- Commodore 64 - Pepto
#@cli : +pal 352 = +pal c64_colodore -- Commodore 64 - Colodore
#@cli : +pal 353 = +pal com_vic_20 -- Commodore VIC-20
#@cli : +pal 354 = +pal colecovision -- Colecovision
#@cli : +pal 355 = +pal jmp -- Japanese Machine Palette by Arne Niklas Jansson
#@cli : +pal 356 = +pal mac2 -- Macintosh II
#@cli : +pal 357 = +pal mac_8_bit -- Macintosh 8-Bit System Palette
#@cli : +pal 358 = +pal msx -- MSX
#@cli : +pal 359 = +pal nes -- NES
#@cli : +pal 360 = +pal pico -- PICO-8 by Lexaloffle Games
#@cli : +pal 361 = +pal risc -- RISC OS
#@cli : +pal 362 = +pal sam_coupe -- SAM Coupe
#@cli : +pal 363 = +pal mo5 -- Thomson MO5
#@cli : +pal 364 = +pal trs80 -- TRS-80 Color Computer Palette
#@cli : +pal 365 = +pal virtualboy -- Virtual Boy interpreted by Bruno Weinberger
#@cli : +pal 366 = +pal vga -- VGA
#@cli : +pal 367 = +pal win95 -- Win 95
#@cli : +pal 368 = +pal zx -- ZX Spectrum
#@cli : +pal 369 = +pal gnome -- GNOME 32
#@cli : +pal 370 = +pal electronic_crayon -- Electronic Crayon 22
#@cli : +pal 371 = +pal chip16 -- Chip16
#@cli : +pal 372 = +pal deluxe_paint -- Deluxe Paint
#@cli : +pal 373 = +pal flat_ui -- FlatUI from flat ui colors website
#@cli : +pal 374 = +pal makecode_arcade -- MakeCode Arcade Palette
#@cli : +pal 375 = +pal oekaki -- Oekaki from Oekaki.nl
#@cli : +pal 376 = +pal ms_legacy_paint -- Legacy Paint
#@cli : +pal 377 = +pal ms_xp -- XP Paint
#@cli : +pal 378 = +pal vista -- Vista Paint
#@cli : +pal 379 = +pal piet -- Piet Palette by Piet Mondrain
#@cli : +pal 380 = +pal japanese_woodblock -- Japanese Woodblock Palette by Polyducks
#@cli : +pal 381 = +pal human_faces -- Human Faces by Romney57
#@cli : +pal 382 = +pal hsv -- HSV Palette by MadJik
#@cli : +pal 383 = +pal christmas -- ST24 Christmas by Skiller Thomson
#@cli : +pal 384 = +pal ladybug_reds -- Reds by Ladybug
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_name_pals_as_id=0'
+pal:
check "same('$1','*')?($#==2?isnum($-1):1):1"
_$0 $*
e[^-1] $_gmic_s
+_pal:
P=$!

l[] {
	i {``$_path_rc}gmic_community_pals.gmz
	onfail
		_pal_385_pals
		o {``$_path_rc}gmic_community_pals.gmz
}

Q={$!-1}

if same('$1','*')
	if isnum($-1)?$-1
		name[$P--1] ${-_pal_ids}
	fi
	_gmic_s.="Create palette(s) '"${-_pal_ids}"'."
	return
fi

m __$0_dict:"
	n_ids=$""#
	$""=i_"
__$0_dict ${-_pal_ids}
um __$0_dict
${_pal_ids\ j_}={expr('$P+x',385)}

$=var

if ('$1')[0]==_'-'
	rd,var1=1,{`str='$1';(str)[1,size(str)-1]`}
else
	rd=0
fi

repeat $# {
	m=${var{$>+1}}

	if isnum($m)
		if isint($m)&&isfinite($1)
			m=${i_{($m%$n_ids)+1}}
		else
			error inv_arg_{$>+1}
		fi
	fi

	a=${j_$m}
	if narg($a)
		if isint($a) [$a] else $a fi
	else
		error inv_arg_{$>+1}
	fi

	out.=$s$m
	s=,

	if $rd
		j_$m=continue
	fi
}

rm[$P-$Q]
remove_copymark[-$#--1]
_gmic_s="Create palette(s) '"$out"'."
u $out
_pal_ids:
skip "${1=}"
u $1bw,$1rgb,$1b_rgb,$1bw_rgb,$1cmy,$1cmyk,$1w_cmyk,$1rgbcmy,$1"1bitrgb",$1aurora,$1zenit,$1gbg,$1duel,$1hocuspocus,$1playpal,$1srb2,$1uzebox,$1kens16,$1kens32,$1kens54,$1aap12,$1aap16,$1aap64,$1aap96,$1aap128,$1aap_dga16,$1cheerful,$1db8,$1db16,$1db32,$1db_iso22,$1dimwid17,$1dimwid23,$1edg4,$1edg8,$1edg16,$1edg32,$1edg36,$1edg64,$1famicube,$1juicy32,$1juicy56,$1xaiue,$1"15pdx",$1"20pdx",$1"24pdx",$1cabana,$1fantasy16,$1fantasy24,$1tranquil_fantasy_23,$1tfp39,$1faraway,$1fleja,$1koni,$1linearbasic,$1legowiki,$1lego2021,$1vinelinear,$1arcade,$1arq,$1atom,$1blk36,$1blkneo,$1broken_facility,$1bubblegum,$1cpcboy,$1cade,$1calder,$1cdbac,$1cgarne,$1dinoknight,$1llll,$1fzt_ethereal,$1indecision,$1island,$1journey,$1shallowmarsh,$1lago_nenufar,$1juicy,$1chocolate,$1brightwinter1,$1brightwinter2,$1kawaii,$1xdb,$1gzxp,$1chromatic,$1piet_code,$1boltbait_matrix,$1material_design,$1thehamster_rainbow,$1boltbait_rainbow,$1scrj_xxxvi,$1pxls_space,$1lospec,$1moderna,$1oak,$1nature,$1rbypgo,$1new_worlds,$1nauris,$1dynamite,$1interstate,$1downgraded,$1pear36,$1pineapple,$1peachy,$1resurrect,$1rosy42,$1slso_clr17,$1softy,$1spec12,$1the_roarin_80s,$1starmancer,$1superfuture,$1sunshine,$1sweetie16,$1calm,$1optimism,$1taffy,$1todayland,$1trirampo,$1reddit_place_2022,$1tropical,$1vivid,$1shido,$1intacto,$1itatsi,$1enos,$1grixel,$1superb,$1undertones,$1tango,$1cheese,$1equpix15,$1zughy,$1voodo,$1franzston,$1night,$1star29,$1star34,$1still_life,$1simple_jpc_16,$1acid,$1battery,$1clumpy,$1cthul,$1crimso11,$1copper_tech,$1drz15a,$1eggy,$1europa,$1greyt_bit,$1jewel,$1polar,$1sheltzy,$1wyrm,$1yume_nikki,$1rube_goldberg,$1boomboom,$1generic_8,$1crayola,$1funky,$1golden_wall,$1matriax8c,$1nt1h,$1jerrypie,$1nineties_nine,$1on70,$1anb16,$1retrocal,$1punolit,$1luap,$1autum_villan,$1autum_15,$1autum_15_yellow,$1galaxy_flame,$1cretaceous,$1antiquity,$1mushroom,$1aerugo,$1hotel_paintings,$1nopal,$1brightness_gpy,$1blessing,$1fairy_dust,$1milkshake,$1fuzzy,$1fairy,$1naji16,$1easter,$1pastel_and_darks,$1pastel_irena,$1nostalgia,$1ocaso,$1pastel_starlitsunset,$1pollen,$1kule,$1hydrangea,$1fluffy,$1st_8_red_and_blue,$1neon,$1cyclope,$1sy17,$1syz15,$1tui15,$1cave,$1psygnosia,$1marshmellow,$1lost_century,$1finlal,$1industrial,$1murder_mystery,$1fate_and_destiny,$1vinik,$1ykb,$1halloween,$1graveyard,$1steamlords,$1frostical,$1deuterospill,$1cool_bone,$1muted_ally,$1ephemera,$1ink,$1violet_dreams,$1tinyfolks,$1old_gold,$1rose_moss_8,$1aap_radiant_xv,$1aap_majesty_xvii,$1dead_weight,$1mojave,$1petite_8,$1petite_8_afterdark,$1xaiue_radiant,$1daruda,$1firestorm,$1borkfest,$1spicy,$1rust,$1apricot,$1supernova,$1pastry,$1sandy,$1illumination,$1nyx,$1dream_haze,$1oil,$1regal,$1soft_demon,$1sgm,$1midnight_ablaze,$1black_cherry,$1sunset_red,$1inkpink,$1brash_pink,$1pink_neon_sign,$1enchanted_purple,$1arch,$1spacey_easter,$1fornax_void_1,$1fornax_void_2,$1pixelwave,$1s1_6,$1berry_nebula,$1abyss,$1moonlight,$1moon39,$1h2o,$1magic_waters,$1bluemold,$1moss,$1deep_maze,$1toxic_slime,$1lush_green,$1tsunami,$1cryptic_ocean,$1marsh_madness,$1oxyd,$1pink_green,$1woodwalk,$1paper8,$1sahara_pastell,$1sunflower,$1arthoe,$1sky,$1ocean_glass,$1royal,$1eulbink,$1winter_wonderland,$1moon_squid,$1stratus,$1arctic_dust,$1clouds_sunset,$1lilac_skies,$1sea_of_fire,$1autochrome3,$1autochrome5,$1gb_default_1,$1gb_default_2,$1gb_andrade,$1gb_blue,$1gb_blackzone,$1gb_suburb,$1gb_crimson,$1gb_didi,$1gb_dirty,$1gb_arne,$1gb_easy,$1gb_forest,$1gb_harsh_green,$1gb_light_green,$1gb_nostalgia,$1gb_platinum,$1gb_kirokaze,$1gb_cyber,$1gb_wish,$1gb_grapefruit,$1gb_ice_cream,$1gb_red_blue,$1gb_gold,$1gb_choco,$1gb_gray,$1gb_space,$1gb_purple_dawn,$1moon_crystal,$1arne,$1autumn_chill,$1cherrymelon,$1hal4,$1hollow,$1lavender,$1maw,$1voltage_warning,$1tritanopia,$1rabbit,$1amiga2600_ntsc,$1amiga2600_pal,$1amiga2600_secam,$1amiga7800_mess,$1amiga7800,$1amstrad_cpc,$1apple,$1atari,$1cga,$1cga00,$1cga01,$1cga10,$1cga11,$1cga20,$1cga21,$1c64_pepto,$1c64_colodore,$1com_vic_20,$1colecovision,$1jmp,$1mac2,$1mac_8_bit,$1msx,$1nes,$1pico,$1risc,$1sam_coupe,$1mo5,$1trs80,$1virtualboy,$1vga,$1win95,$1zx,$1gnome,$1electronic_crayon,$1chip16,$1deluxe_paint,$1flat_ui,$1makecode_arcade,$1oekaki,$1ms_legacy_paint,$1ms_xp,$1vista,$1piet,$1japanese_woodblock,$1human_faces,$1hsv,$1christmas,$1ladybug_reds
#@cli rep_transfer_color_reduced: [palette],0<=_dither<=1,_pixel_ratio_w>=0,_pixel_ratio_h>=0,_windows_width>=0,_window_height>=0,_color_restriction_per_window>=0,_color_restriction_per_whole>=0,_number_of_alpha>=0,_alpha_dithering>=0,_alpha_mode={ 0=index | 1=window-index | 2=ordered },_alpha_restrict>=0 : { bit_depth | bit_a:...:bit_z | :[palette] },0<=_dither<=1,_pixel_ratio_w>=0,_pixel_ratio_h>=0,_color_restriction_per_whole>=0,_number_of_alpha>=0,_alpha_dithering>=0,_alpha_mode={ 0=index | 1=ordered }
#@cli : Change images to look as if it was reduced. Can be used to emulate old hardware.
rep_transfer_color_reduced:
skip ${3=1},${4=1},${5=1},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=}

# $1  = [palette] = $1                                              | $1 = { bit_depth | bit_a:...:bit_z | :[palette] } = $1
# $2  = 0<=_dither<=1 = $2                                          | $2 = 0<=_dither<=1 = $2
# $3  = _pixel_ratio_w>=0 = $3                                      | $3 = _pixel_ratio_w>=0 = $3
# $4  = _pixel_ratio_h>=0 = $4                                      | $4 = _pixel_ratio_h>=0 = $4
# $5  = _windows_width>=0 = $5                                      | $5 = _threshold_map = $5
# $6  = _window_height>=0 = $6                                      | $6 = _color_restriction_per_whole>=0 = $6
# $7  = _color_restriction_per_window>=0 = $7                       | $7 = _number_of_alpha>=0 = $7
# $8  = _color_restriction_per_whole>=0 = $8                        | $8 = _alpha_dithering>=0 = $8
# $9  = _number_of_alpha>=0 = $9                                    | $9  =_alpha_mode={ 0=index | 1=ordered } = $9
# $10 = _alpha_dithering>=0 = $10                                   | $10 = _return_index_values={ 0=color | 1=index_value | 2=index_value_without_rescale } = $10
# $11 = _alpha_mode={ 0=index | 1=window-index | 2=ordered } = $11
# $12 = _alpha_restrict>=0                                   = $12
# $13 = _alpha_threshold_map                                 = $13
# $14 = _return_index_values={ 0=color | 1=index_value | 2=index_value_without_rescale } = $14

if ${is_image_arg\ $1} mode=0
else mode={(find('$1',':',0,1)!=-1)||isint($1)}
fi

if $mode

  location_of_bracket={find('$1','[',0,1)}

  if $location_of_bracket!=-1
    ('$1')
    crop. $location_of_bracket,{w#-1-1}
    img_arg={t}
    rm.
    pass$img_arg 0
    _rep_transfer_color_reduced[^-1] $mode,[-1],${2-10}
    rm.
  else _rep_transfer_color_reduced $mode,${1-10}
  fi

else

  pass$1 0
  _rep_transfer_color_reduced[^-1] $mode,[-1],${2-14}
  rm.

fi
_rep_transfer_color_reduced:
skip ${3=1},${4=1},${5=1},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=}

# Indexed                                                           | Ordered
# $1  = mode      = $1                                              | $1 = mode
# $2  = [palette] = $2                                              | $2 = { bit_depth | bit_a:...:bit_z | :[palette] } = $2
# $3  = 0<=_dither<=1 = $3                                          | $3 = 0<=_dither<=1     = $3
# $4  = _pixel_ratio_w>=0 = $4                                      | $4 = _pixel_ratio_w>=0 = $4
# $5  = _pixel_ratio_h>=0 = $5                                      | $5 = _pixel_ratio_h>=0 = $5
# $6  = _windows_width>=0 = $6                                      | $6 = _threshold_map = $6
# $7  = _window_height>=0 = $7                                      | $7 = _color_restriction_per_whole>=0 = $7
# $8  = _color_restriction_per_window>=0 = $8                       | $8 = _number_of_alpha>=0 = $8
# $9  = _color_restriction_per_whole>=0  = $9                       | $9 = _alpha_dithering>=0 = $9
# $10 = _number_of_alpha>=0  = $10                                  | $10  =_alpha_mode={ 0=index | 1=ordered } = $10
# $11 = _alpha_dithering>=0  = $11                                  | $11 = _return_index_values={ 0=color | 1=index_value | 2=index_value_without_rescale } = $11
# $12 = _alpha_mode={ 0=index | 1=window-index | 2=ordered } = $12
# $13 = _alpha_restrict>=0                                   = $13
# $14 = _alpha_threshold_map                                 = $14
# $15 = _return_index_values={ 0=color | 1=index_value | 2=index_value_without_rescale } = $15

# mode == 0 => indexed
# mode == 1 => ordered

num_of_images,mode,special_effect={$!},$1,0

if isnum($3)||ispercentage($3)
  dither={cut($3,0,1)}
else
  # This is where special effect are set up in
  dither,special_effect={[$mode?.25,1]}
  # special_effect defines whether it is applied.
  ('$3')
  split_point=-{w#-1-2}
  split. x,$split_point
  eff_factor={{-2,t}}
  dither*=$eff_factor
  ov={I(#-1,0)=='c'?4+(I(#-1,1)=='l'):(2*(I(#-1,0)=='l')+(I(#-1,1)=='v'))}
  rm[-2,-1]
fi

pixel_ratio_w,pixel_ratio_h,rescale_back_w,rescale_back_h={pixel_ratio=vmax([1,1],int(abs([$4,$5])));[pixel_ratio,pixel_ratio*100]}
return_index_values={$mode?(narg($11)?$11%3:0):(narg($15)?$15%3:0)}
out_color={!$return_index_values}

number_of_alpha,alpha_dithering={$mode?(narg($8)?int(abs($8))):(narg($10)?int(abs($10)))},{$mode?(narg($9)?cut($9,0,1)):(narg($11)?cut($11,0,1))}
alpha_mode={$number_of_alpha?($mode?($10&1)*2+1:$12%3+1)}

color_restriction_per_window,color_restriction_whole={!$mode?(narg($8)?$8:0)},{$mode?(narg($7)?int(abs($7))):(narg($9)?int(abs($9)))}

if !$mode&&($color_restriction_whole?($color_restriction_whole<=$color_restriction_per_window)) color_restriction_per_window=0 fi

decrement_color_restriction_whole={$color_restriction_whole-1}

pixel_ratio_gcd={gcd($pixel_ratio_w,$pixel_ratio_h)}
if $pixel_ratio_gcd>1 pixel_ratio_w,pixel_ratio_h/=$pixel_ratio_gcd fi

if $pixel_ratio_w==1||$pixel_ratio_h==1
  initial_rescale_w,initial_rescale_h={bd=max($pixel_ratio_w,$pixel_ratio_h);100*($pixel_ratio_w>$pixel_ratio_h?vector(#2,1)/[bd,1]:vector(#2,1)/[1,bd])}
else
  min_dimension,max_dimension={min($pixel_ratio_w,$pixel_ratio_h)},{max($pixel_ratio_w,$pixel_ratio_h)}
  recip_rd={1/($max_dimension/$min_dimension)}
  initial_rescale_w,initial_rescale_h={100*($pixel_ratio_w>$pixel_ratio_h?[$recip_rd,1]:[1,$recip_rd])}
fi

if $mode
 threshold_map_level,alpha_threshold_map={narg($6)?$6:3}
 alpha_restrict=$number_of_alpha
else
  window_width,window_height,alpha_restrict,alpha_threshold_map={int(abs([narg($6)?int(abs($6)),narg($7)?int(abs($7))]))},{narg($13)?int(abs($13))},{narg($14)?$14:3}
  if $window_width==1&&$window_height==1 color_restriction_per_window=0 fi
  if $window_width&&!$window_height window_height+=1 fi
  if $window_height&&!$window_width window_width+=1 fi
fi

use_images=0

if ${is_image_arg\ $2}

  pass$2 0 => palette

  if !(s%2) error pal_cont_alp fi

  if h#-1>1&&d#-1==1 rotate. -90
  elif h#-1>1&&d#-1>1 colormap. 0,,0
  fi

  if $color_restriction_whole>=w#-1 color_restriction_whole=0 fi
  if !$color_restriction_per_window color_restriction_per_window={w#-1} fi

  store. img_palette
  use_images+=1

fi

if $alpha_mode?($alpha_mode<($mode?2:3))

  $number_of_alpha,1,1,1,"begin(
      const dividier=(w-1)/255;
    );
    x/dividier;"

  => alpha

  use_images+=1

fi

if $use_images==2

  images="$>",-1
  v_col_info,v_alpha=[palette],[alpha]

elif $use_images==1

  images="$>",-1

  if ${is_image_arg\ $2}
    v_col_info,v_alpha=[palette],$number_of_alpha
  else
    v_col_info,v_alpha=$2,[alpha]
  fi

else

  images="$>"
  v_col_info,v_alpha=$2,$number_of_alpha

fi

contain_pal=${is_image_arg\ $v_col_info}

repeat $num_of_images {

  local[{[$images]}] {

    if s#0>4||!s#0 continue fi

    targ_img_alp,con_img_palette={!(s#0%2)},0

    resize[0] $initial_rescale_w%,$initial_rescale_h%,100%,100%,3

    if $contain_pal

      $img_palette

      con_img_palette=1

      use_color_space_conversion,min_col_pos={s0=s#0;s0-=!(s0%2);csc=s0!=s#-1;s#-1>s0?[csc,-1]:[csc,0];}

      if $use_color_space_conversion
        if $min_col_pos==-1 to_gray[-1]
        else
          cs_convert=${arg1\ s#0-1,to_gray,to_graya,to_rgb}
          $cs_convert[0]
        fi
      fi

    fi

    if $targ_img_alp?$out_color

      sh[0] 0,{s#0-2}

      if $color_restriction_whole&&$con_img_palette

        +index[-1] [palette],1,0
        histogram. 100%
        {w},1,1,1,x
        pixelsort. -,x,..
        crop. 0,0,$decrement_color_restriction_whole,0
        map. [palette]

        if $special_effect _rep_transfer_color_reduced_special_effect[-3] $ov,$eff_factor fi

        if $mode rep_ordered_dithering[-3] [-1],$dither,$threshold_map_level,$out_color,1
        else rep_index_by_window_and_color_restriction[-3] [-1],$dither,$color_restriction_per_window,$window_width,$window_height,1,$out_color
        fi

        rm[-2,-1]

      else

        if $special_effect _rep_transfer_color_reduced_special_effect[-1] $ov,$eff_factor fi

        if $mode rep_ordered_dithering[-1] $v_col_info,$dither,$threshold_map_level,$out_color,1
        else rep_index_by_window_and_color_restriction[-1] $v_col_info,$dither,$color_restriction_per_window,$window_width,$window_height,1,$out_color
        fi

      fi

      rm.

      if $alpha_mode

        sh[0] {s#0-1}

        if $alpha_mode==3 rep_ordered_dithering[-1] $v_alpha,$alpha_dithering,$alpha_threshold_map,$out_color,1
        elif $alpha_mode==2 rep_index_by_window_and_color_restriction[-1] $v_alpha,$alpha_dithering,$alpha_restrict,$window_width,$window_height,1,$out_color
        else index[-1] $v_alpha,$alpha_dithering,1
        fi

        rm.

      fi

    else

      if $targ_img_alp split_opacity[0] fi

      if $color_restriction_whole&&$con_img_palette

        +index[0] [palette],1,0
        histogram. 100%
        {w},1,1,1,x
        pixelsort. -,x,..
        crop. 0,0,$decrement_color_restriction_whole,0
        map. [palette]

        if $mode rep_ordered_dithering[0] [-1],$dither,$threshold_map_level,$out_color,1
        else rep_index_by_window_and_color_restriction[0] [-1],$dither,$color_restriction_per_window,$window_width,$window_height,1,$out_color
        fi

        rm[-2,-1]

      else

        if $mode rep_ordered_dithering[0] $v_col_info,$dither,$threshold_map_level,$out_color,1
        else rep_index_by_window_and_color_restriction[0] $v_col_info,$dither,$color_restriction_per_window,$window_width,$window_height,1,$out_color
        fi

      fi

      if $targ_img_alp
        if $return_index_values
          if $alpha_mode==3 rep_ordered_dithering[1] $v_alpha,$alpha_dithering,$alpha_threshold_map,$out_color,1
          elif $alpha_mode==2 rep_index_by_window_and_color_restriction[1] $v_alpha,$alpha_dithering,$alpha_restrict,$window_width,$window_height,1,$out_color
          else index[1] $v_alpha,$alpha_dithering,$out_color
          fi
          a[0,1] c
        else rm[1]
        fi
      fi

    fi

    if $con_img_palette rm[palette] fi

    if $return_index_values!=2 resize[0] $rescale_back_w%,$rescale_back_h%,100%,100%,1 fi
  }

}

remove_named alpha

_rep_transfer_color_reduced_special_effect:

# This is where special effect are set up in

if $1>3
 f ":begin(
   const eff_factor=cut($2,0,1)/4;
   const overlay_value=($1&1)*255;
   arr_overlay=vector(#s,overlay_value);
  );
  ((x+y)&1)?lerp(I,arr_overlay,eff_factor):I;"
else
 f ":begin(
   const overlay_value=(int($1/2)%2)*255;
   const eff_factor=cut($2,0,1)/4;
   const direction=$1%2;
   arr_overlay=vector(#s,overlay_value);
   direction?(
    eff_app()=x%2?(lerp(I,arr_overlay,eff_factor);):I;
   ):(
    eff_app()=y%2?(lerp(I,arr_overlay,eff_factor);):I;
   );
  );
  eff_app();"
fi
#@cli rep_index_by_window_and_color_restriction:[palette],0<=_dithering<=1,_color_restriction>2,_window_width,_window_height,_window_depth,_map_palette={ 0 | 1 }
#@cli : Index images per window
rep_index_by_window_and_color_restriction:
skip ${2=1},${3=},${4=1},${5=1},${6=1},${7=1}
dithering,wi_w,wi_h,wi_d,map_palette,timg={cut($2,0,1)},{vmax(vector(#3,1),int(abs([${4-6}])))},{$7%2},{$!}

pass$1 1

if h#-1>1&&d#-1==1
 rm. pass$1 0
 rotate. -90
elif h#-1>1&&d#-1>1
 rm. pass$1 0
 colormap. 0,,0
fi

col_res={narg($3)?cut(int(abs($3)),2,w#-1):w#-1}
dec_col_res={$col_res-1}

if $dithering

 # Jarvis, Judice, and Ninke dithering Array
  jjn_1R0D,jjn_2R0D,\
  jjn_2L1D,jjn_1L1D,jjn_M01D,jjn_1R1D,jjn_2R1D,\
  jjn_2L2D,jjn_1L2D,jjn_M02D,jjn_1R2D,jjn_2R2D\
  ={([7,5,3,5,7,5,3,1,3,5,3,1]/48)*$dithering}

fi

eval "
  const spectrum_size=s#-1;
  const rf=$timg;
  valid_spec=1;
  repeat(rf,id,
   if(s#id!=spectrum_size,valid_spec=0;break(););
  );
  valid_spec;
 "

if !${} error incompatible_img_pal fi

if $col_res>=w#-1
 index[^-1] [-1],$dithering,$map_palette
 rm.
 return
fi

repeat $timg {
 local[$>,-1] {

  ow,oh,od,tw,th,td,nw,nh,nd={od=[w#0,h#0,d#0];wd=vmin([w#0,h#0,d#0],[$wi_w,$wi_h,$wi_d]);td=ceil(od/wd);nd=td*wd;[od,td,nd]}

  if [$tw,$th,$td]==vector(#3,1)
   +index[0] [1],1,0
   histogram. 100%
   {w},1,1,1,x
   pixelsort. -,x,..
   crop. 0,0,$dec_col_res,0
   map. ...
   index[0] .,$dithering,$map_palette
  else

   r[0] $nw,$nh,$nd,100%,0,3,.5,.5,.5

   +index[0] [1],{$dithering?.75},0

   $tw,$th,$td,1,*"begin(
     const nb_cols=w#1;

     const spectrum_size=s#1;
     const inc_spectrum_size=spectrum_size+1;

     const nb_restrict=$col_res;
     const dec_nb_restrict=nb_restrict-1;

     const res_y_spec=nb_restrict*spectrum_size;

     const wi_w=$wi_w;
     const wi_h=$wi_h;
     const wi_d=$wi_d;

     const dec_wi_w=wi_w-1;
     const dec_wi_h=wi_h-1;
     const dec_wi_d=wi_d-1;

     const box_dim=wi_w*wi_h*wi_d;

     init_freq_y_ind=expr('(x%2)?int(x/2);',nb_cols*2);
     init_sel_res_pal_dist_arr=vector(#nb_restrict,0);

     const dithering_mode=$dithering;
     const map_palette=$map_palette;

     dithering_mode?(

      #                            jjn_1R0D jjn_2R0D
      # jjn_2L1D jjn_1L1D jjn_M01D jjn_1R1D jjn_2R1D
      # jjn_2L2D jjn_1L2D jjn_M02D jjn_1R2D jjn_2R2D

      const jjn_1R0D=$jjn_1R0D;
      const jjn_2R0D=$jjn_2R0D;
      const jjn_2L1D=$jjn_2L1D;
      const jjn_1L1D=$jjn_1L1D;
      const jjn_M01D=$jjn_M01D;
      const jjn_1R1D=$jjn_1R1D;
      const jjn_2R1D=$jjn_2R1D;
      const jjn_2L2D=$jjn_2L2D;
      const jjn_1L2D=$jjn_1L2D;
      const jjn_M02D=$jjn_M02D;
      const jjn_1R2D=$jjn_1R2D;
      const jjn_2R2D=$jjn_2R2D;

      v_col()=I(#2,pos_x,pos_y,pos_z);

      # gen_res_pal_col();

      map_palette?(
       result_img_part()=(
        old_color=I(#0,pos_x,pos_y,pos_z);
        new_color=I(#1,res_col_id[argmin(sqrt(res_color_sum))],0,0);

        I(#0,pos_x,pos_y,pos_z)=new_color;
       );
      ):(
       result_img_part()=(
        old_color=I(#0,pos_x,pos_y,pos_z);
        new_color_pos=res_col_id[argmin(sqrt(res_color_sum))];
        new_color=I(#1,new_color_pos,0,0);

        i(#0,pos_x,pos_y,pos_z,0)=new_color_pos;
       );
      );

      result_img()=(
       result_img_part();
       diff_color=old_color-new_color;

       use_strip_1D=(pos_y+1)<min_out_of_boundary_offset_pos[2];
       use_strip_2D=(pos_y+2)<min_out_of_boundary_offset_pos[2];

       use_strip_1D?(
        I(#0,pos_x,pos_y+1,pos_z)+=diff_color*jjn_M01D;
       );

       use_strip_2D?(
        I(#0,pos_x,pos_y+2,pos_z)+=diff_color*jjn_M02D;
       );

       (pos_x-2)>min_out_of_boundary_offset_pos[0]?(
        use_strip_1D?(
         I(#0,pos_x-2,pos_y+1,pos_z)+=diff_color*jjn_2L1D;
        );
        use_strip_2D?(
         I(#0,pos_x-2,pos_y+2,pos_z)+=diff_color*jjn_2L2D;
        );
       );

       (pos_x-1)>min_out_of_boundary_offset_pos[0]?(
        use_strip_1D?(
         I(#0,pos_x-1,pos_y+1,pos_z)+=diff_color*jjn_1L1D;
        );
        use_strip_2D?(
         I(#0,pos_x-1,pos_y+2,pos_z)+=diff_color*jjn_1L2D;
        );
       );

       (pos_x+1)<min_out_of_boundary_offset_pos[1]?(
        I(#0,pos_x+1,pos_y,pos_z)+=diff_color*jjn_1R0D;
        use_strip_1D?(
         I(#0,pos_x+1,pos_y+1,pos_z)+=diff_color*jjn_1R1D;
        );
        use_strip_2D?(
         I(#0,pos_x+1,pos_y+2,pos_z)+=diff_color*jjn_1R2D;
        );
       );

       (pos_x+2)<min_out_of_boundary_offset_pos[1]?(
        I(#0,pos_x+2,pos_y,pos_z)+=diff_color*jjn_2R0D;
        use_strip_1D?(
         I(#0,pos_x+2,pos_y+1,pos_z)+=diff_color*jjn_2R1D;
        );
        use_strip_2D?(
         I(#0,pos_x+2,pos_y+2,pos_z)+=diff_color*jjn_2R2D;
        );
       );

      );

     ):(

      v_col()=I(#0,pos_x,pos_y,pos_z);

      # gen_res_pal_col();

      map_palette?(
       result_img()=(
        I(#0,pos_x,pos_y,pos_z)=I(#1,res_col_id[argmin(sqrt(res_color_sum))],0,0);
       );
      ):(
       result_img()=(
        i(#0,pos_x,pos_y,pos_z,0)=res_col_id[argmin(sqrt(res_color_sum))];
       );
      );
     );

    );

    c_xp=x*wi_w;
    c_yp=y*wi_h;
    c_zp=z*wi_d;

    min_out_of_boundary_offset_pos=[c_xp,c_xp,c_yp]+[-1,wi_w,wi_h];

    freq_y_ind=init_freq_y_ind;

    tv=crop(#2,c_xp,c_yp,c_zp,0,wi_w,wi_h,wi_d,1);

    repeat(box_dim,k,
     ++freq_y_ind[tv[k]*2];
    );

    freq_y_ind=sort(freq_y_ind,0,nb_cols,2);
    res_col_id=(freq_y_ind)[1,nb_restrict,2];

    res_pal=vector(#res_y_spec,0);

    repeat(nb_restrict,p,
     res_pal_col=I(#1,res_col_id[p],0,0);
     repeat(spectrum_size,q,
      res_pal[q*nb_restrict+p]=res_pal_col[q];
     );
    );

    repeat(wi_d,oz,
     pos_z=c_zp+oz;

     repeat(wi_h,oy,
      pos_y=c_yp+oy;

      repeat(wi_w,ox,
       pos_x=c_xp+ox;

       res_color_sum=init_sel_res_pal_dist_arr;
       v_col=I(#0,pos_x,pos_y,pos_z);

       repeat(spectrum_size,k,
        res_color_sum+=sqr((res_pal)[k*nb_restrict,nb_restrict]-v_col[k]);
       );

       result_img();

      );
     );
    );
    0;
    "

   if !$map_palette channels[0] 0 fi

   r[0] $ow,$oh,$od,100%,0,0,.5,.5,.5

  fi

  k[0,1]

 }

}

rm.
#@cli rep_ordered_dithering:
#@cli : level>0,0<=dither<=1,threshold_map_iter>0,map_pal={ 0 | 1 },_use_previous_threshold_map={ 0 | 1 } :
#@cli : level_a>0:.:level_z>0,0<=dither<=1,threshold_map_iter>0,map_pal={ 0 | 1 },_use_previous_threshold_map={ 0 | 1 }  :
#@cli : [palette],0<=dither<=1,threshold_map_iter>0,map_pal={ 0 | 1 },_use_previous_threshold_map={ 0 | 1 } :
#@cli : level<0,0<=dither<=1,threshold_map_iter>0,spread,_use_previous_threshold_map={ 0 | 1 }
#@cli :
#@cli : Apply ordered dithering effect onto image.
#@cli :
#@cli : Note A: depth_a:.:depth_z implies that the first argument is a set of arguments joined by the ':' char. This is used for separating bit depth channels.
#@cli : Note B: Negative value is used to alter values of images without indexing, and that is useful for generating windows-based ordered-dithering with the use of rep_index_by_window_and_color_restriction command.
rep_ordered_dithering:
skip ${4=1},${5=0}
check "($2?($2>=0&&$3>0):1)"

dithering,iteration={cut(abs($2),0,1)},{int(abs($3))}

if ${is_image_arg\ $1} use_pal_image=1
else use_pal_image=0
fi

command "convert_first_arg_to_mul_args :

  ('$1')

  local[-1] {
   split. -,{':'}
   foreach[^-1] {
    (',')
    a y
   }
   a y
  }

  _bit_depths={t} rm.

  u $_bit_depths"

command "index_from_bitmaps :

  t_bit_depths:=[$_bit_depths]+1

  foreach {

   if s>$_narg_bit_depths
    sh. 0,{$_narg_bit_depths-1}
   fi

   if s==3
    dims:=vector3($t_bit_depths,1,1)
    $dims,{s},:\"begin(
      const mxi=w-1;
      const myi=h-1;
      const mzi=d-1
     );
     [x/mxi,y/myi,z/mzi]*255;\"
   elif s==2
    dims:=vector3(vector2($t_bit_depths),1,1)
    $dims,{s},:\"begin(
      const mxi=w-1;
      const myi=h-1;
     );
     [x/mxi,y/myi]*255;\"
   else
    dims:=vector1(vector2($t_bit_depths),1,1)
    $dims,{s},\"begin(
      const mxi=w-1;
     );
     x/mxi*255;\"
   fi

   index[-2] [-1],0,1

   k[0]

  }"

if isnum($1)
 if $1<0

  if $#!=4 error inv_arg_cnt fi
  if $-1==0 error inv_spr fi

  +rep_bayer_threshold_map $iteration,,$5

  f[^-1] "begin(
    const n=w#-1-1;
    const dithering=$dithering*abs($-1);
   );
   thres_x=x&n;
   thres_y=y&n;
   threshold_map=i(#-1,thres_x,thres_y,0,0);
   new_color=(I+threshold_map*dithering);"
  rm.

  return

 fi
fi

if $use_pal_image

 pass$1 0

 +rep_bayer_threshold_map $iteration,,$5

 repeat $!-2 {
  local[$>,-2,-1] {

   {w#0},{h#0},100%,1,"
     v_col=I#0;
     color_sum=vector(#w#-2,0);
     repeat(s#-2,k,
      color_sum+=sqr(crop(#-2,0,0,0,k,w#-2,1,1,1)-v_col[k]);
     );
     color_sum=sqrt(color_sum);
     p=argmin(color_sum);
     color_sum[p];
     "
   spread:=ic#-1*2

   rm.

   if $spread

    f[0] "begin(
      const n=w#-1-1;
      const scale=$dithering*$spread;
     );
     thres_x=x&n;
     thres_y=y&n;
     threshold_map=i(#-1,thres_x,thres_y,0,0);
     v_col=cut((I+threshold_map*scale),0,255);"

    index[0] [1],0,$4

   fi

  }
 }

 rm[-2,-1]

else

 if $dithering

  _bit_depths=${-convert_first_arg_to_mul_args}
  var_bit_depths:=var($_bit_depths)

  if !$var_bit_depths&&narg($_bit_depths)>0
    _bit_depths:=([$_bit_depths])[0]
  fi

  if isint($_bit_depths)

   +rep_bayer_threshold_map $iteration,,$5

   f[^-1] "begin(
     const n=w#-1-1;
     const bit_depth=max(1,int(abs($_bit_depths)));
     const scale=255/bit_depth;
     const end_scale=$4?scale:1;
     const dithering=$dithering;
     const internal_scale=scale*dithering;
     const power_level=s>1?2^(1/(bit_depth+.5)):1;
    );
    thres_x=x&n;
    thres_y=y&n;
    threshold_map=i(#-1,thres_x,thres_y,0,0);
    new_color=(I+internal_scale*threshold_map)/scale;
    inew_color=int(new_color);
    exp_dist_from_inew_color=abs(new_color-inew_color)^power_level;
    cut(round(lerp(new_color,exp_dist_from_inew_color+inew_color,dithering))*end_scale,0,255);"

   rm.

  else

   _narg_bit_depths:=narg($_bit_depths)
   if $_narg_bit_depths>3 error excess_args fi

   +rep_bayer_threshold_map $iteration

   f[^-1] "begin(
     const n=w#-1-1;
     const dithering=$dithering;
     _bit_depths=vector(#s,"$_bit_depths");
     scale=255/_bit_depths;
     internal_scale=scale*dithering;
     power_level=2^(1/_bit_depths);
    );
    thres_x=x&n;
    thres_y=y&n;
    threshold_map=i(#-1,thres_x,thres_y,0,0);
    new_color=(I+internal_scale*threshold_map*dithering);"

   rm.

   index_from_bitmaps

  fi

 else

  if isint($1)

   f "begin(
     const bit_depth=max(1,int(abs($1)));
     const scale=255/bit_depth;
    );
    round(I/scale)*scale;"

  else

   _bit_depths=${-convert_first_arg_to_mul_args}
   _narg_bit_depths:=narg($_bit_depths)
   if $_narg_bit_depths>3 error excess_args fi

   index_from_bitmaps

  fi

 fi

fi

uncommand convert_first_arg_to_mul_args,index_from_bitmaps
#@cli +rep_bayer_threshold_map: iteration,_normalize,_load_preserved_map
#@cli : Create Bayer Threshold Map
+rep_bayer_threshold_map:
skip ${2=1},${3=0}

if narg($_bayer_threshold_map)&&$3
 $_bayer_threshold_map
else
 ws=2

 (0,2;3,1)
 +store. initial_map

 repeat $1 {

  ws*=2

  $initial_map

  $ws,$ws

  eval[-2] "begin(
    const ws=$ws;
    const half_ws=ws>>1;
    initial=crop(#-3);
   );
   M_Surface=initial*4;
   M_Surface+=i;
   draw(#-1,M_Surface,x*half_ws,y*half_ws,0,0,half_ws,half_ws,1,1);
   "

  rm[-3,-2]

 }

 if $2

  +. 1
  /. {4^($1+1)}
  -. {ia#-1}

 fi

 +store. _bayer_threshold_map
fi
#@cli modf: eq. to 'modular_formula'.
modf:
skip ${2=255},${3=100%}
max_img_ind={$!-1}
modf_arg2,modf_arg3=${2-3}

if ${is_image_arg\ $2}
 pass$2 1
 name[-1] max_channel_image
 modf_arg2=[$max_channel_image]
fi

if ${is_image_arg\ $3}
 pass$3 1
 name[-1] channel_values_image
 modf_arg3=[$channel_values_image]
fi

modular_formula[0-$max_img_ind] $1,$modf_arg2,$modf_arg3
keep[0-$max_img_ind]
#@cli modular_formula : operation,max_channel_value={ float_value | [image] },_channel_values={ float_value(%) | [image] }
#@cli : Apply modular formulas into selected images. 'channel_value' can be values outside the channel ranges of image.
#@cli : When using a image argument to max_channel_value, the dimension should be equal to the spectrum of target images.
#@cli : When using a image argument to channel_value, it can be single spectrum or equal to the spectrum of target images.
#@cli : (eq. to 'modf').
#@cli : operation can be { 0=modulo | 1=modulo_continuous | 2=divisive | 3=divisive_continuous | 4=additive | 5=additive_continuous}
#@cli : In addition, the operation variable can be the corresponding string as argument.
#@cli : Author: Reptorian.
#@cli : Default value: '_channel_value=100%'
modular_formula:
skip ${2=255},${3=100%}
if isint($1)
	modular_mode={int($1)%6}
else
		modulo,modulo_continuous,divisive,divisive_continuous,additive,additive_continuous=0,1,2,3,4,5
		modular_mode=$$1
		if !narg($modular_mode) error invalid_input fi
fi

max_images_index,utilize_max_channel_image,utilize_channel_values_image={$!-1},0,0

if ${is_image_arg\ $2}
	pass$2 1
	name[-1] max_channel_image
	if find(crop(#-1),0,0,1)+1 error invalid_max_chan_val_set fi
	utilize_max_channel_image=1
	if s==1 max_channel={i} fi
else
	if !$2 error invalid_max_chan_val fi
fi

if ${is_image_arg\ $3}
	pass$3 1
	name[-1] channel_values_image
	utilize_channel_values_image=1
else
	use_percent_mode:=ispercentage($3)
	if !$3
		if $modular_mode==2||$modular_mode>3 return
		else
			foreach { 100%,100%,100%,100% rm.. } return
		fi
	fi
fi

fill[0-$max_images_index] "begin(
		const modular_mode=$modular_mode;
		const epsilon=1E-13;
		const utilize_max_channel_image=$utilize_max_channel_image;

		if(utilize_max_channel_image,
			const max_channel_reference=$max_channel_image;

			whds#max_channel_reference==1?(
				const max_channel=$max_channel;
				const max_channel_mod=max_channel+epsilon;
				const double_max_channel=max_channel*2;
				const use_max_channel_array=0;
			):(
				max_channel=crop(#max_channel_reference);
				max_channel_mod=max_channel+epsilon;
				double_max_channel=max_channel*2;
				const use_max_channel_array=1;
			);
		,
			const max_channel=$2;
			const max_channel_mod=max_channel+epsilon;
			const double_max_channel=max_channel*2;
			const use_max_channel_array=0;
		);

		$utilize_channel_values_image?(
			const channel_values_reference=$channel_values_image;
			const spectrum_size_of_channel_values_reference=s#channel_values_reference;
			const multispectrum_mode=spectrum_size_of_channel_values_reference>1;

			multispectrum_mode?(
				multiplier()=(
					channels_values=I#channel_values_reference;
					nonzero_values=bool(channels_values);
					zero_values=!channels_values;
					channels_values+=zero_values;
					result_multiplier();
				);0;
			):(
				multiplier()=(
					channel_value=i(#channel_values_reference,x,y,z,0);
					channel_value?max_channel/channels_values;
				);0;
			);

			modular_mode==0?(
				multispectrum_mode?(
					modular_output()=(
						channels_values=abs(I#channel_values_reference);
						multiplier=bool(channels_values);
						(I%(channels_values+epsilon)*multiplier)%max_channel_mod;
					);
				):(
					modular_output()=(
						channel_value=i(#channel_values_reference,x,y,z,0);
						channel_value?I%(channel_value+epsilon)%max_channel_mod;
					);
				);
			):
			modular_mode==1?(
				multispectrum_mode?(
					modular_output()=(
						channels_values=I#channel_values_reference;
						multiplier=bool(channels_values);
						channels_values+=epsilon*(1-multiplier);
						a=I%(channels_values*2)%max_channel_mod;
						multiplier*(channels_values-abs(channels_values-a));
					);
				):(
					modular_output()=(
						channel_value=i(#channel_values_reference,x,y,z,0);
						channel_value?(
							double_channel_value=channel_value*2;
							a=I%double_channel_value;
							channel_value-abs(channel_value-a);
						);
					);
				);
			):
			modular_mode==2?(
				multispectrum_mode?(
					result_multiplier()=nonzero_values*(max_channel/channels_values)+zero_values;
					modular_output()=(I*multiplier())%max_channel_mod;
				):(
					modular_output()=(
						channel_value=i(#channel_values_reference,x,y,z,0);
						channel_value?(
							(I*(max_channel/channel_value))%max_channel_mod;
						):I;
					);
				);
			):
			modular_mode==3?(
				multispectrum_mode?(
					result_multiplier()=nonzero_values*(max_channel/channels_values);
					modular_output()=(
						a=(I*multiplier())%double_max_channel;
						max_channel-abs(max_channel-a);
					);
				):(
					modular_output()=(
						channel_value=i(#channel_values_reference,x,y,z,0);
						channel_value?(
							a=(I*(max_channel/channel_value))%double_max_channel;
							max_channel-abs(max_channel-a);
						);
					);
				);
			):
			modular_mode==4?(
				multispectrum_mode?(
					modular_output()=(I+I#channel_values_reference)%max_channel_mod;
				):(
					modular_output()=(I+i(#channel_values_reference,x,y,z,0))%max_channel_mod;
				);
			):(
				multispectrum_mode?(
					modular_output()=(
						a=(I+I#channel_values_reference)%double_max_channel;
						max_channel-abs(max_channel-a);
					);
				):(
					modular_output()=(
						a=(I+i(#channel_values_reference,x,y,z,0))%double_max_channel;
						max_channel-abs(max_channel-a);
					);
				);
			);
		):(
			const use_percent_mode=$use_percent_mode;
			const divisive_mode=inrange(modular_mode,2,3,1,1);

			divisive_mode?(
				use_percent_mode?(
					const multiplier=1/$3;
				):(
					utilize_max_channel_image?(
						multiplier=max_channel/$3;
					):(
						const multiplier=max_channel/$3;
					);
				);
			):(
				use_percent_mode?(
					use_max_channel_array?(
						channels_values=max_channel*$3;
						if(modular_mode&1,
							double_channels_values=channels_values*2;
						);
						sum_channels_values_eps=channels_values+epsilon;
					):(
						const channels_values=max_channel*$3;
						if(modular_mode&1,
							const double_channels_values=channels_values*2;
						);
						const sum_channels_values_eps=channels_values+epsilon;
					);
				):(
					use_max_channel_array?(
						channels_values=vector(#s,$3);
						if(modular_mode&1,
							double_channels_values=channel_values*2;
						);
						sum_channels_values_eps=channels_values+epsilon;
					):(
						const channels_values=$3;
						if(modular_mode&1,
							const double_channels_values=channels_values*2;
						);
						const sum_channels_values_eps=channels_values+epsilon;
					);
				);
			);

			modular_mode==0?(
				modular_output()=I%sum_channels_values_eps%max_channel_mod;
			):
			modular_mode==1?(
				modular_output()=(
					a=I%double_channels_values;
					channels_values-abs(channels_values-a);
				);
			):
			modular_mode==2?(
				modular_output()=(I*multiplier)%max_channel_mod;
			):
			modular_mode==3?(
				modular_output()=(
					a=(I*multiplier)%double_max_channel;
					max_channel-abs(max_channel-a);
				);
			):
			modular_mode==4?(
				modular_output()=(I+channels_values)%max_channel_mod;
			):(
				modular_output()=(
					a=(I+channels_values)%double_max_channel;
					max_channel-abs(max_channel-a);
				);
			);
		);
	);
	modular_output();"

keep[0-$max_images_index]
#@cli rep_photomosaic : {foldername|[images_arg]},_tile_width>=0,_tile_height>=0,_dithering<=1,0<=_interpolation<=5,_palette={ 0=average, 1=median},_autocrop,_maxalp
#@cli : Generates mosaic using multiple pictures using indexing methodology, and uses either average or median to determine the mapping based on colors. Tile_Width and Tile_Height cannot be both zero!\n
#@cli : Author: Reptorian.
#@cli : Default value: 'tile_height=0', 'interpolation=5', 'autocrop=0'
rep_photomosaic:
skip ${3=0},${4=.5},${5=0},${6=0},${7=0},${8=255}

include_image_as_arg=${"is_image_arg $1"}
tile_width={round(abs($2))}
tile_height={round(abs($3))}
half_perimeter={$tile_width*$tile_height}
non_zero_length={$tile_width+$tile_height}
total_target_img={$!}
if !$tile_width&&!$tile_height error "($"1>0")"&&"($"2>0")"==F fi
e[^-1] "Generating Mosaic!"

if $include_image_as_arg
 pass$1 0
else
 ig $1
fi

total_end_img={$!}

if ($!-$total_target_img<2) error "_"#"imports>=2==F" fi

diff={$total_end_img-$total_target_img}

if ${-max_s}==4 to_rgba
elif ${-max_s}==3 to_rgb
elif ${-max_s}==2 to_graya
elif ${-max_s}==1 to_gray
fi

if s==2||s>3 contain_alpha=1
else contain_alpha=0
fi

endchan={s-2}

if $tile_width&&$tile_height

 if $7 autocrop[$total_target_img--1] fi
 rep_aspect_crop_2d[$total_target_img--1] $tile_width,$tile_height

 if $contain_alpha

  sh[$total_target_img--1] 0,{s-2}

  if $5==1 +rep_lbchstatfunc_to_pal[$total_end_img--1] median
  else +rep_lbchstatfunc_to_pal[$total_end_img--1] average
  fi

  rm[$total_end_img--2]

 else

  if $5==1 +rep_lbchstatfunc_to_pal[$total_target_img--1] median
  else +rep_lbchstatfunc_to_pal[$total_target_img--1] average
  fi

 fi

 repeat $total_target_img {

  mini_width={ceil(w#$>/$tile_width)}
  mini_height={ceil(h#$>/$tile_height)}
  r[$>] {$mini_width*$tile_width},{$mini_height*$tile_height},100%,100%,0,1,.5,.5
  r[$>] $mini_width,$mini_height,100%,100%,{abs($6)+1}

  if $contain_alpha

   sh[$>] 0,$endchan

   index. [-2],$4,1

   f. "begin(
     const length=w#-2;
    );
    repeat(length,v,
     if(I==I(#-2,v,0),break(););
    );
    v+$total_target_img;"

   rm.

  else

   index[$>] [-1],$4,1

   f[$>] "begin(
     const length=w#-1;
    );
    repeat(length,v,
     if(I==I(#-1,v,0),break(););
    );
    v+$total_target_img;"

  fi

 }

 rm.

 r[$total_target_img--1] $tile_width,$tile_height,100%,100%,{abs($6)+1}
 r[0-{$total_target_img-1}] {$tile_width*100}%,{$tile_height*100}%,100%,100%,1

 if $contain_alpha
  f[0-{$total_target_img-1}] c<s-1?i(#i,x%$tile_width,y%$tile_height,z,c):i/$8*i(#i0,x%$tile_width,y%$tile_height,z,s-1)
 else
  f[0-{$total_target_img-1}] i(#i,x%$tile_width,y%$tile_height,z,c)
 fi

 k[0-{$total_target_img-1}]

else

 same_dim=0

 if $total_target_img>1

  continue_loop=1
  count=1

  do
   if (w#0==w#$count)&&(h#0==h#$count)
    same_dim=1
   else
    same_dim=0
    continue_loop=0
   fi
   count+=1
  while $count<$total_target_img&&$continue_loop

 fi

 if $total_target_img==1||$same_dim

  temp_tile_width={floor(w#0>h#0?$non_zero_length:w#0/h#0*$non_zero_length)}
  temp_tile_height={floor(h#0>w#0?$non_zero_length:h#0/w#0*$non_zero_length)}
  tile_width={$temp_tile_width}
  tile_height={$temp_tile_height}
  mini_width={ceil(w#0/$tile_width)}
  mini_height={ceil(h#0/$tile_height)}

  if $7 autocrop[$total_target_img--1] fi
  rep_aspect_crop_2d[$total_target_img--1] $tile_width,$tile_height

  if $contain_alpha

   sh[$total_target_img--1] 0,{s-2}

   if $5==1 +rep_lbchstatfunc_to_pal[$total_end_img--1] median
   else +rep_lbchstatfunc_to_pal[$total_end_img--1] average
   fi

   rm[$total_end_img--2]

  else

   if $5==1 +rep_lbchstatfunc_to_pal[$total_target_img--1] median
   else +rep_lbchstatfunc_to_pal[$total_target_img--1] average
   fi

  fi

  r[0-{$total_target_img-1}] {$mini_width*$tile_width},{$mini_height*$tile_height},100%,100%,0,3,.5,.5
  r[0-{$total_target_img-1}] $mini_width,$mini_height,100%,100%,{abs($6)+1}

  repeat $total_target_img {

   if $contain_alpha

    sh[$>] 0,$endchan
    index. [-2],$4,1

    f. "begin(const length=w#-2;);
     repeat(length,v,
      if(I==I(#-2,v,0),break(););
     );
     v+$total_target_img;"
    rm.

   else

    index[$>] [-1],$4,1

    f[$>] "begin(const length=w#-1;);
     repeat(length,v,
      if(I==I(#-1,v,0),break(););
     );
     v+$total_target_img;"

   fi

  }

  rm.

  r[$total_target_img--1] $tile_width,$tile_height,100%,100%,{abs($6)+1}
  r[0-{$total_target_img-1}] {$tile_width*100}%,{$tile_height*100}%,100%,100%,1

  if $contain_alpha
   f[0-{$total_target_img-1}] c<s-1?i(#i,x%$tile_width,y%$tile_height,z,c):i/$8*i(#i0,x%$tile_width,y%$tile_height,z,s-1)
  else
   f[0-{$total_target_img-1}] i(#i,x%$tile_width,y%$tile_height,z,c)
  fi

  k[0-{$total_target_img-1}]

 else

  if $7 autocrop[$total_target_img--1] fi
  repeat $total_target_img {

   temp_tile_width={floor(w#$>>h#$>?$non_zero_length:w#$>/h#$>*$non_zero_length)}
   temp_tile_height={floor(h#$>>w#$>?$non_zero_length:h#$>/w#$>*$non_zero_length)}
   tile_width={$temp_tile_width}
   tile_height={$temp_tile_height}
   mini_width={ceil(w#$>/$tile_width)}
   mini_height={ceil(h#$>/$tile_height)}

   +rep_aspect_crop_2d[$total_target_img--1] $tile_width,$tile_height

   if $contain_alpha
    local[$total_end_img--1] {
     endid={$!}
     sh 0,{s-2}
     if $5==1 +rep_lbchstatfunc_to_pal[$endid--1] median
     else +rep_lbchstatfunc_to_pal[$endid--1] average
     fi
     rm[$endid--2]
    }
   else
    if $5==1 +rep_lbchstatfunc_to_pal[$total_end_img--1] median
    else +rep_lbchstatfunc_to_pal[$total_end_img--1] average
    fi
   fi

   r[$>] {$mini_width*$tile_width},{$mini_height*$tile_height},100%,100%,0,3,.5,.5
   r[$>] $mini_width,$mini_height,100%,100%,{abs($6)+1}

   if $contain_alpha
    sh[$>] 0,$endchan
    index. [-2],$4,1

    f. "begin(const length=w#-2;);
    repeat(length,v,
    if(I==I(#-2,v,0),break(););
    );
    v+$total_end_img;
    "
    rm.
   else
    index[$>] [-1],$4,1

    f[$>] "begin(const length=w#-1;);
    repeat(length,v,if(I==I(#-1,v,0),break();););
    v+$total_end_img;"
   fi

   rm.

   r[$total_end_img--1] $tile_width,$tile_height,100%,100%,{abs($6)+1}
   r[$>] {$tile_width*100}%,{$tile_height*100}%,100%,100%,1

   if $contain_alpha
    f[$>] c<s-1?i(#i,x%$tile_width,y%$tile_height,z,c):i/$8*i(#i0,x%$tile_width,y%$tile_height,z,s-1)
   else
    f[$>] i(#i,x%$tile_width,y%$tile_height,z,c)
   fi

   k[0-{$total_end_img-1}]

  }

  k[0-{$total_target_img-1}]

 fi
fi
#@cli rep_aspect_crop_2d: width_ratio>0,height_ratio>0,-1<=_shift_factor[%]<=1 : width_ratio>0,height_ratio>0,-1<=_shift_factor_a[%]<=1,-1<=_shift_factor_b[%]<=1
#@cli : Crop images based on specified aspect ratio.
#@cli :
#@cli : Code for finding new dimension was provided by Sumruv in discord/generative. The code that was provided applies only in the case of ratio not equal to 1.
#@cli : Default value: 'shift_factor=0'
#@cli : Author: Reptorian.
rep_aspect_crop_2d:
skip ${3=0},${4=}
check "$1>0&&$2>0"

# cr = Crop Ratio
# sf = Shift Factor
# dsf = Different Shift Factors
# ar = Aspect Ratio
# arc = Aspect Ratio Crop

use_dsf={narg($4)?1:0}

####################################################
#      Sumruv's Solution at discord/generative     #
#       let a_ratio = a2 / a1;                     #
#       let new_b2 = min(b1 * a_ratio, b2);        #
#       let new_b1 = new_b2 / a_ratio;             #
####################################################

cr2d_w,cr2d_h,sf_0,sf_1=${1-2},{(cut(($use_dsf?[$3,$4]:vector2($3)),-1,1)+1)/2}
crop_ratio={$cr2d_h/$cr2d_w}

if $crop_ratio==1
	m __$0_arc_2d_crop:"
		if w==h return fi

		if w>h
			start_point={int($sf_0*(w-h))}
			crop $start_point,0,{[$start_point,0]+(h-1)}
		else
			start_point={int($sf_1*(h-w)}
			crop $start_point,0,{[0,$start_point]+(w-1)}
		fi"
else
	m __$0_arc_2d_crop:"
		ratio={h/w}

		if $ratio==$crop_ratio return fi

		new_dim,mode={\"
				ny=min(w#-1*"$crop_ratio",h#-1);
				ny<h#-1?([round(ny),1]):([round(h#-1/"$crop_ratio"),0]);
			\"}

		shift_factor=${sf_$mode}

		if $mode
			start_point={int($shift_factor*(h-$new_dim))}
			crop 0,$start_point,{[w-1,$start_point+$new_dim-1]}
		else
			start_point={int($shift_factor*(w-$new_dim))}
			crop $start_point,0,{[$start_point+$new_dim-1,h-1]}
		fi"
fi

foreach { __$0_arc_2d_crop }

um __$0_arc_2d_crop
#@cli rep_nebulous: _main_surf_xy_factor>0,_main_surf_x_factor>0,_main_surf_y_factor>0,-100<=_x_center[%]<=100,-100<=_y_center[%]<=100,0<=_fxyangle<=360,_wave,0<=_lighting_angle<=360,_disturbance>=0,_distx,_disty,0<=_distangle<=360,_disturbance_mode={ 0= do_not_scale | 1=scale_by_axisfact },_color={ 0=gray | 1=color },_alpha_base={ 0=None | 1=hard_light | 2=hard_shade | 3=soft_light | 4=soft_light },_subpixelevel>=0,subpixelprocessingmethod={ 0=Average | 1=Linear | 2=Grid | 3=Bicubic | 4=Lanczos }
#@cli : Creates a Nebulous texture inspired by its Paint.NET plugin equivalent made by MadJik.\n
#@cli : '_main_surf_xy_factor' - Amount of waves by xy-axis.
#@cli : '_main_surf_x_factor' - Amount of waves by x-axis.
#@cli : '_main_surf_y_factor' - Amount of waves by y-axis.
#@cli : '_x_center' - Placement of Nebulous texture relative to the center by x-axis.
#@cli : '_y_center' - Placement of Nebulous texture relative to the center by y-axis.
#@cli : '_fxyangle' - Function angle of Nebulous texture.
#@cli : '_wave' - Amount of waves within waves.
#@cli : '_lighting_angle' - Shifts color output within waves
#@cli : '_disturbance' - Multiplier for distortion.
#@cli : '_distx' - Distorts function by x-axis.
#@cli : '_disty' - Distorts function by y-axis.
#@cli : '_distangle' - Distortion function Angle
#@cli : '_disturbance_mode' - Influences how the distortion result is calculated.
#@cli : '_color' - Color Output
#@cli : '_alpha_base' - determines the alpha based on waves angle.
#@cli : '_subpixelevel' - Subpixel processing level
#@cli : '_subpixelprocessingmethod' - Subpixel processing method. Only applicable when '_subpixelevel' is greater than 0.\n
#@cli : Default value: '_main_surf_x_factor=10','_main_surf_y_factor=10','_x_center[%]=0','_y_center[%]=0','_fxangle=0','_wave=1','_lighting_angle=0','_disturbance=0','_distx=100','_disty=100','_distangle=0','_disturbance_mode=0','_color=1','_alpha_base=0','_subpixellevel=1','_subpixelprocessingmethod=1'\n
#@cli : Author: Reptorian.
#@cli : $ 640,480,1,1 rep_nebulous 10,,,,,45,,,750,100,100,15,0,1,3 n 0,255 drgba
rep_nebulous:
skip ${2=10},${3=10},${4=0},${5=0},${6=0},${7=1},${8=0},${9=0},${10=100},${11=100},${12=0},${13=0},${14=1},${15=0},${16=0},${17=1}

if $1==0||$2==0||$3==0 v + error "Variable 1 to 3 cannot be zero!" v - fi
if $9<0 v + error "Disturbance factor cannot be less than 0!" v - fi

use_sub={abs($16)}
sublevel={$use_sub+1}
spec_count={!14?0+($15?1:0):3+($15?1:0)}

foreach {

	iw,ih={[w,h]}

	{$use_sub?w*$sublevel:w},{$use_sub?h*$sublevel:h},1,$spec_count,"begin(
			const sd=w/h;
			const shx=($4*w)/2;
			const shy=($5*h)/2;
			const sx=w>h?1:1/sd;
			const sy=w>h?sd:1;
			const sx2=2/sx;
			const sy2=2/sy;
			const ang=-pi*$6/180;
			const cos_ang=cos(ang);
			const sin_ang=sin(ang);
			const distlvl=$9*$1;
			const dist=pi/(distlvl/100);
			const disth=$10;
			const distv=$11;
			const dang=-pi*$12/180;
			const cos_dang=cos(dang);
			const sin_dang=sin(dang);
			const k=pi+((-pi+(pi*$7))*10)/10;
			const ld=-($8-$6)*pi/180;
			const IX_mul=$2*4;
			const IY_mul=$3*4;
			const cx_mul=$13?$2:1;
			const cy_mul=$13?$3:1;
			const iml=1.5*($1*10);
			const angld=ang+ld;
			const hpi=pi/2;
		);
		ix=(((x+shx)/w-.5)*iml)/sx;
		iy=(((y+shy)/h-.5)*iml)/sy;
		IX=ix*cos_ang-iy*sin_ang;
		IY=ix*sin_ang+iy*cos_ang;
		IX*=IX_mul;
		IY*=IY_mul;
		if(distlvl,
			dix=(x/w-.5)*sx2;
			diy=(y/h-.5)*sy2;
			DIX=dix*cos_dang-diy*sin_dang;
			DIY=dix*sin_dang+diy*cos_dang;
			cx=DIX*cx_mul;
			cy=DIY*cy_mul;
			fsd=sin(((cx+cy)/2)/dist);
			fcd=cos(((cy-cx)/2)/dist);
			IX+=disth*(fsd-fcd);
			IY-=distv*(fsd+fcd);
		);
		t=atan2(IY,IX);
		r=norm(IX,IY)/100;
		ti=sin(t)*cos(r)*k+r+angld;
		$15?(
			cg=[sin(pi+ti),sin(hpi+ti),sin(ti)];
			g=sum(cg);
			alp=$15>2?($15==3?g:g*-1):($15==2?(g*-1<0?-1:1):(g<0?-1:1));
			$14?[cg,alp]:[g,alp];
		):(
			$14?[sin(pi+ti),sin(hpi+ti),sin(ti)]:sin(ti)+sin(hpi+ti)+sin(pi+ti);
		);"

	rm..

	if $use_sub r $iw,$ih,1,{s},{$17+2} fi

}
#@cli rep_sptbwgp: eq. to 'rep_shift_pixel_to_boundary_with_group_pixels'
rep_sptbwgp: rep_shift_pixel_to_boundary_with_group_pixels $*
#@cli rep_shift_pixel_to_boundary_with_group_pixels: (-1/0%)<=_position<=(1/100%),_axis={ x | y | z },0%<_influence_factor[%]<=100%,0<=_threshold<=100%,_max_alpha>0,_channel_mode
#@cli : Shifts pixels to boundary by percentage using grouped pixels. position less than .5 means shift will be negative, and position greater than .5 means shift will be positive.
#@cli : Default values: '_influence_factor=100%','_threshold=0%','_max_alpha=255','_channel_mode=n/a'
rep_shift_pixel_to_boundary_with_group_pixels:
skip ${3=100%},${4=0},${5=255},${6=}

old_status=${}

use_custom_chan={narg($6)}
check "(size('$2')==1?isint(_'$2',_'x',_'z'))&&      # Axis
       inrange([${3-4}],0,1,1,1)==[1,1]&&            # Influence and Threshold
       $5>0&&$5<inf&&                                # max_alpha
       $use_custom_chan?isint($6,0,"${-max_s}"-1):1" # Channels to use

m $0_gen_args:"
  Ap={$""1%3}
  a0,a1,a2=$""2
  c1,c2,c3=$""{3--1}
  a$Ap=${arg0\\ $Ap,$c1,$c2,$c3}
  u $a0,$a1,$a2
  "

a1p={ispercentage($1)}
pos,axis,infl,thres,M:=$a1p?$1:($1+1)/2,_'$2'-_'x',${3-4},$5*$4

if !$infl&&!$thres return fi

if $axis&&!$a1p
	pos={1-$pos}
fi

check inrange($pos,0,1,1,1)

if $use_custom_chan
	ext_c=min(s#0-1,$6)
	tcr=$6
else
	ext_c=s#0-1
	tcr=3
fi

arg_resize=${$0_gen_args\ $axis,100%,1},1
chk_pos={`A='x,y,z';A[$axis<<1]=_'p';A;`}
ins_pos={`A='x,y,z';A[$axis<<1]=_'q';A;`}
step_size,D=${arg0\ $axis,1,w#0,wh#0},${arg0\ $axis,w#1,h#1,d#1}

foreach {
	if s==2||s>$tcr
		sh {$ext_c}

		if iv
			rm.

			100%,100%,100%,100%

			$arg_resize,${arg0\ {whd>0x1000},>,:}"
				begin(
					const sel_chan="$ext_c";
					const along_dim_length="$D";
					const step_size="$step_size";
					const influence=$infl;
					const thres=$thres;
					const pos=$pos;

					thres?(
						chk_chn_val()=i(#0,"$chk_pos",sel_chan)>=$M;
					):(
						chk_chn_val()=i(#0,"$chk_pos",sel_chan);
					);

					positions=vector(#along_dim_length);
					0;
				);
				found_values=0;

				repeat(along_dim_length,p,
					if(chk_chn_val(),
						positions[found_values++]=p;
					);
				);

				if(found_values,
					found_values==along_dim_length?(
						p=0;

						repeat(s#0,q,
							copy(i(#1,"$chk_pos",q),i(#0,"$chk_pos",q),along_dim_length,step_size,step_size);
						);
					):(
						ref_pos=round(lerp(0,along_dim_length-found_values,pos));

						repeat(found_values,q,
							p=positions[q];
							q=round(lerp(p,ref_pos,influence));
							I(#1,"$ins_pos")=I(#0,"$chk_pos");
							++ref_pos;
						);
					);
				);

				found_values;
				"
			rm[0,2]
		else
			rm.
		fi
	fi
}

um $0_gen_args
#@cli rep_sinowaterdist: (eq. to rep_sinusoidal_water_distortion)
rep_sinowaterdist: rep_sinusoidal_water_distortion $*
#@cli rep_sinusoidal_distortion: _xbalance>0,_ybalance>0,_scale>=0,_interpolation,_boundary_condition
#@cli : Shift by sinusoidal distortion formula.
rep_sinusoidal_water_distortion:
skip ${4=2},${5=1}
f "
	balanceY=y*sin(180)/$3*10;
	balanceX=x*cos(180)/$3*10;
	vx=x+cos(balanceY)*$1;
	vy=y+sin(balanceX)*$2;
	i(vx,vy,z,c,$4,($5?3:2));"
#@cli rep_binaltquad: eq. to 'rep_binary_alterating_quad_texture'.
rep_binaltquad: rep_binary_alterating_quad_texture $*
#@cli rep_binary_alterating_quad_texture: _style={ 0 = Horizontal , 1 = Diagonal , 2 = Simple },_variable_1>=0,_variable_2>=0,_variable_3>=0,0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted },_modnum>0
#@cli : Generates a texture full of alternating quadrilateral shapes using binary logic. Converted, and extended from Asmageddon Quaddro Bumperoo/Inverto Paint.NET source code.
#@cli : (eq. to 'rep_binaltquad').\n
#@cli : Author: Reptorian.
rep_binary_alterating_quad_texture:
skip ${4=128},${5=2},${6=0},${7=0},${8=0},${9=256},${10=255},${11=1}
channels 0
style=$1
var_1=$2
var_2=$3
var_3=$4
operand={$1!=2?$5:2}
angle=$6
x_dir=$7
y_dir=$8
modnum=$9
normalize=$10
allow_normal=$11
f begin(ang=pi*($angle/180);sd=w/h;);ix=((x/w)-.5)/(h>w?1/sd:1);iy=((y/h)-.5)/(w>h?sd:1);IX=ix*cos(ang)-iy*sin(ang);IY=ix*sin(ang)+iy*cos(ang);ix=IX;iy=IY;ix+=.5/(h>w?1/sd:1);iy+=.5/(w>h?sd:1);ix=(w>h?ix*w:ix*h);iy=(w>h?iy*w:iy*h);ix=round(ix)+1;iy=round(iy)+1;$style==2?((!$x_dir?xor(ix,$var_1):xor(w-ix,$var_1))+(!$y_dir?xor(iy,$var_2):xor(h-iy,$var_2)))%$modnum:(int(((($style==1?($operand?($operand==1?(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))):($operand?($operand==1?(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))))/(int($operand!=2?$var_3:-$var_3)*2))-int(($style==1?($operand?($operand==1?(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))):($operand?($operand==1?(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))))/(int($operand!=2?$var_3:-$var_3)*2)))*($style==1?($operand?($operand==1?(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))):($operand?($operand==1?(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2))))))<int($operand!=2?$var_3:-$var_3)?($style==1?($operand?($operand==1?(abs($modnum)-1)-(((($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))%$modnum):($operand?($operand==1?(abs($modnum)-1)-(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))%$modnum)):($style==1?($operand?($operand==1?(abs($modnum)-1)-(((-($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))%$modnum):($operand?($operand==1?(abs($modnum)-1)-(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))%$modnum)))
if $allow_normal n 0,$normalize fi
#@cli rep_binaltquadc: eq. to 'rep_binary_alterating_quad_c'.
rep_binaltquadc: rep_binary_alterating_quad_c $*
#@cli rep_binary_alterating_quad_c: 0<=_colorspace<=13,_contain_alpha= { 0=No Alpha | 1=Alpha Included },_8bitmode= { 0=Not 8-Bit Value | 1=8-Bit Value } \ 0<=_channel_order<=5,0<=_channel_order<=5,0<=_channel_order<=5,0<=_channel_order<=5,0<=_channel_order<=5, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }
#@cli : Generates a texture full of alternating quadrilateral shapes using binary logic. Converted, and extended from Asmageddon Quaddro Bumperoo/Inverto Paint.NET source code.
#@cli : (eq. to 'rep_binaltquadc').
rep_binary_alterating_quad_c:
skip ${7=0},${8=0},${9=0},${10=0},${11=0},${12=0},${13=0},${14=0},${15=0},${16=0},${17=0},${18=0},${19=0},${20=0},${21=0},${22=0},${23=0},${24=0},${25=0},${26=0},${27=0},${28=0},${29=0},${30=0},${31=0},${32=0},${33=0},${34=0},${35=0},${36=0},${37=0},${38=0},${39=0},${40=0},${41=0},${42=0},${43=0},${44=0},${45=0},${46=0},${47=0},${48=0},${49=0}

foreach {
 cs_mode=$1
 cmyk_mode={$cs_mode==3?4:3}
 contain_alpha={$2?1:0}
 bitmode=$3
 tch={$cmyk_mode+$contain_alpha}

 channels 0
 r 100%,100%,100%,$tch

 if $tch==3 ($4,$5,$6)
 elif $tch==4 ($4,$5,$6,$7)
 elif $tch==5 ($4,$5,$6,$7,$8)
 fi

 tc={w#1} s. x remove_duplicates tw={$!-1} if $tw<$tc v + error "Invalid Channel Order!" v - fi
 a[^0] x rv

 ($*)

 if ($cs_mode==3||(($cs_mode>8&&$cs_mode<11)||$cs_mode<3))||$bitmode (256,256,256,256,255)
 else
  if $cs_mode>3&&$cs_mode<7 (361,101,101,256)
  elif $cs_mode==7 (101,201,201,256)
  elif $cs_mode==8 (101,129,{ceil((pi)*200)},256)
  elif $cs_mode==11 (301,301,301,256)
  elif $cs_mode==12 (256,301,301,256)
  elif $cs_mode==13 (301,301,301,256)
  fi
 fi
 fact=9
 repeat $tch {
  sh[1] {i(#0,$>,0)}
  rep_binaltquad. {i(#2,8+$fact*$>,0)},{i(#2,9+$fact*$>,0)},{i(#2,10+$fact*$>,0)},{i(#2,11+$fact*$>,0)},{i(#2,12+$fact*$>,0)},{i(#2,13+$fact*$>,0)},{i(#2,14+$fact*$>,0)},{i(#2,15+$fact*$>,0)},{i(#3,$>,0)},{i(#3,$>,0)-1},{i(#2,16+$fact*$>,0)}
  rm.
 }
 k[1]
 if $cs_mode==3
  if $contain_alpha
   s c
   a[0-{$!-2}] c
   cmyk2rgb..
   *.. {255/254}
   a c
  else
   cmyk2rgb
   * {255/254}
  fi
 else
  if ($cs_mode>8&&$cs_mode<11)||$cs_mode<3
   if $cs_mode==1 ac "ryb2rgb",rgb
   elif $cs_mode==2 ac "cmy2rgb",rgb
   elif $cs_mode==9 ac "ycbcr2rgb",rgb
   elif $cs_mode==10 ac "ycbcrglic2rgb",rgb
   fi
   cut 0,255
  else
   if $bitmode
    if $cs_mode==1 ac "ryb2rgb",rgb
    elif $cs_mode==4 ac "hsi82rgb",rgb
    elif $cs_mode==5 ac "hsv82rgb",rgb
    elif $cs_mode==6 ac "hsl82rgb",rgb
    elif $cs_mode==7 ac "lab82rgb",rgb
    elif $cs_mode==8 ac "lch82rgb",rgb
    elif $cs_mode==11 ac "yiq82rgb",rgb
    elif $cs_mode==12 ac "yuv82rgb",rgb
    elif $cs_mode==13 ac "xyz82rgb",rgb
    fi
    cut 0,255
   else
    if $cs_mode>3&&$cs_mode<7
     f s<4?[i0,i1/100,i2/100,i3]:[i0,i1/100,i2/100]
     if $cs_mode==4 hsi2rgb
     elif $cs_mode==5 hsv2rgb
     elif $cs_mode==6 hsl2rgb
     fi
     cut 0,255
    elif $cs_mode==7
     f s<4?[i0,i1-100,i2-100,i3]:[i0,i1-100,i2-100]
     lab2rgb
    elif $cs_mode==8
     f s<4?[i0,i1,((i2-314.5)*(pi/3.145)/100),i3]:[i0,i1,((i2-314.5)*(pi/3.145)/100)]
     sh 0,2
     lch2rgb.
     rm.
    elif $cs_mode==11
     f s<4?[i0,i1-150,i2-150,i3]:[i0,i1-150,i2-150]
     yiq2rgb
    elif $cs_mode==12
     f s<4?[i0/255,(i1-150)/150,(i2-150)/150,i3]:[i0/255,(i1-150)/150,(i2-150)/150]
     yuv2rgb
    elif $cs_mode==13
     f s<4?[i0/300,i1/300,i2/300,i3]:[i0/300,i1/300,i2/300]
     xyz2rgb
    fi
   fi
  fi
fi
}
#@cli rep_strbul: eq. to 'rep_strange_bulger'.
rep_strbul: rep_strange_bulger $*
#@cli rep_strange_bulger : 0<=_angle<=360,_axis={ 0 = X-Axis | 1 = Y-Axis },_interpolation,_boundary_condition
#@cli : Performs a bulge effect found in Strange Bulger Series made by Asmageddon for Paint.NET.
#@cli : (eq. to 'rep_strbul').\n
#@cli : _angle refers to the angle of distortion.
#@cli : _axis_of_bulge refers to the axis that is the distortion is based from.\n
#@cli : Author: Reptorian.
rep_strange_bulger:
f "begin(
		const BulgeAng=$1*(pi/180);
		const cX=w/2;
		const cY=h/2;
	);
	vx=$2?x:cX-x;
	vy=$2?cY-y:y;
	vx=(vx^2)/cX;
	vy=(vy^2)/cY;
	vx=(x+(x-vx)*cos(BulgeAng)+(y-vy)*sin(BulgeAng));
	vy=(y+(x-vx)*sin(BulgeAng)+(y-vy)*cos(BulgeAng));
	i(vx,vy,z,c,$3,($4?3:2));"
#@cli rep_strbulkal: eq. to 'rep_strange_bulger_kaleidoscope'.
rep_strbulkal:rep_strange_bulger_kaleidoscope $*
#@cli rep_strange_bulger_kaleidoscope: 0<=_bulge_ang<=360,_axis_of_bulge= { 0=horizontal | 1=vertical },_scale>0,-1<_offset_main_x<=1,-1<_offset_main_y<=1,-1<_offset_kaleido_x<=1,-1<_offset_kaleido_y,-360<=surface_ang<=360,_mirror_placement= { 0=inside-out | 1=outside-in },_boundary_condition= { 0=Periodic | 1=Mirror },1<=_interpolation<=5,_dimension_reference>0
#@cli : Distorts image using bulge effect found in Strange Bulger Series made by Asmageddon for Paint.NET. This is the Kaleidoscope version of Strange Bulger.
#@cli : (eq. to 'rep_strbulkal').\n
#@cli : _bulge_ang refers to the angle of distortion.
#@cli : _axis_of_bulge refers to the axis that is the distortion is based from.
#@cli : _scale refers to the scaling of the distortion. The larger the _scale value is, the more areas is revealed.
#@cli : _offset_main_x refers to the horizontal displacement of the initial image
#@cli : _offset_main_y refers to the vertical displacement of the initial image
#@cli : _offset_kaleido_x refers to the horizontal displacement of the center of the distortion
#@cli : _offset_kaleido_y refers to the vertical displacement of the center of the distortion
#@cli : _surface_ang refers to the angle of distortion
#@cli : _mirror_placement refers to whether the displacement is mirror from the center or not.
#@cli : _dimension_reference refers to the base dimension used for calculation of bulging, it uses the biggest dimension as a reference for scaling. The PDN version of Strange Bulger Kaleidoscope does not have a dimension reference which means that bulges are dependent on the image size. This is to ensure that preview stays consistent with the end result. What you see is what you get as _dimension_reference variable is a internal dimension processing variable.\n
#@cli : Author: Reptorian.
rep_strange_bulger_kaleidoscope:
skip ${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=3},${12=1024}
if $3<10^-8 v + error "Scale cannot be 0 or less than 0!" v - fi
if $12==0 v + error "dimension_reference cannot be 0!" v - fi

shift {50*$4}%,{50*$5}%,0,0,3,1

f "begin(
		const BulgeAng=pi*((h>w?360-$1:$1)/180);
		const ang=pi*($8/180);
		const sd=w/h;
		const iox=$6/(h>w?1/sd:1);
		const ioy=($7*-1)/(w>h?sd:1);
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		const ox=iox*cos_ang-ioy*sin_ang;
		const oy=iox*sin_ang+ioy*cos_ang;
		const ed=abs(int($12));
		const id=w>h?ed/w:ed/h;
		const iw=w*id;
		const ih=h*id;
		const cx=iw/2;
		const cy=ih/2;
	);
	ix=((x/w)-.5)/(h>w?1/sd:1);
	iy=((y/h)-.5)/(w>h?sd:1);
	IX=ix*cos_ang-iy*sin_ang;
	IY=ix*sin_ang+iy*cos_ang;
	ix=IX;
	iy=IY;
	ix+=.5/(h>w?1/sd:1);
	iy+=.5/(w>h?sd:1);
	ix*=ed;
	iy*=ed;
	xx=sqrt(abs(ix-cx-ox*(cx>cy?cx:cy)));
	yy=sqrt(abs(iy-cy-oy*(cx>cy?cx:cy)));
	xx*=$3*ed;
	yy*=$3*ed;
	xx/=100;
	yy/=100;
	vx=(w>h?$2:!$2)?xx:cx-xx;
	vy=(w>h?$2:!$2)?cy-yy:yy;
	vx=vx^2/cx;
	vy=vy^2/cy;
	vx=(xx+(xx-vx)*cos(BulgeAng)+(yy-vy)*sin(BulgeAng));
	vy=(yy+(xx-vx)*sin(BulgeAng)+(yy-vy)*cos(BulgeAng));
	vx*=w/ed;
	vy*=h/ed;
	i(vx,vy,z,c,$11,($10?3:2));"

if $9 shift 50%,50%,0,0,3,1 fi
#@cli rep_logpindis: eq. to 'rep_logarithmic_pinching_distortion'.
rep_logpindis: rep_logarithmic_pinching_distortion $*
#@cli rep_logarithmic_pinching_distortion: _distortion_main>=0,-1<=_preshift_x<=1,-1<=_preshift_y<=1,-1<=_effposition_x<=1,-1<=_effposition_y<=1,_prescale_x,_prescale_y,_afterscale_x,_afterscale_y,0<=_angle<=360,_mirror_placement= { 0=outside-in | 1=inside-out },_lx_axis= { 0=different axis | 1=same axis},_ly_axis= { 0=different axis | 1=same axis},ix_dir={ 0=negative | 1=positive },iy_dir={ 0=negative | 1=positive },_boundary= { 0=Periodic | 1=Mirror },1<=_interpolation<=5,_dimension_ref>0
#@cli : (eq. to 'rep_logpindis').\n
#@cli : Author: Reptorian.
rep_logarithmic_pinching_distortion:
skip ${2=0},${3=0},${4=0},${5=0},${6=1},${7=1},${8=1},${9=1},${10=0},${11=0},${12=1},${13=0},${14=1},${15=0},${16=0},${17=5},${18=1024}
if $6==0||$7==0||$8==0||$9==0 v + error "Scale cannot be 0!" v - fi
if $17<1 v + error "interpolation cannot be less than 1" v - fi

shift {50*$2}%,{50*$3}%,0,0,3,1

f "begin(
		const sd=w/h;
		const ang=pi*($10/180);
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		const iox=($4*-1)/(h>w?1/sd:1);
		const ioy=$5/(w>h?sd:1);
		const ox=iox*cos_ang-ioy*sin_ang;
		const oy=iox*sin_ang+ioy*cos_ang;
		const ed=int(abs($18))/2;
		const dx=$14?1:-1;
		const dy=$15?1:-1;
		const iend=$16?3:2;
	);
	ix=((x/w)-.5)/(h>w?1/sd:1);
	iy=((y/h)-.5)/(w>h?sd:1);
	IX=ix*cos_ang-iy*sin_ang;
	IY=ix*sin_ang+iy*cos_ang;
	ix=IX;
	iy=IY;
	ix=abs(ix+ox/2)*$6;
	iy=abs(iy+oy/2)*$7;
	ix*=ed;
	iy*=ed;
	lx=ix==0||iy==0?log(1^-8)*$1:log($12?iy^2:ix*iy)*$1;
	ly=ix==0||iy==0?log(1^-8)*$1:log($13?ix^2:ix*iy)*$1;
	ix-=lx*dx;
	iy-=ly*dy;
	ix*=w/ed;
	iy*=h/ed;
	ix*=$8;
	iy*=$9;
	i(ix,iy,z,c,$17,iend);"

if $11 shift 50%,50%,0,0,3,1 fi
#@cli rep_sqrlogpindis: eq. to rep_square_root_logarithmic_pinching_distortion
rep_sqrlogpindis: rep_square_root_logarithmic_pinching_distortion $*
#@cli rep_square_root_logarithmic_pinching_distortion: _distortion_main>=0,-1<=_preshift_x<=1,-1<=_preshift_y<=1,-1<=_effposition_x<=1,-1<=_effposition_y<=1,_prescale_x,_prescale_y,_afterscale_x,_afterscale_y,0<=_angle<=360,_mirror_placement= { 0=outside-in | 1=inside-out },_lx_axis= { 0=different axis | 1=same axis},_ly_axis= { 0=different axis | 1=same axis},ix_dir={ 0=negative | 1=positive },iy_dir={ 0=negative | 1=positive },_boundary= { 0=Periodic | 1=Mirror },1<=_interpolation<=5,_dimension_ref>0
#@cli : (eq. to 'rep_sqrlogpindis').\n
#@cli : Author: Reptorian.
rep_square_root_logarithmic_pinching_distortion:
skip ${2=0},${3=0},${4=0},${5=0},${6=1},${7=1},${8=1},${9=1},${10=0},${11=0},${12=1},${13=0},${14=1},${15=0},${16=0},${17=5},${18=1024}
if $6==0||$7==0||$8==0||$9==0 v + error "Scale cannot be 0!" v - fi
if $17<1 v + error "interpolation cannot be less than 1" v - fi

shift {50*$2}%,{50*$3}%,0,0,3,1

f "begin(
		const ed=int(abs($18));
		const sd=w/h;
		const ang=pi*($10/180);
		ox=$4;
		oy=$5*-1;
		ox/=h>w?1/sd:1;
		oy/=w>h?sd:1;
		OX=ox*cos(ang)-oy*sin(ang);
		OY=ox*sin(ang)+oy*cos(ang);
		ox=OX;
		oy=OY;
	);
	ix=((x/w)-.5)/(h>w?1/sd:1);
	iy=((y/h)-.5)/(w>h?sd:1);
	IX=ix*cos(ang)-iy*sin(ang);
	IY=ix*sin(ang)+iy*cos(ang);
	ix=IX;
	iy=IY;
	ix+=.5/(h>w?1/sd:1);
	iy+=.5/(w>h?sd:1);
	iw=w/(h>w||w==h?1/sd:1);
	ih=h/(w>h||w==h?1:1/sd);
	id=ed/w;
	iw*=id;
	ih*=id;
	cx=iw/2;
	cy=ih/2;
	ix*=1;
	iy*=1;
	xx=sqrt(abs(ix*ed-cx-cx*ox))*$6;
	yy=sqrt(abs(iy*ed-cy-cx*oy))*$7;
	vx=xx*100;
	vy=yy*100;
	lx=xx==0||yy==0?log(1^-8)*$1:log($12?yy^2:xx*yy)*$1;
	ly=xx==0||yy==0?log(1^-8)*$1:log($13?xx^2:xx*yy)*$1;
	vx+=($14?-1:1)*lx;
	vy+=($15?-1:1)*ly;
	vx*=w/ed;
	vy*=h/ed;
	vx*=$8;
	vy*=$9;
	i(vx,vy,z,c,$17,($16?3:2));"

if $11 shift 50%,50%,0,0,3,1 fi
#@cli rep_stitch: { offset[%]>=0% | offset>=0 },{ thickness[%]>=0% | thickness>=0 },_modulo,_offset_iter_rand={ 0=single | 1= multiple },_strip_iter_rand={ 0=none | 1=single | 2=multiple },_seed_offset,_seed_strip,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror },_sublevel>=0,_interpolation={ 0=nearest | 1=average | 2=linear | 3=bicubic | 4=lanczos },angle_0...angle_inf
#@cli : Stitches images.
#@cli : $ sp rep_stitch 15%,1%,,,,,,,,,45,135
rep_stitch:
skip ${3=0},${4=0},${5=0},${6=},${7=},${8=3},${9=1},${10=2},${11=}

modulo_mode,random_offset_mode,random_strip_mode,seed_off,seed_strip,boundary,sublevel,interpolation,diff_dim_mode,timg,max_img_ind,has_strip_seed,has_off_seed={int($3)},{$4%2},{$5%3},${6-7},{$8%4},{abs($9)+1},{v=abs($10)+1;v==4?++v:v;},0,{$!},{$!-1},0,0

if narg($seed_strip) has_strip_seed=1 fi
if narg($seed_off) has_off_seed=1 fi

if ispercentage($1) use_perc_off=1
else
	use_perc_off,offset=0,{abs($1)*$sublevel}
	if !$offset return fi
fi

if ispercentage($2) use_perc_thk=1
else
	use_perc_thk,thickness=0,{max(1,int(abs($2)*$sublevel))}
fi

modulo,modulo_mode={abs_mod=abs($modulo_mode);[abs_mod,abs_mod==2||$modulo_mode>=-1]}

if $modulo if $modulo<2 error "$3">1==F fi fi

if narg($11) ang_args=${11--1}
else ang_args=45,135
fi

+rep_find_nonduplicate_angles deg180,5,$ang_args => rad_ang
num_angs={w#-1}

if $num_angs==1
	random_offset_mode=0
	if $random_strip_mode==2 random_strip_mode=0 fi
fi

if $!>2 # Test if dimensions are different

	eval "
		diff=0;
		const ti=$timg;
		initial_dimensions=[w#0,h#0,d#0];
		for(p=1,p<ti,++p,
			if([w#p,h#p,d#p]!=initial_dimensions,
				diff=1;
				break();
			);
		);
		diff;"

	diff_dim_mode=${}

fi

img_targets=0-$max_img_ind

repeat $diff_dim_mode?$!-1:1 {

	if $diff_dim_mode img_targets=$> fi

	ow,oh={[w#$>,h#$>]}

	if $diff_dim_mode r[$>] {round($ow*$sublevel)},{round($oh*$sublevel)},100%,100%,1
	else r[0--2] {round(w#0*$sublevel)},{round(h#0*$sublevel)},100%,100%,1
	fi

	nw,nh={[w#$>,h#$>]}

	length={norm($nw,$nh)/2}
	if $use_perc_off offset={$length*$1} fi
	if $use_perc_thk thickness={max($sublevel,round($length*$2))} fi

	if $offset

		+f. "begin(

				const sublevel=$sublevel;

				const thickness=$thickness;
				const half_thickness=thickness>>1;
				const modulo=$modulo;
				const hpi=pi/2;

				const nw=$nw;
				const nh=$nh;

				modulo?(
					const img_width=nw;
					const img_height=nh;
					const hypotenuse=sqrt(img_width^2+img_height^2);
					const pt_0=atan2(img_height,img_width);
					const pt_1=atan2(img_width,img_height);
					calc_nbars(v)=min( modulo, int((v+half_thickness)/thickness) );
				):(
					const cx=(nw-1)/2;
					const cy=(nh-1)/2;
					const hypotenuse=sqrt(cx^2+cy^2);
					const pt_0=atan2(cy,cx);
					const pt_1=atan2(cx,cy);
					calc_nbars(v)=int((v+half_thickness)/thickness);
				);

			);
			angle=i;
			quadrant_01=xor(inrange(angle,-hpi,hpi,1,0),angle>=0);
			angle%=hpi;
			distance=quadrant_01?cos(pt_0-angle)*hypotenuse:cos(angle-pt_1)*hypotenuse;
			calc_nbars(distance);"

			=> number_of_bars

			total_number_of_bars,max_nbar={is#-1},{iM#-1}

			if $random_offset_mode

				if $has_off_seed

					$total_number_of_bars,1,1,{$modulo?1:2},>"begin(
							seed=$seed_off;
							srand(seed);

							num_of_bars_arr=crop(#$number_of_bars);

							const arr_length=w#-1;
							pos_bars=vectorarr_length(0);

							t=0;
							repeat(w#-1,p,
								t+=num_of_bars_arr[p];
								pos_bars[p]=t;
							);

							k=0;
							activate_place_length=1;

							const modulo=$modulo;
							modulo?(
								output()=(
									if(x==pos_bars[k],
										++k;
										srand(++seed);
									);
									u(-1,1)*$offset;
								);
							):(
								output()=(
									if(x==pos_bars[k],
										++k;
										activate_place_length=1;
										srand(++seed);
									);

									a=u(-1,1)*$offset;
									b=u(-1,1)*$offset;

									ov=v(0,2,1,0)?[b,a]:[a,b];

									activate_place_length?(
										activate_place_length=0;
										[ov[0],num_of_bars_arr[k]];
									):(ov);
								);
							);
						);
						output();"
				else
						{is#-1},1,1,{$modulo?1:2},"begin(
								const offset=$offset;
								const modulo=$modulo;
								if(modulo
								,output()=u(-1,1)*offset;
								,output()=[u(-1,1),u(-1,1)]*offset;
								);
							);
							output();"

						eval.. i(#-1,i,0,0,1)=i;
				fi
			else # Create strip for Single_Iteration
				{$modulo?max(2,iM#-1+1):iM#-1},1,1,{$modulo?1:2},>"begin(
						const offset=$offset;
						if($has_off_seed,srand($seed_off););
					);
					a=u(-1,1)*offset;
					b=u(-1,1)*offset;
					ov=v(0,2,1,0)?[b,a]:[a,b];
					x? ov : [ ov[0],w ];"

			fi

			f[$img_targets] "
				begin(
					const has_strip_seed=$has_strip_seed;
					if(has_strip_seed,srand($seed_strip););

					const modulo=$modulo;
					const modulo_mode=$modulo_mode;
					const shift_mod_pos=modulo>>1;

					const boundary=$boundary;

					const max_x=w-1;
					const max_y=h-1;
					const cx=max_x/2;
					const cy=max_y/2;

					const random_offset_mode=$random_offset_mode;
					const random_strip_mode=$random_strip_mode;

					const length=$total_number_of_bars;
					const sub_length=length-1;

					const num_angs=$num_angs;

					const thickness=$thickness;
					const half_thickness=thickness>>1;

					vector_of_number_of_bars=crop(#$number_of_bars);
					const strip_length=w#-1;
					const max_nbar_arr=$max_nbar;

					angs=crop(#$rad_ang);
					cos_ang=cos(angs);
					sin_ang=sin(angs);
					rot_x(a,b,c)=a*cos_ang[c]-b*sin_ang[c];
					rot_y(a,b,c)=a*sin_ang[c]-b*cos_ang[c];

					modulo?(

						offset_strip=crop(#-1);

						random_offset_mode?(
							offset_pos=[0,(vector_of_number_of_bars)[0,num_angs-1]];
							t=offset_pos[1];
							for(p=2,p<num_angs,++p,
								offset_pos[p]=t+=offset_pos[p];
							);
							find_offset(bar_pos)=(
								offset=offset_strip[(bar_pos+offset_pos[ind])%strip_length];
								off_x=cos_ang[ind]*offset;
								off_y=sin_ang[ind]*offset;
								[off_x,off_y];
							);
						):(
							find_offset(bar_pos)=(
								offset=offset_strip[bar_pos%strip_length];
								off_x=cos_ang[ind]*offset;
								off_y=sin_ang[ind]*offset;
								[off_x,off_y];
							);
						);

					):(

						pos_off=crop(#-1,0,0,0,0,w#-1,1,1,1);
						neg_off=crop(#-1,0,0,0,1,w#-1,1,1,1);

						random_offset_mode?(
							offset_pos=[0,(vector_of_number_of_bars)[0,num_angs-1]];
							t=offset_pos[1];
							for(p=2,p<num_angs,++p,
								offset_pos[p]=t+=offset_pos[p];
							);
							find_offset(bar_pos)=(
								offset=bar_pos>=0?pos_off[(bar_pos+offset_pos[ind])%strip_length]:neg_off[(abs(bar_pos)+offset_pos[ind])%strip_length];
								off_x=cos_ang[ind]*offset;
								off_y=sin_ang[ind]*offset;
								[off_x,off_y];
							);
						):(
							find_offset(bar_pos)=(
								offset=bar_pos>=0?pos_off[bar_pos%strip_length]:neg_off[abs(bar_pos)%strip_length];
								off_x=cos_ang[ind]*offset;
								off_y=sin_ang[ind]*offset;
								[off_x,off_y];
							);
						);

					);

					random_strip_mode==2?(

						modulo?(

							const multi_strip_length=$total_number_of_bars;

							has_strip_seed?(
								rand_v=expr('>begin(seed=$seed_strip;srand(seed);tbars=crop(#$number_of_bars);vector_of_number_of_bars=vector(#size(tbars),0);t=0;repeat(size(vector_of_number_of_bars),pos,vector_of_number_of_bars[pos]=t+=tbars[pos]);const num_angs=$num_angs;const ina=num_angs+1;k=0;);if(x==vector_of_number_of_bars[k]&&k<num_angs,++k;++seed;srand(seed););v(0,ina,1,0);',multi_strip_length);
							):(
								rand_v=expr('begin(const ina=$num_angs+1;);v(0,ina,1,0);',multi_strip_length);
							);

							nbars_k_pos=(vector_of_number_of_bars)[0,num_angs-1];

							if(num_angs>2,
								t=nbars_k_pos[0];
								for(k=1,k<num_angs,++k,
									nbars_k_pos[k]=t+=nbars_k_pos[k];
								);
							);

							strip_indices=[0,nbars_k_pos];

							off_out(v)=rand_v[v+strip_indices[k]];

						):(
							const multi_strip_length=2*length+num_angs;
							const pos_neg_v_length=length;

							has_strip_seed?(

								total_neg_zer_pos(v)=(v<<1)+1;

								neg_v=expr('<begin(seed=$seed_strip-1+3*w#$rad_ang;srand(seed);tbars=crop(#$number_of_bars);tbars-=tbars[0];vector_of_number_of_bars=vector(#size(tbars),0);t=0;repeat(size(vector_of_number_of_bars),pos,vector_of_number_of_bars[pos]=t+=tbars[pos]);vector_of_number_of_bars=reverse(vector_of_number_of_bars);k=0;const ina=$num_angs+1;);if(x==vector_of_number_of_bars[k],++k;seed-=3;srand(seed););v(0,ina,1,0);',pos_neg_v_length);
								pos_v=expr('>begin(seed=$seed_strip+1;srand(seed);tbars=crop(#$number_of_bars);vector_of_number_of_bars=vector(#size(tbars),0);t=0;repeat(size(vector_of_number_of_bars),pos,vector_of_number_of_bars[pos]=t+=tbars[pos]);const num_angs=$num_angs;const ina=$num_angs+1;k=0;);if(x==vector_of_number_of_bars[k]&&k<num_angs,++k;seed+=3;srand(seed););v(0,ina,1,0);',pos_neg_v_length);
								middle=expr('>begin(seed=$seed_strip-3;srand(seed);const ina=$num_angs+1;v(0,ina,1,0););v(0,ina,1,0);',num_angs);

								rand_v=vectormulti_strip_length();

								place=extract_pos=0;

								repeat(num_angs,k,
									number_of_bars=vector_of_number_of_bars[k];
									copy(rand_v[place],neg_v[extract_pos],number_of_bars);
									place+=number_of_bars;
									rand_v[place]=middle[k];
									++place;
									copy(rand_v[place],pos_v[extract_pos],number_of_bars);
									place+=number_of_bars;
									extract_pos+=number_of_bars;
								);

							):(

								rand_v=expr('begin(const ina=$num_angs+1;);v(0,ina,1,0);',multi_strip_length);

							);

							non_zero_pos=(vector_of_number_of_bars)[0,num_angs-1]<<1;
							++non_zero_pos;

							if(num_angs>2,
								t=non_zero_pos[0];
								for(k=1,k<num_angs,++k,
									non_zero_pos[k]=t+=non_zero_pos[k];
								);
							);

							strip_indices=[0,non_zero_pos];
							off_out(v)=rand_v[v+vector_of_number_of_bars[k]+strip_indices[k]];

						);

					):
					random_strip_mode==1?(
						modulo?(
							rand_v=expr('begin(if($has_strip_seed,srand($seed_strip););const ina=$num_angs+1);v(0,ina,1,0);',$total_number_of_bars);

							num_angs>1?(

								nbars_k_pos=(vector_of_number_of_bars)[0,num_angs-1];

								t=nbars_k_pos[0];
								for(k=1,k<num_angs,++k,
									nbars_k_pos[k]=t+=nbars_k_pos[k];
								);

								strip_indices=[0,nbars_k_pos];

								off_out(v)=rand_v[v+strip_indices[k]];

							):(
								off_out(v)=rand_v[v];
							);
						):(
							neg_v=expr('<begin(if($has_strip_seed,srand($seed_strip-1););const ina=$num_angs+1;);v(0,ina,1,0);',max_nbar_arr);
							pos_v=expr('>begin(if($has_strip_seed,srand($seed_strip+1););const ina=$num_angs+1;);v(0,ina,1,0);',max_nbar_arr);
							middle=v(0,num_angs+1,1,0);
							rand_v=[neg_v,middle,pos_v];
							off_out(v)=rand_v[v+vector_of_number_of_bars[k]];
						);
					):(
						off_out(v)=v%2;
					);

					modulo?(
						modulo_mode?(
							calc_t()=(floor((rot_y(xx,yy,k)+half_thickness)/thickness)+shift_mod_pos)%modulo;
						):(
							const new_modulo=modulo+(modulo-2);
							const max_modulo_index=modulo-1;
							calc_t()=(
								nv=(floor((rot_y(xx,yy,k)+half_thickness)/thickness)+shift_mod_pos)%new_modulo;
								nv>max_modulo_index?new_modulo-nv:nv;
							);
						);
					):(
						calc_t()=floor((rot_y(xx,yy,k)+half_thickness)/thickness);
					);

				);
				xx=x-cx;
				yy=y-cy;
				current_bar=vector(#num_angs,0);
				ind=0;
				repeat(num_angs,k,
					t=calc_t();
					current_bar[k]=t;
					ind+=off_out(t);
				);
				ind%=num_angs;
				J(find_offset(current_bar[ind]),0,boundary);
				"

		r[$img_targets] $ow,$oh,100%,100%,$interpolation

		rm[-2,-1]

	fi

}

rm.
#@cli rep_find_nonduplicate_angles mode,pw2_buckets,angle_0,...,angle_n
#@cli : Return all unique angles in radians as a image.
#@cli : 'mode'       : deg180, deg360, pi, tau (valid string arguments, input angle units, and near maximum value)
#@cli : 'pw2_buckets': 2^input hash buckets
#@cli : 'angle_0',.. : List of input angles
+rep_find_nonduplicate_angles:
deg180,deg360,pi,tau,ds=0,1,2,3,{1<<$2} # ds=dict_size
mode,T,H=$$1,$!,{$!+2}
(${3--1}) {whd#-1} 0x$ds

eval[$T] >"
	begin(
		const tau=pi*2;
		const mode=$mode;
		const convert_2_rad=mode<2;
		const main_mod=convert_2_rad?360:tau;
		const mod_factor=arg1(mode+1,180,360,pi,tau);
		const offset=convert_2_rad?180:pi;
		const insertion_point=k+1;
		const start_of_hash=k+2;
		const D=$ds;
		const bit_mask=D-1;
		const M=D/mod_factor;
		coa=0; # count of angles
	);
	current_angle=(i+offset)%main_mod;
	current_angle_mod=current_angle>mod_factor?current_angle-mod_factor:current_angle;
	H=((current_angle_mod*M)&bit_mask)+start_of_hash;
	if(find(#H,current_angle_mod,da_size(#H)-1,-1)==-1,
		da_push(#H,current_angle_mod);
		if(convert_2_rad
		,i[#insertion_point,coa++]=deg2rad(current_angle)-pi;
		,i[#insertion_point,coa++]=current_angle-pi;
		);
	);
	end(resize(#insertion_point,coa,1,1,1););"

rm[$T,$H--1]
#@cli rep_polkal: (eq. to rep_polar_kaleidoscope)
rep_polkal:rep_polar_kaleidoscope $*
#@cli rep_polar_kaleidoscope: _angle_cut_repeat>0,_radial_cut_repeat>0,_angle,-1<=_shift_x<=1,-1<=_shift_y<=1,_flip_x= { 0=Original | 1=Flipped },_flip_y= { 0=Original | 1=Flipped },_edge_x= { 0=Repeat | 1=Alternating },0<=_edge_y<=2,_radial_fit_dimension= { 0=Minimum | 1=Maximum },_conical_start_ang= { 0=90 | 1=0 },_sublevel>0,0<_interpolation<=5
#@cli : _angle_cut_repeat refers to the amount of time a image will repeat along the center.
#@cli : _radial_cut_repeat refers to the amount of time a image will repeat from the center.
#@cli : _angle refers to the angle of the filter function.
#@cli : _shift_x refers to the horizontal distance distance from the center in relative to the center of the target image(s)
#@cli : _shift_y refers to the verticla distance of the center in relative to the center of the target image(s).
#@cli : _flip_x mirrors the image horizontally prior to the polar effect.
#@cli : _flip_y mirrors the image vertically prior to the polar effect.
#@cli : _radial_fit_dimension fits the end of radius cut to the min or max dimension.
#@cli : _conical_start_ang starts the polar image from the standard interpretation or straight up.
#@cli : _sublevel refers to the antialiasing degree of the polar effect.
#@cli : Default value: '_angle_cut_repeat=2','_radial_cut_repeat=1','_angle=0','_shift_x=0','_shift_y=0','_flip_x=0','_flip_y=0','_edge_x=1','_edge_y=1','_radial_fit_dimension=0','_conical_start_ang=0','_sublevel=.5','_interpolation=2'\n
#@cli : Author: Reptorian.
rep_polar_kaleidoscope:
skip ${1=2},${2=1},${3=0},${4=0},${5=0},${6=0},${7=0},${8=1},${9=1},${10=0},${11=0},${12=.5},${13=2}

if $1==0 v + error "Invalid Number - Variable 1" v - fi
if $2==0 v + error "Invalid Number - Variable 2" v - fi
if $4<-1||$4>1 v + error "Invalid Number - Variable 3" v - fi
if $5<-1||$5>1 v + error "Invalid Number - Variable 4" v - fi
if $12<0 v + error "Invalid Number - Variable" 12 v - fi
if $13<=0 v + error "Invalid Number - Variable" 13 v - fi

rs {($12+1)*100}%,,$13

f "begin(
		const dr=max(w,h)/min(w,h);
		const ang=pi*(($3*-1)/180);
	);
	xx=((x-$4*w/2)/w-.5)*2;
	yy=((y+$5*h/2)/h-.5)*2;
	xx*=w>h?dr:1;
	yy*=w>h?1:dr;
	XX=xx*cos(ang)-yy*sin(ang);
	YY=xx*sin(ang)+yy*cos(ang);
	xx=XX;
	yy=YY;
	xs=($11?atan2(yy,xx)+pi:atan2(xx,yy)+pi)/(2*pi);
	xs*=$1;
	ys=norm(xx,yy)/($10?dr/1:1);
	ys*=$2;
	xs=$8?(int(xs)%2!=0?1-(xs-floor(xs)):xs-floor(xs)):xs-floor(xs);
	ys=$9?($9-1?(int(ys)%2!=0?1-(ys-floor(ys)):ys-floor(ys)):ys-floor(ys)):ys;
	xs=$6?1-xs:xs;
	ys=$7?1-ys:ys;
	polkal_a=i(abs(xs*w),ys*h,z,c,0,0);
	polkal_b=i(xs*w,ys*h,z,c,1,1);
	$9?polkal_b:polkal_a;"

rs {(1/($12+1))*100}%,,$13
#@cli rep_objvf: eq. to 'rep_objvolumefilt'
rep_objvf: rep_objvolumefilt $*
#@cli rep_objvolumefilt: 0<=_v1<=100%,0<=_v2<=100%,_mode={ -2=preserve_exterior_filter_max_out || -1=preserve_interior_filter_max_out || 0=preserve_interior || 1=preserve_exterior },_colour1...
#@cli : _v1 and _v2 refers to boundary in percent. By default, this command use alpha as reference unless all channel values are specified next to mode.
#@cli : (eq. to 'rep_objvf').\n
#@cli : Default value: '_mode=1'\n
#@cli : Author: Reptorian.
rep_objvolumefilt:
skip ${3=0},${4=}

if $1<0||$2<0||$1>1||$2>1 error ""(""$"1>=0&&"$"1"<=1)"&&"(""$"2>=0&&"$"2"<=1)==F"" fi
if (max($1,$2)-min($1,$2))==1 error "max"(""$"1,"$"2")"-min"(""$"1,"$"2")"<1==F" fi

if ($1!=$2)

	foreach {

		ssize={s}

		if narg(${4--1})&&s>1

			if (narg(${4--1})<($ssize-1)) error "{narg(${4--1})}>={$ssize-1}==F" fi
			if narg(${4--1})<$ssize +channels {s-1} colormap. 0,1,2 alp={i(#-1,0,0)} rm. fi

			100%,100%,100%,1,"begin(
					const ss=$ssize-1;
					ref_color=vectorss(${4--1});
				);
				vectorss(I#0)!=ref_color?1:0"

			if narg(${4--1})<$ssize End={vector$ssize(${4--1},$alp)}
			else End={vector$ssize(${4--1})}
			fi

		else

			+channels {s-1}
			End={vector$ssize(0)}

		fi

		if !iv#-1 error "Variance>0==F" fi

		f. i?1 area_fg. 0,1

		if $3<0 f. i==iM?0:i fi

		+f. i==0?iM:i

		newmin={im#-1}

		rm.

		MM={iM#-1-$newmin}

		area_1={$1*$MM}
		area_2={$2*$MM}
		area_1+=$newmin
		area_2+=$newmin

		minarea={min($area_1,$area_2)}
		maxarea={max($area_1,$area_2)}

		if $3>=0
			if $3 f.. !(i0#-1>=$minarea&&i0#-1<=$maxarea)?I:[$End]
			else f.. i0#-1>=$minarea&&i0#-1<=$maxarea?I:[$End]
			fi
		else
			if $3<-1 f.. if(i0#-1,(!(i0#-1>=$minarea&&i0#-1<=$maxarea)?I:[$End]),I)
			else f.. if(i0#-1,(i0#-1>=$minarea&&i0#-1<=$maxarea?I:[$End]),I)
			fi
		fi

		rm.

		vv=0

		repeat s {
			sh $>
			vv+={iv#-1}
			rm.
		}

		if !$vv error "Final Variance>0==F" fi

	}

fi
#@cli rep_form_pixel: form_id,form_quad_lx!=0,form_quad_ly!=0,_form_ratio[%]!=0,_angle, 0<=_reflect_dir<=2,_sublevel,_tile_boundary={ 0=periodic | 1=mirror_x | 2=mirror_y | 3=mirror_xy },_image_boundary={ 0=neumann | 1=periodic | 2=mirror},_abs_zconvf>=0,_zconv_boundary={0=periodic | 1= mirror},_interpolation={ 0=nearest | 1=average | 2=grid | 3=linear | 4=bicubic | 5=lanczos},cs_mode={ 0=rgb | 1=ryb | 2=cmyk | 3=hcy | 4=hsi | 5=hsl | 6=hsv | 7=lab | 8=lch },_fit_tile={ 0=squash_to_fit | 1=resize_to_fit },_kdol={ 0=new_dim | 1=new_layer_new_dim | 2=new_layer | 3=new_layer_old_dim },shape_option_1..._shape_option_n
#@cli : _form_id refers to the id or name of shape. circle is a valid form id, and any integer number that is 0-24 inclusive is a form id. You can also use image as an argument, so you can use any arbitrary shapes.
#@cli : _form_quad_lx refers to the size of the tile in pixel form. It cannot be 0 unless you want to use _form_quad_ly variable to define the tile width.
#@cli : _form_quad_ly refers to the size of the tile in pixel form. It cannot be 0 unless you want to use _form_quad_lx variable to define it tile height.
#@cli : _form_ratio refers to the how much the shape fills each tile.
#@cli : _angle refers to the rotation of shapes per tile
#@cli : _reflect_dir refers to the mirroring of each shape. 1,2 means the mirroring is applied.
#@cli : _sublevel refers to the initial size of the shape to be scaled down to fit tiles.
#@cli : _tile_boundary refers to how the tiles are repeated within the canvas
#@cli : _image_boundary refers to how the pixels are treated when out-of-range of original canvas before generating tiles
#@cli : _abs_zconvf defines the contrast level of each tiles using z-convolution within a small color tile reference 3D image.
#@cli : _zconv_boundary defines how out-of-range value within z-convolution kernet are treated.
#@cli : _interpolation refers to the interpolation of the scaling of shapes to fit each tile. See 'gmic h resize' _interpolation.
#@cli : _cs_mode refers to the color processing space that form_pixel filter utilize.
#@cli : _fit_tile is a parameter used for whether to fit tile into specified tile width and height or to use stretch resize =method.
#@cli : _kdol can be used to resize the generated result to original dimension and/or to create new layer on top of existing image.
#@cli : _shape_option are used to define the behavior of shapes when available.
#@cli :
#@cli : -- form_id --
#@cli : string | shape_name_id | shape_options
#@cli :
#@cli : [image] ---- image_as_shape
#@cli : 0  - australia
#@cli : 1  - barbedwire
#@cli : 2  - circle
#@cli : 3  - crosshair
#@cli : 4  - cupid
#@cli : 5  - diamond
#@cli : 6  - dragon ------ dragon_recursion>=0,-360<=dragon_curve_rotation_angle>=360
#@cli : 7  - dragonfly
#@cli : 8  - fern - size>=0,density[%]>=0,ang,0<=opacity<=1,type={ 0=Black Spleenwort | 1=Marsh }
#@cli : 9  - flip
#@cli : 10 - gear  ------- teeth>0,0<height<=100,0<=offset_teeth=100,0<ratio<=100
#@cli : 11 - gumleaf
#@cli : 12 - heart
#@cli : 13 - information
#@cli : 14 - kookaburra
#@cli : 15 - mail
#@cli : 16 - mapleleaf
#@cli : 17 - paint_splat
#@cli : 18 - paw
#@cli : 19 - phone
#@cli : 20 - polygon  ------- vertices>0
#@cli : 21 - rooster
#@cli : 22 - shopping_cart
#@cli : 23 - snowflake  ------- 1<=recursion<=6
#@cli : 24 - star  ------- branches>3,thickness[%]
#@cli :
#@cli : -- end of form_id --
#@cli :
#@cli : Note: _shape_option_1 can be empty. n refers to corresponding shape option.
#@cli :
#@cli : Author: Reptorian.
#@cli : $ sp landscape +rep_form_pixel star,20,,90%,45,0,1,1,2,75%,0,5,2,0,0
#@cli : $ sp dog +rep_form_pixel star,15,,80%,20,0,100%,1,0,250%
rep_form_pixel:
skip ${2=0},${3=0},${4=1},${5=0},${6=0},${7=1},${8=0},${9=1},${10=100%},${11=0},${12=5},${13=0},${14=1},${15=0}

form_ratio,ang,mirror,sub,tile_boundary,image_boundary,z_convolve,z_convolve_boundary,interpolation,cs_mode,fit_tile,var_kodl={[cut(abs($4),0,1),$5,int(abs($6))%3,abs($7)+1,int(abs($8))%4,int(abs($9))%3+1,abs($10),abs($11)%2+1,int(abs($12))+1,int(abs($13))%9,$14&1,int(abs($15))%4]}

if $cs_mode convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$cs_mode,,ryb,,hcy,hsi,hsl,hsv,lab,lch} fi

if $cs_mode>2
	if $cs_mode>=3&&$cs_mode<7 cutf_vals=0,360,0,100,0,1,0,255
	elif $cs_mode==7 cutf_vals=0,100,-176,176,-176,176,0,255
	else cutf_vals=0,100,0,255,{-pi},{pi},0,255
	fi
fi

if $z_convolve
	offpixel,onpixel={z_convolve=$z_convolve;[z_convolve*-1,z_convolve*2+1]}
	($offpixel/$onpixel/$offpixel)
	store. zmap
fi

tile_w,tile_h={round(abs([$2,$3]))}
if $tile_w?$tile_w<4 tile_w=4 fi
if $tile_h?$tile_h<4 tile_h=4 fi
if !($tile_w||$tile_h) error "\$tile_w||\$tile_h==F" fi
tile_w={!$tile_w?$tile_h:$tile_w}
tile_h={!$tile_h?$tile_w:$tile_h}
tile_wh={$tile_w*$tile_h}
tile_dim=[$tile_w,$tile_h]

if ${is_image_arg\ $1}

	pass$1 0

	if s<=4&&s>1
		if s==3
			to_gray.
		else
			s. c,{if(s==4,-3,if(s==2,-1,-s))}
			to_gray..
			*[-2,-1]
		fi
	elif s==5
		s. c,-4 cmyk2rgb.. to_gray.. *[-2,-1]
	fi

else

	sid=$1

	if isnum($1)
		if isint($1)
		sid=${"-arg1 "1+$sid"","australia,barbedwire,circle,crosshair,cupid,diamond,dragon,dragonfly,fern,flip,gear,gumleaf,heart,information,kookaburra,mail,mapleleaf,paint_splat,paw,phone,polygon,rooster,shopping_cart,snowflake,star"}
		fi
	fi

	if $#>15 shape_$sid {max($tile_w,$tile_h)*$sub},${16--1}
	else shape_$sid {max($tile_w,$tile_h)*$sub}
	fi

	resize. {ceil(w/$tile_w)*$tile_w},{ceil(h/$tile_h)*$tile_h},100%,100%,0,0,.5,.5

fi

if $ang-360*floor($ang/360) rotate. $ang,1 fi

if   $mirror==1 mirror. x
elif $mirror==2 mirror. y
fi

n. 0,1 autocrop. 0

if $fit_tile
	rs. {round([$tile_w,$tile_h]*$form_ratio)},$interpolation
else
	r. {round([$tile_w,$tile_h]*$form_ratio)},100%,100%,$interpolation
fi

r. $tile_w,$tile_h,100%,100%,0,0,.5,.5

cut. 0,1 n. 0,1

avgc={ia#-1}

repeat $!-1 {

	l[$<,-1] {

		ntw,nth,rw,rh={tile_dim=$tile_dim;new_tile=ceil([w#0,h#0]/tile_dim);[new_tile,new_tile*tile_dim]}

		if $var_kodl>1
			if $var_kodl==3 +store[0] kodl_image fi
			ow,oh={[w#0,h#0]}
			r[0] $rw,$rh,100%,100%,0,$image_boundary,.5,.5
		elif $var_kodl==1
			r[0] $rw,$rh,100%,100%,0,$image_boundary,.5,.5
			+store[$<] kodl_image
		else
			r[0] $rw,$rh,100%,100%,0,$image_boundary,.5,.5
		fi

		if $cs_mode&&(s#0>=3)
			if $cs_mode!=2
				$convert_colors_fwd[0]
			else
				if s#$<==3 rgb2cmyk[0]
				else
					local[0] {
						split c,-3
						rgb2cmyk..
						append c
					}
				fi
			fi
		fi

		$ntw,$nth,2,{s#0},:"begin(
			const avg_c=$avgc;
			const tw=$tile_w;
			const th=$tile_h;
			const wwhh=$tile_wh;
			const w_avg=wwhh*avg_c;
			const iw_avg=wwhh-w_avg;
			const tile_boundary=$tile_boundary;
			tile_boundary>2?(
				find_pos()=1+x%2+y%2*2;
				ti_0=crop(#-1,0,0,0,0,tw,th,1,1);
				ti_1=crop(#-1,tw,0,0,0,tw,th,1,1,3);
				ti_2=crop(#-1,0,th,0,0,tw,th,1,1,3);
				ti_3=crop(#-1,tw,th,0,0,tw,th,1,1,3);
				i_ti_0=1-ti_0;
				i_ti_1=1-ti_1;
				i_ti_2=1-ti_2;
				i_ti_3=1-ti_3;
				generate_color_a()=(
					if(z
					,sum(crop_area*i_ti_0)/iw_avg;
					,sum(crop_area*ti_0)/w_avg;
					);
				);
				generate_color_b()=(
					if(z
					,sum(crop_area*i_ti_1)/iw_avg;
					,sum(crop_area*ti_1)/w_avg;
					);
				);
				generate_color_c()=(
					if(z
					,sum(crop_area*i_ti_2)/iw_avg;
					,sum(crop_area*ti_2)/w_avg;
					);
				);
				generate_color_d()=(
					if(z
					,sum(crop_area*i_ti_3)/iw_avg;
					,sum(crop_area*ti_3)/w_avg;
					);
				);
				generate_color()=arg1(find_pos(),generate_color_a(),generate_color_b(),generate_color_c(),generate_color_d());
			):
			tile_boundary?(
				ti_0=crop(#-1,0,0,0,0,tw,th,1,1);
				tile_boundary==2?(
					find_pos()=y%2;
					ti_1=crop(#-1,0,th,0,0,tw,th,1,1,3);
				):(
					find_pos()=x%2;
					ti_1=crop(#-1,tw,0,0,0,tw,th,1,1,3);
				);
				i_ti_0=1-ti_0;
				i_ti_1=1-ti_1;
				generate_color()=(
					find_pos()?(
						if(z
						,sum(crop_area*i_ti_1)/iw_avg;
						,sum(crop_area*ti_1)/w_avg;
						);
					):(
						if(z
						,sum(crop_area*i_ti_0)/iw_avg;
						,sum(crop_area*ti_0)/w_avg;
						);
					);
				);
			):(
				ti_0=crop(#-1,0,0,0,0,tw,th,1,1);
				i_ti_0=1-ti_0;
				generate_color()=(
					if(z
					,sum(crop_area*i_ti_0)/iw_avg;
					,sum(crop_area*ti_0)/w_avg;
					);
				);
			);
		);

		crop_area=crop(#0,x*tw,y*th,0,c,tw,th,1,1);
		generate_color();
		"

		if $z_convolve
			$zmap
			convolve.. .,$z_convolve_boundary
			rm.
		fi

		if $cs_mode>=2&&(s#-1>=3)
			if $cs_mode!=2
				sh. 0,2
				if $z_convolve rep_mc. $cutf_vals fi
				$convert_colors_bwd.
				rm.
			else
				if s#-1==4
					cmyk2rgb.
					channels[0] 0,2
				else
					s. c,-4
					cmyk2rgb..
					a[-2,-1] c
					channels[0] 0,3
				fi
				if $z_convolve cut. 0,255 fi
			fi
		else
			if $cs_mode $convert_colors_bwd. fi
			if $z_convolve cut. 0,255 fi
		fi

		$ntw,$nth,1,1,:"begin(
			const tw=$tile_w;
			const th=$tile_h;
			const tile_boundary=$tile_boundary;
			const ss=s#-1;
			const length=$tile_wh*ss;
			nv()=vc_0+vc_1*tile_v;
			tile_boundary==3?(
				find_pos()=1+x%2+y%2*2;
				ti_0=crop(#-2,0,0,0,0,tw,th,1,1);
				ti_1=crop(#-2,tw,0,0,0,tw,th,1,1,3);
				ti_2=crop(#-2,0,th,0,0,tw,th,1,1,3);
				ti_3=crop(#-2,tw,th,0,0,tw,th,1,1,3);
				tile_v0=resize(ti_0,length,0,2);
				tile_v1=resize(ti_1,length,0,2);
				tile_v2=resize(ti_2,length,0,2);
				tile_v3=resize(ti_3,length,0,2);
				generate_tile()=(
					tile_v=arg1(find_pos(),tile_v0,tile_v1,tile_v2,tile_v3);
					nv=nv();
					draw(#0,nv,x*tw,y*th,0,0,tw,th,1,ss);
				);
			):
			tile_boundary?(
				ti_0=crop(#-2,0,0,0,0,tw,th,1,1);
				tile_boundary==2?(
					find_pos()=y%2;
					ti_1=crop(#-2,0,th,0,0,tw,th,1,1,3);
				):(
					find_pos()=x%2;
					ti_1=crop(#-2,tw,0,0,0,tw,th,1,1,3);
				);
				tile_v0=resize(ti_0,length,0,2);
				tile_v1=resize(ti_1,length,0,2);
				generate_tile()=(
					tile_v=find_pos()?tile_v1:tile_v0;
					nv=nv();
					draw(#0,nv,x*tw,y*th,0,0,tw,th,1,ss);
				);
			):(
				ti=crop(#-2,0,0,0,0,tw,th,1,1);
				tile_v=resize(ti,length,0,2);
				generate_tile()=(
					nv=nv();
					draw(#0,nv,x*tw,y*th,0,0,tw,th,1,ss);
				);
			);
		);
		c0=J(#-1,0,0,1);
		c1=I(#-1);
		diff_colors=c1-c0;
		vc_0=resize(c0,length,1,0);
		vc_1=resize(diff_colors,length,1,0);
		generate_tile();"

		if $var_kodl
			local[0] {
				if $var_kodl&1
					$kodl_image
					reverse
				fi
				if $var_kodl>1
					resize $ow,$oh,100%,100%,0,0,.5,.5
				fi
			}
		fi

		remove[-2,-1]

	}

}

remove[-1]
#@cli rep_tfrac: eq. to 'rep_thorn_fractal'
rep_tfrac: rep_thorn_fractal $*
#@cli rep_thorn_fractal: -inf<=style<=57,_escape>0,_iteration>0,_subsampling_level>=1,_dx,_dy,_r_xy>0,_r_x>0,_r_y>0,_r_pi= { 0=r_xy multiplied by 1 | 1=r_xy multiplied by pi },_o_x,_o_y,_function_angle,_vx,_vy,..._vx_n,vy_n : \ : \ -inf<=style<=47,_escape>0,_iteration>0,_subsampling_level>=1,_dx,_dy,_r_xy>0,_r_x>0,_r_y>0,_r_pi= { 0=r_xy multiplied by 1 | 1=r_xy multiplied by pi },_o_x,_o_y,_function_angle,_vx,_vy,..._vx_n,vy_n,ovx,ovy,overload_freq>=1 : \ : \ -inf<=style<=47,_escape>0,_iteration>0,_subsampling_level>=1,_dx,_dy,_r_xy>0,_r_x>0,_r_y>0,_r_pi= { 0=r_xy multiplied by 1 | 1=r_xy multiplied by pi },_o_x,_o_y,_function_angle,_vx,_vy,..._vx_n,vy_n,ovx,ovy,cfa,cfb,overload_freq>=1
#@cli : Thorn Fractal is the fractal attributed to Andrew Wayne Graff, alternatively named the "Secant Sea". The code was adapted from Sample C source code provided by Adam Majewski.
#@cli :
#@cli : Source - http://paulbourke.net/fractals/thorn/#dane
#@cli :
#@cli : Alternating Chaos Formula are alternating formula founded by MadJik and are originally implemented in Fractal Attractor Plugin for Paint.NET. They use overload functions rather than a simple switch.
#@cli :
#@cli : (eq. to 'rep_tfrac').
#@cli : 'style' variable is used to define how the thorn fractal will look like with predefined formula. Use a integer value less than 0 to use custom formula, and use a integer value less than -1 to use custom alternating formula. See lists of available style and their corresponding id below.
#@cli : 'escape' variable is used to define the minimum value to escape from the iterative loop.
#@cli : 'iteration' variable defines how much repetition of loop used to find the end value.
#@cli : 'subsampling_level' defines the subsampling level of image.
#@cli : 'dx' is a number used to add to a variable involving distortion within the x-axis during the loop used for fractal generation.
#@cli : 'dy' is a number used to add to a variable involving distortion within the y-axis during the loop used for fractal generation.
#@cli : 'r_xy' defines how much the general infinite line boundary will repeat within the xy axis.
#@cli : 'r_x' defines how much the general infinite line boundary will repeat within the x axis.
#@cli : 'r_y' defines how much the general infinite line boundary will repeat within the y axis.
#@cli : 'r_pi' is used as a multiple to r_xy or to normalize the xmin and xmax to pi ranges.
#@cli : 'o_x' offset the resulting image within the x-direction.
#@cli : 'o_y' offset the resulting image within the y-direction.
#@cli : 'ang' defines the function angle of the thorn fractal.
#@cli : 'vx' variable is used to define custom formula for vx variable for the thorn fractal formula by default.
#@cli : 'vy' variable is used to define custom formula for vy variable for the thorn fractal formula by default.
#@cli : 'vx_n' variable defines a custom formula used for vx variable depending on altern number.
#@cli : 'vy_n' variable defines a custom formula used for vy variable depending on altern number.
#@cli : 'ovx' variable defines a custom formula to be used when the altern is greater than the range of cardinality of set of set[vx,vy]. 'o' in ovx stands for overload.
#@cli : 'ovx' variable defines a custom formula to be used when the altern is greater than the range of cardinality of set of set[vx,vy]. 'o' in ovx stands for overload.
#@cli : 'cfa' variable defines a variable that is used by overload formulas. Used as a temporary constant for each number that exceed the cardinality of set of set[vx,vy].
#@cli : 'cfb' variable defines a variable that is used by overload formulas. Used as a temporary constant for each number that exceed the cardinality of set of set[vx,vy].
#@cli : 'overload_freq' defines how much the ovx,and ovy formula will be applied when altern is greater than the range of cardinality of set of set[vx,vy].
#@cli : - Note on custom formula usage -\n
#@cli : Available adjustible variable: v,vx,vy,dx,dy,a,b,cfa,cfb\n
#@cli : 'v' is the iteration number within loop.
#@cli : 'vx' is the output of distortion function for x-axis.
#@cli : 'vy' is the output of distortion function for y-axis.
#@cli : 'dx' is the distortion-x number.
#@cli : 'dy' is the distortion-y number.
#@cli : 'a' defines result of number defined by vx equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.
#@cli : 'b' defines result of number defined by vy equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.
#@cli : 'cfa' is the output of overload function for x-axis.
#@cli : 'cfb' is the output of overlload function for x-axis.
#@cli :
#@cli : Multiple expressions are supported, and they are separated by the character semicolon-[;]. Furthermore, the usage of commas-[,] requires you to wrap them around with quotation marks-["]. See example of usage with commas. If it the only expression, then it would be used for calculation of vx or vy. Otherwise, the first expression may be the only one used for calculation of vx or vy.
#@cli :
#@cli : - End of Note on custom formula usage -
#@cli :
#@cli : - Style List -
#@cli :
#@cli : List here below contains all the list of style. The 'asterisk' or * means the line contains a note.
#@cli :
#@cli :   n<-1* = Custom Alternating Formula
#@cli :   -1 = Custom Formula
#@cli :   0  = Normal
#@cli :   1  = Normal Inverted
#@cli :   2  = Arcangent
#@cli :   3  = Tangent
#@cli :   4  = Tanh Stroke
#@cli :   5  = Asymphological Vibrato
#@cli :   6  = Asymphological Basic
#@cli :   7  = Asymphological Basic 2
#@cli :   8  = Asymphochaos
#@cli :   9  = Petallian
#@cli :   10 = Semi-Thorny Petallian
#@cli :   11 = Thorny Petal
#@cli :   12 = Thorny Petal 2
#@cli :   13 = Inflation
#@cli :   14 = Inflation 2
#@cli :   15 = Chaotic Creation
#@cli :   16 = Earthing
#@cli :   17 = Acrylic Earthing
#@cli :   18 = Unearthing Origami
#@cli :   19 = Cubic Unearthing
#@cli :   20 = Webbing Cubic Unearthing
#@cli :   21 = Unearthing Chaotic Hooks
#@cli :   22 = Chaotic Hooks
#@cli :   23 = Sinusoidal Liquid
#@cli :   24 = Cosinusoidal Liquid
#@cli :   25 = Echo Wide
#@cli :   26 = Echo Squircle
#@cli :   27 = Echo Hall
#@cli :   28 = Echo Hall 2
#@cli :   29 = Liquid Parabolic
#@cli :   30 = Chaos-Vibrato
#@cli :   31 = Chaos Deep-Vibrato
#@cli :   32 = Chaos Spacetime
#@cli :   33 = Parabolic
#@cli :   34 = Parabolic Chaos
#@cli :   35 = Cubic-Diamond Chaos
#@cli :   36 = C-Line
#@cli :   37 = Contour Chaos
#@cli :   38 = Spiderweb-Diamond
#@cli :   39 = Acrylica
#@cli :   40 = Refractive Space
#@cli :   41 = Smooth-Artistry
#@cli :   42 = Ferrofluid
#@cli :   43 = Triangular Interweaving
#@cli :   44 = Fabric Chaos
#@cli :   45 = Reverse Tangent Division
#@cli :   46 = Chaotic Tangent
#@cli :   47 = Alternating Chaos 0
#@cli :   48 = Alternating Chaos 1 (Legacy)
#@cli :   49 = Alternating Chaos 2 (Legacy)
#@cli :   50 = Alternating Chaos 3 (Legacy)
#@cli :   51 = Alternating Chaos 4 (Legacy)
#@cli :   52 = Alternating Chaos 5 (Legacy)
#@cli :   53 = Alternating Chaos 1
#@cli :   54 = Alternating Chaos 2
#@cli :   55 = Alternating Chaos 3
#@cli :   56 = Alternating Chaos 4
#@cli :   57 = Alternating Chaos 5
#@cli :
#@cli : * = The absolute of value is the numbers of vx,vy next to '_function_angle'. Per loop, every two different functions are assigned instead.
#@cli :
#@cli : - End Style List -
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_escape=50000','_iteration=255','_subsampling_level=4','_dx=0','_dy=0','_r_xy=1','_r_x=1','_r_y=1','_r_pi=1','_o_x=0','_o_y=0','_function_angle=0','_custom_x=','_custom_y='
#@cli : $ 1024,1024 rep_thorn_fractal -1,10000,255,4,2.544,-5.2424,1,1,1/2,1,0,0,30,atan2(a"^"2\,b"^"2)/cos(b),b/sin(a)
rep_thorn_fractal:
skip ${2=50000},${3=255},${4=4},${5=0},${6=0},${7=1},${8=1},${9=1},${10=1},${11=0},${12=0},${13=0},${14=},${15=}

if $1<0
	if !(narg($14)&&narg($15)) error "When using custom formula, there must be an arguments into custom_x and custom_y variables"
	fi
fi

if $1>57 error "$"1<57==F fi
if $2<=0 error "$"2>0==F fi
if $3<1 error "$"3>0==F fi
if $4<1 error "$"4>0==F fi

if !(($7>0&&$8>0)&&$9>0) error "Repeat variables cannot be 0!" fi

if $1>52
	chaos_a=a/cfb
	chaos_b=b/cfa
else
	chaos_a=a
	chaos_b=b
fi

if $1<0
	bounds:=abs($1)*2
	if narg($*)==18+$bounds activate_overload=2
	elif narg($*)==16+$bounds activate_overload=1
	else activate_overload=0
	fi
else activate_overload=0
fi

if $activate_overload!=2&&$1<0
	repeat narg(${14--1}) {
		$=t
		it=${t{$>+14}}
		n={$>+14}

		strcontains $it,cfa
		if ${} error \$\-1!=2?!incl(\$$n,cfa):T==F fi

		strcontains $it,cfb
		if ${} error \$\-1!=2?!incl(\$$n,cfb):T==F fi

		if same('$it','cfa')||same('$it','cfb') error overload!=2?str_incl(cfa):T==F fi

	}
fi

if $activate_overload==2
	fta=$-3
	ftb=$-2
	if $-1>0 ovf_place_pos=if(use_altlim,if(altern==altlim,cfa=fta();cfb=ftb();););
	elif $-1<0 ovf_place_neg=if(use_altlim,if(altern==altlim,cfa=fta();cfb=ftb();););
	else activate_overload=0
	fi
else
	fta=atan(vx)
	ftb=atan(vy)
	if $1>52 ovf_place_pos=if(use_altlim,if(altern==altlim,cfa=fta();cfb=ftb(););); fi
fi

foreach {

	ww,hh={[w,h]}

	iw,ih={int($4*[$ww,$hh])}

	if !($iw%2) iw+=1 fi
	if !($ih%2) ih+=1 fi

	rm

	$iw,$ih,1,1,"begin(
		altern=0;
		const half_width=w/2;
		const half_height=h/2;
		const sd=max(w,h)/min(w,h);
		w>h?(
			const sx=half_width/sd;
			const sy=half_height;
		):(
			const sx=half_width;
			const sy=half_height/sd;
		);
		const rf=int(abs($3));
		const chaos=$1>46;
		const ang=pi*($13/180);
		const cos_ang=cos(ang);
		const sin_ang=sin(ang);
		const dx=$5;
		const dy=$6;
		const rpi=($10?pi:1);
		const ox=$11*rpi;
		const oy=$12*rpi;
		const srpi=rpi*$7;
		const szx=$8*srpi;
		const szy=$9*srpi;
		const overload=$activate_overload;
		const activate_alt_bool=chaos||$1<-1||($1==-1&&overload);
		const use_altlim=($1<0&&(overload==2))||$1>52;
		chaos?(const altlim=3;)
		:(use_altlim?(
				const max_vec_pos=(overload?($-1<0?0:1):1);
				const altlim=abs($1)-max_vec_pos;
				const overlim=altlim+max_vec_pos;
			):(
				const altlim=abs($1)-1;
				const overlim=altlim+1;
			);
		);
		cfa=cfb=1;
		vx=vy=0;
		fta()="$fta";
		ftb()="$ftb";
		logabs(v)=log(abs(v));
		logabs_zero_inf(v)=log(abs(v)+1);
		concat(arg...)=(

			ref([arg],numbers);

			additional_numbers=size(numbers)-1;

			first_number=numbers[0];
			a=abs(first_number);
			use_negative=first_number<0;

			repeat(additional_numbers,pos,

				num_pos=pos+1;
				b=abs(numbers[num_pos]);
				num_digits=(b>0?int(log10(b)))+1;

				if(num_pos!=additional_numbers
				,a=int(a*10^num_digits+b);
				,a=int(a*10^num_digits)+b;
				);

			);

			use_negative?-a:a;
		);

		overload?(
			const count_overload=abs($-1);
		):(
			const count_overload=0;
		);

		chaos?(
			const ff=use_altlim? $1-49 : $1-44 ;
		):(
			const ff=abs($1)-1+count_overload;
		);

		($1<-1||($1==-1&&overload))?(
			overload?(
				use_altlim?(
					vxf(a,b)=arg1(min(altern,overlim)+1,${14--4:2});
					vyf(a,b)=arg1(min(altern,overlim)+1,${15--4:2});
				):(
					vxf(a,b)=arg1(min(altern,overlim)+1,${14--2:2});
					vyf(a,b)=arg1(min(altern,overlim)+1,${15--2:2});
				);
			):(
				vxf(a,b)=arg1(altern+1,${14--1:2});
				vyf(a,b)=arg1(altern+1,${15--1:2});
			);
		):
		$1==-1?(
			vxf(a,b)=$14;
			vyf(a,b)=$15;
		):
		$1==0?(
			vxf(a,b)=a/cos(b);
			vyf(a,b)=b/sin(a);
		):
		$1==1?(
			vxf(a,b)=a/sin(b);
			vyf(a,b)=b/cos(a);
		):
		$1==2?(
			vxf(a,b)=a/atan(b);
			vyf(a,b)=b/atan(a);
		):
		$1==3?(
			vxf(a,b)=a/tan(b);
			vyf(a,b)=b/tan(a);
		):
		$1==4?(
			vxf(a,b)=a/cos(b)*sin(b);
			vyf(a,b)=b/sin(a)*cos(a);
		):
		$1==5?(
			vxf(a,b)=a*tan(a*b)/sin(b);
			vyf(a,b)=b*tan(a*b)/cos(a);
		):
		$1==6?(
			vxf(a,b)=(a+tan(a*b))/sin(b);
			vyf(a,b)=(b+tan(a*b))/cos(a);
		):
		$1==7?(
			vxf(a,b)=(a-tan(a*b))/sin(b);
			vyf(a,b)=(b-tan(a*b))/cos(a);
		):
		$1==8?(
			vxf(a,b)=a/cos(b)+a/sin(b);
			vyf(a,b)=b/cos(a)+b/sin(a);
		):
		$1==9?(
			vxf(a,b)=a/(cos(b)*sin(b));
			vyf(a,b)=b/(sin(a)*cos(a));
		):
		$1==10?(
			vxf(a,b)=a/(cos(tan(b))*sin(tan(b)));
			vyf(a,b)=b/(sin(tan(a))*cos(tan(a)));
		):
		$1==11?(
			vxf(a,b)=(tan(a)+b)/(cos(tan(b))*sin(tan(b)));
			vyf(a,b)=(tan(b)+a)/(sin(tan(a))*cos(tan(a)));
		):
		$1==12?(
			vxf(a,b)=(a+tan(a)+tan(b))/(cos(tan(b))*sin(tan(b)));
			vyf(a,b)=(b+tan(a)+tan(b))/(sin(tan(a))*cos(tan(a)));
		):
		$1==13?(
			vxf(a,b)=(a+tan(a)+tan(b))/cos(a);
			vyf(a,b)=(b+tan(a)+tan(b))/sin(a);
		):
		$1==14?(
			vxf(a,b)=(a+tan(a)+tan(b))/sin(b);
			vyf(a,b)=(b+tan(a)+tan(b))/cos(a);
		):
		$1==15?(
			vxf(a,b)=a/sin(cos(b)*sin(b));
			vyf(a,b)=b/cos(sin(a)*cos(a));
		):
		$1==16?(
			vxf(a,b)=(a+tan(a)/tan(b))/cos(a);
			vyf(a,b)=(b+tan(a)/tan(b))/sin(b);
		):
		$1==17?(
			vxf(a,b)=(b+tan(a)/tan(b))/cos(a);
			vyf(a,b)=(a+tan(a)/tan(b))/sin(b);
		):
		$1==18?(
			vxf(a,b)=(b+tan(b)/tan(a))/cos(a);
			vyf(a,b)=(a+tan(a)/tan(b))/sin(b);
		):
		$1==19?(
			vxf(a,b)=(b+tan(b)/tan(a))/cos(a);
			vyf(a,b)=(a+tan(b)/tan(a))/sin(b);
		):
		$1==20?(
			vxf(a,b)=(b+tan(a)/tan(a))/cos(a);
			vyf(a,b)=(a+tan(b)/tan(a))/sin(b);
		):
		$1==21?(
			vxf(a,b)=b+tan(a)/a/cos(b)+a/sin(b);
			vyf(a,b)=a+tan(b)/b/cos(a)+b/sin(a);
		):
		$1==22?(
			vxf(a,b)=b+tan(a)/(a/cos(b))+a/sin(b);
			vyf(a,b)=a+tan(b)/(b/cos(a))+b/sin(a);
		):
		$1==23?(
			vxf(a,b)=a+3*sin(b)-pi;
			vyf(a,b)=a+b+3*sin(a)-pi;
		):
		$1==24?(
			vxf(a,b)=a+3*cos(b)-pi;
			vyf(a,b)=a+b+3*cos(a)-pi;
		):
		$1==25?(
			vxf(a,b)=a/sin(a/sin(b));
			vyf(a,b)=b/cos(b/cos(a));
		):
		$1==26?(
			vxf(a,b)=a/cos(a/sin(b));
			vyf(a,b)=b/sin(b/cos(a));
		):
		$1==27?(
			vxf(a,b)=a/cos(a/atan(sin(b)));
			vyf(a,b)=b/sin(b/atan(cos(a)));
		):
		$1==28?(
			vxf(a,b)=a/sin(a/atan(cos(b)));
			vyf(a,b)=b/cos(b/atan(sin(a)));
		):
		$1==29?(
			vxf(a,b)=a/atan(cos(b));
			vyf(a,b)=b/atan(sin(a));
		):
		$1==30?(
			vxf(a,b)=(a+tanh(a*b))/cos(b);
			vyf(a,b)=(b+tanh(a*b))/sin(a);
		):
		$1==31?(
			vxf(a,b)=b+tan(b)/(a/(cos(b)))+a/(sin(a));
			vyf(a,b)=a+tan(a)/(b/(cos(a)))+b/(sin(b));
		):
		$1==32?(
			vxf(a,b)=(a+tanh(a+b))/cos(b);
			vyf(a,b)=(b+tanh(a+b))/sin(a);
		):
		$1==33?(
			vxf(a,b)=a/sin(b)/tan(b);
			vyf(a,b)=b/cos(a)/tan(a);
		):
		$1==34?(
			vxf(a,b)=a/(tan(b)*cos(b)*sin(b));
			vyf(a,b)=b/(tan(a)*cos(a)*sin(a));
		):
		$1==35?(
			vxf(a,b)=a/tan(cos(b));
			vyf(a,b)=b/tan(sin(a));
		):
		$1==36?(
			vxf(a,b)=(a+tanh(a*b))/(cos(b)*sin(a));
			vyf(a,b)=(b+tanh(a*b))/(sin(b)*cos(a));
		):
		$1==37?(
			vxf(a,b)=(a+tan(cos(a)*sin(b)))/cos(a);
			vyf(a,b)=(b+tan(sin(a)*cos(b)))/sin(b);
		):
		$1==38?(
			vxf(a,b)=(tan(a+b)*b)/cos(b);
			vyf(a,b)=(tan(a-b)*a)/sin(a);
		):
		$1==39?(
			vxf(a,b)=a/cos(b)*sin(a);
			vyf(a,b)=b/sin(a)*cos(b);
		):
		$1==40?(
			vxf(a,b)=a/tan(cos(b)+sin(b));
			vyf(a,b)=b/tan(cos(a)+sin(a));
		):
		$1==41?(
			vxf(a,b)=a+(tanh(a+b)/cos(b));
			vyf(a,b)=b+(tanh(a+b)/sin(a));
		):
		$1==42?(
			vxf(a,b)=(a/(cos(b)))/(b/(sin(a)));
			vyf(a,b)=(b/(cos(a)))/(a/(sin(b)));
		):
		$1==43?(
			vxf(a,b)=(a*tan(a+b))/sin(b);
			vyf(a,b)=(b*tan(a+b))/cos(a);
		):
		$1==44?(
			vxf(a,b)=a/(atan2(b^2,a^2)*tan(b));
			vyf(a,b)=b/(atan2(b^2,a^2)*tan(a));
		):
		$1==45?(
			vxf(a,b)=tan(a)/b;
			vyf(a,b)=tan(b)/a;
		):
		$1==46?(
			vxf(a,b)=a/atan(b/cos(a/sin(a)));
			vyf(a,b)=b/atan(a/sin(b/cos(b)));
		):
		$1>46?(
			vxf(a,b)=altern>3?"$chaos_a":arg1(altern+1,a/cos(b),a/sin(b),a/tan(b),a/atan(b));
			vyf(a,b)=altern>3?"$chaos_b":arg1(altern+1,b/sin(a),b/cos(a),b/tan(a),b/atan(a));
		);
	);
	xx=(x-half_width)/sx;
	yy=(y-half_height)/sy;
	zx=szx*((xx*cos_ang-yy*sin_ang))+ox;
	zy=szy*((xx*sin_ang+yy*cos_ang))+oy;
	zx&&zy?(
		vx=zx;
		vy=zy;
		repeat(rf,v,
			a=vx;
			b=vy;
			"$ovf_place_neg"
			vx=vxf(a,b);
			vy=vyf(a,b);
			"$ovf_place_pos"
			vx+=dx;
			vy+=dy;
			if(activate_alt_bool,
				++altern;
				if(altern>ff,altern=0);
			);
			if((vx*vx+vy*vy)>$2,break());
		);
		v;
	):(0);"

	r $ww,$hh,1,1,6

}
#@gui _<b>Testing</b>
#@gui <i>Reptorian</i>
# #@gui Modulos Operation:fx_rep_modo,fx_rep_modo_preview
# #@gui:_=note("<b>Initial</b>")
# #@gui:Colour Space=choice(0,"RGB","sRGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
# #@gui:Edit Multiple Channels at once?=bool(0)
# #@gui:Reverse Layers?=bool(0)
# #@gui:_=separator(),_=note("<b>Operation</b>")
# #@gui:Channel Set=choice(0,"Color Channels","Alpha")
# #@gui:Channel=choice(0,"First","Second","Third")
# #@gui:Channel=choice(0,"First","Second","Third","Fourth")
# #@gui:Channel=choice(0,"First","Second","Third","Fourth","Fifth")
# #@gui:Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
# #@gui:Factor (%)=float(100,0,100)
# #@gui:Use Layer as Factor instead?=bool(0)
# #@gui:Negate?=bool(0)
# #@gui:Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
# #@gui:Factor (%)=float(100,0,100)
# #@gui:Use Layer as Factor instead?=bool(0)
# #@gui:Negate?=bool(0)
# #@gui:Disable Effect for Channel #1=bool(0)
# #@gui:Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
# #@gui:Factor (%)=float(100,0,100)
# #@gui:Use Layer as Factor instead?=bool(0)
# #@gui:Negate?=bool(0)
# #@gui:Disable Effect for Channel #2=bool(0)
# #@gui:Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
# #@gui:Factor (%)=float(100,0,100)
# #@gui:Use Layer as Factor instead?=bool(0)
# #@gui:Negate?=bool(0)
# #@gui:Disable Effect for Channel #3=bool(0)
# #@gui:Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
# #@gui:Factor (%)=float(100,0,100)
# #@gui:Use Layer as Factor instead?=bool(0)
# #@gui:Negate?=bool(0)
# #@gui:Disable Effect for Channel #4=bool(0)
# #@gui:Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
# #@gui:Factor (%)=float(100,0,100)
# #@gui:Use Layer as Factor instead?=bool(0)
# #@gui:Negate Alpha?=bool(0)
# #@gui:Disable Effect for Alpha=bool(1)
# #@gui:Disable Effect for Colour Channel #1=bool(0)
# #@gui:Disable Effect for Colour Channel #2=bool(0)
# #@gui:Disable Effect for Colour Channel #3=bool(0)
# #@gui:Disable Effect for Colour Channel #4=bool(0)
# #@gui:Disable Effect for Alpha Channel?=bool(1)
# #@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
# #@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/10/20</i>.</small>")
fx_rep_modo:
if ($1>=0&&$1<4)||$1>=9 color_id=[{vector3(255)}]
elif $1==4 color_id=[{vector4(255)}]
elif $1<9 color_id=[360,1,1]
fi

if $1==4 v_n={$2?(!$37&&$11):(!$16&&$15)},{$2?(!$38&&$11):(!$21&&$20)},{$2?(!$39&&$11):(!$26&&$25)},{$2?(!$40&&$11):(!$31&&$30)},{$2?(!$41&&$11):(!$36&&$35)}
else v_n={$2?(!$37&&$11):(!$16&&$15)},{$2?(!$38&&$11):(!$21&&$20)},{$2?(!$39&&$11):(!$26&&$25)},{$2?(!$41&&$11):(!$36&&$35)}
fi

use_negate=max($v_n)
v_n=[$v_n]

color_channels={$1==4?4:3}

if $1 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$1,,srgb,ryb,cmy,,hcy,hsi,hsl,hsv,lab8,lch8,yiq8,yuv8,ycbcr,ycbcrglic,xyz8,yes8,k18,ohta8} fi

if $1
 foreach {
  if $1!=4
   $convert_colors_fwd.
  else
   if s==3 rgb2cmyk
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
   u cmyk
  fi
 }
fi

if $color_channels==3
 modo_variables={$2?$8:$12},{($color_id)[0]},{$2?($37?-2:($10?-1:$9%)):($16?-2:($14?-1:$13%))},{$2?$8:$17},{($color_id)[1]},{$2?($38?-2:($10?-1:$9%)):($21?-2:($19?-1:$18%))},{$2?$8:$22},{($color_id)[2]},{$2?($39?-2:($10?-1:$9%)):($26?-2:($24?-1:$23%))},$32,255,{($2?$41:$36)?-2:($34?-1:$33%)}
else
 modo_variables={$2?$8:$12},{($color_id)[0]},{$2?($37?-2:($10?-1:$9%)):($16?-2:($14?-1:$13%))},{$2?$8:$17},{($color_id)[1]},{$2?($38?-2:($10?-1:$9%)):($21?-2:($19?-1:$18%))},{$2?$8:$22},{($color_id)[2]},{$2?($39?-2:($10?-1:$9%)):($26?-2:($24?-1:$23%))},{$2?$8:$27},{($color_id)[3]},{$2?($40?-2:($10?-1:$9%)):($31?-2:($29?-1:$28%))},$32,255,{($2?$41:$36)?-2:($34?-1:$33%)}
fi

rep_modo_mc $modo_variables

if $use_negate
 foreach {
  ss={s-1}
  repeat s {
   if $>!=$ss if ($v_n)[$>] sh. $> f. ($color_id)[$>]-i rm. fi
   else if ($v_n)[$>] sh. $> f. 255-i rm. fi
   fi
  }
 }
fi

if $1
 foreach {
  if $1!=4
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 }
fi

if !$3 rv fi
if same('$_host','paintdotnet') k[0] fi

fx_rep_modo_preview:
two_plus_layer={$!>1}
ms=${-max_s}
rv gui_split_preview "fx_rep_modo ${1-41}",${-3--1}
contain_alpha={$ms>3}
activate_individual_channels={!$2?2}
mode_0={$contain_alpha&&$2?2}
mode_1={!$contain_alpha&&!$2?2}
mode_2={$1!=4?(($contain_alpha&&!$2)?2):((!$contain_alpha&&!$2)?2)}
mode_3={!$2?(($1==4&&$contain_alpha)?2)}
use_channel_1_a={$5==0?2}
use_channel_1_b={$6==0?2}
use_channel_1_c={$7==0?2}
use_channel_2_a={$5==1?2}
use_channel_2_b={$6==1?2}
use_channel_2_c={$7==1?2}
use_channel_3_a={$5==2?2}
use_channel_3_b={$6==2?2}
use_channel_3_c={$7==2?2}
activate_a={!$2?(($mode_1?$use_channel_1_a:($mode_2?$use_channel_1_b:$use_channel_1_c))?2)}
activate_b={($mode_1?$use_channel_2_a:($mode_2?$use_channel_2_b:$use_channel_2_c))?2}
activate_c={($mode_1?$use_channel_3_a:($mode_2?$use_channel_3_b:$use_channel_3_c))?2}
activate_d={$1==4?($mode_2?($6==3?2):($mode_3?($7==3?2)))}
activate_e={$2?($mode_0?($4==1?2)):($contain_alpha?($1!=4?($mode_2?($6==3?2):($7==4?2)):($mode_3?$7==4?2)))}
activate_csm={$2&&!$4?2}
activate_bottom_sec={$2?2}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{$mode_0}\
"{$5}_"{$mode_1}\
"{$6}_"{$mode_2}\
"{$7}_"{$mode_3}\
"{$8}_"{$activate_csm}\
"{$9}_"{$activate_csm}\
"{$10}_"{$two_plus_layer?$activate_csm}\
"{$11}_"{$activate_csm}\
"{$12}_"{$activate_a}\
"{$13}_"{$activate_a}\
"{$14}_"{$two_plus_layer?$activate_a}\
"{$15}_"{$activate_a}\
"{$16}_"{$activate_a}\
"{$17}_"{$activate_b}\
"{$18}_"{$activate_b}\
"{$19}_"{$two_plus_layer?$activate_b}\
"{$20}_"{$activate_b}\
"{$21}_"{$activate_b}\
"{$22}_"{$activate_c}\
"{$23}_"{$activate_c}\
"{$24}_"{$two_plus_layer?$activate_c}\
"{$25}_"{$activate_c}\
"{$26}_"{$activate_c}\
"{$27}_"{$activate_d}\
"{$28}_"{$activate_d}\
"{$29}_"{$two_plus_layer?$activate_d}\
"{$30}_"{$activate_d}\
"{$31}_"{$activate_d}\
"{$32}_"{$activate_e}\
"{$33}_"{$activate_e}\
"{$34}_"{$two_plus_layer?$activate_e}\
"{$35}_"{$activate_e}\
"{$36}_"{!$2?$activate_e}\
"{$37}_"{$activate_bottom_sec}\
"{$38}_"{$activate_bottom_sec}\
"{$39}_"{$activate_bottom_sec}\
"{$40}_"{$2?($1==4?2)}\
"{$41}_"{($2&&$contain_alpha)?2}\
"{$42}"\
"{$43,$44}"
#@gui Channel Blur-Sharpen-Overblur-Overline:fx_rep_cbsoo,fx_rep_cbsoo_preview(0)*
#@gui:_=separator(),_=note("<b>Color Space Mode</b>")
#@gui:8-Bit Color Space=choice(0,"RGB","RYB","CMY/K","HSI","HSL","HSV","LAB","LCH","YCbCr-GLIC","YIQ","YUV","YES",Ohta","Kodak-1")
#@gui:Include K Channel=bool(1)
#@gui:Contain Gray=bool(0)_0
#@gui:Contain Color=bool(0)_0
#@gui:Contain Alpha=bool(0)_0
#@gui:List of Images with 3 or 4 channels=text("temp_text")_0
#@gui:Gray Image To Display=int(-1,-1,999999)_0
#@gui:Gray-Alpha Image To Display=int(-1,-1,999999)_0
#@gui:Color Image To Display=int(-1,-1,999999)_0
#@gui:Color-Alpha Image To Display=int(-1,-1,999999)_0
#@gui:Only Alpha To Display=int(-1,-1,999999)_0
#@gui:Use Only Alpha To Display=bool(0)_0
#@gui:_=separator(),_=note("<b>Channel Processing</b>")
#@gui:Section=choice(1,"Gray","Color")
#@gui:Section=choice(0,"Gray","Alpha")
#@gui:Section=choice(0,"Color","Alpha")
#@gui:Section=choice(0,"Gray","Color","Alpha")
#@gui:Section=choice(1,"Gray","CMY")
#@gui:Section=choice(1,"Gray","CMYK")
#@gui:Section=choice(0,"CMY","Alpha")
#@gui:Section=choice(0,"CMYK","Alpha")
#@gui:Section=choice(1,"Gray","CMY","Alpha")
#@gui:Section=choice(1,"Gray","CMYK","Alpha")
#@gui:Use Section=bool(0)_0
#@gui:Section to Use=int(0,0,3)_0
#@gui:Color Channel=choice(0,"Channel 0","Channel 1","Channel 2")
#@gui:Color Channel=choice(0,"Channel 0","Channel 1","Channel 2","Channel 3")
#@gui:Method (Linked)=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor (Linked)=float(100,0,1000)
#@gui:Multiplication (Linked)=float(1,.1,10)
#@gui:Blend Operation (Linked)=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%) (Linked)=float(100,.1,100)
#@gui:Method=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor=float(100,0,1000)
#@gui:Multiplication=float(1,.1,10)
#@gui:Blend Operation=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%)=float(100,.1,100)
#@gui:Enable Gray Channel=bool(1)
#@gui:Method=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor=float(100,0,1000)
#@gui:Multiplication=float(1,.1,10)
#@gui:Blend Operation=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%)=float(100,.1,100)
#@gui:Enable Channel 0=bool(1)
#@gui:Enable Channel Cyan=bool(1)
#@gui:Method=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor=float(100,0,1000)
#@gui:Multiplication=float(1,.1,10)
#@gui:Blend Operation=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%)=float(100,.1,100)
#@gui:Enable Channel 1=bool(1)
#@gui:Enable Channel Magenta=bool(1)
#@gui:Method=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor=float(100,0,1000)
#@gui:Multiplication=float(1,.1,10)
#@gui:Blend Operation=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%)=float(100,.1,100)
#@gui:Enable Channel 2=bool(1)
#@gui:Enable Channel Yellow=bool(1)
#@gui:Method=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor=float(100,0,1000)
#@gui:Multiplication=float(1,.1,10)
#@gui:Blend Operation=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%)=float(100,.1,100)
#@gui:Enable Channel K=bool(1)
#@gui:Method=choice(3,"Blur","Sharpen","Overblur","Overline")
#@gui:Effect Factor=float(100,0,1000)
#@gui:Multiplication=float(1,.1,10)
#@gui:Blend Operation=choice(21,"Add","Alpha","AND","Average","Burn","Darken","Difference","Divide","Dodge","Exclusion","Freeze","Grain Extract","Grain Merge","Hardlight","Hard Mix","Interpolation","Lighten","Linear Burn","Linear Light","Multiply","Normal","Negation","OR","Overlay","Pin Light","Reflect","Screen","Shape Average","Soft Burn","Soft Dodge","Soft Light","Stamp","Subtract","Vivid Light","XOR")
#@gui:Blend Opacity(%)=float(100,.1,100)
#@gui:Enable Channel Alpha=bool(1)
#@gui:Randomize Inputs=button(0)
#@gui:Randomize Inputs (Global)=button(0)
#@gui:Make All Channels with same inputs=button(0)
#@gui:Link Channels=bool(0)
#@gui:Link Checkbox Visibility=int(2,0,2)_0
#@gui:Old Color Space=choice(0,"RGB","RYB","CMY/K","HSI","HSL","HSV","LAB","LCH","YCbCr-GLIC","YIQ","YUV","YES",Ohta","Kodak-1")_0
#@gui:Old Include K?=bool(1)_0
#@gui:Old Link=bool(0)_0
#@gui:Color Space Options=int(2,0,2)_0
#@gui:_=separator(),_=note("<b>Preview Setting</b>")
#@gui:Cropped Viewport Point=point(50,50,1,1,255,255,255,255,1%)
#@gui:Total Bools Available=int(1,1,5)_0
#@gui:Last Visible Option=int(1,-1,6)_0
#@gui:Filter Parameter Changed=bool(0)_0
#@gui:Stored Variables=text("-1")_0
#@gui:Previous Image Display=int(0,0,3)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2024/03/27</i>.</small>")
fx_rep_cbsoo:
skip $*
if same('$_host','cli')
	_pasted_from_gui=1
	fx_rep_cbsoo_preview $*
else
	if narg($_persistent) rm $_persistent keep[filtered]
	else
		_gui_reapply=1
		fx_rep_cbsoo_preview $*
	fi
fi
fx_rep_cbsoo_preview:
skip $*

cs_choice,include_k,num_of_imgs,previous_image_preview=$1,$2,$!,$86
if $cs_choice convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$cs_choice,,ryb,,hsi8,hsl8,hsv8,lab8,lch8,ycbcrglic,yiq8,yuv8,yes8,ohta8,k18} fi
cmyk_mode,contain_persistent,filter_parameters_changed={[$cs_choice==2,narg($_persistent),$84]}
list_of_images_to_display=gray_preview,gray_alpha_preview,color_preview,color_alpha_preview

if $contain_persistent
	rm $_persistent
else to_automode
	name[0--1] auto
fi

if $contain_persistent
	_gui_analysis_gray,_gui_analysis_color,_gui_analysis_alpha,$list_of_images_to_display,only_alpha_to_preview,use_only_alpha_to_preview=${3-5},${7-12}
	list_of_color_images=$6

	use_section,section_variable,\
	use_link,display_link_checkbox,old_link,\
	display_color_space_options,last_visible_option\
	=${23-24},${74-75},$78,$79,$83

	color_space_switched={[$1,$2]!=[$76,$77]}

	display_make_same_vars_button=$display_link_checkbox
	k_display_mode:=$display_color_space_options?$cmyk_mode<<1
	stored_variables=$85

	temp_check_count_bools,check_count_bools=$82
	if $use_section
		if $section_variable==1
			section_space=gray,alpha
		else
			if $cmyk_mode
				ct_text={`('cmyk')[0,3+$2]`}
				if $include_k check_count_bools+=1 fi
			else ct_text=color fi

			if $section_variable==3   section_space=gray,$ct_text,alpha
			elif $section_variable==2 section_space=$ct_text,alpha
			else                      section_space=gray,$ct_text
			fi
		fi
	fi

else

	$list_of_images_to_display=-1
	list_of_color_images,color_space_switched=0

	eval "
		const num_of_imgs=$num_of_imgs;
		contain_gray=contain_color=contain_alpha=0;
		repeat(num_of_imgs,p,
			current_spec_size=s#p;
			if(!contain_gray?current_spec_size<3,contain_gray=1;);
			if(!contain_color?current_spec_size>2,contain_color=1;);
			if(!contain_alpha?current_spec_size==2||current_spec_size>3,contain_alpha=1;);
			if(contain_gray&&contain_color,
				if(contain_alpha,break(););
			);
		);
		[contain_gray,contain_color,contain_alpha];
		"

	_gui_analysis_gray,_gui_analysis_color,_gui_analysis_alpha=${}

	if $_gui_analysis_color
		1
		eval repeat($num_of_imgs,p,if(s#p>2,da_push(#-1,p);););da_freeze(#-1);
		list_of_color_images:=crop(#-1)
		rm.
	fi

	temp_check_count_bools,check_count_bools=1
	use_section:=sum($_gui_analysis_gray,$_gui_analysis_color,$_gui_analysis_alpha)>1

	only_alpha_to_preview,use_only_alpha_to_preview=-1,0
	if $num_of_imgs>1

		m _$0_check_variance_1:"eval da_push(#-4,[iv#$>,$>]);"
		m _$0_check_variance_2:"l[$>,-3] { s.. c eval da_push(#-1,[iv#0*.25+iv#1*.75,$_iter]) a[^-1] c }"
		m _$0_check_variance_3:"l[$>,-2] { s.. c eval da_push(#-1,[avg(iv#0,iv#1,iv#2),$_iter]) a[^-1] c }"
		m _$0_check_variance_4:"l[$>,-1] { s.. c eval da_push(#-1,[avg(iv#0,iv#1,iv#2)*.25+iv#-3*.75,$_iter]) a[^-1] c }"

		1,1,1,2x4 repeat $num_of_imgs { _iter=$> _$0_check_variance_{s#$>} }

		repeat 4 {
			temp_ind:=$>-4
			if da_size(#$temp_ind)
				da_freeze[$temp_ind]
				${arg0\ $>,$list_of_images_to_display}:=(crop(#$temp_ind,0,0,0,1,1,h#$temp_ind,1,1))[argmax(crop(#$temp_ind,0,0,0,0,1,h#$temp_ind,1,1))]
			fi
			um _$0_check_variance_{$>+1}
		}

		rm[-4--1]

		if sum($gray_alpha_preview==-1,$color_alpha_preview==-1)==1
			use_only_alpha_to_preview=1
			if $gray_alpha_preview!=-1
				only_alpha_to_preview=$gray_alpha_preview
			else
				only_alpha_to_preview=$color_alpha_preview
			fi
		fi

	elif $num_of_imgs
		${arg1\ s,$list_of_images_to_display}=0
	else
		error \$\!\>=1==F
	fi

	if $use_section
		section_list=section_gray_color,section_gray_alpha,section_color_alpha,section_gray_color_alpha
		$section_list:=expr('x',narg($section_list))
		temp_section=section

		if $_gui_analysis_gray
			temp_section.=_gray
		fi

		if $_gui_analysis_color
			temp_section.=_color
		fi

		if $_gui_analysis_alpha
			temp_section.=_alpha
		fi

		section_variable=${$temp_section}

		if $section_variable==1
			section_space=gray,alpha
			temp_check_count_bools,check_count_bools=2
		else

			if $cmyk_mode ct_text={`('cmyk')[0,3+$2]`} else ct_text=color fi

			if $section_variable==3   section_space=gray,$ct_text,alpha
			elif $section_variable==2 section_space=$ct_text,alpha
			else                      section_space=gray,$ct_text
			fi

			temp_check_count_bools,check_count_bools={narg($section_space)+2}
			if $cmyk_mode?$include_k check_count_bools+=1 fi

		fi

	fi

	display_make_same_vars_button,display_link_checkbox:=($use_section||$_gui_analysis_color)<<1
	use_link:=$display_link_checkbox?$74
	old_link=$use_link
	display_color_space_options:=$_gui_analysis_color<<1
	k_display_mode:=$display_color_space_options?$cmyk_mode<<1

	last_visible_option=-1
fi

link_visibility,\
link_effect_visibility,\
gray_visibility,\
gray_effect_visibility,\
display_gray_checkbox,\
channel_0_visibility,\
channel_0_effect_visibility,\
display_channel_0_checkbox,\
display_cyan_checkbox,\
channel_1_visibility,\
channel_1_effect_visibility,\
display_channel_1_checkbox,\
display_magenta_checkbox,\
channel_2_visibility,\
channel_2_effect_visibility,\
display_channel_2_checkbox,\
display_yellow_checkbox,\
channel_3_visibility,\
channel_3_effect_visibility,\
display_black_checkbox,\
alpha_visibility,\
alpha_effect_visibility,\
display_alpha_checkbox,\
section_0_visibility,\
section_1_visibility,\
section_2_visibility,\
section_3_visibility,\
section_4_visibility,\
section_5_visibility,\
section_6_visibility,\
section_7_visibility,\
section_8_visibility,\
section_9_visibility,\
color_3_channels_box_visibility,\
color_4_channels_box_visibility,\
display_k_box,\
allow_link_display,apply_filter=0

temp_section_variable=$section_variable

if $use_section

	if $section_variable!=1&&$cmyk_mode
		selected_section:=$temp_section_variable-($section_variable>1)
		temp_section_variable:=4+($selected_section<<1)+$2
	fi

	section_space_selection:=([${13-22}])[$temp_section_variable]+1
	section_space=${arg1\ $section_space_selection,$section_space}

	if !$use_link
		section_${temp_section_variable}_visibility=2
		if same('$section_space','color')||same('$section_space','cmy')
			color_3_channels_box_visibility=2
		elif same('$section_space','cmyk')
			color_4_channels_box_visibility=2
		fi
	else display_make_same_vars_button=0
	fi

elif $_gui_analysis_color
	if $use_link
		display_make_same_vars_button=0
	else
		if $cmyk_mode&&$include_k
			color_4_channels_box_visibility=2
		else
			color_3_channels_box_visibility=2
		fi
	fi
else use_link=0
fi

if $72||!$filter_parameters_changed
	randomize_str=[v(0,3),round(u(0,1000),0.01),round(u(0.1,10),0.001),v(0,34),round(u(.1,100),0.01)]
	link_method,link_effect,link_multiplication,link_blend,link_opacity={_$randomize_str}
	gray_method,gray_effect,gray_multiplication,gray_blend,gray_opacity={_$randomize_str}
	repeat 4 {
		channel_$>_method,channel_$>_effect,channel_$>_multiplication,channel_$>_blend,channel_$>_opacity={_$randomize_str}
	}
	alpha_method,alpha_effect,alpha_multiplication,alpha_blend,alpha_opacity={_$randomize_str}
elif $73||($use_link!=$old_link)
	chosen_options:=([${27-31},${32-36},${38-42},${45-49},${52-56},${59-63},${65-69}])[$last_visible_option*5,5]
	link_method,link_effect,link_multiplication,link_blend,link_opacity=$chosen_options
	gray_method,gray_effect,gray_multiplication,gray_blend,gray_opacity=$chosen_options
	repeat 4 {
		channel_$>_method,channel_$>_effect,channel_$>_multiplication,channel_$>_blend,channel_$>_opacity=$chosen_options
	}
	alpha_method,alpha_effect,alpha_multiplication,alpha_blend,alpha_opacity=$chosen_options
else
	link_method,link_effect,link_multiplication,link_blend,link_opacity,\
	gray_method,gray_effect,gray_multiplication,gray_blend,gray_opacity,\
	channel_0_method,channel_0_effect,channel_0_multiplication,channel_0_blend,channel_0_opacity,\
	channel_1_method,channel_1_effect,channel_1_multiplication,channel_1_blend,channel_1_opacity,\
	channel_2_method,channel_2_effect,channel_2_multiplication,channel_2_blend,channel_2_opacity,\
	channel_3_method,channel_3_effect,channel_3_multiplication,channel_3_blend,channel_3_opacity,\
	alpha_method,alpha_effect,alpha_multiplication,alpha_blend,alpha_opacity\
	=${27-31},${32-36},${38-42},${45-49},${52-56},${59-63},${65-69}
	if $71
		if inrange($last_visible_option,2,5,1,1)
			channel=channel_{$last_visible_option-2}
		else
			choice_pos:=$last_visible_option?(bool($last_visible_option)+bool($last_visible_option-1))
			channel=${arg0\ $choice_pos,link,gray,alpha}
		fi
		${channel}_method,${channel}_effect,${channel}_multiplication,${channel}_blend,${channel}_opacity={_[v(0,3),round(u(0,1000),0.01),round(u(0.1,10),0.001),v(0,34),round(u(.1,100),0.01)]}
	fi
fi

if $use_link

	at_least_one_bool,last_visible_option,checked_box=0
	link_args=$link_method,$link_effect,$link_multiplication,$link_blend,$link_opacity%
	sep=

	if $link_effect
		apply_filter=1
	fi

	if $_gui_analysis_gray
		display_gray_checkbox=2

		if $37
			filter_args=$link_args
			checked_box+=1
		else
			filter_args=-
		fi

		sep=,

		if !$at_least_one_bool?$37 at_least_one_bool=1 fi

	fi

	if $_gui_analysis_color
		color_channels_checkbox_count=0
		t_filter_args,t_sep=

		if $cmyk_mode
			display_cyan_checkbox,display_magenta_checkbox,display_yellow_checkbox=2
			display_black_checkbox:=$include_k<<1

			if $44
				t_filter_args.=$link_args
				color_channels_checkbox_count+=1
			else
				t_filter_args=-
			fi

			t_sep=,
			t_filter_args.=$t_sep

			if $51
				t_filter_args.=$link_args
				color_channels_checkbox_count+=1
			else
				t_filter_args.=-
			fi

			t_filter_args.=$t_sep

			if $58
				t_filter_args.=$link_args
				color_channels_checkbox_count+=1
			else
				t_filter_args.=-
			fi

			if $include_k
				t_filter_args.=$t_sep
				if $64
					t_filter_args.=$link_args
					color_channels_checkbox_count+=1
				else
					t_filter_args.=-
				fi
			fi

			if $color_channels_checkbox_count==(3+$include_k)
				t_filter_args=$link_args
			fi

			if !$at_least_one_bool?($44||$51||$58||$64) at_least_one_bool=1 fi

			if same('$t_filter_args','-,-,-') t_filter_args= fi

			checked_box+=$color_channels_checkbox_count
			filter_args.=$sep$t_filter_args
			sep=,
		else
			display_channel_0_checkbox,display_channel_1_checkbox,display_channel_2_checkbox=2

			if $43
				t_filter_args.=$link_args
				color_channels_checkbox_count+=1
			else
				t_filter_args=-
			fi

			t_sep=,
			t_filter_args.=$t_sep

			if $50
				t_filter_args.=$link_args
				color_channels_checkbox_count+=1
			else
				t_filter_args.=-
			fi

			t_filter_args.=$t_sep

			if $57
				t_filter_args.=$link_args
				color_channels_checkbox_count+=1
			else
				t_filter_args.=-
			fi

			if $color_channels_checkbox_count==3
				t_filter_args=$link_args
			fi

			if !$at_least_one_bool?($43||$50||$57) at_least_one_bool=1 fi

			if same('$t_filter_args','-,-,-') t_filter_args= fi

			checked_box+=$color_channels_checkbox_count
			filter_args.=$sep$t_filter_args
			sep=,
		fi
	fi

	if $_gui_analysis_alpha
		display_alpha_checkbox=2

		if $70
			filter_args.=$sep$link_args
			checked_box+=1
		else
			filter_args.=$sep
			filter_args.=-
		fi

		if !$at_least_one_bool?$70 at_least_one_bool=1 fi

	fi

	link_effect_visibility:=1+$at_least_one_bool
	link_visibility:=bool($at_least_one_bool?$link_effect)+1

	if $checked_box==$check_count_bools filter_args=$link_args fi
else
	all_args_same=1
	previous_args=n/a
	sep=

	if $_gui_analysis_gray
		if $37
			previous_args=$gray_method,$gray_effect,$gray_multiplication,$gray_blend,$gray_opacity%
			if $gray_effect apply_filter=1 fi
		else
			previous_args=-
			all_args_same=0
		fi

		gray_args=$previous_args
		filter_args=$previous_args
		sep=,

		current_args=$previous_args

		if $use_section?same('$section_space','gray'):1
			gray_effect_visibility:=1+$37
			gray_visibility:=bool($37?$gray_effect)+1
			if $display_link_checkbox display_gray_checkbox=2 fi
			last_visible_option=1
			if $previous_image_preview>1
				previous_image_preview=0
			fi
		fi
	fi

	if $_gui_analysis_color
		local_all_args_same=1

		if $cmyk_mode
			if $44
				current_args=$channel_0_method,$channel_0_effect,$channel_0_multiplication,$channel_0_blend,$channel_0_opacity%
				if $channel_0_effect apply_filter=1 fi
			else
				current_args=-
				local_all_args_same=all_args_same=0
			fi

			t_filter_args=$current_args
			previous_args=$current_args

			if $51
				current_args=$channel_1_method,$channel_1_effect,$channel_1_multiplication,$channel_1_blend,$channel_1_opacity%
				if $local_all_args_same local_all_args_same={same('$current_args','$previous_args')} fi
				if $channel_1_effect apply_filter=1 fi
			else
				current_args=-
				local_all_args_same=all_args_same=0
			fi

			t_filter_args.=,$current_args
			previous_args=$current_args

			if $58
				current_args=$channel_2_method,$channel_2_effect,$channel_2_multiplication,$channel_2_blend,$channel_2_opacity%
				if $local_all_args_same local_all_args_same={same('$current_args','$previous_args')} fi
				if $channel_2_effect apply_filter=1 fi
			else
				current_args=-
				local_all_args_same=all_args_same=0
			fi

			t_filter_args.=,$current_args
			previous_args=$current_args

			if $include_k
				if $64
					current_args=$channel_3_method,$channel_3_effect,$channel_3_multiplication,$channel_3_blend,$channel_3_opacity%
					if $local_all_args_same local_all_args_same={same('$current_args','$previous_args')} fi
					if $channel_3_effect apply_filter=1 fi
				else
					current_args=-
					local_all_args_same=all_args_same=0
				fi

				t_filter_args.=,$current_args
				previous_args=$current_args
			fi

			if $local_all_args_same
				if $_gui_analysis_gray
					if '$gray_args'!='$previous_args' all_args_same=0 fi
				fi
			else all_args_same=0
			fi

			if same('$t_filter_args','-,-,-') t_filter_args= fi

			filter_args.=$sep$t_filter_args

			if $use_section?same('$section_space','cmy')||same('$section_space','cmyk'):1
				pos_choice:=$color_4_channels_box_visibility?$26:$25
				state_chosen_bool,state_chosen_effect:=([$44,$channel_0_effect,$51,$channel_1_effect,$58,$channel_2_effect,$64,$channel_3_effect])[$pos_choice<<1,2]
				channel_${pos_choice}_effect_visibility:=1+$state_chosen_bool
				channel_${pos_choice}_visibility:=bool($state_chosen_bool?$state_chosen_effect)+1
				channel_name=${arg0\ $pos_choice,cyan,magenta,yellow,black}
				display_${channel_name}_checkbox=2
				last_visible_option:=2+$pos_choice
				if $previous_image_preview<2
					previous_image_preview=2
				fi
			fi

		else
			if $43
				current_args=$channel_0_method,$channel_0_effect,$channel_0_multiplication,$channel_0_blend,$channel_0_opacity%
				if $channel_0_effect apply_filter=1 fi
			else
				current_args=-
				local_all_args_same=all_args_same=0
			fi

			t_filter_args=$current_args
			previous_args=$current_args

			if $50
				current_args=$channel_1_method,$channel_1_effect,$channel_1_multiplication,$channel_1_blend,$channel_1_opacity%
				if $local_all_args_same local_all_args_same={same('$current_args','$previous_args')} fi
				if $channel_1_effect apply_filter=1 fi
			else
				current_args=-
				local_all_args_same=all_args_same=0
			fi

			t_filter_args.=,$current_args
			previous_args=$current_args

			if $57
				current_args=$channel_2_method,$channel_2_effect,$channel_2_multiplication,$channel_2_blend,$channel_2_opacity%
				if $local_all_args_same
					local_all_args_same={same('$current_args','$previous_args')}
				fi
				if $channel_2_method apply_filter=1 fi
			else
				current_args=-
				local_all_args_same=all_args_same=0
			fi

			t_filter_args.=,$current_args
			previous_args=$current_args

			if $local_all_args_same
				if $_gui_analysis_gray
					if '$gray_args'!='$previous_args' all_args_same=0 fi
				fi
				t_filter_args=$previous_args
			else all_args_same=0
			fi

			if same('$t_filter_args','-,-,-') t_filter_args= fi

			filter_args.=$sep$t_filter_args

			if $use_section?same('$section_space','color'):1
				state_chosen_bool,state_chosen_effect:=([$43,$channel_0_effect,$50,$channel_1_effect,$57,$channel_2_effect])[$25<<1,2]
				channel_$25_effect_visibility:=1+$state_chosen_bool
				channel_$25_visibility:=bool($state_chosen_bool?$state_chosen_effect)+1
				display_channel_$25_checkbox=2
				last_visible_option:=2+$25
				if $previous_image_preview<2
					previous_image_preview=2
				fi
			fi
		fi
	fi

	if $_gui_analysis_alpha
		if $70
			current_args=$alpha_method,$alpha_effect,$alpha_multiplication,$alpha_blend,$alpha_opacity%
			if $alpha_effect apply_filter=1 fi
		else
			current_args=-
			all_args_same=0
		fi

		if '$current_args'!='$previous_args'
			all_args_same=0
		fi

		filter_args.=,$current_args

		if same('$section_space','alpha')
			alpha_effect_visibility:=1+$70
			alpha_visibility:=bool($70?$alpha_effect)+1
			display_alpha_checkbox=2
			last_visible_option=6
			if !($previous_image_preview&1)
				previous_image_preview+=1
			fi
		fi
	fi

	if $all_args_same filter_args=$current_args fi
fi

if $_gui_analysis_color?$cmyk_mode?$include_k filter_args.=,cmyk fi

if same('$_host','cli')

	if $cs_choice?$_gui_analysis_color
		if $cmyk_mode&&$include_k
			foreach[$list_of_color_images] {
					s c,-3
					rgb2cmyk[0]
					append c
			}
		else
			$convert_colors_fwd[$list_of_color_images]
		fi
	fi

	rep_channels_blur_sharpen_overblur_overline $filter_args

	if $cs_choice?$_gui_analysis_color
		if $cmyk_mode&&$include_k
			foreach[$list_of_color_images] {
					s c,-4
					cmyk2rgb[0]
					append c
			}
		else
			$convert_colors_bwd[$list_of_color_images]
		fi
	fi

else

	if !$contain_persistent||$color_space_switched||!same('$filter_args','$stored_variables')
		rmn filtered

		if $cs_choice

			if $cmyk_mode
				+foreach {
					if s<3 continue fi
					s c,-3
					rgb2cmyk[0]
					append c
				}
			else
				+foreach {
					if s<3 continue fi
					$convert_colors_fwd
				}
			fi

			rep_channels_blur_sharpen_overblur_overline[$num_of_imgs--1] $filter_args

			if $cmyk_mode
				foreach[$num_of_imgs--1] {
					if s<4 continue fi
					s c,-4
					cmyk2rgb[0]
					append c
				}
			else
				foreach[$num_of_imgs--1] {
					if s<3 continue fi
					$convert_colors_bwd
				}
			fi

		else
			+rep_channels_blur_sharpen_overblur_overline $filter_args
		fi

		name[$num_of_imgs--1] filtered
		+store _persistent
	fi

	if narg($_gui_reapply)||narg($_pasted_from_gui) keep[filtered] return fi

	if $use_section&&($!>2)
		if $previous_image_preview&1
			if $use_only_alpha_to_preview
				keep[{$num_of_imgs+$only_alpha_to_preview}]
			else
				if $previous_image_preview<2
					keep[{$num_of_imgs+$gray_alpha_preview}]
				else
					keep[{$num_of_imgs+$color_alpha_preview}]
				fi
			fi
		else
			if $previous_image_preview<2
				keep[{$num_of_imgs+$gray_preview}]
			else
				keep[{$num_of_imgs+$color_preview}]
			fi
		fi
	else
		if $!==2 keep[filtered]
		else
			if $_gui_analysis_gray keep[{$num_of_imgs+$gray_preview}]
			else                   keep[{$num_of_imgs+$color_preview}]
			fi
		fi
	fi

	if !isnan($80)
		point_x,point_y:=cut([$80,$81],0,100)
		upper_left_crop_points:=vmax([(w-1-($_preview_area_width-1))*($point_x%),(h-1-($_preview_area_height))*($point_y%)],[0,0])
		bottom_right_crop_points:=vmin([$upper_left_crop_points]+[$_preview_area_width,$_preview_area_height],[w-1,h-1])
		crop $upper_left_crop_points,$bottom_right_crop_points
	else
		point_x,point_y=${80-81}
	fi

	u "{$1}"_$display_color_space_options\
	"{$2}"_$k_display_mode\
	"{"$_gui_analysis_gray"}"\
	"{"$_gui_analysis_color"}"\
	"{"$_gui_analysis_alpha"}"\
	"{"$list_of_color_images"}"\
	"{"$gray_preview"}"\
	"{"$gray_alpha_preview"}"\
	"{"$color_preview"}"\
	"{"$color_alpha_preview"}"\
	"{"$only_alpha_to_preview"}"\
	"{"$use_only_alpha_to_preview"}"\
	"{$13}"_$section_0_visibility\
	"{$14}"_$section_1_visibility\
	"{$15}"_$section_2_visibility\
	"{$16}"_$section_3_visibility\
	"{$17}"_$section_4_visibility\
	"{$18}"_$section_5_visibility\
	"{$19}"_$section_6_visibility\
	"{$20}"_$section_7_visibility\
	"{$21}"_$section_8_visibility\
	"{$22}"_$section_9_visibility\
	"{"$use_section"}"\
	"{"$section_variable"}"\
	"{$25}"_$color_3_channels_box_visibility\
	"{$26}"_$color_4_channels_box_visibility\
	"{"$link_method"}"_$link_visibility\
	"{"$link_effect"}"_$link_effect_visibility\
	"{"$link_multiplication"}"_$link_visibility\
	"{"$link_blend"}"_$link_visibility\
	"{"$link_opacity"}"_$link_visibility\
	"{"$gray_method"}"_$gray_visibility\
	"{"$gray_effect"}"_$gray_effect_visibility\
	"{"$gray_multiplication"}"_$gray_visibility\
	"{"$gray_blend"}"_$gray_visibility\
	"{"$gray_opacity"}"_$gray_visibility\
	"{$37}"_$display_gray_checkbox\
	"{"$channel_0_method"}"_$channel_0_visibility\
	"{"$channel_0_effect"}"_$channel_0_effect_visibility\
	"{"$channel_0_multiplication"}"_$channel_0_visibility\
	"{"$channel_0_blend"}"_$channel_0_visibility\
	"{"$channel_0_opacity"}"_$channel_0_visibility\
	"{$43}"_$display_channel_0_checkbox\
	"{$44}"_$display_cyan_checkbox\
	"{"$channel_1_method"}"_$channel_1_visibility\
	"{"$channel_1_effect"}"_$channel_1_effect_visibility\
	"{"$channel_1_multiplication"}"_$channel_1_visibility\
	"{"$channel_1_blend"}"_$channel_1_visibility\
	"{"$channel_1_opacity"}"_$channel_1_visibility\
	"{$50}"_$display_channel_1_checkbox\
	"{$51}"_$display_magenta_checkbox\
	"{"$channel_2_method"}"_$channel_2_visibility\
	"{"$channel_2_effect"}"_$channel_2_effect_visibility\
	"{"$channel_2_multiplication"}"_$channel_2_visibility\
	"{"$channel_2_blend"}"_$channel_2_visibility\
	"{"$channel_2_opacity"}"_$channel_2_visibility\
	"{$57}"_$display_channel_2_checkbox\
	"{$58}"_$display_yellow_checkbox\
	"{"$channel_3_method"}"_$channel_3_visibility\
	"{"$channel_3_effect"}"_$channel_3_effect_visibility\
	"{"$channel_3_multiplication"}"_$channel_3_visibility\
	"{"$channel_3_blend"}"_$channel_3_visibility\
	"{"$channel_3_opacity"}"_$channel_3_visibility\
	"{$64}"_$display_black_checkbox\
	"{"$alpha_method"}"_$alpha_visibility\
	"{"$alpha_effect"}"_$alpha_effect_visibility\
	"{"$alpha_multiplication"}"_$alpha_visibility\
	"{"$alpha_blend"}"_$alpha_visibility\
	"{"$alpha_opacity"}"_$alpha_visibility\
	"{$70}"_$display_alpha_checkbox\
	"{0}"\
	"{0}"_$display_make_same_vars_button\
	"{0}"_$display_make_same_vars_button\
	"{"$use_link"}"_$display_link_checkbox\
	"{"$display_link_checkbox"}"\
	"{$1}"\
	"{$2}"\
	"{"$use_link"}"\
	"{"$display_color_space_options"}"\
	"{"$point_x,$point_y"}"\
	"{"$temp_check_count_bools"}"\
	"{"$last_visible_option"}"\
	"{1}"\
	"{"$filter_args"}"\
	"{"$previous_image_preview"}"
fi
#@gui Vibrato:fx_vibrato,_fx_vibrato_preview(0)
#@gui:_=note("This is the advanced version of the Vibrato filter. If you do want to manipulate multiple channels at once, use <u>Vibrato - Basic</u> filter. <i>Note: Disable channel mulplication for non-transparent images.</i> \n\n")
#@gui:_=note("This filter is the one of the G'MIC version of <b>MadJik's</b> <i>Paint.NET plugin</i>")
#@gui:_=separator()
#@gui:Colour Space=choice("RGB", "CMY", "HSI", "HSL", "HSV", "LAB", "LCH", "YCbCr", "YCbCr-Glic", "YUV", "YIQ", "XYZ", "Bayer")
#@gui:_=separator()
#@gui:Manipulate Multiple Channels at Once?=bool(1)
#@gui:Process Channel 1?=bool(1)
#@gui:Process Channel 2?=bool(1)
#@gui:Process Channel 3?=bool(1)
#@gui:Process Alpha Channel?=bool(1)
#@gui:Inherit Alpha?=bool(1)
#@gui:X-Orientation=bool(1)
#@gui:Y-Orientation=bool(1)
#@gui:U- Factor=float(.85,.1,15)
#@gui:V- Factor=float(.85,.1,15)
#@gui:X-Scale Factor=float(1,.1,15)
#@gui:Y-Scale Factor=float(1,.1,15)
#@gui:XY-Scale Factor=float(1,.1,3)
#@gui:Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui:Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui:Elevation=float(.7,-100,100)
#@gui:Multiply Blending=bool(0)
#@gui:Invert Vibrato=bool(0)
#@gui:Vibrato Blending Factor=float (100,0,100)
#@gui:Channel Influence Factor=float(1,-8,8)
#@gui:Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui:_=separator()
#@gui:_=note("- <b>Channel #1</b> - ")
#@gui:Process Channel?=bool(1)
#@gui:X-Orientation=bool(1)
#@gui:Y-Orientation=bool(1)
#@gui:U-Factor=float(.85,.1,15)
#@gui:V-Factor=float(.85,.1,15)
#@gui:X-Scale Factor=float(1,.1,15)
#@gui:Y-Scale Factor=float(1,.1,15)
#@gui:XY-Scale Factor=float(1,.1,3)
#@gui:Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui:Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui:Elevation=float(.7,-100,100)
#@gui:Multiply Blending=bool(0)
#@gui:Invert Vibrato=bool(0)
#@gui:Vibrato Blending Factor=float (100,0,100)
#@gui:Channel Influence Factor=float(1,-8,8)
#@gui:Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui:_=separator()
#@gui:_=note("- <b>Channel #2</b> - ")
#@gui:Process Channel?=bool(1)
#@gui:X-Orientation=bool(1)
#@gui:Y-Orientation=bool(1)
#@gui:U-Factor=float(.85,.1,15)
#@gui:V-Factor=float(.85,.1,15)
#@gui:X-Scale Factor=float(1,.1,15)
#@gui:Y-Scale Factor=float(1,.1,15)
#@gui:XY-Scale Factor=float(1,.1,3)
#@gui:Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui:Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui:Elevation=float(.7,-100,100)
#@gui:Multiply Blending=bool(0)
#@gui:Invert Vibrato=bool(0)
#@gui:Vibrato Blending Factor=float (100,0,100)
#@gui:Channel Influence Factor=float(1,-8,8)
#@gui:Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui:_=separator()
#@gui:_=note("- <b>Channel #3</b> - ")
#@gui:Process Channel?=bool(1)
#@gui:X-Orientation=bool(1)
#@gui:Y-Orientation=bool(1)
#@gui:U-Factor=float(.85,.1,15)
#@gui:V-Factor=float(.85,.1,15)
#@gui:X-Scale Factor=float(1,.1,15)
#@gui:Y-Scale Factor=float(1,.1,15)
#@gui:XY-Scale Factor=float(1,.1,3)
#@gui:Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui:Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui:Elevation=float(.7,-100,100)
#@gui:Multiply Blending=bool(0)
#@gui:Invert Vibrato=bool(0)
#@gui:Vibrato Blending Factor=float (100,0,100)
#@gui:Channel Influence Factor=float(1,-8,8)
#@gui:Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui:_=separator()
#@gui:_=note("- <b>Alpha Channel #1</b> - ")
#@gui:Process Channel?=bool(0)
#@gui:X-Orientation=bool(1)
#@gui:Y-Orientation=bool(1)
#@gui:U-Factor=float(.85,.1,15)
#@gui:V-Factor=float(.85,.1,15)
#@gui:X-Scale Factor=float(1,.1,15)
#@gui:Y-Scale Factor=float(1,.1,15)
#@gui:XY-Scale Factor=float(1,.1,3)
#@gui:Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui:Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui:Elevation=float(.7,-100,100)
#@gui:Multiply Blending=bool(1)
#@gui:Invert Vibrato=bool(0)
#@gui:Vibrato Blending Factor=float (100,0,100)
#@gui:Channel Influence Factor=float(1,-8,8)
#@gui:Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui:_=separator(),Preview type=choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2018/12/19</i>.</small>")

fx_vibrato:
split_opacity
local[0]
if $1==1 rgb2cmy
elif $1==2 rgb2hsi8
elif $1==3 rgb2hsl8
elif $1==4 rgb2hsv8
elif $1==5 rgb2lab8
elif $1==6 rgb2lch8
elif $1==7 rgb2ycbcr
elif $1==8 rgb2ycbcrglic
elif $1==9 rgb2yuv8
elif $1==10 rgb2yiq8
elif $1==11 rgb2xyz8
elif $1==12 rgb2bayer 0
fi

s c

if $2==1
if $3==1 -vibrato[0] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
if $4==1 -vibrato[1] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
if $5==1 -vibrato[2] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
elif $2==0
if $23==1 -vibrato[0] $24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38 fi
if $39==1 -vibrato[1] $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54 fi
if $55==1 -vibrato[2] $56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$70 fi
fi
a c

if $1==1 cmy2rgb
elif $1==2 hsi82rgb
elif $1==3 hsl82rgb
elif $1==4 hsv82rgb
elif $1==5 lab82rgb
elif $1==6 lch82rgb
elif $1==7 ycbcr2rgb
elif $1==8 ycbcrglic2rgb
elif $1==9 yuv82rgb
elif $1==10 yiq82rgb
elif $1==11 xyz82rgb
elif $1==12 bayer2rgb 0,0,0
fi
done
if $2==1
if $6==1 -vibrato[1] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$7,$19,$20,$21,$22 fi
elif $2==0
if $71==1 -vibrato[1] $72,$73,$74,$75,$76,$77,$78,$79,$80,$81,$82,$83,$84,$85,$86 fi
fi
a c

vibrato:
foreach {
 n 0,255

 f "
  q=($8/100)*w;
  l=($9/100)*h;
  X=(($1?w-x+q:x+q)/w-.5) * 2 * 1/$5 * 1/$7;
  Y=(($2?h-y+l:y+l)/h-.5) * 2 * 1/$6 * 1/$7;
  U=sqrt($3);
  V=sqrt($4);
  Z=((X-Y) * (X-U) * (X+U) * (Y-V) * (Y+V))+ $10;
  C=(Z+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$14)*(Z+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$14);
  F=abs(C)>1?C-int(C):C;
  A=$12?F:1-F;
  B=$11?(i*A):A*200;
  E=$13/100*B+(1-$13/100)*i;
 "

 n 0,255
 mul $15
 mod 256
}
_fx_vibrato_preview :
gui_split_preview "fx_vibrato ${1--2}",$-1
#@gui Construction Material Texture:_cons_turb,_cons_turb_preview(0)
#@gui:_=note("Construction Material Texture filter is based off the following tutorial by <b>theonlychad</b> for Paint.NET software: <a href="https://forums.getpaint.net/topic/16075-concrete-texture-tutorial/">Concrete Texture Tutorial</a>.\n")
#@gui:_=separator(),_=note("<b>Turbulance Texture</b>")
#@gui:Radius=float(88,1,1024)
#@gui:Octaves=int(8,1,12)
#@gui:Damping per Octave=float(2.5,1,10)
#@gui:Mode=choice(2,"Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gui:Color Balance = color(128,128,128)
#@gui:_=separator(),_=note("<b>Noise Processing</b>")
#@gui:Amplitude=float(20,0,200)
#@gui:Noise Type=choice(3,"Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui:_=separator()
#@gui:Channel(s)=choice(0,"RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui:Value Action=choice(1,"None","Cut","Normalize")
#@gui:_=separator(),_=note("<b>Grayscale Processing</b>")
#@gui:Colour Space=choice("RGB","sRGB")
#@gui:Channel 1=float(1,0,3)
#@gui:Channel 2=float(1,0,3)
#@gui:Channel 3=float(1,0,3)
#@gui:Normalise=bool(1)
#@gui:Desaturation (%)=float(100,0,100)
#@gui:_=separator(),_=note("<b>Self-Image Processing</b>")
#@gui:Self-Blending=choice(20,"add","burn","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","linearburn","linearlight","luminance","multiply","negation","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","vividlight")
#@gui:Self-Blending Opacity (%)=float (100,0,100)
#@gui:Self-Blending V. Original Blending=choice(15,"add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor")
#@gui:Self-Blend V. Original Opacity (%)=float (100,0,100)
#@gui:_=separator(),_=note("<b>Value Processing</b>")
#@gui:Value Action=choice(2,"None","Cut","Normalize")
#@gui:Number #1=float(0,0,255)
#@gui:Number #2=float(188,0,255)
#@gui:Equalize?=bool(0)
#@gui:Negate?=bool(0)
#@gui:_=separator(),_=note("<b>Warp by Intensity</b>")
#@gui:X-Factor=float(0.19,-6,6)
#@gui:Y-Factor=float(0.52,-6,6)
#@gui:_=separator()
#@gui:X-Offset=float(128,0,255)
#@gui:Y-Offset=float(128,0,255)
#@gui:_=separator()
#@gui:Correlated Channels=bool(0)
#@gui:Interpolation=choice(1,"Nearest Neighbor","Linear")
#@gui:Boundary=choice(2,"Transparent","Nearest","Periodic","Mirror")
#@gui:_=separator()
#@gui:Channel(s)=choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui:_=separator(),_=note("<b>Style Processing</b>")
#@gui:Blur Original=float(0,0,16)
#@gui:_=separator(),_=note("<b>Butterworth Bandpass Processing</b>")
#@gui:Activate Butterworth Bandpass Processing=bool(0)
#@gui:Create Copy?=bool(0)
#@gui:LP Frequency Power=float(3,0,16)
#@gui:LP Order Cube Root=float(2,0,4)
#@gui:LP Resonance=float(0,0,5)
#@gui:HP Frequency Power=float(4,0,16)
#@gui:HP Order Cube Root=float(2,0,4)
#@gui:HP Resonance=float(2,0,4)
#@gui:Colour Space=choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","CMY","CMYK","Bayer")
#@gui:Absolute=bool(1)
#@gui:Makeup Gain=bool(1)
#@gui:_=separator(),_=note("<b>Relief Processing</b>")
#@gui:Activate Relief Processing=bool(1)
#@gui:Radius=int(5,5,100)
#@gui:Angle=float(0,-180,180)
#@gui:Sigma=float(.5,.05,4)
#@gui:Value Scale=float(2,.5,10)
#@gui:Output Color=bool(1)
#@gui:Blending Mode=choice(0,"Grain Extract","Grain Merge")
#@gui:Blending Opacity (%)=float(100,0,100)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/12/07</i>.</small>")
_cons_turb :
foreach { cons_turb $* }
cons_turb :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"

fill_color 0,0,0
turbulence ${1-3},0,$4
balance_gamma ${5-7}

remove_opacity

if $10<=4 ac "_fx_noise $8,$9",{$10+2},$11
else ac "_fx_noise $8,$9",{$10+3},$11
fi

remove_opacity

+jr_desaturate ${12-16}

blend normal,$17/100

+cons_self_blend $18,$19

blend ${_mode{$20+1}},$21/100

if $22==1 cut $23,$24
elif $22==2 n $23,$24
fi

if $25 ac "equalize",rgb fi
if $26 negate fi

fx_make_seamless 256

fx_warp_by_intensity ${27-34}

if $36

	if !$37

		blur $35
		fx_butterworth_bp ${38-44},0,${45-46}

		if $45==1
			+rep_emboss_relief ${48-51},0,$52
		fi

	else

		+fx_butterworth_bp ${38-44},0,${45-46}
		blur[0] $35

		if $47==1
			rep_emboss_relief[1] ${48-51},0,$52
		fi

	fi

else

	blur $35

	if $47
		+rep_emboss_relief ${48-51},0,$52
	fi

fi
if $47 if $53 blend grainmerge,{$54/100} else blend grainextract,{$54/100} fi fi
cons_self_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","burn","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","linearburn","linearlight","luminance","multiply","negation","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","vividlight","edges","error"
[0]
blend ${_mode{$1+1}},$2/100
_cons_turb_preview :
gui_split_preview "_cons_turb $*",${-3--1}
#@gui Emboss-Relief:fx_emboss_relief,fx_emboss_relief_preview(0)
#@gui:Radius=int(5,5,100)
#@gui:Angle=float(0,-180,180)
#@gui:Sigma=float(.5,.05,4)
#@gui:Value Scale=float(2,.5,10)
#@gui:Output=choice(0,"Emboss","Relief")
#@gui:Output Color=bool(1)
#@gui:Preserve Alpha?=bool(1)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/12/07</i>.</small>")
fx_emboss_relief:
if !$7 remove_opacity fi
rep_emboss_relief ${1-6}
fx_emboss_relief_preview: gui_split_preview "fx_emboss_relief ${1-7}",${-3--1}
#@gui Premade Palette:fx_rep_premade_palette,fx_rep_premade_palette_preview(0):.
#@gui:_=note("This filter creates palettes. Credits are given below. "), _=separator()
#@gui:Palette=choice(10,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:X-Position=choice(1,"Left","Middle","Right")
#@gui:Y-Position=choice(1,"Top","Middle","Bottom")
#@gui:Palette Width=int(16,1,256)
#@gui:Palette Scaling=int(12,1,32)
#@gui:Alternating Flips=bool(0)
#@gui:Palette Rotation=choice(2,"180","90","0,"-90")
#@gui:Mirror X-Axis Palette=bool(0)
#@gui:Mirror Y-Axis Palette=bool(0)
#@gui:Blend Palette to Image(s)?=bool(1)
#@gui:_=separator(),_=note("<b>Export</b>")
#@gui:Output Location=folder()
#@gui:File Name=text("color_harmonies")
#@gui:Format=choice(0,"GIMP Palette - .gpl","Paint.NET Palette - .txt","JASC-PAL - .pal")
#@gui:Message=_text("Available for Export!")
#@gui:Export=button()
#@gui:Palette=choice(0,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")_0
#@gui:_=separator(),_=note("<b>Palette CLI Information</b>\n\n <i>Main Source of Palettes - </i><a href=\"https://lospec.com/palette-list\"> LoSpec Palette List</a>\n\nPalette Number -- pal number_id = pal name_id -- Full Palette Name by Author[if mentioned]\n\n1 -- +pal 0 = +pal bw -- Black & White\n2 -- +pal 1 = +pal rgb -- Red-Green-Blue\n3 -- +pal 2 = +pal b_rgb -- Black with Red-Green-Blue\n4 -- +pal 3 = +pal bw_rgb -- Black & White with Red-Green-Blue\n5 -- +pal 4 = +pal cmy -- Cyan-Magenta-Yellow\n6 -- +pal 5 = +pal cmyk -- Cyan-Magenta-Yellow-Black\n7 -- +pal 6 = +pal w_cmyk -- White-Cyan-Magenta-Yellow-Black\n8 -- +pal 7 = +pal rgbcmy -- Red-Green-Blue with Cyan-Magenta-Yellow\n9 -- +pal 8 = +pal 1bitrgb -- 1-Bit RGB\n10 -- +pal 9 = +pal aurora -- Aurora by GrafxKid\n11 -- +pal 10 = +pal zenit -- Zenit-241 by Zenit40\n12 -- +pal 11 = +pal gbg -- Game Builder Garage: Texture-Sprite Editor Palette\n13 -- +pal 12 = +pal duel -- Duel by Arilyn\n14 -- +pal 13 = +pal hocuspocus -- Hocus Pocus Palette by Apogee Software,Ltd.\n15 -- +pal 14 = +pal playpal -- PLAYPAL by id Tech 1 | DOOM Engine\n16 -- +pal 15 = +pal srb2 -- Sonic Robo Blast 2\n17 -- +pal 16 = +pal uzebox -- Uzebox from Uzebox console\n18 -- +pal 17 = +pal kens16 -- Andrew Kensler - 16 by Andrew Kensler\n19 -- +pal 18 = +pal kens32 -- Andrew Kensler - 32 by Andrew Kensler\n20 -- +pal 19 = +pal kens54 -- Andrew Kensler - 54 by Andrew Kensler\n21 -- +pal 20 = +pal aap12 -- AAP-Micro 12 by Adigun A. Polack\n22 -- +pal 21 = +pal aap16 -- AAP-16 by Adigun A. Polack\n23 -- +pal 22 = +pal aap64 -- AAP-64 by Adigun A. Polack\n24 -- +pal 23 = +pal aap96 -- AAP-RadiantPLUS by Adigun A. Polack\n25 -- +pal 24 = +pal aap128 -- AAP-SPLENDOR128 by Adigun A. Polack\n26 -- +pal 25 = +pal aap_dga16 -- AAP-DGA16 by Adigun A. Polack\n27 -- +pal 26 = +pal cheerful -- Cheerful-32 by SoundsDotZip\n28 -- +pal 27 = +pal db8 -- DB8 by DawnBringer\n29 -- +pal 28 = +pal db16 -- DB16 by DawnBringer\n30 -- +pal 29 = +pal db32 -- DB32 by DawnBringer\n31 -- +pal 30 = +pal db_iso22 -- DB-ISO22 by DawnBringer\n32 -- +pal 31 = +pal dimwid17 -- DimWiddy 17 by DimWiddy\n33 -- +pal 32 = +pal dimwid23 -- DimWiddy 23 by DimWiddy\n34 -- +pal 33 = +pal edg4 -- Endesga-4 by Endesga\n35 -- +pal 34 = +pal edg8 -- Endesga-8 by Endesga\n36 -- +pal 35 = +pal edg16 -- Endesga-16 by Endesga\n37 -- +pal 36 = +pal edg32 -- Endesga-32 by Endesga\n38 -- +pal 37 = +pal edg36 -- Endesga-36 by Endesga\n39 -- +pal 38 = +pal edg64 -- Endesga-64 by Endesga\n40 -- +pal 39 = +pal famicube -- Famicube by Arne\n41 -- +pal 40 = +pal juicy32 -- Juicy-32 by Real Juice\n42 -- +pal 41 = +pal juicy56 -- Juicy-56 by Real Juice\n43 -- +pal 42 = +pal xaiue -- XAIUE-22 by xaiue\n44 -- +pal 43 = +pal 15pdx -- 15P-DX by GrafxKid\n45 -- +pal 44 = +pal 20pdx -- 20P-DX by GrafxKid\n46 -- +pal 45 = +pal 24pdx -- 24P-DX by GrafxKid\n47 -- +pal 46 = +pal cabana -- Cabana-64 by Crabby\n48 -- +pal 47 = +pal fantasy16 -- Fantasy 16 by Brettybooop\n49 -- +pal 48 = +pal fantasy24 -- Fantasy 24 by Gabriel C.\n50 -- +pal 49 = +pal tranquil_fantasy_23 -- Tranquil Fantasy 23 by windfall.apples\n51 -- +pal 50 = +pal tfp39 -- Tranquility Plus 39 by windfall.apples\n52 -- +pal 51 = +pal faraway -- Faraway 48 by Igor Ferreira.\n53 -- +pal 52 = +pal fleja -- Fleja Master Palette by Fleja\n54 -- +pal 53 = +pal koni -- Koni32 by Konic\n55 -- +pal 54 = +pal linearbasic -- Linear Color Palette Basic by GrafxKid\n56 -- +pal 55 = +pal legowiki -- LEGO colors from LEGO wiki\n57 -- +pal 56 = +pal lego2021 -- Lego Colours 2021 by Six Pies\n58 -- +pal 57 = +pal vinelinear -- Vines Flexible Linear Ramps by Vine 2D\n59 -- +pal 58 = +pal arcade -- Arcade Standard 29 by GrafxKid\n60 -- +pal 59 = +pal arq -- ARQ16 by Endesga\n61 -- +pal 60 = +pal atom -- Atom-8 by polyphrog\n62 -- +pal 61 = +pal blk36 -- BLK 36 by BlackedIRL.\n63 -- +pal 62 = +pal blkneo -- BLK-NEO by BlackedIRL.\n64 -- +pal 63 = +pal broken_facility -- Broken Facility by telepathic-melon\n65 -- +pal 64 = +pal bubblegum -- Bubblegum-16 by PineTreePizza\n66 -- +pal 65 = +pal cpcboy -- CPC BOY by Arne Niklas Jansson\n67 -- +pal 66 = +pal cade -- Cade 15 by MonstersGoBoom\n68 -- +pal 67 = +pal calder -- Calder 8 by Philip Dodderige\n69 -- +pal 68 = +pal cdbac -- CD-BAC by DimWiddy\n70 -- +pal 69 = +pal cgarne -- CG Arne by Arne Niklas Jansson\n71 -- +pal 70 = +pal dinoknight -- DinoKnight 16 by Retrospec\n72 -- +pal 71 = +pal llll -- ||||-22 by ||||\n73 -- +pal 72 = +pal fzt_ethereal -- FZT Ethereal 16 by Fusionnist\n74 -- +pal 73 = +pal indecision -- Indecision by Nelson SMG\n75 -- +pal 74 = +pal island -- Island Joy 16 by Kerrie Lake\n76 -- +pal 75 = +pal journey -- Journey by PineTreePizza\n77 -- +pal 76 = +pal shallowmarsh -- Shallowmarsh26 by archer\n78 -- +pal 77 = +pal lago_nenufar -- Lago Nenufar &#40;Lake Water Lily&#41; by Popxel Art\n79 -- +pal 78 = +pal juicy -- Juicy 17 by JerryPie\n80 -- +pal 79 = +pal chocolate -- ChocolateGanache by Ladybug\n81 -- +pal 80 = +pal brightwinter1 -- Bright Winter 1 by Nai\n82 -- +pal 81 = +pal brightwinter2 -- Bright Winter 2 by Nai\n83 -- +pal 82 = +pal kawaii -- Kawaii16 by Arisuki\n84 -- +pal 83 = +pal xdb -- 0xdb-01 by 0xDB\n85 -- +pal 84 = +pal gzxp -- GZXP by GrafxKid\n86 -- +pal 85 = +pal chromatic -- Chromatic16 by DragonDePlatino\n87 -- +pal 86 = +pal piet_code -- Piet Coding Language\n88 -- +pal 87 = +pal boltbait_matrix -- Matrix by BoltBait\n89 -- +pal 88 = +pal material_design -- Material Design by Ruchir L. Sharma\n90 -- +pal 89 = +pal thehamster_rainbow -- Rainbow by thehamster\n91 -- +pal 90 = +pal boltbait_rainbow -- Rainbow by BoltBait\n92 -- +pal 91 = +pal scrj_xxxvi -- SCRJ-XXXVI by StudioCRJ\n93 -- +pal 92 = +pal pxls_space -- Pxls Default from pxls.space\n94 -- +pal 93 = +pal lospec -- Lospec500 by the Lospec community\n95 -- +pal 94 = +pal moderna -- Moderna by yedamameday\n96 -- +pal 95 = +pal oak -- Oak21 by Dan Oak\n97 -- +pal 96 = +pal nature -- Nature's Embrace 55 by GrafxKid\n98 -- +pal 97 = +pal rbypgo -- RBYPGO by Marilynx\n99 -- +pal 98 = +pal new_worlds -- New Worlds 46 by Count Moriarty\n100 -- +pal 99 = +pal nauris -- Nauris-16 by Nauris\n101 -- +pal 100 = +pal dynamite -- Dynamite by Pixi\n102 -- +pal 101 = +pal interstate -- Interstate 28 by maine\n103 -- +pal 102 = +pal downgraded -- Downgraded 32 by daniel\n104 -- +pal 103 = +pal pear36 -- Pear 36 by PineTreePizza\n105 -- +pal 104 = +pal pineapple -- Pineapple 32 by PineTreePizza\n106 -- +pal 105 = +pal peachy -- Peachy Pop 16 by Kerrie Lake\n107 -- +pal 106 = +pal resurrect -- Resurrect 32 by Kerrie Lake\n108 -- +pal 107 = +pal rosy42 -- Rosy 42 by PineTreePizza\n109 -- +pal 108 = +pal slso_clr17 -- SLSO-CLR17 by Luis Miguel Maldonado\n110 -- +pal 109 = +pal softy -- Softy 15 by Eggy\n111 -- +pal 110 = +pal spec12 -- SPEC12 by Smalls\n112 -- +pal 111 = +pal the_roarin_80s -- The Roarin 80's by Malo\n113 -- +pal 112 = +pal starmancer -- Starmancer by Ominux Games\n114 -- +pal 113 = +pal superfuture -- SuperFuture25 by Endesga\n115 -- +pal 114 = +pal sunshine -- SUNSHINE 35 by mysunnyrose\n116 -- +pal 115 = +pal sweetie16 -- Sweetie 16 by GrafxKid\n117 -- +pal 116 = +pal calm -- Calm 48 by Xina\n118 -- +pal 117 = +pal optimism -- Optimism by mingapur\n119 -- +pal 118 = +pal taffy -- Taffy 16 by PineTreePizza\n120 -- +pal 119 = +pal todayland -- Todayland Palette V2 by GrafxKid\n121 -- +pal 120 = +pal trirampo -- TriRampo by ANoob\n122 -- +pal 121 = +pal reddit_place_2022 -- r|place 2022\n123 -- +pal 122 = +pal tropical -- Tropical Cone 24 by yedamameday\n124 -- +pal 123 = +pal vivid -- Vivid-17 by Irenaart\n125 -- +pal 124 = +pal shido -- SHIDO50+ by Shidoengie\n126 -- +pal 125 = +pal intacto -- Intacto14 by Anoob\n127 -- +pal 126 = +pal itatsi -- Itatsi by SoundsDotZip\n128 -- +pal 127 = +pal enos -- ENOS16 by Endesga\n129 -- +pal 128 = +pal grixel -- Grixel Grotto by Northernite\n130 -- +pal 129 = +pal superb -- Superb 8 by BigPotato\n131 -- +pal 130 = +pal undertones -- Undertones-17 by Irenaart\n132 -- +pal 131 = +pal tango -- Tango by Duck\n133 -- +pal 132 = +pal cheese -- Cheese Palette by Gors\n134 -- +pal 133 = +pal equpix15 -- Equpix 15 by Night\n135 -- +pal 134 = +pal zughy -- Zughy 32 by Zughy\n136 -- +pal 135 = +pal voodo -- Voodo34 by Shamaboy\n137 -- +pal 136 = +pal franzston -- Franzston 30 by Virus610\n138 -- +pal 137 = +pal night -- Night 16 by Night\n139 -- +pal 138 = +pal star29 -- Star 29 by Starlane\n140 -- +pal 139 = +pal star34 -- Star 34 by Starlane\n141 -- +pal 140 = +pal still_life -- Still-Life by cure\n142 -- +pal 141 = +pal simple_jpc_16 -- SimpleJPC-16 by Adigun A. Polack\n143 -- +pal 142 = +pal acid -- Acid 15 by pyrometal\n144 -- +pal 143 = +pal battery -- Battery 24 by Battery Jellyfish\n145 -- +pal 144 = +pal clumpy -- Clumpy 18 by windfall.apples\n146 -- +pal 145 = +pal cthul -- Cthulhu by Starlane\n147 -- +pal 146 = +pal crimso11 -- Crimso 11 by Crimso\n148 -- +pal 147 = +pal copper_tech -- Copper-Tech by Arne Niklas Jansson\n149 -- +pal 148 = +pal drz15a -- DRZ15A by Drazille\n150 -- +pal 149 = +pal eggy -- Eggy 15 by Eggy\n151 -- +pal 150 = +pal europa -- Europa 16 by Starlane\n152 -- +pal 151 = +pal greyt_bit -- GreyT-bit by Sam Keddy\n153 -- +pal 152 = +pal jewel -- Jewel by AprilSundae\n154 -- +pal 153 = +pal polar -- Polar 11 by Smalls\n155 -- +pal 154 = +pal sheltzy -- Sheltzy 32 by NatTorpedia\n156 -- +pal 155 = +pal wyrm -- Wyrm 24 by FrogWyrm\n157 -- +pal 156 = +pal yume_nikki -- Yume Nikki by Space Sandwich\n158 -- +pal 157 = +pal rube_goldberg -- Rube-Goldberg\n159 -- +pal 158 = +pal boomboom -- BoomBoom by Salman_Shh\n160 -- +pal 159 = +pal generic_8 -- Generic-8 by GrafxKid\n161 -- +pal 160 = +pal crayola -- Crayola Blind\n162 -- +pal 161 = +pal funky -- FunkyFuture8 by ShamaBoy\n163 -- +pal 162 = +pal golden_wall -- The Golden Wall Palette by Hans Hofmann\n164 -- +pal 163 = +pal matriax8c -- Matriax8c by Davit Masia\n165 -- +pal 164 = +pal nt1h -- NT1H by NatTorpedia\n166 -- +pal 165 = +pal jerrypie -- JerryPie 22 by JerryPie\n167 -- +pal 166 = +pal nineties_nine -- Nineties Nine by Cubby Crazes\n168 -- +pal 167 = +pal on70 -- On70 by By8Bits\n169 -- +pal 168 = +pal anb16 -- ANB16 by Anoob\n170 -- +pal 169 = +pal retrocal -- Retrocal-8 by polyphrog\n171 -- +pal 170 = +pal punolit -- Punolit by Punoli\n172 -- +pal 171 = +pal luap -- Luap 40 by Luap\n173 -- +pal 172 = +pal autum_villan -- Autum Villan 6 by Chase Stemel\n174 -- +pal 173 = +pal autum_15 -- Autum 15 by jok\n175 -- +pal 174 = +pal autum_15_yellow -- Autum 15 [Yellow] by jok\n176 -- +pal 175 = +pal galaxy_flame -- Galaxy Flame by Rhoq\n177 -- +pal 176 = +pal cretaceous -- Cretaceous-16 by Joao Vasconcelos\n178 -- +pal 177 = +pal antiquity -- Antiquity16 by ILTA\n179 -- +pal 178 = +pal mushroom -- Mushroom by Jimison3\n180 -- +pal 179 = +pal aerugo -- Aerugo by Lizalot\n181 -- +pal 180 = +pal hotel_paintings -- Hotel Paintings 6 by Chase Stemel\n182 -- +pal 181 = +pal nopal -- Nopal-12 by BlackedIRL.\n183 -- +pal 182 = +pal brightness_gpy -- Brightness GPY by rickthepalette\n184 -- +pal 183 = +pal blessing -- Blessing by Maruki\n185 -- +pal 184 = +pal fairy_dust -- Fairydust 8 by Yousurname\n186 -- +pal 185 = +pal milkshake -- Vanilla MilkShake by Space Sandwich\n187 -- +pal 186 = +pal fuzzy -- Fuzzy Four by P-Tux7\n188 -- +pal 187 = +pal fairy -- Fairy Tales by lollige\n189 -- +pal 188 = +pal naji16 -- Naji 16 by Naji\n190 -- +pal 189 = +pal easter -- Easter Island by skamocore\n191 -- +pal 190 = +pal pastel_and_darks -- Pastel and Darks 58 Palette by Glxss\n192 -- +pal 191 = +pal pastel_irena -- 17 Pastels by Irenaart\n193 -- +pal 192 = +pal nostalgia -- NOSTALGIA15 by Arisuki\n194 -- +pal 193 = +pal ocaso -- Ocaso by Minord\n195 -- +pal 194 = +pal pastel_starlitsunset -- Oh Hell, Pastel by StarlitSunset\n196 -- +pal 195 = +pal pollen -- Pollen-8 by Conker\n197 -- +pal 196 = +pal kule -- KULE-16 by Cuymacu\n198 -- +pal 197 = +pal hydrangea -- Hydrangea 11 by Dinchen's Art\n199 -- +pal 198 = +pal fluffy -- Fluffy8 by vee\n200 -- +pal 199 = +pal st_8_red_and_blue -- ST 8 R&B Remake by Skiller Thomson\n201 -- +pal 200 = +pal neon -- Neon Space by Jimison3\n202 -- +pal 201 = +pal cyclope -- Cyclope6 by Royal_Naym\n203 -- +pal 202 = +pal sy17 -- Sy17 by xaiue\n204 -- +pal 203 = +pal syz15 -- Syz15 by Fusionnist\n205 -- +pal 204 = +pal tui15 -- TUI-15 by Jeremy\n206 -- +pal 205 = +pal cave -- Cave by PineTreePizza\n207 -- +pal 206 = +pal psygnosia -- Psygnosia by Arne Niklas Jansson\n208 -- +pal 207 = +pal marshmellow -- MarshMellow32 by FormalPrejudice\n209 -- +pal 208 = +pal lost_century -- Lost Century 24 by CalmRadish\n210 -- +pal 209 = +pal finlal -- Finlal 11 by Finlal\n211 -- +pal 210 = +pal industrial -- Industrial Factory 16 by Toby_Yasha\n212 -- +pal 211 = +pal murder_mystery -- Murder Mystery 16 by Toby_Yasha\n213 -- +pal 212 = +pal fate_and_destiny -- Fate & Destiny 12 by Toby_Yasha\n214 -- +pal 213 = +pal vinik -- Vinik 24 by Vinik\n215 -- +pal 214 = +pal ykb -- YKB-22 by yahkehbu\n216 -- +pal 215 = +pal halloween -- Halloween by Mememellow\n217 -- +pal 216 = +pal graveyard -- Graveyard-21 by AprilSundae\n218 -- +pal 217 = +pal steamlords -- Steam Lords by Slynyrd\n219 -- +pal 218 = +pal frostical -- Frostical by yedamameday\n220 -- +pal 219 = +pal deuterospill -- DeuteroSpill by Royal_Naym\n221 -- +pal 220 = +pal cool_bone -- Cool Bone 7 by Chase Stemel\n222 -- +pal 221 = +pal muted_ally -- Muted Ally 6 by Chase Stemel\n223 -- +pal 222 = +pal ephemera -- EPHEMERA by K C\n224 -- +pal 223 = +pal ink -- Ink by AprilSundae\n225 -- +pal 224 = +pal violet_dreams -- Violet Dreams by Solitaire\n226 -- +pal 225 = +pal tinyfolks -- Tinyfolks by Pierr Vandermaesan\n227 -- +pal 226 = +pal old_gold -- Old Gold 7 by Chase Stemel\n228 -- +pal 227 = +pal rose_moss_8 -- Rosemoss-8 by polyphrog\n229 -- +pal 228 = +pal aap_radiant_xv -- AAP-RadiantXV by Adigun A. Polack\n230 -- +pal 229 = +pal aap_majesty_xvii -- AAP-Majesty XVII by Adigun A. Polack\n231 -- +pal 230 = +pal dead_weight -- Dead Weight-8 by polyphrog\n232 -- +pal 231 = +pal mojave -- Mojave20 by magodellepercussioni\n233 -- +pal 232 = +pal petite-8 -- Petite-8 by Adigun A. Polack\n234 -- +pal 233 = +pal petite-8-afterdark -- Petite-8 Afterdark by Adigun A. Polack\n235 -- +pal 234 = +pal xaiue_radiant -- XAIUE-Radiant by xaiue\n236 -- +pal 235 = +pal daruda -- Daruda 22 by daruda\n237 -- +pal 236 = +pal firestorm -- Firestorm by theartistjulian\n238 -- +pal 237 = +pal borkfest -- Borkfest by ã¾ãã\n239 -- +pal 238 = +pal spicy -- Spicy 07 by green guy\n240 -- +pal 239 = +pal rust -- Rust-6 by Blue Phoenix\n241 -- +pal 240 = +pal apricot -- Apricot by Chase Stemel\n242 -- +pal 241 = +pal supernova -- SuperNova 7 by Blue Phoenix\n243 -- +pal 242 = +pal pastry -- Pastry by MirruTatep\n244 -- +pal 243 = +pal sandy -- Sandy 06 by green guy\n245 -- +pal 244 = +pal illumination -- Illumination by MirruTatep\n246 -- +pal 245 = +pal nyx -- NYX8 by Javier Guerrero\n247 -- +pal 246 = +pal dream_haze -- Dream Haze 8 by Klafooty\n248 -- +pal 247 = +pal oil -- OIL6 by GrafxKid\n249 -- +pal 248 = +pal regal -- Regal10 by JRiggles\n250 -- +pal 249 = +pal soft_demon -- Soft Demon 7 by Chase Stemel\n251 -- +pal 250 = +pal sgm -- SGM-Palette 2 by s.g.m\n252 -- +pal 251 = +pal midnight_ablaze -- Midnight ablaze by Inkpendude\n253 -- +pal 252 = +pal black_cherry -- Black Cherry by MirruTatep\n254 -- +pal 253 = +pal sunset_red -- Sunset Red by Cabezinu\n255 -- +pal 254 = +pal inkpink -- INKPINK by Inkpendude\n256 -- +pal 255 = +pal brash_pink -- Brash Pink by ItzFred\n257 -- +pal 256 = +pal pink_neon_sign -- Pink Neon Sign 6 by Chase Stemel\n258 -- +pal 257 = +pal enchanted_purple -- Enchanted Purple by Kaiburn\n259 -- +pal 258 = +pal arch -- Arch by Poltergasm\n260 -- +pal 259 = +pal spacey_easter -- Spacey Easter by Spark Norris\n261 -- +pal 260 = +pal fornax_void_1 -- Fornax Void I by Fornax Void\n262 -- +pal 261 = +pal fornax_void_2 -- Fornax Void II by Fornax Void\n263 -- +pal 262 = +pal pixelwave -- Pixelwave by Reptorian\n264 -- +pal 263 = +pal s1_6 -- S1-6 by Blyzz\n265 -- +pal 264 = +pal berry_nebula -- Berry Nebula by LostInIndigo\n266 -- +pal 265 = +pal abyss -- ABYSS-9 by Jusiv\n267 -- +pal 266 = +pal moonlight -- Moonlight 15 by Tofu\n268 -- +pal 267 = +pal moon39 -- Moonlit-39 by theartistjulian\n269 -- +pal 268 = +pal h2o -- H2O by maine\n270 -- +pal 269 = +pal magic_waters -- Magic Waters 9 by Chase Stemel\n271 -- +pal 270 = +pal bluemold -- Bluem0ld by warpixel\n272 -- +pal 271 = +pal moss -- Moss by Zetomis\n273 -- +pal 272 = +pal deep_maze -- DEEP MAZE by Ryosuke\n274 -- +pal 273 = +pal toxic_slime -- Toxic Slime by MirruTatep\n275 -- +pal 274 = +pal lush_green -- Lush Green by EerieJam\n276 -- +pal 275 = +pal tsunami -- Tsunami by MirruTatep\n277 -- +pal 276 = +pal cryptic_ocean -- Cryptic Ocean by Klafooty\n278 -- +pal 277 = +pal marsh_madness -- Marsh Madness by MirruTatep\n279 -- +pal 278 = +pal oxyd -- OXYD by ItzFred\n280 -- +pal 279 = +pal pink_green -- Pink&Green by q1\n281 -- +pal 280 = +pal woodwalk -- Walking in the Woods 8 by Chase Stemel\n282 -- +pal 281 = +pal paper8 -- Paper 8 by Frosty Rabbid\n283 -- +pal 282 = +pal sahara_pastell -- Sahara Pastell by wermz\n284 -- +pal 283 = +pal sunflower -- Sunflower Painting 7 by Chase Stemel\n285 -- +pal 284 = +pal arthoe -- Art Hoe Aesthetic 7 by Chase Stemel\n286 -- +pal 285 = +pal sky -- Sky5 by MiniTe\n287 -- +pal 286 = +pal ocean_glass -- Ocean Glass by Solitaire\n288 -- +pal 287 = +pal royal -- RoyalGuard by Royal_Naym\n289 -- +pal 288 = +pal eulbink -- Eulbink by Inkpendude\n290 -- +pal 289 = +pal winter_wonderland -- Winter Wonderland by Jimison3\n291 -- +pal 290 = +pal moon_squid -- Moon Squid 7 by Chase Stemel\n292 -- +pal 291 = +pal stratus -- Stratus by MirruTatep\n293 -- +pal 292 = +pal arctic_dust -- Arctic Dust by MirruTatep\n294 -- +pal 293 = +pal clouds_sunset -- CL8UDS by _Nicola\n295 -- +pal 294 = +pal lilac_skies -- Lilac Skies 5 by Chase Stemel\n296 -- +pal 295 = +pal sea_of_fire -- Sea of Fire by TATA-PIXEL\n297 -- +pal 296 = +pal autochrome3 -- Autochrome 3 by Reptorian\n298 -- +pal 297 = +pal autochrome5 -- Autochrome 5 by Reptorian\n299 -- +pal 298 = +pal gb_default_1 -- GB Default 1\n300 -- +pal 299 = +pal gb_default_2 -- GB Default 2\n301 -- +pal 300 = +pal gb_andrade -- GB Andrade by Andrade\n302 -- +pal 301 = +pal gb_blue -- GB Blue Seni by WildLeoKnight\n303 -- +pal 302 = +pal gb_blackzone -- GB Blackzone\n304 -- +pal 303 = +pal gb_suburb -- GB Suburb by Poppysalmon\n305 -- +pal 304 = +pal gb_crimson -- GB Crimson by WildLeoKnight\n306 -- +pal 305 = +pal gb_didi -- GB Didi by DidiGameboy\n307 -- +pal 306 = +pal gb_dirty -- GB Dirty by WildLeoKnight\n308 -- +pal 307 = +pal gb_arne -- GB Arne by Arne\n309 -- +pal 308 = +pal gb_easy -- GB Easy by GrafxKid\n310 -- +pal 309 = +pal gb_forest -- GB Forest\n311 -- +pal 310 = +pal gb_harsh_green -- GB Harsh Green by WildLeoKnight\n312 -- +pal 311 = +pal gb_light_green -- GB Light Green by WildLeoKnight\n313 -- +pal 312 = +pal gb_nostalgia -- GB Nostalgia by WildLeoKnight\n314 -- +pal 313 = +pal gb_platinum -- GB Platinum by WildLeoKnight\n315 -- +pal 314 = +pal gb_kirokaze -- GB Kirokaze by Kirokaze\n316 -- +pal 315 = +pal gb_cyber -- GB Cyber\n317 -- +pal 316 = +pal gb_wish -- GB Wish by Kerrie Lake\n318 -- +pal 317 = +pal gb_grapefruit -- GB Grapefruit by GrafxKid\n319 -- +pal 318 = +pal gb_ice_cream -- GB Ice Cream by Kerrie Lake\n320 -- +pal 319 = +pal gb_red_blue -- GB Red_Blue\n321 -- +pal 320 = +pal gb_gold -- Gold GB by Isa\n322 -- +pal 321 = +pal gb_choco -- GB Chocolate by GrafxKid\n323 -- +pal 322 = +pal gb_gray -- GB Gray by GrafxKid\n324 -- +pal 323 = +pal gb_space -- GB Spacehaze by WildLeoKnight\n325 -- +pal 324 = +pal gb_purple_dawn -- GB Purple Dawn by WildLeoKnight\n326 -- +pal 325 = +pal moon_crystal -- Moon Crystal by Doph\n327 -- +pal 326 = +pal arne -- ARNE4 by Arne\n328 -- +pal 327 = +pal autumn_chill -- Autumn Chill by Doph\n329 -- +pal 328 = +pal cherrymelon -- CherryMelon by WildLeoKnight\n330 -- +pal 329 = +pal hal4 -- HallowPumpkin by WildLeoKnight\n331 -- +pal 330 = +pal hollow -- Hollow by Poltergasm\n332 -- +pal 331 = +pal lavender -- Lavender4 by Solitaire\n333 -- +pal 332 = +pal maw -- MAW by bloo\n334 -- +pal 333 = +pal voltage_warning -- Voltage Warning by Wuchta\n335 -- +pal 334 = +pal tritanopia -- Tritanopia by Allappini\n336 -- +pal 335 = +pal rabbit -- Rabbit 7 by GrafxKid\n337 -- +pal 336 = +pal amiga2600_ntsc -- Amiga 2600 NTSC\n338 -- +pal 337 = +pal amiga2600_pal -- Amiga 2600 PAL\n339 -- +pal 338 = +pal amiga2600_secam -- Amiga 2600 SECAM\n340 -- +pal 339 = +pal amiga7800_mess -- Amiga 7800 M.E.S.S by Nabuko78\n341 -- +pal 340 = +pal amiga7800 -- Amiga 7800\n342 -- +pal 341 = +pal amstrad_cpc -- Amstrad CPC\n343 -- +pal 342 = +pal apple -- Apple II\n344 -- +pal 343 = +pal atari -- Atari 8-Bit Series - GTIA by PixelCrunch\n345 -- +pal 344 = +pal cga -- CGA\n346 -- +pal 345 = +pal cga00 -- CGA Mode 0 [Low]\n347 -- +pal 346 = +pal cga01 -- CGA Mode 0 [High]\n348 -- +pal 347 = +pal cga10 -- CGA Mode 1 [Low]\n349 -- +pal 348 = +pal cga11 -- CGA Mode 1 [High]\n350 -- +pal 349 = +pal cga20 -- CGA Mode 2 [Low]\n351 -- +pal 350 = +pal cga21 -- CGA Mode 2 [High]\n352 -- +pal 351 = +pal c64_pepto -- Commodore 64 - Pepto\n353 -- +pal 352 = +pal c64_colodore -- Commodore 64 - Colodore\n354 -- +pal 353 = +pal com_vic_20 -- Commodore VIC-20\n355 -- +pal 354 = +pal colecovision -- Colecovision\n356 -- +pal 355 = +pal jmp -- Japanese Machine Palette by Arne Niklas Jansson\n357 -- +pal 356 = +pal mac2 -- Macintosh II\n358 -- +pal 357 = +pal mac_8_bit -- Macintosh 8-Bit System Palette\n359 -- +pal 358 = +pal msx -- MSX\n360 -- +pal 359 = +pal nes -- NES\n361 -- +pal 360 = +pal pico -- PICO-8 by Lexaloffle Games\n362 -- +pal 361 = +pal risc -- RISC OS\n363 -- +pal 362 = +pal sam_coupe -- SAM Coupe\n364 -- +pal 363 = +pal mo5 -- Thomson MO5\n365 -- +pal 364 = +pal trs80 -- TRS-80 Color Computer Palette\n366 -- +pal 365 = +pal virtualboy -- Virtual Boy interpreted by Bruno Weinberger\n367 -- +pal 366 = +pal vga -- VGA\n368 -- +pal 367 = +pal win95 -- Win 95\n369 -- +pal 368 = +pal zx -- ZX Spectrum\n370 -- +pal 369 = +pal gnome -- GNOME 32\n371 -- +pal 370 = +pal electronic_crayon -- Electronic Crayon 22\n372 -- +pal 371 = +pal chip16 -- Chip16\n373 -- +pal 372 = +pal deluxe_paint -- Deluxe Paint\n374 -- +pal 373 = +pal flat_ui -- FlatUI from flat ui colors website\n375 -- +pal 374 = +pal makecode_arcade -- MakeCode Arcade Palette\n376 -- +pal 375 = +pal oekaki -- Oekaki from Oekaki.nl\n377 -- +pal 376 = +pal ms_legacy_paint -- Legacy Paint\n378 -- +pal 377 = +pal ms_xp -- XP Paint\n379 -- +pal 378 = +pal vista -- Vista Paint\n380 -- +pal 379 = +pal piet -- Piet Palette by Piet Mondrain\n381 -- +pal 380 = +pal japanese_woodblock -- Japanese Woodblock Palette by Polyducks\n382 -- +pal 381 = +pal human_faces -- Human Faces by Romney57\n383 -- +pal 382 = +pal hsv -- HSV Palette by MadJik\n384 -- +pal 383 = +pal christmas -- ST24 Christmas by Skiller Thomson\n385 -- +pal 384 = +pal ladybug_reds -- Reds by Ladybug")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_premade_palette:

xpos,ypos,split_width,scaling,flip_row,rotation_angle,mir_x,mir_y,pal_to_img={$2/2}~,{$3/2}~,${4-6},{((3-$7)-1)*(90*(($8!=$9)?-1:1))},${8-9},$10

+pal $1

to_rgba

local[-1] {
	s x,-$split_width
	if $flip_row&&$!>1 mirror[1--1:2] x fi
	a y
}

rotate. $rotation_angle
if $mir_x mirror. x fi
if $mir_y mirror. y fi
rs. {w*$scaling},,1

split_opacity. to_rgba..
store[-2,-1] palette_img

foreach {
	if !$pal_to_img {w},{h},1,100% rm.. fi
	$palette_img
	j[-3] [-2],$xpos,$ypos,0,0,1,[-1],255
	rm[-2,-1]
}

fx_rep_premade_palette_preview:
fx_rep_premade_palette ${1-10}
message_out,act_exp="Available for Export!",$15
format_choice=${arg0\ $13,gpl,pdn_pal,jasc}
use_pdn:=['$format_choice']==['pdn_pal']
enable_export=2

+pal $1

if $1!=$-1
	output_name={-1,n}
else
	output_name="$12"
fi

rep_correct_exp_ne {``$output_name}
new_out=${}

if $act_exp

	rep_output_$format_choice. "$11"/$new_out

	if $use_pdn
		if whd#-1>96 message_out="Export failed! 96 or less color only for PDN Palette." fi
	else message_out="Successfully Exported!"
	fi

elif $use_pdn&&whd#-1>96
	enable_export=1
	message_out="96 Colors Restriction Exceeded! Disabled Export!"
fi

u "{$1}"\
  "{$2}"\
  "{$3}"\
  "{$4}"\
  "{$5}"\
  "{$6}"\
  "{$7}"\
  "{$8}"\
  "{$9}"\
  "{$10}"\
  "{$11}"\
  "{"$new_out"}"\
  "{$13}"\
  "{"$message_out"}"\
  "{0}_"$enable_export\
  "{$1}"
#@gui Transfer Color [Reduced Colors]:fx_rep_transfer_color_reduced,fx_rep_transfer_color_reduced_preview(0)*
#@gui:_=separator(),_=note("<b>Preliminary Setup</b>")
#@gui:Style of Dithering=choice(0,"Indexing","Ordered")
#@gui:Dithering (%)=float(50,0,100)
#@gui:Special Effect=choice(0,"None","Horizontal-D","Vertical-D","Horizontal-L","Vertical-L","Checkerboard-D","Checkerboard-L")
#@gui:Special Effect Factor (%)=float(50,0,100)
#@gui:_=separator(),_=note("<b>Palette</b>")
#@gui:Coloring Method=choice(0,"Premade Palette","Bit Depth/Levels")
#@gui:Palette Method=choice(0,"Premade","Auto","Import","Custom")
#@gui:Use Bit Depth=bool(0)
#@gui:Levels=int(4,1,64)
#@gui:Red Levels=int(4,1,64)
#@gui:Green Levels=int(4,1,64)
#@gui:Blue Levels=int(4,1,64)
#@gui:Use Same Levels for All Channels=bool(0)
#@gui:Bit-Depth=int(2,1,8)
#@gui:Red Bit-Depth=int(2,1,8)
#@gui:Green Bit-Depth=int(2,1,8)
#@gui:Blue Bit-Depth=int(2,1,8)
#@gui:Use Same Bit-Depths for All Channel=bool(0)
#@gui:Palette to Use=choice(18,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:â - Send to Custom Paletteâ - =button()
#@gui:Palette File Location=file()
#@gui:Re-Import Fileââ=button()
#@gui:Number of Color=int(8,2,256)
#@gui:Number of Color=int(8,2,256)
#@gui:Color Restriction Per Whole Image=int(0,0,256)
#@gui:Color Restriction Per Window=int(0,0,16)
#@gui:Display Custom Palette Colors=bool(1)
#@gui:Multi-Select Palette Color=bool(0)
#@gui:_=separator()
#@gui:Delete All Selected Palette=button(0)
#@gui:_=separator()
#@gui:Palette Color 1=color(247,244,191)
#@gui:â  â  â  â  Delete Color 1â  â  â  â  â  =button(0)
#@gui:Color 1 Selected=_bool(0)
#@gui:Palette Color 2=color(255,240,43)
#@gui:â  â  â  â  Delete Color 2â  â  â  â  â  =button(0)
#@gui:Color 2 Selected=_bool(0)
#@gui:Palette Color 3=color(255,207,5)
#@gui:â  â  â  â  Delete Color 3â  â  â  â  â  =button(0)
#@gui:Color 3 Selected=_bool(0)
#@gui:Palette Color 4=color(255,177,8)
#@gui:â  â  â  â  Delete Color 4â  â  â  â  â  =button(0)
#@gui:Color 4 Selected=_bool(0)
#@gui:Palette Color 5=color(233,134,39)
#@gui:â  â  â  â  Delete Color 5â  â  â  â  â  =button(0)
#@gui:Color 5 Selected=_bool(0)
#@gui:Palette Color 6=color(191,90,62)
#@gui:â  â  â  â  Delete Color 6â  â  â  â  â  =button(0)
#@gui:Color 6 Selected=_bool(0)
#@gui:Palette Color 7=color(156,51,39)
#@gui:â  â  â  â  Delete Color 7â  â  â  â  â  =button(0)
#@gui:Color 7 Selected=_bool(0)
#@gui:Palette Color 8=color(114,28,3)
#@gui:â  â  â  â  Delete Color 8â  â  â  â  â  =button(0)
#@gui:Color 8 Selected=_bool(0)
#@gui:Palette Color 9=color(255,226,207)
#@gui:â  â  â  â  Delete Color 9â  â  â  â  â  =button(0)
#@gui:Color 9 Selected=_bool(0)
#@gui:Palette Color 10=color(212,174,170)
#@gui:â  â  â  â  Delete Color 10â  â  â  â â=button(0)
#@gui:Color 10 Selected=_bool(0)
#@gui:Palette Color 11=color(181,139,148)
#@gui:â  â  â  â Delete Color 11â  â  â  â  â=button(0)
#@gui:Color 11 Selected=_bool(0)
#@gui:Palette Color 12=color(173,121,132)
#@gui:â  â  â  â Delete Color 12â  â  â  â  â=button(0)
#@gui:Color 12 Selected=_bool(0)
#@gui:Palette Color 13=color(145,96,106)
#@gui:â  â  â  â Delete Color 13â  â  â  â  â=button(0)
#@gui:Color 13 Selected=_bool(0)
#@gui:Palette Color 14=color(119,83,91)
#@gui:â  â  â  â Delete Color 14â  â  â  â  â=button(0)
#@gui:Color 14 Selected=_bool(0)
#@gui:Palette Color 15=color(94,65,74)
#@gui:â  â  â  â Delete Color 15â  â  â  â  â=button(0)
#@gui:Color 15 Selected=_bool(0)
#@gui:Palette Color 16=color(73,33,41)
#@gui:â  â  â  â Delete Color 16â  â  â  â  â=button(0)
#@gui:Color 16 Selected=_bool(0)
#@gui:Palette Color 17=color(131,147,195)
#@gui:â  â  â  â Delete Color 17â  â  â  â  â=button(0)
#@gui:Color 17 Selected=_bool(0)
#@gui:Palette Color 18=color(108,130,196)
#@gui:â  â  â  â Delete Color 18â  â  â  â  â=button(0)
#@gui:Color 18 Selected=_bool(0)
#@gui:Palette Color 19=color(82,116,197)
#@gui:â  â  â  â Delete Color 19â  â  â  â  â=button(0)
#@gui:Color 19 Selected=_bool(0)
#@gui:Palette Color 20=color(81,101,174)
#@gui:â  â  â  â Delete Color 20â  â  â  â  â=button(0)
#@gui:Color 20 Selected=_bool(0)
#@gui:Palette Color 21=color(61,80,131)
#@gui:â  â  â  â Delete Color 21â  â  â  â  â=button(0)
#@gui:Color 21 Selected=_bool(0)
#@gui:Palette Color 22=color(45,61,114)
#@gui:â  â  â  â Delete Color 22â  â  â  â  â=button(0)
#@gui:Color 22 Selected=_bool(0)
#@gui:Palette Color 23=color(40,51,93)
#@gui:â  â  â  â Delete Color 23â  â  â  â  â=button(0)
#@gui:Color 23 Selected=_bool(0)
#@gui:Palette Color 24=color(38,36,80)
#@gui:â  â  â  â Delete Color 24â  â  â  â  â=button(0)
#@gui:Color 24 Selected=_bool(0)
#@gui:Palette Color 25=color(209,189,254)
#@gui:â  â  â  â Delete Color 25â  â  â  â  â=button(0)
#@gui:Color 25 Selected=_bool(0)
#@gui:Palette Color 26=color(186,171,247)
#@gui:â  â  â  â Delete Color 26â  â  â  â  â=button(0)
#@gui:Color 26 Selected=_bool(0)
#@gui:Palette Color 27=color(169,150,236)
#@gui:â  â  â  â Delete Color 27â  â  â  â  â=button(0)
#@gui:Color 27 Selected=_bool(0)
#@gui:Palette Color 28=color(149,133,241)
#@gui:â  â  â  â Delete Color 28â  â  â  â  â=button(0)
#@gui:Color 28 Selected=_bool(0)
#@gui:Palette Color 29=color(121,100,186)
#@gui:â  â  â  â Delete Color 29â  â  â  â  â=button(0)
#@gui:Color 29 Selected=_bool(0)
#@gui:Palette Color 30=color(88,74,127)
#@gui:â  â  â  â Delete Color 30â  â  â  â  â=button(0)
#@gui:Color 30 Selected=_bool(0)
#@gui:Palette Color 31=color(60,49,81)
#@gui:â  â  â  â Delete Color 31â  â  â  â  â=button(0)
#@gui:Color 31 Selected=_bool(0)
#@gui:Palette Color 32=color(29,29,33)
#@gui:â  â  â  â Delete Color 32â  â  â  â  â=button(0)
#@gui:Color 32 Selected=_bool(0)
#@gui:Palette Color 33=color(253,247,134)
#@gui:â  â  â  â Delete Color 33â  â  â  â  â=button(0)
#@gui:Color 33 Selected=_bool(0)
#@gui:Palette Color 34=color(255,213,155)
#@gui:â  â  â  â Delete Color 34â  â  â  â  â=button(0)
#@gui:Color 34 Selected=_bool(0)
#@gui:Palette Color 35=color(235,189,157)
#@gui:â  â  â  â Delete Color 35â  â  â  â  â=button(0)
#@gui:Color 35 Selected=_bool(0)
#@gui:Palette Color 36=color(213,163,154)
#@gui:â  â  â  â Delete Color 36â  â  â  â  â=button(0)
#@gui:Color 36 Selected=_bool(0)
#@gui:Palette Color 37=color(185,140,147)
#@gui:â  â  â  â Delete Color 37â  â  â  â  â=button(0)
#@gui:Color 37 Selected=_bool(0)
#@gui:Palette Color 38=color(151,116,136)
#@gui:â  â  â  â Delete Color 38â  â  â  â  â=button(0)
#@gui:Color 38 Selected=_bool(0)
#@gui:Palette Color 39=color(118,93,115)
#@gui:â  â  â  â Delete Color 39â  â  â  â  â=button(0)
#@gui:Color 39 Selected=_bool(0)
#@gui:Palette Color 40=color(85,71,105)
#@gui:â  â  â  â Delete Color 40â  â  â  â  â=button(0)
#@gui:Color 40 Selected=_bool(0)
#@gui:Palette Color 41=color(109,204,255)
#@gui:â  â  â  â Delete Color 41â  â  â  â  â=button(0)
#@gui:Color 41 Selected=_bool(0)
#@gui:Palette Color 42=color(85,177,241)
#@gui:â  â  â  â Delete Color 42â  â  â  â  â=button(0)
#@gui:Color 42 Selected=_bool(0)
#@gui:Palette Color 43=color(64,151,234)
#@gui:â  â  â  â Delete Color 43â  â  â  â  â=button(0)
#@gui:Color 43 Selected=_bool(0)
#@gui:Palette Color 44=color(20,118,192)
#@gui:â  â  â  â Delete Color 44â  â  â  â  â=button(0)
#@gui:Color 44 Selected=_bool(0)
#@gui:Palette Color 45=color(16,93,162)
#@gui:â  â  â  â Delete Color 45â  â  â  â  â=button(0)
#@gui:Color 45 Selected=_bool(0)
#@gui:Palette Color 46=color(7,72,124)
#@gui:â  â  â  â Delete Color 46â  â  â  â  â=button(0)
#@gui:Color 46 Selected=_bool(0)
#@gui:Palette Color 47=color(3,49,95)
#@gui:â  â  â  â Delete Color 47â  â  â  â  â=button(0)
#@gui:Color 47 Selected=_bool(0)
#@gui:Palette Color 48=color(0,27,64)
#@gui:â  â  â  â Delete Color 48â  â  â  â  â=button(0)
#@gui:Color 48 Selected=_bool(0)
#@gui:Palette Color 49=color(224,250,235)
#@gui:â  â  â  â Delete Color 49â  â  â  â  â=button(0)
#@gui:Color 49 Selected=_bool(0)
#@gui:Palette Color 50=color(169,209,193)
#@gui:â  â  â  â Delete Color 50â  â  â  â  â=button(0)
#@gui:Color 50 Selected=_bool(0)
#@gui:Palette Color 51=color(138,193,150)
#@gui:â  â  â  â Delete Color 51â  â  â  â  â=button(0)
#@gui:Color 51 Selected=_bool(0)
#@gui:Palette Color 52=color(135,174,142)
#@gui:â  â  â  â Delete Color 52â  â  â  â  â=button(0)
#@gui:Color 52 Selected=_bool(0)
#@gui:Palette Color 53=color(113,149,125)
#@gui:â  â  â  â Delete Color 53â  â  â  â  â=button(0)
#@gui:Color 53 Selected=_bool(0)
#@gui:Palette Color 54=color(91,123,105)
#@gui:â  â  â  â Delete Color 54â  â  â  â  â=button(0)
#@gui:Color 54 Selected=_bool(0)
#@gui:Palette Color 55=color(71,101,90)
#@gui:â  â  â  â Delete Color 55â  â  â  â  â=button(0)
#@gui:Color 55 Selected=_bool(0)
#@gui:Palette Color 56=color(45,75,71)
#@gui:â  â  â  â Delete Color 56â  â  â  â  â=button(0)
#@gui:Color 56 Selected=_bool(0)
#@gui:Palette Color 57=color(244,163,128)
#@gui:â  â  â  â Delete Color 57â  â  â  â  â=button(0)
#@gui:Color 57 Selected=_bool(0)
#@gui:Palette Color 58=color(215,147,116)
#@gui:â  â  â  â Delete Color 58â  â  â  â  â=button(0)
#@gui:Color 58 Selected=_bool(0)
#@gui:Palette Color 59=color(191,126,99)
#@gui:â  â  â  â Delete Color 59â  â  â  â  â=button(0)
#@gui:Color 59 Selected=_bool(0)
#@gui:Palette Color 60=color(169,109,88)
#@gui:â  â  â  â Delete Color 60â  â  â  â  â=button(0)
#@gui:Color 60 Selected=_bool(0)
#@gui:Palette Color 61=color(148,93,79)
#@gui:â  â  â  â Delete Color 61â  â  â  â  â=button(0)
#@gui:Color 61 Selected=_bool(0)
#@gui:Palette Color 62=color(120,76,73)
#@gui:â  â  â  â Delete Color 62â  â  â  â  â=button(0)
#@gui:Color 62 Selected=_bool(0)
#@gui:Palette Color 63=color(83,57,58)
#@gui:â  â  â  â Delete Color 63â  â  â  â  â=button(0)
#@gui:Color 63 Selected=_bool(0)
#@gui:Palette Color 64=color(55,36,35)
#@gui:â  â  â  â Delete Color 64â  â  â  â  â=button(0)
#@gui:Color 64 Selected=_bool(0)
#@gui:Palette Color 65=color(127,189,57)
#@gui:â  â  â  â Delete Color 65â  â  â  â  â=button(0)
#@gui:Color 65 Selected=_bool(0)
#@gui:Palette Color 66=color(120,158,36)
#@gui:â  â  â  â Delete Color 66â  â  â  â  â=button(0)
#@gui:Color 66 Selected=_bool(0)
#@gui:Palette Color 67=color(107,132,45)
#@gui:â  â  â  â Delete Color 67â  â  â  â  â=button(0)
#@gui:Color 67 Selected=_bool(0)
#@gui:Palette Color 68=color(88,113,44)
#@gui:â  â  â  â Delete Color 68â  â  â  â  â=button(0)
#@gui:Color 68 Selected=_bool(0)
#@gui:Palette Color 69=color(76,95,51)
#@gui:â  â  â  â Delete Color 69â  â  â  â  â=button(0)
#@gui:Color 69 Selected=_bool(0)
#@gui:Palette Color 70=color(57,77,60)
#@gui:â  â  â  â Delete Color 70â  â  â  â  â=button(0)
#@gui:Color 70 Selected=_bool(0)
#@gui:Palette Color 71=color(46,61,71)
#@gui:â  â  â  â Delete Color 71â  â  â  â  â=button(0)
#@gui:Color 71 Selected=_bool(0)
#@gui:Palette Color 72=color(29,44,67)
#@gui:â  â  â  â Delete Color 72â  â  â  â  â=button(0)
#@gui:Color 72 Selected=_bool(0)
#@gui:Palette Color 73=color(254,223,177)
#@gui:â  â  â  â Delete Color 73â  â  â  â  â=button(0)
#@gui:Color 73 Selected=_bool(0)
#@gui:Palette Color 74=color(207,175,142)
#@gui:â  â  â  â Delete Color 74â  â  â  â  â=button(0)
#@gui:Color 74 Selected=_bool(0)
#@gui:Palette Color 75=color(179,151,131)
#@gui:â  â  â  â Delete Color 75â  â  â  â  â=button(0)
#@gui:Color 75 Selected=_bool(0)
#@gui:Palette Color 76=color(145,122,123)
#@gui:â  â  â  â Delete Color 76â  â  â  â  â=button(0)
#@gui:Color 76 Selected=_bool(0)
#@gui:Palette Color 77=color(117,104,110)
#@gui:â  â  â  â Delete Color 77â  â  â  â  â=button(0)
#@gui:Color 77 Selected=_bool(0)
#@gui:Palette Color 78=color(86,80,111)
#@gui:â  â  â  â Delete Color 78â  â  â  â  â=button(0)
#@gui:Color 78 Selected=_bool(0)
#@gui:Palette Color 79=color(59,56,85)
#@gui:â  â  â  â Delete Color 79â  â  â  â  â=button(0)
#@gui:Color 79 Selected=_bool(0)
#@gui:Palette Color 80=color(38,35,61)
#@gui:â  â  â  â Delete Color 80â  â  â  â  â=button(0)
#@gui:Color 80 Selected=_bool(0)
#@gui:Palette Color 81=color(255,246,79)
#@gui:â  â  â  â Delete Color 81â  â  â  â  â=button(0)
#@gui:Color 81 Selected=_bool(0)
#@gui:Palette Color 82=color(232,210,75)
#@gui:â  â  â  â Delete Color 82â  â  â  â  â=button(0)
#@gui:Color 82 Selected=_bool(0)
#@gui:Palette Color 83=color(209,170,57)
#@gui:â  â  â  â Delete Color 83â  â  â  â  â=button(0)
#@gui:Color 83 Selected=_bool(0)
#@gui:Palette Color 84=color(186,136,46)
#@gui:â  â  â  â Delete Color 84â  â  â  â  â=button(0)
#@gui:Color 84 Selected=_bool(0)
#@gui:Palette Color 85=color(158,101,32)
#@gui:â  â  â  â Delete Color 85â  â  â  â  â=button(0)
#@gui:Color 85 Selected=_bool(0)
#@gui:Palette Color 86=color(133,79,18)
#@gui:â  â  â  â Delete Color 86â  â  â  â  â=button(0)
#@gui:Color 86 Selected=_bool(0)
#@gui:Palette Color 87=color(117,59,9)
#@gui:â  â  â  â Delete Color 87â  â  â  â  â=button(0)
#@gui:Color 87 Selected=_bool(0)
#@gui:Palette Color 88=color(98,42,0)
#@gui:â  â  â  â Delete Color 88â  â  â  â  â=button(0)
#@gui:Color 88 Selected=_bool(0)
#@gui:Palette Color 89=color(208,204,50)
#@gui:â  â  â  â Delete Color 89â  â  â  â  â=button(0)
#@gui:Color 89 Selected=_bool(0)
#@gui:Palette Color 90=color(180,170,51)
#@gui:â  â  â  â Delete Color 90â  â  â  â  â=button(0)
#@gui:Color 90 Selected=_bool(0)
#@gui:Palette Color 91=color(150,154,38)
#@gui:â  â  â  â Delete Color 91â  â  â  â  â=button(0)
#@gui:Color 91 Selected=_bool(0)
#@gui:Palette Color 92=color(124,131,30)
#@gui:â  â  â  â Delete Color 92â  â  â  â  â=button(0)
#@gui:Color 92 Selected=_bool(0)
#@gui:Palette Color 93=color(97,115,8)
#@gui:â  â  â  â Delete Color 93â  â  â  â  â=button(0)
#@gui:Color 93 Selected=_bool(0)
#@gui:Palette Color 94=color(73,93,0)
#@gui:â  â  â  â Delete Color 94â  â  â  â  â=button(0)
#@gui:Color 94 Selected=_bool(0)
#@gui:Palette Color 95=color(47,79,8)
#@gui:â  â  â  â Delete Color 95â  â  â  â  â=button(0)
#@gui:Color 95 Selected=_bool(0)
#@gui:Palette Color 96=color(32,41,0)
#@gui:â  â  â  â Delete Color 96â  â  â  â  â=button(0)
#@gui:Color 96 Selected=_bool(0)
#@gui:Palette Color 97=color(229,154,124)
#@gui:â  â  â  â Delete Color 97â  â  â  â  â=button(0)
#@gui:Color 97 Selected=_bool(0)
#@gui:Palette Color 98=color(210,141,122)
#@gui:â  â  â  â Delete Color 98â  â  â  â  â=button(0)
#@gui:Color 98 Selected=_bool(0)
#@gui:Palette Color 99=color(193,126,122)
#@gui:â  â  â  â Delete Color 99â  â  â  â  â=button(0)
#@gui:Color 99 Selected=_bool(0)
#@gui:Palette Color 100=color(172,111,110)
#@gui:â  â  â  â Delete Color 100â  â  â  ââ=button(0)
#@gui:Color 100 Selected=_bool(0)
#@gui:Palette Color 101=color(152,89,90)
#@gui:â  â  â  âDelete Color 101â  â  â  â  =button(0)
#@gui:Color 101 Selected=_bool(0)
#@gui:Palette Color 102=color(124,75,71)
#@gui:â  â  â  âDelete Color 102â  â  â  â  =button(0)
#@gui:Color 102 Selected=_bool(0)
#@gui:Palette Color 103=color(99,52,50)
#@gui:â  â  â  âDelete Color 103â  â  â  â  =button(0)
#@gui:Color 103 Selected=_bool(0)
#@gui:Palette Color 104=color(73,37,28)
#@gui:â  â  â  âDelete Color 104â  â  â  â  =button(0)
#@gui:Color 104 Selected=_bool(0)
#@gui:Palette Color 105=color(255,205,255)
#@gui:â  â  â  âDelete Color 105â  â  â  â  =button(0)
#@gui:Color 105 Selected=_bool(0)
#@gui:Palette Color 106=color(255,166,197)
#@gui:â  â  â  âDelete Color 106â  â  â  â  =button(0)
#@gui:Color 106 Selected=_bool(0)
#@gui:Palette Color 107=color(255,125,175)
#@gui:â  â  â  âDelete Color 107â  â  â  â  =button(0)
#@gui:Color 107 Selected=_bool(0)
#@gui:Palette Color 108=color(248,93,128)
#@gui:â  â  â  âDelete Color 108â  â  â  â  =button(0)
#@gui:Color 108 Selected=_bool(0)
#@gui:Palette Color 109=color(217,74,105)
#@gui:â  â  â  âDelete Color 109â  â  â  â  =button(0)
#@gui:Color 109 Selected=_bool(0)
#@gui:Palette Color 110=color(159,59,82)
#@gui:â  â  â  âDelete Color 110â  â  â  â  =button(0)
#@gui:Color 110 Selected=_bool(0)
#@gui:Palette Color 111=color(113,43,59)
#@gui:â  â  â  âDelete Color 111â  â  â  â  =button(0)
#@gui:Color 111 Selected=_bool(0)
#@gui:Palette Color 112=color(67,23,41)
#@gui:â  â  â  âDelete Color 112â  â  â  â  =button(0)
#@gui:Color 112 Selected=_bool(0)
#@gui:Palette Color 113=color(220,212,255)
#@gui:â  â  â  âDelete Color 113â  â  â  â  =button(0)
#@gui:Color 113 Selected=_bool(0)
#@gui:Palette Color 114=color(184,174,255)
#@gui:â  â  â  âDelete Color 114â  â  â  â  =button(0)
#@gui:Color 114 Selected=_bool(0)
#@gui:Palette Color 115=color(156,155,239)
#@gui:â  â  â  âDelete Color 115â  â  â  â  =button(0)
#@gui:Color 115 Selected=_bool(0)
#@gui:Palette Color 116=color(142,140,226)
#@gui:â  â  â  âDelete Color 116â  â  â  â  =button(0)
#@gui:Color 116 Selected=_bool(0)
#@gui:Palette Color 117=color(120,119,193)
#@gui:â  â  â  âDelete Color 117â  â  â  â  =button(0)
#@gui:Color 117 Selected=_bool(0)
#@gui:Palette Color 118=color(100,101,157)
#@gui:â  â  â  âDelete Color 118â  â  â  â  =button(0)
#@gui:Color 118 Selected=_bool(0)
#@gui:Palette Color 119=color(74,82,128)
#@gui:â  â  â  âDelete Color 119â  â  â  â  =button(0)
#@gui:Color 119 Selected=_bool(0)
#@gui:Palette Color 120=color(50,53,88)
#@gui:â  â  â  âDelete Color 120â  â  â  â  =button(0)
#@gui:Color 120 Selected=_bool(0)
#@gui:Palette Color 121=color(237,212,147)
#@gui:â  â  â  âDelete Color 121â  â  â  â  =button(0)
#@gui:Color 121 Selected=_bool(0)
#@gui:Palette Color 122=color(237,182,124)
#@gui:â  â  â  âDelete Color 122â  â  â  â  =button(0)
#@gui:Color 122 Selected=_bool(0)
#@gui:Palette Color 123=color(206,151,112)
#@gui:â  â  â  âDelete Color 123â  â  â  â  =button(0)
#@gui:Color 123 Selected=_bool(0)
#@gui:Palette Color 124=color(189,125,100)
#@gui:â  â  â  âDelete Color 124â  â  â  â  =button(0)
#@gui:Color 124 Selected=_bool(0)
#@gui:Palette Color 125=color(167,96,87)
#@gui:â  â  â  âDelete Color 125â  â  â  â  =button(0)
#@gui:Color 125 Selected=_bool(0)
#@gui:Palette Color 126=color(144,70,71)
#@gui:â  â  â  âDelete Color 126â  â  â  â  =button(0)
#@gui:Color 126 Selected=_bool(0)
#@gui:Palette Color 127=color(110,36,52)
#@gui:â  â  â  âDelete Color 127â  â  â  â  =button(0)
#@gui:Color 127 Selected=_bool(0)
#@gui:Palette Color 128=color(95,9,38)
#@gui:â  â  â  âDelete Color 128â  â  â  â  =button(0)
#@gui:Color 128 Selected=_bool(0)
#@gui:Palette Color 129=color(251,234,163)
#@gui:â  â  â  âDelete Color 129â  â  â  â  =button(0)
#@gui:Color 129 Selected=_bool(0)
#@gui:Palette Color 130=color(232,203,130)
#@gui:â  â  â  âDelete Color 130â  â  â  â  =button(0)
#@gui:Color 130 Selected=_bool(0)
#@gui:Palette Color 131=color(204,169,110)
#@gui:â  â  â  âDelete Color 131â  â  â  â  =button(0)
#@gui:Color 131 Selected=_bool(0)
#@gui:Palette Color 132=color(178,144,98)
#@gui:â  â  â  âDelete Color 132â  â  â  â  =button(0)
#@gui:Color 132 Selected=_bool(0)
#@gui:Palette Color 133=color(153,121,81)
#@gui:â  â  â  âDelete Color 133â  â  â  â  =button(0)
#@gui:Color 133 Selected=_bool(0)
#@gui:Palette Color 134=color(126,97,68)
#@gui:â  â  â  âDelete Color 134â  â  â  â  =button(0)
#@gui:Color 134 Selected=_bool(0)
#@gui:Palette Color 135=color(97,74,60)
#@gui:â  â  â  âDelete Color 135â  â  â  â  =button(0)
#@gui:Color 135 Selected=_bool(0)
#@gui:Palette Color 136=color(69,49,37)
#@gui:â  â  â  âDelete Color 136â  â  â  â  =button(0)
#@gui:Color 136 Selected=_bool(0)
#@gui:Palette Color 137=color(0,222,218)
#@gui:â  â  â  âDelete Color 137â  â  â  â  =button(0)
#@gui:Color 137 Selected=_bool(0)
#@gui:Palette Color 138=color(0,191,163)
#@gui:â  â  â  âDelete Color 138â  â  â  â  =button(0)
#@gui:Color 138 Selected=_bool(0)
#@gui:Palette Color 139=color(0,160,135)
#@gui:â  â  â  âDelete Color 139â  â  â  â  =button(0)
#@gui:Color 139 Selected=_bool(0)
#@gui:Palette Color 140=color(0,130,121)
#@gui:â  â  â  âDelete Color 140â  â  â  â  =button(0)
#@gui:Color 140 Selected=_bool(0)
#@gui:Palette Color 141=color(0,107,109)
#@gui:â  â  â  âDelete Color 141â  â  â  â  =button(0)
#@gui:Color 141 Selected=_bool(0)
#@gui:Palette Color 142=color(0,81,98)
#@gui:â  â  â  âDelete Color 142â  â  â  â  =button(0)
#@gui:Color 142 Selected=_bool(0)
#@gui:Palette Color 143=color(0,64,81)
#@gui:â  â  â  âDelete Color 143â  â  â  â  =button(0)
#@gui:Color 143 Selected=_bool(0)
#@gui:Palette Color 144=color(0,46,73)
#@gui:â  â  â  âDelete Color 144â  â  â  â  =button(0)
#@gui:Color 144 Selected=_bool(0)
#@gui:Palette Color 145=color(248,198,218)
#@gui:â  â  â  âDelete Color 145â  â  â  â  =button(0)
#@gui:Color 145 Selected=_bool(0)
#@gui:Palette Color 146=color(219,153,191)
#@gui:â  â  â  âDelete Color 146â  â  â  â  =button(0)
#@gui:Color 146 Selected=_bool(0)
#@gui:Palette Color 147=color(193,120,170)
#@gui:â  â  â  âDelete Color 147â  â  â  â  =button(0)
#@gui:Color 147 Selected=_bool(0)
#@gui:Palette Color 148=color(185,109,145)
#@gui:â  â  â  âDelete Color 148â  â  â  â  =button(0)
#@gui:Color 148 Selected=_bool(0)
#@gui:Palette Color 149=color(151,84,117)
#@gui:â  â  â  âDelete Color 149â  â  â  â  =button(0)
#@gui:Color 149 Selected=_bool(0)
#@gui:Palette Color 150=color(102,54,89)
#@gui:â  â  â  âDelete Color 150â  â  â  â  =button(0)
#@gui:Color 150 Selected=_bool(0)
#@gui:Palette Color 151=color(73,40,61)
#@gui:â  â  â  âDelete Color 151â  â  â  â  =button(0)
#@gui:Color 151 Selected=_bool(0)
#@gui:Palette Color 152=color(46,16,38)
#@gui:â  â  â  âDelete Color 152â  â  â  â  =button(0)
#@gui:Color 152 Selected=_bool(0)
#@gui:Palette Color 153=color(221,191,154)
#@gui:â  â  â  âDelete Color 153â  â  â  â  =button(0)
#@gui:Color 153 Selected=_bool(0)
#@gui:Palette Color 154=color(192,165,136)
#@gui:â  â  â  âDelete Color 154â  â  â  â  =button(0)
#@gui:Color 154 Selected=_bool(0)
#@gui:Palette Color 155=color(158,138,110)
#@gui:â  â  â  âDelete Color 155â  â  â  â  =button(0)
#@gui:Color 155 Selected=_bool(0)
#@gui:Palette Color 156=color(126,108,84)
#@gui:â  â  â  âDelete Color 156â  â  â  â  =button(0)
#@gui:Color 156 Selected=_bool(0)
#@gui:Palette Color 157=color(114,90,81)
#@gui:â  â  â  âDelete Color 157â  â  â  â  =button(0)
#@gui:Color 157 Selected=_bool(0)
#@gui:Palette Color 158=color(94,70,70)
#@gui:â  â  â  âDelete Color 158â  â  â  â  =button(0)
#@gui:Color 158 Selected=_bool(0)
#@gui:Palette Color 159=color(74,53,60)
#@gui:â  â  â  âDelete Color 159â  â  â  â  =button(0)
#@gui:Color 159 Selected=_bool(0)
#@gui:Palette Color 160=color(49,34,42)
#@gui:â  â  â  âDelete Color 160â  â  â  â  =button(0)
#@gui:Color 160 Selected=_bool(0)
#@gui:Palette Color 161=color(255,250,171)
#@gui:â  â  â  âDelete Color 161â  â  â  â  =button(0)
#@gui:Color 161 Selected=_bool(0)
#@gui:Palette Color 162=color(236,197,129)
#@gui:â  â  â  âDelete Color 162â  â  â  â  =button(0)
#@gui:Color 162 Selected=_bool(0)
#@gui:Palette Color 163=color(216,159,117)
#@gui:â  â  â  âDelete Color 163â  â  â  â  =button(0)
#@gui:Color 163 Selected=_bool(0)
#@gui:Palette Color 164=color(199,130,108)
#@gui:â  â  â  âDelete Color 164â  â  â  â  =button(0)
#@gui:Color 164 Selected=_bool(0)
#@gui:Palette Color 165=color(174,107,96)
#@gui:â  â  â  âDelete Color 165â  â  â  â  =button(0)
#@gui:Color 165 Selected=_bool(0)
#@gui:Palette Color 166=color(138,82,88)
#@gui:â  â  â  âDelete Color 166â  â  â  â  =button(0)
#@gui:Color 166 Selected=_bool(0)
#@gui:Palette Color 167=color(90,60,69)
#@gui:â  â  â  âDelete Color 167â  â  â  â  =button(0)
#@gui:Color 167 Selected=_bool(0)
#@gui:Palette Color 168=color(59,48,60)
#@gui:â  â  â  âDelete Color 168â  â  â  â  =button(0)
#@gui:Color 168 Selected=_bool(0)
#@gui:Palette Color 169=color(235,240,246)
#@gui:â  â  â  âDelete Color 169â  â  â  â  =button(0)
#@gui:Color 169 Selected=_bool(0)
#@gui:Palette Color 170=color(186,199,219)
#@gui:â  â  â  âDelete Color 170â  â  â  â  =button(0)
#@gui:Color 170 Selected=_bool(0)
#@gui:Palette Color 171=color(171,174,190)
#@gui:â  â  â  âDelete Color 171â  â  â  â  =button(0)
#@gui:Color 171 Selected=_bool(0)
#@gui:Palette Color 172=color(132,135,149)
#@gui:â  â  â  âDelete Color 172â  â  â  â  =button(0)
#@gui:Color 172 Selected=_bool(0)
#@gui:Palette Color 173=color(115,115,127)
#@gui:â  â  â  âDelete Color 173â  â  â  â  =button(0)
#@gui:Color 173 Selected=_bool(0)
#@gui:Palette Color 174=color(91,92,105)
#@gui:â  â  â  âDelete Color 174â  â  â  â  =button(0)
#@gui:Color 174 Selected=_bool(0)
#@gui:Palette Color 175=color(72,71,77)
#@gui:â  â  â  âDelete Color 175â  â  â  â  =button(0)
#@gui:Color 175 Selected=_bool(0)
#@gui:Palette Color 176=color(45,49,54)
#@gui:â  â  â  âDelete Color 176â  â  â  â  =button(0)
#@gui:Color 176 Selected=_bool(0)
#@gui:Palette Color 177=color(255,219,255)
#@gui:â  â  â  âDelete Color 177â  â  â  â  =button(0)
#@gui:Color 177 Selected=_bool(0)
#@gui:Palette Color 178=color(255,187,199)
#@gui:â  â  â  âDelete Color 178â  â  â  â  =button(0)
#@gui:Color 178 Selected=_bool(0)
#@gui:Palette Color 179=color(255,155,168)
#@gui:â  â  â  âDelete Color 179â  â  â  â  =button(0)
#@gui:Color 179 Selected=_bool(0)
#@gui:Palette Color 180=color(255,118,118)
#@gui:â  â  â  âDelete Color 180â  â  â  â  =button(0)
#@gui:Color 180 Selected=_bool(0)
#@gui:Palette Color 181=color(228,92,95)
#@gui:â  â  â  âDelete Color 181â  â  â  â  =button(0)
#@gui:Color 181 Selected=_bool(0)
#@gui:Palette Color 182=color(182,60,53)
#@gui:â  â  â  âDelete Color 182â  â  â  â  =button(0)
#@gui:Color 182 Selected=_bool(0)
#@gui:Palette Color 183=color(130,33,29)
#@gui:â  â  â  âDelete Color 183â  â  â  â  =button(0)
#@gui:Color 183 Selected=_bool(0)
#@gui:Palette Color 184=color(94,7,17)
#@gui:â  â  â  âDelete Color 184â  â  â  â  =button(0)
#@gui:Color 184 Selected=_bool(0)
#@gui:Palette Color 185=color(145,218,161)
#@gui:â  â  â  âDelete Color 185â  â  â  â  =button(0)
#@gui:Color 185 Selected=_bool(0)
#@gui:Palette Color 186=color(85,182,125)
#@gui:â  â  â  âDelete Color 186â  â  â  â  =button(0)
#@gui:Color 186 Selected=_bool(0)
#@gui:Palette Color 187=color(73,137,96)
#@gui:â  â  â  âDelete Color 187â  â  â  â  =button(0)
#@gui:Color 187 Selected=_bool(0)
#@gui:Palette Color 188=color(65,116,85)
#@gui:â  â  â  âDelete Color 188â  â  â  â  =button(0)
#@gui:Color 188 Selected=_bool(0)
#@gui:Palette Color 189=color(50,92,64)
#@gui:â  â  â  âDelete Color 189â  â  â  â  =button(0)
#@gui:Color 189 Selected=_bool(0)
#@gui:Palette Color 190=color(56,81,64)
#@gui:â  â  â  âDelete Color 190â  â  â  â  =button(0)
#@gui:Color 190 Selected=_bool(0)
#@gui:Palette Color 191=color(47,63,56)
#@gui:â  â  â  âDelete Color 191â  â  â  â  =button(0)
#@gui:Color 191 Selected=_bool(0)
#@gui:Palette Color 192=color(26,51,44)
#@gui:â  â  â  âDelete Color 192â  â  â  â  =button(0)
#@gui:Color 192 Selected=_bool(0)
#@gui:Palette Color 193=color(116,245,253)
#@gui:â  â  â  âDelete Color 193â  â  â  â  =button(0)
#@gui:Color 193 Selected=_bool(0)
#@gui:Palette Color 194=color(82,210,255)
#@gui:â  â  â  âDelete Color 194â  â  â  â  =button(0)
#@gui:Color 194 Selected=_bool(0)
#@gui:Palette Color 195=color(65,178,227)
#@gui:â  â  â  âDelete Color 195â  â  â  â  =button(0)
#@gui:Color 195 Selected=_bool(0)
#@gui:Palette Color 196=color(49,142,184)
#@gui:â  â  â  âDelete Color 196â  â  â  â  =button(0)
#@gui:Color 196 Selected=_bool(0)
#@gui:Palette Color 197=color(54,107,138)
#@gui:â  â  â  âDelete Color 197â  â  â  â  =button(0)
#@gui:Color 197 Selected=_bool(0)
#@gui:Palette Color 198=color(37,70,107)
#@gui:â  â  â  âDelete Color 198â  â  â  â  =button(0)
#@gui:Color 198 Selected=_bool(0)
#@gui:Palette Color 199=color(35,50,77)
#@gui:â  â  â  âDelete Color 199â  â  â  â  =button(0)
#@gui:Color 199 Selected=_bool(0)
#@gui:Palette Color 200=color(24,31,47)
#@gui:â  â  â  âDelete Color 200â  â  â  â  =button(0)
#@gui:Color 200 Selected=_bool(0)
#@gui:Palette Color 201=color(166,204,52)
#@gui:â  â  â  âDelete Color 201â  â  â  â  =button(0)
#@gui:Color 201 Selected=_bool(0)
#@gui:Palette Color 202=color(125,164,45)
#@gui:â  â  â  âDelete Color 202â  â  â  â  =button(0)
#@gui:Color 202 Selected=_bool(0)
#@gui:Palette Color 203=color(81,136,34)
#@gui:â  â  â  âDelete Color 203â  â  â  â  =button(0)
#@gui:Color 203 Selected=_bool(0)
#@gui:Palette Color 204=color(47,105,12)
#@gui:â  â  â  âDelete Color 204â  â  â  â  =button(0)
#@gui:Color 204 Selected=_bool(0)
#@gui:Palette Color 205=color(34,89,24)
#@gui:â  â  â  âDelete Color 205â  â  â  â  =button(0)
#@gui:Color 205 Selected=_bool(0)
#@gui:Palette Color 206=color(23,74,27)
#@gui:â  â  â  âDelete Color 206â  â  â  â  =button(0)
#@gui:Color 206 Selected=_bool(0)
#@gui:Palette Color 207=color(0,50,33)
#@gui:â  â  â  âDelete Color 207â  â  â  â  =button(0)
#@gui:Color 207 Selected=_bool(0)
#@gui:Palette Color 208=color(0,34,25)
#@gui:â  â  â  âDelete Color 208â  â  â  â  =button(0)
#@gui:Color 208 Selected=_bool(0)
#@gui:Palette Color 209=color(198,236,255)
#@gui:â  â  â  âDelete Color 209â  â  â  â  =button(0)
#@gui:Color 209 Selected=_bool(0)
#@gui:Palette Color 210=color(199,214,255)
#@gui:â  â  â  âDelete Color 210â  â  â  â  =button(0)
#@gui:Color 210 Selected=_bool(0)
#@gui:Palette Color 211=color(150,178,217)
#@gui:â  â  â  âDelete Color 211â  â  â  â  =button(0)
#@gui:Color 211 Selected=_bool(0)
#@gui:Palette Color 212=color(134,144,178)
#@gui:â  â  â  âDelete Color 212â  â  â  â  =button(0)
#@gui:Color 212 Selected=_bool(0)
#@gui:Palette Color 213=color(122,119,153)
#@gui:â  â  â  âDelete Color 213â  â  â  â  =button(0)
#@gui:Color 213 Selected=_bool(0)
#@gui:Palette Color 214=color(97,95,132)
#@gui:â  â  â  âDelete Color 214â  â  â  â  =button(0)
#@gui:Color 214 Selected=_bool(0)
#@gui:Palette Color 215=color(58,69,104)
#@gui:â  â  â  âDelete Color 215â  â  â  â  =button(0)
#@gui:Color 215 Selected=_bool(0)
#@gui:Palette Color 216=color(40,43,74)
#@gui:â  â  â  âDelete Color 216â  â  â  â  =button(0)
#@gui:Color 216 Selected=_bool(0)
#@gui:Palette Color 217=color(255,233,73)
#@gui:â  â  â  âDelete Color 217â  â  â  â  =button(0)
#@gui:Color 217 Selected=_bool(0)
#@gui:Palette Color 218=color(255,188,78)
#@gui:â  â  â  âDelete Color 218â  â  â  â  =button(0)
#@gui:Color 218 Selected=_bool(0)
#@gui:Palette Color 219=color(249,155,78)
#@gui:â  â  â  âDelete Color 219â  â  â  â  =button(0)
#@gui:Color 219 Selected=_bool(0)
#@gui:Palette Color 220=color(227,120,64)
#@gui:â  â  â  âDelete Color 220â  â  â  â  =button(0)
#@gui:Color 220 Selected=_bool(0)
#@gui:Palette Color 221=color(205,94,70)
#@gui:â  â  â  âDelete Color 221â  â  â  â  =button(0)
#@gui:Color 221 Selected=_bool(0)
#@gui:Palette Color 222=color(182,77,70)
#@gui:â  â  â  âDelete Color 222â  â  â  â  =button(0)
#@gui:Color 222 Selected=_bool(0)
#@gui:Palette Color 223=color(148,54,58)
#@gui:â  â  â  âDelete Color 223â  â  â  â  =button(0)
#@gui:Color 223 Selected=_bool(0)
#@gui:Palette Color 224=color(102,43,41)
#@gui:â  â  â  âDelete Color 224â  â  â  â  =button(0)
#@gui:Color 224 Selected=_bool(0)
#@gui:Palette Color 225=color(136,214,255)
#@gui:â  â  â  âDelete Color 225â  â  â  â  =button(0)
#@gui:Color 225 Selected=_bool(0)
#@gui:Palette Color 226=color(36,174,214)
#@gui:â  â  â  âDelete Color 226â  â  â  â  =button(0)
#@gui:Color 226 Selected=_bool(0)
#@gui:Palette Color 227=color(50,140,167)
#@gui:â  â  â  âDelete Color 227â  â  â  â  =button(0)
#@gui:Color 227 Selected=_bool(0)
#@gui:Palette Color 228=color(0,111,137)
#@gui:â  â  â  âDelete Color 228â  â  â  â  =button(0)
#@gui:Color 228 Selected=_bool(0)
#@gui:Palette Color 229=color(11,102,127)
#@gui:â  â  â  âDelete Color 229â  â  â  â  =button(0)
#@gui:Color 229 Selected=_bool(0)
#@gui:Palette Color 230=color(0,77,94)
#@gui:â  â  â  âDelete Color 230â  â  â  â  =button(0)
#@gui:Color 230 Selected=_bool(0)
#@gui:Palette Color 231=color(0,56,80)
#@gui:â  â  â  âDelete Color 231â  â  â  â  =button(0)
#@gui:Color 231 Selected=_bool(0)
#@gui:Palette Color 232=color(0,39,53)
#@gui:â  â  â  âDelete Color 232â  â  â  â  =button(0)
#@gui:Color 232 Selected=_bool(0)
#@gui:Palette Color 233=color(255,206,127)
#@gui:â  â  â  âDelete Color 233â  â  â  â  =button(0)
#@gui:Color 233 Selected=_bool(0)
#@gui:Palette Color 234=color(251,170,132)
#@gui:â  â  â  âDelete Color 234â  â  â  â  =button(0)
#@gui:Color 234 Selected=_bool(0)
#@gui:Palette Color 235=color(213,141,107)
#@gui:â  â  â  âDelete Color 235â  â  â  â  =button(0)
#@gui:Color 235 Selected=_bool(0)
#@gui:Palette Color 236=color(173,110,81)
#@gui:â  â  â  âDelete Color 236â  â  â  â  =button(0)
#@gui:Color 236 Selected=_bool(0)
#@gui:Palette Color 237=color(154,98,76)
#@gui:â  â  â  âDelete Color 237â  â  â  â  =button(0)
#@gui:Color 237 Selected=_bool(0)
#@gui:Palette Color 238=color(136,80,65)
#@gui:â  â  â  âDelete Color 238â  â  â  â  =button(0)
#@gui:Color 238 Selected=_bool(0)
#@gui:Palette Color 239=color(115,61,59)
#@gui:â  â  â  âDelete Color 239â  â  â  â  =button(0)
#@gui:Color 239 Selected=_bool(0)
#@gui:Palette Color 240=color(88,49,38)
#@gui:â  â  â  âDelete Color 240â  â  â  â  =button(0)
#@gui:Color 240 Selected=_bool(0)
#@gui:Palette Color 241=color(255,243,214)
#@gui:â  â  â  âDelete Color 241â  â  â  â  =button(0)
#@gui:Color 241 Selected=_bool(0)
#@gui:Palette Color 242=color(234,219,201)
#@gui:â  â  â  âDelete Color 242â  â  â  â  =button(0)
#@gui:Color 242 Selected=_bool(0)
#@gui:Palette Color 243=color(204,195,177)
#@gui:â  â  â  âDelete Color 243â  â  â  â  =button(0)
#@gui:Color 243 Selected=_bool(0)
#@gui:Palette Color 244=color(187,175,164)
#@gui:â  â  â  âDelete Color 244â  â  â  â  =button(0)
#@gui:Color 244 Selected=_bool(0)
#@gui:Palette Color 245=color(174,161,137)
#@gui:â  â  â  âDelete Color 245â  â  â  â  =button(0)
#@gui:Color 245 Selected=_bool(0)
#@gui:Palette Color 246=color(158,140,121)
#@gui:â  â  â  âDelete Color 246â  â  â  â  =button(0)
#@gui:Color 246 Selected=_bool(0)
#@gui:Palette Color 247=color(133,117,101)
#@gui:â  â  â  âDelete Color 247â  â  â  â  =button(0)
#@gui:Color 247 Selected=_bool(0)
#@gui:Palette Color 248=color(98,93,84)
#@gui:â  â  â  âDelete Color 248â  â  â  â  =button(0)
#@gui:Color 248 Selected=_bool(0)
#@gui:Palette Color 249=color(245,247,250)
#@gui:â  â  â  âDelete Color 249â  â  â  â  =button(0)
#@gui:Color 249 Selected=_bool(0)
#@gui:Palette Color 250=color(205,210,218)
#@gui:â  â  â  âDelete Color 250â  â  â  â  =button(0)
#@gui:Color 250 Selected=_bool(0)
#@gui:Palette Color 251=color(166,174,186)
#@gui:â  â  â  âDelete Color 251â  â  â  â  =button(0)
#@gui:Color 251 Selected=_bool(0)
#@gui:Palette Color 252=color(130,139,152)
#@gui:â  â  â  âDelete Color 252â  â  â  â  =button(0)
#@gui:Color 252 Selected=_bool(0)
#@gui:Palette Color 253=color(98,104,113)
#@gui:â  â  â  âDelete Color 253â  â  â  â  =button(0)
#@gui:Color 253 Selected=_bool(0)
#@gui:Palette Color 254=color(67,69,73)
#@gui:â  â  â  âDelete Color 254â  â  â  â  =button(0)
#@gui:Color 254 Selected=_bool(0)
#@gui:Palette Color 255=color(34,35,35)
#@gui:â  â  â  âDelete Color 255â  â  â  â  =button(0)
#@gui:Color 255 Selected=_bool(0)
#@gui:Palette Color 256=color(0,0,0)
#@gui:â  â  â  âDelete Color 256â  â  â  â  =button(0)
#@gui:Color 256 Selected=_bool(0)
#@gui:_=separator()
#@gui:â  â  â  Add Palette Colorâ  â â  ââ=button(0)
#@gui:Delete All Selected Palette=button(0)
#@gui:_=separator(),_=note("<b>RGB Output</b>")
#@gui:Pixel Width=int(1,1,8)
#@gui:Pixel Height=int(1,1,8)
#@gui:Windows Width=int(1,1,128)
#@gui:Use Image Width as Windows Width=bool(0)
#@gui:Windows Height=int(1,1,128)
#@gui:Use Image Height as Windows Height=bool(0)
#@gui:Threshold Map Iteration=int(3,1,6)
#@gui:_=separator(),_=note("<b>Alpha Output</b>")
#@gui:Enable Alpha Processing=bool(0)
#@gui:Number of Alpha=int(2,2,256)
#@gui:Alpha Dithering (%)=float(50,0,100)
#@gui:Alpha Mode=choice(0,"Indexed","Windows-Based Indexing","Ordered")
#@gui:Alpha Mode=choice(0,"Indexed","Ordered")
#@gui:Alpha Restriction=int(0,0,128)
#@gui:Alpha Threshold Map Iteration=int(3,1,6)
#@gui:_=note("<small>If this section is empty, it is because there is no alpha on any images.</small>")
#@gui:_=separator(),_=note("<b>CLI Command</b>")
#@gui:CLI version=_text("Here is where you copy command to command line interface.")
#@gui:Import Palette File=file()_0
#@gui:Imported=bool(0)_0
#@gui:_=note("<small>Note: Here is where you copy command to command line interface. </small>")
#@gui:_=separator(),_=note("<b>Post-Processing</b>")
#@gui:Crop to Original Dimension=bool(1)
#@gui:Message Out=text("Initialized GUI Filter!")
#@gui:Status=int(0,0,3)_0
#@gui:Color Status=color(255,255,255)
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui:Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_transfer_color_reduced:
skip ${20=""},${1326=""}

if $1330==1 error inv_inp fi
if $1330==2 error import_mode_err fi

use_pal={$1?!$5:1}

img_cont_alp={sum(1-expr('s#x',$!)&1)}

if $img_cont_alp
  img_cont_alp=0

  foreach {
    if s&1 continue fi

    sh. {s#-1-1}

    if iv#-1 rm. img_cont_alp=1 break
    else rm.
    fi
  }
fi

if $1318&&$img_cont_alp
  if $1 alpha_args=$1319,{$1320/100},$1322
  else  alpha_args=$1319,{$1320/100},$1321,$1323,$1324
  fi
else
  alpha_args=0
fi

if $use_pal
  if $6==3
    (${29-1308})
    split. x,-5
    a[-256--1] y
    permute. yzcx
    channels. 0,2
    crop. 0,{$22-1}
    store. palette
  fi
else
  if $7
    if $17 tcrc_arg={2^$13}
    else tcrc_arg={2^$14}:{2^$15}:{2^$16}
    fi
  else
    if $12 tcrc_arg=$8
    else tcrc_arg=$9:$10:$11
    fi
  fi
fi

fx_rep_tcrc_windows_width,fx_rep_tcrc_window_height=${arg0\ $1314,$1313,w},${arg0\ $1316,$1315,h}

if $3&&$4
 fx_rep_tcrc_dither=$4%${arg1\ $3,dh,dv,lh,lv,cd,cl}
else
 fx_rep_tcrc_dither={$2/100}
fi

foreach {
  od={[w-1,h-1]}

  if $use_pal

    if $6==3

      $palette

      if $1 rep_transfer_color_reduced.. :[-1],$fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$alpha_args
      else rep_transfer_color_reduced.. [-1],$fx_rep_tcrc_dither,$1311,$1312,$fx_rep_tcrc_windows_width,$fx_rep_tcrc_window_height,$25,$24,$alpha_args
      fi

    elif $6==1

      if s>2 sh[0] 0,2
      else sh[0] 0
      fi

      +colormap. $23,0 rm..

      if $1 rep_transfer_color_reduced.. :[-1],$fx_rep_tcrc_dither,$1311,$1312,$1317,0,$_alpha_args
      else rep_transfer_color_reduced.. [-1],$fx_rep_tcrc_dither,$1311,$1312,$fx_rep_tcrc_windows_width,$fx_rep_tcrc_window_height,$25,0,$alpha_args
      fi

    else

      +pal $18

      if $1 rep_transfer_color_reduced.. :[-1],$fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$alpha_args
      else rep_transfer_color_reduced.. [-1],$fx_rep_tcrc_dither,$1311,$1312,$fx_rep_tcrc_windows_width,$fx_rep_tcrc_window_height,$25,$24,$alpha_args
      fi

    fi
    rm.

  else rep_transfer_color_reduced $tcrc_arg,$fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$alpha_args
  fi

  if $1330==3 crop 0,0,$od fi
}
fx_rep_transfer_color_reduced_preview:
skip ${20=""},${1326=""}

original_width,original_height={[w#0,h#0]}

imgs,dec_imgs,use_pal,imported={$!},{$!-1},{$1?!$5:1},$1327
use_custom_pal,num_of_colors,pal_method={$use_pal&&($6>1?1:!$6?$19)},$22,$6
text_box="$1325"

img_cont_alp={sum(1-expr('s#x',$!)&1)}

if $img_cont_alp
  img_cont_alp=0

  foreach {
    if s&1 continue fi

    sh. {s#-1-1}

    if iv#-1 rm. img_cont_alp=1 break
    else rm.
    fi
  }
fi

if $pal_method!=1
  z $_preview_x0,$_preview_y0,$_preview_x1,$_preview_y1
  r ${-gui_preview_wh},1,100%
fi

if $1309 num_of_colors+=1 fi

if $1314&&$1316 tcrc_windows_width_check,tcrc_windows_height_check,_fx_rep_tcrc_windows_width,_fx_rep_tcrc_window_height=0,0,$1313,$1315
else            tcrc_windows_width_check,tcrc_windows_height_check,_fx_rep_tcrc_windows_width,_fx_rep_tcrc_window_height=$1314,$1316,${arg0\ $1314,$1313,w},${arg0\ $1316,$1315,h}
fi

if $1318&&$img_cont_alp
  if $1 _alpha_args=$1319,{$1320/100},$1322
  else  _alpha_args=$1319,{$1320/100},$1321,$1323,$1324
  fi
else
  _alpha_args=0
fi

if $3&&$4
 _fx_rep_tcrc_dither=$4%${arg1\ $3,dh,dv,lh,lv,cd,cl}
else
 _fx_rep_tcrc_dither={$2/100}
fi

if narg($_persistent)&&!$use_custom_pal

  ($_persistent)

  repeat 256 {
    q={$>*3}
    color_$>:=crop(#-1,$q,3)
  }

  rm.

elif !$use_custom_pal

  (${29-1306})

  repeat 256 {
    q={$>*5}
    color_$>:=crop(#-1,$q,3)
  }

  _persistent=$color_0,$color_1,$color_2,$color_3,$color_4,$color_5,$color_6,$color_7,$color_8,$color_9,$color_10,$color_11,$color_12,$color_13,$color_14,$color_15,$color_16,$color_17,$color_18,$color_19,$color_20,$color_21,$color_22,$color_23,$color_24,$color_25,$color_26,$color_27,$color_28,$color_29,$color_30,$color_31,$color_32,$color_33,$color_34,$color_35,$color_36,$color_37,$color_38,$color_39,$color_40,$color_41,$color_42,$color_43,$color_44,$color_45,$color_46,$color_47,$color_48,$color_49,$color_50,$color_51,$color_52,$color_53,$color_54,$color_55,$color_56,$color_57,$color_58,$color_59,$color_60,$color_61,$color_62,$color_63,$color_64,$color_65,$color_66,$color_67,$color_68,$color_69,$color_70,$color_71,$color_72,$color_73,$color_74,$color_75,$color_76,$color_77,$color_78,$color_79,$color_80,$color_81,$color_82,$color_83,$color_84,$color_85,$color_86,$color_87,$color_88,$color_89,$color_90,$color_91,$color_92,$color_93,$color_94,$color_95,$color_96,$color_97,$color_98,$color_99,$color_100,$color_101,$color_102,$color_103,$color_104,$color_105,$color_106,$color_107,$color_108,$color_109,$color_110,$color_111,$color_112,$color_113,$color_114,$color_115,$color_116,$color_117,$color_118,$color_119,$color_120,$color_121,$color_122,$color_123,$color_124,$color_125,$color_126,$color_127,$color_128,$color_129,$color_130,$color_131,$color_132,$color_133,$color_134,$color_135,$color_136,$color_137,$color_138,$color_139,$color_140,$color_141,$color_142,$color_143,$color_144,$color_145,$color_146,$color_147,$color_148,$color_149,$color_150,$color_151,$color_152,$color_153,$color_154,$color_155,$color_156,$color_157,$color_158,$color_159,$color_160,$color_161,$color_162,$color_163,$color_164,$color_165,$color_166,$color_167,$color_168,$color_169,$color_170,$color_171,$color_172,$color_173,$color_174,$color_175,$color_176,$color_177,$color_178,$color_179,$color_180,$color_181,$color_182,$color_183,$color_184,$color_185,$color_186,$color_187,$color_188,$color_189,$color_190,$color_191,$color_192,$color_193,$color_194,$color_195,$color_196,$color_197,$color_198,$color_199,$color_200,$color_201,$color_202,$color_203,$color_204,$color_205,$color_206,$color_207,$color_208,$color_209,$color_210,$color_211,$color_212,$color_213,$color_214,$color_215,$color_216,$color_217,$color_218,$color_219,$color_220,$color_221,$color_222,$color_223,$color_224,$color_225,$color_226,$color_227,$color_228,$color_229,$color_230,$color_231,$color_232,$color_233,$color_234,$color_235,$color_236,$color_237,$color_238,$color_239,$color_240,$color_241,$color_242,$color_243,$color_244,$color_245,$color_246,$color_247,$color_248,$color_249,$color_250,$color_251,$color_252,$color_253,$color_254,$color_255

  rm.

fi

if $use_pal

  if $use_custom_pal||($6==2?('"$1326"'!='"$20"'))
    (${29-1308})
    split. x,-5
    a[-256--1] y
    permute. yzcx
  fi

  if $6==3

    if $27

      sh. 4
      num_of_colors-={is#-1}
      t_sub_col={is#-1}

      if $t_sub_col
        if $num_of_colors
          area_fg. 0
          $num_of_colors,1,1,3,"I(#-2,x+i(#-1,x));"
          rm..
        else
          rm.
          num_of_colors=2
          2,1,1,3,vector(#3,x);
        fi
      else
        rm.
        +crop. 0,0,0,0,{$num_of_colors-1},0,0,2
      fi

    else

      sh. 3

      max_val:=iM
      pos:=xM
      rm.

      if $max_val
        if $pos==($num_of_colors-1)
          +crop. 0,0,0,0,{$num_of_colors-2},0,0,2
        elif !$pos
          +crop. 1,0,0,0,{$num_of_colors-1},0,0,2
        else
          +crop. 0,0,0,0,{$pos-1},0,0,2
          +crop.. {$pos+1},0,0,0,{$num_of_colors-1},0,0,2
          a[-2,-1] x
        fi
        num_of_colors-=1
      else
        +crop. 0,0,0,0,{$num_of_colors-1},0,0,2
      fi

    fi

    image.. .

    store. _palette

    channels. 0,2

    repeat 256 { color_$>={I(#-1,$>)} }

    rm.

    if $1
      gui_split_preview "$_palette rep_transfer_color_reduced[^-1] :[-1],$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args rm.",${-3--1}
      text_out="rep_transfer_color_reduced[^-1] :[-1]",$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args
    else
      gui_split_preview "$_palette rep_transfer_color_reduced[^-1] [-1],$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,$24,$_alpha_args rm.",${-3--1}
      text_out="rep_transfer_color_reduced[^-1] [-1]",$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,$24,$_alpha_args
    fi

  elif $6==2

    apply_preview_image=0

    if narg($20)?(('$1326'!='$20')||($imported?$21))

      apply_preview_image,imported=1

      num_of_images={$!}

      i $20

      if $!>($num_of_images+1) error excess_imgs fi

      if whd#-1<2 error inv_pal_dim fi

      if w#-1>1&&(h#-1>1||d#-1>1) colormap. 0
      elif w#-1==1&&h#-1>1 rotate. 90
      fi

      image.. .

      num_of_colors={w#-1}

      store. _palette

      channels. 0,2

      repeat 256 { color_$>={I(#-1,$>)} }

      pal_method=3

    fi

    k[0-$dec_imgs]

    if $apply_preview_image
      if $1
        gui_split_preview "$_palette rep_transfer_color_reduced[^-1] :[-1],$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args rm.",${-3--1}
        text_out="rep_transfer_color_reduced[^-1] :[-1]",$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args
      else
        gui_split_preview "$_palette rep_transfer_color_reduced[^-1] [-1],$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,$24,$_alpha_args rm.",${-3--1}
        text_out="rep_transfer_color_reduced[^-1] [-1]",$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,$24,$_alpha_args
      fi
    else
      foreach {
        sh. 0,2
        100%,100%,100%,4 drgba. blend[-2] [-1],normal,.5 rm.
        text_outline. "Awaiting\n palette",.5~,.5~,10%
        rm.
      }
    fi

  elif $6==1

    if s>2 sh[0] 0,2
    else sh[0] 0
    fi

    +colormap. $23,0
    store. _palette
    rm.

    z $_preview_x0,$_preview_y0,$_preview_x1,$_preview_y1
    r ${-gui_preview_wh},1,100%

    if $1
      gui_split_preview "$_palette rep_transfer_color_reduced[^-1] :[-1],$_fx_rep_tcrc_dither,$1311,$1312,$1317,0,$_alpha_args rm.",${-3--1}
      text_box="+colormap $23 rep_transfer_color_reduced[^-1] :[-1]",$_fx_rep_tcrc_dither,$1311,$1312,$1317,0,$_alpha_args
    else
      gui_split_preview "$_palette rep_transfer_color_reduced[^-1] [-1],$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,0,$_alpha_args rm.",${-3--1}
      text_box="+colormap $23 $_palette rep_transfer_color_reduced[^-1] [-1]",$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,0,$_alpha_args
    fi

  else

    +pal $18

    if $19
      num_of_colors:=whd#-1
      channels.. 0,2
      image.. .
      repeat 256 { color_$>={I(#-2,$>)} }
      rm..
      pal_method=3
    fi

    store. _palette

    if $1
      gui_split_preview "$_palette rep_transfer_color_reduced[^-1] :[-1],$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args rm.",${-3--1}
      text_box="rep_transfer_color_reduced[^-1] :[-1]",$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args
    else
      gui_split_preview "$_palette rep_transfer_color_reduced[^-1] [-1],$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,$24,$_alpha_args rm.",${-3--1}
      text_box="rep_transfer_color_reduced[^-1] [-1]",$_fx_rep_tcrc_dither,$1311,$1312,$_fx_rep_tcrc_windows_width,$_fx_rep_tcrc_window_height,$25,$24,$_alpha_args
    fi

  fi

else

  if $7
    if $17 _tcrc_arg={2^$13}
    else _tcrc_arg={2^$14}:{2^$15}:{2^$16}
    fi
  else
    if $12 _tcrc_arg=$8
    else _tcrc_arg=$9:$10:$11
    fi
  fi

  gui_split_preview "rep_transfer_color_reduced $_tcrc_arg,$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args",${-3--1}
  text_box="rep_transfer_color_reduced "$_tcrc_arg,$_fx_rep_tcrc_dither,$1311,$1312,$1317,$24,$_alpha_args
fi

out_status=4
message_out=""
status_color=${1331-1333}

if $pal_method!=2
  if $1328
    pixel_width,pixel_height=${1311-1312}
    pixel_ratio_gcd={gcd($pixel_width,$pixel_height)}
    if $pixel_ratio_gcd>1 pixel_width,pixel_height/=$pixel_ratio_gcd fi
    if min($pixel_width,$pixel_height)>1 out_status=1
    else
      f_w={$original_width/$pixel_width}
      f_h={$original_height/$pixel_height}
      if ($f_w!=int($f_w))||($f_h!=int($f_h)) out_status=3 fi
    fi
  fi
else out_status=2
fi

if $out_status==4
  message_out="Pass!"
  status_color=62,205,0
elif $out_status==3
  message_out="Output Trimmed. Proceed Anyway."
  status_color=255,194,0
else
  if $out_status==2 message_out="Exit out of Import Mode to proceed with output"
  else message_out="Will not output!"
  fi
  status_color=170,43,0
fi

display_palette:=$use_pal&&($pal_method==3)

u "{$1}"\
"{$2}_"{$3?1:2}\
"{$3}"\
"{$4}_"{$3?2:1}\
"{$5}_"{$1?2}\
"{"$pal_method"}_"{$1?(!$5?2):2}\
"{$7}_"{$1&&$5?2}\
"{$8}_"{$1&&$5&&!$7?($12?2)}\
"{$9}_"{$1&&$5&&!$7?(!$12?2)}\
"{$10}_"{$1&&$5&&!$7?(!$12?2)}\
"{$11}_"{$1&&$5&&!$7?(!$12?2)}\
"{$12}_"{$1&&$5&&!$7?2}\
"{$13}_"{$1&&$5&&$7?($17?2)}\
"{$14}_"{$1&&$5&&$7?(!$17?2)}\
"{$15}_"{$1&&$5&&$7?(!$17?2)}\
"{$16}_"{$1&&$5&&$7?(!$17?2)}\
"{$17}_"{$1&&$5&&$7?2}\
"{$18}_"{$1?(!$5?(!$pal_method?2)):(!$pal_method?2)}\
"{0}_"{$1?(!$5?(!$pal_method?2)):(!$pal_method?2)}\
"{$20}_"{$1?(!$5?($pal_method==2?2)):($pal_method==2?2)}\
"{0}_"{$1?(!$5?($pal_method==2?2)):($pal_method==2?($imported?2:1))}\
"{"$num_of_colors"}_"{$1?(!$5?($pal_method==3?2)):($pal_method==3?2)}\
"{$23}_"{$1?(!$5?($pal_method==1?2)):($pal_method==1?2)}\
"{$24}_"{$1?(!$5?($pal_method!=1?2)):($pal_method!=1?2)}\
"{$25}_"{!$1?2}\
"{$26}_"{$display_palette?2}\
"{$27}_"{$26&&$display_palette?2}\
"{0}_"{$26&&$display_palette&&$27?2}\
"{"$color_0"}_"{$26&&$display_palette&&(0<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(0<$num_of_colors)?(!$27?1+($num_of_colors!=2))}\
"{0}_"{$26&&$display_palette&&(0<$num_of_colors)?($27?2)}\
"{"$color_1"}_"{$26&&$display_palette&&(1<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(1<$num_of_colors)?(!$27?1+($num_of_colors!=2))}\
"{0}_"{$26&&$display_palette&&(1<$num_of_colors)?($27?2)}\
"{"$color_2"}_"{$26&&$display_palette&&(2<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(2<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(2<$num_of_colors)?($27?2)}\
"{"$color_3"}_"{$26&&$display_palette&&(3<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(3<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(3<$num_of_colors)?($27?2)}\
"{"$color_4"}_"{$26&&$display_palette&&(4<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(4<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(4<$num_of_colors)?($27?2)}\
"{"$color_5"}_"{$26&&$display_palette&&(5<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(5<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(5<$num_of_colors)?($27?2)}\
"{"$color_6"}_"{$26&&$display_palette&&(6<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(6<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(6<$num_of_colors)?($27?2)}\
"{"$color_7"}_"{$26&&$display_palette&&(7<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(7<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(7<$num_of_colors)?($27?2)}\
"{"$color_8"}_"{$26&&$display_palette&&(8<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(8<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(8<$num_of_colors)?($27?2)}\
"{"$color_9"}_"{$26&&$display_palette&&(9<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(9<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(9<$num_of_colors)?($27?2)}\
"{"$color_10"}_"{$26&&$display_palette&&(10<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(10<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(10<$num_of_colors)?($27?2)}\
"{"$color_11"}_"{$26&&$display_palette&&(11<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(11<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(11<$num_of_colors)?($27?2)}\
"{"$color_12"}_"{$26&&$display_palette&&(12<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(12<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(12<$num_of_colors)?($27?2)}\
"{"$color_13"}_"{$26&&$display_palette&&(13<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(13<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(13<$num_of_colors)?($27?2)}\
"{"$color_14"}_"{$26&&$display_palette&&(14<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(14<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(14<$num_of_colors)?($27?2)}\
"{"$color_15"}_"{$26&&$display_palette&&(15<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(15<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(15<$num_of_colors)?($27?2)}\
"{"$color_16"}_"{$26&&$display_palette&&(16<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(16<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(16<$num_of_colors)?($27?2)}\
"{"$color_17"}_"{$26&&$display_palette&&(17<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(17<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(17<$num_of_colors)?($27?2)}\
"{"$color_18"}_"{$26&&$display_palette&&(18<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(18<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(18<$num_of_colors)?($27?2)}\
"{"$color_19"}_"{$26&&$display_palette&&(19<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(19<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(19<$num_of_colors)?($27?2)}\
"{"$color_20"}_"{$26&&$display_palette&&(20<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(20<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(20<$num_of_colors)?($27?2)}\
"{"$color_21"}_"{$26&&$display_palette&&(21<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(21<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(21<$num_of_colors)?($27?2)}\
"{"$color_22"}_"{$26&&$display_palette&&(22<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(22<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(22<$num_of_colors)?($27?2)}\
"{"$color_23"}_"{$26&&$display_palette&&(23<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(23<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(23<$num_of_colors)?($27?2)}\
"{"$color_24"}_"{$26&&$display_palette&&(24<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(24<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(24<$num_of_colors)?($27?2)}\
"{"$color_25"}_"{$26&&$display_palette&&(25<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(25<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(25<$num_of_colors)?($27?2)}\
"{"$color_26"}_"{$26&&$display_palette&&(26<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(26<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(26<$num_of_colors)?($27?2)}\
"{"$color_27"}_"{$26&&$display_palette&&(27<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(27<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(27<$num_of_colors)?($27?2)}\
"{"$color_28"}_"{$26&&$display_palette&&(28<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(28<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(28<$num_of_colors)?($27?2)}\
"{"$color_29"}_"{$26&&$display_palette&&(29<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(29<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(29<$num_of_colors)?($27?2)}\
"{"$color_30"}_"{$26&&$display_palette&&(30<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(30<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(30<$num_of_colors)?($27?2)}\
"{"$color_31"}_"{$26&&$display_palette&&(31<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(31<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(31<$num_of_colors)?($27?2)}\
"{"$color_32"}_"{$26&&$display_palette&&(32<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(32<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(32<$num_of_colors)?($27?2)}\
"{"$color_33"}_"{$26&&$display_palette&&(33<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(33<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(33<$num_of_colors)?($27?2)}\
"{"$color_34"}_"{$26&&$display_palette&&(34<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(34<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(34<$num_of_colors)?($27?2)}\
"{"$color_35"}_"{$26&&$display_palette&&(35<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(35<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(35<$num_of_colors)?($27?2)}\
"{"$color_36"}_"{$26&&$display_palette&&(36<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(36<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(36<$num_of_colors)?($27?2)}\
"{"$color_37"}_"{$26&&$display_palette&&(37<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(37<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(37<$num_of_colors)?($27?2)}\
"{"$color_38"}_"{$26&&$display_palette&&(38<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(38<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(38<$num_of_colors)?($27?2)}\
"{"$color_39"}_"{$26&&$display_palette&&(39<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(39<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(39<$num_of_colors)?($27?2)}\
"{"$color_40"}_"{$26&&$display_palette&&(40<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(40<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(40<$num_of_colors)?($27?2)}\
"{"$color_41"}_"{$26&&$display_palette&&(41<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(41<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(41<$num_of_colors)?($27?2)}\
"{"$color_42"}_"{$26&&$display_palette&&(42<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(42<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(42<$num_of_colors)?($27?2)}\
"{"$color_43"}_"{$26&&$display_palette&&(43<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(43<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(43<$num_of_colors)?($27?2)}\
"{"$color_44"}_"{$26&&$display_palette&&(44<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(44<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(44<$num_of_colors)?($27?2)}\
"{"$color_45"}_"{$26&&$display_palette&&(45<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(45<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(45<$num_of_colors)?($27?2)}\
"{"$color_46"}_"{$26&&$display_palette&&(46<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(46<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(46<$num_of_colors)?($27?2)}\
"{"$color_47"}_"{$26&&$display_palette&&(47<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(47<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(47<$num_of_colors)?($27?2)}\
"{"$color_48"}_"{$26&&$display_palette&&(48<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(48<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(48<$num_of_colors)?($27?2)}\
"{"$color_49"}_"{$26&&$display_palette&&(49<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(49<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(49<$num_of_colors)?($27?2)}\
"{"$color_50"}_"{$26&&$display_palette&&(50<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(50<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(50<$num_of_colors)?($27?2)}\
"{"$color_51"}_"{$26&&$display_palette&&(51<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(51<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(51<$num_of_colors)?($27?2)}\
"{"$color_52"}_"{$26&&$display_palette&&(52<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(52<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(52<$num_of_colors)?($27?2)}\
"{"$color_53"}_"{$26&&$display_palette&&(53<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(53<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(53<$num_of_colors)?($27?2)}\
"{"$color_54"}_"{$26&&$display_palette&&(54<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(54<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(54<$num_of_colors)?($27?2)}\
"{"$color_55"}_"{$26&&$display_palette&&(55<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(55<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(55<$num_of_colors)?($27?2)}\
"{"$color_56"}_"{$26&&$display_palette&&(56<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(56<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(56<$num_of_colors)?($27?2)}\
"{"$color_57"}_"{$26&&$display_palette&&(57<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(57<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(57<$num_of_colors)?($27?2)}\
"{"$color_58"}_"{$26&&$display_palette&&(58<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(58<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(58<$num_of_colors)?($27?2)}\
"{"$color_59"}_"{$26&&$display_palette&&(59<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(59<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(59<$num_of_colors)?($27?2)}\
"{"$color_60"}_"{$26&&$display_palette&&(60<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(60<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(60<$num_of_colors)?($27?2)}\
"{"$color_61"}_"{$26&&$display_palette&&(61<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(61<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(61<$num_of_colors)?($27?2)}\
"{"$color_62"}_"{$26&&$display_palette&&(62<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(62<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(62<$num_of_colors)?($27?2)}\
"{"$color_63"}_"{$26&&$display_palette&&(63<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(63<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(63<$num_of_colors)?($27?2)}\
"{"$color_64"}_"{$26&&$display_palette&&(64<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(64<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(64<$num_of_colors)?($27?2)}\
"{"$color_65"}_"{$26&&$display_palette&&(65<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(65<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(65<$num_of_colors)?($27?2)}\
"{"$color_66"}_"{$26&&$display_palette&&(66<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(66<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(66<$num_of_colors)?($27?2)}\
"{"$color_67"}_"{$26&&$display_palette&&(67<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(67<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(67<$num_of_colors)?($27?2)}\
"{"$color_68"}_"{$26&&$display_palette&&(68<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(68<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(68<$num_of_colors)?($27?2)}\
"{"$color_69"}_"{$26&&$display_palette&&(69<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(69<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(69<$num_of_colors)?($27?2)}\
"{"$color_70"}_"{$26&&$display_palette&&(70<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(70<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(70<$num_of_colors)?($27?2)}\
"{"$color_71"}_"{$26&&$display_palette&&(71<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(71<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(71<$num_of_colors)?($27?2)}\
"{"$color_72"}_"{$26&&$display_palette&&(72<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(72<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(72<$num_of_colors)?($27?2)}\
"{"$color_73"}_"{$26&&$display_palette&&(73<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(73<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(73<$num_of_colors)?($27?2)}\
"{"$color_74"}_"{$26&&$display_palette&&(74<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(74<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(74<$num_of_colors)?($27?2)}\
"{"$color_75"}_"{$26&&$display_palette&&(75<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(75<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(75<$num_of_colors)?($27?2)}\
"{"$color_76"}_"{$26&&$display_palette&&(76<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(76<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(76<$num_of_colors)?($27?2)}\
"{"$color_77"}_"{$26&&$display_palette&&(77<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(77<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(77<$num_of_colors)?($27?2)}\
"{"$color_78"}_"{$26&&$display_palette&&(78<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(78<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(78<$num_of_colors)?($27?2)}\
"{"$color_79"}_"{$26&&$display_palette&&(79<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(79<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(79<$num_of_colors)?($27?2)}\
"{"$color_80"}_"{$26&&$display_palette&&(80<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(80<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(80<$num_of_colors)?($27?2)}\
"{"$color_81"}_"{$26&&$display_palette&&(81<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(81<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(81<$num_of_colors)?($27?2)}\
"{"$color_82"}_"{$26&&$display_palette&&(82<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(82<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(82<$num_of_colors)?($27?2)}\
"{"$color_83"}_"{$26&&$display_palette&&(83<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(83<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(83<$num_of_colors)?($27?2)}\
"{"$color_84"}_"{$26&&$display_palette&&(84<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(84<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(84<$num_of_colors)?($27?2)}\
"{"$color_85"}_"{$26&&$display_palette&&(85<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(85<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(85<$num_of_colors)?($27?2)}\
"{"$color_86"}_"{$26&&$display_palette&&(86<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(86<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(86<$num_of_colors)?($27?2)}\
"{"$color_87"}_"{$26&&$display_palette&&(87<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(87<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(87<$num_of_colors)?($27?2)}\
"{"$color_88"}_"{$26&&$display_palette&&(88<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(88<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(88<$num_of_colors)?($27?2)}\
"{"$color_89"}_"{$26&&$display_palette&&(89<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(89<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(89<$num_of_colors)?($27?2)}\
"{"$color_90"}_"{$26&&$display_palette&&(90<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(90<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(90<$num_of_colors)?($27?2)}\
"{"$color_91"}_"{$26&&$display_palette&&(91<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(91<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(91<$num_of_colors)?($27?2)}\
"{"$color_92"}_"{$26&&$display_palette&&(92<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(92<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(92<$num_of_colors)?($27?2)}\
"{"$color_93"}_"{$26&&$display_palette&&(93<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(93<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(93<$num_of_colors)?($27?2)}\
"{"$color_94"}_"{$26&&$display_palette&&(94<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(94<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(94<$num_of_colors)?($27?2)}\
"{"$color_95"}_"{$26&&$display_palette&&(95<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(95<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(95<$num_of_colors)?($27?2)}\
"{"$color_96"}_"{$26&&$display_palette&&(96<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(96<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(96<$num_of_colors)?($27?2)}\
"{"$color_97"}_"{$26&&$display_palette&&(97<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(97<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(97<$num_of_colors)?($27?2)}\
"{"$color_98"}_"{$26&&$display_palette&&(98<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(98<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(98<$num_of_colors)?($27?2)}\
"{"$color_99"}_"{$26&&$display_palette&&(99<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(99<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(99<$num_of_colors)?($27?2)}\
"{"$color_100"}_"{$26&&$display_palette&&(100<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(100<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(100<$num_of_colors)?($27?2)}\
"{"$color_101"}_"{$26&&$display_palette&&(101<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(101<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(101<$num_of_colors)?($27?2)}\
"{"$color_102"}_"{$26&&$display_palette&&(102<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(102<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(102<$num_of_colors)?($27?2)}\
"{"$color_103"}_"{$26&&$display_palette&&(103<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(103<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(103<$num_of_colors)?($27?2)}\
"{"$color_104"}_"{$26&&$display_palette&&(104<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(104<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(104<$num_of_colors)?($27?2)}\
"{"$color_105"}_"{$26&&$display_palette&&(105<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(105<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(105<$num_of_colors)?($27?2)}\
"{"$color_106"}_"{$26&&$display_palette&&(106<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(106<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(106<$num_of_colors)?($27?2)}\
"{"$color_107"}_"{$26&&$display_palette&&(107<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(107<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(107<$num_of_colors)?($27?2)}\
"{"$color_108"}_"{$26&&$display_palette&&(108<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(108<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(108<$num_of_colors)?($27?2)}\
"{"$color_109"}_"{$26&&$display_palette&&(109<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(109<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(109<$num_of_colors)?($27?2)}\
"{"$color_110"}_"{$26&&$display_palette&&(110<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(110<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(110<$num_of_colors)?($27?2)}\
"{"$color_111"}_"{$26&&$display_palette&&(111<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(111<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(111<$num_of_colors)?($27?2)}\
"{"$color_112"}_"{$26&&$display_palette&&(112<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(112<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(112<$num_of_colors)?($27?2)}\
"{"$color_113"}_"{$26&&$display_palette&&(113<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(113<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(113<$num_of_colors)?($27?2)}\
"{"$color_114"}_"{$26&&$display_palette&&(114<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(114<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(114<$num_of_colors)?($27?2)}\
"{"$color_115"}_"{$26&&$display_palette&&(115<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(115<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(115<$num_of_colors)?($27?2)}\
"{"$color_116"}_"{$26&&$display_palette&&(116<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(116<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(116<$num_of_colors)?($27?2)}\
"{"$color_117"}_"{$26&&$display_palette&&(117<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(117<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(117<$num_of_colors)?($27?2)}\
"{"$color_118"}_"{$26&&$display_palette&&(118<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(118<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(118<$num_of_colors)?($27?2)}\
"{"$color_119"}_"{$26&&$display_palette&&(119<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(119<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(119<$num_of_colors)?($27?2)}\
"{"$color_120"}_"{$26&&$display_palette&&(120<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(120<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(120<$num_of_colors)?($27?2)}\
"{"$color_121"}_"{$26&&$display_palette&&(121<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(121<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(121<$num_of_colors)?($27?2)}\
"{"$color_122"}_"{$26&&$display_palette&&(122<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(122<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(122<$num_of_colors)?($27?2)}\
"{"$color_123"}_"{$26&&$display_palette&&(123<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(123<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(123<$num_of_colors)?($27?2)}\
"{"$color_124"}_"{$26&&$display_palette&&(124<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(124<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(124<$num_of_colors)?($27?2)}\
"{"$color_125"}_"{$26&&$display_palette&&(125<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(125<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(125<$num_of_colors)?($27?2)}\
"{"$color_126"}_"{$26&&$display_palette&&(126<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(126<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(126<$num_of_colors)?($27?2)}\
"{"$color_127"}_"{$26&&$display_palette&&(127<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(127<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(127<$num_of_colors)?($27?2)}\
"{"$color_128"}_"{$26&&$display_palette&&(128<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(128<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(128<$num_of_colors)?($27?2)}\
"{"$color_129"}_"{$26&&$display_palette&&(129<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(129<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(129<$num_of_colors)?($27?2)}\
"{"$color_130"}_"{$26&&$display_palette&&(130<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(130<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(130<$num_of_colors)?($27?2)}\
"{"$color_131"}_"{$26&&$display_palette&&(131<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(131<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(131<$num_of_colors)?($27?2)}\
"{"$color_132"}_"{$26&&$display_palette&&(132<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(132<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(132<$num_of_colors)?($27?2)}\
"{"$color_133"}_"{$26&&$display_palette&&(133<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(133<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(133<$num_of_colors)?($27?2)}\
"{"$color_134"}_"{$26&&$display_palette&&(134<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(134<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(134<$num_of_colors)?($27?2)}\
"{"$color_135"}_"{$26&&$display_palette&&(135<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(135<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(135<$num_of_colors)?($27?2)}\
"{"$color_136"}_"{$26&&$display_palette&&(136<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(136<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(136<$num_of_colors)?($27?2)}\
"{"$color_137"}_"{$26&&$display_palette&&(137<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(137<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(137<$num_of_colors)?($27?2)}\
"{"$color_138"}_"{$26&&$display_palette&&(138<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(138<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(138<$num_of_colors)?($27?2)}\
"{"$color_139"}_"{$26&&$display_palette&&(139<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(139<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(139<$num_of_colors)?($27?2)}\
"{"$color_140"}_"{$26&&$display_palette&&(140<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(140<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(140<$num_of_colors)?($27?2)}\
"{"$color_141"}_"{$26&&$display_palette&&(141<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(141<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(141<$num_of_colors)?($27?2)}\
"{"$color_142"}_"{$26&&$display_palette&&(142<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(142<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(142<$num_of_colors)?($27?2)}\
"{"$color_143"}_"{$26&&$display_palette&&(143<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(143<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(143<$num_of_colors)?($27?2)}\
"{"$color_144"}_"{$26&&$display_palette&&(144<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(144<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(144<$num_of_colors)?($27?2)}\
"{"$color_145"}_"{$26&&$display_palette&&(145<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(145<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(145<$num_of_colors)?($27?2)}\
"{"$color_146"}_"{$26&&$display_palette&&(146<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(146<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(146<$num_of_colors)?($27?2)}\
"{"$color_147"}_"{$26&&$display_palette&&(147<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(147<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(147<$num_of_colors)?($27?2)}\
"{"$color_148"}_"{$26&&$display_palette&&(148<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(148<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(148<$num_of_colors)?($27?2)}\
"{"$color_149"}_"{$26&&$display_palette&&(149<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(149<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(149<$num_of_colors)?($27?2)}\
"{"$color_150"}_"{$26&&$display_palette&&(150<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(150<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(150<$num_of_colors)?($27?2)}\
"{"$color_151"}_"{$26&&$display_palette&&(151<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(151<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(151<$num_of_colors)?($27?2)}\
"{"$color_152"}_"{$26&&$display_palette&&(152<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(152<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(152<$num_of_colors)?($27?2)}\
"{"$color_153"}_"{$26&&$display_palette&&(153<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(153<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(153<$num_of_colors)?($27?2)}\
"{"$color_154"}_"{$26&&$display_palette&&(154<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(154<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(154<$num_of_colors)?($27?2)}\
"{"$color_155"}_"{$26&&$display_palette&&(155<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(155<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(155<$num_of_colors)?($27?2)}\
"{"$color_156"}_"{$26&&$display_palette&&(156<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(156<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(156<$num_of_colors)?($27?2)}\
"{"$color_157"}_"{$26&&$display_palette&&(157<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(157<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(157<$num_of_colors)?($27?2)}\
"{"$color_158"}_"{$26&&$display_palette&&(158<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(158<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(158<$num_of_colors)?($27?2)}\
"{"$color_159"}_"{$26&&$display_palette&&(159<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(159<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(159<$num_of_colors)?($27?2)}\
"{"$color_160"}_"{$26&&$display_palette&&(160<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(160<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(160<$num_of_colors)?($27?2)}\
"{"$color_161"}_"{$26&&$display_palette&&(161<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(161<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(161<$num_of_colors)?($27?2)}\
"{"$color_162"}_"{$26&&$display_palette&&(162<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(162<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(162<$num_of_colors)?($27?2)}\
"{"$color_163"}_"{$26&&$display_palette&&(163<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(163<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(163<$num_of_colors)?($27?2)}\
"{"$color_164"}_"{$26&&$display_palette&&(164<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(164<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(164<$num_of_colors)?($27?2)}\
"{"$color_165"}_"{$26&&$display_palette&&(165<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(165<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(165<$num_of_colors)?($27?2)}\
"{"$color_166"}_"{$26&&$display_palette&&(166<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(166<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(166<$num_of_colors)?($27?2)}\
"{"$color_167"}_"{$26&&$display_palette&&(167<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(167<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(167<$num_of_colors)?($27?2)}\
"{"$color_168"}_"{$26&&$display_palette&&(168<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(168<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(168<$num_of_colors)?($27?2)}\
"{"$color_169"}_"{$26&&$display_palette&&(169<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(169<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(169<$num_of_colors)?($27?2)}\
"{"$color_170"}_"{$26&&$display_palette&&(170<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(170<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(170<$num_of_colors)?($27?2)}\
"{"$color_171"}_"{$26&&$display_palette&&(171<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(171<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(171<$num_of_colors)?($27?2)}\
"{"$color_172"}_"{$26&&$display_palette&&(172<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(172<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(172<$num_of_colors)?($27?2)}\
"{"$color_173"}_"{$26&&$display_palette&&(173<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(173<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(173<$num_of_colors)?($27?2)}\
"{"$color_174"}_"{$26&&$display_palette&&(174<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(174<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(174<$num_of_colors)?($27?2)}\
"{"$color_175"}_"{$26&&$display_palette&&(175<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(175<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(175<$num_of_colors)?($27?2)}\
"{"$color_176"}_"{$26&&$display_palette&&(176<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(176<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(176<$num_of_colors)?($27?2)}\
"{"$color_177"}_"{$26&&$display_palette&&(177<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(177<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(177<$num_of_colors)?($27?2)}\
"{"$color_178"}_"{$26&&$display_palette&&(178<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(178<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(178<$num_of_colors)?($27?2)}\
"{"$color_179"}_"{$26&&$display_palette&&(179<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(179<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(179<$num_of_colors)?($27?2)}\
"{"$color_180"}_"{$26&&$display_palette&&(180<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(180<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(180<$num_of_colors)?($27?2)}\
"{"$color_181"}_"{$26&&$display_palette&&(181<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(181<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(181<$num_of_colors)?($27?2)}\
"{"$color_182"}_"{$26&&$display_palette&&(182<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(182<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(182<$num_of_colors)?($27?2)}\
"{"$color_183"}_"{$26&&$display_palette&&(183<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(183<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(183<$num_of_colors)?($27?2)}\
"{"$color_184"}_"{$26&&$display_palette&&(184<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(184<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(184<$num_of_colors)?($27?2)}\
"{"$color_185"}_"{$26&&$display_palette&&(185<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(185<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(185<$num_of_colors)?($27?2)}\
"{"$color_186"}_"{$26&&$display_palette&&(186<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(186<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(186<$num_of_colors)?($27?2)}\
"{"$color_187"}_"{$26&&$display_palette&&(187<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(187<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(187<$num_of_colors)?($27?2)}\
"{"$color_188"}_"{$26&&$display_palette&&(188<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(188<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(188<$num_of_colors)?($27?2)}\
"{"$color_189"}_"{$26&&$display_palette&&(189<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(189<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(189<$num_of_colors)?($27?2)}\
"{"$color_190"}_"{$26&&$display_palette&&(190<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(190<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(190<$num_of_colors)?($27?2)}\
"{"$color_191"}_"{$26&&$display_palette&&(191<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(191<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(191<$num_of_colors)?($27?2)}\
"{"$color_192"}_"{$26&&$display_palette&&(192<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(192<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(192<$num_of_colors)?($27?2)}\
"{"$color_193"}_"{$26&&$display_palette&&(193<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(193<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(193<$num_of_colors)?($27?2)}\
"{"$color_194"}_"{$26&&$display_palette&&(194<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(194<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(194<$num_of_colors)?($27?2)}\
"{"$color_195"}_"{$26&&$display_palette&&(195<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(195<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(195<$num_of_colors)?($27?2)}\
"{"$color_196"}_"{$26&&$display_palette&&(196<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(196<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(196<$num_of_colors)?($27?2)}\
"{"$color_197"}_"{$26&&$display_palette&&(197<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(197<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(197<$num_of_colors)?($27?2)}\
"{"$color_198"}_"{$26&&$display_palette&&(198<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(198<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(198<$num_of_colors)?($27?2)}\
"{"$color_199"}_"{$26&&$display_palette&&(199<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(199<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(199<$num_of_colors)?($27?2)}\
"{"$color_200"}_"{$26&&$display_palette&&(200<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(200<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(200<$num_of_colors)?($27?2)}\
"{"$color_201"}_"{$26&&$display_palette&&(201<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(201<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(201<$num_of_colors)?($27?2)}\
"{"$color_202"}_"{$26&&$display_palette&&(202<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(202<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(202<$num_of_colors)?($27?2)}\
"{"$color_203"}_"{$26&&$display_palette&&(203<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(203<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(203<$num_of_colors)?($27?2)}\
"{"$color_204"}_"{$26&&$display_palette&&(204<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(204<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(204<$num_of_colors)?($27?2)}\
"{"$color_205"}_"{$26&&$display_palette&&(205<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(205<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(205<$num_of_colors)?($27?2)}\
"{"$color_206"}_"{$26&&$display_palette&&(206<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(206<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(206<$num_of_colors)?($27?2)}\
"{"$color_207"}_"{$26&&$display_palette&&(207<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(207<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(207<$num_of_colors)?($27?2)}\
"{"$color_208"}_"{$26&&$display_palette&&(208<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(208<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(208<$num_of_colors)?($27?2)}\
"{"$color_209"}_"{$26&&$display_palette&&(209<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(209<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(209<$num_of_colors)?($27?2)}\
"{"$color_210"}_"{$26&&$display_palette&&(210<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(210<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(210<$num_of_colors)?($27?2)}\
"{"$color_211"}_"{$26&&$display_palette&&(211<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(211<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(211<$num_of_colors)?($27?2)}\
"{"$color_212"}_"{$26&&$display_palette&&(212<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(212<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(212<$num_of_colors)?($27?2)}\
"{"$color_213"}_"{$26&&$display_palette&&(213<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(213<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(213<$num_of_colors)?($27?2)}\
"{"$color_214"}_"{$26&&$display_palette&&(214<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(214<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(214<$num_of_colors)?($27?2)}\
"{"$color_215"}_"{$26&&$display_palette&&(215<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(215<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(215<$num_of_colors)?($27?2)}\
"{"$color_216"}_"{$26&&$display_palette&&(216<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(216<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(216<$num_of_colors)?($27?2)}\
"{"$color_217"}_"{$26&&$display_palette&&(217<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(217<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(217<$num_of_colors)?($27?2)}\
"{"$color_218"}_"{$26&&$display_palette&&(218<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(218<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(218<$num_of_colors)?($27?2)}\
"{"$color_219"}_"{$26&&$display_palette&&(219<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(219<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(219<$num_of_colors)?($27?2)}\
"{"$color_220"}_"{$26&&$display_palette&&(220<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(220<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(220<$num_of_colors)?($27?2)}\
"{"$color_221"}_"{$26&&$display_palette&&(221<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(221<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(221<$num_of_colors)?($27?2)}\
"{"$color_222"}_"{$26&&$display_palette&&(222<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(222<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(222<$num_of_colors)?($27?2)}\
"{"$color_223"}_"{$26&&$display_palette&&(223<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(223<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(223<$num_of_colors)?($27?2)}\
"{"$color_224"}_"{$26&&$display_palette&&(224<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(224<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(224<$num_of_colors)?($27?2)}\
"{"$color_225"}_"{$26&&$display_palette&&(225<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(225<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(225<$num_of_colors)?($27?2)}\
"{"$color_226"}_"{$26&&$display_palette&&(226<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(226<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(226<$num_of_colors)?($27?2)}\
"{"$color_227"}_"{$26&&$display_palette&&(227<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(227<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(227<$num_of_colors)?($27?2)}\
"{"$color_228"}_"{$26&&$display_palette&&(228<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(228<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(228<$num_of_colors)?($27?2)}\
"{"$color_229"}_"{$26&&$display_palette&&(229<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(229<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(229<$num_of_colors)?($27?2)}\
"{"$color_230"}_"{$26&&$display_palette&&(230<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(230<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(230<$num_of_colors)?($27?2)}\
"{"$color_231"}_"{$26&&$display_palette&&(231<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(231<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(231<$num_of_colors)?($27?2)}\
"{"$color_232"}_"{$26&&$display_palette&&(232<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(232<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(232<$num_of_colors)?($27?2)}\
"{"$color_233"}_"{$26&&$display_palette&&(233<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(233<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(233<$num_of_colors)?($27?2)}\
"{"$color_234"}_"{$26&&$display_palette&&(234<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(234<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(234<$num_of_colors)?($27?2)}\
"{"$color_235"}_"{$26&&$display_palette&&(235<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(235<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(235<$num_of_colors)?($27?2)}\
"{"$color_236"}_"{$26&&$display_palette&&(236<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(236<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(236<$num_of_colors)?($27?2)}\
"{"$color_237"}_"{$26&&$display_palette&&(237<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(237<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(237<$num_of_colors)?($27?2)}\
"{"$color_238"}_"{$26&&$display_palette&&(238<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(238<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(238<$num_of_colors)?($27?2)}\
"{"$color_239"}_"{$26&&$display_palette&&(239<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(239<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(239<$num_of_colors)?($27?2)}\
"{"$color_240"}_"{$26&&$display_palette&&(240<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(240<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(240<$num_of_colors)?($27?2)}\
"{"$color_241"}_"{$26&&$display_palette&&(241<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(241<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(241<$num_of_colors)?($27?2)}\
"{"$color_242"}_"{$26&&$display_palette&&(242<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(242<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(242<$num_of_colors)?($27?2)}\
"{"$color_243"}_"{$26&&$display_palette&&(243<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(243<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(243<$num_of_colors)?($27?2)}\
"{"$color_244"}_"{$26&&$display_palette&&(244<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(244<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(244<$num_of_colors)?($27?2)}\
"{"$color_245"}_"{$26&&$display_palette&&(245<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(245<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(245<$num_of_colors)?($27?2)}\
"{"$color_246"}_"{$26&&$display_palette&&(246<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(246<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(246<$num_of_colors)?($27?2)}\
"{"$color_247"}_"{$26&&$display_palette&&(247<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(247<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(247<$num_of_colors)?($27?2)}\
"{"$color_248"}_"{$26&&$display_palette&&(248<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(248<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(248<$num_of_colors)?($27?2)}\
"{"$color_249"}_"{$26&&$display_palette&&(249<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(249<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(249<$num_of_colors)?($27?2)}\
"{"$color_250"}_"{$26&&$display_palette&&(250<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(250<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(250<$num_of_colors)?($27?2)}\
"{"$color_251"}_"{$26&&$display_palette&&(251<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(251<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(251<$num_of_colors)?($27?2)}\
"{"$color_252"}_"{$26&&$display_palette&&(252<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(252<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(252<$num_of_colors)?($27?2)}\
"{"$color_253"}_"{$26&&$display_palette&&(253<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(253<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(253<$num_of_colors)?($27?2)}\
"{"$color_254"}_"{$26&&$display_palette&&(254<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(254<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(254<$num_of_colors)?($27?2)}\
"{"$color_255"}_"{$26&&$display_palette&&(255<$num_of_colors)?2}\
"{0}_"{$26&&$display_palette&&(255<$num_of_colors)?(!$27?2)}\
"{0}_"{$26&&$display_palette&&(255<$num_of_colors)?($27?2)}\
"{0}_"{$26&&$display_palette?2}\
"{0}_"{$26&&$display_palette&&$27?2}\
"{$1311}"\
"{$1312}"\
"{$1313}_"{!$1?((!$25||$tcrc_windows_width_check)?1:2)}\
"{"$tcrc_windows_width_check"}_"{!$1?(!$25?1:2)}\
"{$1315}_"{!$1?((!$25||$tcrc_windows_height_check)?1:2)}\
"{"$tcrc_windows_height_check"}_"{!$1?(!$25?1:2)}\
"{$1317}_"{$1?2}\
"{$1318}_"{$img_cont_alp?2}\
"{$1319}_"{$img_cont_alp?($1318?2:1)}\
"{$1320}_"{$img_cont_alp?($1318?2:1)}\
"{$1321}_"{$img_cont_alp?($1318?(!$1?2):(!$1?1))}\
"{$1322}_"{$img_cont_alp?($1318?($1?2):($1?1))}\
"{$1323}_"{$img_cont_alp?($1318?(!$1&&$1321==1?2):(!$1&&$1321==1?1))}\
"{$1324}_"{$img_cont_alp?($1318?(!$1?($1321==2?2:0)):(!$1?($1321==2?1:0)))}\
"{"$text_box"}"\
"{$20}"\
"{"$imported"}"\
"{$1328}"\
"{"$message_out"}"\
"{"$out_status"}"\
"{"$status_color"}"\
"{$1334}"\
"{$1335,$1336}"
#@gui Color Modulo Texture:gui_rep_colmt,gui_rep_colmt_preview
#@gui:_=note("This filter is inspired by <a href="https://forums.getpaint.net/topic/111782-color-modulo-texture-tool-ymd20170922/">Color Modulo</a> plugin made by <b>MadJik</b> for <a href="https://www.getpaint.net/">Paint.NET</a> software.\n\nPreview is inaccurate! Use 100% Zoom Preview for most accuracy!"), _=separator()
#@gui:_=note("<b>Colour and Channel Setting</b>"), _=separator()
#@gui:_=note("- Colour Space and Alpha Setting -")
#@gui:Colour Space=choice(0,"RGB-8","RYB-8","CMY-8","CMYK-8","HSI-8","HSL-8","HSV-8","LAB-8","LCH-8","YIQ-8","YUV-8","YCbCr-8","YCbCrGLIC-8","XYZ-8","YES-8")
#@gui:Contain Alpha?=bool(0)
#@gui:_=separator(),_=note("- Channel Setting -")
#@gui:Channel Order=choice(0,"1-2-3-4","1-2-4-3","1-3-2-4","1-3-4-2","1-4-2-3","1-4-3-2","2-1-3-4","2-1-4-3","2-3-1-4","2-3-4-1","2-4-1-3","2-4-3-1","3-1-2-4","3-1-4-2","3-2-1-4","3-2-4-1","3-4-1-2","3-4-2-1","4-1-2-3","4-1-3-2","4-2-1-3","4-2-3-1","4-3-1-2","4-3-2-1")
#@gui:Channel Order=choice(0,"1-2-3","1-3-2","2-1-3","2-3-1","3-1-2","3-2-1")
#@gui:Edit Multiple Channel Separately?=bool(1)
#@gui:_=separator(),_=note("<b>Diagonal Setting</b>"), _=separator()
#@gui:Flip Diagonal?=bool(0)
#@gui:_=separator(),_=note("<b>Modulo Texture Setting</b>")
#@gui:_=separator(),_=note("- Multichannel Editing-")
#@gui:Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui:Modulo Variable #1=int(0,0,786)
#@gui:Modulo Variable #2=int(255,0,786)
#@gui:Function Angle=float(0,-180,180)
#@gui:Value Shift=int(0,0,786)
#@gui:Centered=bool(1)
#@gui:Negate=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=note("<small>Option available when <u>Edit Multiple Channel Separately</u> is turned off</small>")
#@gui:_=separator(),_=note("- Separate Channel Editing -")
#@gui:Channel Section=choice(0,"Channel #1","Channel #2","Channel #3","Channel #4")
#@gui:Channel Section=choice(0,"Channel #1","Channel #2","Channel #3")
#@gui:_=note("<small>Option available when <u>Edit Multiple Channel Separately</u> is turned on</small>"), _=separator()
#@gui:Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui:Modulo Variable #1=int(0,0,786)
#@gui:Modulo Variable #2=int(255,0,786)
#@gui:Function Angle=float(0,-180,180)
#@gui:Value Shift=int(0,0,786)
#@gui:Centered=bool(1)
#@gui:Negate=bool(0)
#@gui:Normalize=bool(1)
#@gui:Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui:Modulo Variable #1=int(0,0,786)
#@gui:Modulo Variable #2=int(255,0,786)
#@gui:Function Angle=float(0,-180,180)
#@gui:Value Shift=int(0,0,786)
#@gui:Centered=bool(1)
#@gui:Negate=bool(0)
#@gui:Normalize=bool(1)
#@gui:Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui:Modulo Variable #1=int(0,0,786)
#@gui:Modulo Variable #2=int(255,0,786)
#@gui:Function Angle=float(0,-180,180)
#@gui:Value Shift=int(0,0,786)
#@gui:Centered=bool(1)
#@gui:Negate=bool(0)
#@gui:Normalize=bool(1)
#@gui:Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui:Modulo Variable #1=int(0,0,786)
#@gui:Modulo Variable #2=int(255,0,786)
#@gui:Function Angle=float(0,-180,180)
#@gui:Value Shift=int(0,0,786)
#@gui:Centered=bool(1)
#@gui:Negate=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=note("<small>Option available when <u>Edit Multiple Channel Separately</u> is turned on</small>")
#@gui:_=separator(),_=note("<b>Subpixel Processing Setting</b>"), _=separator()
#@gui:Subpixel Rendering Level=float(1,0,1)
#@gui:Subpixel Interpolation=choice(5,"Nearest","Average","Grid","Linear","Bicubic","Lanczos")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/10/07</i>.</small>")
gui_rep_colmt:
cs=$1
alp=$2
tc={$cs!=3?3+$alp:4}
pos={$tc==4?$3:$4}
argset=${1-2},$pos,$6,${49-50}

if $5 rep_color_modulo_texture $argset,${17-48}
else rep_color_modulo_texture $argset,${7-14}
fi
gui_rep_colmt_preview:
gui_rep_colmt $*
cs=$1
alp={$2?1}
tc={$cs!=3?3+$alp:4}
set_a={!$5?2:0}
set_b={$5?($tc==4?($15==0?2:0):($16==0?2:0)):0}
set_c={$5?($tc==4?($15==1?2:0):($16==1?2:0)):0}
set_d={$5?($tc==4?($15==2?2:0):($16==2?2:0)):0}
set_e={$5?($tc==4?($15==3?2:0):0):0}

u "{$1}"\
"{$2}_"{$1==3?0:2}\
"{$3}_"{$tc==4?2:0}\
"{$4}_"{$tc==3?2:0}\
"{$5}"\
"{$6}"\
"{$7}_"$set_a\
"{$8}_"$set_a\
"{$9}_"$set_a\
"{$10}_"$set_a\
"{$11}_"$set_a\
"{$12}_"$set_a\
"{$13}_"$set_a\
"{$14}_"$set_a\
"{$15}_"{$5&&$tc==4?2:0}\
"{$16}_"{$5&&$tc==3?2:0}\
"{$17}_"$set_b\
"{$18}_"$set_b\
"{$19}_"$set_b\
"{$20}_"$set_b\
"{$21}_"$set_b\
"{$22}_"$set_b\
"{$23}_"$set_b\
"{$24}_"$set_b\
"{$25}_"$set_c\
"{$26}_"$set_c\
"{$27}_"$set_c\
"{$28}_"$set_c\
"{$29}_"$set_c\
"{$30}_"$set_c\
"{$31}_"$set_c\
"{$32}_"$set_c\
"{$33}_"$set_d\
"{$34}_"$set_d\
"{$35}_"$set_d\
"{$36}_"$set_d\
"{$37}_"$set_d\
"{$38}_"$set_d\
"{$39}_"$set_d\
"{$40}_"$set_d\
"{$41}_"$set_e\
"{$42}_"$set_e\
"{$43}_"$set_e\
"{$44}_"$set_e\
"{$45}_"$set_e\
"{$46}_"$set_e\
"{$47}_"$set_e\
"{$48}_"$set_e\
"{$49}"\
"{$50}"
#@gui Picture Mosaic:fx_rep_photomosaic,fx_rep_photomosaic_preview
#@gui:_=note("Generates picture mosaic using indexing,color searching, and scaling.\n\n<b>Note - </b>Instruction are found below!"),_=separator()
#@gui:_=note("<b>- Input -<b>")
#@gui:Use Folder?=bool(0)
#@gui:Mosaic Tile Pictures=folder()
#@gui:Target Layer=choice(0,"Top","Bottom"),_=separator(),_=note("<b>- Mosaic Generation -</b>\n\n<small><i>Note: When either tile_height or tile_width is equal to 0, it will automatically create the tile ratio based on which side is smaller.</i></small>")
#@gui:Tile Width=int(15,0,50)
#@gui:Tile Height=int(0,0,50)
#@gui:Dithering (%)=float(50,0,100)
#@gui:Scaling Interpolation=choice(0,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui:Palette Choice=choice(0,"Average","Median")
#@gui:Autocrop=bool(0)
#@gui:Preserve Original Dimension=bool(0),_=separator(),_=note("<b>Paint.NET Workaround</b>")
#@gui:Workaround Mode=choice(1,"Export","Clipped-Center",Both")
#@gui:Folder=folder()
#@gui:Filename=text("mosaic.png")
#@gui:_=note("<small>This section is only for Paint.NET users! If you don't use this this software, then you don't need use this section!</small>")
#@gui:_=separator(),_=note("<b>- Information -</b>\n\n<b>Do not be alarmed when multiple command prompt shows up when using folder input as it is a normal process!</b>\n\nThis filter is used for generation of mosaic pictures. Also, the mosaic cli command cannot support a number of images that is less than 3, so this gui filter will automatically use folder input option instead. So, you need at least 2 images inside a folder for the mosaic filter to work when using folder input. For more information, see below.\n\n<b>-Software Usage -</b>\n\n<b>For Krita, and GIMP: </b> Set to input layers to <b>All</b> assuming 3 or more layers are in your file to create mosaic using the top image as a mosaic target.If you are using folder input instead, it is recommended to set layer input to <b>Active</b>.\n\n<b>For Paint.NET: </b> Using 3 or more layer is unsupported due to the Paint.NET plugin restriction, so you can only use folder input. This is a workaround as G'MIC itself supports more than 2 layers.")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/5/1</i>.</small>")
fx_rep_photomosaic:
fileloc="$2"
filename="$12/$13"

ww={w}
hh={h}

if same('$_host','paintdotnet')

 k[0] ig $fileloc rep_photomosaic[0] [^0],$4,$5,{$6/100},${7-9} k[0]
 if $11==0||$11==2 o[0] $filename fi
 if $11 r $ww,$hh,100%,100%,0,0,.5,.5 fi

else

  if ($!>2)&&!$1
   if $3 rv fi rep_photomosaic[0] [^0],$4,$5,{$6/100},${7-9} if !$3 k[0] fi
  else
   imgs={$!} ig $fileloc rep_photomosaic[0-{$imgs-1}] [$imgs--1],$4,$5,{$6/100},${7-9} k[0-{$imgs-1}]
  fi
 if $10 r $ww,$hh,100%,100%,0,0,.5,.5 fi

fi

fx_rep_photomosaic_preview:
if same('$_host','paintdotnet') pdn=1 else pdn=0 fi
imgs={$!}
fx_rep_photomosaic $1,"$2",${3-11},"$12","$13"

a={$pdn?($11==0||$11==2?2:1)}

u "{$1}_"{!$pdn?($imgs<2?1:2)}\
"{$2}_"{!$pdn?($imgs>2?($1?2:1):2):2}\
"{$3}_"{!$pdn?($imgs>2?(!$1?2:1):2)}\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}_"{!$pdn?2}\
"{$11}_"{$pdn?2}\
"{$12}_"$a\
"{$13}_"$a
#@gui Non-Convolution Edge Extraction:fx_ncee,fx_ncee_preview(0)
#@gui:_=note("Based off PS Embossing filtering. The way it works is that you duplicate once and then shift with wrap-around using original image data using an angle and offset. Then finally, you invert one of the layer, and average those values. In this filter, you have several options when it comes to alpha and how the image wrap-around. Also, CMYK mode may be fixed later as I'm trying to avoid the problem with Alpha mode and CMYK mode.")
#@gui:_=separator()
#@gui:Colour Space=choice(0,"RGB8","RYB8","CMY8","CMYK8","HSI8","HSL8","HSV8","LAB8","LCH8","YIQ8","YUV8","XYZ8","YES8","Kodak 1-8","Ohta8")
#@gui:_=separator()
#@gui:Angle=float(0,0,360)
#@gui:Offset=float(1,.5,256)
#@gui:Contrast Factor [%]=float(100,0,500)
#@gui:Wraparound Mode=choice(2,"Dirichlet","Neumann","Periodic","Mirror")
#@gui:Interpolation=bool(0)
#@gui:_=separator(),_=note("Alpha Processing")
#@gui:Alpha Mode=choice(0,"Preserve Original Alpha","Multiply Alphas")
#@gui:_=separator(),_=note("Blending Processing\n\n<i>If you're looking for normal blending mode, you do not need to touch this and if you did, set mode to alpha and opacity to 100.</i>")
#@gui:Blending Mode=choice(1,"add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor")
#@gui:9. Blending Opacity=float(100,0,100)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian Latest Update: <i>2019/4/25</i>.</small>")
fx_ncee:
foreach { rep_ncee $3,$2,$5,$6,{$4/100},$7,$1,$8,{$9/100} }
fx_ncee_preview:
gui_split_preview "fx_ncee $*",${-3--1}
#@gui Fragment Blur:gui_rep_frblur,gui_rep_frblur_preview(0)
#@gui:_=note("Inspired by the Paint.NET Fragment Blur filter, this implementation improves upon it by adding color space options, preservation of original image as a option, boundary condition option, and interpolation option.\n\n<b>Warning -</b> Preview may not be accurate with image with completely opaque images. The output will not show any transparency regardless."), _=separator(), _=note("<b>Main Setting</b>")
#@gui:Color Space=choice(0,"RGB","sRGB","RYB","CMYK","HCY","HSI","HSL","HSV","LAB","LCH")
#@gui:Additional Duplicates Count=int(10,2,100)
#@gui:Half Image-Diagonal (%)=float(5,0,100)
#@gui:Angle=float(0,-180,180)
#@gui:Superimpose with Original?=bool(0)
#@gui:_=separator(),_=note("<b>Secondary Setting</b>")
#@gui:Boundary=choice(1,"None","Neumann","Periodic","Mirror")
#@gui:Shift Linear Interpolation? =bool(0)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author : <i>Reptorian</i>      Latest update: <i>2019/9/26</i>.</small>")
gui_rep_frblur: rep_frblur $2,$3%,$4,$5,$6,$7,$1
gui_rep_frblur_preview: gui_split_preview "gui_rep_frblur $*",${-3--1}
#@gui Nebulous:fx_rep_nebulous,fx_rep_nebulous_preview
#@gui:_=note("Based off <a href="https://forums.getpaint.net/topic/111774-nebulous-texture-update-ymd20170922/?tab=comments#comment-535865">MadJik's PDN Nebulous plugin</a>. The G'MIC version of Nebulous allows you to manipulate the result by angle within the main surface and the distortion surface, and allows you to shift the positioning of the Nebulous surface. Furthermore, the G'MIC version of Nebulous doesn't use integer on the output of surface."), _=separator()
#@gui:_=note("<b>Surface Theme</b>"), Colour Space Mode=choice (0,"RGB8","RYB8","HSI8","HSL8","HSV8","LAB8","LCH8","YIQ8","YUV8","XYZ8","YES8","Kodak 1-8","Ohta8","YCoCg-R"), _=separator()
#@gui:_=note("<b>Surface Generation</b>")
#@gui:XY-Factor=float(4,.1,1000)
#@gui:X-Factor=float(10,.01,1000)
#@gui:Y-Factor=float(10,.01,1000)
#@gui:X-Shift (%)=float(0,-10,10)
#@gui:Y-Shift (%)=float(0,-10,10)
#@gui:Angle of Main Nebulous Surface=float(0,-180,180)
#@gui:Wave(s)=float(1,-25,25)
#@gui:Lighting Angle=float(0,-180,180)
#@gui:Surface Disturbance=float(0,0,2000)
#@gui:Surface Disturbance Multiplier=float(1,1,500)
#@gui:Disturbance X=float(0,0,1000)
#@gui:Disturbance Y=float(0,0,1000)
#@gui:Angle of Disturbance Surface=float(0,-180,180)
#@gui:Disturbance Scale-By-Factor=bool(0)
#@gui:Output Mode=choice(2,"Built-in Gray","Luminosity from Color","Color")
#@gui:Alpha Mode=choice(0,"None","Hard Light","Hard Dark","Smooth Light","Smooth Dark")
#@gui:_=separator()
#@gui:_=note("<b>Subpixel Processing</b>\n\n You do not need to touch this unless you want higher amount of precision, but the difference is small. If you are using a very small surface or hard alpha mode, then it makes sense to touch subpixel processing variables.")
#@gui:Subpixel Level=float(1,0,3)
#@gui:Subpixel Interpolation=choice(3,"Average","Linear","Grid","Bicubic","Lanczos")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2019/5/11</i>.</small>")
fx_rep_nebulous:
convert_colors=${arg0\ $1,to_rgb,ryb2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,xyz82rgb,yes82rgb,k182rgb,ohta82rgb,ycocgr2rgb}
foreach {

	rep_nebulous ${2-8},{$1>4&&$1<9?$9+180:$9},{$10*$11},${12-16},{$1>4&&$1<9?$17!=0?($17>=3?3+(4-$17):1+(2-$17)):$17},{$18+1},$19 + 1 * 127.5

	if $1&&$16
		$convert_colors.
	fi

	if $16==1
		s c,{if(s==4,-3,if(s==2,-1,-s))}
		if $!==2
			to_gray.. a c
		else
			to_gray
		fi
	fi

}
fx_rep_nebulous_preview:
fx_rep_nebulous $*
#@gui Grouped Pixel Axis-Based Shift:fx_rep_sptbwgp,fx_rep_sptbwgp_preview(0)*
#@gui:_=note("Based off MadJik's Paint.NET Gravity Plugin. New feature are shift position, and influence factor."),_=separator()
#@gui:Shift Position (%)=float(0,-100,100)
#@gui:Influence Factor (%)=float(0,0,100)
#@gui:Threshold (%)=float(0,0,100)
#@gui:Axis=choice(0,"Horizontal","Vertical")
#@gui:_=value("stored_values_here")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2025/11/20</i>.</small>")
fx_rep_sptbwgp:
_fx_rep_sptbwgp_helper ${1-5},0
fx_rep_sptbwgp_preview:
_fx_rep_sptbwgp_helper ${1-5},1
_fx_rep_sptbwgp_helper:
if narg($_persistent)?same([${1-4}],[$5])
	rm $_persistent
else
	to_automode
	rep_shift_pixel_to_boundary_with_group_pixels {$1%},${arg0\ $4,x,y},$2%,$3%
	if $6
		+store _persistent
	fi
fi

if $6
	z $_preview_x0,$_preview_y0,$_preview_x1,$_preview_y1
	r ${-gui_preview_wh},1,100%
	u "{$1}"\
		"{$2}"\
		"{$3}"\
		"{$4}"\
		"{"\"${1-4}\""}"
fi
#@gui Binary Alternating Quaddro Texture [Basic]:rep_binary_quaddro_basic_gui,rep_binary_quaddro_basic_gui_preview(0)
#@gui:_=note("This filter is a extended version of a filter found in<a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui:_=note("<b>Channel Processing</b>"),Texture Output=choice(0,"Grayscale","Hue","Degradation Mode"),_=separator()
#@gui:_=note("<b>Main Texture Processing</b>")
#@gui:Style=choice(0,"Cracking Alternating Texture","Alternating Glasses","Simple")
#@gui:Variable#1=int(8,-512,512)
#@gui:Variable#2=int(8,-512,512)
#@gui:Variable#3=int(128,-200,200)
#@gui:Operand=choice(2,"AND","OR","XOR")
#@gui:Angle=float(0,-180,180)
#@gui:X-Flip=bool(0)
#@gui:Y-Flip=bool(0)
#@gui:Number Modulo=int(256,256,2048)
#@gui:Internal Normalize=int(255,255,2048)
#@gui:Internal Normalization=bool(1)
#@gui:Number Modulo=int(361,256,2048)
#@gui:Internal Normalize=int(361,360,2048)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2018/12/19</i>.</small>")
rep_binary_quaddro_basic_gui:
if $1==0 rep_binaltquad ${2-12} % 256
elif $1==1
 foreach {
  rep_binaltquad ${2-9},${13-14},1 % 361
  +f 1
  [-1]
  a c
  hsv2rgb
 }
elif $1==2
 foreach {
  +rep_binaltquad ${2-9},{w*h-1},{w*h-1}
  f.. I[i#1]
  k..
 }
fi
rep_binary_quaddro_basic_gui_preview:
rep_binary_quaddro_basic_gui $*
a={$2!=2?2:0}
b={$1==0?2:0}
c={$1==1?2:0}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}_"$a\
"{$6}_"$a\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}_"$b\
"{$11}_"$b\
"{$12}_"$b\
"{$13}_"$c\
"{$14}_"$c
#@gui Binary Alternating Quaddro Texture [MultiChannel]:rep_binary_quaddro_mc_gui, rep_binary_quaddro_mc_gui_preview(0)
#@gui:_=note("This filter is a extended version of a filter found in <a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui:_=note("<b>Configuration</b>")
#@gui:Color Space=choice(0,"RGB","RYB","CMY","CMYK","HSI","HSV","HSL","LAB","LCH","YCbCr","YCbCrGLIC","YIQ","YUV","XYZ")
#@gui:Contain Alpha?=bool(0)
#@gui:8-Bit Mode?=bool(0)
#@gui:_=separator()
#@gui:_=note("<b>Channel Order</b>")
#@gui:Channel #1=choice(0,"0","1","2")
#@gui:Channel #2=choice(1,"0","1","2")
#@gui:Channel #3=choice(2,"0","1","2")
#@gui:Channel #1=choice(0,"0","1","2","3")
#@gui:Channel #2=choice(1,"0","1","2","3")
#@gui:Channel #3=choice(2,"0","1","2","3")
#@gui:Channel #4=choice(3,"0","1","2","3")
#@gui:Channel #1=choice(0,"0","1","2","3","4")
#@gui:Channel #2=choice(1,"0","1","2","3","4")
#@gui:Channel #3=choice(2,"0","1","2","3","4")
#@gui:Channel #4=choice(3,"0","1","2","3","4")
#@gui:Channel #5=choice(4,"0","1","2","3","4")
#@gui:_=separator()
#@gui:_=note("<b>Main Texture Processing</b>")
#@gui:_=note("<i>Channel #1</i>")
#@gui:Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui:Variable#1=int(8,-512,512)
#@gui:Variable#2=int(8,-512,512)
#@gui:Variable#3=int(128,-200,200)
#@gui:Operand=choice(2,"AND","OR","XOR")
#@gui:Angle=float(0,-180,180)
#@gui:X-Flip=bool(0)
#@gui:Y-Flip=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=separator()
#@gui:_=note("<i>Channel #2</i>")
#@gui:Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui:Variable#1=int(8,-512,512)
#@gui:Variable#2=int(8,-512,512)
#@gui:Variable#3=int(128,-200,200)
#@gui:Operand=choice(2,"AND","OR","XOR")
#@gui:Angle=float(0,-180,180)
#@gui:X-Flip=bool(0)
#@gui:Y-Flip=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=separator()
#@gui:_=note("<i>Channel #3</i>")
#@gui:Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui:Variable#1=int(8,-512,512)
#@gui:Variable#2=int(8,-512,512)
#@gui:Variable#3=int(128,-200,200)
#@gui:Operand=choice(2,"AND","OR","XOR")
#@gui:Angle=float(0,-180,180)
#@gui:X-Flip=bool(0)
#@gui:Y-Flip=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=separator()
#@gui:_=note("<i>Channel #4</i>")
#@gui:Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui:Variable#1=int(8,-512,512)
#@gui:Variable#2=int(8,-512,512)
#@gui:Variable#3=int(128,-200,200)
#@gui:Operand=choice(2,"AND","OR","XOR")
#@gui:Angle=float(0,-180,180)
#@gui:X-Flip=bool(0)
#@gui:Y-Flip=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=separator()
#@gui:_=note("<i>Channel #5</i>")
#@gui:Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui:Variable#1=int(8,-512,512)
#@gui:Variable#2=int(8,-512,512)
#@gui:Variable#3=int(128,-200,200)
#@gui:Operand=choice(2,"AND","OR","XOR")
#@gui:Angle=float(0,-180,180)
#@gui:X-Flip=bool(0)
#@gui:Y-Flip=bool(0)
#@gui:Normalize=bool(1)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2018/12/19</i>.</small>")
rep_binary_quaddro_mc_gui:
cs_mode=$1
cmyk_mode={$cs_mode==3?4:3}
contain_alpha={$2?1:0}
tch={$cmyk_mode+$contain_alpha}

if $tch==3 rep_binary_alterating_quad_c $1,$2,$3,$4,$5,$6,${14-42}
elif $tch==4 rep_binary_alterating_quad_c $1,$2,$3,$7,$8,$9,$10,${15-51}
else rep_binary_alterating_quad_c $1,$2,$3,$11,$12,$13,$14,$15,${16-60}
fi
rep_binary_quaddro_mc_gui_preview:
cs_mode=$1
cmyk_mode={$1==3?4:3}
contain_alpha={$2?1:0}
tch={$cmyk_mode+$contain_alpha}
rep_binary_quaddro_mc_gui $*

set_a={$tch==3?2:0}
set_b={$tch==4?2:0}
set_c={$tch==5?2:0}
set_d={$16!=2?2:0}
set_e={$24!=2?2:0}
set_f={$34!=2?2:0}
set_g={$tch>=4?2:0}
set_h={$tch>=4?($43!=2?2:0):0}
set_i={$tch>=5?($43!=2?2:0):0}
set_j={$tch>=5?2:0}

u "{$1}"\
"{$2}"\
"{$3}_"{(($cs_mode>8&&$cs_mode<11)||$cs_mode<=3)?0:2}\
"{$4}_"$set_a\
"{$5}_"$set_a\
"{$6}_"$set_a\
"{$7}_"$set_b\
"{$8}_"$set_b\
"{$9}_"$set_b\
"{$10}_"$set_b\
"{$11}_"$set_c\
"{$12}_"$set_c\
"{$13}_"$set_c\
"{$14}_"$set_c\
"{$15}_"$set_c\
"{$16}"\
"{$17}"\
"{$18}"\
"{$19}_"$set_d\
"{$20}_"$set_d\
"{$21}"\
"{$22}"\
"{$23}"\
"{$24}"\
"{$25}"\
"{$26}"\
"{$27}"\
"{$28}_"$set_e\
"{$29}_"$set_e\
"{$30}"\
"{$31}"\
"{$32}"\
"{$33}"\
"{$34}"\
"{$35}"\
"{$36}"\
"{$37}_"$set_f\
"{$38}_"$set_f\
"{$39}"\
"{$40}"\
"{$41}"\
"{$42}"\
"{$43}_"$set_g\
"{$44}_"$set_g\
"{$45}_"$set_g\
"{$46}_"$set_h\
"{$47}_"$set_h\
"{$48}_"$set_g\
"{$49}_"$set_g\
"{$50}_"$set_g\
"{$51}_"$set_g\
"{$52}_"$set_j\
"{$53}_"$set_j\
"{$54}_"$set_j\
"{$55}_"$set_i\
"{$56}_"$set_i\
"{$57}_"$set_j\
"{$58}_"$set_j\
"{$59}_"$set_j\
"{$60}_"$set_j
#@gui Sinusoidal Water Distortion:rep_sinowaterdist_gui,rep_sinowaterdist_gui_preview(0)
#@gui:X-Balance=float(0,-100,100)
#@gui:Y-Balance=float(0,-100,100)
#@gui:Scale=float(.5,.1,100)
#@gui:Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui:Boundary Condition=choice(0,"Periodic","Mirror")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_sinowaterdist_gui:
rep_sinowaterdist $1,$2,{($3/100)*(w>h?w:h)},$4,$5
rep_sinowaterdist_gui_preview:
gui_split_preview "rep_sinowaterdist_gui $*",${-3--1}
#@gui Strange Bulger: rep_strbul,rep_strbul_preview(0)
#@gui:Angle=float(0,-180,180)
#@gui:Axis=choice(0,"X-Axis","Y-Axis")
#@gui:Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui:Boundary Condition=choice(0,"Periodic","Mirror")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_strbul_preview:
gui_split_preview "rep_strbul $*",${-3--1}
#@gui Strange Bulger Kaleidoscope:rep_strbulkal_gui,rep_strbulkal_gui_preview(0)
#@gui:_=note("This filter is a extended version of the filters named 'Strange Bulger A', and 'Strange Bulger B' found in<a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using source code for Asmageddon's tool, and then extended."),_=separator()
#@gui:Bulge Angle=float(0,-180,180)
#@gui:Axis of Bulge=choice(0,"X-Axis","Y-Axis")
#@gui:Scale=float(1,.1,10)
#@gui:Preliminary Surface Shift = point(50,50,0,1,128,128,128,255)
#@gui:Distortion Surface Position = point(50,50,0,1,255,255,255,255)
#@gui:Distortion Surface Angle=float(0,0,360)
#@gui:Placement=choice(0,"Inside-Out","Outside-In")
#@gui:Boundary Condition=choice(0,"Periodic","Mirror")
#@gui:Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui:Base Reference Dimension=int(1024,10,4096)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_strbulkal_gui:
rep_strbulkal ${1-3},{(([${4-7}]/100)-.5)*[2,-2,2,-2]},${8-10},{$11+1},$12
rep_strbulkal_gui_preview:
gui_split_preview "rep_strbulkal_gui $*",${-3--1}
#@gui Logarithmic Distortion:rep_logpindis_gui,rep_logpindis_gui_preview(0)
#@gui:_=note("This filter is a extended version of a filter found in <a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui:Distortion Factor=float(1,.1,1000)
#@gui:Preliminary Surface Shift = point(50,50,0,1,128,128,128,255)
#@gui:Distortion Surface Position = point(50,50,0,1,255,255,255,255)
#@gui:Preliminary X-Axis Scaling=float(1,.1,10)
#@gui:Preliminary Y-Axis Scaling=float(1,.1,10)
#@gui:Effect X-Axis Scaling=float(1,.1,10)
#@gui:Effect Y-Axis Scaling=float(1,.1,10)
#@gui:Distortion Surface Angle=float(0,0,360)
#@gui:Placement=choice(0,"Inside-Out","Outside-In")
#@gui:Logarithmic Distortion Axis Combination for X-Axis=choice(0,"Different Axis","Same Axis")
#@gui:Logarithmic Distortion Axis combination for y-Axis=choice(0,"Different Axis","Same Axis")
#@gui:Logarithmic Distortion X-Axis Direction=choice(0,"Negative","Positive")
#@gui:Logarithmic Distortion Y-Axis Direction=choice(0,"Negative","Positive")
#@gui:Boundary Condition=choice(0,"Periodic","Mirror")
#@gui:Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui:Base Reference Dimension=int(1024,10,4096)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_logpindis_gui:
rep_logpindis $1,{(($2/100)-.5)*2},{(($3/100)-.5)*-2},{(($4/100)-.5)*2},{(($5/100)-.5)*-2},${6-18}
rep_logpindis_gui_preview:
gui_split_preview "rep_logpindis_gui $*",${-3--1}
#@gui Squareroot - Logarithmic Distortion:rep_sqrlogpindis_gui,rep_sqrlogpindis_gui_preview(0)
#@gui:_=note("This filter is a extended version of a filter found in <a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui:Distortion Factor=float(1,.1,1000)
#@gui:Preliminary Surface Shift = point(50,50,0,1,128,128,128,255)
#@gui:Distortion Surface Position = point(50,50,0,1,255,255,255,255)
#@gui:Preliminary X-Axis Scaling=float(1,.1,10)
#@gui:Preliminary Y-Axis Scaling=float(1,.1,10)
#@gui:Effect X-Axis Scaling=float(1,.1,10)
#@gui:Effect Y-Axis Scaling=float(1,.1,10)
#@gui:Distortion Surface Angle=float(0,0,360)
#@gui:Placement=choice(0,"Inside-Out","Outside-In")
#@gui:Logarithmic Distortion Axis Combination for X-Axis=choice(0,"Different Axis","Same Axis")
#@gui:Logarithmic Distortion Axis combination for y-Axis=choice(0,"Different Axis","Same Axis")
#@gui:Logarithmic Distortion X-Axis Direction=choice(0,"Negative","Positive")
#@gui:Logarithmic Distortion Y-Axis Direction=choice(0,"Negative","Positive")
#@gui:Boundary Condition=choice(0,"Periodic","Mirror")
#@gui:Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui:Base Reference Dimension=int(1024,10,4096)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_sqrlogpindis_gui:
rep_sqrlogpindis $1,{(([${2-5}]/100)-.5)*[2,-2,2,-2]},${6-16},{$17+1},$18
rep_sqrlogpindis_gui_preview:
gui_split_preview "rep_sqrlogpindis_gui $*",${-3--1}
#@gui Stitch Distort: fx_rep_stitch,fx_rep_stitch_preview
#@gui:_=note("<b>Main</b>")
#@gui:Offset by Half-Image-Diagonal(%)=float(5,-100,100)
#@gui:Strip Thickness(%)=float(1,0,75)
#@gui:Modulo=int(0,0,128)
#@gui:Modulo Boundary=choice(0,"Periodic","Continuous")
#@gui:Image Boundary=choice(3,"None","Neumann","Periodic","Mirror")
#@gui:Offset Mode=choice(0,"Single Iteration of Randomization","Multiple Iteration of Randomization")
#@gui:Strip Mode=choice(0,"None","Single Iteration of Randomization","Multiple Iteration of Randomization")
#@gui:Offset Seed=int(128,0,255)
#@gui:Strip Seed=int(128,0,255)
#@gui:_=separator(),_=note("<b>Rendering</b>")
#@gui:Subpixel Processing Level=float(1,0,2)
#@gui:Interpolation=choice(4,"Nearest","Average","Linear","Bicubic","Lanczos")
#@gui:_=separator(),_=note("<b>Angles</b>")
#@gui:Angles Mode=choice(1,"Non-Symmetrical","Symmetrical")
#@gui:Start Angle=float(0,-180,180)
#@gui:Number of Angles=int(2,2,12)
#@gui:Number of Angles=int(2,1,12)
#@gui:Angle #1=float(45,-180,180)
#@gui:Angle #2=float(-45,-180,180)
#@gui:Angle #3=float(90,-180,180)
#@gui:Angle #4=float(0,-180,180)
#@gui:Angle #5=float(60,-180,180)
#@gui:Angle #6=float(-60,-180,180)
#@gui:Angle #7=float(15,-180,180)
#@gui:Angle #8=float(-15,-180,180)
#@gui:Angle #9=float(30,-180,180)
#@gui:Angle #10=float(-30,-180,180)
#@gui:Angle #11=float(5,-180,180)
#@gui:Angle #12=float(-5,-180,180)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2022/4/16</i>.</small>")
fx_rep_stitch:
if $12 angles={expr('$13+x/w*180',$14);}
else angles={([${16-27}])[0,$15]}
fi

cli_args=$1%,$2%,{$3>1?($4?-$3:$3)},${6-9},$5,${10-11},$angles

rep_stitch $cli_args

u "rep_stitch "$cli_args
fx_rep_stitch_preview:
gui_split_preview "fx_rep_stitch ${1-27}",${-3--1}
more_than_one_ang=!$12?$15>1:1

if !$12
 +rep_find_nonduplicate_angles {([${16-27}])[0,$15]}
 if w#-1==1 more_than_one_ang=0 fi
 rm.
fi

activate_nonsym:=$12*2
activate_sym:=!$activate_nonsym*2

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{($3>1)+1}\
"{$5}"\
"{$6}_"{($more_than_one_ang?1)+1}\
"{$7}_"{($more_than_one_ang?1)+1}\
"{$8}"\
"{$9}_"{($more_than_one_ang&&$7?1)+1}\
"{$10}"\
"{$11}_"{($10?1)+1}\
"{$12}"\
"{$13}_"$activate_nonsym\
"{$14}_"$activate_nonsym\
"{$15}_"$activate_sym\
"{$16}_"{2*($activate_sym&&$15>0)}\
"{$17}_"{2*($activate_sym&&$15>1)}\
"{$18}_"{2*($activate_sym&&$15>2)}\
"{$19}_"{2*($activate_sym&&$15>3)}\
"{$20}_"{2*($activate_sym&&$15>4)}\
"{$21}_"{2*($activate_sym&&$15>5)}\
"{$22}_"{2*($activate_sym&&$15>6)}\
"{$23}_"{2*($activate_sym&&$15>7)}\
"{$24}_"{2*($activate_sym&&$15>8)}\
"{$25}_"{2*($activate_sym&&$15>9)}\
"{$26}_"{2*($activate_sym&&$15>10)}\
"{$27}_"{2*($activate_sym&&$15>11)}\
"{$28}"\
"{$29,$30}"
#@gui Kaleidoscope [Reptorian-Polar]:gui_rep_polkal,gui_rep_polkal
#@gui:Angle Cut=float(2,.01,100)
#@gui:Radius Cut=float(1,.01,100)
#@gui:Surface Angle=float(0,-180,180)
#@gui:Center (%)=point(50,50)
#@gui:Flip Angle Direction?=bool(0)
#@gui:Flip Radial Direction?=bool(0)
#@gui:Angle Edge Behaviour=choice(1,"Repeat","Alternating")
#@gui:Radial Edge Behaviour=choice(2,"None","Repeat","Alternating")
#@gui:Fit Radial End to Min/Max Dimension=choice(0,"Minimum Dimension","Maximum Dimension")
#@gui:Conical Start at 0?=bool(1)
#@gui:_=note("<small>Conical start is only used for matching other software filter behavior with conical gradients</small>")
#@gui:_=separator()
#@gui:Sublevel=float(.5,0,3)
#@gui:Interpolation=choice(2,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/9/7</i>.</small>")
gui_rep_polkal: rep_polkal ${1-3},{($4-50)*2}%,{($5-50)*-2}%,${6--1}
#@gui Object Size Filtering: gui_rep_objvf,gui_rep_objvf_preview(0)
#@gui:Mode of Object Filtering=choice(0,"Auto","Alpha","Colour")
#@gui:Threshold for Auto-Mode Switching(%)=float(10,0,100)
#@gui:_=separator(),_=note("<b>Object Filtering Options</b>")
#@gui:Volume 1 (%)=float(1,0,100)
#@gui:Volume 2 (%)=float(99,0,100)
#@gui:Preserve=choice(0,"Inclusive","Exclusive")
#@gui:Preserve=choice(0,"Inclusive by Secondary Max Area","Exclusive by Secondary Max Area")
#@gui:Use Secondary Maximum Area?=bool(0)
#@gui:Colour=color(0,0,0,0)
#@gui:_=separator(),_=note("<b>Preview Settings</b>")
#@gui:Reveal Erased Objects?=bool(1)
#@gui:Colour of Erased Object=color(127,127,127)
#@gui:Render Mode=choice(0,"Main","Removed Alpha Mode","Alpha Details")
#@gui:List Percentiles?=bool(0)_0
#@gui:_=separator(),_=note("<b>-Instruction-</b>\n\nThe purpose of this filter is to filter objects based on their volume. It is based on the principle of the <a href="https://forums.getpaint.net/topic/113962-object-pruner/">Object Pruner plugin</a> for Paint.NET made by <b>MJW</b>.\n\n<b>Note:</b> Use Colour Mode for fully opaque image.\n<b>Alternative Note:</b> Use Colour Mode with Alpha or Auto.\n\n<b>Special Note:</b> If you're seeing error, switch the render mode and pick the colors until error no longer show up on Main Render Mode.Sometimes changing Mode of Object Filtering can resolve it.\n----\n<b>Warning:</b> Untested on GIMP!")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/2/21</i>.</small>")
gui_rep_objvf:
if $7 preserve_choice={($6+1)*-1}
else preserve_choice=$5
fi

if !$1

 foreach {
  colour={vectors(${8-11})}

  if s==2||s>3

   ss={s-1}
   colour={vector$ss(${8-11})}
   sh {s-1}
   maxalp={iM#-1}
   +f. i#-1?1
   sumnalp={1-(is#-1/wh#-1)}
   rm.

   if $sumnalp>$2%
    rm.
    rep_objvf $3%,$4%,$preserve_choice
   else
    if !iv#-1
     alp=$maxalp
    else
     alp=0
    fi
    rm.
    rep_objvf $3%,$4%,$preserve_choice,$colour,$alp
   fi

  else

   colour={vectors(${8-11})}
   rep_objvf $3%,$4%,$preserve_choice,$colour

  fi
 }

elif $1==1
 rep_objvf $3%,$4%,$preserve_choice
else
 colour={vectors(${8-11})}
 rep_objvf $3%,$4%,$preserve_choice,$colour
fi
gui_rep_objvf_preview:
show_colour,current_layer=0

if !$1

 do

  local[$current_layer] {
   if s==2||s>3
    {w},{h},100%,1,i(#-1,x,y,z,s-1)?1
    sumnalp={1-(is#-1/wh#-1)}
    if $1>$2% show_colour=1 fi
    rm.
   fi
  }

  current_layer+=1
 while !$show_colour&&$current_layer<$!

elif $1==2 show_colour=1
fi

if $16==2 channels {s-1}
elif $16==1 channels 0,{s-2}
else

 if $12
  +gui_rep_objvf ${1-11}
  f begin(ss={s-1};);if(i(x,y,z,ss),i,0);
  f.. I!=I#-1?[${13-15},255]:I
 else
  gui_rep_objvf ${1-11}
 fi

fi

u "{$1}"\
"{$2}"_{!$1?2:0}\
"{$3}"\
"{$4}"\
"{$5}"_{!$7?2:0}\
"{$6}"_{$7?2:0}\
"{$7}"\
"{$8,$9,$10,$11}"_{$show_colour?2:0}\
"{$12}"_{!$16?2:1}\
"{$13,$14,$15}"_{($12&&!$16)?2:1}\
"{$16}"\
"{$17}"_0
#@gui Tiled Form:gui_rep_form_pixel,gui_rep_form_pixel_preview
#@gui:_=note("<b>Colour Space Processing</b>")
#@gui:Colour Space=choice(0,"RGB","RYB","CMYK","HCY","HSI","HSL","HSV","LAB","LCH")
#@gui:_=separator(),_=note("<b>Tile Shape</b>")
#@gui:Tiled Shape=choice(3,"By Layer","Australia","Barbedwire","Circle","Crosshair","Cupid","Diamond","Dragon Curve-[D]","Dragonfly","Fern-[D]","Flip","Gear-[D]","Gumleaf","Heart","Information","Kookaburra","Mail","Mapleleaf","Paint Splat","Paw","Phone","Polygon-[D]","Rooster","Shopping Cart","Snowflake-[D]","Star-[D]")
#@gui:Reverse Layer=bool(0)
#@gui:_=note("<small>For the first option, you must use at least 2 layer to use layer as shape reference, else it'll use the only image itself as shape reference. Reverse Layer option might have to be used to generate the proper result when using first option.</small>")
#@gui:_=separator(),_=note("<b>Tiles</b>")
#@gui:Shape Width (px)=int(30,0,512)
#@gui:Shape Height (px)=int(30,0,512)
#@gui:Shape Ratio (%)=float(100,5,100)
#@gui:Shape Rotation=float(0,-180,180)
#@gui:Shape Mirror Axis=choice(0,"None","X","Y")
#@gui:Subpixel Level=float(.5,0,2)
#@gui:Z-Convolution Factor (%)=float(50,0,200)
#@gui:Z-Convolution Boundary=choice(0,"Neumann","Periodic")
#@gui:Interpolation=choice(5,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui:Tile Boundary=choice(0,"Periodic","Mirror - X","Mirror - Y","Mirror - XY")
#@gui:Preprocess Boundary=choice(2,"Neumann","Periodic","Mirror")
#@gui:Fit Tile?=bool(1)
#@gui:Output=choice(0,"New Dimension","New Dimension - New Layer","Old Dimension","Old Dimension - New Layer")
#@gui:_=note("<b>If using Krita and New Layer option, then you may have to reorder one layer.</b>")
#@gui:_=separator(),_=note("<b>Dynamic Shape</b>")
#@gui:Dragon Curve Recursion=int(10,0,30)
#@gui:Dragon Curve Rotation=float(0,-180,180)
#@gui:Fern Type=choice("Asplenium Adiantum-Nigrum","Thelypteridaceae")
#@gui:Fern Density (%)=float(100,0,300)
#@gui:Gear Teeth Count=int(8,3,32)
#@gui:Gear Height (%)=float(25,0.1,100)
#@gui:Gear Offset Teeth (%)=float(0,0,100)
#@gui:Gear Inner Ratio (%)=float(50,0.1,100)
#@gui:Polygon Vertices=int(5,3,100)
#@gui:Snowflake Recursion=int(5,1,6)
#@gui:Star Branches=int(3,5,100)
#@gui:Star Thickness (%)=float(38,.1,100)
#@gui:_=note("<small>Dynamic Shapes Options are only visible for dynamic shapes!</small>")
#@gui:_=separator(),_=note("Original idea comes from <a href="https://forums.getpaint.net/topic/26758-trs-tiled-pixels-v12/">TR's Tiled Pixels V1.2</a> plugin by <b>TechnoRobbo</b> for Paint.NET. This version is a extended version utilizing weighted average sampling per area per tile, boundary option, anti-aliasing, dynamic shape, color space,and transformation. Dynamic shapes are also supported by this filter.")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/15</i>.</small>")
gui_rep_form_pixel:
use_dynamic=0
ti={$!}

if $3 rv fi

if $2==7
 form_id=dragon
 form_var=${17-18}
 use_dynamic=1
elif $2==9
 form_id=fern
 form_var=$20%,0,1,$19
 use_dynamic=1
elif $2==11
 form_id=gear
 form_var=${21-24}
 use_dynamic=1
elif $2==21
 form_id=polygon
 form_var=$25
 use_dynamic=1
elif $2==24
 form_id=snowflake
 form_var=$26
 use_dynamic=1
elif $2==25
 form_id=star
 form_var=$27,{$28/100}
 use_dynamic=1
else
 form_id={$2-1}
fi

if !$2
 if $ti==1 . fi
 rep_form_pixel[^0] [0],${4-5},$6%,${7-9},${13-14},$10%,${11-12},$1,${15-16}
else
 if $use_dynamic
  rep_form_pixel $form_id,${4-5},$6%,${7-9},${13-14},$10%,${11-12},$1,${15-16},$form_var
 else
  rep_form_pixel $form_id,${4-5},$6%,${7-9},${13-14},$10%,${11-12},$1,${15-16}
 fi
fi

if !$2 rv fi

if same('$_host','paintdotnet')&&!$2 rm[0] fi
gui_rep_form_pixel_preview:
if $3 rv fi

if !$2
 if $!==1 +store _ref
 else store[0] _ref
 fi
fi

if $3 rv fi

if !$2
 if $!==1 +store _ref
 else store[0] _ref
 fi
fi

gui_split_preview "if !$2 $_ref rv fi gui_rep_form_pixel ${1-28}",${-3--1}

set_a={$2==7?2}
set_b={$2==9?2}
set_c={$2==11?2}
set_d={$2==25?2}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}_"{$10?2:1}\
"{$12}"\
"{$13}"\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}_"$set_a\
"{$18}_"$set_a\
"{$19}_"$set_b\
"{$20}_"$set_b\
"{$21}_"$set_c\
"{$22}_"$set_c\
"{$23}_"$set_c\
"{$24}_"$set_c\
"{$25}_"{$2==21?2}\
"{$26}_"{$2==24?2}\
"{$27}_"$set_d\
"{$28}_"$set_d\
"{$29}"\
"{$30,$31}"
#@gui Color Existence Distribution [RGB-8]:rep_color_existence_distribution_rgb8,rep_color_existence_distribution_rgb8
#@gui:_=note("This filter is used to find colors that does or does not exist within a image.\n\n For <b>Paint.NET users</b>, please refer to this tutorial named <a href="https://forums.getpaint.net/topic/115124-finding-millions-of-colors-that-does-or-does-not-exist-gmic-qt-tutorial/?tab=comments#comment-562927">Finding millions of colors that does or does not exist - G'MIC QT Tutorial</a>")
#@gui:sep separator()
#@gui:Set of Color(s)=choice(1,"Nonexistent Colors","Existing Colors")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/9/20</i>.</small>")
#@gui Reverse Engineer Gradient Map: gui_rep_regm, gui_rep_regm_preview(0):+
#@gui:_=note("Reverse engineer gradient map. You must export, and then import to your program of choice!"),_=separator()
#@gui:_=note("<b>Processing</b>")
#@gui:Gradient Thickness=int(10,1,100)
#@gui:Use first layer?=bool(1)
#@gui:Normalize?=bool(0)
#@gui:_=separator(),_=note("<b>Export</b>")
#@gui:Folder=folder()
#@gui:Filename=text("gradient.png")
#@gui:Export Gradient=button()
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Preview all gradient at once?=bool(1)
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/27</i>.</small>")
gui_rep_regm: error "Use Export Button to export gradient! This filter does nothing on host!"
gui_rep_regm_preview:
filename="$4/$5"

if $2 mv. 0 fi

if $6
 rep_reverse_engineer_gradient_map 256,$3
 r 100%,$1
 o $filename
 remove_opacity to "Exported!",.5~,.5~,50%,2,255
else
 rep_reverse_engineer_gradient_map 256,$3
 r 100%,$1
 if $7 a y fi
fi

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{0}"\
"{$7}"
#@gui Reverse Engineer Color Curve: gui_rep_recc, gui_rep_recc_preview(0):+
#@gui:_=note("Reverse engineer color curves map. You must export, and then import to your program of choice!"),_=separator()
#@gui:_=note("<b>Processing</b>")
#@gui:Gradient Thickness=int(10,1,100)
#@gui:Use first layer?=bool(1)
#@gui:_=separator(),_=note("<b>Export</b>")
#@gui:Folder=folder()
#@gui:Filename=text("gradient.png")
#@gui:Export Gradient=button()
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Preview all gradient at once?=bool(1)
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/1/2</i>.</small>")
gui_rep_recc: error "Use Export Button to export color curve map! This filter does nothing on host!"
gui_rep_recc_preview:
filename="$3/$4"
remove_opacity
if $2 mv. 0 fi

if $5
 rep_recc 256
 r 100%,$1
 o $filename
 to "Exported!",.5~,.5~,50%,2,255
else
 rep_recc 256
 r 100%,$1
 if $6 a y fi
fi

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{0}"\
"{$6}"
#@gui Autofill Coloring Book :gui_rep_acb,gui_rep_acb_preview(0)
#@gui:_=note("This filter is specifically designed to autofill areas with random colors that only appear once.\n\n<b>Don't trust the preview for colors, test the result first!</b>")
#@gui:_=separator()
#@gui:Line Threshold=int(180,1,254)
#@gui:Dilate/Erode=int(0,-3,3)
#@gui:Line Mode=choice(1,"Hard","Soft")
#@gui:Alpha Threshold=int(0,0,254)
#@gui:Coloring Seed=int(250000,0,500000)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
gui_rep_acb: rep_acb {$1/255},$2,$3,{$4/255},$5
gui_rep_acb_preview:
gui_split_preview "gui_rep_acb $*",${-3--1}
#@gui __<b>Rendering</b>
#@gui Thorn Fractal - Secant Sea:gui_rep_tfrac,gui_rep_tfrac_preview
#@gui:_=note("Thorn Fractal is the fractal attributed to Andrew Wayne Graff, alternatively named the "Secant Sea".\nThe code was adapted from <a href="http://paulbourke.net/fractals/thorn/thorn_code.c">Sample C source code</a> provided by Adam Majewski.\n\nDocumentation - <a href="http://paulbourke.net/fractals/thorn/#dane">Thorn Fractal</a> by <a href="http://paulbourke.net/fractals/">Paul Bourke</a>\n\nAlternating Chaos formula are made by <a href="https://forums.getpaint.net/profile/45895-madjik/">MadJik</a>, and they are originally used in <a href="https://forums.getpaint.net/topic/111491-fractal-attractor-ymd170628/">Fractal Attractor</a> plugin for Paint.NET software."), _=separator()
#@gui:_=note("<b>Style Setting</b>")
#@gui:Predefined Formula=choice(0,"Normal","Normal Inverted","Arctangent","Tangent","Tanh Stroke","Asymphological Vibrato","Asymphological Basic","Asymphological Basic 2","Asymphochaos","Petallian","Semi-Thorny Petallian","Thorny Petal 1","Thorny Petal 2","Inflation","Inflation 2","Chaotic Creation","Earthing","Acrylic Earthing","Unearthing Origami","Cubic Unearthing","Webbing Cubic Unearthing","Chaotic Hooks Unearthing","Chaotic Hooks","Sinusoidal Liquid","Cosinusoidal Liquid","Echo Wide","Echo Squircle","Echo Hall","Echo Hall 2","Liquid Parabolic","Chaos-Vibrato","Chaos Deep-Vibrato","Chaos Spacetime","Parabolic","Parabolic Chaos","Cubic-Diamond Chaos","C-Line","Contour Chaos","Spiderweb-Diamond","Acrylica","Refractive Space","Smooth-Artistry","Ferrofluid","Triangular Interweaving","Fabric Chaos","Reverse Tangent Division","Chaotic Tangent","Alternating Chaos 0","Alternating Chaos 1 [Legacy]","Alternating Chaos 2 [Legacy]","Alternating Chaos 3 [Legacy]","Alternating Chaos 4 [Legacy]","Alternating Chaos 5 [Legacy]","Alternating Chaos 1","Alternating Chaos 2","Alternating Chaos 3","Alternating Chaos 4","Alternating Chaos 5")
#@gui:Custom Formula=choice(0,"None","Custom Formula","Alternating Custom Formula Level 1","Alternating Custom Formula Level 2","Alternative Custom Formula Level 3","Alternating Custom Formula Level 4")
#@gui:_=separator()
#@gui:_=note("<b>Fractal Calculation Constraints</b>")
#@gui:_=note("<small>Information at bottom of filter. Some predefined formulas requires you to use low values. You may need to type in values from 5-1024 manually.</small>")
#@gui:Escape Value=int(10000,5,3000000)
#@gui:Loop Limitation=int(255,1,1024)
#@gui:Subsampling Level=float(3,1,10)
#@gui:_=separator(),_=note("<b>Distortion Factors</b>")
#@gui:Distortion X-[dx]=float(0,-50,50)
#@gui:Distortion Y-[dy]=float(0,-50,50)
#@gui:_=separator(),_=note("<b>Transformations</b>"),_=note("- Scaling -")
#@gui:Scaling XY-Axis=float(1,.01,15)
#@gui:Scaling X-Axis=float(1,.01,15)
#@gui:Scaling Y-Axis=float(1,.01,15)
#@gui:PI-Based Scaling=bool(1)
#@gui:_=separator(),_=note("- Displacement -")
#@gui:Offset X-Transformation=float(0,-5,5)
#@gui:Offset Y-Transformation=float(0,-5,5)
#@gui:_=separator(),_=note("- Rotation -")
#@gui:Function Angle=float(0,-180,180)
#@gui:_=separator(),_=note("<b>Custom Formula</b>)
#@gui:_=note("<small>See bottom of this filter to see instruction of usage</small>")
#@gui:Custom A-X-[vx]=text{a/sin(b)}
#@gui:Custom A-Y-[vy]=text{b/cos(a)}
#@gui:Custom B-X-[vx]=text{sin(a)/cos(b)}
#@gui:Custom B-Y-[vy]=text{b/cos(a)}
#@gui:Custom C-X-[vx]=text{a/sin(b)}
#@gui:Custom C-Y-[vy]=text{b/cos(a+b)}
#@gui:Custom D-X-[vx]=text{a}
#@gui:Custom D-Y-[vy]=text{b}
#@gui:Custom E-X-[vx]=text{a}
#@gui:Custom E-Y-[vy]=text{b}
#@gui:_=separator(), _=note("- Overload -")
#@gui:Activate Overload Functions=bool(0)
#@gui:Enable CFA/CFB* Formulas for OVX and OVY formulas?=bool(1)
#@gui:Overload X=text{a/(cfb*cos(b))}
#@gui:Overload Y=text{b/(cfa*sin(a))}
#@gui:CFA-[cfa]=text{cos(vx)/tan(vx)}
#@gui:CFB-[cfb]=text{sin(vy)/tan(vy)}
#@gui:Overload Count**=int(1,1,4)
#@gui:Use Negative Overload=bool(0)
#@gui:_=note("<small>*=cfa and cfb must be lowercase when using in overload formula!\n\n**=Negative Overload Count utilize last vector number rather than second last to find cfa,cfb.</small>")
#@gui:_=separator(),_=note("<b>Colour Setting</b>)
#@gui:Fractal Mapping=choice(0,"Grayscale","Hue","Random Color Map")
#@gui:Colours=int(3,3,8)
#@gui:Colour Generation Seed=int(0,0,5000)
#@gui:_=separator(),_=note("<b>Information of Thorn Fractal - Secant Sea filter</b>"),_=separator(), _=note("<i>Fractal Calculation Constraints</i>\n\n<b>Escape Value</b> defines the minimum value to escape from the loop used to determine the amount of iteration needed to be bigger than the specified value per pixels. The lower the value, the more contrast at a sacrifise of details.\n\n<b>Iterations</b> defines the maximum possible amount of loop per pixels when escape value is not reached. The lower the value, the more contrast and the more posterization of values.\n\n<b>Subsampling Level</b> is used to alter the dimensions before calculation of fractal, and it is resized to the original dimension after the fractal has been generated. The bigger the value, the more computationally intensive it is. In fact, this has the most consistent impact on performance."), _=separator(),_=note("<i>Custom Formula</i>\n\nTo use this, type in a formula utilizing the syntax given by the G'MIC reference manual. Use notes given the information provided below.\n\nMultiple expressions are supported, and they are separated by \";\" character. If it the only expression, then it would be used for calculation of vx or vy. Otherwise, the first expression may be the only one used for calculation of vx or vy.\n\n<i>Available variables - </i> v,vx,vy,dx,dy,a,b,cfa,cfb\n\n<b>v</b> - Iteration number within Thorn Fractal.\n\n<b>vx</b> - Output of distortion function for x-axis.\n\n<b>vy</b> - Output of distortion function for y-axis.\n\n<b>dx</b> - Distortion-X Number.\n\n<b>dy</b> - Distortion-Y Number.\n\n<b>a</b> - Value of <b>a</b> is given by vx equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.\n\n<b>b</b> - Value of <b>b</b> is given by vx equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.\n\n<b>cfa</b> - Output of <b>CFA</b> function. Useful if and only if using overload function.\n\n<b>cfb</b> - Output of <b>CFB</b> function. Useful if and only if using overload function.")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/6/13</i>.</small>")
gui_rep_tfrac:
srand $35

if !$2 rep_thorn_fractal $1,${3-14}
else

 if $2==1   formulas="$15","$16"
 elif $2==2 formulas="$15","$16","$17","$18"
 elif $2==3 formulas="$15","$16","$17","$18","$19","$20"
 elif $2==4 formulas="$15","$16","$17","$18","$19","$20","$21","$22"
 elif $2==5 formulas="$15","$16","$17","$18","$19","$20","$21","$22","$23","$24"
 fi

 if $25
  if $26 rep_thorn_fractal {-1*$2},${3-14},$formulas,"$27","$28","$29","$30",{$31*($32?-1:1)}
  else rep_thorn_fractal {-1*$2},${3-14},$formulas,"$27","$28",{$31*($32?-1:1)}
  fi
 else rep_thorn_fractal {-1*$2},${3-14},$formulas
 fi

fi

if $33==0 n 0,255
elif $33==1 n 0,360 r 100%,100%,100%,3 f [i0,1,1] hsv2rgb
else n 0,1 $34,1,1,1 f. u(x/w#-1,(x+1)/w#-1) n. 0,16777215 r. 100%,100%,1,3 f. [i0-256*floor(i0/256),floor(i0/256)-256*floor(floor(i0/256)/256),i0/(256^2)] r. 4096,1,100%,100%,5 r[^-1] 100%,100%,100%,3 f[^-1] i(#-1,i0*w#-1,0,z,c,2) rm.
fi

gui_rep_tfrac_preview:
gui_rep_tfrac ${1-14},"$15","$16","$17","$18","$19","$20","$21","$22","$23","$24",$25,$26,"$27","$28","$29","$30",${31-35}

set_a={$2>=1?2:0}
set_b={$2>=2?2:0}
set_c={$2>=3?2:0}
set_d={$2>=4?2:0}
set_e={$2>=5?2:0}
set_f={$2?($25&&abs($31)?2:1)}
set_g={$2?($26&&abs($31)?($25?2:1):1)}
set_h={$2?($25?2:1)}
set_i={$33==2?2:0}

u "{$1}_"{!$2?2:1}\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}"\
"{$15}_"$set_a\
"{$16}_"$set_a\
"{$17}_"$set_b\
"{$18}_"$set_b\
"{$19}_"$set_c\
"{$20}_"$set_c\
"{$21}_"$set_d\
"{$22}_"$set_d\
"{$23}_"$set_e\
"{$24}_"$set_e\
"{$25}_"{$2?2}\
"{$26}_"$set_f\
"{$27}_"$set_f\
"{$28}_"$set_f\
"{$29}_"$set_g\
"{$30}_"$set_g\
"{$31}_"$set_h\
"{$32}_"$set_h\
"{$33}"\
"{$34}_"$set_i\
"{$35}_"$set_i
rep_generate_thorn_fractal_expression_generator:

# Dear Reptorian,
#  If you are reading this, this means that you left this note.
#
#  This is for generation of custom formula of Thorn Fractal. So when you get to it, remove this note.
#
# Thank you for reading,
#   Reptorian

v1,v2,started=0
previous_r_choice=-1

if u<.5 status a symbol,mode=a,0
else    status b symbol,mode=b,1
fi

do
 v2+=1

 if u<$v1||$v2>6
  if $started break fi
 else
  v1:=$v1+u(-.2,.2)
  r:=u(13.1)

  r_choice:=v(0,4,1,0)

  if $r_choice==$previous_r_choice
   if u<.5 r_choice=($r_choice+1)%4
   else    r_choice=($r_choice-1)%4
   fi
  fi

  if $mode symbol,mode=a,0
  else     symbol,mode=b,1
  fi

  if $r<1     status cos(${})
  elif $r<2   status sin(${})
  elif $r<3   status tan(${})
  elif $r<4   status logabs(${})
  elif $r<5   status norm(${},$symbol)
  elif $r<6   status sqr(${})
  elif $r<7   status ${}/${arg0\ $r_choice,cos($symbol),sin($symbol),tan($symbol),logabs($symbol)}
  elif $r<8   status ${}*${arg0\ $r_choice,cos($symbol),sin($symbol),tan($symbol),logabs($symbol)}
  elif $r<9   status ${}+${arg0\ $r_choice,cos($symbol),sin($symbol),tan($symbol),logabs($symbol)}
  elif $r<10  status ${}-${arg0\ $r_choice,cos($symbol),sin($symbol),tan($symbol),logabs($symbol)}
  elif $r<11  status ${arg0\ $r_choice,cos($symbol),sin($symbol),tan($symbol),logabs($symbol)}/${}
  elif $r<12  status abs(${})
  elif $r<13  status avg($symbol,${})
  else        status (${})
  fi

  previous_r_choice=$r_choice
  started=1
 fi

while !((u<$v1&&$v2>1)||$v2>6)

('${}')

fill[-1] >"begin(
  const _a=_'a';
  const _b=_'b';
  separators='(,)';
  mode=0;
  old_char=0;
  previous_a_b_char=0;
 );
 if(isin(i,_a,_b),
  back_char=j(-1);
  front_char=j(1);
  if((back_char==separators[0]||back_char==separators[1])&&(front_char==separators[1]||front_char==separators[2]),
   mode?(
    check_with_previous_a_b_char=i==previous_a_b_char;
    if(check_with_previous_a_b_char,
     if(i==_a
     ,previous_a_b_char=_b;_b;
     ,previous_a_b_char=_a;_a;
     );
    ,previous_a_b_char=i;i;
    );
   ):(
    mode=1;
    previous_a_b_char=i;
    i;
   );
  ,i);
 ,i);
 "

out={t}

remove[-1]
status $out
#@gui _<b>Testing</b>
#@gui <i>Reptorian</i>
#@gui Z-Time:rep_z_render:*
#@gui:_=note("Z-Time Rendering is a filter that utilize the value of a layer to represent the frame where frames are interpolated and normalized to the value of that layer. In other word, the reference layer can be seen as a representative of time.<b>Note:</b>Try to use a gradient for top or bottom layer depending on option you use.\n\n<b>Z-Depth Values</b> is recommended to be altered when using float image as reference. Use values less than 255 in order to posterize.\n\n<b>This filter do not work with Paint.NET as you need 3 images!</b>"), _=separator()
#@gui:Layer to use as time reference?=choice(0,"Top Layer","Bottom Layer")
#@gui:Z-Depth Values=int(255,3,1024)
#@gui:Mirror Frame Ordering?=bool(0)
#@gui:Separate time by channels?=bool(0)
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/10/13</i>.</small>")
#@gui Bricks: gui_rep_shape_brick
#@gui:_=note("This filter on the <a href="https://forums.getpaint.net/topic/8251-bricks-updated-with-examples/">Bricks plugin for Paint.NET</a> made by <a href="https://forums.getpaint.net/profile/49909-jchunn/">Jesse Chunn</a> as part of his <a href="https://forums.getpaint.net/index.php?/topic/8408-jesse-chunn-plugin-pack-march-8-2008/">plugin pack</a>.\n\n This is a extended version of the bricks filter with bevel options, and blending mode option.")
#@gui:_=separator(),_=note("<b>Brick Main Setting</b>")
#@gui:Brick Width (px)=int(150,4,2048)
#@gui:Brick Height (px)=int(150,4,2048)
#@gui:Mortar Width (px)=int(5,0,512)
#@gui:Mortar Height (px)=int(5,0,512)
#@gui:Outline (px)=int(0,0,50)
#@gui:_=separator(),_=note("<b>Offset Setting</b>)
#@gui:Brick Offset (%)=float(0,-100,100)
#@gui:Offset Direction=choice(0,"Horizontal","Vertical")
#@gui:Reverse Offset=bool(0)
#@gui:_=separator(),_=note("<b>Bevel Setting</b>)
#@gui:Bevel Radius (px)=int(0,0,50)
#@gui:Bevel Style=choice(0,"Round","Inverse Round","Chamfer")
#@gui:_=separator(),_=note("<b>Colouring and Blending Options</b>")
#@gui:Brick Colour=color(170,0,0,255)
#@gui:Brick Outline=color(85,0,0,255)
#@gui:Mortar Colour=color(121,77,2,255)
#@gui:Use Blending Mode?=bool(0)
#@gui:Blending Mode=choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui:"difference","divide","dodge","exclusion","freeze",
#@gui:"grainextract","grainmerge","green","hardlight","hardmix",
#@gui:"hue","interpolation","lighten","lightness","linearburn",
#@gui:"linearlight","luminance","multiply","negation","or",
#@gui:"overlay","pinlight","red","reflect","saturation","screen",
#@gui:"shapeaverage","softburn","softdodge","softlight","stamp",
#@gui:"subtract","value","vividlight","xor")
#@gui:Opacity (%)=float(100,0,100)
#@gui:_=separator(),_=note("<b>Antialias</b>)
#@gui:Antialias Level=float(0,0,3)
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/10/15</i>.</small>")
gui_rep_shape_brick:

-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"

foreach {

 to_a
 rep_shape_brick $1,$2,$3,$4,$5,$9,$10,$6%,$7,$8,$26

 n. 0,1

 r. {w#-2},{h#-2},100%,{s#-2},0,2,0,0

 if $5 ($19,$15,$11^$20,$16,$12^$21,$17,$13^$22,$18,$14)
 else ($19,$11^$20,$12^$21,$13^$22,$14)
 fi

 r. {($26+1)*100}%,100%,100%,100%,3

 f.. i(#-1,(w#-1-1)*i,0,z,c,3) rm.

 if $23 blend ${_mode{$24+1}},{$25%}
 else k.
 fi

}
#@gui TR's Intense Filtering:gui_rep_trif,gui_rep_trif_preview(0)
#@gui:Hue=float(45,0,360)
#@gui:Image Coefficient (%)=float(100,0,200)
#@gui:Mix Factor (%)=float(0,0,100)
#@gui:Style Base=choice(0,"Based from Original Image","Based on Grayscale","Based on Hue")
#@gui:_=separator(),_=note("<b>Preview Setting</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<b>TR's Intense Filtration</b> is a filter that filters out colors and augment a color based on hue. The formula for the filter is created by <b>TechnoRobbo</b>. The code for this filter is based on the <a href="https://forums.getpaint.net/topic/30148-trs-intense-filtration-v-13-oct-092014/">source code</a> of <b>TechnoRobbo's Intense Filtration v1.3</b> plugin for <b>Paint.NET.</b>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/11/1</i>.</small>")
gui_rep_trif: rep_trif $1,$2%,$3%,$4
gui_rep_trif_preview: gui_split_preview "gui_rep_trif ${1-4}",${-3--1}
#@gui TR's Pixel Sharpener: gui_rep_trps,gui_rep_trps_preview(0)
#@gui:Sharpening=float(0,0,50)
#@gui:Internal Blurring=int(0,0,4)
#@gui:Blur Type=choice(0,"Photo","Horizontal","Vertical","Angle - One Axis","Angle - Two Axis","Angle - Two Axis [Disconnected]")
#@gui:Angle= float(0,-180,180)
#@gui:Angle 2= float(0,-180,180)
#@gui:Channel(s)=choice(11,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui:"Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui:"YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui:"YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui:"Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui:"HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui:"CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui:_=separator(),_=note("This is a extended filter which was based on a Paint.NET plugin that was created by <b>TechnoRobbo</b> - <a href="https://forums.getpaint.net/topic/26783-trs-pixel-sharpener-plugin-v20-dec-21-2014/">TR's Pixel Sharpener</a>")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/11/2</i>.</small>")
gui_rep_trps: ac "rep_tr_pixel_sharpener ${1-5}",$6
gui_rep_trps_preview: gui_split_preview "gui_rep_trps ${1-6}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{$3>2?2:0}\
"{$5}_"{$3>4?2:0}\
"{$6}"\
"{$7}"\
"{$8}"
#@gui Glass Vignette:gui_rep_gv, gui_rep_gv_preview(0)
#@gui:_=note("<small>Distorts images as if it is based from the view of a bulged car mirror or camera len. This G'MIC filter is a heavily extended version of <a href="https://forums.getpaint.net/topic/28355-trs-glass-vignette/">TR's Glass Vignette</a> plugin made by TechnoRobbo for Paint.NET. It can also be used for generating abstract art as well.</small>"), _=separator()
#@gui:_=note("<b>Refraction Settings</b>")
#@gui:Refraction (%)=float(100,-200,200)
#@gui:Refraction Power (%)=float(0,-200,200)
#@gui:Len Size (%)=float(100,25,200)
#@gui:Chromatic Aberration (%)=float(0,-100,100)
#@gui:_=separator(),_=note("<b>Transformations Settings</b>")
#@gui:_=note("<small><i>Preliminary Image Transformations</i></small>")
#@gui:Preliminary Image Shift=point(50,50,0,1,128,128,128,255)
#@gui:Image Additional Zoom (%)=float(0,0,500)
#@gui:Image Angle=float(0,-180,180)
#@gui:_=separator(),_=note("<small><i>Distortion Transformations</i></small>")
#@gui:Distortion Scale by X-Axis (%)=float(100,0,1000)
#@gui:Distortion Scale by Y-Axis (%)=float(100,0,1000)
#@gui:Distortion Scale by XY-Axis (%)=float(100,0.01,500)
#@gui:Distortion Angle=float(0,-180,180)
#@gui:Distortion Offset=point(50,50,0,1,255,255,255,255)
#@gui:_=note("<small><i>When Distortion Scale by X-Axis and/or Y-Axis is 0, then distortion will be based on image ratio.</i></small>")
#@gui:_=separator(),_=note("<b>Processing Settings</b>")
#@gui:Colour Space=choice(0,"RGB","sRGB","RYB","CMY","CMYK",HCY",HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui:Boundary=choice(3,"None","Neumann","Periodic","Mirror")
#@gui:Interpolation=choice(5,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui:Subpixel=float(1,0,2)
#@gui:_=separator(),_=note("<b>Preview Settings</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/04/06</i>.</small>")
gui_rep_gv: rep_gv $1%,$2%,$3%,$4%,{$5-50}%,{$6-50}%,$7%,$8,$9%,$10%,$11%,$12,{$13+50}%,{$14+50}%,$18,${15-17}
gui_rep_gv_preview: gui_split_preview "gui_rep_gv ${1-18}",${-3--1}
#@gui Fibonacci: fx_rep_fibonacci,fx_rep_fibonacci
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Fill Mode=choice(1,"Textile","Fill")
#@gui:Iterations=int(10,3,20)
#@gui:Direction=choice(0,"Top Left","Top Right","Bottom Left","Bottom Right")
#@gui:Fibonacci Style=choice(0,"Corner","Spiral")
#@gui:Initial Orientation=choice(0,"Landscape","Portrait")
#@gui:Center - Point=point(50,50)
#@gui:Boundary=choice(0,"Periodic","Mirror")
#@gui:Attachment=choice(0,"A","B")
#@gui:Integer Scale=int(1,1,10)
#@gui:_=separator(),_=note("<b>Coloring/Shading</b>")
#@gui:Palette=choice(0,"Normalized Grayscale","Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Cycle Color(%)=float(0,0,100)
#@gui:Color Random Ordering Seed=int(2500,0,5000)
#@gui:Color Random Ordering Seed A=int(100,0,5000)
#@gui:Color Random Ordering Seed B=int(500,0,5000)
#@gui:Negate?=bool(0)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_fibonacci:
if $1

 if $11
  pal {$11-1}
  rep_fibonacci_fill[^-1] ${3-5},0,$10,{($6-50)/100*2},{($7-50)/100*2},$12%,$16,[-1],$13
  rm.
 else
  rep_fibonacci_fill ${3-5},0,$10,{($6-50)/100*2},{($7-50)/100*2},$12%,$16
  n 0,255
 fi

else

 if $11
  pal {$11-1}
  rep_fibonacci_fill[^-1] ${3-5},$2,$10,$8,$9,$12%,$16,[-1],$14,$15
  rm.
 else
  rep_fibonacci_fill ${3-5},$2,$10,$8,$9,$12%,$16
  n 0,255
 fi

fi
u "{$1}"\
"{$2}_"{$1?0:2}\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6,$7}_"{$1?($4?2:0):0}\
"{$8}_"{$1?0:2}\
"{$9}_"{$1?0:2}\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}_"{$1?($11?2:1):0}\
"{$14}_"{$1?0:($11?2:1)}\
"{$15}_"{$1?0:($11?2:1)}\
"{$16}"
#@gui Spiral Distortion:gui_rep_sd,gui_rep_sd_preview(0)
#@gui:_=note("Transform image using spiral gradient for x-coordinate, and radial gradient for y-coordinate."),_=separator()
#@gui:Revolution=float(1,.1,10)
#@gui:Spiral Height=float(1,.5,10)
#@gui:Refraction Power=float(0,-.99,2)
#@gui:Direction=choice(0,"Clockwise","Counterclockwise")
#@gui:Angle=float(0,-180,180)
#@gui:Spiral Mode=choice(0,"Periodic","Continuous")
#@gui:Preshift Position=point(50,50,0,1,200,200,200,255)
#@gui:Preshift Boundary=choice(0,"Periodic","Mirror")
#@gui:Skew Position (%)=point(50,50,0,1,100,100,100,255)
#@gui:Skew Multiplier=float(1,-.5,3)
#@gui:Offset (%)=point(50,50,0,1,255,255,255,255)
#@gui:Scale X-Coordinate (%)=float(100,1,1000)
#@gui:Scale Y-Coordinate (%)=float(100,1,1000)
#@gui:Boundary Condition=choice(3,"None","Neumann","Periodic","Mirror")
#@gui:Interpolation=choice(4,"Nearest","Average","Linear","Bicubic","Lanczos")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/10/15</i>.</small>")
gui_rep_sd: rep_sd ${1-6},{($7-50)*2}%,{($8-50)*2}%,$9,{($10-50)*2}%,{($11-50)*-2}%,$12,{($15-50)*2}%,{($16-50)*2}%,{($13-50)*2}%,{($14-50)*2}%,$17,$18
gui_rep_sd_preview: gui_split_preview "gui_rep_sd ${1-18}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}_"{(($7!=50)||($8!=50))?2:1}\
"{$10,$11}"\
"{$12}_"{($10!=50)||($11!=50)?2:1}\
"{$13,$14}"\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18}"\
"{$19}"\
"{$20,21}"
#@gui Perspective Streak:gui_rep_perspective_streak,gui_rep_perspective_streak_preview(0)
#@gui:_=note("Creates streak effect toward vanishing point. Read notes below the filter option for more instructions.\n\n<b>Warning - </b> This is a computationally intensive filter.\n\n<small><b>Note - </b>Future versions may come with easier way to utilize this filter.</small>"),_=separator(),_=note("<b>Main</b>")
#@gui:Vanishing Point (%)=point(50,50,0,1,128,128,128,255)
#@gui:Alpha Exponential Factor (%)=float(0,-100,500)
#@gui:Distance Threshold (%)=float(100,.1,100)
#@gui:Distance Start (%)=float(0,0,99.99)
#@gui:Streak Direction=choice(0,"Inside","Outside")
#@gui:_=separator(),_=note("<b>Info Output</b>")
#@gui:Streak Mode=choice(0,"Color","Grayscale","Binary","Grayscale+Binary")
#@gui:Preserve Edges=bool(1)
#@gui:_=note("<small>Preserve Edges are not available on binary mode.</small>")
#@gui:_=separator(),_=note("<b>Preview</b>")Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<b>- Instruction Notes-</b>\n\n<small><b>Note 1 - </b>To effectively use this filter, experiment using <b>Secondary Settings</b> on <u>multiple copies of original image[s]</u>.\n\n<b>Note 2 - </b>Use blending modes.\n\n<b>Note 3 - </b>If your software supports alpha inheritance, use that to advantage.</small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/8</i>.</small>")
gui_rep_perspective_streak:
px={(($1-50)*2)/100}
py={(($2-50)*-2)/100}

if $px<-1 px=-1
elif $px>1 px=1
fi

if $py<-1 px=-1
elif $py>1 px=1
fi
rep_pstrk $px,$py,$3%,$4%,$5%,$6,$7,$8,255
if $7 * 255 fi
gui_rep_perspective_streak_preview:
gui_split_preview "gui_rep_perspective_streak ${1-8}",${-3--1}
u "{$1,$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}_"{$7!=2?2:1}\
"{$9,$10}"\
"{$11}"
#@gui Axis Streak:gui_axis_streak,gui_axis_streak_preview
#@gui:_=note("Streaks pixel taking into account of opacity by blending pixels-by-pixels."),_=separator()
#@gui:Orientation=choice(0,"Horizontal","Vertical")
#@gui:Direction=choice(0,"Left","Right")
#@gui:Direction=choice(0,"Up","Down")
#@gui:Alpha Exponential Factor(%)=float(0,-100,500)
#@gui:_=separator(),_=note("<b>Preview</b>")Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/7</i>.</small>")
gui_axis_streak:
if $1 rep_axis_streak $1,!$3,$4%,255
else rep_axis_streak $1,$2,$4%,255
fi
gui_axis_streak_preview:
gui_split_preview "gui_axis_streak ${1-4}",${-3--1}
u "{$1}"\
"{$2}"_{$1?0:2}\
"{$3}"_{$1?2:0}\
"{$4}"\
"{$5,$6}"\
"{$7}"
#@gui Majority:gui_rep_majority,gui_rep_majority_preview
#@gui:_=separator(),_=note("<b>Filter Options</b>")
#@gui:Color Space=choice(11,"RGB","sRGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui:Contain Alpha=bool(0)
#@gui:Kernel Size=int(5,2,50)
#@gui:Mode=choice(0,"Soft Regular","Soft Average Channels","Hard Regular,"Hard Average Channels")
#@gui:Convert to Black and White?=bool(0)
#@gui:_=separator(),_=note("<b>Preview Setting</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<b>Info about filter</b>\n\n<small>Majority effects comes in one of those two version.\n\n1- Use a predefined value to take either the value of the min/max values within kernel.\n\n2-Automatically let the average of kernel to define which values to take which can be either min/max value within kernel.</small>"),_=separator(),_=note("<small>More information - <a href="https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/">Paint.NET Majority Effect</a></small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/31</i>.</small>")
gui_rep_majority:
rep_major $3,$4,$1,$2
if $5 to_graya fi
gui_rep_majority_preview:
gui_split_preview "gui_rep_majority ${1-5}",${-3--1}
#@gui Majority [Threshold]:gui_rep_majority_threshold,gui_rep_majority_threshold_preview
#@gui:_=separator(),_=note("<b>Filter Options</b>")
#@gui:Color Space=choice(11,"RGB","sRGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui:Contain Alpha=bool(0)
#@gui:Kernel Size=int(5,2,50)
#@gui:Tolerance (%)=float(50,0,100)
#@gui:Conditional Mode=choice(1,"Less Than","Greater Than")
#@gui:Output Mode=choice(0,"Soft","Hard")
#@gui:Convert to Black and White?=bool(0)
#@gui:_=separator(),_=note("<b>Preview Setting</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<b>Info about filter</b>\n\n<small>Majority effects comes in one of those two version.\n\n1- Use a predefined value to take either the value of the min/max values within kernel.\n\n2-Automatically let the average of kernel to define which values to take which can be either min/max value within kernel.</small>"),_=separator(),_=note("<small>More information - <a href="https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/">Paint.NET Majority Effect</a></small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/31</i>.</small>")
gui_rep_majority_threshold:
rep_major_t $3,$4%,$5,$6,$1,$2
if $7 to_graya fi
gui_rep_majority_threshold_preview:
gui_split_preview "gui_rep_majority_threshold ${1-7}",${-3--1}
#@gui Newton Fractal [MadJik Style]:rep_mj_newf,rep_mj_newf
#@gui:_=note("<b>Warning-</b> Filter is very hard to control!Also,filter is computationally intensive!\n\nMight be solved later."),_=separator()
#@gui:Zoom=float(16,1,1000000)
#@gui:X-Pan=float(0,-10000,10000)
#@gui:Y-Pan=float(0,-10000,10000)
#@gui:Color Range=float(128,0,255)
#@gui:Factor A=float(9,-100,100)
#@gui:Factor B=float(0,-100,100)
#@gui:Factor C=float(75,-100,100)
#@gui:Factor D=float(5,-100,100)
#@gui:Exponent=float(10,0,17)
#@gui:Depth=float(50,1,500)
#@gui:Background Frequency=float(50,1,500)
#@gui:Color Angle=float(45,-180,180)
#@gui:Alternate Color Function=bool(0)
#@gui:Symmetry=bool(0)
#@gui:Channel Swap=bool(0)
#@gui:_=separator(),_=note("<small>Original Code made by MadJik - <a href="https://forums.getpaint.net/topic/111758-newton-fractal-texture-ymd-170915/">Newton Fractal texture (ymd 170915)</a></small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/1/2</i>.</small>")
#@gui Graduated Filter: fx_rep_graduated_filter,fx_rep_graduated_filter_preview(0)
#@gui:Strength (%)=float(50,0,100)
#@gui:Luminosity Filtering Strength (%)=float(100,0,100)
#@gui:Placement (%)=float(50,0,100)
#@gui:Filtering Angle=float(0,-180,180)
#@gui:Graduated Filter Color=color(0,0,0)
#@gui:_=separator(),Preview type=choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/1/4</i>.</small>")
fx_rep_graduated_filter: rep_graduated_filter $1%,$2%,$3%,$4,,${5-7}
fx_rep_graduated_filter_preview: gui_split_preview "fx_rep_graduated_filter ${1-7}",${-3--1}
#@gui Rectangle-Square Fill:fx_rep_rand_sqrrecfill,fx_rep_rand_sqrrecfill
#@gui:_=note("<b>Main</b>")
#@gui:1.Palette=choice(0,"None","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:2.Use Random Color Instead?=bool(0)
#@gui:3.Square Size=int(15,2,150)
#@gui:4.Max Primary Dimension of Rectangle=int(2,1,10)
#@gui:5.Max Secondary Dimension of Rectangle=int(1,1,10)
#@gui:6.Frequency of Rectangle=float(1,0,1)
#@gui:7.Line Erosion=int(0,-15,15)
#@gui:8.Line Output=bool(1)
#@gui:9.Reduce Non-Rectangular Shape=bool(1)
#@gui:10.Remove Black from Palette?=bool(1)
#@gui:Seed=int(0,0,50000)
#@gui:Colour Space=choice(0,"RGB-8","RYB-8","HSI-8","HSL-8","HSV-8","LAB-8","LCH-8","YIQ-8","YUV-8")
#@gui:_=separator(),_=note("<b>Extra</b>")
#@gui:Output Mode=choice(0,"Clipped","Enlarged","Shrinked")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_rand_sqrrecfill:
ww={w}
hh={h}
if $-1!=1

 square_size=$3

 if $8
  if abs($7)
   if $7>0 square_size+={abs($5)}
   else square_size+=1
   fi
  fi
 fi

 rw={w-$square_size*2}
 rh={h-$square_size*2}
 nw={floor($rw/($square_size*($8?(($3+1)/$3):1)))*$square_size}
 nh={floor($rh/($square_size*($8?(($3+1)/$3):1)))*$square_size}
 if $-1==2 r $nw,$nh,100%,100% fi

fi

if $2 rep_rand_sqrrecfill -1,${3--2}
else
 rep_rand_sqrrecfill $1,${3--3}
 if $1==0 n. 0,255 fi
fi

if $-1!=1 if $-1==2 f. 255-i fi r. $ww,$hh,100%,100%,0,0,.5,.5 if $-1==2 f. 255-i fi fi
k.
u "{$1}_"{$2?1:2}\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}_"{(($1==0&&$2==0)?0:$8)?2:1}\
"{$8}_"{$1==0&&$2==0?1:2}\
"{$9}"\
"{$10}"_{!($1==0&&$2!=1)?2:1}\
"{$11}"\
"{$12}_"{$2?2:1}\
"{$13}"
#@gui Point Warp:gui_rep_pw,gui_rep_pw_preview(0)
#@gui:Point Width=float(100,0,100)
#@gui:Distance=float(100,0,100)
#@gui:Radial Influence=float(0,0,100)
#@gui:Placement of Distortion=point(50,50,0,1,128,128,128,255)
#@gui:Distortion Angle=float(0,-180,180)
#@gui:Boundary Condition=choice(3,"None","Neumann","Periodic","Mirror")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>This is a modified code of a conversion of Illab2014's Paint.NET plugin named <a href="https://forums.getpaint.net/topic/32180-point-warp-engorged-smudge-aug-20-2015/">Point Warp</a>. The difference between this and Illab2014's filter is that this one takes into account of image size and contains boundary conditions.</small>")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/2/26</i>.</small>")
gui_rep_pw:
rep_pw $1%,$2%,$3%,{($4/100-.5)*2},{($5/100-.5)*-2},$6,$7
gui_rep_pw_preview:
gui_split_preview "gui_rep_pw ${1-7}",${-3--1}
#@gui Prime Surface:gui_rep_prime_surface
#@gui:Negate Direction?=bool(0)
#@gui:Mirror Direction=choice(0,"None","X","Y")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/2/26</i>.</small>")
gui_rep_prime_surface:
rep_prime_surface {w},{h},$1,$2 k. n 0,255
#@gui Pixel Push:fx_rep_pxpush,fx_pxpush_preview(0)
#@gui:Push Point=point(50,50,0,1,255,255,255,255)
#@gui:_=separator(),_=note("Recreation of filter from source code to TR's Pixel Push plugin for Paint.NET.Currently only Bezier option is supported until the secondary option is figured out.")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/2/26</i>.</small>")
fx_rep_pxpush: rep_pxpush {($1/100-.5)*2},{($2/100-.5)*2}
fx_pxpush_preview: gui_split_preview "fx_rep_pxpush $*",${-3--1}
#@gui Rotate by Torus Map:fx_rep_rbtt,fx_rep_rbtt_preview(0)
#@gui:_=note("<b>Main</b>")
#@gui:Circumference A (%)=float(100,0,100)
#@gui:Circumference B (%)=float(50,0,100)
#@gui:_=separator()_=note("<b>Distortion</b>")
#@gui:Distortion Angle=float(-180,-720,720)
#@gui:Distortion Mode=choice(3,"Soft","Medium","Hard","Alternative Hard","Distroy","Inverse-Distroy","Quad Extrude","Hexagonal Extrude")
#@gui:Distortion Mode A=choice(3,"Soft","Medium","Hard","Alternative Hard","Distroy","Inverse-Distroy","Quad Extrude","Hexagonal Extrude")
#@gui:Distortion Mode B=choice(7,"Soft","Medium","Hard","Alternative Hard","Distroy","Inverse-Distroy","Quad Extrude","Hexagonal Extrude")
#@gui:Distortion Mode Blending (%)=float(50,0,100)
#@gui:Enable Distortion Mode Blending=bool(1)
#@gui:Distortion Position=point(50,50,0,1,255,255,255,255)
#@gui:Wraparound Distortion?=bool(1)
#@gui:_=separator(),_=note("<b>Additional</b>")
#@gui:Remove Background?=bool(0)
#@gui:Activate Isolated Torus Mode?=bool(0)
#@gui:_=separator(),_=note("<b>Rendering</b>")
#@gui:Interpolation=choice(1,"None","Linear")
#@gui:Boundary Condition=choice(2,"None","Neumann","Periodic","Mirror")
#@gui:_=separator(),_=note("<b>Preview</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<b>Information</b>\n"),_=note("This filter is inspired by <a href="https://forums.getpaint.net/topic/23400-donut-distortion-effect-plugin/">Donut Distortion Paint.NET plugin</a> by <a href="https://forums.getpaint.net/profile/45895-madjik/">MadJik</a>.\n\n This G'MIC version includes additional modes,wraparound mode, and special mode which isolates the distortion.")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/11/08</i>.</small>")
fx_rep_rbtt:
to_a
if $8 rep_rbtt {$1/100},{$2/100},$3,$5,$6,{$7/100},{($9/100-.5)*2},{($10/100-.5)*-2},$11,$12,$13,$14,$15
else  rep_rbtt {$1/100},{$2/100},$3,$4,,,{($9/100-.5)*2},{($10/100-.5)*-2},$11,$12,$13,$14,$15
fi
fx_rep_rbtt_preview: gui_split_preview "fx_rep_rbtt ${1-13},{$14*-1},$15",${-3--1}
a={$8?2:1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{!$8?2:1}\
"{$5}_"$a\
"{$6}_"$a\
"{$7}_"$a\
"{$8}"\
"{$9,$10}"\
"{$11}"\
"{$12}"\
"{$13}_"{$12?2:1}\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17,$18}"
#@gui RGB-Gray Linear Interpolation:fx_rep_lerp_rgb_gray,fx_rep_lerp_rgb_gray_preview(0)
#@gui:_=note("<b>Formula</b>")
#@gui:Mode=choice(0,"Luminosity A","Luminosity B","Lightness","Minimum","Maximum","Average",Weighted")
#@gui:Limit Factor to 100%=bool(0)
#@gui:_=separator(),_=note("<b>Channel Factor</b>")
#@gui:Red Factor (%)=float(100,0,150)
#@gui:Green Factor (%)=float(100,0,150)
#@gui:Blue Factor (%)=float(100,0,150)
#@gui:Red Factor (%)=float(100,0,100)
#@gui:Green Factor (%)=float(100,0,100)
#@gui:Blue Factor (%)=float(100,0,100)
#@gui:Red Weight=float(1,0,1)
#@gui:Green Weight=float(1,0,1)
#@gui:Blue Weight=float(1,0,1)
#@gui:_=separator(),_=note("<b>Preview</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/14/3</i>.</small>")
fx_rep_lerp_rgb_gray:
if $1==6
 if $2 rep_lerp_rgb_gray $6%,$7%,$8%,${9-11}
 else  rep_lerp_rgb_gray $3%,$4%,$5%,${9-11}
 fi
else
 if $2 rep_lerp_rgb_gray $6%,$7%,$8%,$1
 else  rep_lerp_rgb_gray $3%,$4%,$5%,$1
 fi
fi
fx_rep_lerp_rgb_gray_preview:
if $2 r1,g1,b1,r2,g2,b2={[$6<100?$6:$3,$7<100?$7:$4,$8<100?$8:$5,$6,$7,$8]}
else r1,g1,b1,r2,g2,b2={[$3,$4,$5,$3,$4,$5]}
fi

gui_split_preview "fx_rep_lerp_rgb_gray ${1-11}",${-3--1}

a={$2?0:2}
b={$2?2:0}
c={$1==6?2:0}

u "{$1}"\
"{$2}"\
"{"$r1"}_"$a\
"{"$g1"}_"$a\
"{"$b1"}_"$a\
"{"$r2"}_"$b\
"{"$g2"}_"$b\
"{"$b2"}_"$b\
"{$9}_"$c\
"{$10}_"$c\
"{$11}_"$c\
"{$12}"\
"{$13,$14}"
#@gui Trigonometry Mapping: fx_rep_tg3,fx_rep_tg3_preview(0)
#@gui:_=note("<b>Processing</b>)
#@gui:Colour Space=choice(0,"RGB-8","RYB-8","CMY-8","HSI-8","HSL-8","HSV-8","LAB-8","LCH-8","YIQ-8","YUV-8","XYZ-8","YES-8","OHTA-8","Kodak 1-8")
#@gui:Mode=choice(0,"Direct Trig-3","Luminosity to Trig-3")
#@gui:Preserve Luminosity=bool(1),_=separator()
#@gui:_=note("<b>Mapping</b>)
#@gui:Channel Order=choice(0,"First-Second-Third","First-Third-Second","Second-First-Third","Second-Third-First","Third-First-Second","Third-Second-Third")
#@gui:Channel=choice(0,"First","Second","Third")
#@gui:Channel=choice(0,"First","Third","Second")
#@gui:Channel=choice(0,"Second","First","Third")
#@gui:Channel=choice(0,"Second","Third","First")
#@gui:Channel=choice(0,"Third","First","Second")
#@gui:Channel=choice(0,"Third","Second","First")
#@gui:Formula=choice(0,"Sinusoidal","Cosinusodial","Cubic Sinusoidal","Cubic Cosinusodial","Cubic Sinusoidal-Cosinusodial")
#@gui:Multiplier=float(1,.1,5)
#@gui:Value Shift=float(0,-1,1)
#@gui:Midgray Exponential Factor=float(1,.01,2)
#@gui:Lightness Merge Factor=float(1,0,1)
#@gui:Lightness Exponential Factor=float(1,.01,5)
#@gui:End Value to Base Factor=float(1,0,1)
#@gui:Formula=choice(0,"Sinusoidal","Cosinusodial","Cubic Sinusoidal","Cubic Cosinusodial","Cubic Sinusoidal-Cosinusodial")
#@gui:Multiplier=float(1,.1,5)
#@gui:Value Shift=float(0,-1,1)
#@gui:Midgray Exponential Factor=float(1,.01,2)
#@gui:Lightness Merge Factor=float(1,0,1)
#@gui:Lightness Exponential Factor=float(1,.01,5)
#@gui:End Value to Base Factor=float(1,0,1)
#@gui:Formula=choice(0,"Sinusoidal","Cosinusodial","Cubic Sinusoidal","Cubic Cosinusodial","Cubic Sinusoidal-Cosinusodial")
#@gui:Multiplier=float(1,.1,5)
#@gui:Value Shift=float(0,-1,1)
#@gui:Midgray Exponential Factor=float(1,.01,2)
#@gui:Lightness Merge Factor=float(1,0,1)
#@gui:Lightness Exponential Factor=float(1,.01,5)
#@gui:End Value to Base Factor=float(1,0,1)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/8/9</i>.</small>")
fx_rep_tg3:
if $1 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$1,,ryb,cmy,hsi8,hsl8,hsv8,lab8,lch8,yiq8,yuv8,xyz8,yes8,ohta8,k18} fi

foreach {

	if s==4 s c,-3 +store.. color store. alpha contain_alpha=1
	elif s<2 continue
	else +store color contain_alpha=0
	fi

	sh. 0,2
	if $1 $convert_colors_fwd. fi

	if $2 rep_tg3. 8il,$4,${11-31}
	else  rep_tg3. 8i,$4,${11-31}
	fi

	if $1 $convert_colors_bwd. fi

	cut. 0,255
	rm.

	if $3 $color blend luminance fi
	if $contain_alpha $alpha a c fi

}
fx_rep_tg3_preview:

cc1,cc2,cc3,cc4,cc5,cc6=$5,$6,$7,$8,$9,$10
cc=[$cc1,$cc2,$cc3,$cc4,$cc5,$cc6]
cc={($cc)[$4]}
cc1,cc2,cc3,cc4,cc5,cc6={[$cc,$cc,$cc,$cc,$cc,$cc]}

gui_split_preview "fx_rep_tg3 ${1-31}",${-3--1}

a={((($4==0&&$5==0)||($4==1&&$6==0))||(($4==2&&$7==0)||($4==3&&$8==0)))||(($4==4&&$9==0)||($4==5&&$10==0))?2:0}
b={((($4==0&&$5==1)||($4==1&&$6==1))||(($4==2&&$7==1)||($4==3&&$8==1)))||(($4==4&&$9==1)||($4==5&&$10==1))?2:0}
c={((($4==0&&$5==2)||($4==1&&$6==2))||(($4==2&&$7==2)||($4==3&&$8==2)))||(($4==4&&$9==2)||($4==5&&$10==2))?2:0}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{"$cc1"}_"{$4==0?2:0}\
"{"$cc2"}_"{$4==1?2:0}\
"{"$cc3"}_"{$4==2?2:0}\
"{"$cc4"}_"{$4==3?2:0}\
"{"$cc5"}_"{$4==4?2:0}\
"{"$cc6"}_"{$4==5?2:0}\
"{$11}_"$a\
"{$12}_"$a\
"{$13}_"$a\
"{$14}_"$a\
"{$15}_"$a\
"{$16}_"$a\
"{$17}_"$a\
"{$18}_"$b\
"{$19}_"$b\
"{$20}_"$b\
"{$21}_"$b\
"{$22}_"$b\
"{$23}_"$b\
"{$24}_"$b\
"{$25}_"$c\
"{$26}_"$c\
"{$27}_"$c\
"{$28}_"$c\
"{$29}_"$c\
"{$30}_"$c\
"{$31}_"$c\
"{$32}"\
"{$33,$34}"
#@gui Attractor:fx_rep_trsa,fx_rep_trsa_preview(0)
#@gui:_=note("Generates <b>Attractor</b> fractal."),_=separator()
#@gui:_=note("<b>Input</b>")
#@gui:Algorithm=choice(0,A,B,C,D,E,F,G)
#@gui:Density=float(7,.5,50)
#@gui:Scale=float(1,.1,3)
#@gui:_=note("<b>Parameters</b>)
#@gui:A=float(1,-1,1)
#@gui:B=float(1,-1,1)
#@gui:C=float(1,-1,1)
#@gui:D=float(1,-1,1)
#@gui:E=float(1,-1,1)
#@gui:F=float(1,-1,1)
#@gui:G=float(1,-1,1)
#@gui:H=float(1,-1,1)
#@gui:I=float(1,-1,1)
#@gui:Randomize Parameters=button(),_=separator()
#@gui:_=note("<b>Output</b>")
#@gui:Mode=choice(0,"A","A/B","A/A")
#@gui:Negative Exponential Factor=float(1,1,10)
#@gui:Multiplier=float(1,1,10)
#@gui:Quality=float(1,1,3),_=separator()
#@gui:_=note("<b>Preview</b>")
#@gui:Fill Percentage=bool(0)
#@gui:_=separator(),_=note("<b>Instruction</b>"),_=note("Attractor are fractals in which values lean toward a location within phase space.\n\n<b>1. </b><u>Input</u> setting defines the format of attractor fractal as well as its density and scaling.\n\n<b>2. </b> <u>Parameters</u> are different variables with different numbers assigned. This is used to alter the forms of attractor.\n\n<b>3.</b> <u>Output</u> influence the shading of attractor. A implies that negative exponental factor is applicable while B means that it's not applicable. In case of two letter, the last letter is the alpha channel. The greater the negative exponential factor value is, the more visible the attractor will be.\n\n<b>4. Quality</b> resizes the image and multiply the density by the quality number, then resize the image back to the original size. It is used to reduce noise.\n\n<b>5. Fill Percentage</b> is used as a way to diagnose whether there is a fractal appearing or not. A very low percentage means there is no fractal. Percentage higher than 100% implies some values are out of range in respect to the image boundary.")
#@gui:_=separator(),_=note("<b>Info</b>"),_=note("Conversion of a PDN plugin made by TechnoRobbo.\n\nSource Code: <a href=\"https://forums.getpaint.net/topic/28512-trs-strange-attractors-v113-august-8th-2014/">TR's Strange Attractor Plugin</a>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/3/29</i>.</small>")
fx_rep_trsa:
skip ${18=0},${19=1}

local[-1] {
    ww={w} hh={h}

    channels 0 f 0

    rs {$17*100}%

    rep_trsa $1,{$2*$17},${3-12},$19

    u {${}/wh#-1}

    n 0,1

    if $14 r 100%,100%,100%,2 fi

    if $14<1 f [i^(1/$15)]
    else f i^(1/$15)
    fi

    r $ww,$hh,1,{s},2
    * 255 * $16
}
fx_rep_trsa_preview:

param1,param2,param3,param4,param5,param6,param7,param8,param9=$4,$5,$6,$7,$8,$9,$10,$11,$12
if $13
 param1,param2,param3,param4,param5,param6,param7,param8,param9={[u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1)]}
fi

fx_rep_trsa ${1-3},$param1,$param2,$param3,$param4,$param5,$param6,$param7,$param8,$param9,0,${14-17},,0

fill_decimal={${}}
fill_perc={round($fill_decimal*10000)/100}
if $18 to $fill_perc"%" fi

a={$1!=3?2}
b={$1>3?2}
c={$1==5?2}

u "{$1}"\
"{$2}"\
"{$3}"\
"{"$param1"}"\
"{"$param2"}"\
"{"$param3"}_"$a\
"{"$param4"}_"$a\
"{"$param5"}_"$b\
"{"$param6"}_"$b\
"{"$param7"}_"$c\
"{"$param8"}_"$c\
"{"$param9"}_"$c\
"{0}"\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18}"
#@gui Non-Isometric RPG Tiler (Interactive):fx_rep_rpgtiler_noniso,fx_rep_rpgtiler_noniso_preview
#@gui:_=note("Launch the interactive non-isometric RPG Tiling toolkit.\n\n<b>Note : </b>When using Custom Tileset, you must load the file in tileset!\n\n<u>Please Read Instruction Below!</u>"),_=separator()
#@gui:_=note("<b>Tileset</b>")
#@gui:Premade Tileset=choice(0,LPC House Interior[32], Generic Platform[32], Metroid Like[16], Omega Team[16],Classic RPG[16],Dungeon[32],Happyland[16])
#@gui:Import Custom Tileset?=bool(0)
#@gui:Tileset=file(),_=separator(),_=note("<b>Interactive Window Setting</b>")
#@gui:Tile Size=int(32,3,128)
#@gui:Max Selection Increment=int(2,0,8)
#@gui:Interactive Tileset Width=int(16,2,64)
#@gui:Interactive Tileset Height=int(16,2,64)
#@gui:Layer as Placed Tiles?=bool(0)
#@gui:Apply Image Background on Final Image?=bool(0)
#@gui:Alpha to RGB Background Mode=choice(0,"Checkerboard","Colored")
#@gui:Background Colour=color(0,0,0)
#@gui:Grid Color=float(0,0,255)
#@gui:Trackpad Color=float(45,0,255)
#@gui:_=separator(),_=note("<b>Preprocessing</b>")
#@gui:Reverse Layers?=bool(0)
#@gui:_=note("<small>This option is usable for programs that supports editing on two or more layer at once with G'MIC-QT!</small>")
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Hide Background?=bool(0)
#@gui:Preview Grid and Tracker?=bool(1)
#@gui:Hide Tileset?=bool(0),_=separator(),_=note("<b>Paint.NET Workaround</b>")
#@gui:Output Mode=choice(0,"Center Result","Output to File")
#@gui:Output Folder=folder()
#@gui:Output Filename=text("placed_tile.png")
#@gui:_=note("<small>This section is only for Paint.NET users! If you don't use this this software, then you don't need use this section!</small>")
#@gui:_=separator()
#@gui:_=note("\n- <u><b>Instruction</b></u> -\n\n"),_=separator()
#@gui:_=note("<b>Section 1 - Preview Window</b>"),_=separator()
#@gui:_=note("Before processing to the interactive window - Test the following conditions:\n\n<b>1. </b>Tileset is correct\n<b>2. </b>Grid fits and is very visible\n<b>3. </b>Tracker is very visible\n\nIf the preview looks good, then proceed to the interactive tool by clicking OK.\n\n<b>Warning: </b>Apply will only waste your time!")
#@gui:_=separator(),_=note("<b>Section 2 - Interactive Windows</b>"),_=separator()
#@gui:_=note("Press Escape on Canvas Window to exit!\n\n<u>Main Editing Mode</u>\n\n<b>On Any Windows</b>\n\n- D: Switch between Place/Eraser Mode\n- R: Activate Replace Mode\n- W: Restore All Windows\n- SPACEBAR: Switch Editing Mode\n\n<b>On Canvas Window</b>\n\n- C: Copy Mode On/Off\n- X: Cut Mode On/Off\n- Z: Undo Canvas Change\n- F: Activate/Deactivate Background Tile Layering Mode\n- G: Grid Mode On/Off\n- Q: Remove/Restore Background\n- A: Tracker On/Off\n- S: Symmetry Mode On/Off\n\n=== On Canvas[Symmetry Mode] ===\n--- 1: Switch Symmetry Axis to X-Axis\n--- 2: Switch Symmetry Axis to Y-Axis\n--- 3: Switch Symmetry Axis to Cross XY-Axis\n--- 4: Switch Symmetry Axis to Mirror XY-Axis\n--- ARROWKEY: Move Symmetry Line\n--- B: Switch Axis in Symmetry Mode\n--- M: Switch Axis in Periodic/Mirror Mode\n--- J: Symmetry Line to Center\n--- S: Deactivate Symmetry Mode\n\n<b>On Tileset Window</b>\n\n- G: Grid Mode On/Off\n- CTRL+ARROWKEY : Resize Tile Selection\n- ARROWKEY : Scroll Through Tileset\n\n<b>On Tile Window</b>\n\n- CTRL+ARROWKEY : Resize Tile Selection\n- ARROWKEY : Scroll Through Tileset\n- MOUSE BUTTON : Switch Between Place/Eraser Mode\n\n=== On Tile[No Symmetry Mode] ===\n--- 1: Switch Fill Boundary to Periodic\n--- 2: Switch Fill Boundary to Mirror\n--- 3: Switch Fill Boundary to Mirror X\n--- 4: Switch Fill Boundary to Mirror Y\n--- B: Switch Fill Boundary Mode\n\n<u>Row/Column Editing Mode</u>\n\n<b>On Any Windows</b>\n\n- W: Restore All Windows\n- SPACEBAR: Switch Editing Mode\n\n<b>On Canvas Window</b>\n\n- Z: Undo Canvas Change\n- T: Enable Row/Column Shifting Mode\n- E: Place Mode On/Off\n- G: Grid Mode On/Off\n- Q: Remove/Restore Background\n- A: Tracker On/Off\n- S: Activate Symmetrical Selection Mode\n\n=== On Canvas[Selection] ===\n--- C: Keep Selected Row/Column\n--- X: Delete Selected Row/Column\n--- D: Select/Deselect\n--- R: Clear Selection\n--- V: View Selection Box/Hide Selection Box\n--- Mouse Button: Select/Deselect\n--- ARROWKEY: Switch between Row/Column Selection\n\n=== On Canvas[Symmetry Mode-Symmetry] ===\n--- J: Symmetry Line to Center\n--- ARROWKEY: Move Symmetry Line\n--- S: Deactivate Symmetrical Selection Mode\n\n=== On Canvas[Row/Column Shifting Mode] ===\n--- Mouse Button[1st Click]: Activate Shifting\n--- Mouse Button[2nd Click]: Finalize Shifting\n--- 0: Shift Boundary Mode - None\n--- 1: Shift Boundary Mode - Neumann [Periodic]\n--- 2: Shift Boundary Mode - Neumann [Mirror]\n--- 3: Shift Boundary Mode - Neumann [Alternating]\n--- 4: Shift Boundary Mode - Periodic\n--- 5: Shift Boundary Mode - Mirror\n--- ARROWKEY: Switch between Row/Column Selection\n--- T: Disable Row/Column Shifting Mode\n\n=== On Canvas[Place Mode] ===\n--- Mouse Button: Place Row/Column\n--- B: Switch between Replacement/Placement Mode\n--- F: Place Row/Column as Foreground/Background\n--- Mouse Button: Place Row/Column\n--- E: Deactivate Place Mode\n\n<b>On Tile Window</b>\n\n- ARROWKEY: Flip Row/Column")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/10/20</i>.</small>")
fx_rep_rpgtiler_noniso:
skip ${3=""}
ww={w}
hh={h}

if same('$_host','paintdotnet') if $20 +store. pdnimage fi fi

if $2 fileloc="$3" fi

if $16 if $8 rv[^0] else rv fi fi

if $8 blend[^0] alpha
else blend alpha
fi

if $2 i $fileloc
else rep_tileset_n $1
fi

if $8
 if $10 rep_tiler_n[-2] [-1],${4-7},[0],$9,${11-15}
 else rep_tiler_n[-2] [-1],${4-7},[0],$9,,,,${14-15}
 fi
 k[-2]
else
 if $10 rep_tiler_n[-2] [-1],${4-7},,$9,${11-15}
 else rep_tiler_n[-2] [-1],${4-7},,$9,,,,${14-15}
 fi
 k[-2]
fi
if same('$_host','paintdotnet') if $20 filename="$21/$22" o[0] $filename rm $pdnimage
else
r $ww,$hh,100%,100%,0,0,.5,.5
fi fi
fx_rep_rpgtiler_noniso_preview:
skip ${3=""}
if $2 fileloc="$3" fi

ww={w}
hh={h}

if $16 rv fi
if $17 f 0 fi

blend alpha

if !$19

 store. bg

 if $2 i $fileloc
 else rep_tileset_n $1
 fi

 tw={w#-1}
 th={h#-1}

 r. $ww,$hh,100%,100%,0,0

 shift. {floor((w/$4)/2)*$4-(floor($tw/$4/2)-(!$tw%2?1))*$4},{floor((h/$4)/2)*$4-(floor($th/$4/2)-($th%2?1))*$4}

 if !$17 $bg rv blend alpha fi

fi

if $10
 drgba ${11-13}
else
 drgba
fi

if $18
 f "
 begin(
  const psx=floor((w/2)/$4)*$4;
  const psy=floor((h/2)/$4)*$4;
  const border=2;
  const border_left=psx+border;
  const border_right=psx+$4-border;
  const border_up=psy+border;
  const border_down=psy+$4-border;
  const boundx=psx+$4;
  const boundy=psy+$4;
 );
 tracker=(x>psx&&x<boundx)&&(y>psy&&y<boundy)?((x<=border_left||x>=border_right)||(y<=border_up||y>=border_down)?(xor($15,i)>128?0:255):i):i;
 grid=!(((x%$4)==0||(y%$4)==0)||(x==(w-1)||y==(h-1)))?tracker:$14;
 "
fi
if same('$_host','paintdotnet') pdn=1 else pdn=0 fi
u "{$1}_"{!$2?2:1}\
"{$2}"\
"{$3}_"{$2?2:1}\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11,$12,$13}_"{$10?2:1}\
"{$14}"\
"{$15}"\
"{$16}_"{!$pdn?2:0}\
"{$17}"\
"{$18}"\
"{$19}"\
"{$20}_"{$pdn?2:0}\
"{$21}_"{$pdn?($20?2:1):0}\
"{$22}_"{$pdn?($20?2:1):0}
# #@gui Grouped Pixels Shift By Rectangular Polar Transformation: gui_rep_sptbwgp_recpoltrans,gui_rep_sptbwgp_recpoltrans_preview(0)
# #@gui:_=note("Forces image to be within a point based on shape and boundary. Read notes below the filter option for more instructions.\n\n<b>Warning - </b> This is a computationally intensive filter.\n\n<small><b>Note - </b>Future versions may come with easier way to utilize this filter.</small>"),_=separator(),_=note("<b>Main</b>")
# #@gui:Relative Position (%)=float(-100,-100,100)
# #@gui:Influence Factor (%)=float(100,0,100)
# #@gui:Threshold (%)=float(50,0,100)
# #@gui:Vanishing Point (%)=point(50,50,0,1,128,128,128,255)
# #@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
# #@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/5/10</i>.</small>")
gui_rep_sptbwgp_recpoltrans:
position={$1%}
influence={$2%}
threshold={$3%*255}
px={(($4-50)*2)/100}
py={(($5-50)*-2)/100}
rep_sptbwgp_recpoltrans $position,$influence,$threshold,$px,$py
gui_rep_sptbwgp_recpoltrans_preview:
gui_split_preview "gui_rep_sptbwgp_recpoltrans ${1-5}",${-3--1}
#@gui Ordered Dithering:fx_rep_loupasc_ordered_dither,fx_rep_loupasc_ordered_dither_preview
#@gui:Dithering Method=choice(4,"Checkerboard","Dispersed","Arcade","Ordered","Lines","Matrix","Random")
#@gui:Color Count=choice(3,"2","4","6","16")
#@gui:Use Luminosity?=bool(0)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui:Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Dithering algorithm developed by Pascal Ollive. - <a href="https://forums.getpaint.net/topic/116414-new-developer-new-plugin-ordered-dither/?tab=comments#comment-571305">Source Code Link</a></small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/5/15</i>.</small>")
fx_rep_loupasc_ordered_dither:
foreach {
 if $3
  to_graya sh. 0 rep_loupasc_ordered_dither. $1,$2 rm.
 else
  sh. 0,2 rep_loupasc_ordered_dither. $1,$2 rm.
 fi
}
fx_rep_loupasc_ordered_dither_preview:
gui_split_preview "fx_rep_loupasc_ordered_dither ${1-3}",${-3--1}
#@gui Edge Fade: fx_rep_edgefade,fx_rep_edgefade_preview(0)
#@gui:_=note("If your image has slim alpha, activate Use Max Distance for better control over the fade, however preview will not be as accurate unless you view the full image."),_=separator()
#@gui:_=note("<b>Main</b>")
#@gui:Half Image-Diagonal(%)=float(10,.1,100)
#@gui:Max Distance (%)=float(10,.1,100)
#@gui:Use Max Distance?=bool(0)
#@gui:Exponential Factor=float(2,0,3)
#@gui:_=separator(),_=note("<b>Local Normalization</b>")
#@gui:Amplitude=float(0,0,15)
#@gui:Neighborhood Smoothness (%)=float(4,.1,100)
#@gui:Average Smoothness (%)=float(2,.1,100)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/7/13</i>.</small>")
fx_rep_edgefade:
if $3
 rep_edgefade $2%,${4-5},$6%,$7%
else
 diag={round((norm(w,h)/2)*($1/100))}
 rep_edgefade $diag,${4-5},$6%,$7%
fi
fx_rep_edgefade_preview:
gui_split_preview "fx_rep_edgefade ${1-7}",${-3--1}
u "{$1}_"{!$3?2}\
"{$2}_"{$3?2}\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}_"{$5?2:1}\
"{$7}_"{$5?2:1}\
"{$8}"\
"{$9,$10}"
#@gui Bit-Plane Shuffler:fx_rep_bitplane_shuffle,fx_rep_bitplane_shuffle_preview
#@gui:_=separator(),_=note("<b>Main</b>)
#@gui:Direction=choice(0,"Forward","Backward")
#@gui:Depth=choice(0,"8-Bit","16-Bit")
#@gui:Use Alpha?=bool(0)
#@gui:_=separator(),_=note("<b>CLI Command</b>")
#@gui:CLI version=text("Here is where you copy command to command line interface.")
#@gui:CLI version=text("This is just a reference text")_0
#@gui:_=separator(),_=note("<b>Plane Shuffling</b>)
#@gui:Shuffle Index=int(0,0,40319)
#@gui:Shuffle Index=int(0,0,40319)_0
#@gui:Shuffle Index=text("0")_0
#@gui:Plane Shift Method=_choice(0,"Move","Swap")
#@gui:Plane A=int(1,1,8)
#@gui:Plane B=int(2,1,8)
#@gui:Plane C=int(3,1,8)
#@gui:Plane D=int(4,1,8)
#@gui:Plane E=int(5,1,8)
#@gui:Plane F=int(6,1,8)
#@gui:Plane G=int(7,1,8)
#@gui:Plane H=int(8,1,8)
#@gui:Plane A=int(1,1,8)_0
#@gui:Plane B=int(2,1,8)_0
#@gui:Plane C=int(3,1,8)_0
#@gui:Plane D=int(4,1,8)_0
#@gui:Plane E=int(5,1,8)_0
#@gui:Plane F=int(6,1,8)_0
#@gui:Plane G=int(7,1,8)_0
#@gui:Plane H=int(8,1,8)_0
#@gui:Plane A=int(8,1,16)
#@gui:Plane B=int(10,1,16)
#@gui:Plane C=int(9,1,16)
#@gui:Plane D=int(4,1,16)
#@gui:Plane E=int(7,1,16)
#@gui:Plane F=int(13,1,16)
#@gui:Plane G=int(1,1,16)
#@gui:Plane H=int(3,1,16)
#@gui:Plane I=int(11,1,16)
#@gui:Plane J=int(14,1,16)
#@gui:Plane K=int(6,1,16)
#@gui:Plane L=int(2,1,16)
#@gui:Plane M=int(12,1,16)
#@gui:Plane N=int(5,1,16)
#@gui:Plane O=int(15,1,16)
#@gui:Plane P=int(16,1,16)
#@gui:Plane A=int(8,1,16)_0
#@gui:Plane B=int(10,1,16)_0
#@gui:Plane C=int(9,1,16)_0
#@gui:Plane D=int(4,1,16)_0
#@gui:Plane E=int(7,1,16)_0
#@gui:Plane F=int(13,1,16)_0
#@gui:Plane G=int(1,1,16)_0
#@gui:Plane H=int(3,1,16)_0
#@gui:Plane I=int(11,1,16)_0
#@gui:Plane J=int(14,1,16)_0
#@gui:Plane K=int(6,1,16)_0
#@gui:Plane L=int(2,1,16)_0
#@gui:Plane M=int(12,1,16)_0
#@gui:Plane N=int(5,1,16)_0
#@gui:Plane O=int(15,1,16)_0
#@gui:Plane P=int(16,1,16)_0
#@gui:Randomize=button()
#@gui:Depth=choice(0,"8-Bit","16-Bit")_0
#@gui:Visited 8-Bit=bool(0)_0
#@gui:Visited 16-Bit=bool(0)_0
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/11/27</i>.</small>")
fx_rep_bitplane_shuffle:
skip "$*"

if narg($_persistent)
	if $3
		if $2 * 257 fi
		$_persistent channels. $1
		map[^-1] [-1] rm.
		if $2 / 257 fi
	else
		$_persistent channels. $1 store. _persistent
		foreach {
			if !(s&1) sh 0,{s-2} fi
			if $2 *. 257 fi
			$_persistent
			map[-2] [-1] rm.
			if $2 /. 257 fi
			k[0]
		}
	fi
else rep_bitplane_shuffle {![$1,$3]},$cli_base
fi
fx_rep_bitplane_shuffle_preview:
skip "${4=}"

cli_base="$5"
activate_randomize=$58

use_reverse_permutation,mode_16,mode_alpha,index_8,index_16,\
old_mode_16,old_index_8\
=${1-3},$6,$8,\
 $59,$7

if narg($_persistent) visited_8,visited_16=$60,$61
else                  visited_8,visited_16=0
fi

plane_8_series=plane_8_0,plane_8_1,plane_8_2,plane_8_3,\
               plane_8_4,plane_8_5,plane_8_6,plane_8_7

plane_16_series=plane_16_0,plane_16_1,plane_16_2,plane_16_3,\
                plane_16_4,plane_16_5,plane_16_6,plane_16_7,\
                plane_16_8,plane_16_9,plane_16_a,plane_16_b,\
                plane_16_c,plane_16_d,plane_16_e,plane_16_f

$plane_8_series=${10-17}
$plane_16_series=${26-41}
persistent_change,depth_changed=0,{$mode_16!=$old_mode_16}

if $mode_16
	activate_randomize|=!$visited_16?!$index_16
	shift_plane={"a=[${26-41}];
	              b=[${42-57}];
	              diff_mode=a!=b;
	              if(diff_mode,
	              	const use_swap_mode=$9;
	              	diff_pos=argmax(abs(a-b));
	              	use_swap_mode?(
	              		swap_pos=find(b,a[diff_pos],0,1);
	              		swap(b[diff_pos],b[swap_pos]);
	              		set('order',v2s(b-1));
	              	):(
	              		position_start=b[diff_pos];
	              		position_final=a[diff_pos];
	              		differential=position_final<position_start?1:-1;
	              		fill(a,p,
	              			v=b[p];
	              			inrange(v,position_start,position_final,1,1)?(
	              				v+=differential;
	              			);
	              			v;
	              		);
	              		a[diff_pos]=position_final;
	              		set('order',v2s(a-1));
	              	);
	              );
	              diff_mode;"}
	persistent_change:=$activate_randomize||$shift_plane

	if $activate_randomize
		index_16:=$index_16?v(1,20922789888000,1,0):(v=v(1,20922789887999,1,0);v+=v>=$index_16;);
		order=${rep_permutation_index2list\ 16,$index_16}
	elif $shift_plane
		index_16=${rep_permutation_list2index\ $order}
	elif $depth_changed||!$visited_16
		order={[${26-41}]-1}
		inverse_order=${rep_inverse_permutation\ $order}
	fi

	if $persistent_change
		$plane_16_series:=[$order]+1
		inverse_order=${rep_inverse_permutation\ $order}
		cli_base=$order
	fi

	if $persistent_change||$depth_changed||!$visited_16
		65536,1,1,2,sum((x>>[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]&1)<<(c?[$inverse_order]:[$order]))
		store. _persistent
		cli_base=$order
	fi

 	visited_16=1
else
	activate_randomize|=!$visited_8?!$index_8
	index_change:=$index_8!=$old_index_8
	shift_plane={"a=[${10-17}];
	              b=[${18-25}];
	              diff_mode=a!=b;
	              if(diff_mode,
	              	const use_swap_mode=$9;
	              	diff_pos=argmax(abs(a-b));
	              	use_swap_mode?(
	              		swap_pos=find(b,a[diff_pos],0,1);
	              		swap(b[diff_pos],b[swap_pos]);
	              		 set('order',v2s(b-1));
	              	):(
	              		position_start=b[diff_pos];
	              		position_final=a[diff_pos];
	              		differential=position_final<position_start?1:-1;
	              		fill(a,p,
	              			v=b[p];
	              			inrange(v,position_start,position_final,1,1)?(
	              				v+=differential;
	              			);
	              			v;
	              		);
	              		a[diff_pos]=position_final;
	              		set('order',v2s(a-1));
	              		);
	              );
	              diff_mode;"}
	persistent_change:=$activate_randomize||$index_change||$shift_plane

	if $activate_randomize
		index_8:=$index_8?v(1,40320,1,0):(v=v(1,40319,1,0);v+=v>=$index_8;);
		index_change=1
	fi

	if $index_change
		order=${rep_permutation_index2list\ 8,$index_8}
	elif $shift_plane
		index_8=${rep_permutation_list2index\ $order}
	elif $depth_changed||!$visited_8
		order={[${10-17}]-1}
		inverse_order=${rep_inverse_permutation\ $order}
	fi

	if $persistent_change
		$plane_8_series:=[$order]+1
		inverse_order=${rep_inverse_permutation\ $order}
		cli_base=$order
	fi

	if $persistent_change||$depth_changed||!$visited_8
		256,1,1,2,sum((x>>[0,1,2,3,4,5,6,7]&1)<<(c?[$inverse_order]:[$order]))
		store. _persistent
		cli_base=$order
	fi

	visited_8=1
fi

cli_text=image.jpg\ rep_bitplane_shuffle\ {![$use_reverse_permutation,$mode_alpha]},$cli_base

if $mode_16?$index_16:$index_8
	gui_split_preview "
		round 0
		if "$mode_16" * 257 fi
		if !"$mode_alpha"&&(!(s&1)) shared 0,{s-2} fi
		$_persistent
		channels. "$use_reverse_permutation"
		map[-2] [-1]
		k[0]
		if "$mode_16" / 257 fi
		",${-3--1}
else gui_split_preview "skip \"$*\"",${-3--1}
fi

visible_8,visible_16:=[!$mode_16,$mode_16]<<1;

u "{"$use_reverse_permutation"}"\
"{"$mode_16"}"\
"{$3}"\
"{"$cli_text"}"\
"{"$cli_base"}"\
"{"$index_8"}_"$visible_8\
"{"$index_8"}"\
"{"$index_16"}"\
"{$9}"\
"{"$plane_8_0"}_"$visible_8\
"{"$plane_8_1"}_"$visible_8\
"{"$plane_8_2"}_"$visible_8\
"{"$plane_8_3"}_"$visible_8\
"{"$plane_8_4"}_"$visible_8\
"{"$plane_8_5"}_"$visible_8\
"{"$plane_8_6"}_"$visible_8\
"{"$plane_8_7"}_"$visible_8\
"{"$plane_8_0"}"\
"{"$plane_8_1"}"\
"{"$plane_8_2"}"\
"{"$plane_8_3"}"\
"{"$plane_8_4"}"\
"{"$plane_8_5"}"\
"{"$plane_8_6"}"\
"{"$plane_8_7"}"\
"{"$plane_16_0"}_"$visible_16\
"{"$plane_16_1"}_"$visible_16\
"{"$plane_16_2"}_"$visible_16\
"{"$plane_16_3"}_"$visible_16\
"{"$plane_16_4"}_"$visible_16\
"{"$plane_16_5"}_"$visible_16\
"{"$plane_16_6"}_"$visible_16\
"{"$plane_16_7"}_"$visible_16\
"{"$plane_16_8"}_"$visible_16\
"{"$plane_16_9"}_"$visible_16\
"{"$plane_16_a"}_"$visible_16\
"{"$plane_16_b"}_"$visible_16\
"{"$plane_16_c"}_"$visible_16\
"{"$plane_16_d"}_"$visible_16\
"{"$plane_16_e"}_"$visible_16\
"{"$plane_16_f"}_"$visible_16\
"{"$plane_16_0"}"\
"{"$plane_16_1"}"\
"{"$plane_16_2"}"\
"{"$plane_16_3"}"\
"{"$plane_16_4"}"\
"{"$plane_16_5"}"\
"{"$plane_16_6"}"\
"{"$plane_16_7"}"\
"{"$plane_16_8"}"\
"{"$plane_16_9"}"\
"{"$plane_16_a"}"\
"{"$plane_16_b"}"\
"{"$plane_16_c"}"\
"{"$plane_16_d"}"\
"{"$plane_16_e"}"\
"{"$plane_16_f"}"\
"{0}"\
"{"$mode_16"}"\
"{"$visited_8"}"\
"{"$visited_16"}"\
"{$-3}"\
"{$-2,$-1}"
#@gui Graphical Tiling Glitch (Interactive): fx_rep_x_graphical_tiling,fx_rep_x_graphical_tiling_preview(0)
#@gui:_=note("Launch the interactive graphical tiling window.\n\nDetails: The main purpose of this filter is to stimulate graphical tiling glitch observed in Microsoft Windows XP Operating System. However, you can also use it to tile images by hand to artistic purpose.\n\n<u>Please Read Instruction Below!</b>")
#@gui:_=separator(),_=note("<b>Main</b>)
#@gui:Initial Insertion Rate (milliseconds)=int(0,0,1000)
#@gui:Background Color=color(0,0,0)
#@gui:Autocrop and Separate?=bool(0)
#@gui:Reverse Layers?=bool(0)
#@gui:Output Mode=choice(1,"Tiled Only","New Layer","Blended")
#@gui:_=separator(),_=note("<b>Preview</b>)
#@gui:Background Mode=choice(0,"Image","Colored","Alpha")
#@gui:Offset=point(50,50,0,1,255,255,255,255)
#@gui:Duplicates=int(5,1,50)
#@gui:Display Message?=bool(1)
#@gui:_=separator(),_=note("<b><u>Instruction</u></b>)
#@gui:_=note("\n<b>All Mode</b>\n\n- O: Change Preview Mode\n- SPACE: Switch Mode\n- ESC: End Interactive Window\n\n<u>Important Note: Check the message in the title bar.</u>\n\n<b>Image Placement Mode</b>\n\n- D: Display Overlay Image\n- H: Flip Image Horizontally\n- V: Flip Image Vertically\n- Mouse Click: Move/Place Image\n- ARROW UP/DOWN: Change Tiling Image\n- ARROW LEFT/RIGHT: Rotate Image\n\n<b>Tiling Mode</b>\n\n- Mouse Move: Place Tile at Insertion Rate\n- ARROW UP/DOWN: Add/Subtract Insertion Rate by 100 ms\n- ARROW LEFT/RIGHT: Add/Subtract Insertion rate by 10 ms")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/8/9</i>.</small>")
fx_rep_x_graphical_tiling:
if !$6 rv fi

if $5 autocrop[^0]
else autocrop_components[^0] 0%,0%,1,1
fi

if $7 +rep_x_graphical_tiling[0] [1--1],$1,${2-4} k[0,-1] if $7==2 blend alpha fi
else rep_x_graphical_tiling[0] [1--1] k[0]
fi
fx_rep_x_graphical_tiling_preview:
if !$6 rv fi

if $5 autocrop[1]
else autocrop_components[1] 0%,0%,1,1
fi

k[0,1]

r. {w#0},{h#0},1,{s#0},0,0,.5,.5
r. 100%,100%,$11,100%,0,1

f. "begin(
		const offx=(100-$9-50)%;
		const offy=(100-$10-50)%;
	);
	j(offx*w*(z/(d-1)),offy*h*(z/(d-1)));"

if $8 k. fi

s. z

if $8!=1 blend alpha
else blend alpha drgba ${2-4}
fi

if $12
	if s==2||s==4 sh. 0,{s-2} fi
	text="Interactive Filter" to. $text,.5~,.5~,10%
	rm.
fi
#@gui Popcorn Fractal [Transformative]: fx_rep_pfrac_t_rs
#@gui:_=note("Generates Transformative Pickover Popcorn Fractal. Discovered by T.Gangopadhyay at XLRI in C.H.Area[E],Jamshedpur,India in 2012.\n\nThere are two style modes for Transformative Popcorn Fractal."),_=separator()
#@gui:_=note("<b>Main</b>"),_=separator()
#@gui:Points=int(50,1,200)
#@gui:Density=float(1,.01,10)
#@gui:H Variable=float(.05,-5,5)
#@gui:K Variable=float(3,-75,75)
#@gui:Zoom=float(.5,.1,10)
#@gui:Angle=float(45,-180,180)
#@gui:Origin=point(50,50,0,1,255,255,255,255)
#@gui:Use Swirling Hall Mode?=bool(0)
#@gui:_=separator(),_=note("<b>Trigonometric</b>")
#@gui:Mode=choice(0,"Trig-4","Trig-6")
#@gui:XY-Axis Mode?=bool(1)
#@gui:Expression A=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-3 - Include V?=bool(1)
#@gui:Expression B=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:B=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-3 - Include V?=bool(1)
#@gui:Expression A=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-3 - Include V?=bool(1)
#@gui:Expression B=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:B=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-3 - Include V?=bool(1)
#@gui:Expression C=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:C=choice(2,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-3 - Include V?=bool(1)
#@gui:Axis=choice(0,"X-Axis","Y-Axis")
#@gui:Expression A=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-3 - Include V?=bool(1)
#@gui:Expression B=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:B=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-3 - Include V?=bool(1)
#@gui:Expression A=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-3 - Include V?=bool(1)
#@gui:Expression B=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:B=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-3 - Include V?=bool(1)
#@gui:Expression C=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:C=choice(2,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-3 - Include V?=bool(1)
#@gui:Expression A=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-3 - Include V?=bool(1)
#@gui:Expression B=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:B=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-3 - Include V?=bool(1)
#@gui:Expression A=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:A-3 - Include V?=bool(1)
#@gui:Expression B=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:B=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:B-3 - Include V?=bool(1)
#@gui:Expression C=choice(0,"func_1[v0]","func_1[v0]+func_2[v1]","func_1[func_2[v0]+include_v?v]")
#@gui:C=choice(2,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-1=choice(1,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-2=choice(0,"Previous Value","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-1=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-2=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui:C-3 - Include V?=bool(1)
#@gui:_=separator(),_=note("<b>Shading</b>")
#@gui:Max Value (%)=float(100,0,100)
#@gui:Mid-Point Shift=float(0,-1,1)
#@gui:Sigmoid-Shift=float(0,-100,100)
#@gui:Value Shift=float(0,-1,1)
#@gui:Multiplier=float(.5,.1,10)
#@gui:Normalize=bool(0)
#@gui:Negate?=bool(0)
fx_rep_pfrac_t_rs:
if $10 # Trigometric-6
	if $11

		if $26==2 set_arg_a=$26,${30-32}
		elif $26==1 set_arg_a=$26,${28-29}
		else set_arg_a=${26-27}
		fi

		if $33==2 set_arg_b=$33,${37-39}
		elif $33==1 set_arg_b=$33,${35-36}
		else set_arg_b=${33-34}
		fi

		if $40==2 set_arg_c=$40,${44-46}
		elif $40==1 set_arg_c=$40,${42-43}
		else set_arg_c=${40-41}
		fi

		set_arg_d=$set_arg_a
		set_arg_e=$set_arg_b
		set_arg_f=$set_arg_c

	else

		if $62==2 set_arg_a=$62,${66-68}
		elif $62==1 set_arg_a=$62,${64-65}
		else set_arg_a=${62-63}
		fi

		if $69==2 set_arg_b=$69,${73-75}
		elif $69==1 set_arg_b=$69,${71-72}
		else set_arg_b=${69-70}
		fi

		if $76==2 set_arg_c=$76,${80-82}
		elif $76==1 set_arg_c=$76,${78-79}
		else set_arg_c=${76-77}
		fi

		if $97==2 set_arg_d=$97,${101-103}
		elif $97==1 set_arg_d=$97,${99-100}
		else set_arg_d=${97-98}
		fi

		if $104==2 set_arg_e=$104,${108-110}
		elif $104==1 set_arg_e=$104,${106-107}
		else set_arg_e=${104-105}
		fi

		if $111==2 set_arg_f=$111,${115-117}
		elif $111==1 set_arg_f=$111,${113-114}
		else set_arg_f=${111-112}
		fi

	fi

	form_args=$set_arg_a,$set_arg_b,$set_arg_c,$set_arg_d,$set_arg_e,$set_arg_f

else   # Trigometric-4

	if $11

		if $12==2 set_arg_a=$12,${16-18}
		elif $12==1 set_arg_a=$12,${14-15}
		else set_arg_a=${12-13}
		fi

		if $19==2 set_arg_b=$19,${23-25}
		elif $19==1 set_arg_b=$19,${21-22}
		else set_arg_b=${19-20}
		fi

		set_arg_c=$set_arg_a
		set_arg_d=$set_arg_b

	else

		if $48==2 set_arg_a=$48,${52-54}
		elif $48==1 set_arg_a=$48,${50-51}
		else set_arg_a=${48-49}
		fi

		if $55==2 set_arg_b=$48,${59-61}
		elif $55==1 set_arg_b=$48,${57-58}
		else set_arg_b=${55-56}
		fi

		if $83==2 set_arg_c=$83,${87-89}
		elif $83==1 set_arg_c=$83,${85-86}
		else set_arg_c=${83-84}
		fi

		if $90==2 set_arg_d=$90,${94-96}
		elif $90==1 set_arg_d=$90,${92-93}
		else set_arg_d=${90-91}
		fi

	fi

	form_args=$set_arg_a,$set_arg_b,$set_arg_c,$set_arg_d

fi

rep_popcorn_fractal_transformative_regular_and_swirling[0] {$9?-$1:$1},${2-6},{($7-50)/50},{((100-$8)-50)/50},$10,$form_args
if $118!=100 cut[0] 0,{iM*$118%} fi
rep_exponential_sigmoid_adjustment[0] ${119-121},{$123?-255:$122}
if $124 cut[0] 0,255 negate fi

t4_xy:=!$10&&$11?2
t6_xy:=$10&&$11?2
t4_sxy:=!$10&&!$11?2
t6_sxy:=$10&&!$11?2
t4_sxy_x:=$t4_sxy&&!$47?2
t4_sxy_y:=$t4_sxy&&$47?2
t6_sxy_x:=$t6_sxy&&!$47?2
t6_sxy_y:=$t6_sxy&&$47?2

t4_xy_expr_a_mode_0:=$t4_xy?$12==0?2
t4_xy_expr_a_mode_1:=$t4_xy?$12==1?2
t4_xy_expr_a_mode_2:=$t4_xy?$12==2?2

t4_xy_expr_b_mode_0:=$t4_xy?$19==0?2
t4_xy_expr_b_mode_1:=$t4_xy?$19==1?2
t4_xy_expr_b_mode_2:=$t4_xy?$19==2?2

t6_xy_expr_a_mode_0:=$t6_xy?$26==0?2
t6_xy_expr_a_mode_1:=$t6_xy?$26==1?2
t6_xy_expr_a_mode_2:=$t6_xy?$26==2?2

t6_xy_expr_b_mode_0:=$t6_xy?$33==0?2
t6_xy_expr_b_mode_1:=$t6_xy?$33==1?2
t6_xy_expr_b_mode_2:=$t6_xy?$33==2?2

t6_xy_expr_c_mode_0:=$t6_xy?$40==0?2
t6_xy_expr_c_mode_1:=$t6_xy?$40==1?2
t6_xy_expr_c_mode_2:=$t6_xy?$40==2?2

t4_x_expr_a_mode_0:=$t4_sxy_x?$48==0?2
t4_x_expr_a_mode_1:=$t4_sxy_x?$48==1?2
t4_x_expr_a_mode_2:=$t4_sxy_x?$48==2?2

t4_x_expr_b_mode_0:=$t4_sxy_x?$55==0?2
t4_x_expr_b_mode_1:=$t4_sxy_x?$55==1?2
t4_x_expr_b_mode_2:=$t4_sxy_x?$55==2?2

t6_x_expr_a_mode_0:=$t6_sxy_x?$62==0?2
t6_x_expr_a_mode_1:=$t6_sxy_x?$62==1?2
t6_x_expr_a_mode_2:=$t6_sxy_x?$62==2?2

t6_x_expr_b_mode_0:=$t6_sxy_x?$69==0?2
t6_x_expr_b_mode_1:=$t6_sxy_x?$69==1?2
t6_x_expr_b_mode_2:=$t6_sxy_x?$69==2?2

t6_x_expr_c_mode_0:=$t6_sxy_x?$76==0?2
t6_x_expr_c_mode_1:=$t6_sxy_x?$76==1?2
t6_x_expr_c_mode_2:=$t6_sxy_x?$76==2?2

t4_y_expr_a_mode_0:=$t4_sxy_y?$83==0?2
t4_y_expr_a_mode_1:=$t4_sxy_y?$83==1?2
t4_y_expr_a_mode_2:=$t4_sxy_y?$83==2?2

t4_y_expr_b_mode_0:=$t4_sxy_y?$90==0?2
t4_y_expr_b_mode_1:=$t4_sxy_y?$90==1?2
t4_y_expr_b_mode_2:=$t4_sxy_y?$90==2?2

t6_y_expr_a_mode_0:=$t6_sxy_y?$97==0?2
t6_y_expr_a_mode_1:=$t6_sxy_y?$97==1?2
t6_y_expr_a_mode_2:=$t6_sxy_y?$97==2?2

t6_y_expr_b_mode_0:=$t6_sxy_y?$104==0?2
t6_y_expr_b_mode_1:=$t6_sxy_y?$104==1?2
t6_y_expr_b_mode_2:=$t6_sxy_y?$104==2?2

t6_y_expr_c_mode_0:=$t6_sxy_y?$111==0?2
t6_y_expr_c_mode_1:=$t6_sxy_y?$111==1?2
t6_y_expr_c_mode_2:=$t6_sxy_y?$111==2?2

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}_"$t4_xy\
"{$13}_"$t4_xy_expr_a_mode_0\
"{$14}_"$t4_xy_expr_a_mode_1\
"{$15}_"$t4_xy_expr_a_mode_1\
"{$16}_"$t4_xy_expr_a_mode_2\
"{$17}_"$t4_xy_expr_a_mode_2\
"{$18}_"$t4_xy_expr_a_mode_2\
"{$19}_"$t4_xy\
"{$20}_"$t4_xy_expr_b_mode_0\
"{$21}_"$t4_xy_expr_b_mode_1\
"{$22}_"$t4_xy_expr_b_mode_1\
"{$23}_"$t4_xy_expr_b_mode_2\
"{$24}_"$t4_xy_expr_b_mode_2\
"{$25}_"$t4_xy_expr_b_mode_2\
"{$26}_"$t6_xy\
"{$27}_"$t6_xy_expr_a_mode_0\
"{$28}_"$t6_xy_expr_a_mode_1\
"{$29}_"$t6_xy_expr_a_mode_1\
"{$30}_"$t6_xy_expr_a_mode_2\
"{$31}_"$t6_xy_expr_a_mode_2\
"{$32}_"$t6_xy_expr_a_mode_2\
"{$33}_"$t6_xy\
"{$34}_"$t6_xy_expr_b_mode_0\
"{$35}_"$t6_xy_expr_b_mode_1\
"{$36}_"$t6_xy_expr_b_mode_1\
"{$37}_"$t6_xy_expr_b_mode_2\
"{$38}_"$t6_xy_expr_b_mode_2\
"{$39}_"$t6_xy_expr_b_mode_2\
"{$40}_"$t6_xy\
"{$41}_"$t6_xy_expr_c_mode_0\
"{$42}_"$t6_xy_expr_c_mode_1\
"{$43}_"$t6_xy_expr_c_mode_1\
"{$44}_"$t6_xy_expr_c_mode_2\
"{$45}_"$t6_xy_expr_c_mode_2\
"{$46}_"$t6_xy_expr_c_mode_2\
"{$47}_"{!$11?2}\
"{$48}_"$t4_sxy_x\
"{$49}_"$t4_x_expr_a_mode_0\
"{$50}_"$t4_x_expr_a_mode_1\
"{$51}_"$t4_x_expr_a_mode_1\
"{$52}_"$t4_x_expr_a_mode_2\
"{$53}_"$t4_x_expr_a_mode_2\
"{$54}_"$t4_x_expr_a_mode_2\
"{$55}_"$t4_sxy_x\
"{$56}_"$t4_x_expr_b_mode_0\
"{$57}_"$t4_x_expr_b_mode_1\
"{$58}_"$t4_x_expr_b_mode_1\
"{$59}_"$t4_x_expr_b_mode_2\
"{$60}_"$t4_x_expr_b_mode_2\
"{$61}_"$t4_x_expr_b_mode_2\
"{$62}_"$t6_sxy_x\
"{$63}_"$t6_x_expr_a_mode_0\
"{$64}_"$t6_x_expr_a_mode_1\
"{$65}_"$t6_x_expr_a_mode_1\
"{$66}_"$t6_x_expr_a_mode_2\
"{$67}_"$t6_x_expr_a_mode_2\
"{$68}_"$t6_x_expr_a_mode_2\
"{$69}_"$t6_sxy_x\
"{$70}_"$t6_x_expr_b_mode_0\
"{$71}_"$t6_x_expr_b_mode_1\
"{$72}_"$t6_x_expr_b_mode_1\
"{$73}_"$t6_x_expr_b_mode_2\
"{$74}_"$t6_x_expr_b_mode_2\
"{$75}_"$t6_x_expr_b_mode_2\
"{$76}_"$t6_sxy_x\
"{$77}_"$t6_x_expr_c_mode_0\
"{$78}_"$t6_x_expr_c_mode_1\
"{$79}_"$t6_x_expr_c_mode_1\
"{$80}_"$t6_x_expr_c_mode_2\
"{$81}_"$t6_x_expr_c_mode_2\
"{$82}_"$t6_x_expr_c_mode_2\
"{$83}_"$t4_sxy_y\
"{$84}_"$t4_y_expr_a_mode_0\
"{$85}_"$t4_y_expr_a_mode_1\
"{$86}_"$t4_y_expr_a_mode_1\
"{$87}_"$t4_y_expr_a_mode_2\
"{$88}_"$t4_y_expr_a_mode_2\
"{$89}_"$t4_y_expr_a_mode_2\
"{$90}_"$t4_sxy_y\
"{$91}_"$t4_y_expr_b_mode_0\
"{$92}_"$t4_y_expr_b_mode_1\
"{$93}_"$t4_y_expr_b_mode_1\
"{$94}_"$t4_y_expr_b_mode_2\
"{$95}_"$t4_y_expr_b_mode_2\
"{$96}_"$t4_y_expr_b_mode_2\
"{$97}_"$t6_sxy_y\
"{$98}_"$t6_y_expr_a_mode_0\
"{$99}_"$t6_y_expr_a_mode_1\
"{$100}_"$t6_y_expr_a_mode_1\
"{$101}_"$t6_y_expr_a_mode_2\
"{$102}_"$t6_y_expr_a_mode_2\
"{$103}_"$t6_y_expr_a_mode_2\
"{$104}_"$t6_sxy_y\
"{$105}_"$t6_y_expr_b_mode_0\
"{$106}_"$t6_y_expr_b_mode_1\
"{$107}_"$t6_y_expr_b_mode_1\
"{$108}_"$t6_y_expr_b_mode_2\
"{$109}_"$t6_y_expr_b_mode_2\
"{$110}_"$t6_y_expr_b_mode_2\
"{$111}_"$t6_sxy_y\
"{$112}_"$t6_y_expr_c_mode_0\
"{$113}_"$t6_y_expr_c_mode_1\
"{$114}_"$t6_y_expr_c_mode_1\
"{$115}_"$t6_y_expr_c_mode_2\
"{$116}_"$t6_y_expr_c_mode_2\
"{$117}_"$t6_y_expr_c_mode_2\
"{$118}"\
"{$119}"\
"{$120}"\
"{$121}"\
"{$122}_"{$123?1:2}\
"{$123}"\
"{$124}"
#@gui Popcorn Fractal: fx_rep_pfrac,fx_rep_pfrac_preview
#@gui:_=note("Fractal attributed to Clifford Pickover. Code adapted from Paul Bourke's C code."),_=separator()
#@gui:_=note("<b>Main</b>")
#@gui:Points=int(50,1,200)
#@gui:Density=float(1,.01,2)
#@gui:H Variable=float(.05,-5,5)
#@gui:K Variable=float(3,-75,75)
#@gui:Zoom=float(1,.1,10)
#@gui:Angle=float(0,-180,180)
#@gui:Origin=point(50,50,0,1,255,255,255,255)
#@gui:_=separator(),_=note("<b>Trigonometric</b>")
#@gui:Mode=choice(0,"Trig-4","Trig-6")
#@gui:XY-Axis Mode?=bool(1)
#@gui:X-Axis Formula S=choice(0,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:X-Axis Formula T=choice(1,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:X-Axis Formula U=choice(2,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:Y-Axis Formula S=choice(0,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:Y-Axis Formula T=choice(1,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:Y-Axis Formula U=choice(2,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:XY-Axis Formula S=choice(0,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:XY-Axis Formula T=choice(1,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:XY-Axis Formula U=choice(2,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui:_=separator(),_=note("<b>Output</b>")
#@gui:Midpoint Shift=float(0,-1,1)
#@gui:Multiplier=float(1,.1,10)
#@gui:Normalize=bool(0)
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Show Fill Ratio?=bool(0)
#@gui:_=note("<small>Fill Ratio provides information on whether there is sufficient filled pixels on canvas. The closer to 100%, the more the canvas is filled.</small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/11/1</i>.</small>")
fx_rep_pfrac:
ox={(($7-50)/100)*2}
oy={(($8-50)/100)*-2}
setarg=${1-6},$ox,$oy
midpoint_shift={1-abs($20)}

if $10
	if $9 setarg2=${17-19}
	else setarg2=$17,$19
	fi
else
	if $9 setarg2=${11-16}
	else setarg2=$11,$13,$14,$16
	fi
fi

local[0] {

	rep_pfrac $setarg,$9,$setarg2
	val_max={iM}
	n 0,1

	if $20>=0 f i^$midpoint_shift
	else f 1-((1-i)^$midpoint_shift)
	fi

	if $22 n 0,255
	else * {$21*$val_max}
	fi

}
fx_rep_pfrac_preview:
fx_rep_pfrac ${1-22}
if $23
 +f[0] i>0?1
	fillperc={ia*100} rm.
	fillperc_l={int($fillperc)}
	fillperc_r={int(($fillperc-$fillperc_l)*100)}
	fillratio=$fillperc_l
	fillratio.=.
	fillratio.=$fillperc_r
	fillratio.=%
	to[0] $fillratio,.5~,.5~,18%
fi
k[0]

a={!$10?2:0}
b={$10?2:0}
c={!$10?($9?2:0):0}
d={$10?($9?2:0):0}

u "{$1}"\
  "{$2}"\
  "{$3}"\
  "{$4}"\
  "{$5}"\
  "{$6}"\
  "{$7,$8}"\
  "{$9}"\
  "{$10}"\
  "{$11}_"$a\
  "{$12}_"$c\
  "{$13}_"$a\
  "{$14}_"$a\
  "{$15}_"$c\
  "{$16}_"$a\
  "{$17}_"$b\
  "{$18}_"$d\
  "{$19}_"$b\
  "{$20}"\
  "{$21}_"{$22?1:2}\
  "{$22}"\
  "{$23}"
#@gui Blur [Splinter]: fx_rep_blur_splinter,fx_rep_blur_splinter_preview
#@gui:_=note(" Apply Splinter Blur.\n\nBased off observation from using Splinter Blur plugin within Paint.NET made by Ed Harvey, and it is inspired by this filter.\n\nComputationally intensive!"),_=separator()
#@gui:Half Image-Diagonal(%) = float(20,0.1,100)
#@gui:Duplicates=int(3,3,100)
#@gui:Angle=float(0,-180,180)
#@gui:Thickness(%)=float(0,0,100)
#@gui:Contrast(%)=float(0,0,100)
#@gui:Balance(%)=float(0,-100,100)
#@gui:Boundary=choice(3,"None","Neumann","Periodic","Mirror")
#@gui:Use Bi-sided Convolution?=bool(0)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/10</i>.</small>")
fx_rep_blur_splinter:
rep_blur_splinter $1%,$2,$3,$4%,{$6%},{$5%},$7,$8 cut 0,255
fx_rep_blur_splinter_preview:
gui_split_preview "fx_rep_blur_splinter ${1-8}",${-3--1}
#@gui Diffusion Limited Aggregation: fx_rep_dla,fx_rep_dla_preview(0)*
#@gui:Attempts=int(100,5,2000)
#@gui:Aggregation Mode=choice(0,"Corners","Axis[Slow!]","All-Around","Alternating")
#@gui:Stem Tone=choice("Dark",Light")
#@gui:Border Size=int(0,0,100)
#@gui:Spread Factor(%)=float(0,0,100)
#@gui:Utilize Dense Point Map=bool(0)
#@gui:Preserve Silhoutte=bool(1)
#@gui:Negate=bool(0)
#@gui:Regenerate Map=button()
#@gui:Old Attempts=int(100,5,2000)_0
#@gui:Old Aggregation Mode=choice(0,"Corners","Axis[Slow!]","All-Around","Alternating")_0
#@gui:Old Stem Tone=choice("Dark",Light")_0
#@gui:Old Border Size=int(0,0,100)_0
#@gui:Old Spread Factor(%)=float(0,0,100)_0
#@gui:Old Utilize Dense Point Map=bool(0)_0
#@gui:Old Preserve Silhoutte=bool(1)_0
#@gui:Old Negate=bool(0)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2023/01/04</i>.</small>")
fx_rep_dla:
skip $*
if narg($_persistent)
	rm $_persistent
else
	if $8
		foreach {
			if s==2||s==4
				shared 0,{s-2}
			fi
			negate[-1]
			k[0]
		}
	fi
	rep_diffusion_limited_aggregation ${1-2},{$5%},${3-4},${6-7}
fi
fx_rep_dla_preview:
status_changed={[${1-8}]!=[${10-17}]}

if !(narg($_persistent)?(!$9&&!$status_changed))
	if $8
		foreach {
			if s==2||s==4
				shared 0,{s-2}
			fi
			negate[-1]
			k[0]
		}
	fi

	rep_diffusion_limited_aggregation ${1-2},{$5%},${3-4},${6-7}
	* 255
	store _persistent
fi

rm $_persistent k[0] crop $_preview_x0,$_preview_y0,$_preview_x1,$_preview_y1

u "{$1}"\
  "{$2}"\
  "{$3}"\
  "{$4}"\
  "{$5}"\
  "{$6}"\
  "{$7}"\
  "{$8}"\
  "{0}"\
  "{$1}"\
  "{$2}"\
  "{$3}"\
  "{$4}"\
  "{$5}"\
  "{$6}"\
  "{$7}"\
  "{$8}"
#@gui Pseudorandom Noise: fx_rep_mj_prn,fx_rep_mj_prn_preview
#@gui:_=note("Generates pseudorandom noise.\n\nBased off <a href="https://forums.getpaint.net/topic/111659-regular-noise-texture-ymd-20170815/">MadJik's Regular Noise Paint.NET Plugin</a>. This is a extended version. Preview may not be accurate!")
#@gui:_=separator(),_=note("<b>Preliminary</b>")
#@gui:K-1=float(8,-8,8)
#@gui:K-2=float(2,-8,8)
#@gui:K Mode=choice(0,"Mode 0","Mode 1")
#@gui:Shift=float(1,-256,256)
#@gui:_=separator(),_=note("<b>Non-K Factors</b>")
#@gui:Color Angle=float(0,-180,180)
#@gui:Pixel Size=int(1,1,16)
#@gui:Position=point(50,50,0,1,128,128,128,255)
#@gui:Formula=choice(1,"Gray","Sinusoidal","RGB","Tangent")
#@gui:Double Pixel Axis?=bool(0)
#@gui:_=separator(),_=note("<b>Grid</b>")
#@gui:Activate Grid?=bool(0)
#@gui:Shade=float(0,0,255)
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/1/17</i>.</small>")
fx_rep_mj_prn:
pos_x={min(max(($7/100-.5)*2,-1),1)}
pos_y={min(max(($8/100-.5)*2,-1),1)}
rep_mj_prn ${1-2},${4-6},$pos_x,$pos_y,$9,$3,${11-12},$10
fx_rep_mj_prn_preview:
fx_rep_mj_prn $*
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}_"{$11?2:1}
#@gui HSX Posterize/Index: fx_rep_p_i
#@gui:Hue Bands=int(10,2,360)
#@gui:Saturation Bands=int(10,2,100)
#@gui:Luminosity Bands=int(10,2,100)
#@gui:Dithering (%)=float(50,0,100)
#@gui:Start Hue=float(0,0,360)
#@gui:Colour Space=choice(2,"HSI","HSL","HSV","HCY")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2025/11/11</i>.</small>")
fx_rep_p_i:
rep_hsx_poster_index ${1-3},{$4%},${5-6}
#@gui Tiled Zoom: fx_rep_tz,fx_rep_tz_preview(0)
#@gui:_=note("Create tiled zoom."),_=separator()
#@gui:Square Width - Half Image-Diagonal(%)=float(10,1,100)
#@gui:Square Height - Half Image-Diagonal(%)=float(10,1,100)
#@gui:Scale=float(2,1,10)
#@gui:Boundary=choice(0,"None","Neumann","Periodic","Mirror")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/22</i>.</small>")
fx_rep_tz:
half_img_diag={norm(w,h)/2}
sw={$1%*$half_img_diag}
sh={$2%*$half_img_diag}
rep_tiled_zoom $sw,$sh,$3,$4
fx_rep_tz_preview:
gui_split_preview "fx_rep_tz ${1-4}",${-3--1}
#@gui Reverse Digits:fx_rep_rd,fx_rep_rd_preview(0)
#@gui:_=note("Reverses digits of image. Used for glitch art.\n\n<small><b>Note:</b>Max-1 for Out-Of-Bound Mode is only applicable in float color space.</small>")
#@gui:_=separator(),_=note("<b>Color and Alpha</b>")
#@gui:Colour Space=choice(0,"RGB-8","SRGB-8","RYB-8","CMY","CMYK","HSI-8,"HSL-8","HSV-8","LAB-8","LCH-8","YCBCR-8","YIQ-8","YUV-8","YES-8","K1-8","Ohta-8")
#@gui:Use Alpha?=bool(0)
#@gui:_=separator(),_=note("<b>Values</b>")
#@gui:Base=float(10,1.01,64)
#@gui:Out-Of-Bound Mode=choice(0,"None","Periodic","Continuous)
#@gui:Cut Value?=bool(0)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/26</i>.</small>")
fx_rep_rd:
if $1 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$1,,srgb,ryb,cmy,,hsi8,hsl8,hsv8,lab8,lch8,ycbcr,yiq8,uv8,yes8,k18,ohta8} fi

not_cmyk={$1!=4}

foreach {

	tcr,convert_back,contain_alpha=3,0,{s==2||s==4}

	if (s==3||s==4)&&$1
		convert_back=1
		if $not_cmyk
			$convert_colors_fwd
		else
			if s==3 tcr=4 rgb2cmyk
			elif s==4 tcr=4 s c,-3 rgb2cmyk.. a c
			fi
		fi
	fi

	if $contain_alpha&&!$2 shared 0,{s-2} fi

	rep_reverse_digits. ${3-4}
	if $5&&!$4 cut. 0,255 fi
	rm.

	if $convert_back
		if $not_cmyk
			$convert_colors_bwd
		else
			if s==4 cmyk2rgb
			elif s==5 s c,-4 cmyk2rgb.. a c
			fi
		fi
	fi
}
fx_rep_rd_preview:
gui_split_preview "fx_rep_rd ${1-5}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}_"{1+!$4}\
"{$6}"\
"{$7,$8}"
#@gui Chirikov-Taylor: fx_rep_cstdmap,fx_rep_cstdmap_preview
#@gui:_=note("Creates Chirikov-Taylor discrete map.")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Lines=int(500,1,10000)
#@gui:Points per line=int(5000,1,100000)
#@gui:K=float(1,-5,5)
#@gui:Mode=choice(0,"Regular","Symmetric Modified")
#@gui:Center Main Rotor=bool(0)
#@gui:Orientation=choice(0,"XY",YX")
#@gui:Multithreaded Processing=bool(1)
#@gui:_=separator(),_=note("<b>Scaling</b>")
#@gui:Factor=float(1,.1,10)
#@gui:Use Image Ratio?=bool(0)
#@gui:_=separator(),_=note("<b>Coloring</b>"),_=note("<u>Preliminary</u>")
#@gui:Mode=choice(0,"Grayscale","HSX","Palette","Random","From Image")
#@gui:Use Alpha?=bool(0)
#@gui:_=separator(),_=note("<u>Additional</u>")
#@gui:HSX Mode=choice(2,"HCY","HSI","HSL/HSV")
#@gui:Palette=choice(0,"Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Color Count=int(20,2,360)
#@gui:Color Seed=int(0,0,100000)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_cstdmap:
srand $15
if $10==4 $14,1,1,1,u(0,1) store. randorder fi
ww={w}
hh={h}
ld={w>h}
md={max(w,h)}
ti={$!-1}
rep_cstdmap {$9?-1*$8*100:$8*100}%,${1-7}
+f. i?1 store. chan

if $10==0
 if $11 +eq. 0 negate. -.. 1 *.. . n.. 0,255 *. 255 a[-2,-1] c
 else n. 0,255
 fi
elif $10==1 -. 1 *. {359.999999/iM#-1} $chan . if $11 . *. 255 fi a[^0-$ti] c
 if $12==0 sh. 2 *. .5 rm. hcy2rgb.
 elif $12==1 hsi2rgb.
 elif $12==2 hsv2rgb.
 fi
elif $10==2 r. 100%,100%,1,3,1 pal {$13+1} f.. i0?i(#-1,(i-1)%w#-1,0) rm. if $11 $chan *. 255 a[-2,-1] c fi
elif $10==3 r. 100%,100%,1,3,1 $14,1,1,3,u(0,255) f.. i0?i(#-1,(i-1)%w#-1,0) rm. if $11 $chan *. 255 a[-2,-1] c fi
elif $10==4 +channels[0] 0,2 +colormap. $14,0,0 rm.. $randorder pixelsort.. +,x,[-1] rm. r.. 100%,100%,1,3 f.. i0?i(#-1,(i-1)%w#-1,0) rm. if $11 $chan *. 255 a[-2,-1] c fi
fi

if $8<1
 if $ld r. {$ww*($6?($4&&$5?2:1):1)},{max($hh,$md)*($6?($4&&$5?2:1):1)},100%,100%,0,2,.5,.5
 else r. {max($ww,$md)*($6?($4&&$5?2:1):1)},{$hh*($6?($4&&$5?2:1):1)},100%,100%,0,2,.5,.5
 fi
elif $8>1
 if !$9 r. {$md*($6?($4&&$5?2:1):1)},{$md*($6?1:($4&&$5?2:1))},100%,100%,6
 else r. {$ww*($6?($4&&$5?2:1):1)},{$hh*($6?1:($4&&$5?2:1))},100%,100%,6
 fi
fi
mv. 0
if same('$host','paintdotnet') k[0] fi
fx_rep_cstdmap_preview:
fx_rep_cstdmap $*
set_a={(($10==3)||($10==4))?2:0}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}_"{$10==1?2:0}\
"{$13}_"{$10==2?2:0}\
"{$14}_"$set_a\
"{$15}_"$set_a
#@gui Gaussian Blur By Color Space: fx_rep_blur_cs,fx_rep_blur_cs_preview
#@gui:XY-Amplitude=float(3,0,100)
#@gui:X-Amplitude=float(0,0,20)
#@gui:Y-Amplitude=float(0,0,20)
#@gui:Boundary=choice(1,"Black","Nearest")
#@gui:_=separator()
#@gui:Color Space=choice(0,"RGB","SRGB","RYB","CMY","CMYKA","HCY","HSI","HSL","HSV","LAB","LCH")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/10/04</i>.</small>")
fx_rep_blur_cs:
tcr=3
if $5 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$5,,srgb,ryb,cmy,,hcy,hsi,hsl,hsv,lab,lch} fi

foreach {

	if $5
		if $5!=4
			$convert_colors_fwd.
		else
			if s==3 rgb2cmyk tcr+=1
			elif s==4 s c,-3 rgb2cmyk.. a c
			fi
		fi
	fi

	_fx_blur_gaussian $1,$2,$3,$4

	if $5
		if $5!=4&&$5
			$convert_colors_bwd.
		else
			if s==4 cmyk2rgb tcr-=1
			elif s==5 s c,-4 cmyk2rgb.. a c
			fi
		fi
	fi

}
fx_rep_blur_cs_preview:
gui_split_preview "fx_rep_blur_cs ${1-5}",${-3--1}
#@gui Dynamic Contrast: rep_dynamic_contrast,rep_dynamic_contrast_preview
#@gui:Amount=float(0,-64,64)
#@gui:Threshold=float(128,0,255)
#@gui:Intensity=float(255,0,255)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("Code adapted from <a href="https://forums.getpaint.net/topic/117538-dynamic-contrast/?tab=comments#comment-578867">Source Code to Dynamic Contrast PDN plugin</a> made by Remake.")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/18</i>.</small>")
rep_dynamic_contrast_preview: gui_split_preview "rep_dynamic_contrast ${1-3}",${-3--1}
#@gui Panel Image: rep_fx_shift,rep_fx_shift_preview
#@gui:Offset=point(50,50,0,1,255,255,255,255)
#@gui:Boundary=choice(2,"None","Neumann","Periodic","Mirror")
#@gui:Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/2/04</i>.</small>")
rep_fx_shift: f "begin(const ox=($1-50)/100*(w-1);const oy=($2-50)/100*(h-1););
i(x-ox,y-oy,z,c,$4,$3);"
rep_fx_shift_preview: gui_split_preview "rep_fx_shift ${1-4}",${-3--1}
#@gui Henon Phase Diagram:fx_rep_henon_phase_diagram,fx_rep_henon_phase_diagram_preview
#@gui:_=note("Creates Henon Phase Diagram.\n\n<b>Warning!:</b> If your image does not show up as expected, you may have to increase points per line and/or lines. Preview is inaccurate!")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:A-Factor=float(2.569,-3.1415,3.1415)
#@gui:Lines=int(500,1,1000000)
#@gui:Points Per Line=int(1000,1,2000)
#@gui:X0-Start=float(-.5,-5,0)
#@gui:X0-End=float(.5,0,5)
#@gui:X0-Increments=int(8,1,14)
#@gui:_=separator(),_=note("<b>Transformation</b>")
#@gui:Scale=float(1,.01,4)
#@gui:Rotation=float(0,-180,180)
#@gui:Position=point(50,50,0,1,255,255,255,255)
#@gui:_=separator(),_=note("<b>Post-Processing</b>")
#@gui:Subpixel Level=float(0,0,10)
#@gui:_=separator(),_=note("<b>Coloring</b>"),_=note("<u>Preliminary</u>")
#@gui:Mode=choice(0,"Grayscale","HSX","Palette")
#@gui:Use Alpha?=bool(0)
#@gui:_=separator(),_=note("<u>Additional</u>")
#@gui:Gray Output=choice(0,"Normalized","Cut","Threshold")
#@gui:Multiplier=float(1,.01,50)
#@gui:HSX Mode=choice(2,"HCY","HSI","HSL/HSV")
#@gui:Palette=choice(0,"Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Color Count=int(20,2,360)_0
#@gui:Color Seed=int(0,0,100000)_0
#@gui:Hue Shift(%)=float(0,0,100)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_henon_phase_diagram:
init_sub={abs($11)}
sub={$init_sub+1}
ww={w} hh={h}
{w*$sub},{h*$sub},1,1,-1
rm..

setarg=$1,$7,$8,$9%,$10%,${2-6}

if $12==0 #Grayscale Mode#

 if $13 #Use Alpha#
  rep_henon_phase_diagram $setarg,{$14==2?3:2}
  if $14==2 {w},{h},1,1,255 rv[-2,-1] a[-2,-1] c r. $ww,$hh,100%,100%,2 sh. 1 n. 0,255 rm.
  else
   inpaint_pde[-3] [-2],1,0,0,1 rm[-2] a[-2,-1] c r. $ww,$hh,100%,100%,2
   if $14 sh. 0 *. $15 cut. 0,255 rm. sh. 1 n. 0,255 rm.
   else sh. 0 sh.. 1 n[-2,-1] 0,255 rm[-2,-1]
   fi
  fi
 else #Do not use Alpha#
  rep_henon_phase_diagram $setarg,{$14>1?3}
  r. $ww,$hh,100%,100%,2
  if $14==1
   *. $15 cut. 0,255
  else
   n. 0,255
  fi
 fi

elif $12==1 #HSX Mode#

 if $13 #Use Alpha#

  rep_henon_phase_diagram $setarg,2
  n... 0,360
  inpaint_pde[-3] [-2],1,0,0,1 rm[-2]

  l.. { {w},{h},100%,2,1 a[-2,-1] c }

  if $16==0 hcy2rgb..
  elif $16==1 hsi2rgb..
  elif $16==2 hsv2rgb..
  fi

  a[-2,-1] c
  r. $ww,$hh,100%,100%,2
  sh. 3 n. 0,255 rm.

 else #Do not use Alpha#

  rep_henon_phase_diagram $setarg,1
  n.. 0,360
  r. 100%,100%,100%,2
  a[-2,-1] c

  if $16==0 hcy2rgb.
  elif $16==1 hsi2rgb.
  elif $16==2 hsv2rgb.
  fi

  r. $ww,$hh,100%,100%,2

 fi

elif $12==2 #Palette#

 +pal {$17+1}

 if $13 #Use Alpha#
  rep_henon_phase_diagram[-2] $setarg,2
  *[-4] {(w#-1-1)/iM#-4}
  vmin={im#-4}
  {w#-4},{h#-4},1,3,pos=i(#-4,x,y,0,0);pos!=$vmin?I(#-1,pos,0,0,1);
  inpaint_pde[-1] [-4],1,0,0,1
  rv[-1,-3] a[-1,-3] c
  rm[-4,-3,-1]
  r. $ww,$hh,100%,100%,2
  sh. 3 n. 0,255 rm.
 else #Do not use Alpha#
  rep_henon_phase_diagram[-2] $setarg
  *[-2] {(w#-1-1)/iM#-2}
  vmin={im#-2}
  {w#-2},{h#-2},1,3,pos=i(#-2,x,y,0,0);pos!=$vmin?I(#-1,pos,0,0,1);
  rm[-3,-2]
  r. $ww,$hh,100%,100%,2
 fi

#elif $12==3 TODO:Random#
#elif $12==4 TODO:From Image
fi
fx_rep_henon_phase_diagram_preview:
fx_rep_henon_phase_diagram $*
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9,$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}_"{!$12?2}\
"{$15}_"{!$12?($14==1?2)}\
"{$16}_"{$12==1?2}\
"{$17}_"{$12==2?2}\
"{$18}"\ #TODO#
"{$19}"\ #TODO#
"{$20}" #TODO#
#@gui Statistical Average: fx_rep_bchstatfunc_average,fx_rep_bchstatfunc_average
#@gui:Mode=choice(0,"RGB","sRGB","RYB","LAB")
#@gui:Preserve Alpha?=bool(0)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2024/01/15</i>.</small>")
fx_rep_bchstatfunc_average:
if $1 convert_colors_bwd,convert_colors_fwd=${rep_cs_arg\ 2,$1,,srgb,ryb,lab} fi

m __$0_average_per_channels:$convert_colors_fwd" +resize 1,1,1,100%,2 ri[-1] [-2] remove[-2] "$convert_colors_bwd

foreach {
	if !(s&1)&&!$1
		s c,-{s-1}
		__$0_average_per_channels[0]
		a c
	else
		__$0_average_per_channels
	fi
}

um __$0_average_per_channels
#@gui Shear: fx_rep_shear,fx_rep_shear_preview
#@gui:_=note("Shears image within 3/4 dimensions")
#@gui:_=separator()
#@gui:Axis-by-Axis Shear=~choice(0,"XY","XZ","XC","YX","YZ","YC","ZX","ZY","ZC","CX","CY","CZ")
#@gui:Axis-by-Axis Shear=~choice(0,"XY","XC","YX","YC","CX","CY")
#@gui:Axis-string=value("place_string_here")
#@gui:Angle=~float(45,-89,89)
#@gui:Centre (%)=~float(50,0,100)
#@gui:Boundary=~choice(2,"None","Neumann","Periodic","Mirror")
#@gui:Interpolation=~choice(2,"Nearest Neighbor","Linear","Bicubic")
#@gui:Colour Space=choice(0,"RGB","sRGB","RYB","CMY","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui:Output Mode=choice("Cropped","Full")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2025/11/10</i>.</small>")
fx_rep_shear:
cs_bwd,cs_fwd=${rep_cs_arg\ 2,$8,,srgb,ryb,cmy,hcy,hsi,hsl,hsv,lab8,lch8,yiq8,yuv8,ycbcr,ycbcrglic,xyz8,yes8,k18,ohta8}
use_full={v='$3';!(v[0]==_'c')}
use_z_processing={isin(_'z',{'$3'})}
if $use_z_processing a z fi
to_automode
if $8 $cs_fwd fi
rep_shear ${3-4},$5%,${6-7},{$9&&$use_full}
if $8 $cs_bwd fi
if $use_z_processing s z fi
fx_rep_shear_preview:
__fx_rep_shear_preview_start

cs_bwd,cs_fwd=${rep_cs_arg\ 2,$8,,srgb,ryb,cmy,hcy,hsi,hsl,hsv,lab8,lch8,yiq8,yuv8,ycbcr,ycbcrglic,xyz8,yes8,k18,ohta8}

if $is_all_dimensions_same
	axis_string=${arg0\ $1,xy,xz,xc,yx,yz,yc,zx,zy,zc,cx,cy,cz}
else
	axis_string=${arg0\ $2,xy,xc,yx,yc,cx,cy}
fi

use_full={v='$axis_string';!(v[0]==_'c')}

use_z_processing={isin(_'z',{'$axis_string'})}

if $use_z_processing a z fi

to_automode

if $8 $cs_fwd fi
rep_shear $axis_string,$4,$5%,${6-7},{$9&&$use_full}
if $8 $cs_bwd fi

if $use_z_processing s z fi

u "{$1}_"$is_all_dimensions_same\
  "{$2}_"$otherwise\
  "{"$axis_string"}"\
  "{$4}"\
  "{$5}"\
  "{$6}"\
  "{$7}"\
  "{$8}"\
  "{$9}_"{$use_full+1}

_persistent=$is_all_dimensions_same,$otherwise
__fx_rep_shear_preview_start:
if narg($_persistent)
	is_all_dimensions_same,otherwise=$_persistent
else
	if $!>1
		$!,1,1,4,[w#0,h#0,d#0,s#0]
		rep_uniq_cols. 0
		is_all_dimensions_same={(w#-1==1)<<1}
		rm.
	else
		is_all_dimensions_same=0
	fi
	otherwise={2-$is_all_dimensions_same}
fi
#@gui Random Gradient Bars: fx_rep_randgradbar,fx_rep_randgradbar_preview
#@gui:_=note("Create Random Gradient Bar.\n\n<b>Note -</b> Preview is only for giving a idea.")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Seed=int(0,0,100000)
#@gui:Bar Size - Quarter Image-Diagonal(%)=float(2,0,100)
#@gui:Space Size - Quarter Image-Diagonal(%)=float(0,0,100)
#@gui:Angle=float(0,-180,180)
#@gui:Skew Angle=float(0,-89,89)
#@gui:Origin=point(50,50,0,1,255,255,255,255)
#@gui:Subsampling=float(1,0,3)
#@gui:_=separator(),_=note("<b>Gradient Transformation</b>")
#@gui:Shift=float(0,0,100)
#@gui:Multiplier A=float(1,.1,250)
#@gui:Multiplier B=float(100,.1,250)
#@gui:_=separator(),_=note("<b>Gradient Modulo</b>")
#@gui:Repetition=choice(0,"Random","Cut","Periodic","Continuous")
#@gui:Random Bar Repetition=choice(0,"All","Cut and Periodic","Cut and Continuous","Periodic and Continuous")
#@gui:Space Mode=choice(0,"Alpha","Cut","Gradient")
#@gui:Symmetry Mode=choice(0,"None","Symmetry A","Symmetry B")
#@gui:Inversion Mode=choice(0,"None","Random-Inversion","Full-Inversion")
#@gui:_=separator(),_=note("<b>Color</b>")
#@gui:Output Color=choice(0,"Grayscale","Duotone","RGB - Random Bars","HSV - Random Bars")
#@gui:Space Color A=color(255,0,127)
#@gui:Space Color B=color(249,215,45)
#@gui:_=separator(),_=note("<b>Animation</b>")
#@gui:Shift=float(0,-5,5)_0
#@gui:Multiplier A=float(1,.1,250)_0
#@gui:Multiplier B=float(100,.1,250)_0
#@gui:_=note("Under Development!")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2021/5/24</i>.</small>")
fx_rep_randgradbar:
srand $1

foreach {

 if $12==0&&$13==0 rep_random_gradient_bars $2%,$3%,$4,$5,{$6/100-.5},{(100-$7)/100-.5},${8-11},-1,,$17,$14,${15-16},$18,$19,$20,$21,$22,$23
 else rep_random_gradient_bars $2%,$3%,$4,$5,{$6/100-.5},{(100-$7)/100-.5},${8-11},{$12-1},{$13-1},$17,$14,${15-16},$18,$19,$20,$21,$22,$23
 fi

 if $17==0 sh. 0 n. 0,255 rm. fi

}
fx_rep_randgradbar_preview:
fx_rep_randgradbar ${1-23}
use_color={$17==0?1:($17==1?2:(($3>0&&$14)?2:1))}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}_"{!$12?2:1}\
"{$14}_"{$3?2:1}\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18,$19,$20}_"$use_color\
"{$21,$22,$23}_"$use_color\
"{$24}"\
"{$25}"\
"{$26}"
#@gui Dungeon Floor (Super Slow!): fx_rep_dungeon_floor,fx_rep_dungeon_floor_preview
#@gui: Tile Size=choice(0,"1x1","2x2")
#@gui: Tile Choice (If 1x1)=choice(0,"1","2","3","4")
#@gui: Subsampling=float(2,0,5)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2021/6/02</i>.</small>")
fx_rep_dungeon_floor:
ww={w}
hh={h}
sub={abs($3)+1}

f. 0 channels. 0

r. {$sub*w},{$sub*h},100%,100%,-1

{w},{h},1,1,"begin(
  const cx=(w-1)/2;
  const cy=(h-1)/2;
  const scaleP=$1?1:.5;
  const wx=.043333;
  const wy=.053333;
  const a=.7;
  const TWO_PI=pi*2;
  const off_x=cx*($1==0?((1-$2%2)?1));
  const off_y=cy*($1==0?($2>1?1));
 );
 xx=scaleP*x/w;
 yy=scaleP*y/h;
 for(n=0,n<10,++n,
  newx=xx+wx-a/(TWO_PI*sin(TWO_PI*yy));
  newy=yy+wy-a/(TWO_PI*sin(TWO_PI*xx));
  xx=(newx+off_x)%w;
  yy=(newy+off_y)%h;
  i(#0,xx,yy)++;
 );"

rm..
if $3!=0 r. $ww,$hh,100%,100%,2 fi
n. 0,255
fx_rep_dungeon_floor_preview:
fx_rep_dungeon_floor $*
u "{$1}"\
"{$2}_"{!$1?2:1}\
"{$3}"
#@gui Array [Random] [Jumble by px]:fx_rep_array_random_jumble_by_px,fx_rep_array_random_jumble_by_px_preview(1)*
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Tile Width(px)=int(128,1,2048)
#@gui:Tile Height=int(128,1,2048)
#@gui:Old Tile Width(px)=int(128,1,2048)_0
#@gui:Old Tile Height=int(128,1,2048)_0
#@gui:Link Dimensions=bool(0)
#@gui:Enforce Factors=bool(0)
#@gui:Reshuffle Tiles=button()
#@gui:_=separator(),_=note("<b>Image Factors</b>")
#@gui:List of Width Factors=text("List of Factors")
#@gui:List of Height Factors=text("List of Factors")
#@gui:List of Width and Height Factors=text("List of Factors")
#@gui:Stored List of Width(s) Factors=text("List of Factors")_0
#@gui:Stored List of Height(s) Factors=text("List of Factors")_0
#@gui:Stored List of Width(s) and Height(s) Factors=text("List of Factors")_0
#@gui:Stored Number of Width(s) Factors=int(1,1,16777216)_0
#@gui:Stored Number of Height(s) Factors=int(1,1,16777216)_0
#@gui:Stored Number of Width(s) and Height(s) Factors=int(1,1,16777216)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2023/07/06</i>.</small>")
fx_rep_array_random_jumble_by_px:

  if narg($_persistent)
    remove
    $_persistent
  else
    fx_rep_array_random_jumble_by_px_preview $*
  fi

fx_rep_array_random_jumble_by_px_preview:

  contain_persistent,link_dimensions={narg($_persistent)},$5

  if $contain_persistent
    list_of_widths_factors=$11
    list_of_heights_factors=$12
    list_of_widths_and_heights_factors=$13

    number_of_widths_factors,\
    number_of_heights_factors,\
    number_of_widths_and_heights_factors=${14-16}
  else
    list_of_widths={expr('w#x',$!)}
    list_of_heights={expr('h#x',$!)}
    list_of_widths_and_heights=$list_of_widths,$list_of_heights

    list_of_widths_factors=${rep_find_factors_of\ $list_of_widths}
    list_of_heights_factors=${rep_find_factors_of\ $list_of_heights}
    list_of_widths_and_heights_factors=${rep_find_factors_of\ $list_of_widths_and_heights}

    number_of_widths_factors:=narg($list_of_widths_factors)
    number_of_heights_factors:=narg($list_of_heights_factors)
    number_of_widths_and_heights_factors:=narg($list_of_widths_and_heights_factors)
  fi

  enforce_factors={$contain_persistent?$6}

  if $enforce_factors
    tile_w,tile_h=${1-2}

    if $link_dimensions

      if $number_of_widths_and_heights_factors==1 error no_common_factors fi

      if $tile_w!=$tile_h
        tile_dim:=u(0,1,0,0)<.5?$tile_h:$tile_w
      elif $tile_w!=$3
        tile_dim=$tile_w
      elif $tile_h!=$4
        tile_dim=$tile_h
      else
        tile_dim=$tile_w
      fi

      tile_dim=${rep_bisect_num_list\ $tile_dim,$list_of_widths_and_heights_factors}
      tile_w,tile_h=$tile_dim
    else
      tile_w=${rep_bisect_num_list\ $tile_w,$list_of_widths_factors}
      tile_h=${rep_bisect_num_list\ $tile_h,$list_of_heights_factors}
    fi
  else
    if $link_dimensions
      if $1!=$3
        tile_w,tile_h=$1
      elif $2!=$4
        tile_w,tile_h=$2
      else
        tile_w,tile_h={$1==$2?$1:(u(0,1,1,0)<.5?$1:$2)}
      fi
    else
      tile_w,tile_h=${1-2}
    fi
  fi

  shuffle_images={$7||($tile_w!=$3)||($tile_h!=$4)||!$contain_persistent}
  tile_dims=$tile_w,$tile_h

  if $shuffle_images
    foreach {
      mini_image_width,mini_image_height={ceil([w,h]/[$tile_dims])}

      if $mini_image_width==1&&$mini_image_height==1 continue fi

      new_image_width,new_image_height={[$mini_image_width,$mini_image_height]*[$tile_dims]}

      refit_image={$new_image_width!=w||$new_image_height!=h}

      if $refit_image
        ow,oh={[w,h]}
        resize $new_image_width,$new_image_height,100%,100%,0,2,.5,.5
      fi

      $new_image_width,$new_image_height,100%,100%

      $mini_image_width,$mini_image_height,1,2,"begin(
        const mini_w=$tile_w;
        const mini_h=$tile_h;
       );
       cx=x*mini_w;
       cy=y*mini_h;
       [cx,cy];"

      shuffle[-1]

      eval[-1] :"begin(
        const mini_w=$tile_w;
        const mini_h=$tile_h;
        const depth=d#0;
        const spectrum=s#0;
       );
       tile=crop(#0,i0,i1,0,0,mini_w,mini_h,depth,spectrum);
       draw(#1,tile,x*mini_w,y*mini_h,0,0,mini_w,mini_h,depth,spectrum);
       I;"

      keep[1]

      if $refit_image
        start_x,start_y:=int(([$new_image_width,$new_image_height]-[$ow,$oh])>>1)
        end_x,end_y:=[$start_x,$start_y]+([$ow,$oh]-1)
        crop $start_x,$start_y,$end_x,$end_y
      fi
    }

    store _persistent
 else
    remove
 fi

 $_persistent

 if '$_host'!='$cli'
   crop $_preview_x0,$_preview_y0,$_preview_x1,$_preview_y1
 fi

 factors_display_mode={1+!$link_dimensions}

 u "{"$tile_w"}"\
   "{"$tile_h"}"\
   "{"$tile_w"}"\
   "{"$tile_h"}"\
   "{$5}"\
   "{"$enforce_factors"}"\
   "{0}"\
   "{"$list_of_widths_factors"}_"$factors_display_mode\
   "{"$list_of_heights_factors"}_"$factors_display_mode\
   "{"$list_of_widths_and_heights_factors"}"\
   "{"$list_of_widths_factors"}"\
   "{"$list_of_heights_factors"}"\
   "{"$list_of_widths_and_heights_factors"}"\
   "{"$number_of_widths_factors"}"\
   "{"$number_of_heights_factors"}"\
   "{"$number_of_widths_and_heights_factors"}"
#@gui Weighted RGB To Grayscale: fx_rep_w_rgb82gray,fx_rep_w_rgb82gray_preview(0)
#@gui:_=note("Weigh the R-G-B Channel, and then output based on their weight")
#@gui:_=separator(),_=note("<b>Main RGB to Grayscale</b>")
#@gui:Red Weight(%)=float(33.33,0,100)
#@gui:Green Weight(%)=float(33.33,0,100)
#@gui:Blue Weight(%)=float(33.33,0,100)
#@gui:Use Weighted Ratio?=bool(1)
#@gui:_=separator(),_=note("<b>Min-Max Value</b>")
#@gui:Min Value Weight(%)=float(0,0,100)
#@gui:Max Value Weight(%)=float(0,0,100)
#@gui:Min-Max Interpolation=float(0,0,1)
#@gui:_=separator(),_=note("<b>Post-Process Adjustment</b>")
#@gui:Value Shift=float(0,-128,128)
#@gui:Midgray Shift=float(0,-1,1)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/6/25</i>.</small>")
fx_rep_w_rgb82gray:
rep_weighted_rgb82gray $1%,$2%,$3%,$4,$5%,$6%,$7,$8,$9
fx_rep_w_rgb82gray_preview:
gui_split_preview "fx_rep_w_rgb82gray ${1-9}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}_"{$5&&$6?2:1}\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11,$12}"
#@gui Markus-Lyapunov Fractal: fx_rep_mlfrac,fx_rep_mlfrac
#@gui:_=note("Create a mapping of Lyapunov exponent within two values or three values.")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:ABC-String=text("ab")
#@gui:ABC-String Repeats=int(50,1,255)
#@gui:Subsampling Level=float(1,0,6)
#@gui:Viewport(%)=float(100,0,100)
#@gui:Position=point(50,50,0,1,255,255,255,255)
#@gui:C-Time(%)=float(50,0,100)
#@gui:_=separator(),_=note("<b>Output</b>")
#@gui:Mode=choice(0,"Grayscale","Duotone","Random","Palette","Layers")
#@gui:Use Inverted?=bool(0)
#@gui:Color A=color(0,0,255,255)
#@gui:Color B=color(255,255,0,255)
#@gui:Set of Palettes=choice(0,"Single","Double")
#@gui:Seed=int(0,0,10000000)
#@gui:Random Palette Color Count=int(8,2,64)
#@gui:Random Palette A Color Count=int(8,2,64)
#@gui:Random Palette B Color Count=int(8,2,64)
#@gui:Color Space=choice(0,"HSL","LAB","LCH")
#@gui:Palette=choice(12,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Palette Order=choice(0,"Default","Randomized","Mirrored")
#@gui:Palette A=choice(16,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Palette A Order=choice(0,"Default","Randomized","Mirrored")
#@gui:Palette B=choice(50,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Palette B Order=choice(0,"Default","Randomized","Mirrored")
#@gui:Color Count=int(8,2,64)
#@gui:Palette Order=choice(0,"Default","Randomized","Mirrored")
#@gui:Color Count A=int(8,2,64)
#@gui:Palette A Order=choice(0,"Default","Randomized","Mirrored")
#@gui:Color Count B=int(8,2,64)
#@gui:Palette B Order=choice(0,"Default","Randomized","Mirrored")
#@gui:Reverse Layers=bool(0)
#@gui:Reverse Non-Target Layers=bool(0)
#@gui:Mode=choice(0,"Import One File Only","Import Two Files")_0
#@gui:File=file()_0
#@gui:File A=file()_0
#@gui:File B=file()_0
#@gui:Color Count=int(8,2,64)_0
#@gui:Randomize Color Position=bool(0)_0
#@gui:Color Count A=int(8,2,64)_0
#@gui:Randomize Colors A Position=bool(0)_0
#@gui:Color Count B=int(8,2,64)_0
#@gui:Randomize Colors B Position=bool(0)_0
#@gui:_=separator(),_=note("<b>Orientation</b>")
#@gui:X-Direction=choice(0,"Default","Mirrored")_0
#@gui:Y-Direction=choice(0,"Default","Mirrored")_0
#@gui:_=note("<small>Under Development!</small>")
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_mlfrac:
skip "${39=}","${40=}","${41=}"
srand $19
set_main_arg=${1-3},$4%,$5%,{100-$6}%,$7%
timg={$!}

if $8==0
 rep_markus_lyapunov_fractal[0] $set_main_arg,$9 n 0,255 if $timg>1 f[^0] I#0 fi
elif $8==1
 hex_col_a=${rep_int82hex\ ${10-13}}
 hex_col_b=${rep_int82hex\ ${14-17}}
 rep_markus_lyapunov_fractal[0] $set_main_arg,$hex_col_a,$hex_col_b
 if $timg>1 f[^0] I#0 fi
elif $8==2
 if $18 rep_markus_lyapunov_fractal[0] $set_main_arg,u,u,${21-23}
 else rep_markus_lyapunov_fractal[0] $set_main_arg,u,$20,$23
 fi
 if $timg>1 f[^0] I#0 fi
elif $8==3
 if $18
  +pal $26
  +pal $28
  rep_markus_lyapunov_fractal[0] $set_main_arg,[-2],[-1],$27,$29
  rm[-2,-1]
  if $timg>1 f[^0] I#0 fi
 else
  +pal $24
  rep_markus_lyapunov_fractal[0] $set_main_arg,[-1],$25
  rm.
  if $timg>1 f[^0] I#0 fi
 fi
else
 if $timg==2||$timg==3
  if $36 rv fi
  if $timg==2
   rep_markus_lyapunov_fractal[0] $set_main_arg,[1],$31,$30
  else
    if $37 rv[^0] fi
    rep_markus_lyapunov_fractal[0] $set_main_arg,[1],[2],$33,$35,$32,$34
  fi
 else
  error "Invalid number of layer(s) for this mode. 2 or 3 Layers Only!"
 fi
fi

use_time=${}
set_a_1={$8==1?2}
set_a_2={$8==2?2}
set_a_3={$8==2&&$18==1?2}
set_b_1={($8==2&&$18==0)?2}
set_b_2={($8==2&&$18==1)?2}
set_c_1={($8==3&&$18==0)?2}
set_c_2={($8==3&&$18==1)?2}
set_d_1={$8==4&&$timg==2?2}
set_d_2={$8==4&&$timg==3?2}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5,$6}"\
"{$7}_"$use_time\
"{$8}"\
"{$9}_"{!$8?2}\
"{$10,$11,$12,$13}_"$set_a_1\
"{$14,$15,$16,$17}_"$set_a_1\
"{$18}_"{$8>1&&$8<4?2}\
"{$19}_"{$8==2?2:$8==3?($18?(($27==1||$29==1)?2:1):($25==1?2:1)):$8==4?($timg==3?(($33==1||$35==1)?2:1):($31==1?2:1))}\
"{$20}_"{$8==2&&$18==0?2}\
"{$21}_"$set_a_3\
"{$22}_"$set_a_3\
"{$23}_"$set_a_2\
"{$24}_"$set_c_1\
"{$25}_"$set_c_1\
"{$26}_"$set_c_2\
"{$27}_"$set_c_2\
"{$28}_"$set_c_2\
"{$29}_"$set_c_2\
"{$30}_"$set_d_1\
"{$31}_"$set_d_1\
"{$32}_"$set_d_2\
"{$33}_"$set_d_2\
"{$34}_"$set_d_2\
"{$35}_"$set_d_2\
"{$36}_"{$8==4?2}\
"{$37}_"$set_d_2\
"{$38}"\
"{$39}"\
"{$40}"\
"{$41}"\
"{$42}"\
"{$43}"\
"{$44}"\
"{$45}"\
"{$46}"\
"{$47}"\
"{$48}"\
"{$49}"
#@gui Rainbowify: fx_rep_rainbowify,fx_rep_rainbowify_preview(0)
#@gui:_=note("Apply rainbowify effect into image. Inspired by <a href="https://blog.jfrech.com/180/">Rainbowify effect made by Jonathan Frech</a>."),_=separator()
#@gui:Hue Shift=float(0,-180,180)
#@gui:Gradient Angle=float(0,-180,180)
#@gui:Gradient Scale(%)=float(100,50,200)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/7/26</i>.</small>")
fx_rep_rainbowify: rep_rainbowify ${1-2},$3%
fx_rep_rainbowify_preview:
gui_split_preview "fx_rep_rainbowify ${1-3}",${-3--1}
#@gui Complexion Burst: fx_rep_compb,fx_rep_compb_preview
#@gui:_=note("Complex-Plane adaptation of the Pickover Popcorn Fractal. Discovered By Reptorian."),_=separator()
#@gui:_=note("<b>Main</b>")
#@gui:Points=int(50,1,200)
#@gui:Density=float(1,.01,2)
#@gui:H-Real=float(.05,-75,75)
#@gui:H-Imag=float(3,-75,75)
#@gui:K-Real=float(3,-75,75)
#@gui:K-Imag=float(3,-75,75)
#@gui:Zoom=float(2,.1,20)
#@gui:Angle=float(0,-180,180)
#@gui:Origin=point(50,50,0,1,255,255,255,255)
#@gui:_=separator(),_=note("<b>Number Extraction</b>")
#@gui:Method=choice(0,"Per-Axis","Additive")
#@gui:_=separator(),_=note("<b>Complex Trigonometric</b>")
#@gui:Mode=choice(0,"Z-4","Z-6")
#@gui:Complex-Plane Mode?=bool(1)
#@gui:Real-Axis Formula S=choice(0,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:Real-Axis Formula T=choice(1,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:Real-Axis Formula U=choice(2,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:Imaginary-Axis Formula S=choice(0,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:Imaginary-Axis Formula T=choice(1,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:Imaginary-Axis Formula U=choice(2,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:XY-Axis Formula S=choice(0,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:XY-Axis Formula T=choice(1,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:XY-Axis Formula U=choice(2,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui:_=separator(),_=note("<b>Output</b>")
#@gui:Value Limit(%)=float(.5,.5,100)
#@gui:Midpoint Shift=float(.5,-1,1)
#@gui:Multiplier=float(1,.1,10)
#@gui:Normalize=bool(1)
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Show Fill Ratio?=bool(0)
#@gui:_=note("<small>Fill Ratio provides information on whether there is sufficient filled pixels on canvas. The closer to 100%, the more the canvas is filled.</small>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/08/19</i>.</small>")
fx_rep_compb:
ox={(($9-50)/100)*2}
oy={(($10-50)/100)*-2}
setarg=${1-2},"[${3-4}]","[${5-6}]",${7-8},$ox,$oy
midpoint_shift={1-abs($24)}

if $13
 if $12 setarg2=${20-22}
 else setarg2=$20,$22
 fi
else
 if $12 setarg2=${14-19}
 else setarg2=$14,$16,$17,$19
 fi
fi

local[0] {

 rep_complexion_burst $setarg,$11,$12,$setarg2
 val_max={iM}

 if ($23%)<1 cut 0,{iM*$23%} fi

 n 0,1

 if $24>=0 f i^$midpoint_shift
 else f 1-((1-i)^$midpoint_shift)
 fi

 if $26 n 0,255
 else * {$25*$val_max}
 fi

}
fx_rep_compb_preview:
fx_rep_compb ${1-26}

if $27
 +f[0] i>0?1
 fillperc={ia*100} rm.
 fillperc_l={int($fillperc)}
 fillperc_r={int(($fillperc-$fillperc_l)*100)}
 fillratio=$fillperc_l
 fillratio.=.
 fillratio.=$fillperc_r
 fillratio.=%
 to[0] $fillratio,.5~,.5~,18%
fi

k[0]

a={!$13?2:0}
b={$13?2:0}
c={!$13?($12?2:0):0}
d={$13?($12?2:0):0}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9,$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}_"$a\
"{$15}_"$c\
"{$16}_"$a\
"{$17}_"$a\
"{$18}_"$c\
"{$19}_"$a\
"{$20}_"$b\
"{$21}_"$d\
"{$22}_"$b\
"{$23}"\
"{$24}"\
"{$25}_"{$26?1:2}\
"{$26}"\
"{$27}"
#@gui Ellsworth Kelly Board: fx_rep_ekb,fx_rep_ekb_preview
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Square Size - Half Minimum-Dimension(%)=float(10,1,100)
#@gui:Border Size - Square Size(%)=float(10,-100,100)
#@gui:Border Size - Pixel=int(1,-50,50)
#@gui:Use Pixel Unit to define Border=bool(1)
#@gui:Frequency(%)=float(50,5,100)
#@gui:Output=choice(0,"Inside","Resized")
#@gui:_=separator(),_=note("<b>Color Options</b>")
#@gui:Unfilled Area Color=color(110,105,130)
#@gui:Keep Unfilled Area Empty?=bool(0)
#@gui:Exterior Border Color=color(255,255,255)
#@gui:Keep Exterior Border Color Empty?=bool(0)
#@gui:Border Value(%)=float(25,0,100)
#@gui:Palette=choice(0,"Predefined","Random")
#@gui:Number of Colors=int(12,5,100)
#@gui:Color Space=choice(0,"RGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YCbCr","YCbCrGLIC","YIQ","YUV","XYZ","YES")
#@gui:Predefined Palette=choice(10,"Black & White with Red-Green-Blue-{5}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 5","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:_=separator(),_=note("<b>Random</b>")
#@gui:Main=int(0,0,1000000)
#@gui:Color=int(0,0,1000000)
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/09/16</i>.</small>")
fx_rep_ekb:
to_rgba

if $18 convert_colors_fwd=${rep_cs_arg1\ 1,$18,,ryb,cmy,cmyk,hcy,hsi,hsl,hsv,lab,lch,ycbcr,ycbcrglic,yiq,yuv,xyz,yes} fi

#Random Below#
#Main=arg20#
#Color=arg21#

square_size={round(min(w,h)/2*$1%)}
if $4
	border_size=$3
else
	border_size=$2%
fi

main_arg=$square_size,$border_size,$15%,$5%

if !$10 ufc=${rep_int82hex\ ${7-9}} fi

second_set_arg=$6,$18

if !$14
 if $18&&$15
  1,1,1,3,[${11-13}]
  $convert_colors_fwd.
  second_set_arg.=,{crop(#-1)}
  rm.
 else
  second_set_arg.=,${11-13}
 fi
fi

if $16
 mimg={$!-1}

 if $18<4||$18==11 vcol=[u(255),u(255),u(255)]
 elif $18<8 vcol=[u(359.999),u(1),u(1)]
 elif $18==8 vcol=[u(0,100),u(-128,182),u(-155,155)]
 elif $18==9 vcol=[u(0,100),u(240),u(-pi,pi)]
 elif $18==10 vcol=[u(16.5,236),u(16.9375,240.0625),u(16.9375,240.0625)]
 elif $18==12 vcol=[u(255),u(-151.90757751464844,151.90757751464844),u(-133.26069641113281,133.26069641113281)]
 elif $18==13 vcol=[u(1),u(-.436,.436),u(-.615,.615)]
 elif $18==14 vcol=[u(1),u(1),u(1)]
 elif $18==15 vcol=[u(255),u(-127.5,127.5),u(-127.5,127.5)]
 fi

 $17,1,1,{$18==3?4:3},begin(srand($21));$vcol

 srand $20

 rep_ellsworth_kelly_board[0-$mimg] $main_arg,[-1],$ufc,$second_set_arg

 rm.
else
 ppc=${arg0\ $19,bw_rgb,wcmyk,rgbcmy,1bitrgb,aurora,zenit,gbg,duel,hocuspocus,playpal,srb2,uzebox,kens16,kens32,kens54,aap12,aap16,aap64,aap96,aap128,aap_dga16,cheerful,db8,db16,db32,db_iso22,dimwid17,dimwid23,edg8,edg16,edg32,edg36,edg64,famicube,juicy32,juicy56,xaiue,15pdx,20pdx,24pdx,cabana,fantasy16,fantasy24,tranquil_fantasy_23,tfp39,faraway,fleja,koni,linearbasic,legowiki,lego2021,vinelinear,arcade,arq,atom,blk36,blkneo,brokefac,bubblegum,cpcboy,cade,calder,cdbac,cgarne,dinoknight,4l,fzt,indecision,island,journey,shallowmarsh,lago_nenufar,juicy,chocolateganache,brightwinter1,brightwinter2,kawaii,xdb,gzxp,chromatic,piet_code,boltbait_matrix,material_design,thehamster_rainbow,boltbait_rainbow,scrj,pxls,lospec,moderna,oak,nature,rbypgo,new_worlds,nauris,dynamite,interstate,downgraded,pear,pineapple,peachy,resurrect,rosy42,slso,softy,spec,roarin80s,starmancer,superfuture,sunshine,sweetie,calm,optimism,taffy,todayland,trirampo,reddit_place_2022,tropical,vivid,shido,intacto,itatsi,enos,grixel,superb,undertones,tango,cheese,equpix15,zughy,voodo,franzston,night,star29,star34,still_life,simjpc,acid,battery,clump,cthul,crimso11,coptec,drz,eggy,europa,greyt_bit,jewel,polar,sheltzy,wyrm,yume_nikki,rube_goldberg,boomboom,g8,crayola,funky,golden_wall,matriax,nt1h,jerrypie,nineties_nine,on70,anb,retrocal,punolit,luap,autum_villan,au15,au15y,galaxy_flame,cretaceous,antiquity,mushroom,aerugo,hotel_paintings,nopal,blessing,fairydust,milkshake,fairy,naji,easter,pastel_and_darks,pastel_irena,nostalgia,ocaso,pastel_starlitsunset,pollen,kule,hydrangea,fluffy,st8rb,neon,cyclope,sy,syz,tui,cave,psygnosia,marshmellow,lost_century,finlal,industrial,murder_mystery,fate_and_destiny,vinik,ykb,halloween,graveyard,steamlords,frostical,deuterospill,cool_bone,muted_ally,ephemera,ink,violet_dreams,tinyfolks,old_gold,rosemoss,aaprad,aapmaj,dead_weight,mojave,pet8,pet8d,xaiue_rad,daruda,firestorm,borkfest,spicy,rust,apricot,supernova,pastry,sandy,illumination,nyx,dreamhaze,oil,regal,softdemon,sgm,midnight_ablaze,black_cherry,sunset_red,inkpink,brash_pink,pink_neon_sign,enchanted_purple,arch,spaceyeaster,fornaxvoid1,fornaxvoid2,pixelwave,s1,berry_nebula,abyss,moonlight,moon39,h2o,magic_waters,moss,deep_maze,toxic_slime,lush_green,tsunami,cryptic_ocean,marsh_madness,oxyd,pinkgreen,woodwalk,paper,sahara_pastell,sunflower,arthoe,sky,ocean_glass,royal,eulbink,winter_wonderland,moon_squid,stratus,arctic_dust,clouds_sunset,lilac_skies,sea_of_fire,autochrome5,tritanopia,rabbit,amiga2600ntsc,amiga2600pal,amiga2600secam,amiga7800mess,amiga7800,amstrad_cpc,apple,atari,cga,c64_pepto,c64_colodore,com_vic_20,colecovision,jmp,mac2,mac8,msx,nes,pico,risc,samcoupe,mo5,vga,win95,zx,gnome,elc,chip16,deluxepaint,flat,makecode,oekaki,lms,msxp,vista,piet,japwood,humanfaces,hues,christmas,ladybugreds}
 srand $20
 rep_ellsworth_kelly_board $main_arg,$ppc,$ufc,$second_set_arg
fi
fx_rep_ekb_preview:
fx_rep_ekb $*
a={$16?2:0}
u "{$1}"\
"{$2}"_{!$4?2:0}\
"{$3}"_{$4?2:0}\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8,$9}"_{!$10?2:1}\
"{$10}"\
"{$11,$12,$13}"_{$6?0:!$14?2:1}\
"{$14}"_{$6?0:2}\
"{$15}"_{(($4?$3:$2)!=0)?2:1}\
"{$16}"\
"{$17}"_$a\
"{$18}"_$a\
"{$19}"_{!$16?2:0}\
"{$20}"\
"{$21}"_{$16?2:0}
#@gui Random Rectangle Division: fx_rep_rrd,fx_rep_rrd
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Division=int(10,1,20)
#@gui:Additional Thickness=int(5,0,100)
#@gui:Maximum Division Iteration=int(5,2,40)
#@gui:Probability of Division(%)=float(95,20,100)
#@gui:Loop Limit=int(50000,1000,2097152)
#@gui:Seed=int(0,0,300)
#@gui:Border(%)=float(35,0,100)
#@gui:_=separator(),_=note("<b>Color</b>")
#@gui:Mode=choice(0,"Grayscale","Palette","Random")
#@gui:Normalize?=bool(1)
#@gui:Palette=choice(12,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Color Space=choice(0,"RGB","HSV")
#@gui:Number of Color=int(0,0,100)
#@gui:Seed=int(0,0,100000)
#@gui:Border=color(0,0,0)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_rrd:
border_size={max(0,round($2*$7/100))}
rgb_col=${rep_int82hex\ ${14-16}}

if $8==2
 if $12 rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col,${11-13}
 else rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col,$11,,$13
 fi
elif $8==1
 rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col,pal,$10,$13
else
 rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col
fi

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"_{!$8?2}\
"{$10}"_{$8==1?2}\
"{$11}"_{$8==2?2}\
"{$12}"_{$8==2?2}\
"{$13}"_{$8?2}\
"{$14,$15,$16}"_{$border_size?2:1}
#@gui Three-Coupled Oscillators: fx_rep_tco,fx_rep_tco
#@gui:_=note("<b>Main</b>"),_=separator()
#@gui:Maximum Iteration=int(50,1,200)
#@gui:K-A Tau(%)=float(50,-100,100)
#@gui:K-B Tau(%)=float(-50,-100,100)
#@gui:Subpixel Level=float(1,0,2)
#@gui:Angle=float(0,-180,180)
#@gui:Position=point(50,50,0,1,128,128,128,255)
#@gui:Axis-Scale=float(1,1,15)
#@gui:_=note("<b>Coloring</b>"),_=separator()
#@gui:Mode=choice(0,"Grayscale","Palette","Random")
#@gui:Palette=choice(12,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Number of Colors=int(6,2,100)
#@gui:Color Space=choice(0,"RGB","HSI","HCY","LAB")
#@gui:Seed=int(0,0,3000)
#@gui:Boundary=choice(1,"Periodic","Periodic-Smooth","Continuous")
#@gui:Negate=bool(0)
#@gui:Shift Value=float(0,-1,1)
#@gui:Multiplier=float(1,.25,10)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_tco:
tau={2*pi}
ow={w}
oh={h}
mode={$14+1}
ti=$!

local[0] {
 rep_three_coupled_oscillators $1,{$tau*$2%},{$tau*$3%},-$4,$5,{($6-50)/50},{($7-50)/-50},$8

 if $9==0

  if $-1!=1

   if $-1>1
    n 0,{255*$-1}
    if $-2!=0 + {$-2*255} fi
    modf {$-4?3:2},255,100%
   else
    n 0,{255*$-1}
   fi

  else
   n 0,255
  fi

  if $-2!=0&&(!($-1>1))
   + {$-2*255}
   modf {$-4?3:2},255,100%
  fi

  if $-3 negate fi

 elif $9==1

  +pal $10
  n.. 0,{$-1*(w#-1-1)}

  if $-3 negate.. fi
  if $-2!=0 +.. {(w#-1-1)*$-2} fi

  rep_cubic_map.. [-1],$mode
  rm.

 fi

 if $9!=2 r $ow,$oh,100%,100%,6 fi
}

if $9==2

 if $12 convert_colors_bwd=${arg1\ $12,hsi2rgb,hcy2rgb,lab2rgb} fi

 ti={$!}

 if $ti>1
  rm[^0]
  [-1]x{$ti-1}
 fi

 foreach {

  if $12==3 $11,1,1,3,begin(srand($13+$>););[u(0,100),u(-128.014,182.136),u(-155.5,155.5)];
  elif $12 $11,1,1,3,begin(srand($13+$>););[u(0,359.999999),u(0,1),u(0,1)];
  else $11,1,1,3,begin(srand($13););u(255);
  fi

  n.. 0,{$-1*(w#-1-1)}

  if $-3 negate.. fi

  if $-2!=0 +.. {(w#-1-1)*$-2} fi

  rep_cubic_map.. [-1],$mode

  rm.

  if $12 $convert_colors_bwd. fi

  r $ow,$oh,100%,100%,6
 }

else

 k.
 if $ti>1
  [-1]x{$ti-1} done
 fi

fi

rand_col_set={$9==2?2}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6,$7}"\
"{$8}"\
"{$9}"\
"{$10}"_{$9==1?2}\
"{$11}"_$rand_col_set\
"{$12}"_$rand_col_set\
"{$13}"_$rand_col_set\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}"
#@gui Color Harmonies:_none_,fx_rep_color_harmonies_tool(1)*
#@gui:_=note("This is a recreation of the <a href="https://forums.getpaint.net/topic/29332-color-harmonies-tools-effect/">Color Harmonies plugin for Paint.NET.</a> which was made by <a href="https://forums.getpaint.net/profile/79572-midora/">midora</a> who is also known as Martin Osieka.")
#@gui:_=separator(),_=note("<b>Reference Point</b>")
#@gui:Hue=float(50,0,360)
#@gui:Saturation(%)=float(100,0,100)
#@gui:Shade/Tint(%)=float(0,-100,100)
#@gui:Color Space=choice(0,"RGB",RYB")
#@gui:Palette Mode=choice(0,"Neutral 8","Neutral 15","Analogous 30","Complementary","Split-Complementary","Triadic","Tetradic","Clash","Four Tones","Five Tones","Six Tones")
#@gui:_=separator(),_=note("<b>Output Color</b>")
#@gui:Color A=color(0,0,0)
#@gui:Color B=color(0,0,0)
#@gui:Color C=color(0,0,0)
#@gui:Color D=color(0,0,0)
#@gui:Color E=color(0,0,0)
#@gui:Color F=color(0,0,0)
#@gui:_=separator(),_=note("<b>Preview</b>")
#@gui:Color A Point Position=point(50,50,1,1,255,255,255,255)_0
#@gui:Color B Point Position=point(50,50,1,1,255,255,255,255)_0
#@gui:Color C Point Position=point(50,50,1,1,255,255,255,255)_0
#@gui:Color D Point Position=point(50,50,1,1,255,255,255,255)_0
#@gui:Color E Point Position=point(50,50,1,1,255,255,255,255)_0
#@gui:Color F Point Position=point(50,50,1,1,255,255,255,255)_0
#@gui:Scaling(%)=float(90,30,100)
#@gui:Color Select Position(%)=float(10,10,50)
#@gui:_=separator(),_=note("<b>Palette Export</b>")
#@gui:Output Location=_folder()
#@gui:File Name=_text("color_harmonies")
#@gui:Format=_choice(0,"GIMP Palette - .gpl","Paint.NET Palette - .txt","JASC-PAL - .pal")
#@gui:Export=button()
#@gui:_=separator(),_=note("<b>Miscellaneous</b>")
#@gui:Console Message=text("This is a interactive tool meant to create palette.")
#@gui:Old Hue=value(50)
#@gui:Old Saturation(%)=value(100)
#@gui:Old Shade/Tint(%)=value(0)
#@gui:Old Color Space=value(0)
#@gui:Old Palette Mode=value(0)
#@gui:List of Old Colors=value{"vector(#18,0)"}
#@gui:List of Old Points=value{"vector(#12,50)"}
#@gui:Old Scaling(%)=value(90)
#@gui:Old Color Select Position(%)=value(10)
#@gui:Old Number of Points=value(6)
#@gui:Old Preview Width=value(1)
#@gui:Old Preview Width=value(1)
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian.</i> Latest update: <i>2024/4/11</i>.</small>")
fx_rep_color_harmonies_tool:
skip "$*"
rm

contain_persistent:=narg($_persistent)

hue,saturation,shade_tint,ryb_mode,palette_mode=${1-5}
hsl_changed={[${1-4}]!=[${43-46}]}
cs_sat_changed={[$2,$4]!=[$44,$46]}
switched_palette_mode:=$palette_mode!=$47
number_of_points={$switched_palette_mode?([6,6,6,2,3,3,4,3,4,5,6])[$palette_mode]:$52}
folder_name,file_name,format_choice,export="$38","$39",${40-41}

color_wheel_scaling,color_wheel_black_point=$36,$37

generate_points=0
if $contain_persistent
 $_persistent

 change_only_color_wheel:=[${36-37}]!=[${50-51}]
 preview_dimensions_changed:=[$_preview_area_width,$_preview_area_height]!=[${53-54}]

 if $switched_palette_mode||$cs_sat_changed||$change_only_color_wheel||$preview_dimensions_changed
  generate_palette,generate_points=1
  remove_named rgb,ryb
  +__fx_rep_color_harmonies_tool_create_color_wheel
  name[-2,-1] rgb,ryb
  move[rgb,ryb] 0
  console_mode={!$change_only_color_wheel}
 elif $hsl_changed
  generate_palette,generate_points,console_mode=1
 else
  console_mode=0
 fi
else
 +__fx_rep_color_harmonies_tool_create_color_wheel
 name[-2,-1] rgb,ryb
 generate_points,generate_palette=1
 console_mode=-1
fi

list_of_points_strs=\
 point_x_a,point_y_a,\
 point_x_b,point_y_b,\
 point_x_c,point_y_c,\
 point_x_d,point_y_d,\
 point_x_e,point_y_e,\
 point_x_f,point_y_f
list_of_points=${24-35}
$list_of_points_strs=$list_of_points

color_0=${6-8}
color_1=${9-11}
color_2=${12-14}
color_3=${15-17}
color_4=${18-20}
color_5=${21-23}
list_of_colors=$color_0,$color_1,$color_2,$color_3,$color_4,$color_5

if !$switched_palette_mode

 if ([${24-35}])[0,$number_of_points<<1]!=($49)[0,$number_of_points<<1]
  list_of_old_points=$49
  __fx_rep_color_harmonies_tool_generate_points_from_changed_points
  console_mode,generate_points,generate_palette=1
 fi

 if ([${6-23}])[0,$number_of_points*3]!=($48)[0,$number_of_points*3]
  colors_collection_a=${6-23}
  colors_collection_b=${48-48}
  __fx_rep_color_harmonies_tool_change_colors

  if $saturation_changed
   rm[rgb,ryb]
   +__fx_rep_color_harmonies_tool_create_color_wheel
   name[-2,-1] rgb,ryb
   move[rgb,ryb] 0
  fi

  console_mode=1
  console_mode,generate_points,generate_palette=1
 fi

else generate_points,generate_palette=1
fi

if $generate_palette
 remove_named[-1] palette
 +__fx_rep_color_harmonies_tool_create_palette => palette
fi

if $generate_points
 __fx_rep_color_harmonies_tool_generate_points
fi

display_boxes_a,display_boxes_b,display_boxes_c,display_boxes_d={([3,4,5,6]<=$number_of_points)<<1}

+store _persistent
__fx_rep_color_harmonies_tool_finalize
keep[$ryb_mode]

u "{"$hue"}"\
"{"$saturation"}"\
"{"$shade_tint"}"\
"{$4}"\
"{$5}"\
"{"$color_0"}"\
"{"$color_1"}"\
"{"$color_2"}_"$display_boxes_a\
"{"$color_3"}_"$display_boxes_b\
"{"$color_4"}_"$display_boxes_c\
"{"$color_5"}_"$display_boxes_d\
"{"$point_x_a,$point_y_a"}"\
"{"$point_x_b,$point_y_b"}"\
"{"$point_x_c,$point_y_c"}"\
"{"$point_x_d,$point_y_d"}"\
"{"$point_x_e,$point_y_e"}"\
"{"$point_x_f,$point_y_f"}"\
"{$36}"\
"{$37}"\
"{$38}"\
"{$39}"\
"{$40}"\
"{0}"\
"{"$console_message"}"\
"{"$hue"}"\
"{"$saturation"}"\
"{"$shade_tint"}"\
"{$4}"\
"{$5}"\
"{"[$list_of_colors]"}"\
"{"[$list_of_points]"}"\
"{$36}"\
"{$37}"\
"{"$number_of_points"}"\
"{"$_preview_area_width"}"\
"{"$_preview_area_height"}"
__fx_rep_color_harmonies_tool_finalize:
if $export
 format_output=${arg0\ $format_choice,gpl,pdn_pal,jasc} => "Generated by G'MIC Color Harmonies"
 rep_output_$format_output. $folder_name/$file_name
 console_mode=2
fi

if $console_mode==2
 console_message="File has been exported!"
elif $console_mode==1
 console_message="Changed Input!"
elif $console_mode==0
 console_message="Standby Mode"
else
 console_message="Initialized"
fi

__fx_rep_color_harmonies_tool_change_colors:

old_saturation=$saturation

hue,saturation,shade_tint={"

  const old_hue=$hue;
  const old_saturation=$saturation;
  const old_shade_tint=$shade_tint;

  const ryb_mode=$ryb_mode;
  const number_of_points=$number_of_points;

  rgb2hsl(rgb)=(
    m=min(rgb);
    M=max(rgb);
    C=M-m;
    H=60*(!C?0:M==rgb[0]?((rgb[1]-rgb[2])/C)%6:M==rgb[1]?(rgb[2]-rgb[0])/C+2:(rgb[0]-rgb[1])/C + 4);
    L=0.5*(m + M)/255;
    S=L==1||!L?0:C/(1-abs(2*L-1))/255;
    [H,S*100,L*200-100];
  );

  colors_collection_a=(["$colors_collection_a"])[0,number_of_points*3];
  colors_collection_b=(["$colors_collection_b"])[0,number_of_points*3];

  repeat(number_of_points,position_of_differences,
   new_color=(colors_collection_a)[position_of_differences*3,3];
   old_color=(colors_collection_b)[position_of_differences*3,3];
   if(new_color!=old_color,break(););
  );

  if(ryb_mode,

   rgb2ryb(rgb)=(
     white=min(rgb);
     rgb-=white;
     maxgreen=max(rgb);
     yellow=min(rgb[0],rgb[1]);
     rgb[0]-=yellow;
     rgb[1]-=yellow;
     if(rgb[2]>0&&rgb[1]>0,
      rgb[2]/=2;
      rgb[1]/=2;
     );
     yellow+=rgb[1];
     rgb[2]+=rgb[1];
     maxyellow = max(rgb[0],yellow,rgb[2]);
     if(maxyellow>0,
       N = maxgreen/maxyellow;
       rgb[0]*=N;
       yellow*=N;
       rgb[2]*=N;
     );
     rgb[0]+=white;
     yellow+=white;
     rgb[2]+=white;
     [rgb[0],yellow,rgb[2]];
   );

   new_color=rgb2ryb(new_color);
   old_color=rgb2ryb(old_color);
  );

  new_color=rgb2hsl(new_color);
  old_color=rgb2hsl(old_color);
  diff_color=new_color-old_color;

  new_hsl=[old_hue,old_saturation,old_shade_tint]+diff_color;

  new_hsl[0]=round(new_hsl[0]%360,0.01);
  new_hsl[1]=round(cut(new_hsl[1],0,100),0.1);
  new_hsl[2]=round(cut(new_hsl[2],-100,100),0.1);

  new_hsl;
 "}

saturation_changed={$old_saturation!=$saturation}

+__fx_rep_color_harmonies_tool_create_palette:
 +rep_color_harmony_palette $hue,$saturation%,$shade_tint%,$palette_mode,$ryb_mode
 repeat whd#-1 { color_$>:=I[#-1,$>] }
 list_of_colors=$color_0,$color_1,$color_2,$color_3,$color_4,$color_5

__fx_rep_color_harmonies_tool_generate_points_from_changed_points:

hue,shade_tint={_"
 const old_hue=$hue;
 const area_width=$_preview_area_width;
 const area_height=$_preview_area_height;

 const center_x=area_width/2;
 const center_y=area_height/2;

 const number_of_points=$number_of_points;
 const coordinates=number_of_points<<1;

 const end_radius=min(center_x,center_y)*($color_wheel_scaling%);
 const start_radius=end_radius*($color_wheel_black_point%);
 difference_radius=end_radius-start_radius;

 new_points=(["$list_of_points"])[0,coordinates];
 old_points=("$list_of_old_points")[0,coordinates];

 repeat(number_of_points,position_of_differences,
  xy_new=(new_points)[position_of_differences<<1,2];
  xy_old=(old_points)[position_of_differences<<1,2];
  if(xy_new!=xy_old,break(););
 );

 xy_new_hue_at_changed_point=180+rad2deg(atan2(xy_new[0]-50,xy_new[1]-50));
 xy_old_hue_at_changed_point=180+rad2deg(atan2(xy_old[0]-50,xy_old[1]-50));
 diff=xy_new_hue_at_changed_point-xy_old_hue_at_changed_point;

 radius_of_current_point=norm([area_width*xy_new[0]/100,area_height*xy_new[1]/100]-[center_x,center_y]);
 new_shade_tint=lerp(-100,100,(cut(radius_of_current_point,start_radius,end_radius)-start_radius)/difference_radius);

 [round((old_hue+diff)%360,0.01),round(new_shade_tint,0.1)];
 "}
__fx_rep_color_harmonies_tool_generate_points:
number_of_points={arg1(1+$palette_mode,6,6,6,2,3,3,4,3,4,5,6)}
list_of_points={_"
 const start_ang=deg2rad($hue-180);
 const area_width=$_preview_area_width;
 const area_height=$_preview_area_height;
 const center_x=area_width/2;
 const center_y=area_height/2;
 const end_radius=min(center_x,center_y)*($color_wheel_scaling%);
 const start_radius=end_radius*($color_wheel_black_point%);
 const shade_tint_percentile=($shade_tint+100)/200;
 const distance_from_center=lerp(start_radius,end_radius,shade_tint_percentile);
 const palette_mode=$palette_mode;
 const number_of_points=$number_of_points;
 calc_points(ang,pos)=(
   points=[sin(ang)*distance_from_center,cos(ang)*distance_from_center];
   points+=[center_x,center_y];
   points/=[area_width,area_height];
   points*=100;
   copy(all_points[p<<1],points[0],2,1,1,1);
 );
 all_points=vector(#12,nan);
 ang=start_ang;
 palette_mode<3?( # Neutral 8-15 and Analogous 30
  const add_ang=deg2rad(arg1(palette_mode+1,8,15,30));
  repeat(number_of_points,p,
   calc_points(ang,p);
   ang+=add_ang;
  );
 ):
 palette_mode==3?( # Complementary
  repeat(number_of_points,p,
   calc_points(ang,p);
   ang+=pi;
  );
 ):
 palette_mode==4?( # Split-Complementary
  repeat(number_of_points,p,
   calc_points(ang,p);
   if(p
   ,ang+=60Â°;
   ,ang+=150Â°;
   );
  );
 ):
 palette_mode<7?(
  const add_ang=(palette_mode&1?120:90)Â°;
  repeat(number_of_points,p,
   calc_points(ang,p);
   ang+=add_ang;
  );
 ):(
  const ind=palette_mode-7;
  add_ang_a=deg2rad(([90,60,120,30])[ind]);
  add_ang_b=deg2rad(([180,120,30,90])[ind]);
  mode=0;
  repeat(number_of_points,p,
   calc_points(ang,p);
   if(mode
   ,ang+=add_ang_b;
   ,ang+=add_ang_a;
   );
   mode=!mode;
   if(palette_mode==9,if(!p,add_ang_a=60Â°;););
  );
 );
 round(all_points,0.01);
 "}
$list_of_points_strs=$list_of_points
+__fx_rep_color_harmonies_tool_create_color_wheel:
$_preview_area_width,$_preview_area_height,2,3,"begin(
  const mx=w-1;
  const my=h-1;
  const cx=mx/2;
  const cy=my/2;
  const sd=max(w,h)/min(w,h);
  const scaling=1/$color_wheel_scaling%;
  const sx=(w>h?sd:1)*scaling;
  const sy=(w>h?1:sd)*scaling;
  const cxsx=cx/sx;
  const cysy=cy/sy;

  const internal_cut_point=$color_wheel_black_point%;
  const reciprocal_internal_cut_point=1/(1-internal_cut_point);
  const saturation=$saturation%;

  const res_atan_end=(2*pi)/360;
  rescale_radial(value)=(value-internal_cut_point)*reciprocal_internal_cut_point;
  rescale_atan2(value)=(value+pi)/res_atan_end;

  hsl2rgb(hue,saturation,lightness)=(
   H=(hue/60)%6;
   C=(1-abs(2*lightness-1))*saturation;
   X=C*(1-abs(H%2-1));
   m=lightness-C/2;
   RGB=arg1(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
   (RGB+=m)*=255;
  );

  hsl2ryb2rgb(hue,saturation,lightness)=(
   H=(hue/60)%6;
   C=(1-abs(2*lightness-1))*saturation;
   X=C*(1-abs(H%2-1));
   m=lightness-C/2;
   RYB=arg1(1+int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
   RYB+=m*=255;
   red=RYB[0];
   yellow=RYB[1];
   blue=RYB[2];
   white=min(RYB);
   red-=white;
   yellow-=white;
   blue-=white;
   maxyellow=max(red,yellow,blue);
   green=min(yellow,blue);
   yellow-=green;
   blue-=green;
   blue>0&&green>0?(
    blue*=2;
    green*=2
   );
   red+=yellow;
   green+=yellow;
   maxgreen = max(red,green,blue);
   maxgreen>0?(
    N=maxyellow/maxgreen;
    red*=N;
    green*=N;
    blue*=N;
   );
   red+=white;
   green+=white;
   blue+=white;
   [red,green,blue];
  );

  ev_light=vector(#3,255);
  ev_dark=vector(#3,0);

 );

 xx=(x-cx)/cxsx;
 yy=(y-cy)/cysy;

 radial_gradient=rescale_radial(norm(xx,yy));

 inrange(radial_gradient,0,1,1,1)?(
  conical_gradient=rescale_atan2(atan2(xx,yy));
  if(z
  ,hsl2ryb2rgb(conical_gradient,saturation,radial_gradient);
  ,hsl2rgb(conical_gradient,saturation,radial_gradient);
  );
 ):(
  radial_gradient>.5?ev_light:ev_dark;
 );
 "

split[-1] z
#@gui Hitomezashi: fx_rep_hitomezashi,fx_rep_hitomezashi_preview(0)*
#@gui:_=note("<b>Initial</b>"),_=separator()
#@gui:Mode=choice(0,"One String","Two Strings")
#@gui:Pixel Size=int(5,1,20)
#@gui:Symmetry=choice(0,"None","Symmetry A","Symmetry B","Symmetry C","Symmetry D")
#@gui:Output=choice(0,"Inside","Resized")
#@gui:Background Color=choice(0,"Black","White")
#@gui:Background Value=int(0,0,255)
#@gui:Background Color=color(255,255,255)
#@gui:_=note("\n\n<i>String</i>"),_=separator()
#@gui:String=text("")
#@gui:String A=text("")
#@gui:String B=text("")
#@gui:â Randomize Stringâ =button()
#@gui:â Randomize String Aâ =button()
#@gui:â Randomize String Bâ =button()
#@gui:â â Randomize Bothâ â =button()
#@gui:_=note("\nNote : Randomize has been programmed to generate binary as characters are converted as binary in the end.\n\n")
#@gui:_=note("<b>Coloring and Shading</b>"),_=separator()
#@gui:Mode=choice(3,"Base Binary","Grayscale","Monotone","Duotone","Palette")
#@gui:Gray A=float(0,0,255)
#@gui:Gray B=float(255,0,255)
#@gui:Background Color=color(128,128,128)
#@gui:Color A=color(241,255,85)
#@gui:Color B=color(159,26,157)
#@gui:Overall Coloring Palette=choice(0,"Pre-defined Palettes","Random","Random Split-Gradients")
#@gui:Overall Color Space=choice(0,"RGB","HSL")
#@gui:Overall Palette Collection=choice(0,"256 Colors Collection","Pixel Art Palettes")
#@gui:Overall Palette=choice(44,"Default","HSV","Lines","Hot","Cool","Jet","Flag","Cube","Rainbow","Parula","Spring","Summer","Autumn","Winter","Bone","Copper","Pink","Vga","Algae","Amp","Balance","Curl","Deep","Delta","Dense","Diff","Gray","Haline","Ice","Matter","Oxy","Phase","Rain","Solar","Speed","Tarn","Tempo","Thermal","Topo","Turbid","Aurora","Hocus Pocus","SRB2","Uzebox","Amiga 7800","Amiga7800 MESS","Fornax Void I")
#@gui:Overall Palette=choice(10,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Overall Number of Colors=int(8,2,255)
#@gui:Overall Number of Split-Colors=int(5,1,25)
#@gui:Overall Number of Colors Per Split=int(4,2,10)
#@gui:Overall Seed=int(0,0,200000)
#@gui:Overall Seed=int(0,0,200000)
#@gui:Overall Randomize Seed=button()
#@gui:Overall Boundary=choice(0,"Periodic","Continuous")
#@gui:Overall Shift Colors(%)=float(0,0,100)
#@gui:Overall Reverse Internal=bool(0)
#@gui:Overall Reverse Entire=bool(0)
#@gui:Overall Reverse=bool(0)
#@gui:Stray Coloring Palette=choice(0,"Single","Pre-defined Palette","Random")
#@gui:Stray Color=color(0,0,0)
#@gui:Stray Palette=choice(10,"Black & White-{2}","Red-Green-Blue-{3}","Black with Red-Green-Blue-{4}","Black & White with Red-Green-Blue-{5}","Cyan-Magenta-Yellow-{3}","Cyan-Magenta-Yellow-Black-{4}","White-Cyan-Magenta-Yellow-Black-{5}","Red-Green-Blue with Cyan-Magenta-Yellow-{6}","1-Bit RGB-{8}","Aurora-{256}","Zenit-241","Game Builder Garage: Texture-Sprite Editor Palette-{117}","Duel-{256}","Hocus Pocus Palette-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Uzebox-{256}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-RadiantPLUS-{96}","AAP-SPLENDOR128","AAP-DGA16","Cheerful-32","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Famicube-{64}","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","LEGO colors-{43}","Lego Colours 2021-{40}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","Atom-8","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","CPC BOY-{32}","Cade 15","Calder 8-{11}","CD-BAC-{16}","CG Arne-{16}","DinoKnight 16","||||-22","FZT Ethereal 16","Indecision-{17}","Island Joy 16","Journey-{64}","Shallowmarsh26","Lago Nenufar &#40;Lake Water Lily&#41;-{19}","Juicy 17","ChocolateGanache-{96}","Bright Winter 1-{74}","Bright Winter 2-{83}","Kawaii16","0xdb-01-{17}","GZXP-{11}","Chromatic16","Piet Coding Language-{20}","Matrix-{96}","Material Design-{96}","Rainbow-{88}","Rainbow-{96}","SCRJ-XXXVI-{36}","Pxls Default-{32}","Lospec500-{42}","Moderna-{24}","Oak21","Nature's Embrace 55","RBYPGO-{94}","New Worlds 46","Nauris-16","Dynamite-{40}","Interstate 28","Downgraded 32","Pear 36","Pineapple 32","Peachy Pop 16","Resurrect 32","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","The Roarin 80's","Starmancer-{52}","SuperFuture25","SUNSHINE 35","Sweetie 16","Calm 48","Optimism-{32}","Taffy 16","Todayland Palette V2-{25}","TriRampo-{12}","r|place 2022-{32}","Tropical Cone 24","Vivid-17","SHIDO50+-{72}","Intacto14","Itatsi-{23}","ENOS16","Grixel Grotto-{16}","Superb 8","Undertones-17","Tango-{28}","Cheese Palette-{28}","Equpix 15","Zughy 32","Voodo34","Franzston 30","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11-{16}","Copper-Tech-{16}","DRZ15A","Eggy 15","Europa 16","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Wyrm 24","Yume Nikki-{24}","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Crayola Blind-{9}","FunkyFuture8","The Golden Wall Palette-{7}","Matriax8c","NT1H-{26}","JerryPie 22","Nineties Nine-{9}","On70-{35}","ANB16","Retrocal-8","Punolit-{21}","Luap 40","Autum Villan 6","Autum 15","Autum 15 [Yellow]","Galaxy Flame-{16}","Cretaceous-16","Antiquity16","Mushroom-{14}","Aerugo-{32}","Hotel Paintings 6","Nopal-12","Brightness GPY-{3}","Blessing-{5}","Fairydust 8","Vanilla MilkShake-{16}","Fuzzy Four-{4}","Fairy Tales-{8}","Naji 16","Easter Island-{16}","Pastel and Darks 58 Palette","17 Pastels","NOSTALGIA15","Ocaso-{17}","Oh Hell&#44; Pastel-{15}","Pollen-8","KULE-16","Hydrangea 11","Fluffy8","ST 8 R&B Remake","Neon Space-{10}","Cyclope6","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Lost Century 24","Finlal 11","Industrial Factory 16","Murder Mystery 16","Fate & Destiny 12","Vinik 24","YKB-22","Halloween-{7}","Graveyard-21","Steam Lords-{16}","Frostical-{18}","DeuteroSpill-{9}","Cool Bone 7","Muted Ally 6","EPHEMERA-{12}","Ink-{5}","Violet Dreams-{8}","Tinyfolks-{5}","Old Gold 7","Rosemoss-8","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Dead Weight-8","Mojave20","Petite-8","Petite-8 Afterdark","XAIUE-Radiant-{22}","Daruda 22","Firestorm-{9}","Borkfest-{8}","Spicy 07","Rust-6","Apricot-{6}","SuperNova 7","Pastry-{5}","Sandy 06","Illumination-{5}","NYX8","Dream Haze 8","OIL6","Regal10","Soft Demon 7","SGM-Palette 2-{17}","Midnight ablaze-{7}","Black Cherry-{5}","Sunset Red-{5}","INKPINK-{6}","Brash Pink-{5}","Pink Neon Sign 6","Enchanted Purple-{12}","Arch-{11}","Spacey Easter-{17}","Fornax Void I-{254}","Fornax Void II-{128}","Pixelwave-{12}","S1-6","Berry Nebula-{8}","ABYSS-9","Moonlight 15","Moonlit-39","H2O-{10}","Magic Waters 9","Bluem0ld-{4}","Moss-{5}","DEEP MAZE-{7}","Toxic Slime-{5}","Lush Green-{6}","Tsunami-{5}","Cryptic Ocean-{6}","Marsh Madness-{5}","OXYD-{8}","Pink&Green-{8}","Walking in the Woods 8","Paper 8","Sahara Pastell-{7}","Sunflower Painting 7","Art Hoe Aesthetic 7","Sky5-{7}","Ocean Glass-{8}","RoyalGuard-{6}","Eulbink-{7}","Winter Wonderland-{8}","Moon Squid 7","Stratus-{5}","Arctic Dust-{5}","CL8UDS","Lilac Skies 5","Sea of Fire-{6}","Autochrome 3","Autochrome 5","GB Default 1-{4}","GB Default 2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Suburb-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","Gold GB-{4}","GB Chocolate-{4}","GB Gray-{4}","GB Spacehaze-{4}","GB Purple Dawn-{4}","Moon Crystal-{4}","ARNE4","Autumn Chill-{4}","CherryMelon-{4}","HallowPumpkin-{4}","Hollow-{4}","Lavender4","MAW-{4}","Voltage Warning-{4}","Tritanopia-{5}","Rabbit 7","Amiga 2600 NTSC-{127}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","Atari 8-Bit Series - GTIA-{256}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 - Pepto-{16}","Commodore 64 - Colodore-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","Macintosh 8-Bit System Palette-{256}","MSX-{15}","NES-{55}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","TRS-80 Color Computer Palette-{4}","Virtual Boy interpreted-{4}","VGA-{244}","Win 95-{256}","ZX Spectrum-{15}","GNOME 32","Electronic Crayon 22","Chip16","Deluxe Paint-{222}","FlatUI-{20}","MakeCode Arcade Palette-{15}","Oekaki-{20}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}","Piet Palette-{5}","Japanese Woodblock Palette-{12}","Human Faces-{94}","HSV Palette-{96}","ST24 Christmas","Reds-{24}")
#@gui:Stray Number of Colors=int(8,2,20)
#@gui:Stray Seed=int(0,0,200000)
#@gui:Stray Randomize Seed=button()
#@gui:Stray Symmetry=bool(0)_0
#@gui:Stray Reverse=bool(0)
#@gui:_=note("<b>Border</b>"),_=separator()
#@gui:Border Size(%)=float(10,0,100)
#@gui:Border Value=float(128,0,255)
#@gui:Border Color=color(0,0,0)
#@gui:_=note("<b>Preview</b>"),_=separator()
#@gui:Cropped Viewport Point=point(50,50,-1,1,255,255,255,255,1%)
#@gui:Reset Points to Center=button()
#@gui:Started Filter=bool(1)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2023/9/11</i>.</small>")
fx_rep_hitomezashi:
skip "${10=}","${11=}","${12=}"

k[0]

ow,oh={[w,h]}

if $3
 if $4
  length_w={ceil((w-$2)/($2*2))}
  length_h={ceil((h-$2)/($2*2))}
 else
  length_w={floor((w-$2)/($2*2))}
  length_h={floor((h-$2)/($2*2))}
 fi
else
 if $4
  length_w={ceil(w/$2)}
  length_h={ceil(h/$2)}
 else
  length_w={floor(w/$2)}
  length_h={floor(h/$2)}
 fi
fi

stray_seed,split_count=$51,$35

if $1

 if !$14&&!$16
  if size('"$11"')>1
   if size('"$11"')<=2
    ('"$11"')
    r. $length_w,1,1,1,0,2
    bin_str_a={t}
    rm.
   else
    bin_str_a="$11"
   fi
  else
   bin_str_a=${rep_random_bits\ $length_w}
  fi
 else
  bin_str_a=${rep_random_bits\ $length_w}
 fi

 if !$15&&!$16
  if size('"$12"')>1
   if size('"$12"')<=2
    ('"$12"')
    r. $length_h,1,1,1,0,2
    bin_str_b={t}
    rm.
   else
    bin_str_b="$12"
   fi
  else
   bin_str_b=${rep_random_bits\ $length_h}
  fi
 else
  bin_str_b=${rep_random_bits\ $length_h}
 fi

 if !$4
  ('$bin_str_a')
  r. $length_w,100%,100%,100%,0,2
  bin_a={t}
  rm.

  ('$bin_str_b')
  r. $length_h,100%,100%,100%,0,2
  bin_b={t}
  rm.
 else
  bin_a=$bin_str_a
  bin_b=$bin_str_b
 fi

else

 max_length={max($length_w,$length_h)}

 if !$13
  if size('"$10"')>1
   if size('"$10"')<=2
    ('"$10"')
    r. $max_length,1,1,1,0,2
    bin_str_0={t}
    rm.
   else
    bin_str_0="$10"
   fi
  else
   bin_str_0=${rep_random_bits\ $max_length}
  fi
 else
  bin_str_0=${rep_random_bits\ $max_length}
 fi

 if !$4
  ('$bin_str_0')
  r. $length_w,100%,100%,100%,0,2
  bin_a={t}
  rm.

  ('$bin_str_0')
  r. $length_h,100%,100%,100%,0,2
  bin_b={t}
  rm.
 else
  bin_a=$bin_str_0
  bin_b=$bin_str_0
 fi

fi

if $17==4

 if $29==2

  if $30 col=[u(360),u(1),u(1)]
  else col=[u(255),u(255),u(255)]
  fi

  $34,1,1,3

  if $39 seed_b={v(200000)}
  else   seed_b=$38
  fi

  local[-1] {

   split_count={$35<$34?$35:$34}

   if $split_count>1 s x,$split_count fi

   f begin(length=(w-1)/$36;);x/length

   $36,1,1,1

   repeat $split_count {
    f. begin(srand($seed_b+$>););$col
    if $42 mirror. x fi
    rep_cubic_map[$>] [-1],2
   }

   rm.

   a x

   if $30 hsl2rgb. fi
   if $43 mirror. x fi

  }

 elif $29==1

  if $39 seed_a={v(200000)}
  else   seed_a=$37
  fi

  if $30 $34,1,1,3,begin(srand($seed_a););[u(360),u(1),u(1)] hsl2rgb.
  else   $34,1,1,3,begin(srand($seed_a););[u(255),u(255),u(255)]
  fi

  if $44 mirror. x fi

 else

  if $31 pal $33
  else palette $32
  fi

  if $44 mirror. x fi

 fi

 if $45

  if $52
   stray_seed={v(200000)}
  fi

  if $45==2
   $50,1,1,3,begin(srand($stray_seed););[u(255),u(255),u(255)]
  else
   pal $49
  fi

  if $54 mirror. x fi

  if $3 +rep_hitomezashi $bin_a,$bin_b,$2,[-2],[-1],{int($41/100*w#-2)},$40,{$3-1},$stray_seed,${46-48},{round($55/100*$2)},${57-59}
  else  +rep_hitomezashi $bin_a,$bin_b,$2,[-2],[-1],{int($41/100*w#-2)},$40,,$stray_seed,${46-48},{round($55/100*$2)},${57-59}
  fi

  rm[-3,-2]

 else

  if $3 +rep_hitomezashi $bin_a,$bin_b,$2,[-1],,{int($41/100*w#-1)},$40,{$3-1},$stray_seed,${46-48},{round($55/100*$2)},${57-59}
  else  +rep_hitomezashi $bin_a,$bin_b,$2,[-1],,{int($41/100*w#-1)},$40,,$stray_seed,${46-48},{round($55/100*$2)},${57-59}
  fi
  rm..

 fi

elif $17==3

 color_a=${rep_int82hex\ ${23-25}}
 color_b=${rep_int82hex\ ${26-28}}

 if $3 +rep_hitomezashi $bin_a,$bin_b,$2,$color_a,$color_b,{$3-1},{round($55/100*$2)},${57-59}
 else +rep_hitomezashi $bin_a,$bin_b,$2,$color_a,$color_b,,{round($55/100*$2)},${57-59}
 fi

elif $17==2

 bgcol=${rep_int82hex\ ${20-22}}

 if $3 +rep_hitomezashi $bin_a,$bin_b,$2,$bgcol,,{$3-1},{round($55/100*$2)},${57-59}
 else +rep_hitomezashi $bin_a,$bin_b,$2,$bgcol,,,{round($55/100*$2)},${57-59}
 fi

elif $17==1

 if $3 +rep_hitomezashi $bin_a,$bin_b,$2,$18~,$19~,{$3-1},{round($55/100*$2)},$56
 else +rep_hitomezashi $bin_a,$bin_b,$2,$18~,$19~,,{round($55/100*$2)},$56
 fi

else

 if $3 +rep_hitomezashi $bin_a,$bin_b,$2,,,{$3-1}
 else +rep_hitomezashi $bin_a,$bin_b,$2
 fi

 *. 255

fi

k.

if !$4
  if $17>1 $ow,$oh,1,{s},[${7-9}]
  else
   val={$17?$6:$5?($5<<8)-1}
   $ow,$oh,1,{s},$val
  fi

  j[1] [0],.5~,.5~

  rm..
fi

u $bin_str_0,$bin_str_a,$bin_str_b,$seed_a,$seed_b,$stray_seed,$split_count
fx_rep_hitomezashi_preview:
skip "${10=}","${11=}","${12=}"

fx_rep_hitomezashi $"*"

bin_str_0,bin_str_a,bin_str_b,seed_a,seed_b,stray_seed,split_count=${}

point_x,point_y,started={[$-4,$-3,$-1]}

if !isnan($point_x)
 point_x,point_y:=($-2||$started)?[100*(50%*w+1)/w,100*(50%*h)/h]:cut([$-4,$-3],0,100)

 eval "
  points=[$point_x,$point_y]%;

  trim_out_width=min($_preview_width,w);
  trim_out_height=min($_preview_height,h);

  trimmed_width=w-trim_out_width;
  trimmed_height=h-trim_out_height;

  x0=ceil(trimmed_width*points[0]);
  y0=ceil(trimmed_height*points[1]);
  x1=x0+trim_out_width-1;
  y1=y0+trim_out_height-1;
  [x0,y0,x1,y1];"

 crop ${}

 started=0
fi

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"_{!$17?!$4?2}\
"{$6}"_{$17==1?!$4?2}\
"{$7,$8,$9}"_{$17>1?!$4?2}\
"{"$bin_str_0"}"_{!$1?2}\
"{"$bin_str_a"}"_{$1?2}\
"{"$bin_str_b"}"_{$1?2}\
"{0}"_{!$1?2}\
"{0}"_{$1?2}\
"{0}"_{$1?2}\
"{0}"_{$1?2}\
"{$17}"\
"{$18}"_{$17==1?2}\
"{$19}"_{$17==1?2}\
"{$20,$21,$22}"_{$17==2?2}\
"{$23,$24,$25}"_{$17==3?2}\
"{$26,$27,$28}"_{$17==3?2}\
"{$29}"_{$17==4?2}\
"{$30}"_{$17==4?($29?2)}\
"{$31}"_{$17==4?(!$29?2)}\
"{$32}"_{$17==4?(!$29?!$31?2)}\
"{$33}"_{$17==4?(!$29?$31?2)}\
"{$34}"_{$29&&$17==4?2}\
"{"$split_count"}"_{$17==4?($29==2?2)}\
"{$36}"_{$17==4?($29==2?2)}\
"{"$seed_a"}"_{$17==4?($29==1?2)}\
"{"$seed_b"}"_{$17==4?($29==2?2)}\
"{0}"_{$17==4?($29?2)}\
"{$40}"_{$17==4?2}\
"{$41}"_{$17==4?2}\
"{$42}"_{$17==4?($29==2?2)}\
"{$43}"_{$17==4?($29==2?2)}\
"{$44}"_{$17==4?($29==1?2)}\
"{$45}"_{$17==4?2}\
"{$46,$47,$48}"_{$17==4?(!$45?2)}\
"{$49}"_{$17==4?($45==1?2)}\
"{$50}"_{$17==4?($45==2?2)}\
"{"$stray_seed"}"_{$17==4?($45?2)}\
"{0}"_{$17==4?($45?2)}\
"{$53}"\ # This is a future feature variable
"{$54}"_{$17==4?($45?2)}\
"{$55}"_{$17?2}\
"{$56}"_{$17==1?2}\
"{$57,$58,$59}"_{$17>1?2}\
"{"$point_x","$point_y"}"\
"{0}"_{!isnan($-4)+1}\
"{"$started"}"
#@gui Mitchell Concatenation: fx_rep_mitchell_concatenation,fx_rep_mitchell_concatenation_preview(0)*
#@gui:_=note("This filter is a recreation of <a href="http://www.kerrymitchell.art/spacefilling-blog/2013/11/concatenations.html">Kerry's Mitchell Concatenation</a>.\n\nWarning: Make sure of the options being applied!"),_=separator()
#@gui:_=note("<b>Initial</b>")
#@gui:Mode=choice(0,"Singular","Dual")
#@gui:Pixel Size(%)=float(0,0,50)
#@gui:Output=choice(0,"New Dimension","Old Dimension")
#@gui:_=separator(),_=note("<b>Starting Point</b>")
#@gui:Start=int(1,1,2000000)
#@gui:Start A=int(1,1,2000000)
#@gui:Start B=int(1,1,2000000)
#@gui:Link Start Numbers?=bool(0)
#@gui:_=separator(),_=note("<b>Base System</b>")
#@gui:Base=int(10,2,1000)
#@gui:Base A=int(10,2,1000)
#@gui:Base B=int(10,2,1000)
#@gui:Link Bases?=bool(0)
#@gui:_=separator(),_=note("<b>Method</b>")
#@gui:Method=choice(0,"Subtraction","Addition","Multiplication")
#@gui:Method A=choice(0,"Subtraction","Addition","Multiplication")
#@gui:Method B=choice(1,"Subtraction","Addition","Multiplication")
#@gui:Link Method?=bool(0)
#@gui:_=separator(),_=note("<b>Palette</b>")
#@gui:Mode=choice(1,"Singular","Dual")
#@gui:Set=choice(0,"Foreground","Background")
#@gui:Color 1=color(255,255,255)
#@gui:Color 2=color(243,235,227)
#@gui:Color 3=color(200,200,136)
#@gui:Color 4=color(124,143,91)
#@gui:Color 5=color(53,74,67)
#@gui:Color 6=color(34,23,36)
#@gui:Color 7=color(0,0,0)
#@gui:Color 1=color(206,206,206)
#@gui:Color 2=color(198,186,182)
#@gui:Color 3=color(166,135,182)
#@gui:Color 4=color(120,105,70)
#@gui:Color 5=color(55,69,48)
#@gui:Color 6=color(37,33,47)
#@gui:Color 7=color(24,24,24)
#@gui:Color 1=color(255,255,255)
#@gui:Color 2=color(243,236,227)
#@gui:Color 3=color(186,200,136)
#@gui:Color 4=color(102,143,91)
#@gui:Color 5=color(55,53,74)
#@gui:Color 6=color(36,23,25)
#@gui:Color 7=color(0,0,0)
#@gui:Link Color Palettes?=bool(0)
#@gui:_=separator(),_=note("<b>Shape</b>")
#@gui:Use Shape=bool(1)
#@gui:Tiled Shape=choice(2,"Australia","Barbedwire","Circle","Crosshair","Cupid","Diamond","Dragon Curve-[D]","Dragonfly","Fern-[D]","Flip","Gear-[D]","Gumleaf","Heart","Information","Kookaburra","Mail","Mapleleaf","Paint Splat","Paw","Phone","Polygon-[D]","Rooster","Shopping Cart","Snowflake-[D]","Star-[D]")
#@gui:Use Image as shape?=bool(0)
#@gui:Ratio(%)=float(100,.1,100)
#@gui:Angle=float(0,-180,180)
#@gui:Direction=choice(0,"None","Mirror X","Mirror Y")
#@gui:Tile Boundary=choice(0,"Periodic","Mirror - X","Mirror - Y","Mirror - XY")
#@gui:Fit Tile?=bool(1)
#@gui:Dragon Curve Recursion=int(10,0,30)
#@gui:Dragon Curve Rotation=float(0,-180,180)
#@gui:Fern Type=choice("Asplenium Adiantum-Nigrum","Thelypteridaceae")
#@gui:Fern Density (%)=float(100,0,300)
#@gui:Gear Teeth Count=int(8,3,32)
#@gui:Gear Height (%)=float(25,0.1,100)
#@gui:Gear Offset Teeth (%)=float(0,0,100)
#@gui:Gear Inner Ratio (%)=float(50,0.1,100)
#@gui:Polygon Vertices=int(5,3,100)
#@gui:Snowflake Recursion=int(5,1,6)
#@gui:Star Branches=int(3,5,100)
#@gui:Star Thickness (%)=float(38,.1,100)
#@gui:_=separator(),_=note("<b>Misc</b>")
#@gui:Position=choice(0,"10","100","1000","10000","100000")
#@gui:Position A=choice(0,"10","100","1000","10000","100000")
#@gui:Position B=choice(0,"10","100","1000","10000","100000")
#@gui:Push into Start Number=button()
#@gui:Push into Start A=button()
#@gui:Push into Start B=button()
#@gui:Push into Both=button()
#@gui:Start A=int(1,1,2000000)_0
#@gui:Start B=int(1,1,2000000)_0
#@gui:Base A=int(10,2,1000)_0
#@gui:Base B=int(10,2,1000)_0
#@gui:Method A=choice(0,"Subtraction","Addition","Multiplication")_0
#@gui:Method B=choice(0,"Subtraction","Addition","Multiplication")_0
#@gui:Color 1=color(255,255,255)_0
#@gui:Color 2=color(243,235,227)_0
#@gui:Color 3=color(200,200,136)_0
#@gui:Color 4=color(124,143,91)_0
#@gui:Color 5=color(53,74,67)_0
#@gui:Color 6=color(34,23,36)_0
#@gui:Color 7=color(0,0,0)_0
#@gui:Color 1=color(206,206,206)_0
#@gui:Color 2=color(198,186,182)_0
#@gui:Color 3=color(166,135,182)_0
#@gui:Color 4=color(120,105,70)_0
#@gui:Color 5=color(55,69,48)_0
#@gui:Color 6=color(37,33,47)_0
#@gui:Color 7=color(24,24,24)_0
#@gui:Color 1=color(255,255,255)_0
#@gui:Color 2=color(243,236,227)_0
#@gui:Color 3=color(186,200,136)_0
#@gui:Color 4=color(102,143,91)_0
#@gui:Color 5=color(55,53,74)_0
#@gui:Color 6=color(36,23,25)_0
#@gui:Color 7=color(0,0,0)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2022/02/08</i>.</small>")
fx_rep_mitchell_concatenation:
 _fx_rep_mitchell_concatenation_base $*

fx_rep_mitchell_concatenation_preview:
 niw,nih,ms=$_preview_width,${-max_h},${-max_h}
 rm

 $niw,$nih,1,$ms
 _fx_rep_mitchell_concatenation_base $*
 r 100%,$_preview_height,100%,100%,0,0,.5,.5

_fx_rep_mitchell_concatenation_base:

original_dimension:=[w,h]
multiple_images:=$!>1
pixels:=max(1,round(h*$2%))
enabl_mode_double_concatenation:=$pixels>=4
ini_double_concatenation_mode:=$enabl_mode_double_concatenation?$1
double_concatenation_mode=0
start_0=$4

if $105
 start_0:=max(1,($8^($102+1))-int(h/($pixels*2)))
fi

start_a,start_b=${5-6}

if $7&&$ini_double_concatenation_mode
 if $5!=$109 start_a,start_b=$5 fi
 if $6!=$110 start_a,start_b=$6 fi
fi

base_a,base_b=${9-10}

if $11&&$ini_double_concatenation_mode
 if $9!=$111 base_a,base_b=$9 fi
 if $10!=$112 base_a,base_b=$10 fi
fi

method_a,method_b=${13-14}

if $15&&$ini_double_concatenation_mode
 if $13!=$113 method_a,method_b=$13 fi
 if $14!=$114 method_a,method_b=$14 fi
fi

if $ini_double_concatenation_mode
 double_concatenation_mode:=(($start_a!=$start_b)||($base_a!=$base_b)||($method_a!=$method_b))?1
fi

if $double_concatenation_mode
 diff:=int(h/($pixels*2))
 if $106||$108
  start_a:=max(1,($base_a^($103+1))-$diff)
 fi
 if $107||$108
  start_b:=max(1,($base_b^($104+1))-$diff)
 fi
 if $ini_double_concatenation_mode
  double_concatenation_mode:=(($start_a!=$start_b)||($base_a!=$base_b)||($method_a!=$method_b))?1
 fi
fi

if $81

 if $double_concatenation_mode&&$16

  if sum(abs([${39-59}]-[${136-156}]))?1

   col_0_r_0,col_0_g_0,col_0_b_0,\
   col_0_r_1,col_0_g_1,col_0_b_1,\
   col_0_r_2,col_0_g_2,col_0_b_2,\
   col_0_r_3,col_0_g_3,col_0_b_3,\
   col_0_r_4,col_0_g_4,col_0_b_4,\
   col_0_r_5,col_0_g_5,col_0_b_5,\
   col_0_r_6,col_0_g_6,col_0_b_6\
   =${39-59}
   col_a_r_0,col_a_g_0,col_a_b_0,\
   col_a_r_1,col_a_g_1,col_a_b_1,\
   col_a_r_2,col_a_g_2,col_a_b_2,\
   col_a_r_3,col_a_g_3,col_a_b_3,\
   col_a_r_4,col_a_g_4,col_a_b_4,\
   col_a_r_5,col_a_g_5,col_a_b_5,\
   col_a_r_6,col_a_g_6,col_a_b_6\
   =${39-59}
   col_b_r_0,col_b_g_0,col_b_b_0,\
   col_b_r_1,col_b_g_1,col_b_b_1,\
   col_b_r_2,col_b_g_2,col_b_b_2,\
   col_b_r_3,col_b_g_3,col_b_b_3,\
   col_b_r_4,col_b_g_4,col_b_b_4,\
   col_b_r_5,col_b_g_5,col_b_b_5,\
   col_b_r_6,col_b_g_6,col_b_b_6\
   =${39-59}

  elif sum(abs([${60-80}]-[${157-177}]))?1

   col_0_r_0,col_0_g_0,col_0_b_0,\
   col_0_r_1,col_0_g_1,col_0_b_1,\
   col_0_r_2,col_0_g_2,col_0_b_2,\
   col_0_r_3,col_0_g_3,col_0_b_3,\
   col_0_r_4,col_0_g_4,col_0_b_4,\
   col_0_r_5,col_0_g_5,col_0_b_5,\
   col_0_r_6,col_0_g_6,col_0_b_6\
   =${60-80}
   col_a_r_0,col_a_g_0,col_a_b_0,\
   col_a_r_1,col_a_g_1,col_a_b_1,\
   col_a_r_2,col_a_g_2,col_a_b_2,\
   col_a_r_3,col_a_g_3,col_a_b_3,\
   col_a_r_4,col_a_g_4,col_a_b_4,\
   col_a_r_5,col_a_g_5,col_a_b_5,\
   col_a_r_6,col_a_g_6,col_a_b_6\
   =${60-80}
   col_b_r_0,col_b_g_0,col_b_b_0,\
   col_b_r_1,col_b_g_1,col_b_b_1,\
   col_b_r_2,col_b_g_2,col_b_b_2,\
   col_b_r_3,col_b_g_3,col_b_b_3,\
   col_b_r_4,col_b_g_4,col_b_b_4,\
   col_b_r_5,col_b_g_5,col_b_b_5,\
   col_b_r_6,col_b_g_6,col_b_b_6\
   =${60-80}
  else

   col_0_r_0,col_0_g_0,col_0_b_0,\
   col_0_r_1,col_0_g_1,col_0_b_1,\
   col_0_r_2,col_0_g_2,col_0_b_2,\
   col_0_r_3,col_0_g_3,col_0_b_3,\
   col_0_r_4,col_0_g_4,col_0_b_4,\
   col_0_r_5,col_0_g_5,col_0_b_5,\
   col_0_r_6,col_0_g_6,col_0_b_6\
   =${18-38}
   col_a_r_0,col_a_g_0,col_a_b_0,\
   col_a_r_1,col_a_g_1,col_a_b_1,\
   col_a_r_2,col_a_g_2,col_a_b_2,\
   col_a_r_3,col_a_g_3,col_a_b_3,\
   col_a_r_4,col_a_g_4,col_a_b_4,\
   col_a_r_5,col_a_g_5,col_a_b_5,\
   col_a_r_6,col_a_g_6,col_a_b_6\
   =${39-59}
   col_b_r_0,col_b_g_0,col_b_b_0,\
   col_b_r_1,col_b_g_1,col_b_b_1,\
   col_b_r_2,col_b_g_2,col_b_b_2,\
   col_b_r_3,col_b_g_3,col_b_b_3,\
   col_b_r_4,col_b_g_4,col_b_b_4,\
   col_b_r_5,col_b_g_5,col_b_b_5,\
   col_b_r_6,col_b_g_6,col_b_b_6\
   =${60-80}

  fi

 else

  if sum(abs([${18-38}]-[${115-135}]))?1

   col_0_r_0,col_0_g_0,col_0_b_0,\
   col_0_r_1,col_0_g_1,col_0_b_1,\
   col_0_r_2,col_0_g_2,col_0_b_2,\
   col_0_r_3,col_0_g_3,col_0_b_3,\
   col_0_r_4,col_0_g_4,col_0_b_4,\
   col_0_r_5,col_0_g_5,col_0_b_5,\
   col_0_r_6,col_0_g_6,col_0_b_6\
   =${18-38}
   col_a_r_0,col_a_g_0,col_a_b_0,\
   col_a_r_1,col_a_g_1,col_a_b_1,\
   col_a_r_2,col_a_g_2,col_a_b_2,\
   col_a_r_3,col_a_g_3,col_a_b_3,\
   col_a_r_4,col_a_g_4,col_a_b_4,\
   col_a_r_5,col_a_g_5,col_a_b_5,\
   col_a_r_6,col_a_g_6,col_a_b_6\
   =${18-38}
   col_b_r_0,col_b_g_0,col_b_b_0,\
   col_b_r_1,col_b_g_1,col_b_b_1,\
   col_b_r_2,col_b_g_2,col_b_b_2,\
   col_b_r_3,col_b_g_3,col_b_b_3,\
   col_b_r_4,col_b_g_4,col_b_b_4,\
   col_b_r_5,col_b_g_5,col_b_b_5,\
   col_b_r_6,col_b_g_6,col_b_b_6\
   =${18-38}

  else

   col_0_r_0,col_0_g_0,col_0_b_0,\
   col_0_r_1,col_0_g_1,col_0_b_1,\
   col_0_r_2,col_0_g_2,col_0_b_2,\
   col_0_r_3,col_0_g_3,col_0_b_3,\
   col_0_r_4,col_0_g_4,col_0_b_4,\
   col_0_r_5,col_0_g_5,col_0_b_5,\
   col_0_r_6,col_0_g_6,col_0_b_6\
   =${18-38}
   col_a_r_0,col_a_g_0,col_a_b_0,\
   col_a_r_1,col_a_g_1,col_a_b_1,\
   col_a_r_2,col_a_g_2,col_a_b_2,\
   col_a_r_3,col_a_g_3,col_a_b_3,\
   col_a_r_4,col_a_g_4,col_a_b_4,\
   col_a_r_5,col_a_g_5,col_a_b_5,\
   col_a_r_6,col_a_g_6,col_a_b_6\
   =${39-59}
   col_b_r_0,col_b_g_0,col_b_b_0,\
   col_b_r_1,col_b_g_1,col_b_b_1,\
   col_b_r_2,col_b_g_2,col_b_b_2,\
   col_b_r_3,col_b_g_3,col_b_b_3,\
   col_b_r_4,col_b_g_4,col_b_b_4,\
   col_b_r_5,col_b_g_5,col_b_b_5,\
   col_b_r_6,col_b_g_6,col_b_b_6\
   =${60-80}

  fi

 fi

else

 col_0_r_0,col_0_g_0,col_0_b_0,\
 col_0_r_1,col_0_g_1,col_0_b_1,\
 col_0_r_2,col_0_g_2,col_0_b_2,\
 col_0_r_3,col_0_g_3,col_0_b_3,\
 col_0_r_4,col_0_g_4,col_0_b_4,\
 col_0_r_5,col_0_g_5,col_0_b_5,\
 col_0_r_6,col_0_g_6,col_0_b_6\
 =${18-38}
 col_a_r_0,col_a_g_0,col_a_b_0,\
 col_a_r_1,col_a_g_1,col_a_b_1,\
 col_a_r_2,col_a_g_2,col_a_b_2,\
 col_a_r_3,col_a_g_3,col_a_b_3,\
 col_a_r_4,col_a_g_4,col_a_b_4,\
 col_a_r_5,col_a_g_5,col_a_b_5,\
 col_a_r_6,col_a_g_6,col_a_b_6\
 =${39-59}
 col_b_r_0,col_b_g_0,col_b_b_0,\
 col_b_r_1,col_b_g_1,col_b_b_1,\
 col_b_r_2,col_b_g_2,col_b_b_2,\
 col_b_r_3,col_b_g_3,col_b_b_3,\
 col_b_r_4,col_b_g_4,col_b_b_4,\
 col_b_r_5,col_b_g_5,col_b_b_5,\
 col_b_r_6,col_b_g_6,col_b_b_6\
 =${60-80}

fi

if $double_concatenation_mode

 if $16

  dyn_single_palette,dyn_dual_palette=0,2

  ($col_a_r_0,$col_a_g_0,$col_a_b_0)
  ($col_a_r_1,$col_a_g_1,$col_a_b_1)
  ($col_a_r_2,$col_a_g_2,$col_a_b_2)
  ($col_a_r_3,$col_a_g_3,$col_a_b_3)
  ($col_a_r_4,$col_a_g_4,$col_a_b_4)
  ($col_a_r_5,$col_a_g_5,$col_a_b_5)
  ($col_a_r_6,$col_a_g_6,$col_a_b_6)

  a[-7--1] y permute. cyzx rotate. 90

  ($col_b_r_0,$col_b_g_0,$col_b_b_0)
  ($col_b_r_1,$col_b_g_1,$col_b_b_1)
  ($col_b_r_2,$col_b_g_2,$col_b_b_2)
  ($col_b_r_3,$col_b_g_3,$col_b_b_3)
  ($col_b_r_4,$col_b_g_4,$col_b_b_4)
  ($col_b_r_5,$col_b_g_5,$col_b_b_5)
  ($col_b_r_6,$col_b_g_6,$col_b_b_6)

  a[-7--1] y permute. cyzx rotate. 90

  if $84&&$multiple_images
   use_shape=1
   rep_mitchell_concatenation[0--4] $start_a,$start_b,$base_a,$base_b,$method_a,$method_b,$pixels,[-2],[-1],1,[-3],{$85/100},${86-89},1
  else
   use_shape=2
   set_arg=1
   if $83==6 set_arg.=,${90-91}
   elif $83==8 set_arg.=,$93%,0,1,$92
   elif $83==10 set_arg.=,${94-97}
   elif $83==20 set_arg.=,$98
   elif $83==23 set_arg.=,$99
   elif $83==24 set_arg.=,$100,{$101/100}
   fi
   rep_mitchell_concatenation[0--3] $start_a,$start_b,$base_a,$base_b,$method_a,$method_b,$pixels,[-2],[-1],1,$83,{$85/100},${86-89},$set_arg
  fi

  rm[-2,-1]

 else

  dyn_single_palette,dyn_dual_palette=2,0

  ($col_0_r_0,$col_0_g_0,$col_0_b_0)
  ($col_0_r_1,$col_0_g_1,$col_0_b_1)
  ($col_0_r_2,$col_0_g_2,$col_0_b_2)
  ($col_0_r_3,$col_0_g_3,$col_0_b_3)
  ($col_0_r_4,$col_0_g_4,$col_0_b_4)
  ($col_0_r_5,$col_0_g_5,$col_0_b_5)
  ($col_0_r_6,$col_0_g_6,$col_0_b_6)

  a[-7--1] y permute. cyzx rotate. 90

  if $84&&$multiple_images
   use_shape=1
   rep_mitchell_concatenation[0--3] $start_a,$start_b,$base_a,$base_b,$method_a,$method_b,$pixels,[-1],,1,[-2],{$85/100},${86-89},1
  else
   use_shape=2
   set_arg=1
   if $83==6 set_arg.=,${90-91}
   elif $83==8 set_arg.=,$93%,0,1,$92
   elif $83==10 set_arg.=,${94-97}
   elif $83==20 set_arg.=,$98
   elif $83==23 set_arg.=,$99
   elif $83==24 set_arg.=,$100,{$101/100}
   fi
   rep_mitchell_concatenation[0--2] $start_a,$start_b,$base_a,$base_b,$method_a,$method_b,$pixels,[-1],,1,$83,{$85/100},${86-89},$set_arg
  fi

  rm.

 fi

else

 dyn_single_palette,dyn_dual_palette=2,0

 ($col_0_r_0,$col_0_g_0,$col_0_b_0)
 ($col_0_r_1,$col_0_g_1,$col_0_b_1)
 ($col_0_r_2,$col_0_g_2,$col_0_b_2)
 ($col_0_r_3,$col_0_g_3,$col_0_b_3)
 ($col_0_r_4,$col_0_g_4,$col_0_b_4)
 ($col_0_r_5,$col_0_g_5,$col_0_b_5)
 ($col_0_r_6,$col_0_g_6,$col_0_b_6)

 a[-7--1] y permute. cyzx rotate. 90

 if $82

  if $84&&$multiple_images
   use_shape=1
   rep_mitchell_concatenation[0--3] $start_0,$start_0,$8,$8,$12,$12,$pixels,[-1],,1,[-2],{$85/100},${86-89},1
  else
   use_shape=2
   set_arg=1

   if $83==6 set_arg.=,${90-91}
   elif $83==8 set_arg.=,$93%,0,1,$92
   elif $83==10 set_arg.=,${94-97}
   elif $83==20 set_arg.=,$98
   elif $83==23 set_arg.=,$99
   elif $83==24 set_arg.=,$100,{$101/100}
   fi

   rep_mitchell_concatenation[0--2] $start_0,$start_0,$8,$8,$12,$12,$pixels,[-1],,1,$83,{$85/100},${86-89},$set_arg
  fi

 else
  use_shape=0
  rep_mitchell_concatenation[0--2] $start_0,$start_0,$8,$8,$12,$12,$pixels,[-1]
 fi

 rm.

fi

if $3 r $original_dimension,100%,100%,0,0,1,.5 fi

enabl_duo_opt:=$pixels>=4?2:1

cond_ini_double_concatenation:=$ini_double_concatenation_mode?2
cond_not_ini_double_concatenation:=!$ini_double_concatenation_mode?2

cond_double_concatenation:=$double_concatenation_mode?2
cond_not_double_concatenation:=!$double_concatenation_mode?2

use_foreground:=$dyn_dual_palette?(!$17?2)
use_background:=$dyn_dual_palette?($17?2)

cond_mul_img:=$multiple_images?2

act_use_shape:=$use_shape?2
enab_dyn_shape:=$use_shape==2
use_dragon_curve:=$enab_dyn_shape?$83==6?2
use_fern:=$enab_dyn_shape?$83==8?2
use_gear:=$enab_dyn_shape?$83==10?2
use_polygon:=$enab_dyn_shape?$83==20?2
use_snowflake:=$enab_dyn_shape?$83==23?2
use_star:=$enab_dyn_shape?$83==24?2

u "{$1}_"$enabl_duo_opt\
"{$2}"\
"{$3}"\
"{"$start_0"}_"$cond_not_ini_double_concatenation\
"{"$start_a"}_"$cond_ini_double_concatenation\
"{"$start_b"}_"$cond_ini_double_concatenation\
"{$7}_"$cond_ini_double_concatenation\
"{$8}_"$cond_not_ini_double_concatenation\
"{"$base_a"}_"$cond_ini_double_concatenation\
"{"$base_b"}_"$cond_ini_double_concatenation\
"{$11}_"$cond_ini_double_concatenation\
"{$12}_"$cond_not_ini_double_concatenation\
"{"$method_a"}_"$cond_ini_double_concatenation\
"{"$method_b"}_"$cond_ini_double_concatenation\
"{$15}_"$cond_ini_double_concatenation\
"{$16}_"$cond_double_concatenation\
"{$17}_"$dyn_dual_palette\
"{"$col_0_r_0","$col_0_g_0","$col_0_b_0"}_"$dyn_single_palette\
"{"$col_0_r_1","$col_0_g_1","$col_0_b_1"}_"$dyn_single_palette\
"{"$col_0_r_2","$col_0_g_2","$col_0_b_2"}_"$dyn_single_palette\
"{"$col_0_r_3","$col_0_g_3","$col_0_b_3"}_"$dyn_single_palette\
"{"$col_0_r_4","$col_0_g_4","$col_0_b_4"}_"$dyn_single_palette\
"{"$col_0_r_5","$col_0_g_5","$col_0_b_5"}_"$dyn_single_palette\
"{"$col_0_r_6","$col_0_g_6","$col_0_b_6"}_"$dyn_single_palette\
"{"$col_a_r_0","$col_a_g_0","$col_a_b_0"}_"$use_foreground\
"{"$col_a_r_1","$col_a_g_1","$col_a_b_1"}_"$use_foreground\
"{"$col_a_r_2","$col_a_g_2","$col_a_b_2"}_"$use_foreground\
"{"$col_a_r_3","$col_a_g_3","$col_a_b_3"}_"$use_foreground\
"{"$col_a_r_4","$col_a_g_4","$col_a_b_4"}_"$use_foreground\
"{"$col_a_r_5","$col_a_g_5","$col_a_b_5"}_"$use_foreground\
"{"$col_a_r_6","$col_a_g_6","$col_a_b_6"}_"$use_foreground\
"{"$col_b_r_0","$col_b_g_0","$col_b_b_0"}_"$use_background\
"{"$col_b_r_1","$col_b_g_1","$col_b_b_1"}_"$use_background\
"{"$col_b_r_2","$col_b_g_2","$col_b_b_2"}_"$use_background\
"{"$col_b_r_3","$col_b_g_3","$col_b_b_3"}_"$use_background\
"{"$col_b_r_4","$col_b_g_4","$col_b_b_4"}_"$use_background\
"{"$col_b_r_5","$col_b_g_5","$col_b_b_5"}_"$use_background\
"{"$col_b_r_6","$col_b_g_6","$col_b_b_6"}_"$use_background\
"{$81}"\
"{$82}_"$cond_not_double_concatenation\
"{$83}_"$use_shape\
"{$84}_"$cond_mul_img\
"{$85}_"$act_use_shape\
"{$86}_"$act_use_shape\
"{$87}_"$act_use_shape\
"{$88}_"$act_use_shape\
"{$89}_"$act_use_shape\
"{$90}_"$use_dragon_curve\
"{$91}_"$use_dragon_curve\
"{$92}_"$use_fern\
"{$93}_"$use_fern\
"{$94}_"$use_gear\
"{$95}_"$use_gear\
"{$96}_"$use_gear\
"{$97}_"$use_gear\
"{$98}_"$use_polygon\
"{$99}_"$use_snowflake\
"{$100}_"$use_star\
"{$101}_"$use_star\
"{$102}_"$cond_not_double_concatenation\
"{$103}_"$cond_double_concatenation\
"{$104}_"$cond_double_concatenation\
"{0}_"$cond_not_double_concatenation\
"{0}_"$cond_double_concatenation\
"{0}_"$cond_double_concatenation\
"{0}_"$cond_double_concatenation\
"{"$start_a"}"\
"{"$start_b"}"\
"{"$base_a"}"\
"{"$base_b"}"\
"{"$method_a"}"\
"{"$method_b"}"\
"{"$col_0_r_0","$col_0_g_0","$col_0_b_0"}"\
"{"$col_0_r_1","$col_0_g_1","$col_0_b_1"}"\
"{"$col_0_r_2","$col_0_g_2","$col_0_b_2"}"\
"{"$col_0_r_3","$col_0_g_3","$col_0_b_3"}"\
"{"$col_0_r_4","$col_0_g_4","$col_0_b_4"}"\
"{"$col_0_r_5","$col_0_g_5","$col_0_b_5"}"\
"{"$col_0_r_6","$col_0_g_6","$col_0_b_6"}"\
"{"$col_a_r_0","$col_a_g_0","$col_a_b_0"}"\
"{"$col_a_r_1","$col_a_g_1","$col_a_b_1"}"\
"{"$col_a_r_2","$col_a_g_2","$col_a_b_2"}"\
"{"$col_a_r_3","$col_a_g_3","$col_a_b_3"}"\
"{"$col_a_r_4","$col_a_g_4","$col_a_b_4"}"\
"{"$col_a_r_5","$col_a_g_5","$col_a_b_5"}"\
"{"$col_a_r_6","$col_a_g_6","$col_a_b_6"}"\
"{"$col_b_r_0","$col_b_g_0","$col_b_b_0"}"\
"{"$col_b_r_1","$col_b_g_1","$col_b_b_1"}"\
"{"$col_b_r_2","$col_b_g_2","$col_b_b_2"}"\
"{"$col_b_r_3","$col_b_g_3","$col_b_b_3"}"\
"{"$col_b_r_4","$col_b_g_4","$col_b_b_4"}"\
"{"$col_b_r_5","$col_b_g_5","$col_b_b_5"}"\
"{"$col_b_r_6","$col_b_g_6","$col_b_b_6"}"
#@gui Serendipitous Circle: fx_rep_serendipitous_circle,fx_rep_serendipitous_circle(0)*
#@gui:_=note("<b>Iterations</b>"),_=separator()
#@gui:Points=int(1000,10,100000)
#@gui:Repeats=int(500,10,20000)
#@gui:_=note("<b>Coefficient</b>"),_=separator()
#@gui:Coefficient A=float(2,-100,100)
#@gui:Coefficient B=float(2,-100,100)
#@gui:Use -0 for Coefficient A?=bool(0)
#@gui:Use -0 for Coefficient B?=bool(0)
#@gui:Coefficient A to 0=button()
#@gui:Coefficient B to 0=button()
#@gui:Coefficients to 0=button()
#@gui:Linked Coefficient?=bool(0)
#@gui:_=note("<b>Operators</b>"),_=separator()
#@gui:Mode A=choice(1,"Multiplication","Division")
#@gui:Mode B=choice(1,"Multiplication","Division")
#@gui:_=note("<b>Variable</b>"),_=separator()
#@gui:Use Old Mode=bool(0)
#@gui:_=note("<b>Rendering</b>"),_=separator()
#@gui:Sublevel=float(1,0,10)
#@gui:Symmetry Mode=choice(1,"Mode 0","Mode 1")
#@gui:Seed=int(0,0,1000000)
#@gui:Randomize Seed=button()
#@gui:Normalization Convolution=int(0,1,500)
#@gui:Use Exponential-Sigmoid Adjustment?=bool(1)
#@gui:Mid-Point Shift=float(.25,-1,1)
#@gui:Sigmoid-Shift=float(0,-100,100)
#@gui:Value-Shift=float(0,-1,1)
#@gui:Coefficient A=float(2,-100,100)_0
#@gui:Coefficient B=float(2,-100,100)_0
#@gui:_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2022/03/09</i>.</small>")
fx_rep_serendipitous_circle:
ow,oh={w},{h}

if $10
 coeff_a,coeff_b=${3-4}

 if !$7
  if $3!=$-2 coeff_a,coeff_b=$3 fi
  if $4!=$-1 coeff_a,coeff_b=$4 fi
 else
  coeff_a,coeff_b=0
 fi

else

 coeff_a,coeff_b=${3-4}

 if $3!=$16 coeff_a=$3 fi
 if $4!=$17 coeff_b=$4 fi
 if $7 coeff_a=0 fi
 if $8 coeff_b=0 fi

fi

if $coeff_a==0 if $5 coeff_a..=- fi fi
if $coeff_b==0 if $6 coeff_b..=- fi fi

seed={$17?round(u(0,1000000)):$16}

rep_serendipitous_circle ${1-2},$coeff_a,$coeff_b,${11-14},$seed,$18,$15

sh. 0 sh.. 1

if $19
 rep_exp_sig_adj.. ${20-22},-255
 n. 0,255
else
 n[-2,-1] 0,255
fi

rm[-2,-1]

r. $ow,$oh,100%,100%,0,0,.5,.5

u "{$1}"\
"{$2}"\
"{"$coeff_a"}"\
"{"$coeff_b"}"\
"{$5}_"{$coeff_a?1:2}\
"{$6}_"{$coeff_b?1:2}\
"{0}_"{!$10?2}\
"{0}_"{!$10?2}\
"{0}_"{$10?2}\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}"\
"{$15}"\
"{"$seed"}"\
"{0}"\
"{$18}"\
"{$19}"\
"{$20}_"{$19?2:1}\
"{$21}_"{$19?2:1}\
"{$22}_"{$19?2:1}\
"{"$coeff_a"}"\
"{"$coeff_b"}"
#@gui Vibrance [YCH]: fx_rep_vibrance_ych,fx_rep_vibrance_ych_preview
#@gui:Vibrance(%)=float(30,-100,100)
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2022/07/05</i>.</small>")
fx_rep_vibrance_ych:
rep_vibrance_ych {$1/100}
fx_rep_vibrance_ych_preview:
gui_split_preview "fx_rep_vibrance_ych $1",${-3--1}
#@gui Image Dimensions Factors:_none_,fx_find_factors_of_images_preview(1)*
#@gui:_=note("This tool is used to calculate factors of your image dimension. It is not used to change image.")
#@gui:_=separator()
#@gui:Factors Information=_text(1,"Every factors can be copied and pasted from this box")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2025/03/27</i>.</small>")
fx_find_factors_of_images_preview:
skip "$*"

if !narg($_persistent)
	repeat $!
	{
		w,h=w#$>,h#$>
		_persistent.=$sep"---Image "\#$>---\n\n
		_persistent.="Image Width Factors: "${rep_find_factors_of\ $w}\n\n
		_persistent.="Image Height Factors: "${rep_find_factors_of\ $h}\n\n
		_persistent.="Image Width and Height Factors: "${rep_find_factors_of\ $w,$h}
		sep=\n\n
	}
fi

u \{{`'$_persistent'`}\}
#@gui Detailed Information:_none_,fx_rep_detailed_info_preview(0)*
#@gui:User and Images Information=_text(1,"Every information can be found here")
#@gui:Ratio Proposition Number (0-1 disables it)=int(16,0,256)
#@gui:Ratio Proposition Number (0-1 disables it)=int(16,0,256)_0
#@gui:Multiplication of Pixels Result=value("to_be_filled")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2025/01/15</i>.</small>")
fx_rep_detailed_info_preview:
skip "$*"
contain_persistent:=narg($_persistent)
list_of_mulpixs_result=$4

if $contain_persistent&&($2==$3)
	$_persistent
	str_inform={t}
	rm.
else
	if !$contain_persistent
		list_of_mulpixs_result=${-_rep_retmulpixs}
	fi

	m __$0_mul_vars:"$""=result_ip_"
	__$0_mul_vars $list_of_mulpixs_result
	um __$0_mul_vars

	s="Host: "$_host\n"Operating System: "$_os\n"Flags: "$_flags\n"Process ID: "$_pid

	foreach {
		w,h={[w,h]}

		s.=\n\n"- Image \#"{$>+1}" -"
		s.=\n"Dimensions: "$w{`120`}$h

		a,b,true_ratio=${rep_nearest_ratio\ $w,$h,$2,1,1}

		if $true_ratio
			s.=\n"Aspect Ratio: "$a{`58`}$b
		else
			s.=\n"Aspect Ratio (Approximated): "$a{`58`}$b
			s.=\n"Error Margin for approximated ratio: "{abs(w/h-$a/$b)}
		fi

		s.=\n"Minimum Value: "{im}
		s.=\n"Maximum Value: "{iM}
		s.=\n"Average Value: "{ia}
		s.=\n"Variance Value: "{iv}
		s.=\n"Summation Value: "{is}
		s.=\n"Product Value: "${result_ip_{$>+1}}
		s.=\n"Median Value: "{ic}
		s.=\n"L2-Norm Vlaue: "{in}
	}

	('$s')
	str_inform={t}
	store. _persistent
fi

u "{"$str_inform"}""{$2}""{$2}""{"$list_of_mulpixs_result"}"
_rep_retmulpixs:
# Return multiplication of pixels per images

products=
sep=

foreach {
	if isinf(iM#-1)||isinf(im#-1)||(!isfinite(ia#-1))||isfinite(ip#-1)
		products.=$sep{ip#-1}
	else
		eval[-1] "
			begin(
				convert_to_scientific_notation(value)=(
					value?(
						current_exponent=floor(log10(abs(value)));
						current_coeff=value/(10^current_exponent);
					):(
						current_exponent=0;
						current_coeff=0;
					);
				);
				accumulate()=(
					accumulative_exponent+=current_exponent;
					t_prod=current_coeff*accumulative_coeff;
					abs(t_prod)>10?(
						t_prod=t_prod/10;
						++accumulative_exponent;
					);
					accumulative_coeff=t_prod;
				);
				accumulative_coeff=1;
				accumulative_exponent=0;
			);
			current_scientific_notation=convert_to_scientific_notation(i);
			accumulate();
			i;
			end(
				merge(accumulative_coeff,*);
				merge(accumulative_exponent,+);
				accumulative_coeff?(
					current_exponent=floor(log10(abs(accumulative_coeff)));
					accumulative_exponent+=current_exponent;
					accumulative_coeff=accumulative_coeff/(10^current_exponent);
				);
				set('accumulative_coeff',accumulative_coeff);
				set('accumulative_exponent',accumulative_exponent);
			);
			"
		if !$accumulative_coeff products.=${sep}0
		else
			products.=$sep${accumulative_coeff}e
			if $accumulative_exponent>=0 products.=+ fi
			products.=$accumulative_exponent
		fi
	fi
	sep=,
}

u $products
#@gui Lavander Binary Map:fx_rep_lavander_binary_map,fx_rep_lavander_binary_map_preview(0)*
#@gui:_=note("Based on the work of Lavander at discord/generative. Instruction on how it works is described at the bottom of this filter.")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Size of Array=choice(0,"Auto","User-Defined")
#@gui:User-Defined Size=int(8,2,14)
#@gui:Formula=choice(5,"AND-Simple","OR-Simple","XOR-Simple","AND","OR","XOR","User-Defined")
#@gui:Binary String A=text("01")
#@gui:Binary String B=text("10")
#@gui:Binary String=text("01")
#@gui:Shift Factor=int(0,0,1000000)
#@gui:Custom Formula=text{"xor(min(xor(x(),y()),xor(ix(),iy())),ix()|iy())"}
#@gui:_=separator(),_=note("<b>Additional</b>")
#@gui:TODO Direction=choice(0,"Default","Mirror-X","Mirror-Y","Mirror-XY")_0
#@gui:Symmetry=choice(0,"None","Symmetry A","Symmetry B","Symmetry C","Symmetry D")
#@gui:TODO Smooth-Shading=bool(0)_0
#@gui:Post-Process Out-Of-Bound=choice(0,"None","Periodic","Reflected")
#@gui:_=separator(),_=note("<b>Random Binary String</b>")
#@gui:Number of digits for Binary String A=int(2,1,4)
#@gui:Number of digits for Binary String B=int(2,1,4)
#@gui:Number of digits for Binary String=int(2,1,4)
#@gui:Binary String A Index=int(0,0,1)
#@gui:Binary String A Index=int(1,0,3)
#@gui:Binary String A Index=int(2,0,7)
#@gui:Binary String A Index=int(0,0,15)
#@gui:Binary String B Index=int(1,0,1)
#@gui:Binary String B Index=int(2,0,3)
#@gui:Binary String B Index=int(5,0,7)
#@gui:Binary String B Index=int(1,0,15)
#@gui:Binary String Index=int(1,0,1)
#@gui:Binary String Index=int(2,0,3)
#@gui:Binary String Index=int(5,0,7)
#@gui:Binary String Index=int(1,0,15)
#@gui:Randomize Binary String A=button()
#@gui:Randomize Binary String B=button()
#@gui:Randomize Both=button()
#@gui:Randomize=button()
#@gui:_=separator(),_=note("<b>Color</b>")
#@gui:Color Mode=choice(1,"Normalized","Colorized")
#@gui:Number of Colors=int(5,3,5)
#@gui:Color A=color(0,0,0)
#@gui:Color B=color(144,111,122)
#@gui:Color C=color(255,255,255)
#@gui:Color A=color(0,0,0)
#@gui:Color B=color(46,125,89)
#@gui:Color C=color(157,156,189)
#@gui:Color D=color(255,255,255)
#@gui:Color A=color(0,0,0)
#@gui:Color B=color(5,122,73)
#@gui:Color C=color(144,111,122)
#@gui:Color D=color(164,184,218)
#@gui:Color E=color(255,255,255)
#@gui:Recolor using changed number of color=button()
#@gui:Random Shade Exponential Factor (%)=float(0,-80,80)
#@gui:Random Lightness Start A (%)=float(0,0,100)
#@gui:Random Darkness Start B(%)=float(0,0,100)
#@gui:TODO Maximum - Lightness=_float(50,50,100)_0
#@gui:TODO Minimum - Darkness=_float(0,0,50)_0
#@gui:Random Seed Index=int(12000,0,24000)
#@gui:Randomize Colors=button()
#@gui:Recolor with current seed=button()
#@gui:Randomization Status=int(2,0,2)_0
#@gui:Previous Randomization Status=int(2,0,2)_0
#@gui:_=separator(),_=note("<b>CLI Command</b>")
#@gui:Copy-able text=_text("Input Text")
#@gui:Stored Text=_text("Restore Text")_0
#@gui:Stored Text 2=_text("Stored Text 2")_0
#@gui:Color Information=_text("Color Information")_0
#@gui:Mapping Information=_text("Mapping Information")_0
#@gui:Escape Quotation Mark=bool(0)
#@gui:_=separator(),_=note("<u><b>Custom Formula Available Macros and Variables</small></b></u>")
#@gui:_=note{"\n<b>Basic Description:</b>\n\n<u>Recommended Variables to Use</u>\n\n1 - <b>x</b>  : X-Coordinate of image\n2 - <b>y</b>  : Y-Coordinate of image\n3 - <b>ix</b> : Inverted X-Coordinate of image\n4 - <b>iy</b> : Inverted Y-Coordinate of image\n\n<u>Recommended Macros to Use</u>\n\n1 - <b>x()</b>  : Value at index X-Coordinate of image inside reference array\n2 - <b>y()</b>  : Value at index Y-Coordinate of image inside reference array\n3 - <b>ix()</b> : Value at index Inverted X-Coordinate of image inside reference array\n4 - <b>iy()</b> : Value at index Inverted X-Coordinate of image inside reference array\n\n<u>Recommended Operators to Use</u>\n\n1 - <b>xor(</b> a,b <b>)</b> : Return the value of XOR operation using a,b\n2 - a<b> & </b>b / <b>and(</b>a,b<b>)</b>: Return the AND value using a,b\n3 - a<b> | </b>b / <b>or(</b>a,b<b>)</b> : Return the OR value using a,b\n4 - <b>flip</b>(v) : Flip bits of value."}
#@gui:_=separator(),_=note("<u><b>Description of How this filter work</small></b></u>")
#@gui:_=note{"\n<b>Basic Description:</b>\n\nGenerates a image based on the count of binary number found in string of binary. Initial array contains value count-sorted by count of binary number within binary representation of integers.\n\n<b>Step:</b>\n\n1) Create an array of integer that matches index with size of 2^n.\n2) Create another array which is the count of 'bin_a' in binary representation of the previous array.\n3) Count sort the array of integer with the count of binary number array.\n4) Delete all other array other than the sorted array.\n5) Generate a surface with row and column the same size as the primary array, and use formula which takes values from the sorted value, and then find the count of 'bin_b' in binary representation of the found value.\n\n<b>Source Code: </b>\n\nAuthor: Lavander in discord/generative AKA weightt_an in discuss.pixls.us"}
#@gui:Python Source Code=_text{1,"def m_show(m, size = 4, cmap = 'afmhot'):\n    import matplotlib.pyplot as plt\n    from numpy import array\n    cmaps =  ['binary', 'gist_yarg', 'gist_gray', 'gray', 'bone',\n                'pink', 'spring', 'summer', 'autumn', 'winter', 'cool',\n                'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper']\n    plt.figure(num = None, figsize=(size, size), dpi=300)\n    plt.axis('off')\n    plot = plt.imshow(array(m), cmap = cmap) #, interpolation='bicubic' )\n    plt.show()\n    plt.close()\n\nfrom tqdm import tqdm\n\ndef get_matrix_bin(s):\n    n = len(s)\n    mat =  [[0]*n for i in range(n)]\n    for x in tqdm(range(0, n)):\n        for y in range(0, n):\n            f = format((s[x] ^ s[y]), 'b').count('10')\n            mat[x][y] = f\n            #mat[y][x] = f\n    return mat\n\nbig_n = 11\n\npows = [i for i in range(0, 2**big_n)]\npows = sorted(pows, key = lambda k: format(k, 'b').count('01'))\nadj_m = get_matrix_bin(pows)\n\nm_show(adj_m)"}
#@gui:Stored Text=_text{1,"def m_show(m, size = 4, cmap = 'afmhot'):\n    import matplotlib.pyplot as plt\n    from numpy import array\n    cmaps =  ['binary', 'gist_yarg', 'gist_gray', 'gray', 'bone',\n                'pink', 'spring', 'summer', 'autumn', 'winter', 'cool',\n                'Wistia', 'hot', 'afmhot', 'gist_heat', 'copper']\n    plt.figure(num = None, figsize=(size, size), dpi=300)\n    plt.axis('off')\n    plot = plt.imshow(array(m), cmap = cmap) #, interpolation='bicubic' )\n    plt.show()\n    plt.close()\n\nfrom tqdm import tqdm\n\ndef get_matrix_bin(s):\n    n = len(s)\n    mat =  [[0]*n for i in range(n)]\n    for x in tqdm(range(0, n)):\n        for y in range(0, n):\n            f = format((s[x] ^ s[y]), 'b').count('10')\n            mat[x][y] = f\n            #mat[y][x] = f\n    return mat\n\nbig_n = 11\n\npows = [i for i in range(0, 2**big_n)]\npows = sorted(pows, key = lambda k: format(k, 'b').count('01'))\nadj_m = get_matrix_bin(pows)\n\nm_show(adj_m)"}_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2023/03/21</i>.</small>")
#@gui:Started?=bool(0)_0
#@gui:Size of Array=choice(0,"Auto","User-Defined")_0
#@gui:Formula=choice(2,"AND-Simple","OR-Simple","XOR-Simple","AND","OR","XOR","User-Defined")_0
#@gui:Binary String A=text("01")_0
#@gui:Binary String B=text("10")_0
#@gui:Binary String=text("01")_0
#@gui:Binary String A Index=int(0,0,1)_0
#@gui:Binary String A Index=int(1,0,3)_0
#@gui:Binary String A Index=int(2,0,7)_0
#@gui:Binary String A Index=int(0,0,15)_0
#@gui:Binary String B Index=int(1,0,1)_0
#@gui:Binary String B Index=int(2,0,3)_0
#@gui:Binary String B Index=int(5,0,7)_0
#@gui:Binary String B Index=int(1,0,15)_0
#@gui:Binary String Index=int(1,0,1)_0
#@gui:Binary String Index=int(2,0,3)_0
#@gui:Binary String Index=int(5,0,7)_0
#@gui:Binary String Index=int(1,0,15)_0
#@gui:Shift Factor=int(0,0,1000000)_0
#@gui:Custom Formula=text{"xor(min(xor(x(),y()),xor(ix(),iy())),ix()|iy())"}_0
#@gui:TODO Direction=choice(0,"Default","Mirror-X","Mirror-Y","Mirror-XY")_0_0
#@gui:Symmetry=choice(0,"None","Symmetry A","Symmetry B","Symmetry C","Symmetry D")_0
#@gui:TODO Smooth-Shading=bool(0)_0
#@gui:User-Defined Size=int(8,2,14)_0
#@gui:Size of Image=int(8,2,14)_0
#@gui:Auto-Size of Image=int(0,0,14)_0
#@gui:Auto-Size of Symmetric Image=int(0,0,14)_0
#@gui:Color Mode=choice(1,"Normalized","Colorized")_0
#@gui:Number of Colors=int(5,3,5)_0
#@gui:Color A=color(0,0,0)_0
#@gui:Color B=color(144,111,122)_0
#@gui:Color C=color(255,255,255)_0
#@gui:Color A=color(0,0,0)_0
#@gui:Color B=color(46,125,89)_0
#@gui:Color C=color(157,156,189)_0
#@gui:Color D=color(255,255,255)_0
#@gui:Color A=color(0,0,0)_0
#@gui:Color B=color(5,122,73)_0
#@gui:Color C=color(144,111,122)_0
#@gui:Color D=color(164,184,218)_0
#@gui:Color E=color(255,255,255)_0
#@gui:Random Shade Exponential Factor (%)=_float(0,-80,80)_0
#@gui:Random Lightness Start A (%)=_float(0,0,100)_0
#@gui:Random Darkness Start B(%)=_float(0,0,100)_0
#@gui:TODO Maximum - Lightness=_float(50,50,100)_0
#@gui:TODO Minimum - Darkness=_float(0,0,50)_0
#@gui:Random Seed Index=int(12000,0,24000)_0
#@gui:TODO Has Activated Smooth?-Shade=bool(0)_0
fx_rep_lavander_binary_map:
skip "$*"

img_width,img_height={[w#0,h#0]}

if !narg($_persistent)
	error uninitialized
fi

$_persistent
keep[output]

if !$1&&$12
	resize $img_width,$img_height,100%,100%,0,{$12+1},.5,.5
fi
fx_rep_lavander_binary_map_preview:
skip "$*"

n0,n1,I0,I1,I2={'01'},a,b,c
started,use_persistent,max_img_ind,timg,neq_form,color_mode_change,cont_base_map,ind_col_change,previous_status_of_random,previous_state_of_symmetry,current_num_of_colors,_num_of_colors=$89,{narg($_persistent)?1},{[$!-1,$!]},0,{$32?($32!=$116?1:0):($32!=$116)},0,0,$80,$110,$117,$33

status_of_random={$32?$previous_status_of_random}

seed_change={$76!=$159}
act_rand_map={$32?(($status_of_random==2?$78)||$seed_change||$77)}
previous_shade,previous_lightness,previous_darkness=${154-156}

cli_command_text="$82"
cli_command_text_with_slash={/"$83"}
_color_info="$84"
mapping_info={/"$85"}

_fx_rep_lavander_binary_map_seed={$77?v(24000):$76}

if !narg($_persistent) started=0 fi

if $70||$77||$78 _num_of_colors=$33 fi

if $act_rand_map
	command "fx_rep_lavander_binary_map_create_palette:
		$_num_of_colors,1,1,3,\"begin(
			srand($_fx_rep_lavander_binary_map_seed);
			const max_index=w-1;
			const half_max_index=max_index>>1;

			const expf=1-abs($71)/100;
			const rand_light=$72%;
			const rand_dark=$73%;

			rand_dark||rand_light?(
				v_shade=expr('begin(srand($_fx_rep_lavander_binary_map_seed));u(1)',w);
			);

			rand_dark&&rand_light?(
				gen_base_shade()=x>half_max_index?lerp(0,1,lerp(x/max_index,v_shade[x],rand_light)):lerp(0,1,lerp(x/max_index,v_shade[x],rand_dark));
			):
			rand_light?(
				gen_base_shade()=x>half_max_index?lerp(0,1,lerp(x/max_index,v_shade[x],rand_light)):lerp(0,1,x/max_index);
			):
			rand_dark?(
				gen_base_shade()=x>half_max_index?lerp(0,1,x/max_index):lerp(0,1,lerp(x/max_index,v_shade[x],rand_dark));
			):(
				gen_base_shade()=lerp(0,1,x/max_index);
			);

			$71?(
				$71<0?(
					gen_shade()=1-(1-gen_base_shade())^expf;
				):(
					gen_shade()=gen_base_shade()^expf;
				);
			):(
				gen_shade()=gen_base_shade();
			);

		);
		shade=gen_shade();
		[u(360),u(1),shade];
		\"

	hsl2rgb.

	if $_num_of_colors==5
		_color_info=({round(I(#-1,0))};{round(I(#-1,1))};{round(I(#-1,2))};{round(I(#-1,3))};{round(I(#-1,4))})
	elif $_num_of_colors==4
		_color_info=({round(I(#-1,0))};{round(I(#-1,1))};{round(I(#-1,2))};{round(I(#-1,3))})
	elif $_num_of_colors==3
		_color_info=({round(I(#-1,0))};{round(I(#-1,1))};{round(I(#-1,2))})
	fi
   "
else

	if $32

		if $_num_of_colors==5
			_color_info=(${55-57};${58-60};${61-63};${64-66};${67-69})
		elif $_num_of_colors==4
			_color_info=(${43-45};${46-48};${49-51};${52-54})
		elif $_num_of_colors==3
			_color_info=(${34-36};${37-39};${40-42})
		fi

		command fx_rep_lavander_binary_map_create_palette:$_color_info

	else
		command "fx_rep_lavander_binary_map_create_palette: 0"
	fi

fi

img_width,img_height={[w#0,h#0]}

color_0_0_r,color_0_0_g,color_0_0_b,\
color_0_1_r,color_0_1_g,color_0_1_b,\
color_0_2_r,color_0_2_g,color_0_2_b,\
color_1_0_r,color_1_0_g,color_1_0_b,\
color_1_1_r,color_1_1_g,color_1_1_b,\
color_1_2_r,color_1_2_g,color_1_2_b,\
color_1_3_r,color_1_3_g,color_1_3_b,\
color_2_0_r,color_2_0_g,color_2_0_b,\
color_2_1_r,color_2_1_g,color_2_1_b,\
color_2_2_r,color_2_2_g,color_2_2_b,\
color_2_3_r,color_2_3_g,color_2_3_b,\
color_2_4_r,color_2_4_g,color_2_4_b,\
old_color_0_0_r,old_color_0_0_g,old_color_0_0_b,\
old_color_0_1_r,old_color_0_1_g,old_color_0_1_b,\
old_color_0_2_r,old_color_0_2_g,old_color_0_2_b,\
old_color_1_0_r,old_color_1_0_g,old_color_1_0_b,\
old_color_1_1_r,old_color_1_1_g,old_color_1_1_b,\
old_color_1_2_r,old_color_1_2_g,old_color_1_2_b,\
old_color_1_3_r,old_color_1_3_g,old_color_1_3_b,\
old_color_2_0_r,old_color_2_0_g,old_color_2_0_b,\
old_color_2_1_r,old_color_2_1_g,old_color_2_1_b,\
old_color_2_2_r,old_color_2_2_g,old_color_2_2_b,\
old_color_2_3_r,old_color_2_3_g,old_color_2_3_b,\
old_color_2_4_r,old_color_2_4_g,old_color_2_4_b\
=${34-69},${118-153}

if ($32?([${34-69}]!=[${118-153}]))||$70
	status_of_random=2
	color_mode_change=1
	_num_of_colors=$33
	ind_col_change=1
fi

if $act_rand_map
	color_mode_change=1
	status_of_random=1
	_num_of_colors=$33
	previous_shade,previous_lightness,previous_darkness=${71-73}
fi

if $32?([${71-73}]!=[$previous_shade,$previous_lightness,$previous_darkness])||($33!=$_num_of_colors)
	status_of_random=2
fi

if $32
	previous_status_of_random=$status_of_random
fi

if !$started||!narg($_persistent)||!$114
	auto_size,auto_size_sym={v=int(log2(min($img_width,$img_height)));[v,v-1]}
else
	auto_size,auto_size_sym={[$114,$115]}
fi

if $1
	if $1&&!$90
		pw2size,user_defined_size=$112
	else
		pw2size,user_defined_size=$2
	fi
elif !$started
	user_defined_size,pw2size=$auto_size
else
	pw2size={$10?$auto_size_sym:$auto_size}
	user_defined_size=$112
fi

size_changed={$pw2size!=$113}

bin_a,bin_b,bin_c="$4","$5","$6"

repeat 3 {
	if v='${bin_${I$>}}';max(v)>$n1||min(v)<$n0
		error inv_bin_str_${I$>}
	fi
}

bin_a_size,bin_b_size,bin_c_size,neq_bin_a,neq_bin_b,neq_bin_c={bin_a='$4';bin_b='$5';bin_c='$6';[size(bin_a),size(bin_b),size(bin_c),bin_a!='$92',bin_b!='$93',bin_c!='$94']}
neq_bin={$neq_bin_a||$neq_bin_b||$neq_bin_c}

repeat 3 {
	if !${bin_${I$>}_size} error absen_bin_${I$>} fi
	if ${bin_${I$>}_size}>4 error exces_bin_${I$>} fi
}

num_of_rand_bin_a_digits,num_of_rand_bin_b_digits,num_of_rand_bin_c_digits,\
binary_string_a_ind_0,binary_string_a_ind_1,binary_string_a_ind_2,binary_string_a_ind_3,\
binary_string_b_ind_0,binary_string_b_ind_1,binary_string_b_ind_2,binary_string_b_ind_3,\
binary_string_c_ind_0,binary_string_c_ind_1,binary_string_c_ind_2,binary_string_c_ind_3\
=${13-27}

if $28||$29||$30||$31

	if $28||$30

		if $num_of_rand_bin_a_digits==1
			bin_a,binary_string_a_ind_0={!$binary_string_a_ind_0}
		else
			index=${arg1\ $num_of_rand_bin_a_digits,${16-19}}
			binary_string_a_ind_{$num_of_rand_bin_a_digits-1},temp={a=v(0,1<<$num_of_rand_bin_a_digits,1,0);a==$index?(a+1)%(1<<$num_of_rand_bin_a_digits):a;}
			(${rep_r_permutation_index2list\ 2,$num_of_rand_bin_a_digits,$temp})
			+. $n0
			bin_a={t}
			rm.
		fi

	fi

	if $29||$30

		if $num_of_rand_bin_b_digits==1
			bin_b,binary_string_b_ind_0={!$binary_string_b_ind_0}
		else
			index=${arg1\ $num_of_rand_bin_b_digits,${20-23}}
			binary_string_b_ind_{$num_of_rand_bin_b_digits-1},temp={b=v(0,1<<$num_of_rand_bin_b_digits,1,0);b==$index?(b+1)%(1<<$num_of_rand_bin_b_digits):b;}
			(${rep_r_permutation_index2list\ 2,$num_of_rand_bin_b_digits,$temp})
			+. $n0
			bin_b={t}
			rm.
		fi

	fi

	if $31

		if $num_of_rand_bin_c_digits==1
			bin_c,binary_string_c_ind_0={!$binary_string_c_ind_0}
		else
			index=${arg1\ $num_of_rand_bin_c_digits,${24-27}}
			binary_string_c_ind_{$num_of_rand_bin_c_digits-1},temp={c=v(0,1<<$num_of_rand_bin_c_digits,1,0);c==$index?(c+1)%(1<<$num_of_rand_bin_c_digits):c;}
			(${rep_r_permutation_index2list\ 2,$num_of_rand_bin_c_digits,$temp})
			+. $n0
			bin_c={t}
			rm.
		fi

	fi

	neq_bin:=('$bin_a'!='$92')||('$bin_b'!='$93')||('$bin_c'!='$94')

elif $neq_bin
	repeat 3 {
		I=${I$>}
		if ${neq_bin_$I}
			num_of_rand_bin_${I}_digits=${bin_${I}_size}
			binary_string_${I}_ind_{${num_of_rand_bin_${I}_digits}-1}=${rep_r_permutation_list2index\ 2,{['${bin_$I}']-$n0}}
		fi
	}
else

	if $started&&([${16-27}]!=[${95-106}])

		$=arg_pos_

		if $3>2

			repeat 8 {

				left_arg=${arg_pos_{$>+16}}
				right_arg=${arg_pos_{$>+95}}

				ab_pos,bin_group_pos={[int($>/4),$>%4]}

				a_b=${arg0\ $ab_pos,a,b}
				num_of_digits={$bin_group_pos+1}

				if !$bin_group_pos

					if $left_arg!=$right_arg
						num_of_rand_bin_$a_b"_digits"=$num_of_digits
						bin_$a_b,binary_string_$a_b"_ind_"$bin_group_pos=$left_arg
						neq_bin=1
						break
					fi

				else

					if $left_arg!=$right_arg
						(${rep_r_permutation_index2list\ 2,$num_of_digits,$left_arg})
						+. $n0
						bin_$a_b={t}
						num_of_rand_bin_$a_b"_digits"=$num_of_digits
						binary_string$a_b"_ind_"$bin_group_pos=$left_arg
						neq_bin=1
						rm.
						break
					fi

				fi

			}

		else

			repeat 4 {

				left_arg=${arg_pos_{$>+24}}
				right_arg=${arg_pos_{$>+103}}
				num_of_digits={$>+1}

				if $left_arg!=$right_arg
					(${rep_r_permutation_index2list\ 2,$num_of_digits,$left_arg})
					+. $n0
					bin_c={t}
					num_of_rand_bin_c_digits=$num_of_digits
					binary_string_c_ind_$>=$left_arg
					neq_bin=1
					rm.
					break
				fi

			}

		fi

	elif !$started

		repeat 3 {
			I=${I$>}
			num_of_rand_bin_${I}_digits=${bin_${I}_size}
			binary_string_${I}_ind_{${num_of_rand_bin_${I}_digits}-1}=${rep_r_permutation_list2index\ 2,{['${bin_$I}']-$n0}}
		}

	fi

fi

form_b=$108

if $3==6
	neq_form:='$8'!='$108'
	form_b=$8
fi

switch_use_sym={($10?1)!=($110?1)}
act_sym_switch={$10!=$110}
sym_mode={$switch_use_sym||$act_sym_switch}

if ([$3,$7]!=[$91,$107])||$neq_form||$neq_bin||$size_changed||!$started
	use_persistent,color_mode_change={[0,1]}

	if $3<6
		formula_mode={$3>2?$3-3:-($3+1)}
	else
		formula_mode=-
	fi

	if $3>2
		+rep_lavander_binary_map $pw2size,$formula_mode,$bin_a,$bin_b,$7,"$8" => base_map
		base_cli_command="+rep_lavander_binary_map "$pw2size,$formula_mode,$bin_a,$bin_b,$7,
	else
		+rep_lavander_binary_map $pw2size,$formula_mode,$bin_c,,$7,"$8" => base_map
		base_cli_command="+rep_lavander_binary_map "$pw2size,$formula_mode,$bin_c,,$7,
	fi

	cli_command_text=$base_cli_command\"$8\"
	cli_command_text_with_slash=$base_cli_command{`92`}\"$8{`92`}\"

	keep[base_map]

	if $10
		rep_symmetrize_xy {$10-1} => base_map
	fi

	cont_base_map=1

	if $sym_mode
		sym_mode=0
	fi
fi

if $sym_mode
	use_persistent=0

	if $110?$10&&$110:$10
		$_persistent
		keep[-2,-1]

		if $110
			eval "
				const pw2size=1<<$pw2size;
				const dec_pw2size=pw2size-1;
				const pos=max(0,$110-1);
				init_v=[1,pw2size]-1;
				off_x=pos%3?dec_pw2size;
				off_y=pos&1?dec_pw2size;
				xc=init_v+off_x;
				yc=init_v+off_y;
				[xc[0],yc[0],xc[1],yc[1]];
				"
			crop[-2,-1] ${}
		fi
	else
		eval "
			const pw2size=1<<$pw2size;
			const dec_pw2size=pw2size-1;
			const pos=max(0,$110)-1;
			init_v=[1,pw2size]-1;
			off_x=pos%3?dec_pw2size;
			off_y=pos&1?dec_pw2size;
			xc=init_v+off_x;
			yc=init_v+off_y;
			[xc[0],yc[0],xc[1],yc[1]];
			"

		$_persistent
		keep[-2,-1]
		crop[-2,-1] ${}
	fi

	if $10
		rep_symmetrize_xy {$10-1}
	fi

	name[-2,-1] base_map,output
	+store[-2,-1] _persistent

	keep[output]

	if !$1&&$12
		resize $img_width,$img_height,100%,100%,0,{$12+1},.5,.5
	fi
fi

if $color_mode_change
	use_persistent=0

	if !$cont_base_map
		if narg($_persistent)
			$_persistent
			keep[base_map]
		fi
	fi

	size_val_arr_base_map={iM#$base_map+1}

	if $32

		current_num_of_colors=$_num_of_colors

		mi={$_num_of_colors-1}

		fx_rep_lavander_binary_map_create_palette => ref_col

		if $_num_of_colors==5
			3,1,1,1
			4,1,1,1
		elif $_num_of_colors==4
			3,1,1,1
			5,1,1,1
		elif $_num_of_colors==3
			4,1,1,1
			5,1,1,1
		fi

		if !$act_rand_map
			permute[-3] yzcx
		fi

		f[-2--1] lerp(0,$mi,x/(w-1))
		rep_cubic_map[-2--1] [-3]
		sort_list[-3--1] +,w

		$size_val_arr_base_map,1,1,1,lerp(0,$mi,x/(w-1))
		rep_cubic_map[-1] [ref_col]

		+map[base_map] [-1] rm.. => output
		+store[$base_map,-1] _persistent

		a[-4--2] x
		round..
		cut.. 0,255
		permute[-2] cxyz

		color_0_0_r,color_0_0_g,color_0_0_b,\
		color_0_1_r,color_0_1_g,color_0_1_b,\
		color_0_2_r,color_0_2_g,color_0_2_b,\
		color_1_0_r,color_1_0_g,color_1_0_b,\
		color_1_1_r,color_1_1_g,color_1_1_b,\
		color_1_2_r,color_1_2_g,color_1_2_b,\
		color_1_3_r,color_1_3_g,color_1_3_b,\
		color_2_0_r,color_2_0_g,color_2_0_b,\
		color_2_1_r,color_2_1_g,color_2_1_b,\
		color_2_2_r,color_2_2_g,color_2_2_b,\
		color_2_3_r,color_2_3_g,color_2_3_b,\
		color_2_4_r,color_2_4_g,color_2_4_b\
		={crop(#-2)}

		old_color_0_0_r,old_color_0_0_g,old_color_0_0_b,\
		old_color_0_1_r,old_color_0_1_g,old_color_0_1_b,\
		old_color_0_2_r,old_color_0_2_g,old_color_0_2_b,\
		old_color_1_0_r,old_color_1_0_g,old_color_1_0_b,\
		old_color_1_1_r,old_color_1_1_g,old_color_1_1_b,\
		old_color_1_2_r,old_color_1_2_g,old_color_1_2_b,\
		old_color_1_3_r,old_color_1_3_g,old_color_1_3_b,\
		old_color_2_0_r,old_color_2_0_g,old_color_2_0_b,\
		old_color_2_1_r,old_color_2_1_g,old_color_2_1_b,\
		old_color_2_2_r,old_color_2_2_g,old_color_2_2_b,\
		old_color_2_3_r,old_color_2_3_g,old_color_2_3_b,\
		old_color_2_4_r,old_color_2_4_g,old_color_2_4_b\
		={crop(#-2)}

		if $32!=$116||!$started
			mapping_info=" "{`123`}iM+1{`125`},1,1,1,lerp(0,{`123`}w#-2-1{`125`},x/(w-1))" "rep_cubic_map[-1]" "[-3]" "map[-2]" "[-1]" "rm[-3,-1]
		fi

	else
		+n. 0,255 => output
		+store[-2,-1] _persistent
		mapping_info=" n[-1] 0,255"
	fi

	keep[output]

	if !$1&&$12
		resize $img_width,$img_height,100%,100%,0,{$12+1},.5,.5
	fi
fi

if $use_persistent
	$_persistent
	keep[output]

	if !$1&&$12
		resize $img_width,$img_height,100%,100%,0,{$12+1},.5,.5
	fi
fi

uncommand fx_rep_lavander_binary_map_create_palette

if $86
	selectable_cli_command_text=$cli_command_text_with_slash
else
	selectable_cli_command_text=$cli_command_text
fi

if $10
	selectable_cli_command_text.=" rep_symmetrize_xy[-1] "{$10-1}
fi

if $32
	selectable_cli_command_text..=$_color_info" permute[-1] yzcx "
fi

selectable_cli_command_text.=$mapping_info

u "{$1}"\
 "{"$pw2size"}_"{$1+1}\
 "{$3}"\
 "{"$bin_a"}_"{$3>2?2}\
 "{"$bin_b"}_"{$3>2?2}\
 "{"$bin_c"}_"{$3<3?2}\
 "{$7}"\
 "{$8}_"{($3==6)+1}\
 "{$9}"\
 "{$10}"\
 "{$11}"\
 "{$12}_"{!$1*2}\
 "{"$num_of_rand_bin_a_digits"}_"{$3>2?2}\
 "{"$num_of_rand_bin_b_digits"}_"{$3>2?2}\
 "{"$num_of_rand_bin_c_digits"}_"{$3<3?2}\
 "{"$binary_string_a_ind_0"}_"{$3>2?$num_of_rand_bin_a_digits==1?2}\
 "{"$binary_string_a_ind_1"}_"{$3>2?$num_of_rand_bin_a_digits==2?2}\
 "{"$binary_string_a_ind_2"}_"{$3>2?$num_of_rand_bin_a_digits==3?2}\
 "{"$binary_string_a_ind_3"}_"{$3>2?$num_of_rand_bin_a_digits==4?2}\
 "{"$binary_string_b_ind_0"}_"{$3>2?$num_of_rand_bin_b_digits==1?2}\
 "{"$binary_string_b_ind_1"}_"{$3>2?$num_of_rand_bin_b_digits==2?2}\
 "{"$binary_string_b_ind_2"}_"{$3>2?$num_of_rand_bin_b_digits==3?2}\
 "{"$binary_string_b_ind_3"}_"{$3>2?$num_of_rand_bin_b_digits==4?2}\
 "{"$binary_string_c_ind_0"}_"{$3<3?$num_of_rand_bin_c_digits==1?2}\
 "{"$binary_string_c_ind_1"}_"{$3<3?$num_of_rand_bin_c_digits==2?2}\
 "{"$binary_string_c_ind_2"}_"{$3<3?$num_of_rand_bin_c_digits==3?2}\
 "{"$binary_string_c_ind_3"}_"{$3<3?$num_of_rand_bin_c_digits==4?2}\
 "{0}_"{$3>2?2}\
 "{0}_"{$3>2?2}\
 "{0}_"{$3>2?2}\
 "{0}_"{$3<3?2}\
 "{$32}"\
 "{$33}_"{$32?2}\
 "{"$color_0_0_r","$color_0_0_g","$color_0_0_b"}_"{$32?($33==3?2)}\
 "{"$color_0_1_r","$color_0_1_g","$color_0_1_b"}_"{$32?($33==3?2)}\
 "{"$color_0_2_r","$color_0_2_g","$color_0_2_b"}_"{$32?($33==3?2)}\
 "{"$color_1_0_r","$color_1_0_g","$color_1_0_b"}_"{$32?($33==4?2)}\
 "{"$color_1_1_r","$color_1_1_g","$color_1_1_b"}_"{$32?($33==4?2)}\
 "{"$color_1_2_r","$color_1_2_g","$color_1_2_b"}_"{$32?($33==4?2)}\
 "{"$color_1_3_r","$color_1_3_g","$color_1_3_b"}_"{$32?($33==4?2)}\
 "{"$color_2_0_r","$color_2_0_g","$color_2_0_b"}_"{$32?($33==5?2)}\
 "{"$color_2_1_r","$color_2_1_g","$color_2_1_b"}_"{$32?($33==5?2)}\
 "{"$color_2_2_r","$color_2_2_g","$color_2_2_b"}_"{$32?($33==5?2)}\
 "{"$color_2_3_r","$color_2_3_g","$color_2_3_b"}_"{$32?($33==5?2)}\
 "{"$color_2_4_r","$color_2_4_g","$color_2_4_b"}_"{$32?($33==5?2)}\
 "{0}_"{$32?(($33!=$current_num_of_colors)+1)}\
 "{$71}_"{$32?2}\
 "{$72}_"{$32?2}\
 "{$73}_"{$32?2}\
 "{$74}"\
 "{$75}"\
 "{"$_fx_rep_lavander_binary_map_seed"}_"{$32?2}\
 "{0}_"{$32?2}\
 "{0}_"{$32?$status_of_random}\
 "{"$status_of_random"}"\
 "{"$previous_status_of_random"}"\
 "{"$selectable_cli_command_text"}"\
 "{"$cli_command_text"}"\
 "{"$cli_command_text_with_slash"}"\
 "{"$_color_info"}"\
 "{"$mapping_info"}"\
 "{$86}"\
 "{$88}"\
 "{$88}"\
 "{1}"\
 "{$1}"\
 "{$3}"\
 "{"$bin_a"}"\
 "{"$bin_b"}"\
 "{"$bin_c"}"\
 "{"$binary_string_a_ind_0"}"\
 "{"$binary_string_a_ind_1"}"\
 "{"$binary_string_a_ind_2"}"\
 "{"$binary_string_a_ind_3"}"\
 "{"$binary_string_b_ind_0"}"\
 "{"$binary_string_b_ind_1"}"\
 "{"$binary_string_b_ind_2"}"\
 "{"$binary_string_b_ind_3"}"\
 "{"$binary_string_c_ind_0"}"\
 "{"$binary_string_c_ind_1"}"\
 "{"$binary_string_c_ind_2"}"\
 "{"$binary_string_c_ind_3"}"\
 "{$7}"\
 "{"$form_b"}"\
 "{$9}"\
 "{$10}"\
 "{$111}"\
 "{"$user_defined_size"}"\
 "{"$pw2size"}"\
 "{"$auto_size"}"\
 "{"$auto_size_sym"}"\
 "{$32}"\
 "{"$current_num_of_colors"}"\
 "{"$old_color_0_0_r","$old_color_0_0_g","$old_color_0_0_b"}"\
 "{"$old_color_0_1_r","$old_color_0_1_g","$old_color_0_1_b"}"\
 "{"$old_color_0_2_r","$old_color_0_2_g","$old_color_0_2_b"}"\
 "{"$old_color_1_0_r","$old_color_1_0_g","$old_color_1_0_b"}"\
 "{"$old_color_1_1_r","$old_color_1_1_g","$old_color_1_1_b"}"\
 "{"$old_color_1_2_r","$old_color_1_2_g","$old_color_1_2_b"}"\
 "{"$old_color_1_3_r","$old_color_1_3_g","$old_color_1_3_b"}"\
 "{"$old_color_2_0_r","$old_color_2_0_g","$old_color_2_0_b"}"\
 "{"$old_color_2_1_r","$old_color_2_1_g","$old_color_2_1_b"}"\
 "{"$old_color_2_2_r","$old_color_2_2_g","$old_color_2_2_b"}"\
 "{"$old_color_2_3_r","$old_color_2_3_g","$old_color_2_3_b"}"\
 "{"$old_color_2_4_r","$old_color_2_4_g","$old_color_2_4_b"}"\
 "{"$previous_shade"}"\
 "{"$previous_lightness"}"\
 "{"$previous_darkness"}"\
 "{$157}"\
 "{$158}"\
 "{"$_fx_rep_lavander_binary_map_seed"}"\
 "{$160}"
#@gui Red Acrylic Plastic Filter:fx_rep_red_acrylic_filter,fx_rep_red_acrylic_filter_preview(1):+
#@gui:_=note("This generates image in which you use red acrylic plastic cover in order to reveal a image.\n\nThis filter require multiple images.")
#@gui:_=separator(),_=note("<b>Initial</b>")
#@gui:Use Imported Image?=bool(0)
#@gui:Image Location=file()
#@gui:Use Reference Layer=bool(0)
#@gui:Reference Layer=choice(0,"Top","Bottom")
#@gui:_=separator(),_=note("<b>Effect</b>")
#@gui:Luminosity Blend=float(0,0,100)
#@gui:Green Cut Point=float(0,0,100)
#@gui:Green Visibility=float(100,0,100)
#@gui:Use Imported Image?=bool(0)_0
#@gui:Image Location=file()_0
#@gui:Use Reference Layer=bool(0)_0
#@gui:Reference Layer=choice(0,"Top","Bottom")_0
#@gui:Luminosity Blend=float(0,0,100)_0
#@gui:Green Cut Point=float(0,0,100)_0
#@gui:Green Visibility=float(100,0,100)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2022/09/12</i>.</small>")
fx_rep_red_acrylic_filter:
skip "${2=}","${9=}"

n_images,\
cond_import_image,cond_refer_image,\
ref_image_id,luma_fact,verd_green_min_pt,verd_green_visil,\
previo_cond_import_image,previo_cond_refer_image,\
previo_ref_image_id,previo_luma_fact,previo_verd_green_min_pt,previo_verd_green_visil\
={$!},$1,${3-8},${10-14}

args:=[$luma_fact,$verd_green_min_pt,$verd_green_visil]/100

if $cond_import_image

 if narg("$2")
  image_loc="$2"
  previo_image_loc="$9"

  if !narg($_persistent)||('$image_loc'!='$previo_image_loc') i $image_loc +store. _persistent
  else $_persistent
  fi

  rep_red_acrylic_filter[0--2] [-1],$args
  rm[-1]
 fi

else

 if $n_images&1||$cond_refer_image
  if $ref_image_id rep_red_acrylic_filter[0--2] [-1],$args
  else             rep_red_acrylic_filter[1--1] [0],$args
  fi
 else
  rv rep_red_acrylic_filter ,$args
 fi

fi
fx_rep_red_acrylic_filter_preview:
skip "${2=}","${9=}"

n_images:=$!

fx_rep_red_acrylic_filter $*

u "{$1}"\
"{$2}_"{$1?2:1}\
"{$3}_"{!$1?2}\
"{$4}_"{!$1?$n_images&1||$1?2}\
"{$5}"\
"{$6}"\
"{$7}"\
"{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"
#@gui Tupper's Self-Referential Formula:fx_rep_self_referential_formula,fx_rep_self_referential_formula_preview(1)*
#@gui:_=note("This filter is to be seen as a showcase filter.\n\n<b>Note</b> - To get the most feature of this filter, you must use a single image of size 106x17.\n\n<b>Warning!</b> - Do not use on images that are not much larger than 300x300. Due to the lack of BIGINT support inside G'MIC, the implementation is quite slow.")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Mode=choice(1,"Generate Image from K","Find K from Images")
#@gui:Mode=choice(1,"Generate Image from K","Find K from Images")_0
#@gui:K Input=choice(0,"User","Tupper's Self-Referential Formula","Euler's Identity","Pacman","Sick App Bro! - Daves")
#@gui:K Input=choice(0,"User","Tupper's Self-Referential Formula","Euler's Identity","Pacman","Sick App Bro! - Daves")_0
#@gui:K Value=text(1,"0")
#@gui:K Value=text("0")_0
#@gui:Predefined K value=text(1,"0")
#@gui:Predefined K value=text("0")_0
#@gui:Copy from Stored K Value=button()
#@gui:Negate after using K-Input result?=bool(1)
#@gui:Negate after using K-Input result?=bool(1)_0
#@gui:K Values from Image(s)=text(1,"1")
#@gui:Stored K value(s) from Images=text(1,"1")_0
#@gui:Pre-Negation?=bool(1)
#@gui:Pre-Negation?=bool(1)_0
#@gui:Allow Examples=bool(1)_0
#@gui:Allow Mode Switch?=bool(1)_0
#@gui:Started=bool(0)_0
#@gui:_=separator(),_=note("<b><u>Details</u></b>")
#@gui:_=note("Tupper's Self Referential Formula refers to a formula which refers to itself when a specific value is assigned. This was founded by Jeff Tupper.\n\nK Values for pre-defined K Inputs are based from <a href="https://keelyhill.github.io/tuppers-formula/">Tupper's Self-Referential Formula Playground</a> and <a href="http://campus.lakeforest.edu/trevino/Tupper_Paper.pdf">Tupper Paper</a> by Margaret Fortman.")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2023/01/19</i>.</small>")
fx_rep_self_referential_formula:
skip "$*" rm $_persistent

if $1 remove_named tuppers_image_mode_0
else remove_named tuppers_self_image_base keep[0]
fi

* 255
fx_rep_self_referential_formula_preview:
skip "$*"

mode_K_a=$1
mode_K_b=$2

k_a=$5
k_b=$6

predefined_K=$8

copy_from_stored_value=$9
negate_after_using_k_input_a=$10
negate_after_using_k_input_b=$11

k_value_from_images="$13"
pre_negation_a=$14
pre_negation_b=$15
allow_example=$16
allow_mode_switch=$17
started=$18

user_mode_a={$allow_example?$3}
user_mode_b={$allow_example?$4}

mode_K_diff,\
K_diff,\
negate_after_K_input_diff,\
user_diff,\
pre_negation_diff,\
copy_from_stored_K_value\
={[$mode_K_a!=$mode_K_b,'$k_a'!='$k_b',$negate_after_using_k_input_a!=$negate_after_using_k_input_b,$user_mode_a!=$user_mode_b,$pre_negation_a!=$pre_negation_b,$9]}

activate_changes={$mode_K_a?$pre_negation_diff:($mode_K_diff||$K_diff||$negate_after_K_input_diff||$user_diff||$copy_from_stored_K_value)}

if $started&&narg($_persistent)
	if $activate_changes
		if $mode_K_a
			rm $_persistent
			rep_tuppers_self_K[tuppers_self_image_base] $pre_negation_a
			store _persistent

			('${}')

			if !$allow_mode_switch
				replace_str ",","\n\n"
			fi

			k_value_from_images={t}
			rm
		else
			if $negate_after_K_input_diff
				rm $_persistent
				negate[tuppers_image_mode_0]
				store _persistent
			else
				width,height={[w,h]}
				rm $_persistent
				store temporary_image
				$width,$height

				if $user_diff||$mode_K_diff
					if $user_mode_a
						predefined_K=${arg1\ $user_mode_a,960939379918958884971672962127852754715004339660129306651505519271702802395266424689642842174350718121267153782770623355993237280874144307891325963941337723487857735749823926629715517173716995165232890538221612403238855866184013235585136048828693337902491454229288667081096184496091705183454067827731551705405381627380967602565625016981482083418783163849115590225610003652351370343874461848378737238198224849863465033159410054974700593138339226497249461751545728366702369745461014655997933798537483143786841806593422227898388722980000748404719,395237837253173619377196292693949302406153931873024916260538490717335936871532361396117451541392229602948889604348128275446264586897474193776400465275167777832622157773372879463606146128022620285693891540788235229239672405060120203686774511468011972485984983535894919421543461759499096362152894616017344239642743391778941134500105852623176726707340602287941750635663845779675174278129608159631247023276032,1162909606774227786762360554904656873467005634722346243123857684508335800080212296528535403972500597220234608121734983386023291518966099546891430040655179625172067449629161883859511896818291049959507502002794829515164438990867773160767189319641778161093019870270482668056135958042158788515967843798733586173623987894941361961956503217167249393827582112256509171868414221167242597679368110852891933106118102448936895420986905619254557683605421985950220457144259359231632456877367983992190446749365022925067669913265323579719756925062086656,1843812769630219797102194898630589042838024531800431544407803208699762220759288686771851688175304525277287596637929619481851566234761209320517998687008822582390183399326187543197624279014134019615905245154166656477378450656137074612544163896000320136805982694616420881365676363963235184229519627621212049120298076086417612215067181351396556381877005473113076180736051591032787133962681831575450591579944470027127255325865144199772221608835705143631909500064802696725673323645838019575905814384115925441812137010043170716647424}
						rep_tuppers_self $predefined_K,$negate_after_using_k_input_a
					else
						rep_tuppers_self $k_a,$negate_after_using_k_input_a
					fi
				fi

				if $K_diff
					rep_tuppers_self $k_a,$negate_after_using_k_input_a
				fi

				if $copy_from_stored_K_value
					rep_tuppers_self $k_value_from_images,$negate_after_using_k_input_a
					k_a=$k_value_from_images
				fi

				name tuppers_image_mode_0

				$temporary_image
				temporary_image,activate_changes=0
				store _persistent
			fi
		fi
	fi
else
	n_imgs={$!}
	mode_K_a=1
	negate_after_using_k_input=$pre_negation_a

	if $!>1
		allow_mode_switch=0
		reverse
	fi

	eval "
	standard_image_size=[106,17];
	allow_example=1;
	repeat($n_imgs,img_id,
		if([w#img_id,h#img_id]!=standard_image_size,
			allow_example=0;
			break();
		);
	);
	allow_example;
	"

	allow_example=${}

	rep_tuppers_self_K $pre_negation_a

	name tuppers_self_image_base
	store _persistent

	if $allow_mode_switch
		k_a,k_b,k_value_from_images=${}
	else
		('${}')
		replace_str ",","\n\n"
		k_value_from_images={t}
		rm
	fi

fi

rm $_persistent

if $mode_K_a
	remove_named tuppers_image_mode_0
	if !$allow_mode_switch
		append y
	fi
else
	remove_named tuppers_self_image_base
fi

* 255

u "{"$mode_K_a"}_"{$allow_mode_switch*2}\
"{"$mode_K_a"}"\
"{"$user_mode_a"}_"{!$mode_K_a?$allow_example*2}\
"{"$user_mode_a"}"\
"{"$k_a"}_"{2*(!$mode_K_a&&!$user_mode_a)}\
"{"$k_a"}"\
"{"$predefined_K"}_"{(!$mode_K_a&&$user_mode_a)*2}\
"{"$predefined_K"}"\
"{0}_"{!$mode_K_a?(!$user_mode_a?1+('$k_a'!='$k_value_from_images'))}\
"{"$negate_after_using_k_input_a"}_"{2*!$mode_K_a}\
"{"$negate_after_using_k_input_a"}"\
"{"$k_value_from_images"}_"{$mode_K_a?2}\
"{"$k_value_from_images"}"\
"{"$pre_negation_a"}_"{$mode_K_a?2}\
"{"$pre_negation_a"}"\
"{"$allow_example"}"\
"{"$allow_mode_switch"}"\
"{1}"
#@gui Color Region:fx_rep_color_region,fx_rep_color_region_preview(0)*
#@gui:Area Threshold (%)=float(5,1,100)
#@gui:Stray Threshold (%)=float(5,0,100)
#@gui:Color Distance Threshold=float(6,0,10)
#@gui:Old Area Threshold (%)=float(-1,-1,100)_0
#@gui:Old Stray Threshold (%)=float(-1,-1,100)_0
#@gui:Old Color Distance Threshold=float(-1,-1,10)_0
#@gui:_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2023/3/15</i>.</small>")
fx_rep_color_region:
if narg($_persistent)
 remove $_persistent
else
	rep_color_region $1%,$2%,$3
fi
fx_rep_color_region_preview:
imgs={$!}

if [${1-3}]!=[${4-6}]||!narg($_persistent)
	+rep_color_region $1%,$2%,$3
	store[-$imgs--1] _persistent
fi

gui_split_preview "remove $_persistent keep[0]",${-3--1}

u "{$1}"\
"{$2}"\
"{$3}"{!$1?2}\
"{$1}"\
"{$2}"\
"{$3}"\
"{$7}"\
"{$8,$9}"
#@gui Statistical Mode: fx_rep_stat_mode, fx_rep_stat_mode_preview(1)*:*
#@gui:_=note("This filter finds the most common color &#40;the statistical mode&#41;. If two or more colors share the same highest frequency, there is no unique mode â those pixels will return <b>nan</b>. If all colors occur equally often, all pixels will be <b>nan</b>, and the filter will return an error.")
#@gui:_=separator(),_=note("<b>Main</b>")
#@gui:Output=choice(0,"Blended","Per-Layer")
#@gui:_=separator(),_=note("<b>Miscellaneous</b>")
#@gui:NAN Replacement Color=color(0,255,0,255)
#@gui:Old Output=value(-1)
#@gui:Old Color=value(-1)
#@gui:_=separator(),_=note("<center><b>- Additional Information -</b></center>\n\nList of CLI variants of this GUI filter:\n\n1. <b>rep_mode</b> *\n2. <b>rep_mode_blend</b>\n\n* <b><u>This command use user-defined arguments!</u></b>")
#@gui:_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2025/11/11</i>.</small>")
fx_rep_stat_mode:
if narg($_persistent)
	rm
	$_persistent
	keep[result]
else
	fx_rep_stat_mode_preview $*
fi
fx_rep_stat_mode_preview:
skip $*
contain_persistent:=narg($_persistent)

if $1!=$6||!$contain_persistent
	to_rgba

	if $1
		rep_mode 1
		foreach { if same({n},vector(#s#-1,nan)) error all_nan@[$>] fi }
	else
		rep_mode_blend
		foreach {
			eval[-1] "begin(
					counts_of_nan=0;
				);
				isnan(i)?++counts_of_nan;
				end(
					merge(counts_of_nan,+);
					set('{}',counts_of_nan==whds);
				);
				"
			if ${} error all_nan@[$>] fi
		}
	fi

	name[0--1] result

	if !$1
		+f isnan(i0)?[${2-5}]:I
		name[-2,-1] temp_result,result
	fi

	+store _persistent
elif $contain_persistent?!same([${2-5}],[$7])
	rm $_persistent rm[result]
	+f isnan(i0)?[${2-5}]:I
	name[-2,-1] temp_result,result
else
	rm $_persistent
fi

rmn temp_result

u "{$1}"\
"{${2-5}}"_{(!$1)<<1}\
"{$1}"\
"{${2-5}}"
######################

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
