#@gmic
#
#  File        : reptorian.gmic
#                ( G'MIC commands file )
#
#  Description : The author of these filter generally recreate
#  filters that exists in one or few softwares to break through
#  the software barrier.
#
#  No reverse engineering has been applied without permission.
#
#  Copyright   : Reptorian
#                ( https://discuss.pixls.us/u/reptorian/summary )
#
#  License     : CeCILL v2.0
#                ( http://cecill.info/licences/Licence_CeCILL_V2-en.html )
#
#  This software is governed by the CeCILL  license under French law and
#  abiding by the rules of distribution of free software.  You can  use,
#  modify and/ or redistribute the software under the terms of the CeCILL
#  license as circulated by CEA, CNRS and INRIA at the following URL
#  "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL license and that you accept its terms.
#

#-------------------------------
#
#@cli :: Reptorian's CLI Commands
#
#-------------------------------
#@cli rep_er : eq. to 'rep_emboss_relief' : (+)
rep_er : rep_emboss_relief $*
#@cli rep_emboss_relief : int_radius>=4,-360>=_ang>=360,_sigma>0,_scale>0,_output={ 0=emboss | 1=relief },_color_out={ 0=gray | 1=color },_bias>0
#@cli : Generates effect of embossing onto image via convolution.
#@cli : Default values: '_ang=45','_sigma=.5','_scale=2','_output=1','_bias=128','_color_out=1'
rep_emboss_relief:
skip ${2=45},${3=.5},${4=2},${5=1},${6=1},${7=128}

_rep_er_radius,_rep_er_angle,_rep_er_sigma,_rep_er_scale,relief_mode,_use_graymode,_rep_er_bias=${1-5},{!$6},$7

m "process_alpha_case : sh 0,{s-2} process_er_filter. rm."

if $_use_graymode
 m "end_relief : +.. . rm."
 um process_alpha_case
 m "process_alpha_case : split_opacity process_er_filter.. a c"
else
 m "end_relief : add"
fi

if $relief_mode
 m "process_er_filter : +_rep_steerable_gaussian_convolve $_rep_er_radius,$_rep_er_angle,$_rep_er_sigma,$_rep_er_scale,$_use_graymode end_relief"
else
 m "process_er_filter : +_rep_steerable_gaussian_convolve $_rep_er_radius,$_rep_er_angle,$_rep_er_sigma,$_rep_er_scale,$_use_graymode +. $_rep_er_bias k."
fi

repeat $! l[$>]  
 if s==2||s==4 process_alpha_case
 else process_er_filter
 fi 
endl done

um process_alpha_case,process_er_filter,end_relief
+_rep_steerable_gaussian_convolve:

sg,theta,sigma,M={max(5,int(abs($1)))},{deg2rad($2)},$3,{3*$3}

$sg,1,1,2,"begin(
  const center_index=(w-1)/2;
  const sigma_exp=2*$sigma^2;
  const sqrsig=$sigma*sqrt(2*pi);
 );
 nx=(x-center_index)/center_index*$M;
 g=exp(-(nx^2)/sigma_exp)/sqrsig;
 gp=(nx/$sigma^2)*g;
 [g,gp];"

sh. 0 ts={is#-1/$4} rm. /. $ts

+rotate. 90

s[-2,-1] c

+convolve[0] [-4]
convolve. [-2]
+convolve[0] [-3]
convolve. [-5]
*. {cos($theta)}
*.. {sin($theta)}
add.. .

k[0,-2]

if $5 ss={s} compose_channels. + /. $ss fi
#@cli rep_hsl2ryb2rgb
#@cli : Convert color representation of selected image from HSL to RYB to RGB
rep_hsl2ryb2rgb:
e[^-1] "Convert color representation of image$? from HSL to RYB to RGB."
f "H=(i0/60)%6;C=(1-abs(2*i2-1))*i1;X=C*(1-abs(H%2-1));
 m=i2-C/2;
 RYB=arg(1+int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
 RYB+=m*=255;
 red=RYB[0];
 yellow=RYB[1];
 blue=RYB[2];
 white=min(RYB);
 red-=white;
 yellow-=white;
 blue-=white;
 maxyellow=max(red,yellow,blue);
 green=min(yellow,blue);
 yellow-=green;
 blue-=green;
 blue>0&&green>0?(
  blue*=2; 
  green*=2
 );
 red+=yellow;
 green+=yellow;
 maxgreen = max(red,green,blue);
 maxgreen>0?(
  N=maxyellow/maxgreen;
  red*=N;
  green*=N;
  blue*=N;
 );
 red+=white;
 green+=white;
 blue+=white;
 [red,green,blue];"
#@cli rep_color_harmony_palette: -360<=ang<=360,0<=_saturation<=1,-100[%]<=shade_tint<=100[%],0<=choice<=10,ryb_mode={ 0=rgb | 1=ryb | 2=hsl+rgb | 3=hsl+ryb }
#@cli : Create a harmony palette. In other word, create a palette based on the color wheel.
+rep_color_harmony_palette:
ang,saturation,shade_tint,choice,ryb_mode=${1-5}
{arg(1+$choice%11,6,6,6,2,3,3,4,3,4,5,6)},1,1,3,">begin(
  fmod(a)=a-360*floor(a/360);
  const start_ang=fmod($ang);
  const saturation=cut($saturation,0,1);
  const shade_tint=cut((1+$shade_tint)/2,0,1);
  const choice=$choice%11;
  ang=start_ang;
  choice<3?( #Neutral 8-15 and Analogous 30
   const add_ang=arg(choice+1,8,15,30);
   new_ang()=x?(ang+=add_ang;ang=fmod(ang););
  ):
  choice==3?( #Complementary
   new_ang()=x?ang=fmod(ang+180);
  ):
  choice==4?( #Split-Complementary
   new_ang()=x==2?(ang+=60;ang=fmod(ang);):x==1?(ang+=150;ang=fmod(ang););
  ):
  choice==5?( #Triadic
   new_ang()=x?ang=fmod(ang+120);
  ):
  choice==6?( #Tetradic
   new_ang()=x?ang=fmod(ang+90);
  ):
  choice==7?( #Clash
   new_ang()=x?(ang=fmod(start_ang+(x%2?90:-90)));
  ):
  choice==8?( #Four Tones
   new_ang()=x?(ang=fmod(ang+arg(x%2+1,120,60)););
  ):
  choice==9?( #Five Tones
   new_ang()=x?(x==1?(ang=fmod(ang+120);):(ang=fmod(ang+arg(x%2+1,30,60))););
  ):(         #Six Tones
   new_ang()=x?(ang=fmod(ang+(x%2?30:90)););
  );
 );
 new_ang();
 [ang,saturation,shade_tint];"

if $ryb_mode>1
 if $ryb_mode%2 +rep_hsl2ryb2rgb. else +hsl2rgb. fi
else
 if $ryb_mode rep_hsl2ryb2rgb. else hsl2rgb. fi
fi
round.
#@cli rep_cubic_map: [image],mode={ 0=neumann | 1=periodic | 2=continuous }
#@cli : Map palette into image with cubic interpolation.
rep_cubic_map:
skip ${2=2}
pass$1 0
ts={s#-1}
length={max(w,h,d)}

repeat $!-1 l[$>,-1]

 {w#-2},{h#-2},{d#-2},$ts,:"begin(
   const length=$length;
   const mi=length-1;
   const smi=mi-1;
   cubic_interpolation(p0,p1,p2,p3,v)=(
    (-.5*p0+1.5*p1-1.5*p2+.5*p3)*v^3
    +(p0-2.5*p1+2*p2-.5*p3)*v^2
    +(-.5*p0+.5*p2)*v
    +p1
   );
   w#-1==length?(
    $2?(
     calc()=cubic_interpolation(
      I(#-1,p_s,0,0),
      I(#-1,p_0,0,0),
      I(#-1,p_1,0,0),
      I(#-1,p_e,0,0),
      interp
     );
    ):(
     calc()=(
      inrange(pref,0,smi,1,1)?(
       cubic_interpolation(
        I(#-1,p_s,0,0),
        I(#-1,p_0,0,0),
        I(#-1,p_1,0,0),
        I(#-1,p_e,0,0),
        interp
       );     
      ):(
       pref>0?I(#-1,mi,0,0):I(#-1,0,0,0);
      );
     );
    );
   ):
   h#-1==length?(
    $2?(
     calc()=cubic_interpolation(
      I(#-1,0,p_s,0),
      I(#-1,0,p_0,0),
      I(#-1,0,p_1,0),
      I(#-1,0,p_e,0),
      interp
     );
    ):(
     calc()=(
      inrange(pref,0,smi,1,1)?(
       cubic_interpolation(
        I(#-1,0,p_s,0),
        I(#-1,0,p_0,0),
        I(#-1,0,p_1,0),
        I(#-1,0,p_e,0),
        interp
       );     
      ):(
       pref>0?I(#-1,0,mi,0):I(#-1,0,0,0);
      );
     );
    );
   ):(
    $2?(
     calc()=cubic_interpolation(
      I(#-1,0,0,p_s),
      I(#-1,0,0,p_0),
      I(#-1,0,0,p_1),
      I(#-1,0,0,p_e),
      interp
     );
    ):(
     calc()=(
      inrange(pref,0,smi,1,1)?(
       cubic_interpolation(
        I(#-1,0,0,p_s),
        I(#-1,0,0,p_0),
        I(#-1,0,0,p_1),
        I(#-1,0,0,p_e),
        interp
       );     
      ):(
       pref>0?I(#-1,0,0,mi):I(#-1,0,0,0);
      );
     );
    );
   );
   $2==2?(
    calc_ps()=[pref-1,pref,pref+1,pref+2]%length;
   ):
   $2==1?(
    calc_ps()=(
     npref=pref%length;
     [max(0,npref-1),npref,min(mi,npref+1),min(npref+2,mi)];
    );
   ):(
    calc_ps()=[pref-1,pref,pref+1,pref+2];
   );
  );
  vp=i(#-2,x,y,z,0);
  pref=floor(vp);
  interp=vp-pref;
  ps=calc_ps();
  p_s=ps[0]; #Start Point
  p_0=ps[1];
  p_1=ps[2];
  p_e=ps[3]; #End Point
  calc();"
 
 rv[0,-1] rm.
 
endl done
rm.
#@cli rep_tco_anim: eq. to 'rep_three_coupled_oscillators_animation' : (+)
rep_tco_anim: rep_three_coupled_oscillators_animation $*
#@cli rep_three_coupled_oscillators_animation: _max_iter>0,-2pi<=_k_a_1<=2pi,-2pi<=_k_b_1<=2pi,-2pi<=_k_a_2<=2pi,-2pi<=_k_b_2<=2pi,_sublevel>=0,-360<=_ang_a<=360,-360<=_ang_b<=360,_ox_a,_oy_a,_ox_b,_oy_b,_axis_scale_a>0,_axis_scale_b>0
#@cli : Animation-based version of Bifurcation diagram for two-parameters of torus-map or three-coupled oscillators. [1]
#@cli :
#@cli : --- Citation ---
#@cli : 1) C. Baesens, J. Guckenheimer, S. Kim, R.S. MacKay
#@cli : Three coupled oscillators: mode-locking, global bifurcations and toroidal chaos
#@cli : Physica D: Nonlinear Phenomena, Volume 49, Issue 3, 1991, Pages 387-475, ISSN 0167-2789
#@cli : ------
#@cli :
#@cli : _max_iter is the number of iterations within the bifurcation diagram.
#@cli : _k_a_1 is the a-variable that influence the output for first frame.
#@cli : _k_b_1 is the b-variable that influence the output for first frame.
#@cli : _k_a_2 is the a-variable that influence the output for last frame.
#@cli : _k_b_2 is the b-variable that influence the output for last frame.
#@cli : _sublevel defines the degree of subpixel processing. 0 means no subpixel sampling. Negative  number in here means it will not be resized (Useful for mapping before downsizing to original image size.).
#@cli : _ang_a defines the angle of function for first frame.
#@cli : _ang_b defines the angle of function for last frame.
#@cli : _ox_a defines the x-offset of function for first frame.
#@cli : _oy_a defines the y-offset of function for first fraime.
#@cli : _ox_b defines the x-offset of function for last frame.
#@cli : _oy_b defines the y-offset of function for last frame.
#@cli : _axis_scale_a defines the scale of each axis for first frame.
#@cli : _axis_scale_b defines the scale of each axis for last frame.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_max_iter=50','_k_a_1=u(-2*pi,2*pi)','_k_b_1=u(-2*pi,2*pi)','_k_a_2=u(-2*pi,2*pi)','_k_b_2=u(-2*pi,2*pi)','_sublevel=1','_ang_a=0','_ang_b=0','_ox_a=0','_oy_a=0','_ox_b=0','_oy_b=1','_axis_scale_a=1','_axis_scale_b=1'
rep_three_coupled_oscillators_animation:
skip ${1=50},${2=},${3=},${4=},${5=},${6=1},${7=0},${8=180},{$9=0},${10=0},${11=0},${12=0},${13=1},${14=1}
check ${-max_d}>1
_rep_three_coupled_oscillators ${1-14}
#@cli rep_tco: eq. to 'rep_three_coupled_oscillators' : (+)
rep_tco: rep_three_coupled_oscillators $*
#@cli rep_three_coupled_oscillators: _max_iter>0,-2pi<=_k_a<=2pi,-2pi<=_k_b<=2pi,_sublevel>=0,-360<=_ang<=360,_ox,_oy,_axis_scale>0
#@cli : Bifurcation diagram for two-parameters of torus-map or three-coupled oscillators. [1]
#@cli :
#@cli : --- Citation ---
#@cli : 1) C. Baesens, J. Guckenheimer, S. Kim, R.S. MacKay
#@cli : Three coupled oscillators: mode-locking, global bifurcations and toroidal chaos
#@cli : Physica D: Nonlinear Phenomena, Volume 49, Issue 3, 1991, Pages 387-475, ISSN 0167-2789
#@cli : ------
#@cli :
#@cli : _max_iter is the number of iterations within the bifurcation diagram.
#@cli : _k_a is a variable that influence the output.
#@cli : _k_b is a variable that influence the output.
#@cli : _sublevel defines the degree of subpixel processing. 0 means no subpixel sampling. Negative  number in here means it will not be resized (Useful for mapping before downsizing to original image size.).
#@cli : _ang defines the angle of function.
#@cli : _ox defines the x-offset of function.
#@cli : _oy defines the y-offset of function.
#@cli : _axis_scale defines the scale of each axis.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_max_iter=50','_k_a=u(-2*pi,2*pi)','_k_b=u(-2*pi,2*pi)','_sublevel=1','_ang=0','_ox=0','_oy=0','_axis_scale=1'
rep_three_coupled_oscillators:
skip ${1=50},${2=},${3=},${4=1},${5=0},${6=0},${7=0},${8=1}
check ${-max_d}==1
_rep_three_coupled_oscillators ${1-8}
_rep_three_coupled_oscillators:
skip ${1=50},${2=},${3=},${4=},${5=}
check "abs($1)!=0&&$8!=0"
 
animation_mode=0
if ${-max_d}>1 animation_mode=1 if $!>1 error "One image only for animation mode!" fi fi

tau={pi*2}

if $animation_mode
 if narg($2) __k_a_1=$2
 else __k_a_1={u(-$tau,$tau)}
 fi
 
 if narg($3) __k_a_2=$3
 else __k_b_1={u(-$tau,$tau)}
 fi
 
 if narg($4) __k_b_1=$4
 else __k_a_2={u(-$tau,$tau)}
 fi
 
 if narg($5) __k_b_2=$5
 else __k_b_2={u(-$tau,$tau)}
 fi
 
 rescale_back={$6>0}
 
 __sub={abs($6)+1}
 m "generate_three_coupled: +_rep_three_coupled_oscillators_animation $1,$__k_a_1,$__k_b_1,$__k_a_2,$__k_b_2,$__sub,${7-14}"
 
else
 if narg($2) __k_a=$2
 else __k_a={u(-$tau,$tau)}
 fi

 if narg($3) __k_b=$3
 else __k_b={u(-$tau,$tau)}
 fi

 rescale_back={$4>0}
 __sub={abs($4)+1}
 
 m "generate_three_coupled: +_rep_three_coupled_oscillators_static_out $1,$__k_a,$__k_b,$__sub,${5-8}"
fi

repeat $! l[$>]

 generate_three_coupled
  
 if $rescale_back r. {w#0},{h#0},100%,100%,6 fi

 rm..
 
endl done

um generate_three_coupled
+_rep_three_coupled_oscillators_animation:
check "$13!=0&&$14!=0"

 {w*$6},{h*$6},{d},1,"*begin(
   const max_iter=abs($1);
   const ww=w-1;
   const hh=h-1;
   const dd=d-1;
   const sd=max(ww,hh)/min(ww,hh);
   const sx=w>h?sd:1;
   const sy=w>h?1:sd;
   const cx=ww/2;
   const cy=hh/2;
   const ox_a=($9+1)*cx;
   const oy_a=($10+1)*cx;
   const ox_b=(($11*-1)+1)*cy;
   const oy_b=(($12*-1)+1)*cy;
   const axis_scale_a=$13;
   const axis_scale_b=$14;
   const cxsx=cx/sx;
   const cysy=cy/sy;
   const cxsx_a=cxsx/axis_scale_a;
   const cxsx_b=cxsx/axis_scale_b;
   const cysy_a=cysy/axis_scale_a;
   const cysy_b=cysy/axis_scale_b;
   const ang_a=-$7;
   const ang_b=-$8;
   set_cos_ang=vectord();
   set_sin_ang=set_cos_ang;
   fill(set_cos_ang,p,cos(deg2rad(lerp(ang_a,ang_b,p/dd))));
   fill(set_sin_ang,p,sin(deg2rad(lerp(ang_a,ang_b,p/dd))));
   const tau=2*pi;
   const k_a_1=$2;
   const k_b_1=$3;
   const k_a_2=$4;
   const k_b_2=$5;
   const tc=.7/tau;
   rot_x(a,b,c)=a*set_cos_ang[c]-b*set_sin_ang[c];
   rot_y(a,b,c)=a*set_sin_ang[c]+b*set_cos_ang[c];
   oscil_a(a,b,c)=a+c-tc*sin(tau*b);
   oscil_b(a,b,c)=a+c-tc*sin(tau*b);
  );
  zp=z/dd;
  ix=(x-lerp(ox_a,ox_b,zp))/lerp(cxsx_a,cxsx_b,zp);
  iy=(y-lerp(oy_a,oy_b,zp))/lerp(cysy_a,cysy_b,zp);
  xp=rot_x(ix,iy,z);
  yp=rot_y(ix,iy,z);
  k_a=lerp(k_a_1,k_b_1,zp);
  k_b=lerp(k_a_2,k_b_2,zp);
  repeat(max_iter,
   txp=xp;
   xp=oscil_a(xp,yp,k_a);
   yp=oscil_b(yp,txp,k_b);
  );
  norm(xp,yp);"
+_rep_three_coupled_oscillators_static_out:
check "$8!=0"

 {w*$4},{h*$4},1,1,*"begin(
   const max_iter=abs($1);
   const ww=w-1;
   const hh=h-1;
   const sd=max(ww,hh)/min(ww,hh);
   const sx=w>h?sd:1;
   const sy=w>h?1:sd;
   const cx=ww/2;
   const cy=hh/2;
   const ox=($6+1)*cx;
   const oy=(($7*-1)+1)*cy;
   const axis_scale=abs($8);
   const cxsx=cx/sx/axis_scale;
   const cysy=cy/sy/axis_scale;
   const ang=-($5/180)*pi;
   const cos_ang=cos(ang);
   const sin_ang=sin(ang);
   const tau=2*pi;
   const k_a=$2;
   const k_b=$3;
   const tc=.7/tau;
   rot_x(a,b)=a*cos_ang-b*sin_ang;
   rot_y(a,b)=a*sin_ang+b*cos_ang;
   oscil_a(a,b)=a+k_a-tc*sin(tau*b);
   oscil_b(a,b)=a+k_b-tc*sin(tau*b);
  );
  ix=(x-ox)/cxsx;
  iy=(y-oy)/cysy;
  xp=rot_x(ix,iy);
  yp=rot_y(ix,iy);
  repeat(max_iter,
   txp=xp;
   xp=oscil_a(xp,yp);
   yp=oscil_b(yp,txp);
  );
  norm(xp,yp);"
#@cli rep_find_permutation: init_num,_add_1,_output
#@cli : Prints all the permutation of set of numbers
#@cli : _output defines whether it is a function to be used onto a variable. This is used to generate a permutation of a set of number.
#@cli :
#@cli : Source of Base Code: https://www.techiedelight.com/find-permutations-string-cpp-java-iterative/
#@cli : Default values: '_add_1=0','_output=0'
rep_find_permutation:
skip ${2=0},${3=0}

check "$1>1&&isint($1)"

$1,1,1,1,x
if $2 +. 1 fi

outstring="\n"

eval "
 s=crop(#-1);
 iter=1;
 revert(q)=(
  a=s;
  n=$1-1;
  for(p=q,p<$1,p++,
   a[p]=s[n];
   n--;
  );
  a;
 );
 m=0;
 while(1,
  run('outstring.=',vtos(s),'\\n');
  i=$1-1;
  while(s[i-1]>=s[i],
   i--;
   if(!i,m=1;break(););
  );
  m?break();
  j=$1-1;
  while(j>i && s[j] <= s[i-1],
   j--;
  );
  swap(s[i-1],s[j]);
  s=revert(i);
  iter++;
 );
 run('iter=',iter);"

if $3 echo "\n[{(["$outstring"])[(""$"n%$iter)*$1,$1]}]
else echo $outstring-$iter
fi

rm.
#@cli rep_rrd: eq. to 'rep_random_rectangular_division' : (+)
rep_rrd: rep_random_rectangular_division $*
#@cli rep_random_rectangular_division: split>1,_additional_thickness>=0,_max_iter>=2,_probability[%]>0,_loop_limit>1,0<=_border[%]>=100%,_seed,_normalize,border_color,palette_mode
#@cli : Generate random division of rectangle as in random number of division and varying thickness within rectangle.
#@cli : _additional_thickness refers to the excess pixel thickness.
#@cli : _max_iter limits the number of iterations per rectangle.
#@cli : _probability determines the probability that a rectangle will be permitted to be utilized for further iteration.
#@cli : _loop_limit limits the number of time the process of subdivision is done.
#@cli : _seed generates the output based on defined parameter.
#@cli : Default values: '_gen_thick=0','_max_iter=5','_probability[%]=95%','_loop_limit=5000','_border=0%','_seed=n/a'
rep_random_rectangular_division:
skip ${2=0},${3=5},${4=95%},${5=5000},${6=0},${7=},${8=0},${9=},${10=},${11=},${12=},${13=}
check "$4>0"
repeat $! l[$>]
 _rep_random_rectangular_division $*
endl done
_rep_random_rectangular_division:
skip ${2=0},${3=5},${4=95%},${5=5000},${6=0},${7=},${8=0},${9=},${10=},${11=},${12=},${13=}

border_size={max(0,round(abs($2)*cut($6,0,1)))}
contain_palette=0
dims={w},{h}
ns=1
col=0
activate_code_block=1

if narg($10)
 ms=3
 contain_palette=1
 if '$10'=='pal'
 elif ${is_image_arg\ $10} pass$10 0 ms={s#-1} rm.
 else contain_palette=0
 fi
fi

if narg($10)
 ms=3
 contain_palette=1
 if '$10'=='pal'
 elif ${is_image_arg\ $10} pass$10 0 ms={s#-1} rm.
 else
  contain_palette=0
  if !narg($11)||(narg($11)?abs($11)==0)
   activate_code_block=0
   if narg($9)&&$border_size
    col=${rep_hex2int8\ $9}
    ns={narg($col)}
    col=vector(#$ns,$col)
   else
    ns=3
   fi
  fi
 fi
else
 if narg($9)&&$border_size
  col=${rep_hex2int8\ $9}
  ns={narg($col)}
  col=vector(#$ns,$col)
 fi
fi

rm.

$dims,1,$ns,$col

1,1,1,5 #Modifiable Rectangle Array
1,1,1,5 #Unmodifiable Rectangle Array

eval ${-math_lib}"
 if(narg($7),srand($7););
 const ww=w#-3-1;
 const hh=h#-3-1;
 const max_split=max(1,int(abs($1)));
 const internal_space=int(abs($2));
 const test_boundary=internal_space?(internal_space+1);
 const max_iter=max(2,round(abs($3)));
 const odd=cut($4,0,1);
 const arr_limit=round(abs($5));

 diff_check(a)=(
  mri=max_split;
  ds=a/mri;
  if(mri>1&&ds<1,
   while(mri>1&&ds<1,
    mri--;
    ds=a/mri;
   );
  );
  ds>1;
 );

 width_check=diff_check(ww-internal_space*2);
 height_check=diff_check(hh-internal_space*2);

 !(width_check||height_check)?run('error inv_dim');

 dar_insert(#-2,[0,ww,0,hh,0]);

 sub_column(v,point)=(
  ri=int(u(1,max_split))+1;
  mri=ri-1;
  sx=v[0]+test_boundary;
  ex=v[1]-test_boundary;
  diff=ex-sx;
  bound_check=diff>test_boundary;
  skip=0;
  dar_remove(#-2,point);
  if(bound_check,
   ds=diff/mri;
   if(mri>1&&ds<=test_boundary,
    while(mri>1&&ds<=test_boundary,
     ri--;
     mri--;
     ds=diff/mri;
    );
   );
   if(test_boundary||diff?(ds>test_boundary):1,
    py=[v[2],v[3]];
    iter=v[4]+1;
    p=v[0];
    repeat(ri,ri_ind,
     rb=odd<1?u(0,1)>odd;
     ri_ind==mri?(
      if(p>v[1],
       p=v[1];
       if(!(v[3]-v[2]),rb=1;);
      );
      (rb||(iter==max_iter))?(
       dar_insert(#-1,[p,v[1],py,iter]);
      ):(
       dar_insert(#-2,[p,v[1],py,iter]);
      );
     ):
     !ri_ind?(
      mx=sx+ds;
      np=min(max(sx,round(u(p,mx))),ex);
      vp=[p,np];
      (rb||(iter==max_iter))?(
       dar_insert(#-1,[vp,py,iter]);
      ):(
       dar_insert(#-2,[vp,py,iter]);
      );
      p=np+1;
      if(p>=ex,skip=1;);
     ):(
      if(skip,continue(););
      mx+=ds;
      np=min(max(p+internal_space,round(u(p,mx))),ex);
      vp=[min(p,ex),np];
      (rb||(iter==max_iter))?(
       dar_insert(#-1,[vp,py,iter]);
      ):(
       dar_insert(#-2,[vp,py,iter]);
      );
      p=np+1;
     );
    );
   ,dar_insert(#-1,v);
   );
  ,dar_insert(#-1,v);
  );
 );

 sub_row(v,point)=(
  ri=int(u(1,max_split))+1;
  mri=ri-1;
  sy=v[2]+test_boundary;
  ey=v[3]-test_boundary;
  diff=ey-sy;
  bound_check=diff>test_boundary;
  skip=0;
  dar_remove(#-2,point);
  if(bound_check,
   ds=diff/mri;
   if(mri>1&&ds<=test_boundary,
    while(mri>1&&ds<=test_boundary,
     ri--;
     mri--;
     ds=diff/mri;
    );
   );
   if(test_boundary||diff?(ds>test_boundary):1,
    px=[v[0],v[1]];
    iter=v[4]+1;
    p=v[2];
    repeat(ri,ri_ind,
     rb=odd<1?u(0,1)>odd;
     ri_ind==mri?(
      if(p>v[3],
       p=v[3];
       if(!(v[1]-v[0]),rb=1;);
      );
      (rb||(iter==max_iter))?(
       dar_insert(#-1,[px,p,v[3],iter]);
      ):(
       dar_insert(#-2,[px,p,v[3],iter]);
      );
     ):
     !ri_ind?(
      my=sy+ds;
      np=min(max(sy,round(u(p,my))),ey);
      vp=[p,np];
      (rb||(iter==max_iter))?(
       dar_insert(#-1,[px,vp,iter]);
      ):(
       dar_insert(#-2,[px,vp,iter]);
      );
      p=np+1;
      if(p>=ey,skip=1;);
     ):(
      if(skip,continue(););
      my+=ds;
      np=min(max(p+internal_space,round(u(p,my))),ey);
      vp=[min(p,ey),np];
      (rb||(iter==max_iter))?(
       dar_insert(#-1,[px,vp,iter]);
      ):(
       dar_insert(#-2,[px,vp,iter]);
      );
      p=np+1;
     );
    );
   ,dar_insert(#-1,v);
   );
  ,dar_insert(#-1,v);
  );
 );


 v=I[#-2,0];

 width_check&&height_check?(
  u(0,1)<=.5?(
   sub_row(v,0);
  ):(
   sub_column(v,0);
  );
 ):
 width_check?(
  sub_column(v,0);
 ):
 height_check?(
  sub_row(v,0);
 );

 arr_point=0;

 while(dar_size(#-2),
  p_ind=int(u(dar_size(#-2)));
  cv=I[#-2,p_ind];
  u(0,1)<.5?(
   sub_row(cv,p_ind);
  ):(
   sub_column(cv,p_ind);
  );
  arr_point++;
  if(arr_point>=arr_limit,break());
 );

 resize(#-2,1,dar_size(#-2),1,4,0);
 resize(#-1,1,dar_size(#-1),1,4,0);"

a[-2,-1] y

eval. :${-math_lib}"begin_t(
  const ww=w#-2-1;
  const hh=h#-2-1;
  const border_size=$border_size;
  const b_a=floor(border_size/2);
  const b_b=ceil(border_size/2);
  const contain_border=$border_size?1;
  $8&&!narg($10)?(
   $ns>1?(
    const rescale_factor=(h-1)/255;
    calc_out()=vector(#$ns,y/rescale_factor);
   ):(
    const rescale_factor=(h-1+contain_border)/255;
    calc_out()=vector(#$ns,(y+contain_border)/rescale_factor);
   );
  ):(
   $activate_code_block?(
    calc_out=calc_out()=y+contain_border;
   ):(
    if(narg($12),srand($12+t););
    $10==1?(
     calc_out()=hsv2rgb(vector(#3,u(360),u(1),u(1)));
    ):(
     calc_out()=vector(#3,u(255),u(255),u(255));
    );
   );
  );
  convert2coords(c)=(
   sx=c[0]+(!(c[0]==0)?b_a);
   sy=c[2]+(!(c[2]==0)?b_a);
   ex=c[1]-(!(c[1]==ww)?b_b);
   ey=c[3]-(!(c[3]==hh)?b_b);
   tl=[sx,sy];
   tr=[ex,sy];
   bl=[sx,ey];
   br=[ex,ey];
   [tl,tr,br,bl];
  );
 );
 polygon(#-2,4,convert2coords(I),1,calc_out());
 end(
  if(contain_border,
   const sub_border=border_size-1;
   const bh=hh-sub_border;
   const bw=ww-sub_border;
   col="$col";
   polygon(#-2,4,[0,0, ww,0, ww,sub_border, 0,sub_border],1,col);
   polygon(#-2,4,[0,border_size,sub_border,border_size,sub_border,hh,0,hh],1,col);
   polygon(#-2,4,[bw,border_size,ww,border_size,ww,hh,bw,hh],1,col);
   polygon(#-2,4,[border_size,bh,bw,bh,bw,hh,border_size,hh],1,col);
  );
 );"

rm.

if narg($10)&&$activate_code_block
 if $contain_palette
  orientation=0
  if $border_size
   col=${rep_hex2int8\ $9}
   1,1,1,$ms,vector(#3,$col);
   if '$10'=='pal'
    +pal $11
    if narg($12)
     {w},1,1,1,begin(srand($12););u
     pixelsort.. +,x,[-1]
     rm.
    fi
   elif ${is_image_arg\ $10}
    pass$10 1
    if h>w orientation=1 fi
    if narg($11)
     if $orientation
      {h},1,1,1,begin(srand($11););u
      pixelsort.. +,y,[-1]
      rm.
     else
      {w},1,1,1,begin(srand($11););u
      pixelsort.. +,x,[-1]
      rm.
     fi
    fi
   fi
   r. {iM#-3-1},1,1,3,0,2
   if $orientation
    r. 1,{iM#-3-1},1,3,0,2
    a[-2,-1] y
   else
    r. {iM#-3-1},1,1,3,0,2
    a[-2,-1] x
   fi
  else
   if '$10'=='pal'
    +pal $11
    if narg($12)
     {w},1,1,1,begin(srand($12););u
     pixelsort.. +,x,[-1]
     rm.
    fi
   elif ${is_image_arg\ $10}
    pass$10 1
    if h>w orientation=1 fi
    if narg($11)
     if $orientation
      {h},1,1,1,begin(srand($11););u
      pixelsort.. +,y,[-1]
      rm.
     else
      {w},1,1,1,begin(srand($11););u
      pixelsort.. +,x,[-1]
      rm.
     fi
    fi
   fi
   if $orientation
    r. 1,{iM#-2-1},1,3,0,2
   else
    r. {iM#-2-1},1,1,3,0,2
   fi
  fi
 else
  if $border_size
   col=${rep_hex2int8\ $9}
   1,1,1,3,vector(#3,$col);
   if $10==1
    {narg($11)?max(abs($11),2):iM#-2-1},1,1,3,${-math_lib}begin(if(narg($12),srand($12);););hsv2rgb(vector(#3,u(360),u(1),u(1)));
   else
    {narg($11)?max(abs($11),2):iM#-2-1},1,1,3,begin(if(narg($12),srand($12);););vector(#3,u(255),u(255),u(255));
   fi
   if narg($11) r. {iM#-3-1},100%,100%,100%,0,2 fi
   a[-2,-1] x
  else
   if $10==1
    {narg($11)?max(abs($11),2):iM#-1-1},1,1,3,${-math_lib}begin(if(narg($12),srand($12);););hsv2rgb(vector(#3,u(360),u(1),u(1)));
   else
    {narg($11)?max(abs($11),2):iM#-1-1},1,1,3,begin(if(narg($12),srand($12);););vector(#3,u(255),u(255),u(255));
   fi
   if narg($11) r. {iM#-2-1},100%,100%,100%,0,2 fi
  fi
 fi
 map.. .
 rm.
fi
#@cli rep_custom_map: _shift_value>0,_negate={ 0=no_negation | 1=negate },_[palette],_seed_a...
#@cli : Custom mapping function with more options than default map.
#@cli : _shift_value defines the shift of base values used for mapping of color. This can be either percentage of integer.
#@cli : _[palette] is used to map into image.
#@cli : _seed defines the seed per image. Note: If you had inserted no argument, but a comma before, then it will pick random. If there is no argument and no comma, then it will use default map method. If this is your only argument, then the seed will defines the output. Sequentive arguments will also be used as seed for output for each images.
#@cli : Default values: '_shift_value=n/a','_[palette]','_seed=n/a'
#@cli :
#@cli : Author: Reptorian
rep_custom_map:
skip "${1=}","${2=0}","${3=}","${4=}"
check narg($1)||(narg(${2--1})>1)

if narg($1)
 if ${is_percent\ $1}
  f "begin(
    const num_val=iM+1;
    const shift_val=round(iM*$1);
    nv=expr('x',num_val);
    shift(nv,-shift_val,2);
   );
   nv[i];"
 else
  f "begin(
    const num_val=iM+1;
    nv=expr('x',num_val);
    shift(nv,-$1,2);
   );
   nv[i];"
 fi
fi

if $2 negate fi

if narg($3)

 if ${is_image_arg\ $3}

  pass$3 0

  check "w#-1==1||h#-1==1"

  store. ordered

  if narg($*)==4

   if narg($4)
    $ordered
    if w>h
     {w#-1},1,1,1,begin(if(narg($4),srand($4)));u
     pixelsort.. +,x,[-1]
    else
     1,{h#-1},1,1,begin(if(narg($4),srand($4)));u
     pixelsort.. +,y,[-1]
    fi
    map[0--3] [-2],2
    rm[-2,-1]

   else

    repeat $!
     $ordered
     if w>h
      {w#-1},1,1,1,u
      pixelsort.. +,x,[-1]
     else
      1,{h#-1},1,1,u
      pixelsort.. +,y,[-1]
     fi
     map[$>] [-2],2
     rm[-2,-1]
    done

   fi

  elif narg($*)>4

   $=seed
   repeat $!
    $ordered
    if w>h
     {w#-1},1,1,1,begin(srand(${seed{4+$>}}));u
     pixelsort.. +,x,[-1]
    else
     1,{h#-1},1,1,begin(srand(${seed{4+$>}}));u
     pixelsort.. +,y,[-1]
    fi
    map[$>] [-2],2
    rm[-2,-1]
   done

  else

   $ordered map[^-1] [-1] rm.

  fi

 else error \$\2!=[img]
 fi
fi
#@cli rep_exp_sig_adj : eq. to 'rep_exponential_sigmoid_adjustment' : (+)
rep_exp_sig_adj: rep_exponential_sigmoid_adjustment $*
#@cli rep_exponential_sigmoid_adjustment: -1>=midpoint_shift>=1,sigmoid_level>=0,_sigmoid_shift,_endval
#@cli : Assign exponential-sigmoid function into image.
#@cli :
#@cli : midpoint_shift defines the center value point. If it at .5, then the center value point will between the largest value and the middle value.
#@cli : sigmoid_level influence how much S-Curve will be applied. If 0, then there is no sigmoid function.
#@cli : _sigmoid_shift shifts value
#@cli : _endval determines the maximum value of output. Negative value will return a image where the maximum image is the positive value of the negative input. Positive value will return a image where the maximum value is the maximum value multiplied by it input.
#@cli :
#@cli : Default values: '_sigmoid_shift=0','_endval=1'
#@cli :
#@cli : Author: Reptorian.
rep_exponential_sigmoid_adjustment:
skip ${3=0},${4=1}
check {abs($4)!=0}

sig_scale={abs($2)}
check_sig_scale={$sig_scale==0}

f ":begin(
 const sig_scale=$sig_scale;
 const midpoint_shift=min(1-abs($1),1);
 const maxval_mul_by_factor=$4>0?iM*$4:abs($4);

 $1>=0?(
  calc_exp_shift(n)=n^midpoint_shift;
 ):(
  calc_exp_shift(n)=1-((1-n)^midpoint_shift);
 );

 $check_sig_scale?(
  calc(n)=calc_exp_shift(n);
 ):(

  sigmoid_curve(a)=(ne=e^a;ne/(ne+1));

  $3==0?(
   change_slope(a)=(a-.5)*sig_scale;
   const start_point=change_slope(0);
   const val_ref=(e^start_point)/(e^start_point+1);
   const min_height=abs(val_ref);
   const max_height=1-2*min_height;
  ):(
   const shift_point=.5+$3;
   change_slope(a)=(a-shift_point)*sig_scale;
   const start_point=change_slope(0);
   const start_ref=(e^start_point)/(e^start_point+1);
   const end_point=change_slope(1);
   const end_ref=(e^end_point)/(e^end_point+1);
   const min_height=abs(start_ref);
   const max_height=end_ref-start_ref;
  );

  calc(n)=(
   new_curve=calc_exp_shift(n);
   (sigmoid_curve(change_slope(new_curve))-min_height)/max_height;
  );

 );
);
start_slope=I/iM;
calc(start_slope)*maxval_mul_by_factor;"
#@cli rep_ekb: eq. to 'rep_ellsworth_board' : (+)
rep_ekb: rep_ellsworth_kelly_board $*
#@cli rep_ellsworth_board: sqr_size,_border_size[%],_border_value[%],_distribution,_{pal_id,[image]},_background_hex,fit_mode,_color_space,_exterior_border_color...
#@cli : Outputs a color board based on colored square tiles art made by Ellsworth Kelly with transparent areas.
#@cli :
#@cli : (eq. to 'rep_ekb')
#@cli : sqr_size defines the painted square size.
#@cli : _border_size defines the size of border. Negative number will take away areas from the painted squares. Positive number will separate painted areas by this amount.
#@cli : _border_value defines the gray level of border.
#@cli : _distribution defines the probability of a square to be painted.
#@cli : _{pal_id,[image]} defines the color. If you choose a name of a existing palette, then this will be the base of the colors of the square. Otherwise, it will be based off the palette.
#@cli : _background_hex defines the background color. This is based on RGB-Hex value.
#@cli : _fit_mode defines whether the resulting board should exceed the size of the original image.
#@cli : _color_space defines the color space of the board.
#@cli : _border_color defines the color of the border. Dependent on color space.
#@cli : Default values: '_border_size=10%','_border_value=50%','_distribution=50%','{pal_id,[image]}=120','_background_hex=n/a',_fit_mode=0,'_color_space=0','_exterior_border_color=n/a'
#@cli :
#@cli : Author: Reptorian
rep_ellsworth_kelly_board:
skip "${2=10%},${3=50%},${4=50%},${5=120},${6=},${7=0},${8=0},${9=}"

check "($1==int(abs($1)))&&(int(abs($1))>=1)&&$4>0"

cs={$8%17}

convert_colors_fwd=${arg\ $cs+1,error,rgb2ryb,rgb2cmy,rgb2cmyk,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch,rgb2ycbcr,rgb2ycbcrglic,rgb2yiq,rgb2yuv,rgb2xyz,rgb2yes}
convert_colors_bwd=${arg\ $cs+1,error,ryb2rgb,cmy2rgb,cmyk2rgb,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb,ycbcr2rgb,ycbcrglic2rgb,yiq2rgb,yuv2rgb,xyz2rgb,yes2rgb}

ref_sqr_size={abs($1)}

mode=1

border_direction={$2>=0}

('$2')

if i(#-1,w-1)==37 use_percent=1 else use_percent=0 fi

rm.

if $border_direction&&$ref_sqr_size>1

 if $use_percent border_size={round(($ref_sqr_size)*abs($2))}
 else border_size={round(abs($2))}
 fi

 if $border_size>0
  sqr_size={$ref_sqr_size+$border_size}
 else
  sqr_size=$ref_sqr_size
 fi

elif !$border_direction||$ref_sqr_size==1

 if $use_percent border_size={round(($ref_sqr_size-1)*abs($2))}
 else border_size={min(round(abs($2)),$ref_sqr_size-1)}
 fi
 sqr_size=$ref_sqr_size

else
 border_size=0
 sqr_size=$ref_sqr_size
fi

border_value={cut($3,0,1)}

if ${is_image_arg\ $5}

 pass$5 0

 if !((w>1&&h==1)||(w==1&&h>1)) error dim_inv fi

 l.
  if w>h
   s x
  else
   s y
  fi
  remove_duplicates
  a x
 endl

else

 +pal $5

 cs=0

fi

if w#-1<5 error min_cols>=5==F fi

if narg($6)
 test_color=${rep_hex2int8\ $6}
 1,1,1,{s},"vectors("$test_color")"
 if $8 $convert_colors_fwd. fi
 eval.. "begin(test_color=I(#-1,0,0,0););if(I==test_color,run('error inval_bant'));"
 empty_color=[{[crop(#-1),255]}]
 rm.
else
 empty_color=vector(#s,0)
fi

if $border_size
 condition_text=condition=(nx>=border_size)&&(ny>=border_size);
 result=condition?color:border_color
else
 result=color
fi

mode={$7%2}

border_value={cut($3,0,1)}

if ${is_image_arg\ $5}
 1,1,1,3,[{vector3($border_value*255)}]
 if $cs $convert_colors_fwd. fi
 init_border_color={crop(#-1)}
 rm.
else init_border_color={vector3($border_value*255)}
fi

use_bg_color=0

if narg($9)&&!$mode bg_color=${9--1},255 use_bg_color=1 fi

repeat $!-1 l[$>,-1]

 if $mode
  mini_w={ceil(w#0/$sqr_size)}
  mini_h={ceil(h#0/$sqr_size)}
 else
  mini_w={int(w#0/$sqr_size)}
  mini_h={int(h#0/$sqr_size)}
 fi

 large_w={$mini_w*$sqr_size+$border_size}
 large_h={$mini_h*$sqr_size+$border_size}

 if $mode
  if ($large_w-$sqr_size)>w#0
   large_w-=$sqr_size
   mini_w-=1
  fi
  if ($large_h-$sqr_size)>h#0
   large_h-=$sqr_size
   mini_h-=1
  fi
 else
  if $large_w>w#0
   large_w-=$sqr_size
   mini_w-=1
  fi
  if $large_h>h#0
   large_h-=$sqr_size
   mini_h-=1
  fi
 fi

 $mini_w,$mini_h,1,1,"begin(
   const probability=cut($4,0,1);
   if(probability==1,
    calc_result()=int(u(w#-1));,
    calc_result()=u(1)<probability?int(u(w#-1)):-1;
   );
  );
  calc_result();
  "

 f. >"begin(
   const num_of_colors=w#-2;
   const mx=w-1;
   const my=h-1;
   find_new_color()=(
    new_col_id=int(u(num_of_colors));
    do(
     new_col_id++;
    ,cols[new_col_id%num_of_colors]
    );
    new_col_id%num_of_colors;
   );
  );
  cols=vector(#num_of_colors,0);
  (i+1)?(
   (x==0&&y==0)?(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    find_new_color();
   ):
   (x==mx&&y==0)?(
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    find_new_color();
   ):
   (x==0&&y==my)?(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (x==mx&&y==my)?(
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (x==0)?(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (x==mx)?(
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   ):
   (y==0)?(
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    find_new_color();
   ):
   (y==my)?(
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    find_new_color();
   ):(
    (j(1,0)+1)?cols[j(1,0)]=1;
    (j(-1,0)+1)?cols[j(-1,0)]=1;
    (j(0,1)+1)?cols[j(0,1)]=1;
    (j(0,-1)+1)?cols[j(0,-1)]=1;
    find_new_color();
   );
  ):-1"

  $large_w,$large_h,1,{s#-2+1},*"begin(
   const col_s=s#-2;
   const border_size=$border_size;
   modv(a)=a-int(a/$sqr_size)*$sqr_size;
   mini(a)=int(a/$sqr_size);
   border_color=["$init_border_color",255];
   empty_color="$empty_color";
  );
  nx=modv(x);
  ny=modv(y);
  mx=mini(x);
  my=mini(y);
  "$condition_text"
  color_pos=i(#-1,mx,my,0,0);
  color=(color_pos+1)?[I(#-2,color_pos,0,0),255]:empty_color;
  "$result";"

 if $use_bg_color
  {w#0},{h#0},1,{s#-3+1},"["$bg_color"]"
  j[-1] [-2],.5~,.5~
  rv[0,-1]
  rm[-3--1]
 else
  if !$mode
   r. {w#0},{h#0},1,100%,0,0,.5,.5
  fi
  rv[0,-1]
  rm[-2--1]
 fi

 if $cs
  if $cs!=3
   $convert_colors_bwd[0]
  else
   if s#0==5
    s[0] c,-4 cmyk2rgb[0] a[0,1] c
   else
    cmyk2rgb[0]
   fi
  fi
 fi

endl done

rm.
#@cli rep_compb : eq. to 'rep_complexion_burst' : (+)
rep_compb: rep_complexion_burst $*
#@cli rep_complexion_burst: _points>0,_density>0,_H,_K,_zoom,_rotation_angle,_origin_x,_origin_y,_numbers_extraction_mode={ 0=Individual | 1=Additive },_mode={ 0=C-4 | C=C-6},_f1={ 0=csin | 1=ccos | 2=ctan | 3=clog},...
#@cli : Complex-Plane adaptation of the Pickover Popcorn Fractal. Discovered By Reptorian.\n
#@cli : _points defines the maximum number of points to be added on image based on pixel location.
#@cli : _density defines the frequency of points to be added along row and height of image. A value of one implies n points to be added per pixel.
#@cli : _H is the function multiplier used to subtract from the new found values from each iteration.
#@cli : _K is the inner multiplier for the inside function. See popcorn_x(a,b), and popcorn_y(a,b) embedded within the code of rep_popcorn_fractal for more information.
#@cli : _zoom defines the magnification of image. A negative value will "shrink" the structure of generated fractal.
#@cli : _rotation_angle defines the function angle of fractal.
#@cli : _origin_x defines the position of fractal. Center of image row will be treated as zero, and the ranges for image row are treated as -1,1.
#@cli : _origin_y defines the position of fractal. Center of image column will be treated as zero, and the ranges for image column are treated as -1,1.
#@cli : _mode defines whether to use 4 trigonometric functions or 6 complex-plane trigonometric functions. Each halves of functions are used on 2 functions used by different axis.
#@cli : _fn defines individual function used for the popcorn fractal.\n
#@cli : Author: Reptorian.\n
#@cli : Default values: '_points=50','density=1','H=[.05,1]','_K=[3,1]','_rotation_angle=0','_origin_x=0','_origin_y=0','_mode=0',...\n
#@cli : \ \ \ \ If _mode=0: ... = '_f1=_f3=0','_f2=_f4=2'
#@cli : \ \ \ \ If _mode=1: ... = '_f1=_f4=0','_f2=_f5=1','_f3=_f6=2'\n
rep_complexion_burst:
skip ${1=50},${2=1},${3=[.05,1]},${4=[3,1]},${5=.25},${6=0},${7=0},${8=0},${9=0},${10=1},${11=0},${12=},${13=},${14=},${15=},${16=},${17=}

if $9
 xnew_text=(real_new+imag_new)[0]
 ynew_text=(real_new+imag_new)[1]
else
 xnew_text=(real_new)[0]
 ynew_text=(imag_new)[1]
fi

if ($6-360*floor($6/360))?1
 fvx=((rot_x($xnew_text,$ynew_text)-osx)*icx_zoom+cxsx)/sx
 fvy=((rot_y($xnew_text,$ynew_text)-osy)*icy_zoom+cysy)/sy
else
 fvx=(($xnew_text-osx)*icx_zoom+cxsx)/sx
 fvy=(($ynew_text-osy)*icy_zoom+cysy)/sy
fi

iw={w-1}
ih={h-1}

channels. 0 f. 0

{int(w*abs($2))},{int(h*abs($2))},1,1,":begin_t(
  const nw=w-1;
  const nh=h-1;
  const ww=$iw;
  const hh=$ih;
  const icx=ww/2;
  const icy=hh/2;
  const pts=$1;
  H=$3;
  K=$4;
  const zoom=1/$5;
  const ang=($6/180)*pi;
  const origin_x=$7*-1*zoom;
  const origin_y=$8*zoom;
  const sd=max(w,h)/min(w,h);
  const sx=w>h?sd:1;
  const sy=w>h?1:sd;
  const sx_zoom=sx*zoom;
  const sy_zoom=sy*zoom;
  const cx=(nw-1)/2;
  const cy=(nh-1)/2;
  const osx=origin_x*sx;
  const osy=origin_y*sy;
  const icx_zoom=icx/zoom;
  const icy_zoom=icy/zoom;
  const cxsx=icx*sx;
  const cysy=icy*sy;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  $10?(
   if(narg($11),
    const argpos10=$11%4;
    argpos10==0?func_a(a)=csin(a):
    argpos10==1?func_a(a)=ccos(a):
    argpos10==2?func_a(a)=ctan(a):
    argpos10==3?func_a(a)=clog(a);
    ,func_a(a)=csin(a);
   );
   if(narg($12),
    const argpos11=$12%4;
    argpos11==0?func_b(a)=csin(a):
    argpos11==1?func_b(a)=ccos(a):
    argpos11==2?func_b(a)=ctan(a):
    argpos11==3?func_b(a)=clog(a);
    ,func_b(a)=ccos(a);
   );
   if(narg($13),
    const argpos12=$13%4;
    argpos12==0?func_c(a)=csin(a):
    argpos12==1?func_c(a)=ccos(a):
    argpos12==2?func_c(a)=ctan(a):
    argpos12==3?func_c(a)=clog(a);
    ,func_c(a)=ctan(a);
   );
   if(!narg($14),
    if(narg($11),
     argpos10==0?func_d(a)=csin(a):
     argpos10==1?func_d(a)=ccos(a):
     argpos10==2?func_d(a)=ctan(a):
     argpos10==3?func_d(a)=clog(a);
     ,func_d(a)=csin(a);
    );,
   const argpos13=$14%4;
   argpos13==0?func_d(a)=csin(a):
   argpos13==1?func_d(a)=ccos(a):
   argpos13==2?func_d(a)=ctan(a):
   argpos13==3?func_d(a)=clog(a);
   );
   if(!narg($15),
    if(narg($12),
     argpos11==0?func_e(a)=csin(a):
     argpos11==1?func_e(a)=ccos(a):
     argpos11==2?func_e(a)=ctan(a):
     argpos11==3?func_e(a)=clog(a);
     ,func_e(a)=ccos(a);
    );,
   const argpos14=$15%4;
   argpos14==0?func_e(a)=csin(a):
   argpos14==1?func_e(a)=ccos(a):
   argpos14==2?func_e(a)=ctan(a):
   argpos14==3?func_e(a)=clog(a);
   );
   if(!narg($16),
    if(narg($13),
     argpos12==0?func_f(a)=csin(a):
     argpos12==1?func_f(a)=ccos(a):
     argpos12==2?func_f(a)=ctan(a):
     argpos12==3?func_f(a)=clog(a);
     ,func_f(a)=ctan(a);
    );,
   const argpos15=$16%4;
   argpos15==0?func_f(a)=csin(a):
   argpos15==1?func_f(a)=ccos(a):
   argpos15==2?func_f(a)=ctan(a):
   argpos15==3?func_f(a)=clog(a);
   );
   popcorn_x(a,b)=(Kb=K**b;a-H**func_a(b+func_b(Kb+func_c(Kb))));
   popcorn_y(a,b)=(Ka=K**a;b-H**func_d(a+func_e(Ka+func_f(Ka))));
  ):(
   if(narg($11),
    const argpos10=$11%4;
    argpos10==0?func_a(a)=csin(a):
    argpos10==1?func_a(a)=ccos(a):
    argpos10==2?func_a(a)=ctan(a):
    argpos10==3?func_a(a)=clog(a);
    ,func_a(a)=csin(a);
   );
   if(narg($12),
    const argpos11=$12%4;
    argpos11==0?func_b(a)=csin(a):
    argpos11==1?func_b(a)=ccos(a):
    argpos11==2?func_b(a)=ctan(a):
    argpos11==3?func_b(a)=clog(a);
    ,func_b(a)=ctan(a);
   );
   if(!narg($13),
    if(narg($11),
     argpos10==0?func_c(a)=csin(a):
     argpos10==1?func_c(a)=ccos(a):
     argpos10==2?func_c(a)=ctan(a):
     argpos10==3?func_c(a)=clog(a);
     ,func_c(a)=csin(a);
    );,
   const argpos12=$13%4;
   argpos12==0?func_c(a)=csin(a):
   argpos12==1?func_c(a)=ccos(a):
   argpos12==2?func_c(a)=ctan(a):
   argpos12==3?func_c(a)=clog(a);
   );
   if(!narg($14),
    if(narg($12),
     argpos11==0?func_d(a)=csin(a):
     argpos11==1?func_d(a)=ccos(a):
     argpos11==2?func_d(a)=ctan(a):
     argpos11==3?func_d(a)=clog(a);
     ,func_d(a)=ctan(a);
    );,
   const argpos13=$14%4;
   argpos13==0?func_d(a)=csin(a):
   argpos13==1?func_d(a)=ccos(a):
   argpos13==2?func_d(a)=ctan(a):
   argpos13==3?func_d(a)=clog(a);
   );
   popcorn_x(a,b)=a-H**func_a(b+func_b(K**b));
   popcorn_y(a,b)=b-H**func_c(a+func_d(K**a));
  );
 );
 real=sx_zoom*(x-cx)/cx;
 imag=sy_zoom*(y-cy)/cy;
 real+=origin_x;
 imag+=origin_y;
 zr=[real,0];
 zi=[0,imag];
 repeat(pts,
  real_new=popcorn_x(zr,zi);
  imag_new=popcorn_y(zr,zi);
  zn=sum(sqr((real_new)[0]),sqr((imag_new)[1]));
  real_new/=zn;
  imag_new/=zn;
  real_val="$fvx";
  imag_val="$fvy";
  rpos=round(real_val);
  ipos=round(imag_val);
  i(#-1,rpos,ipos)++;
  zr=real_new;
  zi=imag_new;
 );"
rm.
#@cli rep_rainbowify: -360<_hue_shift<360,-360<_gradient_angle<360,_gradient_scale[%]>0
#@cli : Apply rainbowify effect into image. Inspired by Rainbowify effect made by Jonathan Frech. The original source of the Rainbowify effect is found in the following URL - https://blog.jfrech.com/180/.
#@cli : Default values: '_hue_shift=0','_gradient_angle=0','_gradient_angle=100%'
#@cli : Author: Reptorian.
rep_rainbowify:
skip ${1=0},${2=0},${3=100%}
repeat $! l[$>]
 if s>4 continue fi
 if s==4 sh 0,2 fi

 if s<3
  m "rainbowify : {w},{h},100%,{s==2?4:3},\"$""1\""
  m "end_out : k."
  calc_v="i(#0,x,y,z,0)"
 else
  m "rainbowify : fill. \"$""1\""
  m "end_out : k[0]"
  calc_v=avg(I)
 fi

 if s==2 calc_rainbow="[hue2rgb(fmod(v+pos+shift_hue)),i(#0,x,y,z,1)]"
 else calc_rainbow=hue2rgb(fmod(v+pos+shift_hue))
 fi

 rainbowify. "begin(
  const shift_hue=$1+180;
  const ang=($2/180)*pi;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  const sd=max(w,h)/min(w,h);
  const sx=w>h?sd:1;
  const sy=w>h?1:sd;
  const ww=w-1;
  const hh=h-1;
  const cx=ww/2;
  const cy=hh/2;
  const cxsx=cx/sx;
  const cysy=cy/sy;
  const m=360/255;
  const rescale_pos=180*$3;
  fmod(a)=a-360*floor(a/360);
  hue2rgb(h)=(
   H=(h/60)%6;
   K=(1-abs(H%2-1))*255;
   arg(1+int(H),[255,K,0],[K,255,0],[0,255,K],[0,K,255],[K,0,255],[255,0,K]);
  );
 );
 px=(x-cx)/cxsx;
 py=(y-cy)/cysy;
 pos=rot_y(px,py)*rescale_pos;
 v="$calc_v"*m;
 "$calc_rainbow";
 "

 end_out

 um rainbowify,end_out

endl done
#@cli rep_w_rgb82gray: eq. to 'rep_weighted_rgb82gray' : (+)
rep_w_rgb82gray: rep_weighted_rgb82gray $*
#@cli rep_weighted_rgb82gray: 0%<=red_weight<=100%,0%<=green_weight<=100%,0%<=blue_weight<=100%,_use_weighted_ratio={ 0=no | 1= yes },0<=_minval_weight[%]<=100%,,0<=_maxval_weight[%]<=100%,,0<=_balance_minmax<=1,0<=_endvaladj<=255,-1<=_midgrayadj<=1
#@cli : Convert images to grayscale image based on different weights, the usage of min/max val, and post-process value adjustment.
#@cli : Default values: '_use_weighted_ratio=1','_minval_weight=0%','_maxval_weight=0%','_balance_minmax=50%','_endvaladj=0','_midgrayadj=0'
#@cli : Author: Reptorian.
#@cli : $ sp car rep_weighted_rgb82gray 10%,50%,70%,,,,,,-.25
rep_weighted_rgb82gray:
skip ${4=1},${5=0%},${6=0%},${7=50%},${8=0},${9=0}
use_merge_back=0

single_channel_mode=0

repeat $! l[$>]

 if s==4
  split_opacity
  store. alpha_image
  use_merge_back=1
 elif s==2
  split_opacity
  store. alpha_image
  use_merge_back=1
 elif s>4 continue
 fi

 if s==1
  m "calc_gray_image : fill. \"$""1\""
  single_channel_mode=1
 else
  m "calc_gray_image : {w},{h},100%,1,\"$""1\""
 fi

 calc_gray_image "begin(
  const red_weight_init=$1;
  const green_weight_init=$2;
  const blue_weight_init=$3;
  const total_weight=red_weight_init+green_weight_init+blue_weight_init;
  if($4,
   const red_weight=red_weight_init/total_weight;
   const green_weight=green_weight_init/total_weight;
   const blue_weight=blue_weight_init/total_weight;
  ,
   const red_weight=red_weight_init;
   const green_weight=green_weight_init;
   const blue_weight=blue_weight_init;
  );
  rescale_color=[red_weight,green_weight,blue_weight];
  (!$5&&!$6)?(
   calc_gray()=sum(I#-1*rescale_color);
  ):
  $5&&$6?(
   calc_gray()=(
    col_ref=I#-1;
    start_col_ref=col_ref*rescale_color;
    minval=cut(lerp(sum(start_col_ref),min(col_ref),$5),0,255);
    maxval=cut(lerp(sum(start_col_ref),max(col_ref),$6),0,255);
    balval=lerp(minval,maxval,$7);
   );
  ):(
   $6?(
    calc_gray()=(
     col_ref=I#-1;
     start_col_ref=col_ref*rescale_color;
     maxval=cut(lerp(sum(start_col_ref),max(col_ref),$6),0,255);
    );
   ):(
    calc_gray()=(
     col_ref=I#-1;
     start_col_ref=I#-1*rescale_color;
     minval=cut(lerp(sum(start_col_ref),min(col_ref),$5),0,255);
    );
   );
  );
  abs($9)?(
   calc_gray_output()=cut(calc_gray(),0,255);
  ):(
   calc_gray_output()=cut(calc_gray()+$8,0,255);
  );
 );
 calc_gray_output();"

 if abs($9)
  if $9>0
   f. "begin(
    const expf=cut(1-abs($9),0,1);
   );
   cut(((i/255)^expf)*255+$8,0,255)"
  else
   f. "begin(
    const expf=cut(1-abs($9),0,1);
   );
   cut(255-(((255-i)/255)^expf)*255+$8,0,255)"
  fi
 fi

 if !$single_channel_mode
  k.
  if $use_merge_back
   $alpha_image a c
  fi
 fi

 use_merge_back=0

 um calc_gray_image
endl done
#@cli rep_hex2int8: hexadecimal_string
#@cli : Convert a hexadecimal argument into 8-bit representation, and then return the converted value.
#@cli :
#@cli : Author: Reptorian.
rep_hex2int8:
strlowercase $1

('${}')

{int(w/2)},1,1,1,"begin(
 from_char(v)=v>=48&&v<=57?v-48:v-87;
 );
 p=x*2;
 from_char(i(#-1,p))*16+from_char(i(#-1,p+1));"

u {crop(#-1)} rm[-2,-1]
#@cli rep_int82hex: 0<=8-bit_value<=255...
#@cli : Convert 8-bit numberical argument(s) into hexadecimal representation, and then return the converted value.
#@cli :
#@cli : Author: Reptorian.
rep_int82hex:
{narg($*)*2},1,1,1,"begin(
  vchar=[$*];
  to_char(v)=v>=0&&v<=9?48+v:87+v;
 );
 p=int(x/2);
 x%2?(
  to_char(int(vchar[p]%16));
 ):(
  to_char(int(vchar[p]/16));
 );"

u {t} rm.
#@cli rep_mlfrac_anim: eq. to 'rep_markus_lyapunov_fractal_animation : (+)
rep_mlfrac_anim: rep_markus_lyapunov_fractal_animation $*
#@cli rep_markus_lyapunov_fractal_animation: abc_string,abc_string_repeats,_sublevel>=0,0%<_view_size[%]<=100%,0%<=_pos_x[%]<=100%,0%<=_pos_y[%]<=100%,0%<=_pos_z_a[%]<=100%,0%<=_pos_z_b[%]<=100%,additional_arguments(see below)
#@cli : Generate an animation of Markus-Lyapunov Fractal or in other words, creates an animation demonstrating mapping of Lyapunov exponent within three values. Each frame represent a cross-section of a 3D Markus-Lyapunov Fractal.
#@cli :
#@cli : [1] http://charles.vassallo.pagesperso-orange.fr/en/lyap_art/lyapdoc.html
#@cli :
#@cli : (eq. to 'rep_mlfrac_anim')
#@cli : Note: Input for abc_string is case-insensitive. Only valid characters are A,a,B,b,C,c.
#@cli : Additional note: Depth of target image defines number of frames.
#@cli :
#@cli : --- Information on 'additional_arguments' ---
#@cli : The following set of arguments are accepted as additional arguments for the command:
#@cli :
#@cli : 1 - use_inversion={ 0=do_not_use_inversion | 1=use_inversion }
#@cli : 2* - hex_color_a,hex_color_b
#@cli : 3** - 'u',color_count>0,color_space={ 0=hsl | 1=lab | 2=lch }
#@cli : 4** - 'u','u',n_colors_a>0,n_colors_b>0,cs={ 0=hsl | 1=lab | 2=lch }
#@cli : 5*** - [image],order={ 0=default | 1=random | 2=mirrored },color_count
#@cli : 6*** - [image],[image],order_a={ 0=default | 1=random | 2=mirrored },use_randomize_b={ 0=default | 1=random | 2=mirrored },color_count_a,color_count_b
#@cli :
#@cli : * = No special characters or space! Only 0-9 and a-f case-insensitive.
#@cli : ** = 'u' means that the input you assigned is exactly 'u'.
#@cli : *** = If you assign a image with width and height both larger than 1, then you need to assign color_count in the respective place. use_randomize is used to randomize the colors in palette.
#@cli :
#@cli : Notes: See examples for usage of these additional variables.
#@cli :
#@cli : --- End of Information on 'additional_arguments' ---
#@cli : Default values: '_sublevel=1','_view_size=100%','_pos_x=50%','_pos_y=50%'
#@cli :
#@cli : Author: Reptorian.
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,1
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,0000ff,ffff00
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,u,8,1
#@cli : $ 50,50,50 rep_markus_lyapunov_fractal_animation abc,50,.5,100%,50%,50%,0%,100%,u,u,5,8,2
#@cli : $ 50,50,50 +pal 71 rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[1],0 rm.
#@cli : $ 50,50,50 +pal 20 +pal 50 rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[1],[2],0,0 rm[-2,-1]
#@cli : $ 50,50,50 sp cat rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[1],0,9 rm.
#@cli : $ 50,50,50 sp cat sp lena rep_markus_lyapunov_fractal_animation[0] abc,50,.5,100%,50%,50%,0%,100%,[-2],[-1],1,1,8,8 rm[-2,-1]
rep_markus_lyapunov_fractal_animation:
skip "${3=1}","${4=100%}","${5=50%}","${6=50%}","${7=0%}","${8=100%}","${9=0}","${10=}","${11=}","${12=}","${13=}","${14=}"
check (abs($4)!=0)&&($!==1)&&(w#-1>1&&h#-1>1&&d#-1>1)

strlowercase $1
ab_string=${}
('$ab_string') -. 97

include_a={im#-1==0}
include_b={find(crop(#-1),1,0,1)!=-1}
include_c={iM#-1==2}

if im#-1<0||iM#-1>2 error invalid_char_found! fi
if !($include_a&&$include_b&&$include_c) error invalid_string fi

ab_string={crop(#-1)}
rm.

mode=0
use_double_u=0
use_hex_mode=0

sub={abs($3)+1}

ow={w}
oh={h}
od={d}
nw={round(w*$sub)}
nh={round(h*$sub)}

if narg($9)||narg($10)

 if ${is_image_arg\ $9} mode+=1
  pass$9 0
 fi
 if ${is_image_arg\ $10} mode+=1
  pass$10 0
 fi

 if $mode==2

  if w#-2>1&&h#-2>1
   colormap.. $13
   if ($11%3)==1
    {w#-2},1,1,1,u(0,1)
    pixelsort... +,x,[-1]
    rm.
   elif ($11%3)==2
    mirror.. x
   fi
   find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
  else
   if w#-2>1
    if ($11%3)==1
     {w#-2},1,1,1,u(0,1)
     pixelsort... +,x,[-1]
     rm.
    elif ($11%3)==2
     mirror.. x
    fi
    find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
   else
    if ($11%3)==1
     1,{h#-2},1,1,u(0,1)
     pixelsort... +,y,[-1]
     rm.
    elif ($11%3)==2
     mirror.. y
    fi
    find_color_a=I(#-1,0,lyapunov_surface/minv*v_length_b,0,1);
   fi
  fi

  if w#-1>1&&h#-1>1
   colormap. $14
   if ($12%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($12%3)==2
    mirror. x
   fi
   find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
  else
   if w#-1>1
    if ($12%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($12%3)==2
     mirror. x
    fi
    find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
   else
    if ($12%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($12%3)==2
     mirror. y
    fi
    find_color_b=I(#-2,0,lyapunov_surface/maxv*v_length_a,0,1);
   fi
  fi

  store. ref_colors_b
  store. ref_colors_a

 elif $mode==1

  if w>1&&h>1
   colormap. $11
   if ($10%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($10%3)==2
    mirror. x
   fi
   find_color_a=I(#-1,lyapunov_surface,0,0,1)
  else
   if w>1
    if ($10%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($10%3)==2
     mirror. x
    fi
    find_color_a=I(#-1,lyapunov_surface,0,0,1)
   else
    if ($10%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($10%3)==2
     mirror. y
    fi
    find_color_a=I(#-1,0,lyapunov_surface,0,1)
   fi
  fi
  store. ref_gradient

 else

  if ('$9'=='u')&&('$10'=='u')

   mode=3
   use_double_u=1
   if narg($11)&&narg($12)
    if narg($13)
     if ($13%3)==2 m "cs_out: lch82rgb"
     elif ($13%3)==1 m "cs_out: lab82rgb"
     else m "cs_out: hsl82rgb"
     fi
    else m "cs_out: hsl82rgb"
    fi
    $11,1,1,3,u(0,255)
    $12,1,1,3,u(0,255)
    store. ref_rand_col_a
    store. ref_rand_col_b
   else error needs size_arg
   fi

  else

   if ('$9'=='u')||('$10'=='u')
    mode=3
    if narg($11)
     if ($11%3)==2 m "cs_out: lch82rgb"
     elif ($11%3)==1 m "cs_out: lab82rgb"
     else m "cs_out: hsl82rgb"
     fi
    else m "cs_out: hsl82rgb"
    fi
    if narg($12) srand $12 fi
    if '$9'=='u'
     $10,1,1,3,u(0,255)
     store. ref_colors
    else
     $9,1,1,3,u(0,255)
     store. ref_colors
    fi
   else
    if (!(size('$9')%2))&&(!(size('$10')%2))
     use_hex_mode=1
     hex_color_a=${rep_hex2int8\ $9}
     hex_color_b=${rep_hex2int8\ $10}
    fi
   fi
  fi
 fi
fi

out_lyapunov=limit
if !$mode&&!$use_hex_mode if $9 out_lyapunov=-limit fi fi

$nw,$nh,100%,1,":begin(
  const sqr_size=cut(abs($4),0,1);
  const gap=1-sqr_size;
  const px=cut($5,0,1)*gap;
  const py=cut($6,0,1)*gap;
  const pz_a_init=cut($7,0,1);
  const pz_b_init=cut($8,0,1);
  const pz_a=min(pz_a_init,pz_b_init)*2+2;
  const pz_b=max(pz_a_init,pz_b_init)*2+2;
  const lx=px*2+2;
  const ly=py*2+2;
  const rx=(px+sqr_size)*2+2;
  const ry=(py+sqr_size)*2+2;
  const inc_w=w+1;
  const inc_h=h+1;
  const inc_d=d+1;

  v_sequence=["$ab_string"];
  const seqsize=size(v_sequence);
  const vsize=round(max(1,abs($2))*seqsize);
 );
 ix=lerp(lx,rx,(x+1)/inc_w);
 iy=lerp(ry,ly,(y+1)/inc_h);
 iz=lerp(pz_a,pz_b,(z+1)/inc_d);
 vn=0.5;
 limit=0;
 repeat(vsize,n,
  sp = n % seqsize;
  rn=arg(v_sequence[sp]+1,ix,iy,iz);
  vn=rn*vn*(1-vn);
  limit+=log(abs(rn*(1-2*vn)));
 );
 "$out_lyapunov";
 "

if $mode==3

 if $use_double_u
  $ref_rand_col_a
  $ref_rand_col_b
  $nw,$nh,$od,3,"begin_t(
    const minv=im#-3;
    const maxv=iM#-3;
    const ww_a=w#-2-1;
    const ww_b=w#-1-1;
   );
   lyapunov_surface=i0#-3;
   use_b=lyapunov_surface>=0;
   use_b?(I(#-1,lyapunov_surface/maxv*ww_b,0,0,1);)
        :(I(#-2,lyapunov_surface/minv*ww_a,0,0,1););
   "
   cs_out.
 else
  $ref_colors
  $nw,$nh,$od,3,"begin(
   const minv=im#-2;
   const maxv=iM#-2;
   const vs=w#-1-1;
   const diff=(maxv-minv)/vs;
  );
  lyapunov_surface=(i0#-2-minv)/diff;
  I(#-1,lyapunov_surface,0,0,1);
  "
  cs_out.
 fi

elif $mode==2

 $ref_colors_a
 $ref_colors_b
 $nw,$nh,$od,{max(s#-2,s#-1)},"begin_t(
   const minv=im#-3;
   const maxv=iM#-3;
   const v_length_a=max(w#-2-1,h#-2-1);
   const v_length_b=max(w#-1-1,h#-2,-1);
  );
  lyapunov_surface=i0#-3;
  use_b=lyapunov_surface>=0;
  use_b?("$find_color_b")
       :("$find_color_a");
  "

elif $mode==1

 $ref_gradient
 $nw,$nh,$od,{s#-1},"begin_t(
   const minv=im#-2;
   const maxv=iM#-2;
   const v_length=max(w#-1-1,h#-1-1);
   const diff=(maxv-minv)/v_length;
  );
  lyapunov_surface=(i0#-2-minv)/diff;
  "$find_color_a";
  "

elif $use_hex_mode
  $nw,$nh,$od,3,"begin_t(

   hex_a=["$hex_color_a"];
   hex_b=["$hex_color_b"];

   const minv=im#-1;
   const maxv=iM#-1;

   const hpi=pi/2;

   contrast(a)=(
    b=a*pi-hpi;
    .5*a^2+.5*(sin(b)+1)/2;
   );
  );
  v=i0#-1;
  shade=v>=0?v/maxv:contrast((1-(v/minv)^(1/2)))^2;
  col=v>=0?hex_a:hex_b;
  col*shade;
 "
fi
k.
s z r $ow,$oh,1,100%,6
um cs_out
#@cli rep_mlfrac: eq. to 'rep_markus_lyapunov_fractal : (+)
rep_mlfrac: rep_markus_lyapunov_fractal $*
#@cli rep_markus_lyapunov_fractal: abc_string,abc_string_repeats,_sublevel>=0,0%<_view_size[%]<=100%,0%<=_pos_x[%]<=100%,0%<=_pos_y[%]<=100%,0%<=_pos_z[%]<=100%,additional_arguments(see below)
#@cli : Generate Markus-Lyapunov Fractal or in other words, creates a mapping of Lyapunov exponent within two or three values.[1] Discovered by Mario Markus of the Max Planck Institute for Nutrition. Alexander Lyapunov was the one that discovered Lyapunov exponent.
#@cli :
#@cli : [1] http://charles.vassallo.pagesperso-orange.fr/en/lyap_art/lyapdoc.html
#@cli :
#@cli : (eq. to 'rep_mlfrac')
#@cli : Note: Input for abc_string is case-insensitive. Only valid characters are A,a,B,b,C,c.
#@cli :
#@cli : --- Information on 'additional_arguments' ---
#@cli : The following set of arguments are accepted as additional arguments for the command:
#@cli :
#@cli : 1 - use_inversion={ 0=do_not_use_inversion | 1=use_inversion }
#@cli : 2* - hex_color_a,hex_color_b
#@cli : 3** - 'u',color_count>0,color_space={ 0=hsl | 1=lab | 2=lch }
#@cli : 4** - 'u','u',n_colors_a>0,n_colors_b>0,cs={ 0=hsl | 1=lab | 2=lch }
#@cli : 5*** - [image],order={ 0=default | 1=random | 2=mirrored },color_count
#@cli : 6*** - [image],[image],order_a={ 0=default | 1=random | 2=mirrored },use_randomize_b={ 0=default | 1=random | 2=mirrored },color_count_a,color_count_b
#@cli :
#@cli : * = No special characters or space! Only 0-9 and a-f case-insensitive.
#@cli : ** = 'u' means that the input you assigned is exactly 'u'.
#@cli : *** = If you assign a image with width and height both larger than 1, then you need to assign color_count in the respective place. use_randomize is used to randomize the colors in palette.
#@cli :
#@cli : Notes: See examples for usage of these additional variables.
#@cli :
#@cli : --- End of Information on 'additional_arguments' ---
#@cli : Default values: '_sublevel=1','_view_size=100%','_pos_x=50%','_pos_y=50%'
#@cli :
#@cli : Author: Reptorian.
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,1
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,0000ff,ffff00
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,u,8,1
#@cli : $ 500,500 rep_markus_lyapunov_fractal ab,50,3,100%,50%,50%,50%,u,u,5,8,2
#@cli : $ 500,500 +pal 71 rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[1],0 rm.
#@cli : $ 500,500 +pal 20 +pal 50 rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[1],[2],0,0 rm[-2,-1]
#@cli : $ 500,500 sp cat rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[1],0,9 rm.
#@cli : $ 500,500 sp cat sp lena rep_markus_lyapunov_fractal[0] ab,50,3,100%,50%,50%,50%,[-2],[-1],1,1,8,8 rm[-2,-1]
rep_markus_lyapunov_fractal:
skip "${3=1}","${4=100%}","${5=50%}","${6=50%}","${7=50%}","${8=0}","${9=}","${10=}","${11=}","${12=}","${13=}"
check "abs($4)!=0"

strlowercase $1
ab_string=${}
('$ab_string') -. 97

if im#-1<0||iM#-1>2 error invalid_char_found! fi

include_a={im#-1==0}
include_b={find(crop(#-1),1,0,1)!=-1}
include_c={iM#-1==2}

case_d1={!($include_a&&$include_b)}
case_dn={!(!$case_d1&&$include_c)}

ab_string={crop(#-1)}
rm.

mode=0
use_double_u=0
use_hex_mode=0

sub={abs($3)+1}

if narg($8)||narg($9)

 if ${is_image_arg\ $8} mode+=1
  pass$8 0
 fi
 if ${is_image_arg\ $9} mode+=1
  pass$9 0
 fi

 if $mode==2

  if w#-2>1&&h#-2>1
   colormap.. $12
   if ($10%3)==1
    {w#-2},1,1,1,u(0,1)
    pixelsort... +,x,[-1]
    rm.
   elif ($10%3)==2
    mirror.. x
   fi
   find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
  else
   if w#-2>1
    if ($10%3)==1
     {w#-2},1,1,1,u(0,1)
     pixelsort... +,x,[-1]
     rm.
    elif ($10%3)==2
     mirror.. x
    fi
    find_color_a=I(#-1,lyapunov_surface/minv*v_length_b,0,0,1);
   else
    if ($10%3)==1
     1,{h#-2},1,1,u(0,1)
     pixelsort... +,y,[-1]
     rm.
    elif ($10%3)==2
     mirror.. y
    fi
    find_color_a=I(#-1,0,lyapunov_surface/minv*v_length_b,0,1);
   fi
  fi

  if w#-1>1&&h#-1>1
   colormap. $13
   if ($11%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($11%3)==2
    mirror. x
   fi
   find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
  else
   if w#-1>1
    if ($11%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($11%3)==2
     mirror. x
    fi
    find_color_b=I(#-2,lyapunov_surface/maxv*v_length_a,0,0,1);
   else
    if ($11%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($11%3)==2
     mirror. y
    fi
    find_color_b=I(#-2,0,lyapunov_surface/maxv*v_length_a,0,1);
   fi
  fi

  store. ref_colors_b
  store. ref_colors_a

 elif $mode==1

  if w>1&&h>1
   colormap. $10
   if ($9%3)==1
    {w},1,1,1,u(0,1)
    pixelsort.. +,x,[-1]
    rm.
   elif ($9%3)==2
    mirror. x
   fi
   find_color_a=I(#-1,lyapunov_surface,0,0,1)
  else
   if w>1
    if ($9%3)==1
     {w},1,1,1,u(0,1)
     pixelsort.. +,x,[-1]
     rm.
    elif ($9%3)==2
     mirror. x
    fi
    find_color_a=I(#-1,lyapunov_surface,0,0,1)
   else
    if ($9%3)==1
     1,{h},1,1,u(0,1)
     pixelsort.. +,y,[-1]
     rm.
    elif ($9%3)==2
     mirror. y
    fi
    find_color_a=I(#-1,0,lyapunov_surface,0,1)
   fi
  fi
  store. ref_gradient

 else

  if ('$8'=='u')&&('$9'=='u')

   mode=3
   use_double_u=1
   if narg($10)&&narg($11)
    if narg($12)
     if ($12%3)==2 m "cs_out: lch82rgb"
     elif ($12%3)==1 m "cs_out: lab82rgb"
     else m "cs_out: hsl82rgb"
     fi
    else m "cs_out: hsl82rgb"
    fi
    $10,1,1,3,u(0,255)
    $11,1,1,3,u(0,255)
    store. ref_rand_col_a
    store. ref_rand_col_b
   else error needs size_arg
   fi

  else

   if ('$8'=='u')||('$9'=='u')
    mode=3
    if narg($10)
     if ($10%3)==2 m "cs_out: lch82rgb"
     elif ($10%3)==1 m "cs_out: lab82rgb"
     else m "cs_out: hsl82rgb"
     fi
    else m "cs_out: hsl82rgb"
    fi
    if narg($11) srand $11 fi
    if '$8'=='u'
     $9,1,1,3,u(0,255)
     store. ref_colors
    else
     $8,1,1,3,u(0,255)
     store. ref_colors
    fi
   else
    if (!(size('$8')%2))&&(!(size('$9')%2))
     use_hex_mode=1
     hex_color_a=${rep_hex2int8\ $8}
     hex_color_b=${rep_hex2int8\ $9}
    fi
   fi
  fi
 fi
fi

out_lyapunov=limit
if !$mode&&!$use_hex_mode if $8 out_lyapunov=-limit fi fi

repeat $! l[$>]

 ow={w}
 oh={h}
 od={d}
 nw={round(w*$sub)}
 nh={round(h*$sub)}
 nd={d>1?d*$sub:1}

 if d>1

  if $case_dn error "At least one of the abc character is not found!" fi

  pz_text="const pz=cut($7,0,1)*gap;"
  lz_text="const lz=pz*2+2;"
  rz_text="const rz=(pz+sqr_size)*2+2;"
  inc_d="const inc_d=d+1;"
  calc_iz_text="iz=lerp(lz,rz,(z+1)/inc_d);"

 else

  if $case_d1 error "At least one of the ab character is not found!" fi

  const_iz_text="const iz=lerp(2+1/(max(w,h,d)+1),2+max(w,h,d)/(max(w,h,d)+1)*2,$7);"

 fi

 $nw,$nh,$nd,1,":begin_t(

  const sqr_size=cut(abs($4),0,1);
  const gap=1-sqr_size;
  const px=cut($5,0,1)*gap;
  const py=cut($6,0,1)*gap;
  "$pz_text"
  const lx=px*2+2;
  const ly=py*2+2;
  "$lz_text"
  const rx=(px+sqr_size)*2+2;
  const ry=(py+sqr_size)*2+2;
  "$rz_text"
  const inc_w=w+1;
  const inc_h=h+1;
  "$inc_d"
  "$const_iz_text"

  v_sequence=["$ab_string"];
  const seqsize=size(v_sequence);
  const vsize=round(max(1,abs($2))*seqsize);

 );
 ix=lerp(lx,rx,(x+1)/inc_w);
 iy=lerp(ry,ly,(y+1)/inc_h);
 "$calc_iz_text"
 vn=0.5;
 limit=0;
 repeat(vsize,n,
  sp = n % seqsize;
  rn=arg(v_sequence[sp]+1,ix,iy,iz);
  vn=rn*vn*(1-vn);
  limit+=log(abs(rn*(1-2*vn)));
 );
 "$out_lyapunov";
 "

 if $mode==3

  if $use_double_u
   $ref_rand_col_a
   $ref_rand_col_b
   $nw,$nh,$nd,3,"begin_t(
     const minv=im#-3;
     const maxv=iM#-3;
     const ww_a=w#-2-1;
     const ww_b=w#-1-1;
    );
    lyapunov_surface=i0#-3;
    use_b=lyapunov_surface>=0;
    use_b?(I(#-1,lyapunov_surface/maxv*ww_b,0,0,1);)
         :(I(#-2,lyapunov_surface/minv*ww_a,0,0,1););
    "
    cs_out.
  else
   $ref_colors
   $nw,$nh,$nd,3,"begin(
    const minv=im#-2;
    const maxv=iM#-2;
    const vs=w#-1-1;
    const diff=(maxv-minv)/vs;
   );
   lyapunov_surface=(i0#-2-minv)/diff;
   I(#-1,lyapunov_surface,0,0,1);
   "
   cs_out.
  fi

 elif $mode==2

  $ref_colors_a
  $ref_colors_b
  $nw,$nh,$nd,{max(s#-2,s#-1)},"begin_t(
    const minv=im#-3;
    const maxv=iM#-3;
    const v_length_a=max(w#-2-1,h#-2-1);
    const v_length_b=max(w#-1-1,h#-2,-1);
   );
   lyapunov_surface=i0#-3;
   use_b=lyapunov_surface>=0;
   use_b?("$find_color_b")
        :("$find_color_a");
   "

 elif $mode==1


  $ref_gradient
  $nw,$nh,$nd,{s#-1},"begin_t(
    const minv=im#-2;
    const maxv=iM#-2;
    const v_length=max(w#-1-1,h#-1-1);
    const diff=(maxv-minv)/v_length;
   );
   lyapunov_surface=(i0#-2-minv)/diff;
   "$find_color_a";
   "

 elif $use_hex_mode
   $nw,$nh,$nd,3,"begin_t(

    hex_a=["$hex_color_a"];
    hex_b=["$hex_color_b"];

    const minv=im#-1;
    const maxv=iM#-1;

    const hpi=pi/2;

    contrast(a)=(
     b=a*pi-hpi;
     .5*a^2+.5*(sin(b)+1)/2;
    );
   );
   v=i0#-1;
   shade=v>=0?v/maxv:contrast((1-(v/minv)^(1/2)))^2;
   col=v>=0?hex_a:hex_b;
   col*shade;
  "
 fi

 r. $ow,$oh,$od,100%,6
 k.

 pz_text=""
 lz_text=""
 rz_text=""
 inc_d=""
 calc_iz_text=""
 const_iz_text=""
endl done

um cs_out

u {$include_c+1}
#@cli rep_randgradbar : eq. to 'rep_random_gradient_bars' : (+)
rep_randgradbar:rep_random_gradient_bars $*
#@cli rep_random_gradient_bars: width>0,spacing>0,-360<=_angle<=360,-90<_skew_angle<90,-1<=_pos_x<=1,-1<=_pos_y<=1,_sublevel>=0,_gradient_shift,_gradient_mul_a,gradient_mul_b,_bar_modulo={ -1=random | 0=cut | 1=periodic | 2=continuous },_random_modulo_out={ 0=cut_and_periodic | 1=cut_and_continuous | 2=periodic_and_continuous },_gradient_color={ 0=B&W | 1=Duotone | 2=Rand-RGB | 3=Rand-HSV },_space_color={ 0=Alpha | 1=Binary Duotone | 2=Gradient Duotone },_symmetry_mode={ 0=none | 1=sym_a | 2=sym_b },_inversion_mode={ 0=n/a | 1=random-inverse | 2=complete-inverse},_bar_hex_rgb_color_a,_bar_hex_rgb_color_b : width>0,spacing>0,-360<=_angle<=360,-90<_skew_angle<90,-1<=_pos_x<=1,-1<=_pos_y<=1,_sublevel>=0,_gradient_shift,_gradient_mul_a,gradient_mul_b,_bar_modulo={ -1=random | 0=cut | 1=periodic | 2=continuous },_random_modulo_out={ 0=cut_and_periodic | 1=cut_and_continuous | 2=periodic_and_continuous },_gradient_color={ 0=B&W | 1=Duotone | 2=Rand-RGB | 3=Rand-HSV },_space_color={ 0=Alpha | 1=Binary Duotone | 2=Gradient Duotone },_symmetry_mode={ 0=none | 1=sym_a | 2=sym_b },_inversion_mode={ 0=n/a | 1=random-inverse | 2=complete-inverse},red_1,green_1,blue_1,red_2,green_2,blue_3
#@cli : Create image filled with random bars.
#@cli :
#@cli : (eq. to 'rep_randgradbar')
rep_random_gradient_bars:
skip ${3=0},${4=0},${5=0},${6=0},${7=1},${8=0},${9=1},${10=100},${11=-1},${12=},${13=0},${14=0},${15=0},${16=0},${17=000000},${18=ffffff}
check "(abs($4)<90)&&((narg($*)==22)||(narg($*)==18))"

sub={abs($7)+1}

if narg(${17--1})==2
 color_a=${rep_hex2int8\ $17}
 color_b=${rep_hex2int8\ $18}
else
 color_a=${17-19}
 color_b=${20-22}
fi

repeat $! l[$>]
 ow={w}
 oh={h}
 {w*$sub},{h*$sub},1,{$13?4:2},"*begin(
   const ww=w-1;
   const hh=h-1;
   const sd=max(ww,hh)/min(ww,hh);
   const sx=ww>hh?sd:1;
   const sy=ww>hh?1:sd;
   eucl_norm(a,b)=sqrt(a^2+b^2);
   const diag_img=eucl_norm(ww,hh);
   const ww_div_sx=ww/sx;
   const hh_div_sy=hh/sy;
   const cx=ww/2;
   const cy=hh/2;
   const ox=cx-(ww*-$5);
   const oy=cy-(hh*$6);
   const skew_ang=-($4/180)*pi;
   const mdist=tan(skew_ang)*diag_img;
   const ang=-($3/180)*pi;
   const cos_ang=cos(ang);
   const sin_ang=sin(ang);
   const cut_ang=atan2(cy,cx);
   const cut_ang2=pi-cut_ang;
   const symmetry_mode=$15%3;
   const inversion_mode=($16+2)%3;

   "${is_percent\ $1}"?(
    const bar_width=max($sub,round((abs($1)*diag_img/4)));
   ):(
    const bar_width=max($sub,round(abs($1)*$sub));
   );
   "${is_percent\ $2}"?(
    const space_width=abs($2)>0?max($sub,round((abs($2)*diag_img/4)));
   ):(
    const space_width=round(abs($2)*$sub);
   );
   const total_width=bar_width+space_width;
   const half_total_width=total_width>1?int(total_width/2);

   (bar_width==1&&space_width<2)?(
    const spacing=space_width>0?.5:0;
    abs(space_width)?(calc_spacing()=int(point_x)%2?1;):(calc_spacing()=1;);
   ):(
    const spacing=1-(space_width/(total_width-1));
    calc_spacing()=abs(1-fmod(point_x,total_width)/total_width-.5)*2<=spacing;
   );

   rot_x(a,b)=a*cos_ang-b*sin_ang;
   rot_y(a,b)=a*sin_ang+b*cos_ang;
   fmod(a,b)=a-b*floor(a/b);
   fmod_cont(a,b)=floor(a/b)%2?b-fmod(a,b):fmod(a,b);
   fcut(a,b)=(cut(a,-b,b)+b)/2;

   const number_of_bars=ceil(eucl_norm(ww,hh)/total_width);
   const shift_bars=int(number_of_bars/2);

   symmetry_mode==1?(calc_bar()=(-1*abs(floor(point_x/total_width))+shift_bars)%number_of_bars;):
   symmetry_mode==2?(calc_bar()=(abs(floor(point_x/total_width))+shift_bars)%number_of_bars;):
                    (calc_bar()=(floor(point_x/total_width)+shift_bars)%number_of_bars;);

   v_mult=expr('u($9,$10)',number_of_bars,1,1,1);
   $8!=0?v_shift=expr('u(-$8,$8)',number_of_bars,1,1,1):v_shift=vectornumber_of_bars(0);

   v_use_invert=expr('round(u(0,1))',number_of_bars,1,1,1);
   inversion_mode==1?(v_use_invert=vectornumber_of_bars(0);):(
   inversion_mode==2?(v_use_invert=vectornumber_of_bars(1);););

   const use_only_one_mode=$11>=0;

   use_only_one_mode?(
    const modulo_out=$11%3;
    v_modulo_mode=vectornumber_of_bars(modulo_out);
   ):(
    narg($12)?(
     const modulo_out=$12%3;
     modulo_out==0?(v_modulo_mode=expr('round(u(0,1))',number_of_bars,1,1,1);):
     modulo_out==1?(v_modulo_mode=expr('round(u(0,1))*2',number_of_bars,1,1,1);):
                   (v_modulo_mode=expr('round(u(0,1))+1',number_of_bars,1,1,1););
    ):(
     v_modulo_mode=expr('round(u(0,2))',number_of_bars,1,1,1);
    );
   );

   rgb2hsv(a)=(
    R=a[0];
    G=a[1];
    B=a[2];
    M = max(R,G,B);
    C = M - min(R,G,B);
    H = 60*(C==0?0:M==R?((G - B)/C)%6:M==G?(B - R)/C + 2:(R - G)/C + 4);
    S = M<=0?0:C/M;
    [H,S,M/255];
   );

   ($14||$13==1)?(
    color_a=["$color_a"];
    color_b=["$color_b"];
    $13==3?(
     color_a=rgb2hsv(color_a);
     color_b=rgb2hsv(color_b);
    );
   );

   const bc=$13%4; #bc==bar color mode#
   const sc=$14%3; #sc==space color mode#

   bc==3?(
    v_hue=expr('u(0,360)',number_of_bars,1,1,1);
    sc==2?(
     calc_gradient()=spaces?[v_hue[bar],1,final_gradient,255]:[lerp(color_b,color_a,cut(gradient*2+.5,0,1)),255];
    ):
    sc==1?(
     calc_gradient()=spaces?[v_hue[bar],1,final_gradient,255]:[gradient>=0?color_a:color_b,255];
    ):(
     calc_gradient()=[v_hue[bar],1,final_gradient,255*spaces];
    );
   ):
   bc==2?(
    v_rgb_r=expr('u(0,255)',number_of_bars,1,1,1);
    v_rgb_g=expr('u(0,255)',number_of_bars,1,1,1);
    v_rgb_b=expr('u(0,255)',number_of_bars,1,1,1);
    sc==2?(
     calc_gradient()=spaces?[final_gradient*v_rgb_r[bar],final_gradient*v_rgb_g[bar],final_gradient*v_rgb_b[bar],255]:[lerp(color_b,color_a,cut(gradient*2+.5,0,1)),255];
    ):
    sc==1?(
     calc_gradient()=spaces?[final_gradient*v_rgb_r[bar],final_gradient*v_rgb_g[bar],final_gradient*v_rgb_b[bar],255]:[gradient>=0?color_a:color_b,255];
    ):(
     calc_gradient()=[final_gradient*v_rgb_r[bar],final_gradient*v_rgb_g[bar],final_gradient*v_rgb_b[bar],255*spaces];
    );
   ):
   bc==1?(
    sc==2?(
     calc_gradient()=spaces?[lerp(color_a,color_b,final_gradient),255]:[lerp(color_b,color_a,cut(gradient*2+.5,0,1)),255];
    ):
    sc==1?(
     calc_gradient()=spaces?[lerp(color_a,color_b,final_gradient),255]:[gradient>=0?color_a:color_b,255];
    ):(
     calc_gradient()=[lerp(color_a,color_b,final_gradient),255*spaces];
    );
   ):(
    sc==2?(
     calc_gradient()=spaces?[final_gradient,255]:[cut(gradient*2+.5,0,1),255];
    ):
    sc==1?(
     calc_gradient()=spaces?[final_gradient,255]:[gradient>=0,255]
    ):(
     calc_gradient()=[final_gradient,255*spaces];
    );
   );
  );

  initial_x=(x-ox)/ww*sx;
  initial_y=(y-oy)/hh*sy;
  gradient=-rot_y(initial_x,initial_y)*hh_div_sy/diag_img;
  point_x=rot_x(initial_x,initial_y)*ww_div_sx+gradient*mdist+half_total_width;
  bar=calc_bar();
  spaces=calc_spacing();
  new_gradient=gradient*v_mult[bar]+v_shift[bar];
  use_modulo_out=v_modulo_mode[bar];
  use_modulo_out==2?(final_gradient=v_use_invert[bar]?1-fmod_cont(new_gradient,1):fmod_cont(new_gradient,1);):
  use_modulo_out==1?(final_gradient=v_use_invert[bar]?1-fmod(new_gradient,1):fmod(new_gradient,1);):
                    (final_gradient=v_use_invert[bar]?1-fcut(new_gradient,1):fcut(new_gradient,1););
  calc_gradient();
  "
  rm..
  if $13==3 hsv2rgb. fi
  if $sub!=1 r. $ow,$oh,100%,100%,5 fi
endl done
#@cli rep_skew: angle,-100%<=_position_skew[%]<=100%,_axis={x|y|z},_boundary={0= 0=dirichlet | 1=neummann | 2=periodic | 3=mirror},_interpolation={ 0=nearest | 1=linear | 2=cubic },_enlarged_mode={ 0=preserve | 1=enlarge }
#@cli : Skew Image Based on angle. Note that axis==z condition has not been tested!
#@cli : Default values: _position_skew[%]=0%,_axis=0
rep_skew:
skip ${2=0},${3=0},${4=3},${5=1},${6=1}

check (abs($1)<90)&&(abs($2)<=1)&&((($3==0)||($3==1)||($3==2))||(('$3'=='x')||('$3'=='y')||('$3'=='z')))

if $1==0 return fi

if $6
 ang={($1/180)*pi}
 tang={tan($ang)}
 repeat $! l[$>]
  if '$3'=='z'||$3==2
   echo[] "TODO: Add depth. Possible TODO: zx,zy,xz,zy" return
  elif '$3'=='y'||$3==1
   dist={abs(w*$tang)}
   new_height={h+$dist}
   100%,$new_height,100%,100%,"begin(
     const ang=$ang*-1;
     const offpos=(h-h#-1)/2;
     const ww=w-1;
     const half_w=(w-1)/2;
     const dist=ww*tan(ang);
    );
    ypos=(x-half_w)/ww*dist-offpos;
    I(#-1,x,y+ypos,z,$5,$4);"
  elif '$3'=='x'||$3==0
   dist={abs(h*$tang)}
   new_width={w+$dist}
   $new_width,100%,100%,100%,"begin(
     const ang=$ang;
     const offpos=(w-w#-1)/2;
     const hh=h-1;
     const half_h=(h-1)/2;
     const dist=hh*tan(ang);
    );
    xpos=(y-half_h)/hh*dist-offpos;
    I(#-1,x+xpos,y,z,$5,$4);"
  else
   error "Invalid input!"
  fi
  k.
 endl done
else
 if '$3'=='z'||$3==2
  echo[] "Untested! Possible TODO: zx,zy,xz,zy"
  f "begin(
    const ang=($1/180)*pi;
    const dd=d-1;
    const pz=dd*($2*.5+.5);
    const dist=dd*tan(ang);
   );
   zpos=(z-pz)/dd;
   J(0,0,lerp(0,dist,zpos),$5,$4);"
 elif '$3'=='y'||$3==1
  f "begin(
    const ang=($1/180)*pi*-1;
    const ww=w-1;
    const px=ww*($2*.5+.5);
    const dist=ww*tan(ang);
   );
   xpos=(x-px)/ww;
   J(0,lerp(0,dist,xpos),0,$5,$4);"
 elif '$3'=='x'||$3==0
  f "begin(
    const ang=($1/180)*pi;
    const hh=h-1;
    const py=hh*(-$2*.5+.5);
    const dist=hh*tan(ang);
   );
   ypos=(y-py)/hh;
   J(lerp(0,dist,ypos),0,0,$5,$4);"
 else
  error "Invalid input!"
 fi
fi
#@cli rep_hpd: eq. to 'rep_henon_phase_diagram' : (+)
rep_hpd:rep_henon_phase_diagram $*
#@cli rep_henon_phase_diagram: a,_scale>0,-180>=_rotation>=180,_posx,_posy,_lines>0,1<_pts_per_line<=500,_start_x0,_end_x0,_steps_x0,_multiple_map
#@cli : Creates Henon Phase Diagram on existing image. Multiple Map option is used to make it easier to create more interesting image via coding.
#@cli :
#@cli : (eq. to 'rep_hpd')\n
#@cli : TODO: Add more description here.
rep_henon_phase_diagram:
skip ${2=1},${3=0},${4=50%},${5=50%}${6=600},${7=1750},${8=-.5},${9=.5},${10=8},${11=0}

if $2==0 error "$"2!=0==F fi

output_mode={$11%4}

if $1!=0

 if s#-1!=1&&d#-1!=1 100%,100%,1,1,-1
 else
  if !iv#-1&&iM#-1!=-1 f. -1 fi
 fi

 if ($3-360*floor($3/360))?1
  out_xi=rot_x(xi,yi)
  out_yi=rot_y(xi,yi)
 else
  out_xi=xi
  out_yi=yi
 fi

 steps={round((max(1,abs($10))-1))}
 lines={max(1,round(abs($6)))}

 if $output_mode==3 calc_out=i(#-1,cx,cy)=1
 else calc_out=cv=i(#-1,cx,cy);i(#-1,cx,cy)=max(cv,y)
 fi

 $steps,$lines,1,1,":begin_t(
   const a=$1;
   const c=cos(a);
   const s=sin(a);
   const pts=max(1,round(abs($7)));
   const ex=w#-1-1;
   const ey=h#-1-1;
   const posx=ex*$4;
   const posy=ey*$5;
   const hex=ex/2;
   const hey=ey/2;
   const dist=min(hex,hey)*abs($2);
   const tau=2*pi;
   const start_x0=$8;
   const end_x0=$9;
   const ang=($3/180)*pi*-1;
   const cos_ang=cos(ang);
   const sin_ang=sin(ang);
   if(abs($10)
    ,const end_step=w-1;
    ,const end_step=1;
   );
   rot_x(a,b)=a*cos_ang-b*sin_ang;
   rot_y(a,b)=a*sin_ang+b*cos_ang;
  );
  t=lerp(start_x0,end_x0,x/end_step);
  xi=t;
  yi=y/h*tau;
  repeat(pts,
   m=xi;
   n=yi-sqr(xi);
   xn=xi*c-n*s;
   yn=xi*s+n*c;
   if(xn==inf||yn==inf||xn==-inf||yn==-inf,break());
   xi=xn;yi=yn;
   if(m!=t,
    cx=round(posx+"$out_xi"/2*dist);
    cy=round(posy-"$out_yi"/2*dist);
    "$calc_out";
   );
  );
  "

 rm.

 if $output_mode==2
  +eq. -1
  +negate.
 elif $output_mode==1
  +gt. -1
 fi

else

 f. 0

fi
#@cli rep_mode_color: _outmode={ 0=blend | 1=mode_per_layer },_color_position
#@cli : Fill image with mode of colors.
#@cli :
#@cli : 'outmode' determines whether to blend images or fill images with mode of itself. If images are to be blended, then it is possible nan values will occur due to the absence of mode or more than one mode.
#@cli : '_color_position' determines the mode to use if it is 0 or over
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_outmode=0','_color_position=-1'
rep_mode_color:
skip ${1=0},${2=-1}
if $!>2&&!$1
 +a z colormap. 0
 a[^-1] c
 {w#0},{h#0},{d#0},{s#1},"begin(
  const vs=w#1;
  const ss=s#1;
  const css=s#0/ss;
  endnan=vectors(nan);
 );
 nmaxfreq=0;
 vfreq=vectorvs(-1);
 vp=I#0;
 repeat(css,pos,
  curcol=vp[pos*ss,ss];
  repeat(vs,posfreq,
   coltestpos=I(#1,posfreq,0,0);
   if(curcol==coltestpos,vfreq[posfreq]++;);
  );
 );
 maxfreqcount=max(vfreq);
 if(maxfreqcount+1,
  posmaxfreqcol=find(vfreq,maxfreqcount,0,1);
  repeat(vs,fs,if(vfreq[fs]==maxfreqcount,nmaxfreq++;););
  if(nmaxfreq==1,I(#1,posmaxfreqcol,0,0);,endnan);
 ,endnan;
 );"
 k.
elif $!==2&&!$1
 f. "begin(endnan=vectors(nan););I==I#0?I:endnan;" rm..
else
 repeat $! l[$>]
  if s>4 error "Unsupported number of channels" fi

  ls={s}

  minv={im}
  - $minv

  repeat s
   sh. $>
   bsize$>={iM+1}
   rm.
  done

  if s==1
   $bsize0,1,1,1 eval.. ++i(#-1,i,0,0,0) {w},1,1,1,x

   u {"freq=0;
    repeat(w#-2,n,
    if(i(#-2,n)==iM#-2,freq++;);
    );
    (freq)"}

   maxfreq={${}}

   echo $maxfreq

   +.. $minv

   pixelsort. -,x,[-2]

   if $1<0
    if $maxfreq==1
     f... i(#-1,0,0,0)
    fi
    k...
   else
    pos={$1%$maxfreq}
    f... i(#-1,$pos,0,0)
    k...
   fi

  else

   if s==2 $bsize0,$bsize1,1,1 eval.. ++i(#-1,[I,0]) dins=[x,y]
   elif s==3 $bsize0,$bsize1,$bsize2,1 eval.. ++i(#-1,I) dins=[x,y,z]
   elif s==4 $bsize0,$bsize1,$bsize2,$bsize3 eval.. ++i(#-1,I) dins=[x,y,z,c]
   fi

   1,1,1,$ls 1,1,1,1

   eval... :${-math_lib}"begin(
     const ls=$ls;
    );
    if(i,
     dar_insert(#-2,"$dins");
     dar_insert(#-1,i-1);
    );
    end(
     resize(#-2,1,dar_size(#-2),1,s(#-2),0);
     resize(#-1,1,dar_size(#-1),1,s(#-1),0);
    );
    "

   +.. $minv

   pixelsort.. -,y,[-1]
   sort. -

   u {"freq=0;
    repeat(h#-1,n,
     if(i(#-1,0,n)==iM,freq++,break(););
     );
     (freq)"}

   maxfreq={${}}

   if $2<0
    if $maxfreq==1
     f[-4] I(#-2,0,0,0)
    fi
   else
    pos={int($2)%$maxfreq}
    f[-4] I(#-2,0,$posfreq,0)
   fi
   k[-4]

  fi
 endl done
fi
#@cli rep_dynamic_contrast: -64<=amount<=64,0<=_threshold<=255,0<=_intensity<=255
#@cli : Apply dynamic contrast using formula found by Remake at forums.getpaint.net. Original source code - https://forums.getpaint.net/topic/117538-dynamic-contrast/?tab=comments#comment-578867 . It is similar to Photoshop's Dynamic Contrast.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_threshold=128','_intensity=255'
rep_dynamic_contrast:
skip ${2=128},${3=255}
repeat $!
  sh[$>] {s#$>>=3?[0,2]:0}
  if s>=3 calcval=v=I;lum=0.296875*v[0]+0.5859375*v[1]+0.11328125*v[2];(I-sqrt(abs(threshold-lum))*(lum>threshold?na:a))*fi+I*ifi;
  else calcval=(i-sqrt(abs(threshold-i))*(i>threshold?na:a))*fi+i*ifi
  fi
  f. "begin(
   const a=$1;
   const threshold=$2;
   const intensity=$3;
   const na=1-a;
   const fi=intensity/255;
   const ifi=1-fi;
  );
  "$calcval"
  "
  cut. 0,255
  rm.
done
#@cli rep_cstdmap: eq. to 'rep_chirikov_taylor' : (+)
rep_cstdmap:rep_chirikov_taylor $*
#@cli rep_chirikov_taylor: size!=0,_lines>0,_pts_per_line>0,_k,_chirikov_mode={ 0=standard | 1=chirikov_karimov },_offmode={ 0=default | 1=center },_orientation={ 0=xy | 1=yx },_use_parallel={ 0=serial | 1=parallel }
#@cli : Creates Chirikov discrete map. Chirikov map can be the standard version which is created by Boris Chirikov or modification done by Artur I. Karimov.\n
#@cli : (eq. to 'rep_cstdmap')\n
#@cli : 'size' can be either in percent or integer. It can be negative or positive. Percentage mode is always based on the size of image. Positive values will lead to square value regardless of initial image. Negative value will create a new image based on whether the width or height is smaller, and scale based on the ratio of max dim vs min dim.
#@cli : '_lines' defines the number of lines created within image. It defaults to 1 if the user inputs a value in which the absolute of value is less than 1.
#@cli : '_pts_per_line' defines how much points is generated per lines.
#@cli : '_k' can be considered distortion factor. It can be negative.
#@cli : '_chirikov_mode' defines whether to apply a symmetric modification to the original version of chirikov standard map. The symmetric modification is based on the paper 'The Study of the Modified Chirikov Map' by Artur I.Karimov, Denis N. Butusov,Vyacheslav G. Rybin, Timur I.Karimov within Department of Computer Aided Design at Saint Petersburg Electrotechnical University.
#@cli : '_offmode' defines whether the main rotor will be centered.
#@cli : '_orientation' defines whether to switch axis for generation of chirikov map.
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_lines=500','_pts_per_line=5000','_k=1','_chirikov_mode=0','_offmode=0','_orientation=0','_use_parallel=1'
rep_chirikov_taylor:
skip ${2=500},${3=5000},${4=1},${5=0},${6=0},${7=0},${8=1}

if ${is_percent\ $1}
 if $!
  if $1>0
   mw=${-max_w}
   mh=${-max_h}
   md={max($mw,$mh)}
   chirikov_w,chirikov_h={$md*$1}
  else
   mw=${-max_w}
   mh=${-max_h}
   sd={max($mw,$mh)/min($mw,$mh)}
   if $mh>$mw
    chirikov_w={$mw*abs($1)}
    chirikov_h={$sd*$chirikov_w}
   else
    chirikov_h={$mh*abs($1)}
    chirikov_w={$sd*$chirikov_h}
   fi
  fi
 else error \$\!>0==F
 fi
else
 if $1>0
  chirikov_w,chirikov_h=$1
 elif $1<0
  if $!
   mw=${-max_w}
   mh=${-max_h}
   sd={max($mw,$mh)/min($mw,$mh)}
   if $mh>$mw
    chirikov_w={abs($1)}
    chirikov_h={$sd*$chirikov_w}
   else
    chirikov_h={abs($1)}
    chirikov_w={$sd*$chirikov_h}
   fi
  else error \$\!>0==F
  fi
 else error \$\1!=0==F
 fi
fi

if $5
 chirikov_mode=txi=fmod(xi+.5*yi);yi=fmod(yi-k*sin(txi));xi=fmod(txi+.5*yi)
else
 chirikov_mode=yi=fmod(yi+k*sin(xi));xi=fmod(xi+yi)
fi

if $7
 coordinates=[round(yi/tau*width),round(xi/tau*height)]
else
 coordinates=[round(xi/tau*width),round(yi/tau*height)]
fi

lines={min(100*$chirikov_h,abs($2))+1}

$chirikov_w,$chirikov_h,1,1

$lines,1,1,1,"begin(const ww=w-1;const tau=2*pi;);x/w*tau;"

if $8 start_char=:
else start_char=>
fi

f. $start_char"
 begin(
  const width=w#-2;
  const height=h#-2;
  const pts=max(1,abs(round($3)));
  const k=$4;
  const tau=2*pi;
  fmod(a)=a-tau*floor(a/tau);
  xi=0;
 );
 yi=i;
 px=x+1;
 repeat(pts,
  "$chirikov_mode";
  coordinates="$coordinates";
  cv=i(#-2,coordinates[0],coordinates[1]);
  i(#-2,coordinates[0],coordinates[1])=max(cv,px);
 );"

rm.

if $6
 if $7
  if $5 +s. y,2 rv[-2,-1] a[-2,-1] y a[-2,-1] x
  else s. x,2 rv[-2,-1] a[-2,-1] x
  fi
 else
  if $5 +s. x,2 rv[-2,-1] a[-2,-1] x a[-2,-1] y
  else s. y,2 rv[-2,-1] a[-2,-1] y
  fi
 fi
fi
#@cli rep_rvi : eq. to 'rep_reverse_integer' :(+)
rep_rvi:rep_reverse_integer
#@cli rep_reverse_integer
#@cli : Reverse integers of images.
#@cli : (eq. to 'rep_rvi')\n
rep_reverse_integer:
f "rv=0;n=i;
do(rv=int(rv)*10+n%10;n=int(n)/10;,int(n)>0);
int(rv);
"
#@cli rep_tz: eq. to 'rep_tiled_zoom' : (+)
rep_tz:rep_tiled_zoom $*
#@cli rep_tiled_zoom: sqr_w>=0,_sqr_h>=0,_scale>=1,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror }
#@cli : Zoom per tiles using information that exists.\n
#@cli : (eq. to 'rep_tz')\n
#@cli : Author: Reptorian\n
#@cli : Default values: '_sqr_h=sqr_w','_scale=2','_boundary=3'
rep_tiled_zoom:
skip ${2=$1},${3=2},${4=3}
sqr_w={max(round(abs($1)),1)}
sqr_h={max(round(abs($2)),1)}
sd={max(1,abs($3))}
if $sd!=1
 repeat $! l[$>]
  columns={ceil(w/$sqr_w)}
  rows={ceil(h/$sqr_h)}
  offx={($sqr_w*$columns)-w}
  offy={($sqr_h*$rows)-h}
  offx/=2
  offy/=2
  offx=int($offx)
  offy=int($offy)

  f "begin(
   px=expr('begin(const cen=(w-1)/2;);cv=x-cen;nv=cv*$sd;nv-cv;',$sqr_w);
   py=expr('begin(const cen=(w-1)/2;);cv=x-cen;nv=cv*$sd;nv-cv;',$sqr_h);
   const boundary=abs($4)%4;
  );
  coords=[px[(x+$offx)%$sqr_w],py[(y+$offy)%$sqr_h]];
  J(coords[0],coords[1],0,2,boundary);"

 endl done
fi
#@cli rep_hsx_p_i: eq. to 'rep_hsx_poster_index' : (+)
rep_hsx_p_i:rep_hsx_poster_index $*
#@cli rep_hsx_poster_index: if $4<0 <=hue_bands<=360,saturation_bands,luminosity_bands,n/a,_colorspace={ 0=hsi | 1=hsl | 2=hsv | 3=hcy } : else 0<=hue_bands<=360,saturation_bands,luminosity_bands,0<=_dithering<=1,_colorspace={ 0=hsi | 1=hsl | 2=hsv | 3=hcy }
#@cli : Posterize images using indexing and several variants of hsx models.\n
#@cli : (eq. to 'rep_hsx_p_i')\n
#@cli : Author: Reptorian\n
#@cli : Default values: _dithering=50%,_colorspace=3
rep_hsx_poster_index:
skip ${4=50%},${5=3}

convert_colors_fwd=${arg\ 1+$5,rgb2hsi,rgb2hsl,rgb2hsv,rgb2hcy}
convert_colors_bwd=${arg\ 1+$5,hsi2rgb,hsl2rgb,hsv2rgb,hcy2rgb}

$convert_colors_fwd

hb={abs($1)+1}
scb={abs($2)+1}
lub={abs($3)+1}

if $1<0||$1>360 error "0<="$"1<=360" fi

if $4<0
 f [round(i0/(360/($hb-1)))*(360/($hb-1)),round(i1*($scb-1))/($scb-1),round(i2*($lub-1))/($lub-1)]
else

 $hb,$scb,$lub,3,[floor(360/($hb-1))*x,y/($scb-1),z/($lub-1)]

 repeat $!-1
  sh[$>] 0,2
  index[-1] [-2],{$4},1
  rm.
 done

 rm.

fi

$convert_colors_bwd
#@cli rep_mj_prn : eq. to 'rep_mj_pseudorandom_noise' : (+)
rep_mj_prn:rep_mj_pseudorandom_noise $*
#@cli rep_mj_pseudorandom_noise : _k1,_k2,_internal_shift,_ang,_px_size,_cx,_cy,_color_output,_kmode,_grid,_gridcol,_axis_thickness
#@cli : Render regular noise. Filter is a extended version of MadJik's Regular Noise PDN plugin and based off MadJik's code. The G'MIC version has been extended.\n
#@cli : (eq. to 'rep_mj_prn').\n
#@cli : '_k1' defines value for k-1
#@cli : '_k2' defines value for k-2
#@cli : '_internal_shift' shift rows based on this value. The more, the more distortion there will be.
#@cli : '_ang' defines the color/shade angle.
#@cli : '_px_size' defines how big the pixels are.
#@cli : '_cx' refers to the x-position of center based on world coordinate of -1,1
#@cli : '_cy' refers to the y-position of center based on world coordinate of -1,1
#@cli : '_color_output' is the function used to color the output.
#@cli : '_kmode' defines how the noise will be processed.
#@cli : '_grid' option is used to whether to output a grid.
#@cli : '_gridcol' defines the value of grid. Only gray color is supported.
#@cli : '_axis_thickness' defines whether the axis has 2 pixel instead of 1.\n
#@cli : Default values: '_k1=8','_k2=2','_internal_shift=1','_ang=0','_px_size=1','_cx=0','_cy=0','_coloroutput=1','_grid=0','_gridcol=0','_axis_thickness=0'\n
#@cli : Author: Reptorian.
#@cli : $ 512,512 rep_mj_pseudorandom_noise 8,2,1,95,4,0,0,1,0,,,0
#@cli : $ 1024,1024 rep_mj_pseudorandom_noise 34,2,30,95,4,0,0,2
rep_mj_pseudorandom_noise:
skip ${1=8},${2=2},${3=1},${4=0},${5=1},${6=0},${7=0},${8=1},${9=0},${10=0},${11=0},${12=0}
r 100%,100%,1,{$8?3:1}
3000,100,1,1,round((1-(x*(x^2*15731+789221)+1376312589&2147483647)/1073741824)*100000)/100000;

if $8%4==2
 outmode=i(#-1,num+($4/180*3000),0,0,0,0,2)
 formulachoice=DoubleToColorRGB(noise_gen)
else
 outmode=i(#-1,num%3000,0,0,0,0,2)
 if $8%4==3 formulachoice=DoubleToColorTan(noise_gen)%256
 elif $8%4==1 formulachoice=formulachoice=DoubleToColorSin(noise_gen)
 else formulachoice=(((ang/pi*256)+noise_gen)/3000*256)%256
 fi
fi

if $10
 tempval={abs($5)+1}
 if $8 gridcol=[$11,$11,$11]
 else gridcol=$11
 fi
 temp_formulachoice=((x%$tempval)&&(y%$tempval))?
 temp_formulachoice.=$formulachoice:$gridcol
 formulachoice=$temp_formulachoice
fi

f[0--2] "
  begin(
   const ww=w/2;
   const halfh=h/2;
   const zoom=1/round(abs(abs($5)+($10?1:0)));
   if($9
   ,const k_one=$1/2;
   ,const k_one=$1/10;
   );
   if($9
   ,const k_two=$2/4;
   ,const k_two=($2*-1)/10;
   );
   noise2d(nx,ny)=(
    a=int(nx);b=int(ny);
    num=abs(a+b*$3)%3000;
    "$outmode";
   );
   const ang=$4/180*pi;
   smoothnoise(nx,ny)=(
    a=int(nx);b=int(ny);
    num=(noise2d(a-1,b-1)*4)/$1;
    num2=(noise2d(a-1,b)*4)/k_one;
    num3=noise2d(a,b)/k_two;
    num4=num+num2+num3;
    num4*256;
   );
   DoubleToColorSin(v)=(
    num=ceil((v*1/pi*10^3))/10^3;
    num2=int(128+127*sin(num+ang));
    num3=int(128+127*sin(pi/2+num+ang));
    num4=int(128+127*sin(pi+num+ang));
    [num4,num3,num2];
   );
   DoubleToColorRGB(t)=(
    num=int(t*65536.0);
    num2=(num&16711680)>>16;
    num3=(num&65280)>>8;
    num4=num&255;
    [num4,num3,num2];
   );
   DoubleToColorTan(w)=(
    num=ceil((w*1/pi)*10^3)/10^3;
    num2=int(128+127*tan(num+ang));
    num3=int(128+127*tan(num+pi/2+ang));
    num4=int(128+127*tan(num+pi+ang));
    [num4,num3,num2];
   );
  );
  xx=abs(int(zoom*(x+0.5)));
  yy=abs(int(zoom*(y+0.5)));
  noise_gen=smoothnoise(xx,yy);
  "$formulachoice";
"
if $12&&(($6!=-1)||($7!=-1))
 if $10
 f[0--2] "begin(
  const sfx=int(($6*.5+.5)*w)+($10?1:0);
  const sfy=int(($7*.5+.5)*h)+($10?1:0);
 );
 psfx=x-sfx;
 psfy=y-sfy;
 i(
  psfx>=0?x-sfx:x-sfx-1,
  psfy>=0?y-sfy:y-sfy-1,z,c,0,3
  );
 "
 else
 f[0--2] "begin(
  const sfx=($6*.5+.5)*w+($10?1:0);
  const sfy=($7*.5+.5)*h+($10?1:0);
 );
 i(x-sfx,y-sfy,z,c,0,3);
 "
 fi
elif $6!=-1||$7!=-1
 f[0--2] "begin(
  const gridfix=($10?1:0);
  const pxlsize=abs($5)+gridfix;
  const errfix=abs($5)==1?!(pxlsize%2):1-gridfix;
  const sw=int(w-pxlsize);
  const sfx=int(($6*.5+.5)*sw);
  const sh=int(h-pxlsize);
  const sfy=int(($7*.5+.5)*sh);
  const errfix2=abs($5)==1;
 );
 psfx=x-sfx;
 psfy=y-sfy;
 i(
 psfx>=0?psfx+errfix2:psfx*-1+pxlsize-errfix,
 psfy>=0?psfy+errfix2:psfy*-1+pxlsize-errfix,
 z,c,
 0,2
 );"
fi
rm.
#@cli rep_dla : eq. to 'rep_diffusion_limited_aggregation' : (+)
rep_dla: rep_diffusion_limited_aggregation $*
#@cli rep_diffusion_limited_aggregation: _point_proximity,_escape,_mode,_target={ 0=dark | 1=light },_border,_preserve_binary_image={ 0=maskless | 1=mask },[mask]
#@cli : Generate Diffusion Limited Aggregation
#@cli : (eq. to 'rep_dla').\n
#@cli : '_point_proximity' defines how frequently noises are generated based on the proximity of pixels. The lower the number, the higher the density.
#@cli : '_escape' defines how much attempts on filling the aggregation form before finishing.
#@cli : '_mode' defines how particles aggregate on the aggregation form.
#@cli : '_target' defines where the aggregation form will fill on.
#@cli : '_border' is only applicable if there is a planting seed map. It is used to limit particles based on proximity away from existing structure.
#@cli : '_preserve_binary_image' is only applicable on images with variance.
#@cli : Author: Reptorian\n
#@cli : Default values: '_point_proximity=2','_escape=10','_mode=1','_target=1','_border=0','_keep_erase_mask=1','[mask]=0'
rep_diffusion_limited_aggregation:
skip ${1=2},${2=100},${3=1},${4=0},${5=0},${6=1}

__bg={$4?0:1}

m "dla_target_2s : n 0,1 s. c * midpoint={avg(iM,im)} f. i>$midpoint?1"
m "dla_target_3s : n 0,1 s c add / 3 midpoint={avg(iM,im)} f. i>$midpoint?1"
m "dla_target_4s_plus : n 0,1 ts={s-1} s c add[^-1] /.. $ts * midpoint={avg(iM,im)} f. i>$midpoint?1"
m "dla_target : if s==1 n 0,1 elif s==2 dla_target_2s elif s==3 dla_target_3s elif s>3 dla_target_4s_plus fi"
m "dla_check_variance : tv=0 repeat s sh $> tv+={iv#-1} rm. if $tv break fi done u {$tv?1:0}"
m "dla_clear_image : {w#0},{h#0},{d#0},1,$__bg rv[-1,0] rm."

if abs($1)>1 m " dla_create_coordinate_map : +rep_noise_poissondisk_to_coordinates {abs($1)},4 round. m={int(h/$_cpus)} f. I(0,int(y/$_cpus)+(y%$_cpus)*$m,0);"
else m "dla_create_coordinate_map : +rep_create_alternating_coordinates_map m={int(h/$_cpus)} f. I(0,int(y/$_cpus)+(y%$_cpus)*$m,0)"
fi

if $4 m "dla_expand : if $5!=0 +dilate_circ[0] {abs($5)} fi"
else m "dla_expand : if $5!=0 +erode_circ[0] {abs($5)} fi"
fi

n_threads={$_cpus}
mt={$n_threads-1}

l.
 $n_threads,1,1,2
 +s. x
 store[^0] dla_ref
endl

length_const_line=""
dar_lines=""

length_const_line.=begin(
length_const_line.="const ww=w#0;"
length_const_line.="const hh=h#0;"
length_const_line.="const " length_const_line.=lim_atmp=$2;
length_const_line.="const " length_const_line.=dlmode={($4%2)>0?1:0} length_const_line.=;
length_const_line.="const " length_const_line.=use_border="$check_count";
length_const_line.=use_border?(
 repeat $n_threads
  insert_ref_pos={2+$n_threads+$>}
  length_const_line.=check_and_insert_point_$>()=(i(#0,I(#$insert_ref_pos,0,refpos))!=i(#-1,I(#$insert_ref_pos,0,refpos)));
 done
length_const_line.=):(
 repeat $n_threads
  insert_ref_pos={2+$n_threads+$>}
  if $4 length_const_line.=check_and_insert_point_$>()=(i(#0,I(#$insert_ref_pos,0,refpos))<.001?1);
  else length_const_line.=check_and_insert_point_$>()=(i(#0,I(#$insert_ref_pos,0,refpos))>0.999?1);
  fi
 done
length_const_line.=);

repeat $n_threads

 insert_dar_pos={$>+2}
 insert_ref_pos={2+$n_threads+$>}

 length_const_line.="const v"
 length_const_line.=$>=
 length_const_line.=h#$insert_ref_pos
 length_const_line.=;

 dar_lines.=x==
 dar_lines.=$>
 dar_lines.=?(
 dar_lines.=repeat(v$>,refpos,
 dar_lines.=if(check_and_insert_point_$>(),dar_insert(#$insert_dar_pos,I(#$insert_ref_pos,0,refpos)););
 dar_lines.=);
 dar_lines.=do(n=0;
 dar_lines.=do(
 dar_lines.=temp_vec=I(#$insert_dar_pos,0,n);
 dar_lines.=xp=temp_vec[0];
 dar_lines.=yp=temp_vec[1];
 dar_lines.=if(
  if $4%2
   if $3==0 dar_lines.=(i(#0,xp-1,yp-1,0,0,0,2)||i(#0,xp-1,yp+1,0,0,0,2))||(i(#0,xp+1,yp-1,0,0,0,2)||i(#0,xp+1,yp+1,0,0,0,2))
   elif $3==1 dar_lines.=(i(#0,xp-1,yp,0,0,0,2)||i(#0,xp+1,yp,0,0,0,2))||(i(#0,xp,yp-1,0,0,0,2)||i(#0,xp,yp+1,0,0,0,2))
   elif $3==2 dar_lines.=((i(#0,xp-1,yp-1,0,0,0,2)||i(#0,xp-1,yp+1,0,0,0,2))||(i(#0,xp+1,yp-1,0,0,0,2)||i(#0,xp+1,yp+1,0,0,0,2)))||((i(#0,xp-1,yp,0,0,0,2)||i(#0,xp+1,yp,0,0,0,2))||(i(#0,xp,yp-1,0,0,0,2)||i(#0,xp,yp+1,0,0,0,2)))
   elif $3==3 dar_lines.=altern?(i(#0,xp-1,yp-1,0,0,0,2)||i(#0,xp-1,yp+1,0,0,0,2))||(i(#0,xp+1,yp-1,0,0,0,2)||i(#0,xp+1,yp+1,0,0,0,2)):(i(#0,xp-1,yp,0,0,0,2)||i(#0,xp+1,yp,0,0,0,2))||(i(#0,xp,yp-1,0,0,0,2)||i(#0,xp,yp+1,0,0,0,2))
   fi
  else
   if $3==0 dar_lines.=(i(#0,xp-1,yp-1,0,0,0,2)<1||i(#0,xp-1,yp+1,0,0,0,2)<1)||(i(#0,xp+1,yp-1,0,0,0,2)<1||i(#0,xp+1,yp+1,0,0,0,2)<1)
   elif $3==1 dar_lines.=(i(#0,xp-1,yp,0,0,0,2)<1||i(#0,xp+1,yp,0,0,0,2)<1)||(i(#0,xp,yp-1,0,0,0,2)<1||i(#0,xp,yp+1,0,0,0,2)<1)
   elif $3==2 dar_lines.=((i(#0,xp-1,yp-1,0,0,0,2)<1||i(#0,xp-1,yp+1,0,0,0,2)<1)||(i(#0,xp+1,yp-1,0,0,0,2)<1||i(#0,xp+1,yp+1,0,0,0,2)<1))||((i(#0,xp-1,yp,0,0,0,2)<1||i(#0,xp+1,yp,0,0,0,2)<1)||(i(#0,xp,yp-1,0,0,0,2)<1||i(#0,xp,yp+1,0,0,0,2)<1))
   elif $3==3 dar_lines.=altern?(i(#0,xp-1,yp-1,0,0,0,2)<1||i(#0,xp-1,yp+1,0,0,0,2)<1)||(i(#0,xp+1,yp-1,0,0,0,2)<1||i(#0,xp+1,yp+1,0,0,0,2)<1):(i(#0,xp-1,yp,0,0,0,2)<1||i(#0,xp+1,yp,0,0,0,2)<1)||(i(#0,xp,yp-1,0,0,0,2)<1||i(#0,xp,yp+1,0,0,0,2)<1)
   fi
  fi
 dar_lines.=,
 dar_lines.=i(#0,xp%ww,yp%hh)=dlmode;
 dar_lines.=dar_remove(#$insert_dar_pos,n);
 dar_lines.=n--;
 dar_lines.=attempts=0;
 dar_lines.=);
 dar_lines.=n++;
 dar_lines.=,n<dar_size(#$insert_dar_pos));
 dar_lines.=repeat(dar_size(#$insert_dar_pos),p,
 dar_lines.=temp_vec=I(#$insert_dar_pos,0,p);
 dar_lines.=px=temp_vec[0];
 dar_lines.=py=temp_vec[1];
 dar_lines.=pv=int(u(0,8));
 dar_lines.=npx=newpos_x[pv];
 dar_lines.=npy=newpos_y[pv];
 dar_lines.=I(#$insert_dar_pos,0,p)=[px+npx,py+npy];
 dar_lines.=);
 dar_lines.=attempts++;
 if $3==3 dar_lines.=altern=(altern+1)%2; fi
 dar_lines.=,dar_size(#$insert_dar_pos)&&(attempts<lim_atmp));
 dar_lines.=)

 if ($>!=$mt)
  dar_lines.=:
 else
  dar_lines.=;
 fi

done

length_const_line.=newpos_x=[-1,0,1,-1,1,-1,0,1];
length_const_line.=newpos_y=[-1,-1,-1,0,0,1,1,1];
length_const_line.=);
length_const_line.=attempts=0;
if $3==3 length_const_line.=altern=round(u(1)); fi

repeat $! l[$>]
 if s>4||d#0>1 continue fi
 dla_create_coordinate_map

 dla_check_variance[0]
 use_dla_map=${}

 l[0] $dla_ref endl

 s. y,$n_threads

 ti={$!}

 check_count=0

 if $use_dla_map
  dla_target[0]
  if !$6
   if $4
    *[0] .001
   else
    replace[0] 0,.999
   fi
  fi
  dla_expand
  check_count={$!-$ti}
 else
  dla_clear_image
  set[0] {1-$__bg},50%,50%
 fi

 eval[1] :${-math_lib}$length_const_line$dar_lines

 k[0]

 if $use_dla_map&&!$6 round fi
endl done

um dla_target,dla_target_2s,dla_target_3s,dla_target_4s_plus,dla_create_coordinate_map,dla_expand
rep_create_alternating_coordinates_map:
1,1,1,2
eval[0] ${-math_lib}"!((x%3==0)!=(y%3==0))*((x%3==0)||(y%3==0))?dar_insert(#-1,[x,y]);
end(resize(#-1,1,dar_size(#-1),1,s(#-1),0););
"
k.
#@cli rep_blur_splinter: _length,_duplicates,_angle,_thickness,-1<=_balance<=1,_contrast,_boundary={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_bisided={ 0=one-line | two-line }
#@cli : Apply Splinter Blur to Image. Based off observation from using Splinter Blur plugin within Paint.NET made by Ed Harvey, and it is inspired by this filter. Note that convolution result is different.
#@cli : Default values: '_length=10%','_duplicates=5','_angle=0','_thickness=0','_balance=0','_contrastr=0','_boundary=1','_bisided=0'
rep_blur_splinter:
skip ${1=10%},${2=5},${3=0},${4=0},${5=0},${6=0},${7=2},${8=0}

if $2<3 error \$\2>2==F fi

start_ang={$3}
angs_per_dups={360/$2}

m "average_output: ti=$! add / $ti"

if $5==-1 m "output_splinter : min"
elif $5<0&&$5>-1 m "output_splinter : +average_output +min[^-1] f. lerp(i#-2,i,abs($5)) k."
elif $5==0 m "output_splinter : average_output"
elif $5>0&&$5<1 m "output_splinter : +average_output +max[^-1] f. lerp(i#-2,i,$5) k."
elif $5==1 m "output_splinter : max"
else error (-1<=\$\6<=1)=F
fi

repeat $! l[$>]
 half_img_diag={norm(w,h)/2}
 if ${is_percent\ $1} length={round(abs($1)*$half_img_diag)}
 else length={round(abs($1))}
 fi

 if ${is_percent\ $4} thickness={round(abs($4)*$half_img_diag)}
 else thickness={round(abs($4))}
 fi

 img_dims={w},{h}

 repeat $2
  ang={$start_ang+$angs_per_dups*$>}
  rep_splinter_blur_convolve_map[^0--1] $length,$thickness,$ang,$6,$8,$img_dims
  +convolve_fft[0] [-1],$7
  rm..
 done

 rm[0]

 output_splinter

endl done
um output_splinter
#@cli rep_splinter_blur_convolve_map: _length,_thickness,_angle,_contrast,_bisided={ 0=one-line | two-line }
#@cli : Create a convolve map for directional blur. This enables one to create a convolve map for one-direction motion blur.
#@cli : Default values: '_length=10%','_thickness=5%','_angle=0','_bisided=1'
rep_splinter_blur_convolve_map : skip ${1=10%},${2=5%},${3=0},${4=0},${5=1},${6=w},${7=h}
ang={($3/180)*pi*-1}
cos_ang={cos($ang)};
sin_ang={sin($ang)};
diag={norm($6,$7)/2}
if ${is_percent\ $1} length={round($1*$diag)} else length={round($1)} fi
if ${is_percent\ $2} thickness={max(round($2*$diag),1)} else thickness={max(round($2),1)} fi

point_b_x=0
point_b_y={$length/2}
point_c_x={$thickness/2}
max_dim={max($point_b_y,$point_c_x)}
min_dim={min($point_b_y,$point_c_x)}
point_c_y={sqrt(sqr($max_dim)-sqr($min_dim))}
point_a_x=-$point_c_x
point_a_y=$point_c_y

n_pax={abs($point_a_x*$cos_ang+$point_a_y*$sin_ang)}
n_pay={abs($point_a_x*$sin_ang+$point_a_y*$cos_ang)}
n_pbx={abs($point_b_x*$cos_ang+$point_b_y*$sin_ang)}
n_pby={abs($point_b_x*$sin_ang+$point_b_y*$cos_ang)}
n_pcx={abs($point_c_x*$cos_ang+$point_c_y*$sin_ang)}
n_pcy={abs($point_c_x*$sin_ang+$point_c_y*$cos_ang)}

rect_width={ceil(max($n_pax,$n_pbx,$n_pcx)*2)}
rect_height={ceil(max($n_pay,$n_pby,$n_pcy)*2)}

{max(1,$rect_width)},{max(1,$rect_height)},1,1,"
 begin(
  const strokelength=$length;
  const sx=w/strokelength;
  const sy=h/strokelength;
  const sides=$5;
  const thickness=$thickness;
  const hw=(w-1)/2;
  const hh=(h-1)/2;
  const ang=($3/180)*pi*-1;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  cutval(v)=v<0?0:v;
  maxcutval(v)=v>1?1:v;
 );
 xx=(x/w-.5)*sx;
 yy=(y/h-.5)*sy;
 lx=x-hw;
 ly=y-hh;
 radial_grad=1-norm(xx,yy)*2;
 radial_grad=cutval(radial_grad);
 line=1-maxcutval(abs(rot_x(lx,ly))/thickness);
 sides?(line?radial_grad*line):(rot_y(lx,ly)<=0?(line?radial_grad*line));
 "
/. {is}
if $4
 avgstat={ia}
 +*. 2 -. $avgstat
 f.. lerp(i,i#1,min(1,min(abs($4),1)))
 rm.
fi
#@cli rep_bgfill: eq. to 'rep_fill_background' : (+)
rep_bgfill: rep_fill_background $*
#@cli rep_fill_background: color,alpha,max_alp
#@cli : Fill image with values.\n
#@cli : (eq. to 'rep_bgfill')\n
#@cli : For RGBA images, 3 values are used in place of color. That means 5 values are to be inserted.
#@cli : For GA Image, only 1 value are used in place of color. That means 3 values are to be used.
rep_fill_background:
if $-2>0
 $!,1,1,1,s#x
 val_test={iv#-1}
 rm.
 if !$val_test
  repeat $! l[$>]
   if s==2||s>3
    sh 0,{s-2}
    sh.. {s}
    f.. I*(i0#-1/$-1)*($-2/$-1)+I*(1-($-2/255))+[${1--3}]*(1-i0#-1/$-1)
    f. $-1*(i/$-1*$-2/$-1)+i*(1-$-2/$-1)+$-2*(1-i/$-1)
    rm[-2,-1]
   fi
  endl done
 else
  error !var(chans)==F
 fi
fi
#@cli rep_pfrac_t : eq. to 'rep_popcorn_fractal_transformative' : (+)
rep_pfrac_t: rep_popcorn_fractal_transformative $*
#@cli rep_popcorn_fractal_transformative: _points>0,_density>0,_H,_K,_zoom,_rotation_angle,_origin_x,_origin_y,set_arg_a,set_arg_b
#@cli : Generates Transformative Pickover Popcorn Fractal. Discovered by T.Gangopadhyay at XLRI in C.H.Area(E),Jamshedpur,India in 2012.
#@cli :
#@cli : Source: International Journal of Computer Applications(0975-8887) Volume 50-No.8, July 2012.
#@cli :
#@cli : _points defines the maximum number of points to be added on image based on pixel location.
#@cli : _density defines the frequency of points to be added along row and height of image. A value of one implies n points to be added per pixel.
#@cli : _H is the function multiplier used to subtract from the new found values from each iteration.
#@cli : _K is the inner multiplier for the inside function. See popcorn_x(a,b), and popcorn_y(a,b) embedded within the code of rep_popcorn_fractal for more information.
#@cli : _zoom defines the magnification of image. A negative value will "shrink" the structure of generated fractal.
#@cli : _rotation_angle defines the function angle of fractal.
#@cli : _origin_x defines the position of fractal. Center of image row will be treated as zero, and the ranges for image row are treated as -1,1.
#@cli : _origin_y defines the position of fractal. Center of image column will be treated as zero, and the ranges for image column are treated as -1,1.
#@cli : _set_arg defines complex trigometric functions to utilize to define the complex popcorn fractal.
#@cli :
#@cli : Note: See below note for more details on _set_arg
#@cli :
#@cli : ---- Set of arguments for each _set_arg -----
#@cli :
#@cli : There can be up to 4 set of arguments. If any of first two set of arguments are specified, then the default arguments for the first two set of arguments are overrided with the first two set of arguments. If any of the last two arguments are not specified, then it will take the last two set of arguments before it, otherwise, it will override it with the specified arguments.
#@cli :
#@cli : Note: Use the examples provided to make it easier to generate. See examples for clarification on what is meant by set of arguments.
#@cli :
#@cli : if _set_arg_n_1==0: 0,_function
#@cli :
#@cli : Output - func_a(v)
#@cli :  _function={0=sin|1=sinh|2=cos|3=cosh|4=tan|5=tanh}
#@cli :
#@cli : elif _set_arg_n_1==1: 1,_function_a,_function_b
#@cli :
#@cli : Output - func_a(v)+func_b(v)
#@cli :  _function_a={0=v|1=sin|2=sinh|3=cos|4=cosh|5=tan|6=tanh}
#@cli :  _function_b={0=v|1=sin|2=sinh|3=cos|4=cosh|5=tan|6=tanh}
#@cli :
#@cli : elif _set_arg_n_1==2: 2,_function_a,_function_b,_include_v
#@cli :
#@cli :  Output - func_a((include_v?v:0)+func_b(v))
#@cli :  _function_a={0=sin|1=sinh|2=cos|3=cosh|4=tan|5=tanh}
#@cli :  _function_b={0=sin|1=sinh|2=cos|3=cosh|4=tan|5=tanh}
#@cli :  _include_v={0=FALSE|1=TRUE}
#@cli :
#@cli : fi
#@cli :
#@cli : ---- End ----
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_points=50','density=1','H=.05','_K=3','zoom=.5','_rotation_angle=45','_origin_x=0','_origin_y=0'
#@cli : $ set_arg_a=0,0 set_arg_b=0,4 512,512 rep_popcorn_fractal_transformative 50,2,.05,3,.5,45,0,0,$set_arg_a,$set_arg_b cut 0,1000
#@cli : $ set_arg_a=2,1,4,, set_arg_b=1,4,2 512,512 rep_popcorn_fractal_transformative 50,2,.05,3,.5,45,0,0,$set_arg_a,$set_arg_b cut 0,1000
#@cli : $ set_arg_a=2,1,4,, set_arg_b=1,4,2 set_arg_c=0,4 set_arg_d=0,0 512,512 rep_popcorn_fractal_transformative 50,2,.05,3,.5,45,0,0,$set_arg_b,$set_arg_c,$set_arg_d cut 0,1000
rep_popcorn_fractal_transformative:
skip ${1=50},${2=1},${3=.05},${4=3},${5=.5},${6=45},${7=0},${8=0},${9=0},${10=},${11=},${12=},${13=},${14=},${15=},${16=},${17=},${18=},${19=},${20=},${21=},${22=},${23=},${24=}

if ($6-360*floor($6/360))?1
 fvx=((rot_x(ix,iy)-osx)*icx_zoom+cxsx)/sx
 fvy=((rot_y(ix,iy)-osy)*icy_zoom+cysy)/sy
else
 fvx=((ix-osx)*icx_zoom+cxsx)/sx
 fvy=((iy-osy)*icy_zoom+cysy)/sy
fi

$=funarg
fp=9
argval={$9%3}

if $argval==0

 fp+=2
 if narg($10)
  argval={$10%6}
  fun_a=${arg\ $argval+1,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
 else
  fun_a=sin(v)
 fi

elif $argval==1

 fp+=3

 if narg($10)
  argval={$10%7}
  fun_a=${arg\ $argval+1,v,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
 else
  fun_a=sin(v)
 fi

 if narg($11)
  argval={$11%7}
  fun_a.=${arg\ $argval+1,+v,+sin(v),+sinh(v),+cos(v),+cosh(v),+tan(v),+tanh(v)}
 else
  fun_a.=+cos(v)
 fi

else

 fp+=4

 if narg($12)
  if $12%2 include_v_a=1
  else include_v_a=0
  fi
 else
  include_v_a=1
 fi

 if narg($10)
  argval={$10%6}
  fun_a=${arg\ $argval+1,sin(,sinh(,cos(,cosh(,tan(,tanh(}
 else
  fun_a=sinh(
 fi

 if $include_v_a fun_a.=v+ fi

 if narg($11)
  argval={$11%6}
  fun_a.=${arg\ $argval+1,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}
 else
  fun_a.=sin(v))
 fi

fi

if narg(${funarg{$fp}})
 tv=${funarg{$fp}}
 mode_2={$tv%3}

 if $mode_2==0
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_b=${arg\ $argval+1,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_b=tan(v)
  fi
  fp+=2
 elif $mode_2==1
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%7}
   fun_b=${arg\ $argval+1,v,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_b=v
  fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%7}
   fun_b.=${arg\ $argval+1,+v,+sin(v),+sinh(v),+cos(v),+cosh(v),+tan(v),+tanh(v)}
  else
   fun_b.=+tan(v)
  fi
  fp+=3
 else
  if narg(${funarg{$fp+3}})
   tv=${funarg{$fp+3}}
   tv={$tv%2}
   if $tv include_v_b=1
   else include_v_b=0
   fi
  else
   include_v_b=$include_v_a
  fi
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_b=${arg\ $argval+1,sin(,sinh(,cos(,cosh(,tan(,tanh(}
  else
   fun_b=sin(
  fi
  if $include_v_b fun_b.=v+ fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%6}
   fun_b.=${arg\ $argval+1,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}
  else
   fun_b.=tan(v))
  fi
  fp+=4
 fi

else
 mode_2={$9%3}

 if $mode_2==0
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_b=${arg\ $argval+1,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_b=tan(v)
  fi
  fp+=2
 elif $mode_2==1
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%7}
   fun_b=${arg\ $argval+1,v,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_b=v
  fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%7}
   fun_b.=${arg\ $argval+1,+v,+sin(v),+sinh(v),+cos(v),+cosh(v),+tan(v),+tanh(v)}
  else
   fun_b.=+tan(v)
  fi
  fp+=3
 else
  if narg(${funarg{$fp+3}})
   tv=${funarg{$fp+3}}
   tv={$tv%2}
   if $tv include_v_b=1
   else include_v_b=0
   fi
  else
   include_v_b=$include_v_a
  fi
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_b=${arg\ $argval+1,sin(,sinh(,cos(,cosh(,tan(,tanh(}
  else
   fun_b=sin(
  fi
  if $include_v_b fun_b.=v+ fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%6}
   fun_b.=${arg\ $argval+1,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}
  else
   fun_b.=tan(v))
  fi
  fp+=4
 fi

fi

if narg(${funarg{$fp}})
 tv=${funarg{$fp}}
 mode_3={$tv%3}

 if $mode_3==0
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_c=${arg\ $argval+1,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_c=tan(v)
  fi
  fp+=2
 elif $mode_3==1
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%7}
   fun_c=${arg\ $argval+1,v,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_c=v
  fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%7}
   fun_c.=${arg\ $argval+1,+v,+sin(v),+sinh(v),+cos(v),+cosh(v),+tan(v),+tanh(v)}
  else
   fun_c.=+tan(v)
  fi
  fp+=3
 else
  if narg(${funarg{$fp+3}})
   tv=${funarg{$fp+3}}
   tv={$tv%2}
   if $tv include_v_b=1
   else include_v_b=0
   fi
  else
   include_v_b=$include_v_a
  fi
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_c=${arg\ $argval+1,sin(,sinh(,cos(,cosh(,tan(,tanh(}
  else
   fun_c=sin(
  fi
  if $include_v_b fun_c.=v+ fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%6}
   fun_c.=${arg\ $argval+1,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}
  else
   fun_c.=tan(v))
  fi
  fp+=4
 fi

else
 fp+={arg($mode_2+1,2,3,4)}
 fun_c=$fun_a
fi

if narg(${funarg{$fp}})
 tv=${funarg{$fp}}
 mode_4={$tv%3}

 if $mode_4==0
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_d=${arg\ $argval+1,sin(v),sinh(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_d=tan(v)
  fi
 elif $mode_4==1
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%7}
   fun_d=${arg\ $argval+1,v,sin(v),cos(v),cosh(v),tan(v),tanh(v)}
  else
   fun_d=v
  fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%7}
   fun_d.=${arg\ $argval+1,+v,+sin(v),+cos(v),+cosh(v),+tan(v),+tanh(v)}
  else
   fun_d.=+tan(v)
  fi
 else
  if narg(${funarg{$fp+3}})
   tv=${funarg{$fp+3}}
   tv={$tv%2}
   if $tv include_v_b=1
   else include_v_b=0
   fi
  else
   include_v_b=$include_v_a
  fi
  if narg(${funarg{$fp+1}})
   tv=${funarg{$fp+1}}
   argval={$tv%6}
   fun_d=${arg\ $argval+1,sin(,sinh(,cos(,cosh(,tan(,tanh(}
  else
   fun_d=sin(
  fi
  if $include_v_b fun_d.=v+ fi
  if narg(${funarg{$fp+2}})
   tv=${funarg{$fp+2}}
   argval={$tv%6}
   fun_d.=${arg\ $argval+1,sin(v)),sinh(v)),cos(v)),cosh(v)),tan(v)),tanh(v))}
  else
   fun_d.=tan(v))
  fi
 fi
else
 fun_d=$fun_b
fi

iw={w-1}
ih={h-1}

channels. 0 f. 0

{int(w*abs($2))},{int(h*abs($2))},1,1,":begin_t(
  const nw=w-1;
  const nh=h-1;
  const ww=$iw;
  const hh=$ih;
  const icx=ww/2;
  const icy=hh/2;
  const pts=$1;
  const H=$3;
  const K=$4;
  const zoom=1/$5;
  const ang=($6/180)*pi;
  const origin_x=$7*-1*zoom;
  const origin_y=$8*zoom;
  const sd=max(w,h)/min(w,h);
  const sx=w>h?sd:1;
  const sy=w>h?1:sd;
  const sx_zoom=sx*zoom;
  const sy_zoom=sy*zoom;
  const cx=(nw-1)/2;
  const cy=(nh-1)/2;
  const osx=origin_x*sx;
  const osy=origin_y*sy;
  const icx_zoom=icx/zoom;
  const icy_zoom=icy/zoom;
  const cxsx=icx*sx;
  const cysy=icy*sy;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  cnorm(a,b)=sum(sqr(a),sqr(b));
  fun_a(v)="$fun_a";
  fun_b(v)="$fun_b";
  fun_c(v)="$fun_c";
  fun_d(v)="$fun_d";
  popcorn_x(a,b)=a-H*fun_a(b+fun_b(K*b));
  popcorn_y(a,b)=b-H*fun_c(a+fun_d(K*a));
 );
 ix=sx_zoom*(x-cx)/cx;
 iy=sy_zoom*(y-cy)/cy;
 ix+=origin_x;
 iy+=origin_y;
 repeat(pts,
  nx=popcorn_x(ix,iy);
  ny=popcorn_y(ix,iy);
  zn=cnorm(nx,ny);
  ix=nx/zn;
  iy=ny/zn;
  xval="$fvx";
  yval="$fvy";
  xpos=round(xval);
  ypos=round(yval);
  i(#-1,xpos,ypos)++;
 );"
rm.
#@cli rep_pfrac : eq. to 'rep_popcorn_fractal' : (+)
rep_pfrac: rep_popcorn_fractal $*
#@cli rep_popcorn_fractal: _points>0,_density>0,_H,_K,_zoom,_rotation_angle,_origin_x,_origin_y,_mode,_f1={ 0=sin | 1=cos | 2=tan | 3=atan},...
#@cli : Generates Pickover Popcorn Fractal. Code was adapted from Paul Bourke's c code, and extended for more possibilities. Fractal is attributed to Clifford Pickover.\n
#@cli : _points defines the maximum number of points to be added on image based on pixel location.
#@cli : _density defines the frequency of points to be added along row and height of image. A value of one implies n points to be added per pixel.
#@cli : _H is the function multiplier used to subtract from the new found values from each iteration.
#@cli : _K is the inner multiplier for the inside function. See popcorn_x(a,b), and popcorn_y(a,b) embedded within the code of rep_popcorn_fractal for more information.
#@cli : _zoom defines the magnification of image. A negative value will "shrink" the structure of generated fractal.
#@cli : _rotation_angle defines the function angle of fractal.
#@cli : _origin_x defines the position of fractal. Center of image row will be treated as zero, and the ranges for image row are treated as -1,1.
#@cli : _origin_y defines the position of fractal. Center of image column will be treated as zero, and the ranges for image column are treated as -1,1.
#@cli : _mode defines whether to use 4 trigonometric functions or 6 trigonometric functions. Each halves of functions are used on 2 functions used by different axis.
#@cli : _fn defines individual function used for the popcorn fractal.\n
#@cli : Author: Reptorian.\n
#@cli : Default values: '_points=50','density=1','H=.05','_K=3','zoom=1','_rotation_angle=0','_origin_x=0','_origin_y=0','_mode=0',...\n
#@cli : \ \ \ \ If _mode=0: ... = '_f1=_f3=0','_f2=_f4=2'
#@cli : \ \ \ \ If _mode=1: ... = '_f1=_f4=0','_f2=_f5=1','_f3=_f6=2'\n
rep_popcorn_fractal:
skip ${1=50},${2=1},${3=.05},${4=3},${5=1},${6=0},${7=0},${8=0},${9=0},${10=},${11=},${12=},${13=},${14=},${15=}

if ($6-360*floor($6/360))?1
 fvx=((rot_x(xnew,ynew)-osx)*icx_zoom+cxsx)/sx
 fvy=((rot_y(xnew,ynew)-osy)*icy_zoom+cysy)/sy
else
 fvx=((xnew-osx)*icx_zoom+cxsx)/sx
 fvy=((ynew-osy)*icy_zoom+cysy)/sy
fi

iw={w-1}
ih={h-1}

channels. 0 f. 0

{int(w*abs($2))},{int(h*abs($2))},1,1,":begin_t(
  const nw=w-1;
  const nh=h-1;
  const ww=$iw;
  const hh=$ih;
  const icx=ww/2;
  const icy=hh/2;
  const pts=$1;
  const H=$3;
  const K=$4;
  const zoom=1/$5;
  const ang=($6/180)*pi;
  const origin_x=$7*-1*zoom;
  const origin_y=$8*zoom;
  const sd=max(w,h)/min(w,h);
  const sx=w>h?sd:1;
  const sy=w>h?1:sd;
  const sx_zoom=sx*zoom;
  const sy_zoom=sy*zoom;
  const cx=(nw-1)/2;
  const cy=(nh-1)/2;
  const osx=origin_x*sx;
  const osy=origin_y*sy;
  const icx_zoom=icx/zoom;
  const icy_zoom=icy/zoom;
  const cxsx=icx*sx;
  const cysy=icy*sy;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  $9?(
   if(narg($10),
    const argpos10=$10%4;
    argpos10==0?func_a(a)=sin(a):
    argpos10==1?func_a(a)=cos(a):
    argpos10==2?func_a(a)=tan(a):
    argpos10==3?func_a(a)=atan(a);
    ,func_a(a)=sin(a);
   );
   if(narg($11),
    const argpos11=$11%4;
    argpos11==0?func_b(a)=sin(a):
    argpos11==1?func_b(a)=cos(a):
    argpos11==2?func_b(a)=tan(a):
    argpos11==3?func_b(a)=atan(a);
    ,func_b(a)=cos(a);
   );
   if(narg($12),
    const argpos12=$12%4;
    argpos12==0?func_c(a)=sin(a):
    argpos12==1?func_c(a)=cos(a):
    argpos12==2?func_c(a)=tan(a):
    argpos12==3?func_c(a)=atan(a);
    ,func_c(a)=tan(a);
   );
   if(!narg($13),
    if(narg($10),
     argpos10==0?func_d(a)=sin(a):
     argpos10==1?func_d(a)=cos(a):
     argpos10==2?func_d(a)=tan(a):
     argpos10==3?func_d(a)=atan(a);
     ,func_d(a)=sin(a);
    );,
   const argpos13=$13%4;
   argpos13==0?func_d(a)=sin(a):
   argpos13==1?func_d(a)=cos(a):
   argpos13==2?func_d(a)=tan(a):
   argpos13==3?func_d(a)=atan(a);
   );
   if(!narg($14),
    if(narg($11),
     argpos11==0?func_e(a)=sin(a):
     argpos11==1?func_e(a)=cos(a):
     argpos11==2?func_e(a)=tan(a):
     argpos11==3?func_e(a)=atan(a);
     ,func_e(a)=cos(a);
    );,
   const argpos14=$14%4;
   argpos14==0?func_e(a)=sin(a):
   argpos14==1?func_e(a)=cos(a):
   argpos14==2?func_e(a)=tan(a):
   argpos14==3?func_e(a)=atan(a);
   );
   if(!narg($15),
    if(narg($12),
     argpos12==0?func_f(a)=sin(a):
     argpos12==1?func_f(a)=cos(a):
     argpos12==2?func_f(a)=tan(a):
     argpos12==3?func_f(a)=atan(a);
     ,func_f(a)=tan(a);
    );,
   const argpos15=$15%4;
   argpos15==0?func_f(a)=sin(a):
   argpos15==1?func_f(a)=cos(a):
   argpos15==2?func_f(a)=tan(a):
   argpos15==3?func_f(a)=atan(a);
   );
   popcorn_x(a,b)=(Kb=K*b;a-H*func_a(b+func_b(Kb+func_c(Kb))));
   popcorn_y(a,b)=(Ka=K*a;b-H*func_d(a+func_e(Ka+func_f(Ka))));
  ):(
   if(narg($10),
    const argpos10=$10%4;
    argpos10==0?func_a(a)=sin(a):
    argpos10==1?func_a(a)=cos(a):
    argpos10==2?func_a(a)=tan(a):
    argpos10==3?func_a(a)=atan(a);
    ,func_a(a)=sin(a);
   );
   if(narg($11),
    const argpos11=$11%4;
    argpos11==0?func_b(a)=sin(a):
    argpos11==1?func_b(a)=cos(a):
    argpos11==2?func_b(a)=tan(a):
    argpos11==3?func_b(a)=atan(a);
    ,func_b(a)=tan(a);
   );
   if(!narg($12),
    if(narg($10),
     argpos10==0?func_c(a)=sin(a):
     argpos10==1?func_c(a)=cos(a):
     argpos10==2?func_c(a)=tan(a):
     argpos10==3?func_c(a)=atan(a);
     ,func_c(a)=sin(a);
    );,
   const argpos12=$12%4;
   argpos12==0?func_c(a)=sin(a):
   argpos12==1?func_c(a)=cos(a):
   argpos12==2?func_c(a)=tan(a):
   argpos12==3?func_c(a)=atan(a);
   );
   if(!narg($13),
    if(narg($11),
     argpos11==0?func_d(a)=sin(a):
     argpos11==1?func_d(a)=cos(a):
     argpos11==2?func_d(a)=tan(a):
     argpos11==3?func_d(a)=atan(a);
     ,func_d(a)=tan(a);
    );,
   const argpos13=$13%4;
   argpos13==0?func_d(a)=sin(a):
   argpos13==1?func_d(a)=cos(a):
   argpos13==2?func_d(a)=tan(a):
   argpos13==3?func_d(a)=atan(a);
   );
   popcorn_x(a,b)=a-H*func_a(b+func_b(K*b));
   popcorn_y(a,b)=b-H*func_c(a+func_d(K*a));
  );
 );
 xx=sx_zoom*(x-cx)/cx;
 yy=sy_zoom*(y-cy)/cy;
 xx+=origin_x;
 yy+=origin_y;
 repeat(pts,
  xnew=popcorn_x(xx,yy);
  ynew=popcorn_y(xx,yy);
  xval="$fvx";
  yval="$fvy";
  xpos=round(xval);
  ypos=round(yval);
  i(#-1,xpos,ypos)++;
  xx=xnew;
  yy=ynew;
 );"
rm.
#@cli rep_x_graphical_tiling: [Images],_insertion_rate,_back_r,_back_g,_back_b
#@cli : Launch the interactive graphical tiling window.\n
#@cli : Details: The main purpose of this filter is to stimulate graphical tiling glitch observed in older operating system and computers. However, you can also use it to tile images by hand to artistic purpose.\n
#@cli : '[Images]' are images to be assigned to be tiled.
#@cli : '_insertion_rate' defines the rate of insertion per milliseconds.
#@cli : '_back_' defines the background color in the one of the preview mode.
#@cli : Default values: '_insertion_rate=0','_back_r=0','_back_g=0','_back_b=0'
rep_x_graphical_tiling:
skip ${2=0},${3=0},${4=0},${5=0}
is_windows_tileset=${"is_image_arg $1"}

e[] "\n Instruction on how to work with interactive windows.\n
 \ ---------------------------------------------------------\n\n
 \ - All Modes -\n\n
 \   * O: Change Preview Mode\n
 \   * SPACE: Switch Mode\n
 \   * ESC: End Interactive Window\n\n
 \ Important Note: Check the message in the title bar.\n\n
 \ - Image Placement Mode -\n\n
 \   * D: Display Overlay Image\n
 \   * H: Flip Image Horizontally\n
 \   * V: Flip Image Vertically\n
 \   * Mouse Click: Move/Place Image\n
 \   * ARROW UP/DOWN:Change Tiling Image\n
 \   * ARROW LEFT/RIGHT:Rotate Image\n
 \ - Tiling Mode - \n\n
 \   * Mouse Move: Place Tile at Insertion Rate\n
 \   * ARROW UP/DOWN: Add/Subtract Insertion Rate by 100 ms\n
 \   * ARROW LEFT/RIGHT: Add/Subtract Insertion Rate by 10 ms\n\n
 \ Additional Note: Type in 'h rep_x_graphical_tiling' for more information.\n\n
 \ ---------------------------------------------------------"

insertion_rate={max(0,$2)}

__r_back={max(0,abs($3))}
__g_back={max(0,abs($4))}
__b_back={max(0,abs($5))}

if $!!=1 error imgs!=1 fi
if !$is_windows_tileset error tile_imgs>0==F fi

pass$1 0

timg={$!}

ms=${-max_s}

if $ms>=3&&$ms<5 to_rgba
elif $ms==1&&$ms<3 to_graya
else error max_chan<5==F
fi

tnimg={$timg-1}

u {expr('w#(x+1)',$tnimg-1)} vec_w=[${}]
u {expr('h#(x+1)',$tnimg-1)} vec_h=[${}]

r {w#0},{h#0},100%,100%,0

{w},{h},1,{s},0

__w={w#0}
__h={h#0}
cx={w#0/2}
cy={h#0/2}
px=$cx
py=$cy
cpx=$cx
cpy=$cy
nx=0
ny=0

__display_mode=0
display_overlay_image=1

util_insertion=0
__ci=1

m "pass2endimage : pass[{$__ci}] 0 shift. $""1,$""2 blend alpha"

paint_mode=0
insert_duplicate_start=1
move_window=0
old_window=0
start_move=0
current_image=0
start=0
ex=-1
ey=-1

do

 if {*,SPACE}
  if $paint_mode paint_mode=0
  else paint_mode=1
  fi
  wait 50
 fi

 activate_preview=0

 if {*,O} __display_mode+=1 __display_mode={$__display_mode%3} activate_preview=1 wait 200 fi

 if !$start activate_preview=1 fi

 x,y,b,ww,wh={*,x,y,b,w,h}

 window_title=""

 if $paint_mode
  window_title.="Painting Mode [ Press SPACE TO Escape Painting Mode]"
  window_title.="- Insertion Rate - "
  window_title.=$insertion_rate
  window_title.=" ms"
  if {*,ARROWUP}" || "{*,ARROWRIGHT}
   if {*,ARROWUP} insertion_rate+=100
   else insertion_rate+=10
   fi
  elif {*,ARROWDOWN}" || "{*,ARROWLEFT}
   if {*,ARROWDOWN} insertion_rate-=100
   else insertion_rate-=10
   fi
   insertion_rate={max(0,$insertion_rate)}
  fi
 else
  if $display_overlay_image
   window_title.="Window Overlay Mode [ON]"
  else
   window_title.="Window Overlay Mode [OFF]"
  fi
  if {*,D} display_overlay_image+=1 display_overlay_image={$display_overlay_image%2} fi
  if {*,ARROWUP}" || "{*,ARROWDOWN}
   if {*,ARROWUP} current_image+=1
   else current_image-=1
   fi
   current_image={$current_image%($timg-1)}
   __ci={$current_image+1}
   wait 50
   activate_preview=1
  elif {*,ARROWLEFT}" || "{*,ARROWRIGHT}
   activate_preview=1
   r[$__ci] {($vec_w)[$__ci-1]},{($vec_h)[$__ci-1]},100%,100%,0
   if {*,ARROWRIGHT}
    rotate[$__ci] 90
   else
    rotate[$__ci] -90
   fi
   temp1={($vec_w)[$__ci-1]}
   temp2={($vec_h)[$__ci-1]}
   vec_w=[{"v=["$vec_w"];v["$__ci"-1]="$temp2";v"}]
   vec_h=[{"v=["$vec_h"];v["$__ci"-1]="$temp1";v"}]
   r[$__ci] {w#0},{h#0},100%,100%,0
  elif {*,H}" || "{*,V}
    r[$__ci] {($vec_w)[$__ci-1]},{($vec_h)[$__ci-1]},100%,100%,0
    if {*,H} mirror[$__ci] x
    elif {*,V} mirror[$__ci] y
    fi
    r[$__ci] {w#0},{h#0},100%,100%,0
  fi
 fi

 if {*,b}
  move_window+=1 move_window={$move_window%2}
  wait 50
  if !$start_move ox={$x} oy={$y} start_move=1 tpx=$px tpy=$py fi
 fi

 if !$paint_mode
  if $move_window
   if {*,C} tpx=$cx tpy=$cy ox={$x} oy={$y} fi
  else
   if {*,C} cpx=$cx cpy=$cy px=$cx py=$py fi
  fi
 fi

 if $move_window
  cpx={$tpx+$x-$ox}
  cpy={$tpy+$y-$oy}
  activate_preview=1
 fi

 if !$move_window&&$old_window
  px=$cpx
  py=$cpy
  start_move=0
  paint_mode=0
 fi

 old_window=$move_window

 if $paint_mode
  if ($ex!=$x)||($ey!=$y)
   spx={$cpx-(($vec_w)[$__ci-1]/2)}
   spy={$cpy-(($vec_h)[$__ci-1]/2)}
   pass2endimage[-1] $spx,$spy
   activate_preview=1
   wait $insertion_rate
  fi
  if $activate_preview
   if $__display_mode==0
    +blend[0,-1] alpha drgba.
   elif $__display_mode==1
    +drgba. $__r_back,$__g_back,$__b_back
   else
    +drgba.
   fi
   w[-1] {w#0},{h#0},0,$window_title
   k[0-$timg]
  fi
  ex=$x
  ey=$y
 else
  if $activate_preview
   spx={$cpx-(($vec_w)[$__ci-1]/2)}
   spy={$cpy-(($vec_h)[$__ci-1]/2)}
   if $display_overlay_image
    +shift[{$__ci}] $spx,$spy
    if $__display_mode==0
     +blend[0,-2,-1] alpha drgba.
    elif $__display_mode==1
     +blend[-2,-1] alpha drgba. $__r_back,$__g_back,$__b_back
    else
     +blend[-2,-1] alpha drgba.
    fi
   else
    if $__display_mode==0
     +blend[0,-1] alpha drgba.
    elif $__display_mode==1
     +drgba. $__r_back,$__g_back,$__b_back
    else
     +drgba.
    fi
   fi
   w[-1] {w#0},{h#0},0,$window_title
   k[0-$timg]
  fi
 fi

 insert_duplicate_start=1
 start=1
 activate_preview=0
 wait
while {*}" && "!{*,ESC}

um pass2endimage k[-1]
#@cli rep_jr_bps : eq. to 'rep_jr_bitplane_shuffler' : (+)
rep_jr_bps: rep_jr_bitplane_shuffler $*
#@cli rep_jr_bitplane_shuffler: _seed,_binary_swap={ 0=reverse | 1=forward },_bitdepth
#@cli : Apply bit plane swapping per pixels.
#@cli : (eq. to 'rep_jr_bps')\n
#@cli : Note: You can apply negative number to _binary_swap to use reverse effect.\n
#@cli : Default values: '_seed=?','_binary_swap=1','_bitdepth=8',
rep_jr_bitplane_shuffler:
skip ${1=u(0,1000000)},${2=1},${3=8}
repeat $! l[$>]
 repeat s
  sh. $>
  f. "begin(
   const bits=$3;
   const mb=2^bits;
   srand(mb*$1);
   shuf=index=vectorbits(0);
   repeat(bits,n,shuf[n]=index[n]=n);
   repeat(bits,n,m=int(u(0,mb))%bits;swap(shuf[m],shuf[n]);srand(m+n+1));
   ($2>0)?(swap(shuf,index));
  );
  val=0;
  repeat(bits,n,(int(i/(2^index[n]))%2)?(val+=(2^shuf[n])));
  val;
  "
  rm.
 done
endl done
#@cli rep_edgefade: radius>0,_exponential_factor>0 : radius>0,_exponential_factor>0,_nl_amplitude>0,0<_n_smooth<=1,0<_a_smooth<=1
#@cli : Fade edges on alpha. Only applicable for images with 2 channels or 4+ channels. The last channel is the alpha channel.\n
#@cli : Note: Execute 'gmic h normalize_local' for more information on '_nl_amplitude','_n_smooth', and '_a_smooth'. nl is short for normalize_local.\n
#@cli : Default values: '_exponential_factor=0','_nl_amplitude=0','_n_smooth=4%','_a_smooth=5%'
rep_edgefade:
skip ${2=1},${3=0},${4=4%},${5=2%}
percent_mode=0 if ${is_percent\ $1} percent_mode=1 fi
repeat $! l[$>]
 if s==2||s>=4
  sh. {s-1} Mval={iM#-1} n. 0,1 rm.
  +channels {s-1}
  r2dx. 200%,3
  l.
   if $3
    +normalize_local. $3,{$1*200%},$4,$5,1,0,1
    n. 0,1
   fi
   +f. i?1
   +distance[{$3?1:0}] 0,2
   if $percent_mode
    f. "begin(const valcheck=min(abs($1),1)*iM#-1;);i>=valcheck?1"
   else
    f. "begin(const valcheck=min(abs($1)*2,iM#-1););i>=valcheck?1"
   fi
   +f[{$3?1:0}] i#0!=0?(i#-2!=i#-1?1):0
   inpaint_pde.. [-1]
   f.. i^$2
   replace_nan.. 0
   f[0] i*i#-2
   k[0]
   r2dx 50%,3
  endl
  sh[0] {s#0-1}
  *. .. *. $Mval rm[-2,-1]
 fi
endl done
#@cli rep_kodl: eq. to 'rep_keep_original_dimension_and_or_layer' : (+)
rep_kodl:
_gmic_s="$?" v + _rep_keep_original_dimension_and_or_layer $"*"
#@cli rep_keep_original_dimension_and_or_layer: "command",_mode={ 0=old_dim | 1=old_dim_and_layer | 2=new_dim_and_layer},_interpolation, _boundary_conditions, _ax, _ay, _az
#@cli : Apply command to image(s), then have the option to preserve dimensions and/or resized layer.
#@cli : (eq. to 'rep_kodl').\n
#@cli : Default values: _preserve_resized_layer=0,_interpolation=0,_boundary_conditions=3,_ax=0.5,_ay=0.5,_az=0\n
#@cli : Author: Reptorian.
rep_keep_original_dimension_and_or_layer:
_gmic_s="$?" v + _$0 $"*"
_rep_keep_original_dimension_and_or_layer:
skip ${2=0},${3=0},${4=3},${5=.5},${6=.5},${7=0}
if $2==0||$2==1
 image_count={$!*3}
 dimensions_info=[{expr('p=int(x/3);arg(x%3+1,w#p,h#p,d#p);',$image_count);}]
fi
m "apply_filter:$1"
if abs($2)>=0&&abs($2)<=2
 repeat $! l[$<]
  if abs($2)>=1
   +apply_filter
   r[0] {w#-1},{h#-1},{d#-1},100%,${3-7}
  fi
  if abs($2)==1||!$2
   if !$2 apply_filter fi
   r {($dimensions_info)[$<*3+0]},{($dimensions_info)[$<*3+1]},{($dimensions_info)[$<*3+2]},100%,${3-7}
  fi
 endl done
fi
uncommand apply_filter
#@cli rep_lpasc_ordith: 'eq to. rep_loupasc_ordered_dither' : (+)
rep_lpasc_ordith: rep_loupasc_ordered_dither $*
#@cli rep_loupasc_ordered_dither : _dither_method={ 0=checkerboard | 1=dispersed | 2=arcade | 3=ordered | 4=lines | 5=custom | 6=random }, _palette={ 0=Binary | 1= EGA | 2= Web-safe | 3=12-bit }
#@cli: Color reduction with dithering using algorithm provided by Pascal Ollive.
rep_loupasc_ordered_dither:
f "begin(
 color_count=[2,4,6,16];
 custom_matrix=[34,14,3,22,6,27,21,8,26,13,30,1,29,18,33,5,20,12,9,0,19,28,10,32,16,31,7,17,2,25,4,24,15,35,23,11];
 line_matrix=[8,9,6,7,1,0,3,2,4,5,9,8,2,3,0,1,4,5,7,6,1,0,3,2,4,5,8,9,6,7,0,1,4,5,7,6,9,8,2,3,4,5,8,9,6,7,1,0,3,2,7,6,9,8,2,3,0,1,4,5,6,7,1,0,3,2,4,5,8,9,2,3,0,1,4,5,7,6,9,8,3,2,4,5,8,9,6,7,1,0,4,5,7,6,9,8,2,3,0,1];
 mat_rev(n)=(
  v = (n & 0x55555555) << 1 | (n >> 1) & 0x55555555;
  v = (v & 0x33333333) << 2 | (v >> 2) & 0x33333333;
  v = (v & 0x0f0f0f0f) << 4 | (v >> 4) & 0x0f0f0f0f;
  v = (v << 24) | ((v & 0xff00) << 8) | ((v >> 8) & 0xff00) | (v >> 24);
 v;
 );
 orddith(ipx,cc,coefcount,ditherpattern)=int((((cc-1)*coefcount+1)*ipx+255*ditherpattern-1)/(255*coefcount));
 randdit(ipx,cc,nx,ny)=(
  sd=(mat_rev(ny)>>23)<<22|mat_rev(nx)>>10;
  ditp=(48271*sd)%2147483647;
  int(((cc - 1) * ipx + (ditp / 8421506)) / 255);
 );
 $1==0?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,2,xor(nx,ny)&0x1):
 $1==1?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,4,((xor(nx,ny)&0x1)<<1)|(ny&0x1)):
 $1==2?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,8,2+(ny&0x3)):
 $1==3?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,5,line_matrix[20*(ny%5)+2*(nx%5)]>>1):
 $1==4?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,10,line_matrix[10*(ny%10)+(nx%10)]):
 $1==5?appdit(ipx,cc,nx,ny)=orddith(ipx,cc,36,custom_matrix[6*(ny%6)+(nx%6)]):
       appdit(ipx,cc,nx,ny)=randdit(ipx,cc,nx,ny);
 cc=color_count[$2];
 cs=255/(cc-1);
);
appdit(i,cc,x,y)*cs;
"
#@cli rep_sptbwgp_recpoltrans: eq. to 'rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation' : (+)
rep_sptbwgp_recpoltrans: rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation $*
#@cli rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation: -1<=_fxy_position<=1,0<=_influence_factor<=1, _threshold>=0,-1>=_ptxy_xpos<=1,-1>=_ptxy_ypos<=1,'_channel_mode='
#@cli : Apply 'rep_shift_pixel_to_boundary_with_group_pixels' effect with 'rep_rectangular_polar_transformation'\n
#@cli : (eq. to 'rep_sptbwgp_recpoltrans').\n
#@cli : '_fx_position' determines the location of pixel relative to ptxy points.
#@cli : '_influence_factor' determines how much influence the effect have on pixels.
#@cli : '_threshold' is used to eliminate alpha below the value.
#@cli : '_ptxy_xpos' assigns the location on point of influence
#@cli : '_ptxy_ypos' assigns the location on point of influence
#@cli : '_channel_mode' is a special variable. See 'gmic h rep_sptbwgp' for more information.\n
#@cli : Default values: '_fxy_position=-1','_influence_factor=1','_threshold=0','_ptxy_xpos=0','_ptxy_ypos=0','_channel_mode=N/A'\n
#@cli : Author: Reptorian.
rep_shift_pixel_to_boundary_with_group_pixels_with_rectangular_polar_transformation:
skip ${1=-1},${2=1},${3=0},${4=0},${5=0},${6=}
point={[$4,$5]}
tcr=3
if narg($6)
 if $6>=0
  tcr+=1
 else
  any_channels=1
 fi
fi
repeat $! l[$>]
 if h>w orientation=1
 else orientation=0
 fi
 if s==2||s>$tcr sh. {s-1} mina={im#-1} maxa={iM#-1} rm. fi
 rep_recpoltrans $point,-3
  if s==2||s>$tcr sh. {s-1} n. $mina,$maxa rm. fi
  rep_sptbwgp {$1*-1},1,$2,$3,$6
 rep_recpoltrans $point,2,$orientation
endl done
#@cli rep_tiler_n: eq. to 'rep_tiler_nonisometric' : (+)
rep_tiler_n:
skip ${4=16},${5=16},${6=},${7=0},${8=},${9=},${10=},${11=0},${12=50}
include_tileset_image=${"is_image_arg $1"}
include_tile_img=${"is_image_arg $6"}
if $include_tile_img&&$include_tileset_image pass$1 0 pass$6 0 rep_tiler_nonisometric[0] [-2],${2-5},[-1],${7--1} rm[-2,-1]
elif $include_tileset_image pass$1 0 rep_tiler_nonisometric[0] [-1],${2--1} rm.
elif $include_tile_img pass$6 0 rep_tiler_nonisometric[0] ${1-5},[-1],${7--1} rm.
else rep_tiler_nonisometric $*
fi
#@cli rep_tiler_nonisometric: { filename | [tileset] },min_tile>=3,increment>=0,_tileset_iw_width>=1,_tileset_ih_width>=1,{ _filename | [placed_tiles] },_preserve_bgout={ 0=eliminate_bg | 1=preserve_bg },_drgba_r>=0,_drgba_g>=0,_drgba_b>=0,_gridcol>=0,_trackpadcol>=0
#@cli : Launch the interactive non-isometric tiling toolkit. Mandatory variables are the first 3 ones!
#@cli : More info: The interactive non-isometric tiling toolkit is a near final version. Final version will have tiledata import and export. Perhaps with a master developer editor to make overworld art.\n
#@cli : (eq. to 'rep_tiler_n').\n
#@cli : Note: This is meant to enable artists to make artwork based on non-isometric RPG games or even world. It is not meant to be a tool to aid into making RPG games. If you want that, then you need to look into other solutions. Of course, there might be the off-chance that this tool is suitable for you.\n
#@cli : '{ filename | [tileset] }' can be either location of the tileset in text form, or as a image argument. If using image argument, you must do rep_tiler_nonisometric[target] [tile] to make it work.
#@cli : '__min_tile' defines the size of tiles.
#@cli : 'increment' defines the maximum possible selection length by number of tiles added by 1. 0 means maximum possible selection length by tile within axis is exactly 1.
#@cli : '_tileset_iw_width' defines the width of tileset visible within interactive window.
#@cli : '_tileset_ih_width' defines the width of tileset visible within interactive window.
#@cli : '_preserve_bgout' can be used to keep or erase image after painting tiles.
#@cli : '{ filename | [placed_tiles] }' can be either location of the tile in text form, or as a image argument. If using image argument, you must do rep_tiler_nonisometric[target] [tile] to make it work.
#@cli : '_dbrga_r' is the color of transparent background. If a value is assigned to this, then transparent areas are replaced with colored background instead of a checkerboard.
#@cli : '_dbrga_g' is the color of transparent background. If a value is assigned to this, then transparent areas are replaced with colored background instead of a checkerboard.
#@cli : '_dbrga_b' is the color of transparent background. If a value is assigned to this, then transparent areas are replaced with colored background instead of a checkerboard.
#@cli : '_gridcol' defines the color of grid within interactive window. Only grayscale value.
#@cli : '_trackpadcol' defines the color of tracker pad within interactive window. Only grayscale value.\n
#@cli : Default values: '_tileset_iw_width=16','_tileset_ih_width=16','_filename=""','_preserve_bgout=0','_drgba_r=','_drgba_g=','_drgba_b=','_gridcol=0','_trackpadcol=0'\n
#@cli : Author: Reptorian
##@cli : $ 640,480,1,4 rep_tileset_n generic_platform rep_tiler_n[0] [-1],32,3,16,16,,0,,,,0,0
##@cli : $ 640,480,1,4 rep_tiler_n[0] tile.png,16,1
rep_tiler_nonisometric:
skip ${4=16},${5=16},${6=},${7=0},${8=},${9=},${10=},${11=0},${12=50}
include_tileset_image=${"is_image_arg $1"}
include_tile_img=${"is_image_arg $6"}

__min_tile={abs($2)}
if $__min_tile<3 error "$"2>=3==F"" fi
max_increment={abs($3)}

tile_width=$__min_tile
tile_height=$__min_tile

gridcol={abs($11)}
trackpadcol={abs($12)}
__trackpadcol_alt=$trackpadcol

if narg($8)||narg($9)||narg($10)
 if narg($8) __r_col={min(abs($8),255)} else __r_col=0 fi
 if narg($9) __g_col={min(abs($9),255)} else __g_col=0 fi
 if narg($10) __b_col={min(abs($10),255)} else __b_col=0 fi
 m "xalp : drgba $__r_col,$__g_col,$__b_col"
else
 m "xalp : drgba"
fi

m "xalpa: xalp to_a"

m "out2display : skip ${""1=},${""2=},${""3=},${""4=1},${""5=1},${""6=},${""7=},${""8=},${""9=},${""10=} if narg($""1) if $""1 $__bg rv blend alpha fi fi xalp if narg($""6) if narg($""2)&&narg($""3)&&narg($""4)&&narg($""5) {$""4},{$""5},1,{s#0},i(#-1,$""2+x,$""3+y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],$""2,$""3 rm. if narg($""8)&&narg($""9)&&narg($""10) if $""8==0||$""8>2 {$""4},{$""5},1,{s#0},i(#0,$__nw+($__min_tile*$""9)-$""2+x-$""4,$""3+y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],{$__nw+($__min_tile*$""9)-$""2-$""4},$""3 rm. fi if $""8==1||$""8>2 {$""4},{$""5},1,{s#0},i(#0,$""2+x,$__nh+($__min_tile*$""10)-$""3+y-$""5) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],$""2,{$__nh+($__min_tile*$""10)-$""3-$""5} rm. fi if $""8==2||$""8>2 {$""4},{$""5},1,{s#0},i(#0,$__nw+($__min_tile*$""9)-$""2+x-$""4,$__nh+($__min_tile*$""10)-$""3+y-$""5) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""7))||x>ww-2)||(y<(2+narg($""7))||y>hh-2)?(xor($""6,i)>128?0:255):i j[0] [-1],{$__nw+($__min_tile*$""9)-$""2-$""4},{$__nh+($__min_tile*$""10)-$""3-$""5} rm. fi fi fi fi if narg($""7) f[0] begin(ww=w-1;hh=h-1;);(x%$__min_tile==0||y%$__min_tile==0)||(x==ww||y==hh)?$""7:i fi"

m "pass2tile : skip ${""4=2} pass$""1 $""4 f[0] i(#-1,$""2+x,$""3+y) rm."

m "tile2canvas : skip ${""4=0} pass$""1 0 +f. i(#0,$""2+x,$""3+y) if !$""4 rv[-2,-1] fi blend[-2,-1] alpha j[0] [-1],$""2,$""3 rm."

m "tile2canvas_r : +f. 0 j[0] [-1],$""1,$""2 rm. tile2canvas[0] [-1],$""1,$""2,$""3"

if $!==1
    ttw={ceil(w#0/$__min_tile)}
    tth={ceil(h#0/$__min_tile)}
    isw={$ttw}
    ish={$tth}
    $ttw,1,1,1 iscl={$ttw-1} store. __isc
    $tth,1,1,1 isrl={$tth-1} store. __isr
    __nw={$ttw*$__min_tile}
    __nh={$tth*$__min_tile}
    ttw-=2
    tth-=2
    to_a r $__nw,$__nh,100%,100%,0,0,.5,.5
    +store[0] obg
    xalpa
    cs={s#-1}
    +store[0] __bg
    if narg($6)
        if $include_tile_img pass$6 0
        else i $6
        fi
        if ((w#-1!=w#-2)||(h#-1!=h#-2)) error "Invalid Tile Image!" fi
        rm[0]
        to_a.
        start=1
    else
        f 0
        start=0
    fi
    +store[0] current_image
    +store[0] undo_image
else
    error "$!==1=F"
fi

m "tile2canvas_sym : pass$""1 0 +f. i(#0,$""2+x,$""3+y) if $""8==0||$""8==3 [1] if $""7 mirror. x fi +f. i(#0,$__nw+($__min_tile*$""9)-$""4-$""2+x,$""3+y) fi if $""8==1||$""8==3 [1] if $""7 mirror. y fi +f. i(#0,$""2+x,$__nh+($__min_tile*$""10)-$""5-$""3+y) fi if $""8==2||$""8==3 [1] if $""7 rotate. 180 fi +f. i(#0,$__nw+($__min_tile*$""9)-$""4-$""2+x,$__nh+($__min_tile*$""10)-$""5-$""3+y) fi if $""8==3 if !$""6 rv[-8,-7] rv[-6,-5] fi blend[-8,-7] alpha blend[-6,-5] alpha fi if !$""6 rv[-4,-3] rv[-2,-1] fi blend[-4,-3] alpha blend[-2,-1] alpha if $""8==3 j[0] [-4],$""2,$""3 j[0] [-3],{$__nw+($__min_tile*$""9)-$""4-$""2},$""3 j[0] [-2],$""2,{$__nh+($__min_tile*$""10)-$""5-$""3} j[0] [-1],{$__nw+($__min_tile*$""9)-$""4-$""2},{$__nh+($__min_tile*$""10)-$""5-$""3} k[0] else j[0] [-2],$""2,$""3 if $""8==0 j[0] [-1],{$__nw+($__min_tile*$""9)-$""4-$""2},$""3 elif $""8==1 j[0] [-1],$""2,{$__nh+($__min_tile*$""10)-$""5-$""3} elif $""8==2 j[0] [-1],{$__nw+($__min_tile*$""9)-$""4-$""2},{$__nh+($__min_tile*$""10)-$""5-$""3} fi rm[-2,-1] fi"

m "tile2canvas_r_sym : +f. 0 j[0] [-1],$""1,$""2 if $""6==3||$""6==0 j[0] [-1],{$__nw+($__min_tile*$""7)-$""3-$""1},$""2 fi if $""6==3||$""6==1 j[0] [-1],$""1,{$__nh+($__min_tile*$""8)-$""4-$""2} fi if $""6==3||$""6==2 j[0] [-1],{$__nw+($__min_tile*$""7)-$""3-$""1},{$__nh+($__min_tile*$""8)-$""4-$""2} fi rm. if $""5&&($""6==3||$""6==0) +mirror[1] x fi if $""5&&($""6==3||$""6==1) +mirror[1] y fi if $""5&&($""6==3||$""6==2) +rotate[1] 180 fi if $""6==3 tile2canvas[0] [{$""5?-4:1}],$""1,$""2 tile2canvas[0] [{$""5?-3:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},$""2 tile2canvas[0] [{$""5?-2:1}],$""1,{$__nh+($__min_tile*$""8)-$""4-$""2} tile2canvas[0] [{$""5?-1:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},{$__nh+($__min_tile*$""8)-$""4-$""2} k[0,1] else tile2canvas[0] [1],$""1,$""2 if $""6==0 tile2canvas[0] [{$""5?2:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},$""2 elif $""6==1 tile2canvas[0] [{$""5?2:1}],$""1,{$__nh+($__min_tile*$""8)-$""4-$""2} elif $""6==2 tile2canvas[0] [{$""5?2:1}],{$__nw+($__min_tile*$""7)-$""3-$""1},{$__nh+($__min_tile*$""8)-$""4-$""2} fi k[0,1] fi"

m "addsym2display : tlx={w#0/2+($""2/2)*$""3-2} tly={h#0/2+($""2/2)*$""4-2} if $""1<2 if $""1==0 4,{h#0},1,{s#0},begin(ww=w-1;dp=$""1<2?0:1;lp=dp+1;);x==0||x==ww?dp:lp elif $""1==1 {w#0},4,1,{s#0},begin(hh=h-1;dp=$""1<2?0:1;lp=dp+1;);y==0||y==hh?dp:lp fi *. 255 if $""1==0 j[0] [-1],$tlx,0 else j[0] [-1],0,$tly fi k[0] else ntlx={$tlx+3} ntly={$tly+3} f[0] ((x>=$tlx&&x<=$ntlx)||(y>=$tly&&y<=$tly+3))?((x==$tlx||x==$ntlx)||(y==$tly||y==$ntly)?0:255):i fi"

m "filter_to_selected_row_column: if $__altmode_orientation $__isr f[0] i(#-1,floor((y+$__pmin*$__min_tile)/$__min_tile),0,0,0)?i:0 else $__isc f[0] i(#-1,floor((x+$__pmin*$__min_tile)/$__min_tile),0,0,0)?i:0 fi k[0]"

m "out2display_alt : skip ${""1=},${""2=},${""3=},${""4=},${""5=} if $__altmode_orientation?$__vmax_y:$__vmax_x sh {s-1} if $__altmode_orientation $__isr f.. i(#-1,floor(y/$__min_tile),0,0,0)?i:i*.625 else $__isc f.. i(#-1,floor(x/$__min_tile),0,0,0)?i:i*.625 fi rm[-2,-1] fi if narg($""1) if $""1 $__bg rv blend alpha fi fi xalp if narg($""2) if $__altmode_orientation $__isr {w#0},{h#0},1,1,i(#-1,floor(y/$__min_tile),0,0,0)?1:0 else $__isc {w#0},{h#0},1,1,i(#-1,floor(x/$__min_tile),0,0,0)?1:0 fi f. ($__altmode_orientation?i(#-2,floor(y/$__min_tile),0,0,0):i(#-2,floor(x/$__min_tile),0,0,0))?!(i&&(j(-2,-2,0,0)&&j(-2,-1,0,0)&&j(-2,0,0,0)&&j(-2,1,0,0)&&j(-2,2,0,0)&&j(-1,-2,0,0)&&j(-1,-1,0,0)&&j(-1,0,0,0)&&j(-1,1,0,0)&&j(-1,2,0,0)&&j(1,-2,0,0)&&j(1,-1,0,0)&&j(1,0,0,0)&&j(1,1,0,0)&&j(1,2,0,0)&&j(2,-2,0,0)&&j(2,-1,0,0)&&j(2,0,0,0)&&j(2,1,0,0)&&j(2,2,0,0)&&j(0,-2,0,0)&&j(0,-1,0,0)&&j(0,1,0,0)&&j(0,2,0,0))) if narg($""3) f. !($__altmode_orientation?i(#-2,floor(x/$__min_tile),0,0,0):i(#-2,floor(y/$__min_tile),0,0,0))?(i?(j(-1,0)||j(0,-1))):i fi rm.. f[0] i(#-1,x,y,z,0)?(xor(i(#-1,x,y,z,0)*$__trackpadcol_alt,i)>128?0:255):i rm. fi if narg($""4)||narg($""5) if $__altsymmetry_mode if $__altmode_orientation {w#0},{$__min_tile},1,{s#0},i(#0,x,$""5+y) {w#0},{$__min_tile},1,{s#0},i(#0,x,$__nh+($__altsymmetry_posy-1)*$__min_tile-$""5+y) f[-2,-1] begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j... [-2],0,$""5 j... [-1],0,{h#0+($__altsymmetry_posy-1)*$__min_tile-$""5} else {$__min_tile},{h#0},1,{s#0},i(#0,$""4+x,y) {$__min_tile},{h#0},1,{s#0},i(#0,$__nw+($__altsymmetry_posx-1)*$__min_tile-$""4+x,y) f[-2,-1] begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j... [-2],$""4,0 j... [-1],{w#0+($__altsymmetry_posx-1)*$__min_tile-$""4},0 fi rm[-2,-1] else if $__altmode_orientation {w#0},{$__min_tile},1,{s#0},i(#0,x,$""5+y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j.. [-1],0,$""5 else {$__min_tile},{h#0},1,{s#0},i(#0,$""4+x,y) f. begin(ww=w-1;hh=h-1;);(x<(2+narg($""3))||x>ww-2)||(y<(2+narg($""3))||y>hh-2)?(xor($__trackpadcol_alt,i)>128?0:255):i j.. [-1],$""4,0 fi rm. fi fi if narg($""3) f. begin(ww=w-1;hh=h-1;);(x%$__min_tile==0||y%$__min_tile==0)||(x==ww||y==hh)?$""3:i fi"

m "out2display_alt_perp : skip ${""3=},${""4=} if narg($""3) if $""3 $__bg rv blend alpha fi fi xalp if $__altmode_orientation $__isr {w#0},{$__pdiff*$__min_tile},1,{s#0},i(#-1,floor(y/$__min_tile)+$__pmin,0,0,0) f. i?(!(j(-2,-2)&&j(-2,-1)&&j(-2,0)&&j(-2,1)&&j(-2,2)&&j(-1,-2)&&j(-1,-1)&&j(-1,0)&&j(-1,1)&&j(-1,2)&&j(0,-2)&&j(0,-1)&&j(0,1)&&j(0,2)&&j(1,-2)&&j(1,-1)&&j(1,0)&&j(1,1)&&j(1,2)&&j(2,-2)&&j(2,-1)&&j(2,0)&&j(2,1)&&j(2,2))?(xor($__trackpadcol_alt,i(#0,x,$""2+y))>128?0:255):i(#0,x,$""2+y)):i(#0,x,$""2+y); j[0] [-1],0,$""2 else $__isc {$__pdiff*$__min_tile},{h#0},1,{s#0},i(#-1,floor(x/$__min_tile)+$__pmin,0,0,0) f. i?(!(j(-2,-2)&&j(-2,-1)&&j(-2,0)&&j(-2,1)&&j(-2,2)&&j(-1,-2)&&j(-1,-1)&&j(-1,0)&&j(-1,1)&&j(-1,2)&&j(0,-2)&&j(0,-1)&&j(0,1)&&j(0,2)&&j(1,-2)&&j(1,-1)&&j(1,0)&&j(1,1)&&j(1,2)&&j(2,-2)&&j(2,-1)&&j(2,0)&&j(2,1)&&j(2,2))?(xor($__trackpadcol_alt,i(#0,$""1+x,y))>128?0:255):i(#0,$""1+x,y)):i(#0,$""1+x,y); j[0] [-1],$""1,0 fi rm[-2,-1] if narg($""4) f. begin(ww=w-1;hh=h-1;);(x%$__min_tile==0||y%$__min_tile==0)||(x==ww||y==hh)?$""4:i fi"

m "keeperase_rowcolumn : if $__altmode_orientation $__isr if $""1 f.. i(#-1,floor(y/$__min_tile),0,0,0)?i:0 else f.. i(#-1,floor(y/$__min_tile),0,0,0)?0:i fi else $__isc if $""1 f.. i(#-1,floor(x/$__min_tile),0,0,0)?i:0 else f.. i(#-1,floor(x/$__min_tile),0,0,0)?0:i fi fi rm."

m "shift_rowcolumn : if $__altmode_orientation $__isr if !($__shiftboundary>0&&$__shiftboundary<4) f[0] i(#-1,floor(y/$__min_tile),0,0,0)?j(-$""1,0,0,0,0,$__shiftboundary-($__shiftboundary?2)):i; else f[0] begin(ww=w-1;);i(#-1,floor(y/$__min_tile),0,0,0)?i(x-$""1>ww?((w-$__min_tile)+($__shiftboundary==3?(floor((x-$""1-w)/$__min_tile)%2?(x-w)%$__min_tile:$__min_tile-(x-w)%$__min_tile-1):(($__shiftboundary-1)?($__min_tile-(x-w)%$__min_tile-1):(x-w)%$__min_tile))):(x-$""1>=0?x-$""1:($__shiftboundary==3?(floor((x-$""1)/$__min_tile)%2?($__min_tile-x%$__min_tile):x%$__min_tile):(($__shiftboundary-1)?($__min_tile-x%$__min_tile):x%$__min_tile))),y):i; fi else $__isc if !($__shiftboundary>0&&$__shiftboundary<4) f[0] i(#-1,floor(x/$__min_tile),0,0,0)?j(0,-$""2,0,0,0,$__shiftboundary-($__shiftboundary?2)):i; else f[0] begin(hh=h-1;);i(#-1,floor(x/$__min_tile),0,0,0)?i(x,y-$""2>hh?((h-$__min_tile)+($__shiftboundary==3?(floor((y-$""2-h)/$__min_tile)%2?(y-h)%$__min_tile:$__min_tile-(y-h)%$__min_tile-1):(($__shiftboundary-1)?($__min_tile-(y-h)%$__min_tile-1):(y-h)%$__min_tile))):(y-$""2>=0?y-$""2:($__shiftboundary==3?(floor((y-$""2)/$__min_tile)%2?($__min_tile-y%$__min_tile):y%$__min_tile):(($__shiftboundary-1)?($__min_tile-y%$__min_tile):y%$__min_tile)))):i; fi fi rm."

m "place_rowcolumn : if $__altmode_orientation if $__altplace_replacemode $__isr pass$""1 0 {w#-1},{h#-1},1,1,i(#-2,floor(y/$__min_tile)+$__pmin,0,0,0) j[0] [-2],0,$""3,0,0,1,[-1],1 else pass$""1 0 {w#0},{h#0},1,{s#0},j(#-1,0,-$""3) rm.. if $__altplacebackmode rv fi blend alpha fi else if $__altplace_replacemode $__isc pass$""1 0 {w#-1},{h#-1},1,1,i(#-2,floor(x/$__min_tile)+$__pmin,0,0,0) j[0] [-2],$""2,0,0,0,1,[-1],1 else pass$""1 0 {w#0},{h#0},1,{s#0},j(#-1,-$""2,0) rm.. if $__altplacebackmode rv fi blend alpha fi fi k[0]"

m "fill_tiles2canvas : if $__fill_boundary==0 f[0] i(#-1,x%w#-1,y%h#-1) elif $__fill_boundary==1 f[0] i(#-1,int(x/w#-1)%2?w#-1-1-x%w#-1:x%w#-1,int(y/h#-1)%2?h#-1-1-y%h#-1:y%h#-1) elif $__fill_boundary==2 f[0] i(#-1,int(x/w#-1)%2?w#-1-1-x%w#-1:x%w#-1,y%h#-1) elif $__fill_boundary==3 f[0] i(#-1,x%w#-1,int(y/h#-1)%2?h#-1-1-y%h#-1:y%h#-1) fi"

v +
e[] "\n Instruction on how to work with interactive windows.\n
 \ ---------------------------------------------------------\n\n
 \ Press Escape on Canvas Window to exit!\n\n
 \ *** MAIN EDITING MODE ***\n\n
 \ - On any window - \n
 \   * D: Switch between Place/Eraser Mode\n
 \   * R: Activate Replace Mode\n
 \   * W: Restore All Windows\n
 \   * SPACEBAR: Switch Mode\n\n
 \ - On Canvas window - \n
 \   * C: Activate Copy Mode On/Off\n
 \   * X: Activate Cut Mode On/Off\n
 \   * Z: Undo Canvas Changes\n
 \   * F: Activate/Deactivate Background Tile Layering Mode\n
 \   * G: Activate Canvas Grid Mode On/Off\n
 \   * Q: Remove/Restore Background\n
 \   * A: Enable/Disable Tracker\n
 \   * S: Activate Symmetry Mode\n\n
 \   -- On Canvas [Symmetry Mode] --\n
 \     * 1: Switch Symmetry Axis to X-Axis\n
 \     * 2: Switch Symmetry Axis to Y-Axis\n
 \     * 3: Switch Symmetry Axis to Cross XY-Axis\n
 \     * 4: Switch Symmetry Axis to Mirror XY-Axis\n
 \     * ARROWKEY: Move Symmetry Line\n
 \     * B: Switch Axis in Symmetry Mode\n
 \     * M: Switch between Periodic/Mirror boundary mode in Symmetry Mode\n
 \     * J: Symmetry Line(s) to Center\n
 \     * S: Deactivate Symmetry Mode\n\n
 \ - On Tileset window - \n
 \   * G: Activate Tileset Grid Mode On/Off\n
 \   * CTRL+ARROWKEY: Resize Tile Selection Box\n
 \   * ARROWKEY: Scroll through tileset\n\n
 \ - On Tile window - \n
 \   * CTRL+ARROWKEY: Mirror alongside axis\n
 \   * ARROWKEY: Rotate Tile\n
 \   * MOUSE BUTTON: Switch between Place/Eraser Mode\n\n
 \   -- On Tile [No Symmetry Mode] --\n
 \     * 1: Switch Fill Boundary to Periodic\n
 \     * 2: Switch Fill Boundary to Mirror\n
 \     * 3: Switch Fill Boundary to Mirror X\n
 \     * 4: Switch Fill Boundary to Mirror Y\n
 \     * B: Increment Fill Boundary Mode\n\n
 \ *** ROW/COLUMN EDITING MODE ***\n\n
 \ - On any window - \n
 \   * W: Restore All Windows\n
 \   * SPACEBAR: Switch Mode\n\n
 \ - On Canvas window - \n
 \   * Z: Undo Canvas Changes\n
 \   * T: Enable Row/Column Shifting Mode\n
 \   * E: Activate Place Mode\n
 \   * G: Activate Canvas Grid Mode On/Off\n
 \   * Q: Remove/Restore Background\n
 \   * A: Enable/Disable Tracker\n
 \   * S: Activate Symmetrical Selection Mode\n\n
 \   -- On Canvas [Selection Mode] --\n
 \     * C: Keep Selected Row/Column\n
 \     * X: Delete Selected Row/Column\n
 \     * D: Select/Deselect Row/Column\n
 \     * R: Clear Selection\n
 \     * V: View Selection Box/Hide Selection Box\n
 \     * Mouse Button: Select or Deselect\n
 \     * ARROWKEY: Switch between Row/Column Selection Mode\n\n
 \   -- On Canvas [Selection Mode](Symmetry Mode)--\n
 \     * J: Symmetry Line to Center\n
 \     * ARROWKEY: Move Symmetry Line\n
 \     * S: Deactivate Symmetrical Selection Mode\n\n
 \   -- On Canvas [Row/Column Shifting Mode] --\n
 \     * Mouse Button (First Click): Activate Shifting\n
 \     * Mouse Button (Second Click): Finalize Shifting\n
 \     * 0: Shift Boundary Mode - None\n
 \     * 1: Shift Boundary Mode - Neumann (Periodic)\n
 \     * 2: Shift Boundary Mode - Neumann (Mirror)\n
 \     * 3: Shift Boundary Mode - Neumann (Alternating)\n
 \     * 4: Shift Boundary Mode - Periodic\n
 \     * 5: Shift Boundary Mode - Mirror\n
 \     * ARROWKEY: Switch between row/column\n
 \     * T: Disable Row/Column Shifting Mode\n\n
 \   -- On Canvas [Place Mode] --\n
 \     * Mouse Button: Place Row/Column\n
 \     * B: Switch between Replacement/Placement Mode\n
 \     * F: In Placement Mode, switch between background/foreground placement mode\n
 \     * E: Deactivate Place Mode\n\n
 \   -- On Tile window - \n
 \     * ARROWKEY: Flip Row/Column\n
 \ ---------------------------------------------------------\n"
v -

if $include_tileset_image
    pass$1 0
else
    i $1
fi

l.
    xr={ceil(w#-1/(abs($4)*$__min_tile))}
    yr={ceil(h#-1/(abs($5)*$__min_tile))}
    split_tiles. {-abs($4)*$__min_tile},{-abs($5)*$__min_tile}
    mw=${-max_w}
    mh=${-max_h}
    tsw={$mw-$__min_tile}
    tsh={$mh-$__min_tile}
    ti={$!}
endl

$__min_tile,$__min_tile,1,4,0
fti={$!}

$__bg
+xalp.

dw0c={w#0}
dh0c={h#0}

dwm0=0
dwm1=0
dwm2=0

d2rw=196

w[-1] {w#0},{h#0},0,"Canvas"
rm[-2,-1]
+xalp[1]
w1[-1] {w#1},{h#1},0,"Tileset" rm.
w2[-1] $d2rw,$d2rw,0,"Tile"

+store. switchmode_tile

fti={$!}

mode=0

 icx=0
 icy=0
 ci=0
 lr=0
 tb=0
 tbc=0
 ni=1

 cutcopymode=0
 erasemode=0
 replacemode=0
 editmode=0

 symmetrymode=0
 symmetryaxis=0
 symmetrybound=0
 symmetry_posx=0
 symmetry_posy=0

 canvas_background=1
 canvas_gridmode=0
 canvas_tracker=1

 tileset_gridmode=0
 temp_tileset_gridmode=0

 select_from_tileset=0

 resize_tile_from_tileset=0
 resize_tile_from_canvas=0
 transform_tile=0
 switch_tile_set=0

 tile_placement_mode=0

 current_csx=-1
 current_csy=-1
 optinsert=1

 __fill_boundary=0
 __corner_fill=0

#mode=1#

 activated_switched_twice=0
 modeswitched=0
 mainaltmode=1
 viewselectionbox=1
 selectionboxmode=0
 deselectmode=0
 activate_deselect_select=0
 movemode=0
 delmode=0
 transfermode=0

 rowcolumnshiftmode=0
 shiftplacecount=0
 __shiftboundary=1
 altrcx1=-1
 altrcy1=-1
 altrcx2=-1
 altrcx2=-1

 current_acsx=-1
 current_acsy=-1
 altx=-1
 alty=-1
 tempaltx=-1
 tempalty=-1
 activate_altpreview=0
 activate_altpass2tile=0

 __altsymmetry_mode=0
 __altsymmetry_posx=0
 __altsymmetry_posy=0
 __altmode_orientation=0

 __vmax_x=0
 __vmax_y=0
 pmax=0
 __pmin=0
 __pdiff=0

 place_rowcolumn_mode=0
 __altplacebackmode=0
 __altplace_replacemode=1

do
 main_w_title="Canvas"
 if $start
  if $mode main_w_title.=" [Row/Column Editing Mode]"
  else main_w_title.=" [Main Editing Mode] -" fi
 fi

 modeswitched=0
 if {*,SPACE}" || "{*1,SPACE}" || "{*2,SPACE}" && "$start mode+=1 mode={$mode%2} modeswitched=1 wait 100 fi

 if $modeswitched
  +store. temp_switch_tile
  $switchmode_tile
  rv[-2,-1]
  rm.
  $temp_switch_tile
  store. switchmode_tile
  if $mode
   +out2display. , w2[-1] {w#-1},{h#-1},-1,-1,"Tile" rm.
   w1[] 0
  else
   +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
   +out2display[$ni] , w1[-1] {w#$ni+$dwm1*w#$ni},{h#$ni+$dwm1*h#$ni} rm.
  fi
 fi

 if $start&&$mode
  if {*,G} canvas_gridmode+=1   canvas_gridmode={$canvas_gridmode%2} wait 100 activate_altpreview=1 fi
  if {*,Q} canvas_background+=1 canvas_background={$canvas_background%2} wait 100 activate_altpreview=1 fi
  if {*,A} canvas_tracker+=1 canvas_tracker={$canvas_tracker%2} wait 100 activate_altpreview=1 fi
  if {*,S} __altsymmetry_mode+=1 __altsymmetry_mode={$__altsymmetry_mode%2} wait 200 activate_altpreview=1 fi
  if {*,E} mainaltmode+=1 mainaltmode={$mainaltmode%2} wait 200 activate_altpreview=1 fi
  if {*,V} viewselectionbox+=1 viewselectionbox={$viewselectionbox%2} wait 200 activate_altpreview=1 fi

  if $mainaltmode if {*,D} deselectmode+=1 deselectmode={$deselectmode%2} wait 200 activate_altpreview=1 activate_deselect_select=1 fi fi

  undo_state=0
  if {*,Z} undo_state=1 fi
  if $undo_state
   +store[0] temp_undo
   $undo_image
   rv[0,-1]
   rm.
   activate_altpreview=1
   $temp_undo
   store. undo_image
  fi

  if {*,T} rowcolumnshiftmode+=1 rowcolumnshiftmode={$rowcolumnshiftmode%2} wait 200 activate_altpreview=1 if $shiftplacecount shiftplacecount=0 fi fi

  if $rowcolumnshiftmode
   if {*,0} __shiftboundary=0 wait 200 activate_altpreview=1 fi
   if {*,1} __shiftboundary=1 wait 200 activate_altpreview=1 fi
   if {*,2} __shiftboundary=2 wait 200 activate_altpreview=1 fi
   if {*,3} __shiftboundary=3 wait 200 activate_altpreview=1 fi
   if {*,4} __shiftboundary=4 wait 200 activate_altpreview=1 fi
   if {*,5} __shiftboundary=5 wait 200 activate_altpreview=1 fi
   if {*,M} __shiftboundary+=1 __shiftboundary={$__shiftboundary%6} wait 200 activate_altpreview=1 fi
  fi

  if {*,W} w[] 1 w2[] 1 fi

  if {*2,ARROWLEFT}" || "{*2,ARROWRIGHT} mirror. x transform_tile=1 wait 100
  elif {*2,ARROWUP}" || "{*2,ARROWDOWN} mirror. y transform_tile=1 wait 100
  fi

  if $transform_tile
   +out2display. , w2[-1] rm.
   transform_tile=0
  fi

  if !$mainaltmode
   if {*,B} __altplace_replacemode+=1 __altplace_replacemode={$__altplace_replacemode%2} wait 200 activate_altpreview=1 fi
   if !$__altplace_replacemode&&{*,F} __altplacebackmode+=1 __altplacebackmode={$__altplacebackmode%2} wait 200 activate_altpreview=1 fi
  fi

  if {*,R}
   if $__altmode_orientation
    $__isr f. 0 store. __isr __vmax_y=0
   else
    $__isc f. 0 store. __isc __vmax_x=0
   fi
   activate_altpreview=1
  fi

  if $mainaltmode&&!$rowcolumnshiftmode
   if $__altsymmetry_mode
    if $__altmode_orientation
     if {*,ARROWUP} __altsymmetry_posy-=1  __altsymmetry_posy={max(-$tth,$__altsymmetry_posy)} activate_altpreview=1 wait 200 fi
     if {*,ARROWDOWN} __altsymmetry_posy+=1 __altsymmetry_posy={min($tth,$__altsymmetry_posy)} activate_altpreview=1 wait 200 fi
     if {*,ARROWLEFT}||{*,ARROWRIGHT} __altmode_orientation=0 activate_altpreview=1 wait 200 fi
     if {*,J} __altsymmetry_posy=0 activate_altpreview=1 wait 200 fi
    else
     if {*,ARROWLEFT} __altsymmetry_posx-=1  __altsymmetry_posx={max(-$ttw,$__altsymmetry_posx)} activate_altpreview=1 wait 200 fi
     if {*,ARROWRIGHT} __altsymmetry_posx+=1 __altsymmetry_posx={min($ttw,$__altsymmetry_posx)} activate_altpreview=1 wait 200 fi
     if {*,ARROWUP}||{*,ARROWDOWN} __altmode_orientation=1 activate_altpreview=1 wait 200 fi
     if {*,J} __altsymmetry_posx=0 activate_altpreview=1 wait 200 fi
    fi
   else
     if {*,ARROWLEFT}||{*,ARROWRIGHT}||{*,ARROWUP}||{*,ARROWDOWN} __altmode_orientation+=1 __altmode_orientation={$__altmode_orientation%2} activate_altpreview=1 wait 200 fi
   fi
  elif $mainaltmode&&$rowcolumnshiftmode
   if {*,ARROWLEFT}||{*,ARROWRIGHT} __altmode_orientation+=1 __altmode_orientation={$__altmode_orientation%2} activate_altpreview=1 wait 200 fi
  fi

  if $mainaltmode&&!$rowcolumnshiftmode
   if $deselectmode main_w_title.=" - [Deselection]"
   else main_w_title.=" - [Selection]"
   fi
  elif $mainaltmode&&$rowcolumnshiftmode
   main_w_title.=" - [Shift] (Boundary Condition - "
   if $__shiftboundary==0 main_w_title.="None)"
   elif $__shiftboundary==1 main_w_title.="Neumann (Periodic))"
   elif $__shiftboundary==2 main_w_title.="Neumann (Mirror))"
   elif $__shiftboundary==3 main_w_title.="Neumann (Alternating))"
   elif $__shiftboundary==4 main_w_title.="Periodic)"
   else main_w_title.="Mirror)"
   fi
  else
   main_w_title.=" - [Place] "
   if $__altplace_replacemode
    main_w_title.="(Replacement Mode)"
   else
    if $__altplacebackmode main_w_title.="(Background)"
    else main_w_title.="(Foreground)"
    fi
   fi
  fi

  if $viewselectionbox&&$canvas_gridmode
   canvas_set=$canvas_background,$viewselectionbox,$gridcol,
  elif $viewselectionbox
   canvas_set=$canvas_background,$viewselectionbox,,
  elif $canvas_gridmode
   canvas_set=$canvas_background,,$gridcol,
  fi

  x,y,b,ww,wh={*,x,y,b,w,h}

  if $b" && "$x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0" && "!{*,G}
   acsx={floor($x/$__min_tile)} acsy={floor($y/$__min_tile)}
   if $mainaltmode&&!$rowcolumnshiftmode
    if ($__altmode_orientation?(($current_acsy!=$acsy)||$__vmax_y==0):(($current_acsx!=$acsx)||$__vmax_x==0))||$activate_deselect_select
     if !$deselectmode
      if !$__altmode_orientation
       $__isc
       f. x==$acsx?1:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posx;);x==(ww-$acsx)?1:i; fi
       __vmax_x={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$iscl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isc
      else
       $__isr
       f. x==$acsy?1:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posy;);x==(ww-$acsy)?1:i; fi
       __vmax_y={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$isrl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isr
      fi
     else
      if !$__altmode_orientation
       $__isc
       f. x==$acsx?0:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posx;);x==(ww-$acsx)?0:i; fi
       __vmax_x={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$iscl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isc
      else
       $__isr
       f. x==$acsy?0:i
       if $__altsymmetry_mode f. begin(ww=w-1;ww+=$__altsymmetry_posy;);x==(ww-$acsy)?0:i; fi
       __vmax_y={iM#-1}
       __pmin={find([crop(#-1)],1,0,1)}
       pmax={find([crop(#-1)],1,$isrl,-1)}
       __pdiff={$pmax-$__pmin+1}
       store. __isr
      fi
     fi
     activate_altpreview=1
     activate_altpass2tile=1
    fi
   elif $mainaltmode&&$rowcolumnshiftmode
    if $shiftplacecount==0
     altrcx1={$acsx*$__min_tile}
     altrcy1={$acsy*$__min_tile}
     activate_altpreview=1
     shiftplacecount+=1
    elif $shiftplacecount==1
     altrcx2={$acsx*$__min_tile}
     altrcy2={$acsy*$__min_tile}
     activate_altpreview=1
     shift_rowcolumn[0] {$altrcx2-$altrcx1},{$altrcy2-$altrcy1}
     if $__altmode_orientation
      if abs($altrcy2-$altrcy1)
       +store[0] undo_image
      fi
     else
      if abs($altrcx2-$altrcx1)
       +store[0] undo_image
      fi
     fi
     shiftplacecount=0
    fi
    wait 100
   else
    if $__altmode_orientation?($current_acsy!=$acsy):($current_acsx!=$acsx)
     +store[0] undo_image
     place_rowcolumn[0] [-1],{min($acsx,$isw-$__pdiff)*$__min_tile},{min($acsy,$ish-$__pdiff)*$__min_tile}
     activate_altpreview=1
    fi
   fi
   current_acsx=$acsx current_acsy=$acsy
  fi

  if $__altmode_orientation?$__vmax_y>0:$__vmax_x>0
   if $activate_altpass2tile
    if !$__altmode_orientation
     r. {$__pdiff*$__min_tile},{h#0}
     pass2tile. [0],{$__pmin*$__min_tile},0
    else
     r. {w#0},{$__pdiff*$__min_tile}
     pass2tile. [0],0,{$__pmin*$__min_tile}
    fi
    filter_to_selected_row_column.
    +out2display. , w2[-1] {w#-1},{h#-1},-1,-1,"Tile" rm.
   fi
   activate_altpass2tile=0
   if {*,K}||{*,C}
    +store[0] undo_image
    keeperase_rowcolumn[0] 1
    wait 200
    activate_altpreview=1
   fi
   if {*,X}
    +store[0] undo_image
    keeperase_rowcolumn[0] 0
    wait 200
    activate_altpreview=1
   fi
  else
   r. 1,1
   f. 0
   +out2display. , w2[-1] {$d2rw},{$d2rw},-1,-1,"Tile" rm.
   mainaltmode=1
   rowcolumnshiftmode=0
   deselectmode=0
  fi

  if $mainaltmode
   if !$rowcolumnshiftmode
    if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0" && "$canvas_tracker" && "($canvas_tracker||$activate_altpreview)
     altx={floor($x/$__min_tile)*$__min_tile} alty={floor($y/$__min_tile)*$__min_tile}
     if ($__altmode_orientation?($alty!=$tempalty):($altx!=$tempaltx))||$activate_altpreview
      canvas_set.=$altx,$alty
      +out2display_alt[0] $canvas_set if $__altsymmetry_mode addsym2display. $__altmode_orientation,$__min_tile,$__altsymmetry_posx,$__altsymmetry_posy fi w[-1] {w#0},{h#0},0,$main_w_title rm.
     fi
     tempaltx=$altx tempalty=$alty
    else
     +out2display_alt[0] $canvas_set if $__altsymmetry_mode addsym2display. $__altmode_orientation,$__min_tile,$__altsymmetry_posx,$__altsymmetry_posy fi w[-1] {w#0},{h#0},0,$main_w_title rm.
    fi
    activate_altpreview=0
   else
    if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
     if $activate_altpreview
      altx={floor($x/$__min_tile)*$__min_tile} alty={floor($y/$__min_tile)*$__min_tile}
      if $shiftplacecount
       if (!$__altmode_orientation?($alty!=$tempalty):($altx!=$tempaltx))||$activate_altpreview
        +shift_rowcolumn[0] {$altx-$altrcx1},{$alty-$altrcy1}
        out2display_alt. $canvas_set
        w[-1] {w#0},{h#0},0,$main_w_title rm.
       fi
       tempaltx=$altx tempalty=$alty
      else
       +out2display_alt[0] $canvas_set
       w[-1] {w#0},{h#0},0,$main_w_title rm.
       activate_altpreview=0
      fi
     fi
    fi
   fi
  else
   if $canvas_gridmode
     perp_end=$canvas_background,$gridcol
   else
     perp_end=$canvas_background
   fi
   if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
    altx={min(floor($x/$__min_tile),$isw-$__pdiff)*$__min_tile} alty={min(floor($y/$__min_tile),$ish-$__pdiff)*$__min_tile}
    if ($__altmode_orientation?($alty!=$tempalty):($altx!=$tempaltx))||$activate_altpreview
     +out2display_alt_perp[0] $altx,$alty,$perp_end w[-1] {w#0},{h#0},0,$main_w_title rm.
    fi
    tempaltx=$altx tempalty=$alty
    activate_altpreview=0
   fi
  fi

 else
  if {*,G}
   canvas_gridmode+=1
   canvas_gridmode={$canvas_gridmode%2} fi
  if {*,Q}
   canvas_background+=1
   canvas_background={$canvas_background%2} fi
  if {*,A}
   canvas_tracker+=1
   canvas_tracker={$canvas_tracker%2} fi

  undo_state=0
  canvas_set=""

  if {*,W}" || "{*1,W}" || "{*2,W} w[] w1[] w2[] fi

  if {*,Z} undo_state=1 fi

  if {*,F} tile_placement_mode+=1 tile_placement_mode={$tile_placement_mode%2} fi
  if {*,R}" || "{*1,R}" || "{*2,R}
   replacemode+=1 replacemode={$replacemode%2} optinsert=1
  fi

  if {*,S} symmetrymode+=1 symmetrymode={$symmetrymode%2} optinsert=1 fi

  if $symmetrymode
   if {*,1} symmetryaxis=0 wait 200 fi
   if {*,2} symmetryaxis=1 wait 200 fi
   if {*,3} symmetryaxis=2 wait 200 fi
   if {*,4} symmetryaxis=3 wait 200 fi
   if {*,B} symmetryaxis+=1 symmetryaxis={$symmetryaxis%4} wait 200 fi
   if {*,M} symmetrybound+=1 symmetrybound={$symmetrybound%2} wait 200  fi
   if {*,J} symmetry_posx=0 symmetry_posy=0 wait 200 fi
   if {*,ARROWLEFT} symmetry_posx-=1 wait 200 fi
   if {*,ARROWRIGHT} symmetry_posx+=1 wait 200 fi
   if {*,ARROWUP} symmetry_posy-=1 wait 200 fi
   if {*,ARROWDOWN} symmetry_posy+=1 wait 200 fi
   symmetry_posx={$symmetry_posx>=0?min($ttw,$symmetry_posx):max(-$ttw,$symmetry_posx)}
   symmetry_posy={$symmetry_posy>=0?min($tth,$symmetry_posy):max(-$tth,$symmetry_posy)}
  else
   if {*2,1} __fill_boundary=0 wait 200
   elif {*2,2} __fill_boundary=1 wait 200
   elif {*2,3} __fill_boundary=2 wait 200
   elif {*2,4} __fill_boundary=3 wait 200
   fi
   if {*2,B} __fill_boundary={($__fill_boundary+1)%4} wait 200 fi
  fi

  if $canvas_gridmode
   if $canvas_tracker canvas_endset=,$trackpadcol,$gridcol,
   else canvas_endset=,,$gridcol,
   fi
  else
   if $canvas_tracker canvas_endset=,$trackpadcol,
   else canvas_endset=",,"
   fi
  fi
  if {*,C}" || "{*,X}
   if {*,X} cutcopymode=1
   else cutcopymode=2
   fi
  fi

  if {*,D}" || "{*1,D}" || "{*2,D}
   erasemode+=1
   erasemode={$erasemode%2}
   if $erasemode  +f. 0 w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
   else +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
   fi
   optinsert=1
  fi

  if {*1,G} tileset_gridmode+=1 tileset_gridmode={$tileset_gridmode%2} wait 200 temp_tileset_gridmode=1 fi

  x,y,b,ww,wh={*,x,y,b,w,h}
  x1,y1,b1,ww1,wh1={*1,x,y,b,w,h}
  x2,y2,b2,ww2,wh2={*2,x,y,b,w,h}

  if $start
   if $undo_state
    +store[0] temp_undo
    $undo_image
    rv[0,-1]
    rm.
    $temp_undo
    store. undo_image
   fi

   if {{*2,CTRLLEFT}" || "{*2,CTRLRIGHT}}" && "{{*2,ARROWLEFT}" || "{*2,ARROWRIGHT}}
    mirror. x transform_tile=1
    wait 100
   elif {{*2,CTRLLEFT}" || "{*2,CTRLRIGHT}}" && "{{*2,ARROWUP}" || "{*2,ARROWDOWN}}
    mirror. y transform_tile=1
    wait 100
   elif {*2,ARROWLEFT}||{*2,ARROWRIGHT}
    temp_tile_width=$tile_width
    temp_tile_height=$tile_height
    temp_icx=$icx
    temp_icy=$icy
    icx=$temp_icy
    icy=$temp_icx
    tile_width=$temp_tile_height
    tile_height=$temp_tile_width

    if {*2,ARROWRIGHT} rotate. 90 else rotate. -90 fi
    transform_tile=1

    wait 100
   fi

   if {*2,O}" && "!$symmetrymode
    +store[0] undo_image
    fill_tiles2canvas
    wait 100
   fi

   if $transform_tile
    +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
    transform_tile=0
    optinsert=1
   fi

   if {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWRIGHT}}
    if $select_from_tileset
     icx+=1
     icx={min($icx,$max_increment)}
     tile_width={$__min_tile+($icx*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWLEFT}}
    if $select_from_tileset
     icx-=1
     icx={max($icx,0)}
     tile_width={$__min_tile+($icx*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWDOWN}}
    if $select_from_tileset
     icy+=1
     icy={min($icy,$max_increment)}
     tile_height={$__min_tile+($icy*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {{{*1,CTRLLEFT}" || "{*1,CTRLRIGHT}}" && "{*1,ARROWUP}}
    if $select_from_tileset
     icy-=1
     icy={max($icy,0)}
     tile_height={$__min_tile+($icy*$__min_tile)}
    fi

    if $select_from_tileset resize_tile_from_tileset=1 fi

    wait 500
   elif {*1,ARROWRIGHT}
    select_from_tileset=0
    lr+=1
    lr={$lr%$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    switch_tile_set=1
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    wait 625
   elif {*1,ARROWLEFT}
    select_from_tileset=0
    lr-=1
    lr={$lr%$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    switch_tile_set=1
    wait 625
   elif {*1,ARROWDOWN}
    select_from_tileset=0
    tbc+=1
    tbc={$tbc%$yr}
    tb={$tbc*$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    switch_tile_set=1
    wait 625
   elif {*1,ARROWUP}
    select_from_tileset=0
    tbc-=1
    tbc={$tbc%$yr}
    tb={$tbc*$xr}
    ci={($lr+$tb)%$ti}
    ni={$ci+1}
    tsw={w#$ni-$__min_tile}
    tsh={h#$ni-$__min_tile}
    switch_tile_set=1
    wait 625
   fi

   if $switch_tile_set
    +out2display[$ni] , w1[-1] {w#$ni+$dwm1*w#$ni},{h#$ni+$dwm1*h#$ni} rm.
    switch_tile_set=0
   fi

   if $resize_tile_from_tileset
     r. $tile_width,$tile_height,100%,100%,0
     tsx={min($tsx,$tsw-($icx*$__min_tile))} tsy={min($tsy,$tsh-($icy*$__min_tile))}
     pass2tile. [$ni],$tsx,$tsy
     +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
     if $tileset_gridmode
      +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol,$gridcol
     else
      +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol
     fi
     w1[-1] rm.
     resize_tile_from_tileset=0
   fi

   if $b" && "$x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
    csx={min(floor($x/$__min_tile)*$__min_tile,($iscl-$icx)*$__min_tile)} csy={min(floor($y/$__min_tile)*$__min_tile,($isrl-$icy)*$__min_tile)}
    if !$cutcopymode&&!$erasemode
     if (($current_csx!=$csx)||($current_csy!=$csy))||$optinsert
      +store[0] undo_image
      if $replacemode
       if $symmetrymode
        tile2canvas_r_sym[0,-1] $csx,$csy,$tile_width,$tile_height,$symmetrybound,$symmetryaxis,$symmetry_posx,$symmetry_posy
       else
        tile2canvas_r[0,-1] $csx,$csy,$tile_placement_mode
       fi
      else
       if $symmetrymode
        tile2canvas_sym[0] [-1],$csx,$csy,$tile_width,$tile_height,$tile_placement_mode,$symmetrybound,$symmetryaxis,$symmetry_posx,$symmetry_posy
       else
        tile2canvas[0] [-1],$csx,$csy,$tile_placement_mode
       fi
      fi
     fi
     optinsert=0
    elif $cutcopymode&&!$erasemode
     if $cutcopymode==1
      +store[0] undo_image
      pass2tile. [0],$cx,$cy {w#-1},{h#-1},1,{s#-1} j[0] [-1],$cx,$cy rm.
     else
      pass2tile. [0],$csx,$csy optinsert=0
     fi
     +out2display. , w2[-1] {$d2rw+($d2rw*$icx)},{$d2rw+($d2rw*$icy)} rm.
     cutcopymode=0
     optinsert=1
     temp_tileset_gridmode=1
     select_from_tileset=0
    else
     +store[0] undo_image
     cutcopymode=0
     if (($current_csx!=$csx)||($current_csy!=$csy))||$optinsert
      if $symmetrymode
       $tile_width,$tile_height,1,{s#0}
       j[0] [-1],$csx,$csy
       if $symmetryaxis==3||$symmetryaxis==0 j[0] [-1],{$__nw+($__min_tile*$symmetry_posx)-$tile_width-$csx},$csy fi
       if $symmetryaxis==3||$symmetryaxis==1 j[0] [-1],$csx,{$__nh+($__min_tile*$symmetry_posy)-$tile_height-$csy} fi
       if $symmetryaxis==3||$symmetryaxis==2 j[0] [-1],{$__nw+($__min_tile*$symmetry_posx)-$tile_width-$csx},{$__nh+($__min_tile*$symmetry_posy)-$tile_height-$csy} fi
       rm.
      else
       $tile_width,$tile_height,1,{s#0} j[0] [-1],$csx,$csy rm.
      fi
     fi
    fi
    current_csx=$csx current_csy=$csy
   fi

  fi

  if $b1" && "$x1>=0" && "$y1>=0" && "$x1<w#1" && "$y1<h#1
   cutcopymode=0
   start=1
   optinsert=1
   select_from_tileset=1
   erasemode=0
   tsx={min(floor($x1/$__min_tile)*$__min_tile,$tsw-($icx*$__min_tile))} tsy={min(floor($y1/$__min_tile)*$__min_tile,$tsh-($icy*$__min_tile))}
   pass2tile. [$ni],$tsx,$tsy
   +out2display. , w2[-1] rm.

   if $tileset_gridmode
    +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol,$gridcol
   else
    +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol
   fi
   w1[-1] rm.

   wait 50
  fi

  if $temp_tileset_gridmode
   if $select_from_tileset
    if $tileset_gridmode
     +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol,$gridcol
    else
     +out2display[$ni] 0,$tsx,$tsy,$tile_width,$tile_height,$trackpadcol
    fi
    w1[-1] rm.
   else
    if $tileset_gridmode
     +out2display[$ni] 0,0,0,1,1,,$gridcol
    else
     +out2display[$ni] 0,0,0,1,1
    fi
    w1[-1] rm.
   fi
   temp_tileset_gridmode=0
  fi

  if !$start
   if $canvas_gridmode
    +out2display[0] $canvas_background,0,0,1,1,,$gridcol
   else
    +out2display[0] $canvas_background
   fi
   if $symmetrymode addsym2display. $symmetryaxis,$__min_tile,$symmetry_posx,$symmetry_posy fi
   w[-1] rm.
  else
   if $x>=0" && "$y>=0" && "$x<w#0" && "$y<h#0
    cx={min(floor($x/$__min_tile)*$__min_tile,($iscl-$icx)*$__min_tile)} cy={min(floor($y/$__min_tile)*$__min_tile,($isrl-$icy)*$__min_tile)}
    canvas_set=$canvas_background,$cx,$cy,$tile_width,$tile_height
    canvas_set.=$canvas_endset
    if $symmetrymode
     if $canvas_gridmode canvas_set.=$symmetryaxis,$symmetry_posx,$symmetry_posy
     else canvas_set.=,$symmetryaxis,$symmetry_posx,$symmetry_posy
     fi
    fi
    +out2display[0] $canvas_set
    if $symmetrymode addsym2display. $symmetryaxis,$__min_tile,$symmetry_posx,$symmetry_posy fi
    w[-1]
    rm.
   else
    if $canvas_gridmode
     +out2display[0] $canvas_background,0,0,1,1,,$gridcol
    else
     +out2display[0] $canvas_background
    fi
    if $symmetrymode addsym2display. $symmetryaxis,$__min_tile,$symmetry_posx,$symmetry_posy fi
    w[-1] rm.
   fi
  fi

  if $start
   if $erasemode main_w_title.=" (Eraser Mode) - "
   else
    if $cutcopymode
     if $cutcopymode==2 main_w_title.=" (Copy Mode) - "
     else main_w_title.=" (Cut Mode) - "
     fi
    else
     if $replacemode main_w_title.=" (Replacement Mode) - "
     else
      if $tile_placement_mode main_w_title.=" (Place Tile [Background]) - "
      else main_w_title.=" (Place Tile [Foreground]) - "
      fi
     fi
    fi
   fi

   if !$symmetrymode
    if $__fill_boundary==0 main_w_title.=" Fill Boundary [Periodic] - "
    elif $__fill_boundary==1 main_w_title.=" Fill Boundary [Mirror] - "
    elif $__fill_boundary==2 main_w_title.=" Fill Boundary [Mirror X] - "
    elif $__fill_boundary==3 main_w_title.=" Fill Boundary [Mirror Y] - "
    fi
   fi

   if $canvas_tracker main_w_title.="(Tracker)" fi
   if $canvas_gridmode main_w_title.="(Grid)" fi
   if $symmetrymode
    if $symmetryaxis==0
     if $symmetrybound main_w_title.="(Symmetry-X (Mirror))"
     else main_w_title.="(Symmetry-X (Periodic))"
     fi
    elif $symmetryaxis==1
     if $symmetrybound main_w_title.="(Symmetry-Y (Mirror))"
     else main_w_title.="(Symmetry-Y (Periodic))"
     fi
    elif $symmetryaxis==2
     if $symmetrybound main_w_title.="(Symmetry-XY (Corner) (Mirror))"
     else main_w_title.="(Symmetry-XY (Corner)(Periodic))"
     fi
    else
     if $symmetrybound main_w_title.="(Symmetry-XY (Reflected) (Mirror))"
     else main_w_title.="(Symmetry-XY (Reflected) (Periodic))"
     fi
    fi
   fi
  fi
  w[] -1,-1,-1,-1,$main_w_title
 fi
 wait 100
while {*}" && "!{*,ESC}
uncommand xalp,xalpa,out2display,pass2tile,tile2canvas,tile2canvas_r,tile2canvas_sym,tile2canvas_r_sym,fill_tiles2canvas,addsym2display,filter_to_selected_row_column,out2display_alt,out2display_alt_perp,keeperase_rowcolumn,shift_rowcolumn,place_rowcolumn
w1[] 0
w2[] 0
k[0]
if $7 $obg rv blend alpha fi
#@cli rep_trsa: eq. to 'rep_technorobbo_strange_attractor' : (+)
rep_trsa: rep_technorobbo_strange_attractor $*
#@cli rep_technorobbo_strange_attractor: _algorithm,_density,_scalefactor,_attractor_var_1,_attractor_var_2,_attractor_var_3,_attractor_var_4,_attractor_var_5,_attractor_var_6,_attractor_var_7,_attractor_var_8,_attractor_var_9
#@cli : Generates Attractor Fractal with equations provided by TechnoRobbo.
#@cli : (eq. to 'rep_trsa').\n
#@cli : Default values: '_density=7','_scalefactor=1','_attractor_var_1=u(0,1)','_attractor_var_2=u(0,1)','_attractor_var_3=u(0,1)','_attractor_var_4=u(0,1)','_attractor_var_5=u(0,1)','_attractor_var_6=u(0,1)','_attractor_var_7=u(0,1)','_attractor_var_8=u(0,1)','_attractor_var_9=u(0,1)'
rep_technorobbo_strange_attractor:
skip ${2=7},${3=1},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=0}

if '$_host'=='cli' if narg($*)>12 error narg(\$"13")<13==F fi fi

max_width=${-max_w}
max_height=${-max_h}
if $!>1 $max_width,$max_height,1,1 else channels 0 f 0 fi

cv_0={narg($4)?$4:u(0,1)}
cv_1={narg($5)?$5:u(0,1)}
cv_2={narg($6)?$6:u(0,1)}
cv_3={narg($7)?$7:u(0,1)}
cv_4={narg($8)?$8:u(0,1)}
cv_5={narg($9)?$9:u(0,1)}
cv_6={narg($10)?$10:u(0,1)}
cv_7={narg($11)?$11:u(0,1)}
cv_8={narg($12)?$12:u(0,1)}

1,1,1,1

eval ${-math_lib}"
interpolate(a,b)=a*-b+(1-a)*b;
eucl_norm(a,b)=sqrt(a^2+b^2);

const use_run=$13;

const mw=w#-2;
const mh=h#-2;
const cenx=mw/2;
const ceny=mh/2;
const cenf=(eucl_norm(cenx,ceny)/2.5)*$3;

xc=yc=zc=0;

const cv_0=$cv_0;
const cv_1=$cv_1;
const cv_2=$cv_2;
const cv_3=$cv_3;
const cv_4=$cv_4;
const cv_5=$cv_5;
const cv_6=$cv_6;
const cv_7=$cv_7;
const cv_8=$cv_8;

if($1<=4,
 const a=interpolate(cv_0,3);
 const b=interpolate(cv_1,3);

 if($1!=3&&$1<4,
  const c=interpolate(cv_2,3);
  const d=interpolate(cv_3,3);
 ,
  const c=interpolate(cv_2,3);
  const d=interpolate(cv_3,3);
  const e=interpolate(cv_4,3);
  const f=interpolate(cv_5,3);
 );

 if($1<2,xc=-.5;yc=-.5;,
 if($1==2,xc=-1;
 );
 );
,
 if($1==5,
  const a=interpolate(cv_0,2);
  const b=interpolate(cv_1,2);
  const c=interpolate(cv_2,2);
  const d=interpolate(cv_3,2);
  const e=interpolate(cv_4,2);
  const f=interpolate(cv_5,2);
  const l=interpolate(cv_6,2);
  const h=interpolate(cv_7,2);
  const j=interpolate(cv_8,2);
  ,
  const a=interpolate(cv_0,3);
  const b=interpolate(cv_1,3);
  const c=interpolate(cv_2,3);
  const d=interpolate(cv_3,3);
  const e=interpolate(cv_4,3);
  const f=interpolate(cv_5,3);
 );
);

if($1==0,
 xnf(cx,cy)=sin(cy*b)+c*sin(b*cx);
 ynf(cx,cy)=sin(a*cx)+d*sin(a*cy);,
if($1==1,
 xnf(cx,cy)=sin(cy*a)+cos(c*cx);
 ynf(cx,cy)=sin(c*cx)-cos(d*cy);,
if($1==2,
 xnf(cx,cy)=abs(sin(cy*a)^3)+cos(c*cx);
 ynf(cx,cy)=abs(sin(c*cx)^2)-cos(d*cy)^2;,
if($1==3,
 xnf(cx,cy)=sin(cy*a)+cos(a*cx);
 ynf(cx,cy)=sin(b*cx)-cos(b*cy);,
if($1==4,
 xnf_3d(cx,cy,cz)=cy*sin(a*cx)+sin(b*cy);
 ynf_3d(cx,cy,cz)=cz*cos(c*cy)-cos(d*cz);
 znf_3d(cx,cy,cz)=cx*sin(e*cz)+cos(f*cx);,
if($1==5,
 xnf_3d(cx,cy,cz)=cy*sin(a*cx)+cos(b*cy)+sin(c*cz);
 ynf_3d(cx,cy,cz)=cz*sin(d*cx)+cos(e*cy)+sin(f*cz);
 znf_3d(cx,cy,cz)=cx*sin(l*cx)+cos(h*cy)+sin(j*cz);,
#if[$1==6,#
 xnf_3d(cx,cy,cz)=cz*sin(a*cx)+cos(b*cy);
 ynf_3d(cx,cy,cz)=cx*sin(c*cy)+cos(d*cz);
 znf_3d(cx,cy,cz)=cy*sin(e*cz)+cos(f*cx);
);
);
);
);
);
);

const td=abs($2)*10^6;
pixcount=0;

if($1<4,
 repeat(td,n,
  xn=xnf(xc,yc);
  yn=ynf(xc,yc);
  xc=xn;
  yc=yn;
  nx=xn*cenf*.75;
  ny=yn*cenf*.75;
  fnx=nx>=0?nx:mw+nx;
  fny=ny>=0?ny:mh+ny;
  if(!i(#-2,fnx,fny),pixcount++;);
  i(#-2,fnx,fny)+=1;
  if(use_run,if(!(n%200000),run('progress ',100*(n/td))););
 );
,
 repeat(td,n,
  xn=xnf_3d(xc,yc,zc);
  yn=ynf_3d(xc,yc,zc);
  zn=znf_3d(xc,yc,zc);
  xc=xn;
  yc=yn;
  zc=zn;
  nx=xn*cenf*1;
  ny=yn*cenf*1;
  fnx=nx>=0?nx:mw+nx;
  fny=ny>=0?ny:mh+ny;
  if(!i(#-2,fnx,fny),pixcount++;);
  i(#-2,fnx,fny)+=1;
  if(use_run,if(!(n%200000),run('progress ',100*(n/td))););
 );
);

pixcount;
"
shift.. 50%,50%,0,0,2 rm.
#@cli rep_tg3: eq. to 'rep_trigonometry_three_channel_gradient' : (+)
rep_tg3: rep_trigonometry_three_channel_gradient $*
#@cli rep_trigonometry_three_channel_gradient: _resolution,_chan_order={ 0=0,1,2 | 1=0,2,1 | 2=1,0,2 | 3=1,2,0 | 4=2,0,1 | 5=2,1,0 },_chan_form_a={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier_a>0,_valueshift_a,0>=_midgray_expf_a>=1,_lightness_merge_factor_a>=1,_lightness_end_expf_a>0,0>=_gray2col_end_a>=1,_chan_form_b={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier_b>0,_valueshift_b,0>=_midgray_expf_b>=1,_lightness_merge_factor_b>=1,_lightness_end_expf_b>0,0>=_gray2col_end_b>=1,_chan_form_c={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier_c>0,_valueshift_c,0>=_midgray_expf_c>=1,_lightness_merge_factor_c>=1,_lightness_end_expf_c>0,0>=_gray2col_end_c>=1
#@cli : Creates trigonometry gradients or map images with trigonometry coloring.
#@cli : (eq. to 'rep_tg3').\n
#@cli : '_resolution' defines the length of gradient or the way it is going to be mapped. See below for more information on _resolution.
#@cli : '_chan_order' defines the order of channel of gradient
#@cli : '_chan_form' refers to the formula each channels use
#@cli : '_multiplier' defines the multiplication of base gradient used to map formula based on trigonometry.
#@cli : '_valueshift' refers to the value shift of base gradient
#@cli : '_midgray_expf' refers to the middle-point of base gradient used to map formula based on trigonometry relative to middle.
#@cli : '_lightness_merge_factor' refers to the merging of lightness gradient with color gradient. Used to add white and black to gradient ends.
#@cli : '_lightness_end_expf' defines the magnitude of shades and tind of each end of end gradient
#@cli : '_gray2col_end' defines how much the end gradient overrides the base gradient\n
#@cli : '_resolution' values and processing info
#@cli : -----
#@cli : Info #1: If '_resolution' is a number: If _resolution is negative, create a 3-channel trigonometry vertical gradient, else create 3-channel trigonometry horizontal gradient.
#@cli : Info #2: If '_resolution' is "8i", then map trigonometry function by first dividing by 255, then perform trigonometry function, finally multiply by 255.
#@cli : Info #3: If '_resolution' is "8il", then image will be converted into RGBA luminosity format, then perform trigonometry function, finally multiply by 255.
#@cli : Info #4: If '_resolution' is empty, then directly map trigonometry function.
#@cli : -----\n
#@cli : Default values: 'resolution=256','_chan_order=0','_chan_form_a=0','_multiplier_a=1','_valueshift_a=0','_midgray_expf_a=1','_lightness_merge_factor_a=1','_lightness_end_expf_a=0','_gray2col_end_a=1','_chan_form_b=_chan_form_a','_multiplier_b=_multiplier_a','_valueshift_b=_valueshift_a','_midgray_expf_b=_midgray_expf_a','_lightness_merge_factor_b=_lightness_merge_factor_a','_lightness_end_expf_b=_lightness_end_expf_a','_gray2col_end_b=_gray2col_end_a','_chan_form_c=_chan_form_b','_multiplier_c=_multiplier_b','_valueshift_c=_valueshift_b','_midgray_expf_c=_midgray_expf_b','_lightness_merge_factor_c=_lightness_merge_factor_b','_lightness_end_expf_c=_lightness_end_expf_b','_gray2col_end_c=_gray2col_end_b'\n
#@cli : Author: Reptorian.
rep_trigonometry_three_channel_gradient:
echo "Map trigonometry function within image"("s")""
skip ${1=},${2=0},${3=},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=},${16=},${17=},${18=},${19=},${20=},${21=},${22=},${23=}
v + e "\nMap trigonometry function within image"("s")"" v -
if narg($3) channel_formula_a=$3    else channel_formula_a=0    fi
if narg($4) multiplier_a=$4      else multiplier_a=1      fi
if narg($5) valueshift_a=$5      else valueshift_a=0      fi
if narg($6) midgray_expf_a=$6    else midgray_expf_a=1    fi
if narg($7) lightness_merge_factor_a=$7   else lightness_merge_factor_a=1   fi
if narg($8) lightness_end_expf_a=$8    else lightness_end_expf_a=0    fi
if narg($9) gray2col_end_a=$9    else gray2col_end_a=1    fi

if narg($10) channel_formula_b=$10  else channel_formula_b=$channel_formula_a     fi
if narg($11) multiplier_b=$11    else multiplier_b=$multiplier_a         fi
if narg($12) valueshift_b=$12    else valueshift_b=$valueshift_a         fi
if narg($13) midgray_expf_b=$13     else midgray_expf_b=$midgray_expf_a        fi
if narg($14) lightness_merge_factor_b=$14 else lightness_merge_factor_b=$lightness_merge_factor_a   fi
if narg($15) lightness_end_expf_b=$15  else lightness_end_expf_b=$lightness_end_expf_a     fi
if narg($16) gray2col_end_b=$16     else gray2col_end_b=$gray2col_end_a        fi

if narg($17) channel_formula_c=$17  else channel_formula_c=$channel_formula_b     fi
if narg($18) multiplier_c=$18    else multiplier_c=$multiplier_b         fi
if narg($19) valueshift_c=$19    else valueshift_c=$valueshift_b         fi
if narg($20) midgray_expf_c=$20     else midgray_expf_c=$midgray_expf_b        fi
if narg($21) lightness_merge_factor_c=$21 else lightness_merge_factor_c=$lightness_merge_factor_b   fi
if narg($22) lightness_end_expf_c=$22  else lightness_end_expf_c=$lightness_end_expf_b     fi
if narg($23) gray2col_end_c=$23     else gray2col_end_c=$gray2col_end_b        fi

channel_formula=[$channel_formula_a,$channel_formula_b,$channel_formula_c]
multiplier=[$multiplier_a,$multiplier_b,$multiplier_c]
valueshift=[$valueshift_a,$valueshift_b,$valueshift_c]
midgray_expf=[$midgray_expf_a,$midgray_expf_b,$midgray_expf_c]
lightness_merge_factor=[$lightness_merge_factor_a,$lightness_merge_factor_b,$lightness_merge_factor_c]
lightness_end_expf=[$lightness_end_expf_a,$lightness_end_expf_b,$lightness_end_expf_c]
gray2col_end=[$gray2col_end_a,$gray2col_end_b,$gray2col_end_c]

channel_order=${arg\ $2+1,\"[0,1,2]\",\"[0,2,1]\",\"[1,0,2]\",\"[1,2,0]\",\"[2,0,1]\",\"[2,1,0]\"}

repeat $!,img_id
 if s#$img_id<3||s#$img_id>4 error s#$img_id>2&&s#$img_id<4==F fi
done

if isnum($1)
 if $1>0   $1,1,1,3,"begin(ww=w-1;);x/ww"
 elif $1<0 1,abs($1),1,3,"begin(hh=h-1;);y/hh"
 else error _$1!=0==F
 fi

 repeat 3
  sh. {($channel_order)[$>]}
  rep_trigmap. ,{($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
  rm.
 done
else
 if narg($1)
  if '$1'=='8i'
   repeat $! l[$>]
    repeat 3
     sh. {($channel_order)[$>]}
     rep_trigmap_8i. {($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
     rm.
    done
   endl done
  elif '$1'=='8il'
   repeat $! l[$>]
    if s==3 to_gray to_rgb
    else to_graya to_rgba
    fi
    repeat 3
     sh. {($channel_order)[$>]}
     rep_trigmap_8i. {($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
     rm.
    done
   endl done
  else error ""(""$"1==8i")"||"(""$"1==8il")"==F"
  fi
 else
  repeat $! l[$>]
   repeat 3
    sh. {($channel_order)[$>]}
    rep_trigmap. ,{($channel_formula)[$>]+5*$>},{($multiplier)[$>]},{($valueshift)[$>]},{($midgray_expf)[$>]},{($lightness_merge_factor)[$>]},{($lightness_end_expf)[$>]},{($gray2col_end)[$>]}
    rm.
   done
  endl done
 fi
fi
#@cli rep_trigmap: eq. to 'rep_trigonometry_map' : (+)
rep_trigmap: rep_trigonometry_map $*
#@cli rep_trigonometry_map: _image_value_divide,_chan_form={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier>0,_valueshift,0>=_midgray_expf>=1,_lightness_merge_factor>=1,_lightness_end_expf>0,0>=_gray2col_end>=1
#@cli : Map trigonometry function into image.
#@cli :
#@cli : (eq. to 'rep_trigmap').
#@cli :
#@cli : '_image_value_divide' defines how much the image should be divided by. Of course, 0 is not valid.
#@cli : '_chan_form' refers to the formula each channels use. Number higher than 4 will use a slight different formula, but still follow the pattern of formulas named above.
#@cli : '_multiplier' defines the multiplication of base gradient used to map formula based on trigonometry.
#@cli : '_valueshift' refers to the value shift of base gradient
#@cli : '_midgray_expf' refers to the middle-point of base gradient used to map formula based on trigonometry relative to middle.
#@cli : '_lightness_merge_factor' refers to the merging of lightness gradient with color gradient. Used to add white and black to gradient ends.
#@cli : '_lightness_end_expf' defines the magnitude of shades and tind of each end of end gradient
#@cli : '_gray2col_end' defines how much the end gradient overrides the base gradient
#@cli :
#@cli : Note: Add 5 or 10 to '_chan_form' for another variation of the specified formula.
#@cli : Default values: '_image_value_divide=1','_multiplier_mode=1','_valueshift=0','_midgray_expf=1','_lightness_merge_factor=1','_lightness_end_expf=0','_gray2col_end=1'\n
#@cli : Author: Reptorian.
rep_trigonometry_map:
skip ${1=1},${2=0},${3=1},${4=0},${5=1},${6=1},${7=0},${8=1}
if $1==0 error ""$"1!=0==f" fi
f "begin(const trigmode=$2%15;
  trigmode==0? chan_form(a)=(sin(a*pi)+1)/2:
  trigmode==1? chan_form(a)=(cos(a*pi)+1)/2:
  trigmode==2? chan_form(a)=(sin(a*pi+pi)^3+1)/2:
  trigmode==3? chan_form(a)=(cos(a*pi+pi)^3+1)/2:
  trigmode==4? chan_form(a)=((cos(a*pi+pi/2)*sin(a*pi+pi/2))^3+.125)*4:
  trigmode==5? chan_form(a)=(sin(a*pi+pi/2)+1)/2:
  trigmode==6? chan_form(a)=(cos(a*pi+pi/2)+1)/2:
  trigmode==7? chan_form(a)=(sin(a*pi+pi/2)^3+1)/2:
  trigmode==8? chan_form(a)=(cos(a*pi+pi/2)^3+1)/2:
  trigmode==9? chan_form(a)=((cos(a*pi+pi/4)*sin(a*pi+pi/4))^3+.125)*4:
  trigmode==10?chan_form(a)=(sin(a*pi+pi)+1)/2:
  trigmode==11?chan_form(a)=(cos(a*pi+pi)+1)/2:
  trigmode==12?chan_form(a)=(sin(a*pi)^3+1)/2:
  trigmode==13?chan_form(a)=(cos(a*pi)^3+1)/2:
  trigmode==14?chan_form(a)=((cos(a*pi)*sin(a*pi))^3+.125)*4;
 );
 slope=i/$1;
 midslope=(max(1-slope,slope)-.5)*2;
 col_chan_zero=chan_form($3*(slope^$5+$4));
 mul_chan_zero=lerp(col_chan_zero,lerp(slope*col_chan_zero,slope,midslope^(abs($7+1))),midslope^(abs($7+1))*$6);
 lerp(slope,mul_chan_zero,$8)*$1;"
#@cli rep_trigmap_8i: eq. to 'rep_trigonometry_map_8bit_integer' : (+)
rep_trigmap_8i: rep_trigonometry_map 255,${1-7}
#@cli rep_trigonometry_map_8bit_integer: _level_formula={ 0=sinusoidal | 1=cosinusoidal | 2=cubic-sinusoidal | 3=cubic-cosinusoidal | 4=cubic-sinusoidal-cosinusoidal },_multiplier>0,_valueshift,0>=_midgray_expf>=1,_lightness_merge_factor>=1,_lightness_end_expf>0,0>=_gray2col_end>=1
#@cli : Map trigonometry function using 8-bit values. Remove _8i for non-8 bit values.
#@cli : (eq. to rep_trigmap_8i).\n
#@cli : Note: Add 5 or 10 to '_level_formula' for another variation of the specified formula.
#@cli : Default values: '_multiplier_a=1','_valueshift_a=0','_midgray_expf_a=1','_lightness_merge_factor_a=1','_lightness_end_expf_a=0','_gray2col_end_a=1'
rep_trigonometry_map_8bit_integer: rep_trigonometry_map 255,${1-7}
#@cli rep_lerp_rgb_gray: eq. to rep_linear_interpolation_rgb_gray : (+)
rep_lerp_rgb_gray: rep_linear_interpolation_rgb_gray $*
#@cli rep_linear_interpolation_rgb_gray: 0%>=_red_factor(%)<=100%,0%>=_green_factor(%)<=100%,0%>=_blue_factor(%)<=100%,_gray_mode={ 0=luminosity | 1=luminosity_alternative | 2=lightness | 3=minimum_channel | 4=maximum_channel | 5=average } : 0%>=_red_factor(%)<=100%,0%>=_green_factor(%)<=100%,0%>=_blue_factor(%)<=100%,_red_weight,green_weight,blue_weight\n
#@cli : Author: Reptorian.
rep_linear_interpolation_rgb_gray:
skip ${4=0},${5=},${6=}
total_arg=0
if isnum($1) total_arg+=1 fi
if isnum($2) total_arg+=1 fi
if isnum($3) total_arg+=1 fi
if isnum($4) total_arg+=1 fi
if isnum($5) total_arg+=1 fi
if isnum($6) total_arg+=1 fi
if $total_arg==5 error "valid_args!=5=F" fi

if abs($1)>2 error "|"$"1|<=2=F" fi
if abs($2)>2 error "|"$"2|<=2=F" fi
if abs($3)>2 error "|"$"3|<=2=F" fi

f "
begin(
 const rlvl=abs($1);
 const glvl=abs($2);
 const blvl=abs($3);

 if(narg($*)>5,
  const tw=abs($4)+abs($5)+abs($6);
  const c1f=abs($4)/tw;
  const c2f=abs($5)/tw;
  const c3f=abs($6)/tw;
  graymode(a,b,c)=a*c1f+b*c2f+c*c3f;
 ,
  $4==0?graymode(a,b,c)=a*0.22248840+b*0.71690369+c*0.06060791:
  $4==1?graymode(a,b,c)=a*0.2990+b*0.5870+c*0.1140:
  $4==2?graymode(a,b,c)=(max(a,b,c)+min(a,b,c))/2:
  $4==3?graymode(a,b,c)=min(a,b,c):
  $4==4?graymode(a,b,c)=max(a,b,c):
        graymode(a,b,c)=avg(a,b,c);
 );
);
gl=graymode(i0,i1,i2);
[lerp(gl,i0,rlvl),lerp(gl,i1,glvl),lerp(gl,i2,blvl)]
"
#@cli rgb2ohta8
#@cli : Convert color representation of selected images from RGB to Ohta8.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg rgb2ohta split c
rgb2ohta8:
e[^-1] "Convert color representation of image$? from RGB to Ohta8."
f [avg(i0,i1,i2),(i0-i2+255)/2,(-i0+i1-i2+255)/3]
#@cli ohta82rgb
#@cli : Convert color representation of selected images from Ohta8 to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg ohta82rgb split c
ohta82rgb:
e[^-1] "Convert color representation of image$? from Ohta8 to RGB."
f c0=i0*3;c1=i1*2-255;c2=i2*3-255;[.25*c0+.5*c1-.25*c2,.5*c0+.5*c2,.25*c0-.5*c1-.25*c2]
#@cli rgb2ohta
#@cli : Convert color representation of selected images from RGB to Ohta.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg rgb2ohta split c
rgb2ohta:
e[^-1] "Convert color representation of image$? from RGB to Ohta."
f [i0+i1+i2,i0-i2,-i0+i1-i2]
#@cli ohta2rgb
#@cli : Convert color representation of selected images from Ohta to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/24/ohta-colorspaces-iii/#more-6335
#@cli : $ image.jpg ohta2rgb split c
ohta2rgb:
e[^-1] "Convert color representation of image$? from Ohta to RGB."
f [.25*i0+.5*i1-.25*i2,.5*i0+.5*i2,.25*i0-.5*i1-.25*i2]
#@cli rgb2ydbdr
#@cli : Convert color representation of selected images from RGB to YDbDr.
#@cli : Source: https://hbfs.wordpress.com/2018/05/15/ydbdr-colorspaces-vi/#more-6355
#@cli : $ image.jpg rgb2ydbdr split c
rgb2ydbdr:
e[^-1] "Convert color representation of image$? from RGB to YDbDr."
f [.299*i0+.587*i1+.114*i2,-.45*i0-.883*i1+1.333*i2,1.333*i0-1.109*i1-.217*i2]
#@cli rgb2ydbdr
#@cli : Convert color representation of selected images from YDbDr to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/05/15/ydbdr-colorspaces-vi/#more-6355
#@cli : $ image.jpg rgb2ydbdr split c
ydbdr2rgb:
e[^-1] "Convert color representation of image$? from YDbDr to RGB."
f [1*i0+.525*i2,1*i0-.129*i1-.268*i2,1*i0+.665*i1]
#@cli rgb2k1
#@cli : Convert color representation of selected images from RGB to Kodak 1.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg rgb2k1 split c
rgb2k1:
e[^-1] "Convert color representation of image$? from RGB to Kodak 1."
f begin(third=1/3;);r=third*i0;g=third*i1;b=third*i2;[r+g+b,b-r-g,r-g-b]
#@cli k12rgb
#@cli : Convert color representation of selected images from Kodak 1 to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg k12rgb split c
k12rgb:
e[^-1] "Convert color representation of image$? from Kodak 1 to RGB."
f [1.5*i0+1.5*i2,-1.5*i1-1.5*i2,1.5*i0+1.5*i1];
#@cli rgb2k18
#@cli : Convert color representation of selected images from RGB to Kodak 1 in 8I.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg rgb2k18 split c
rgb2k18:
e[^-1] "Convert color representation of image$? from RGB to Kodak 1 - 8I."
f begin(third=1/3;);r=third*i0;g=third*i1;b=third*i2;[r+g+b,(b-r-g)+170,(r-g-b)+170]
#@cli k182rgb
#@cli : Convert color representation of selected images from Kodak 1 in 8I to RGB.
#@cli : Source: https://hbfs.wordpress.com/2018/04/10/kodak-1-colorspaces-i/
#@cli : $ image.jpg k182rgb split c
k182rgb:
e[^-1] "Convert color representation of image$? from Kodak 1 - 8I to RGB."
f c1=i1-170;c2=i2-170;[1.5*i0+1.5*c2,-1.5*c1-1.5*c2,1.5*i0+1.5*c1];
#@cli rgb2yes
#@cli : Convert color representation of selected images from RGB to YES.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg rgb2yes split c
rgb2yes:
e[^-1] "Convert color representation of image$? from RGB to YES."
f [.253*i0+.684*i1+.063*i2,.5*i0-.5*i1,.25*i0+.25*i1-.5*i2]
#@cli yes2rgb
#@cli : Convert color representation of selected images from RGB to YES.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg yes2rgb split c
yes2rgb:
e[^-1] "Convert color representation of image$? from YES to RGB."
f [i0+1.431*i1+.126*i2,i0-.569*i1+.126*i2,i0+.431*i1-1.874*i2]
#@cli rgb2yes8
#@cli : Convert color representation of selected images from RGB to Yes8.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg rgb2yes8 split c
rgb2yes8:
e[^-1] "Convert color representation of image$? from RGB to Yes8."
f [.253*i0+.684*i1+.063*i2,(.5*i0-.5*i1)+127.5,(.25*i0+.25*i1-.5*i2)+127.5]
#@cli yes82rgb
#@cli : Convert color representation of selected images from Yes8 to RGB.
#@cli : Source: Xerox Color Encoding Standard, (tech rep?) XNSS 289005 (1989?) ; https://hbfs.wordpress.com/2018/05/01/xerox-yes-colorspaces-iv/
#@cli : $ image.jpg yes82rgb split c
yes82rgb:
e[^-1] "Convert color representation of image$? from Yes8 to RGB."
f [i0+1.431*(i1-127.5)+.126*(i2-127.5),i0-.569*(i1-127.5)+.126*(i2-127.5),i0+.431*(i1-127.5)-1.874*(i2-127.5)]
#@cli rep_rbtt: eq. to 'rep_rotate_by_torus_top' : (+)
rep_rbtt: rep_rotate_by_torus_top $*
#@cli rep_rotate_by_torus_top: 0<=_torus_circu_min_dimension_percent_1(%)<=100,0<=_torus_circu_min_dimension_percent_2(%)<=100,_distort_ang,_mode_1={ 0=softmode | 1=midmode | 2=hardmode | 3=hardmode_alt | 4=distroymode | 5=invdistroymode | 6=quadextrudemode | 7=hexextrudemode },_mode_2={ 0=softmode | 1=midmode | 2=hardmode | 3=hardmode_alt | 4=distroymode | 5=invdistroymode | 6=quadextrudemode | 7=hexextrudemode },0<=_mode_percent_comb(%)<=100,_offx(%),_offy(%),_off_dup={ 0=no_duplicate_dist | 1=duplicate_dist },_bgremove={ 0=keep_background | 1=remove_background },_cent_isolat_torus_mode={ 0=do_not_center | 1=center },_interpolation={ 0=nearest | 1=linear },_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror }
#@cli : Inspired by the Donut Distortion plugin made by MadJik for Paint.NET, this version of donut distortion adds new features such as more modes, mode blending, isolated torus mode.
#@cli : (eq. to 'rep_rbtt')\n
#@cli : _torus_circu_min_dimension_percent_1 refers to the primary circumference of circle relative to the minimum image dimension.
#@cli : _torus_circu_min_dimension_percent_2 refers to the secondary circumference of circle relative to the minimum image dimension.
#@cli : _distort_ang refers to the maximum angle of distortion.
#@cli : _mode_1 refers to the first mode of donut distortion.
#@cli : _mode_1 refers to the second mode of donut distortion.
#@cli : _mode_percent_comb refers to the weighed average of combination of modes. This only works if and only if _mode_1 and _mode_2 are specified!
#@cli : _offx refers to the offset of donut distortion relative to the center in -1,1 x-coordinates. 100% means the center will be located in 1.
#@cli : _offy refers to the offset of donut distortion relative to the center in -1,1 y-coordinates. 100% means the center will be located in 1.
#@cli : _off_dup option defines whether distortion will wrap around when it reach out of bound.
#@cli : _bgremove defines whether the background is removed.
#@cli : _cent_isolat_torus_mode is a special mode used to aid into creating torus from image. This only works if _bgremove is active.
#@cli : _interpolation defines the smoothness of the image.
#@cli : _boundary defines how out-of-range values are wrapped as.
#@cli : Default values: '_torus_circu_min_dimension_percent_1=1','_torus_circu_min_dimension_percent_2=.5','_distort_ang=45','_mode_1=0','_mode_2=','_mode_percent_comb=50%','_offx=0%','_offy=0%','_off_dup=1','_bgremove=0','_cent_isolat_torus_mode=0','_interpolation=1','_boundary=2'
rep_rotate_by_torus_top:
skip ${1=1},${2=0},${3=45},${4=0},${5=},${6=.5},${7=0},${8=0},${9=1},${10=1},${11=0}${12=1},${13=2}

if $1==$2 error ""$"1!="$"2=F" fi
if ($1>1||$1<0)||($2>1||$2<0) error "(0>="$"1<=1)||(0>="$"2<=1)=F" fi
if $4<0||$4>7 error "0<="$"4<=7=F" fi
if narg($5) if $5<0||$5>7 error "0<="$"5<=7=F" fi fi
if $6<0||$6>1 error "0<="$"6<=1=f" fi

mode_1=${arg\ $4+1,(cos(v*(2*pi)-pi)+1)/2,abs(cos(v*pi+pi/2)),sqrt(1-(abs(v-.5)*2)^2),(1-(abs(v-.5)*2)^2)^(1/(2+(1-v))),cos(v*pi)*boundary,(cos(v*pi)*-1)*boundary,1-abs(v-.5)*2,(r=(1-abs(v-.5)*2)*2;r>1?1:r)}

if narg($5)
 mode_2=${arg\ $5+1,(cos(v*(2*pi)-pi)+1)/2,abs(cos(v*pi+pi/2)),sqrt(1-(abs(v-.5)*2)^2),(1-(abs(v-.5)*2)^2)^(1/(2+(1-v))),cos(v*pi)*boundary,(cos(v*pi)*-1)*boundary,1-abs(v-.5)*2,(r=(1-abs(v-.5)*2)*2;r>1?1:r)}
fi

include_alp_cut={$10&&(s==2||s>3)}

if $include_alp_cut
 vnull=[vectors(0)]
 outcolor=vnull
else outcolor=I
fi

if $12>0

 boundary=avg(bndcut(radial_gradient_v[0]),bndcut(radial_gradient_v[1]),bndcut(radial_gradient_v[2]),bndcut(radial_gradient_v[3]))

 calc_antialias=ox=sur_x(start_x(x+.5));oy=sur_y(start_y(y+.5));radial_gradient_v=[nm(norm(xx,yy)),nm(norm(ox,yy)),nm(norm(xx,oy)),nm(norm(ox,oy))];

else
 boundary=bndcut(radial_gradient)
fi

f "
begin(
 boundary=0;

 const s_id=s-1;

 const sd=max(w,h)/min(w,h);
 const sx=w>h?sd:1;
 const sy=w>h?1:sd;

 const ww=w-1;
 const hh=h-1;
 const cx=ww/2;
 const cy=hh/2;
 const offx=cx*$7*-1;
 const offy=cy*$8;
 const eps=10^-10;

 const interpolation=abs($12)?2:0;
 const outboundary=$13;

 vallim_x(v)=v-ww*floor(v/(ww+eps));
 vallim_y(v)=v-hh*floor(v/(hh+eps));

 if($9,
  start_x(v)=vallim_x(v+offx);
  start_y(v)=vallim_y(v+offy);
 ,
  start_x(v)=v+offx;
  start_y(v)=v+offy;
 );

 const torus_val_1=$1;
 const torus_val_2=$2;
 const new_min=min(torus_val_1,torus_val_2);
 const new_max=max(torus_val_1,torus_val_2);
 const end_diff=(1/(new_max-new_min));
 nm(v)=(v-new_min)*end_diff;
 limcut(v)=max(min(1,v),0);
 bndcut(v)=v>1||v<0?0:1;

 const iang=$3*-1;
 ang2rad(v)=pi*(v/180);
 const maxang=ang2rad(iang);
 rot_x(a,b,c)=a*cos(c)-b*sin(c);
 rot_y(a,b,c)=a*sin(c)+b*cos(c);

 sur_x(v)=(v/ww-.5)*2*sx;
 sur_y(v)=(v/hh-.5)*2*sy;
 unsur_x(v)=(v/(2*sx)+.5)*ww;
 unsur_y(v)=(v/(2*sy)+.5)*hh;

 if(narg($5),

  if($6==0||$6==1
  ,if($6,mode(v)="$mode_2";,mode(v)="$mode_1";);
  ,mode(v)=lerp("$mode_1","$mode_2",$6);
  );
 ,
  mode(v)="$mode_1";
 );

 if($include_alp_cut
  ,out(a,b)=[vectors_id(J(a,b,z,interpolation,$13)),j(a,b,z,s_id,0,outboundary)*boundary];vnull="$vnull";
  ,out(a,b)=lerp(I,J(a,b,z,interpolation,outboundary),boundary);
 );
);
nxx=start_x(x);
nyy=start_y(y);
xx=sur_x(nxx);
yy=sur_y(nyy);
"$calc_antialias"
radial_gradient=nm(norm(xx,yy));
norm_gradient=limcut(radial_gradient);
boundary="$boundary";
z_depth=mode(norm_gradient)*maxang;
XX=rot_x(xx,yy,z_depth);
YY=rot_y(xx,yy,z_depth);
XX=unsur_x(XX);
YY=unsur_y(YY);
diff_x=XX-nxx;
diff_y=YY-nyy;
out(diff_x,diff_y);"

if $11&&$10
 offx={($7/2)*100*-1}
 offy={($8/2)*100}

 repeat $! l[$>]
  if s==2||s>3
   shift $offx%,$offy%,0,0,2,0
  fi
 endl done
fi
#@cli rep_pxpush: eq. to 'rep_pixel_push' : (+)
rep_pxpush: rep_pixel_push $*
#@cli rep_pixel_push: -1<=_push_x<=1,-1<=_push_y<=1
#@cli : Pushes pixel relative to coordinate from the center. CLI filter is recreated from source code to TR's Pixel Push plugin for Paint.NET. Currently only Bezier option is supported until the secondary option is figured out.
#@cli : (eq. to 'rep_pxpush')\n
#@cli : Default values: '_push_x=0','_push_y=0'\n
#@cli : Author: Reptorian.
rep_pixel_push:
f "begin(
 const ww=w-1;
 const hh=h-1;
 cx=($1+1)/2;
 cy=($2+1)/2;
 if(cx>1,cx=1,if(cx<0,cx=0));
 if(cy>1,cy=1,if(cy<0,cy=0));
 );
 spanx=x/ww;
 spany=y/hh;
 nx=(1-((cx*(1-spanx))*spanx+(1-spanx)*(cx*spanx+(1-spanx))))*ww;
 ny=(1-((cy*(1-spany))*spany+(1-spany)*(cy*spany+(1-spany))))*hh;
 I(nx,ny,z,2);"
#@cli rep_pw: eq. to 'rep_point_warp' : (+)
rep_pw: rep_point_warp $*
#@cli rep_point_warp: 0%<=_pointwidth(%)<=100%,0%<=_distance(%)<=100%,0%,_radialInfluence<=100%,-1>=_distortion_center_x>=1,-1>=_distortion_center_y>=1,-360>=_distortion_angle>=360,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror }
#@cli : Distorts image around a point. If you're using large radius, radialInfluence is not recommended to be set to 100%.
#@cli : (eq. to 'rep_pw')\n
#@cli : Default values: '_pointwidth=10%','_distance=10%','_radialInfluence=0%','_distortion_center_x=0','_distortion_center_y=0','_distortion_angle=0','_boundary=3'
rep_point_warp:
skip ${1=10},${2=10},${3=0},${4=0},${5=0},${6=0},${7=3}
f "begin(
  eucl_norm(a,b)=sqrt(a^2+b^2);
  const scaled_img_diagonal=eucl_norm(w,h)*$2;
  const radius=log2((10^(abs($3)*300))*1000)*e;
  const lograd=log(radius^($1*(.25*min(w,h))));
  const hw=w/2;
  const hh=h/2;
  const angle=($6/180)*pi+pi;
  const ox=cos(angle)*scaled_img_diagonal;
  const oy=sin(angle)*scaled_img_diagonal;
  const dx=$4*hw;
  const dy=$5*hh;
 );
 xd=x-dx;
 yd=y+dy;
 radinf=radius^(-(((xd-hw)/lograd)^2+((yd-hh)/lograd)^2)^2);
 rx=(ox*radinf)+x;
 ry=(oy*radinf)+y;
 I(rx,ry,z,2,$7);"
#@cli rep_rand_sqrrecfill: eq. to 'rep_random_square_rectangle_fill' : (+)
rep_rand_sqrrecfill: rep_random_square_rectangle_fill $*
#@cli rep_random_square_rectangle_fill: _palette,square_dimension>0,_rectangle_max_length_1>0,_rectangle_max_length_2>0,_erode,_output={ 0=none | 1=line },_reduce_nonrectangles={ 0=do_not_reduce_nonrectagles | 1=reduce_nonrectangles },_remove_black_from_palette={ 0=preserve | 1=remove },_seed,_colourspace,
#@cli : Create texture with aligned rectangle and squares with colors being optional.
#@cli : (eq. to 'rep_rand_sqrrecfill')
#@cli : Default values: '_palette=0','_rectangle_length_2=1','_frequency_of_rectangle=1','_erode=0','_output=1','_reduce_nonrectangles=1','_remove_black_from_palette=1','_seed=','_colourspace=6',
#@cli : Author: Reptorian.
rep_random_square_rectangle_fill:
skip ${1=0},${3=2},${4=1},${5=1},${6=0},${7=1},${8=1},${9=1},${10=},${11=0}

cs2rgb=${arg\ 1+$11,,ryb2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb}

bool_state_pal=0
rand_pal=0

if narg($1)
 if isint($1)&&isnum($1)
  if $1>0||$1<0
   bool_state_pal=1
   text_mode=0
  fi
 else
  if narg($1)
   bool_state_pal=1
   text_mode=1
  fi
 fi
fi
rep_rand_sqrrectex ${2-6},{$bool_state_pal?(($1>0||$1<0)&&abs($7)?3:1):2},$8,$10
if $bool_state_pal
 if narg($10) srand $10 fi

 r. 100%,100%,100%,3

 if $text_mode
  +pal $1
 else
  if $1<0 {iM},1,1,3,u(0,255)
   if $11 $cs2rgb fi
   rand_pal=1
  else +pal $1
  fi
 fi

 if $9
  l.
   s x
   repeat $! l[$<]
    if !{ia} rm fi
   endl done
   a x
  endl
 fi

 if !$rand_pal
   {w#-1},1,1,1,u(0,1)
   pixelsort.. +,x,.
   rm.
 fi

 if !$7 +.. 1 fi
 f.. i0?i(#-1,i0-1,y,0,c,0,2)
 rm.
fi
#@cli rep_rand_sqrrecart: eq. to 'rep_random_square_rectangle_texture' : (+)
rep_rand_sqrrecart: rep_random_square_rectangle_artistic $*
#@cli rep_random_square_rectangle_artistic: square_dimension>0,_rectangle_max_length_1>0,_rectangle_max_length_2>0,_frequency_of_rectangle>0,_erode,_output={ 0=none | 1=line },_reduce_nonrectangles={ 0=do_not_reduce_nonrectagles | 1=reduce_nonrectangles },_distance_mode={ 0=regular_output | 1=distance_output },_seed,_output_resized={ 0=do_not_output_resized_original | 1=output_resized },_colourspace
#@cli : Create artistic rendering of image with aligned rectangle and squares.
#@cli : (eq. to 'rep_rand_sqrrecart')
#@cli : Default values: '_rectangle_max_length_1=2','_rectangle_length_2=1','_frequency_of_rectangle=1','_erode=0','_output=2','_reduce_nonrectangles=0','_seed=','_output_resized=0',_colourspace=0'
#@cli : Author: Reptorian.
rep_random_square_rectangle_artistic:
skip ${2=2},${3=1},${4=1},${5=0},${6=1},${7=1},${8=0},${9=},${10=0},${11=0}
convert_back=0
tcr=3
different_dimension=0
if $!>1
 cw={w#1}
 ch={h#1}
 iter=1
 do
  iter-=1
  if (w#$iter!=$cw)||(h#$iter!=$ch) different_dimension=1 fi
  iter+=2
  cw={w#$iter}
  ch={h#$iter}
 while !$different_dimension&&$iter<$!
fi

if $different_dimension
 repeat $! l[$<]
  rep_rand_sqrrectex ${1-5},{$6?2:1},$7,$9
 endl done
else
 rep_rand_sqrrectex ${1-5},{$6?2:1},$7,$9
 rep_aspect_crop_2d[^-1] {w#-1},{h#-1}
 r[^.] {w#-1},{h#-1},100%,100%,2,2,.5,.5
 if $8
  +distance.. 0
  +blend[-2,-1] shapemax0
  /.. .
  rm.
  store. distance
 fi
 store. art_shape
 repeat $! l[$<]
  if (s==3||s==4)&&$11
   convert_back=1
   if $11!=2
    sh 0,2
      if $11==1 rgb2ryb.
    elif $11==3 rgb2hcy.
    elif $11==4 rgb2hsi.
    elif $11==5 rgb2hsl.
    elif $11==6 rgb2hsv.
    elif $11==7 rgb2lab.
    elif $11==8 rgb2lch.
    elif $11==9 rgb2ycbcr.
    elif $11==10 rgb2ycbcrglic.
    elif $11==11 rgb2yiq.
    elif $11==12 rgb2yuv.
    elif $11==13 rgb2xyz.
    fi
    rm.
   else
      if s==3 rgb2cmyk tcr+=1
    elif s==4 s c,-3 rgb2cmyk.. a c
    fi
   fi
  fi

  if $10 +store output_resized fi

  $art_shape
 endl done
fi
#@cli rep_rand_sqrrectex: eq. to 'rep_random_square_rectangle_texture' : (+)
rep_rand_sqrrectex: rep_random_square_rectangle_texture $*
#@cli rep_random_square_rectangle_texture: square_dimension>0,_rectangle_max_length_1>0,_rectangle_max_length_2>0,_frequency_of_rectangle>0,_erode,_output={ 0=none | 1=filled_gray | 2=filled_line | 3=labeled_filled_line },_reduce_nonrectangles={ 0=do_not_reduce_nonrectagles | 1=reduce_nonrectangles },_seed
#@cli : Create a texture with aligned rectangle and squares.
#@cli : (eq. to 'rep_rand_sqrrectex')
#@cli : Note: '_reduce_nonrectangles' cannot be used to completely clear vectors of nonrectangle due to the algorithm provided, and no solution in context of vector exist as of now.
#@cli : Default values: '_rectangle_max_length=1','_rectangle_max_length=2','_frequency_of_rectangle=1','_erode=0','_output=2','_reduce_nonrectangles','_seed='
#@cli : Author: Reptorian.
##@cli : $ rep_random_square_rectangle_texture 20,3,3,2,,0
rep_random_square_rectangle_texture:
skip ${2=2},${3=1},${4=1},${5=0},${6=2},${7=1},${8=}
if narg($8) srand $8 fi
square_size=$1
rf=0

if abs($5)
 if $5>0 square_size+={abs($5)}
 else square_size+=1
 fi
fi

if $1<2 error ""$"1>1==F" fi

mw=${-max_w}
mh=${-max_h}
nvw={ceil($mw/$square_size)}
nvh={ceil($mh/$square_size)}

$nvw,$nvh,1,1,"x+y*w"
if abs(round($2))==1&&abs(round($3))==1 error ""$"2>1||"$"3>1==F" fi

msize={abs($2)+sqr(round(abs($3)))}

if $1<2 error ""$"2>1==F" fi

freq={int(avg(1/$msize,$4,.5)*(iM+1))}
val={iM+1}

repeat round($freq)
 orientation={round(u(0,1))}
 nsl_1={round(u(1,abs($2)))}
 nsl_2={round(u(1,abs($3)))}
 min_nsl={min($nsl_1,$nsl_2)}
 max_nsl={max($nsl_1,$nsl_2)}
 if $min_nsl==1&&$max_nsl==1 max_nsl={round(u(2,abs(max($2,$3))))} fi
 px={round(u(0,w#-1-1))}
 py={round(u(0,h#-1-1))}
 if $orientation $min_nsl,$max_nsl,1,1,$val j.. .,$px,$py rm.
 else $max_nsl,$min_nsl,1,1,$val j.. .,$px,$py rm.
 fi
 val+=1
done

label. 0,0

if $7&&($2>1&&$3>1)
if max($2,$3)>2
rf={max($2,$3)-2}
fi
repeat 2+$rf
mirror. x
f. "
topleft   = j(-1,-1);
topmiddle = j(0,-1);
topright  = j(1,-1);

middleleft  = j(-1,0);
middle      = i;
middleright = j(1,0);

bottomleft   = j(-1,1);
bottommiddle = j(0,1);
bottomright  = j(1,1);

F=i;

if(

 (  (avg(topmiddle,middleleft)==middle)
 || (avg(topmiddle,middleright)==middle)
 || (avg(bottommiddle,middleleft)==middle)
 || (avg(bottommiddle,middleright)==middle)
 )

 ||

 (  (avg(middleleft,topmiddle,middleright)==middle)
 || (avg(middleleft,bottommiddle,middleright)==middle)
 || (avg(bottommiddle,middleleft,topmiddle)==middle)
 || (avg(bottommiddle,middleright,topmiddle)==middle)
 )

 ||

 (  (avg(bottommiddle,bottomright,middleright)==middle)
 || (avg(bottommiddle,bottomleft,middleleft)==middle)
 || (avg(topmiddle,topright,middleright)==middle)
 || (avg(topmiddle,topleft,middleleft)==middle)
 )

 ,F*=-1;
);

F;
"
label. 0,0
done
fi

if $6
 {$nvw*$square_size+2},{$nvh*$square_size+2},1,1,i(#-1,floor(x/$square_size),floor(y/$square_size),z,0,0,1) rm.. r. {w-1},{h-1}
 if $6>1 r2dx {(($1+1)/$1)*100}%,1 fi
 if $6>1 f. "(x!=0&&x!=w-1&&y!=0&&y!=h-1)?(i(x-1,y-1,z,c,0,1)==i(x,y))*((i(x-1,y,z,c,0,1)==i(x,y))&&(i(x,y-1,z,c,0,1)==i(x,y))):0"
  if $5 erode. {$5<0?(abs($5)>$1?$1:abs($5)):abs($5)} expand_xy. {int(abs($5)/2)},1 if !($5%2) r. {w-1},{h-1} fi fi
 fi
 if $6>2 label_fg. 0,0 fi
 if $6<2 r. {w-1},{h-1} fi
fi
#@cli rep_gradf: eq. to 'rep_graduated_filter' : (+)
rep_gradf: rep_graduated_filter $*
#@cli rep_graduated_filter: 0<strength<=1,0<=_lumastrength<=1,0<=_placement<=1,-360<=_ang<=360,_gradiated_colorspace= { 0=RGB | 1=HSV | 2=YUV },_color1,_color2,_color3
#@cli : Apply graduated filter on the YUV color space.
#@cli : (eq. to 'rep_gradf')
#@cli : Default values: '_lumastrength=0','_offset=0','_ang=0','_gradiated_colorspace=0','_color1=0','_color2=0','_color3=0'\n
#@cli : Author: Reptorian.
rep_graduated_filter:
skip ${2=1},${3=.5},${4=0},${5=0},${6=0},${7=0},${8=0},${9=0}
rgb2yuv

if $5==2 ($6^$7^$8)
elif $5==1 ($6^$7^$8) hsv2rgb. rgb2yuv.
else ($6^$7^$8) rgb2yuv.
fi

f[^-1] "begin(
  const ss=h>w?w:h; #Pick shortside as basis for gradient#
  const ang=pi*((180-$4)/180); #Convert Angle to radians#
  const offset=$3-.5;
  const sin_ang=sin(ang);
  const cos_ang=cos(ang);
  rot_y(a,b)=a*sin_ang+b*cos_ang; #Rotate Function#
  mm_val(a)=a>1?1:(a<0?0:a); #Cut values to 0,1 range#
 );
 pos_x=[mm_val((rot_y(x-w/2,y-h/2)/ss)+offset)];
 Sub_YUV=[(1-i(#-1,0,0,z,0))*pos_x[0]*$2,i(#-1,0,0,z,1)*pos_x[0]*-1,i(#-1,0,0,z,2)*pos_x[0]*-1,0];
 I-Sub_YUV*$1;"
yuv2rgb[^-1]
rm.
#@cli rep_mj_newf: eq. to 'rep_madjik_newton_fractal' : (+)
rep_mj_newf:rep_madjik_newton_fractal $*
#@cli rep_madjik_newton_fractal: _zoom>0,_xpan,_ypan,_colrange>0,_factor_a,_factor_b,_factor_c,_factor_d,_expf>0,_depth>0,_bgfreq>0,-360<=_colang<360,_alternate_colfunc={ 0=Regular | 1=Alternate },_symmetry={ 0=Regular | 1=Symmetrical },_alternate_channels
#@cli : Near direct conversion of MadJik's Newton Fractal Paint.NET plugin. This is a early beta filter. Unlike Paint.NET version, every variables are float-based except for last two.
#@cli : (eq. to 'rep_mj_newf')
#@cli : Default values: '_zoom=16','_xpan=0','_ypan=0','_colrange=128','_factor_a=9','_factor_b=0','_factor_c=75','_factor_d=5','_expf=10','_depth=50','_bgfreq=50','_colang=45','_alternate_colfunc=0','_symmetry=0'
rep_madjik_newton_fractal:
skip ${1=16},${2=0},${3=0},${4=128},${5=9},${6=0},${7=75},${8=5},${9=10},${10=50},${11=50},${12=45},${13=0},${14=0},${15=0}
repeat $! l[$>]
ww={w}
hh={h}
r {max(w,h)*2},{max(w,h)*2},1,3
f "
begin(
 const zoom=$1/100;
 const fvar_b=8/9+$6/1000;
 const fvar_c=$7/10;
 const fvar_d=$8/10;
 const afc=fvar_c*$5;
 const afd=afc*fvar_d;
 const bgfreq=$11/100;
 const ang=$12/180*pi;
 const fexp=10^-$9;
 funcb(w,t)=128+$4*sin(($15?(2-c)/2:c/2)*pi+(bgfreq*(ang+t+w*pi/180)));
 func(w,t)=128+$4*sin(($15?(2-c)/2:c/2)*pi+(bgfreq*(ang+(t+w)*pi/180)));
);
ex=sqr((x-w/2)-$2/100);
ey=sqr((y-h/2)-$3/100);
ix=(x-w/2)*100/(zoom*w)-$2/100;
iy=(y-h/2)*100/(zoom*h)-$3/100;
for(k=1,k<$10,k++,
 ix_2=ix*ix;
 ix_3=ix_2*ix;
 ix_4=ix_3*ix;
 ix_5=ix_4*ix;
 ix_6=ix_5*ix;
 ix_7=ix_6*ix;
 ix_8=ix_7*ix;
 iy_2=iy*iy;
 iy_3=iy_2*iy;
 iy_4=iy_3*iy;
 iy_5=iy_4*iy;
 iy_6=iy_5*iy;
 iy_7=iy_6*iy;
 iy_8=iy_7*iy;
 endval=(ix_2+iy_2)/2;
 repeat(3,m,endval*=endval;);
 ny=fvar_b*iy-($5*ix_7*iy-afc*ix_5*iy_3+afc*ix_3*iy_5-$5*ix*iy_7)/endval;
 nx=fvar_b*ix+(ix_8-afd*ix_6*iy_2+2.5*afd*ix_4*iy_4-afd*ix_2*iy_6+iy_8)/endval;
 if((abs(nx-ix)<fexp)&&(abs(ny-iy)<fexp),break());
 ix=nx;
 iy=ny;
);
v=k;
if($14,
 jx=(w-x-w/2)*100/(zoom*w)-$2/100;
 jy=(h-y-h/2)*100/(zoom*h)-$3/100;
 for(k=1,k<$10,k++,
   jx_2=jx*jx;
   jx_3=jx_2*jx;
   jx_4=jx_3*jx;
   jx_5=jx_4*jx;
   jx_6=jx_5*jx;
   jx_7=jx_6*jx;
   jx_8=jx_7*jx;
   jy_2=jy*jy;
   jy_3=jy_2*jy;
   jy_4=jy_3*jy;
   jy_5=jy_4*jy;
   jy_6=jy_5*jy;
   jy_7=jy_6*jy;
   jy_8=jy_7*jy;
   endval=(jx_2+jy_2)/2;
   repeat(3,m,endval*=endval;);
   ny=fvar_b*jy-($5*jx_7*jy-afc*jx_5*jy_3+afc*jx_3*jy_5-$5*jx*jy_7)/endval;
   nx=fvar_b*jx+(jx_8-afd*jx_6*jy_2+2.5*afd*jx_4*jy_4-afd*jx_2*jy_6+jy_8)/endval;
   if((abs(nx-jx)<fexp)&&(abs(ny-jy)<fexp),break());
   jx=nx;
   jy=ny;
  );
  v+=k;
  v/=2;
);
$13?func(sqrt(ex+ey),v):funcb(sqrt(ex+ey),v);
"
r {$ww*2},{$hh*2},100%,100%,0,0,.5,.5
r2dx 50%,3
endl done
#@cli rep_major: eq. to 'rep_majority' : (+)
rep_major:rep_majority $*
#@cli rep_majority: kernel_size>1,_mode={ 0=soft_regular | 1=soft_average_channels | 2=hard_regular | 3=hard_average_channels },_colourspace,_alpha
#@cli : Calculate whether to erode or dilate pixels using average.
#@cli : (eq. to 'rep_major_t').\n
#@cli : Custom Colour Space values can be specified with negative number for $3\n
#@cli : Primary Source: https://web.archive.org/web/20080214191501/http://interstices.info/display.jsp?id=c_27035
#@cli : Secondary Source: https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/\n
#@cli : Default values: '_mode=0','_colourspace=0','_alpha=0'
#@cli : Author: Reptorian.
rep_majority:
skip ${2=0},${3=0},${4=0}
if ($3>=0&&$3<=4)||($3==13||$3==14) colour="0,255"
elif $3>=5||$3<=8 colour="0,360,0,1,0,1"
elif $3==9        colour="0,100,-100,100,-100,100"
elif $3==10       colour="0,100,0,100,-pi,pi"
elif $3==11       colour="0,255,-100,100,-100,100"
elif $3==12       colour="0,1,-1,1,-1,1"
elif $3==15       colour="0,1,0,1,0,1"
elif $3==16       colour="0,255,-127.5,127.5,-127.5,127.5"
elif $3==17       colour="0,255,-170,85,-170,85"
elif $3==18       colour="0,765,-255,255,-510,255"
elif $colour<0    colour=${5--1}
fi
tcr=3
mergeback=0

convert_colors_fwd=${arg\ 1+$3,rgb,rgb2srgb,rgb2ryb,rgb2cmy,rgb2cmyk,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch,rgb2yiq,rgb2yuv,rgb2ycbcr,rgb2xyz,rgb2yes,rgb2k1,rgb2ohta}
convert_colors_bwd=${arg\ 1+$3,rgb,srgb2rgb,ryb2rgb,cmy2rgb,cmyk2rgb,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb,yiq2rgb,yuv2rgb,ycbcr2rgb,xyz2rgb,yes2rgb,k12rgb,ohta2rgb}

repeat $! l[$>]
 ss={s}
 if (s==3||s==4)&&$3
  convert_back=1
  if $3!=4
   $convert_colors_fwd.
  else
   if s==3 rgb2cmyk tcr+=1
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
  fi
 fi

 if $4&&(s>$tcr||s==2) s c,-{s-1} mergeback=1 fi

 l[0]
  +boxfilter[0] $1
  if $2==1||$2==3 compose_channels. add /. $ss fi
  +erode[0] $1
  +dilate[0] $1
  if $2==3   f[0] "begin(const ts=s*2;if("$4",mm=vectorts("$colour",0,255);,mm=vectorts("$colour");););i<i0#1?mm[c*2]:mm[c*2+1];"
  elif $2==2 f[0] "begin(const ts=s*2;if("$4",mm=vectorts("$colour",0,255);,mm=vectorts("$colour");););i<i#1?mm[c*2]:mm[c*2+1];"
  elif $2==1 f[0] i<i0#1?i#2:i#3
  else f[0] i<i#1?i#2:i#3
  fi
  k[0]
 endl

 if $mergeback a c fi

 if $convert_back
  if $3!=4
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb tcr-=1
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 fi
endl done
#@cli rep_major_t: eq. to 'rep_majority_threshold' : (+)
rep_major_t:rep_majority_threshold $*
#@cli rep_majority_threshold: kernel_size>=2,0<=tolerance[%]<=100,_booldir={ 0=less_than | 1=greater_than },_alpha,_mode={ 0=soft | 1=hard },_colorspace
#@cli : Calculate whether to erode or dilate based on specified threshold.
#@cli : (eq. to 'rep_major_t').\n
#@cli : Custom Colour Space values can be specified with negative number for $6\n
#@cli : Primary Source: https://web.archive.org/web/20080214191501/http://interstices.info/display.jsp?id=c_27035
#@cli : Secondary Source: https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/\n
#@cli : Default values: '_booldir=0','_mode=1','_alpha','_colourspace',
rep_majority_threshold:
skip ${3=0},${4=1},${5=0},${6=0}
remove_image=0

if $1<2 error ""$1">2==F" fi
if ($5>=0&&$5<=4)||($5==13||$5==14) colour="0,255"
elif $5>=5||$5<=8       colour="0,360,0,1,0,1"
elif $5==9        colour="0,100,-100,100,-100,100"
elif $5==10       colour="0,100,0,100,-pi,pi"
elif $5==11       colour="0,255,-100,100,-100,100"
elif $5==12       colour="0,1,-1,1,-1,1"
elif $5==15       colour="0,1,0,1,0,1"
elif $5==16       colour="0,255,-127.5,127.5,-127.5,127.5"
elif $5==16       colour="0,255,-127.5,127.5,-127.5,127.5"
elif $5==17       colour="0,255,-170,85,-170,85"
elif $5==18       colour="0,765,-255,255,-510,255"
elif $5<0         colour=${7--1}
fi

if $5<0 if $#<6 error ""$#">6==F" fi fi

tcr=3

if $5
 convert_colors_fwd=${arg\ $5,rgb2srgb,rgb2ryb,rgb2cmy,error,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch,rgb2yiq,rgb2yuv,rgb2ycbcr,rgb2ycbcrglic,rgb2xyz,rgb2yes,rgb2k1,rgb2ohta}
 convert_colors_bwd=${arg\ $5,srgb2rgb,ryb2rgb,cmy2rgb,error,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb,yiq2rgb,yuv2rgb,ycbcr2rgb,ycbcrglic2rgb,xyz2rgb,yes2rgb,k12rgb,ohta2rgb}
fi

repeat $! l[$>]
 if (s==3||s==4)&&$5
  convert_back=1
  if $5!=4
   $convert_colors_fwd.
  else
   if s==3 rgb2cmyk tcr+=1
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
  fi
 fi

 if !$6&&(s>$tcr||s==2) sh. 0,{s-2} remove_image=1 fi

 f. "begin(
  const dc=($1-1)/2;
  const kern=dc*2+1;
  const ts=s*2;
  NEW_COL=vectors(0);
  if($6,mm=vectorts("$colour",0,255);,mm=vectorts("$colour"););
  skip=1;
 );
 repeat(s,ss,
  N=crop(x-dc,y-dc,0,ss,kern,kern,1,1,1);
  min_val=min(mm[ss*2],mm[ss*2+1]);
  max_val=max(mm[ss*2],mm[ss*2+1]);
  tolerance=$2*(max_val-min_val)+min_val;
  if(skip,
   if($3,
    if($4
    ,calc_newcol()=i(x,y,z,ss)<tolerance?min_val:max_val;
    ,calc_newcol()=i(x,y,z,ss)<tolerance?min(N):max(N);
    );
   ,
    if($4
    ,calc_newcol()=i(x,y,z,ss)>tolerance?min_val:max_val;
    ,calc_newcol()=i(x,y,z,ss)>tolerance?min(N):max(N);
    );
   );
  skip--;
  );
  NEW_COL[ss]=calc_newcol();
 );

 NEW_COL;

 end(if(!skip,
  if($3,
    if($4
    ,calc_newcol()=i(x,y,z,ss)<tolerance?min_val:max_val;
    ,calc_newcol()=i(x,y,z,ss)<tolerance?min(N):max(N);
    );
   ,
    if($4
    ,calc_newcol()=i(x,y,z,ss)>tolerance?min_val:max_val;
    ,calc_newcol()=i(x,y,z,ss)>tolerance?min(N):max(N);
    );
   );
  );
 );"

 if $remove_image rm. fi

 if $convert_back
  if $5!=4
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb tcr-=1
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 fi
endl done
#@cli rep_pstrk: eq. to 'rep_perspective_streak' : (+)
rep_pstrk: rep_perspective_streak $*
#@cli rep_perspective_streak: -1<=_xpos<=1,-1<=_ypos<=1,-1<=_alpha_exponential_factor,0<_distance_threshold<=1,0<_distance_start<=1,_direction={ 0=in | 1=out },_streak_mode={ 0=color | 1=gray | 2=binary | 3=gray+binary },_preserve_edges={ 0=do_not_preserve_edges | 1=preserve_edges },_alpval
#@cli : Create perspective streak effect. _preserve_details only is applicable on non-binary mode.
#@cli : (eq. to 'rep_pstrk').\n
#@cli : Default values: '_xpos=0','_ypos=0','_alpha_exponential_factor=1','_distance_threshold=1','_distance_start=0','_direction=0','_streak_mode=0','_preserve_edges=1','_alpval'\n
#@cli : Author: Reptorian.
rep_perspective_streak:
skip ${1=0},${2=0},${3=0},${4=1},${5=0},${6=0},${7=0},${8=1},${9=}
point={[$1,$2]}
if !$4 error "$4|"$"4>0" fi
repeat $! l[$>]
 if s!=3
  echo "Applying perspective streak at coordinate point $point!"
  if h>w orientation=1
  else orientation=0
  fi
  if s>1
   sh. 0,{s-2}
   sh.. {s}
   f. ":begin(
    const cols=s#-2;
    );
    targ=0;
    !i?(
     v=vectorcols(0);
     vb=J(#-2,0,-1);
     vd=J(#-2,-1,0);
     vf=J(#-2,1,0);
     vh=J(#-2,0,1);
     j(0,-1)?(targ++;v+=vb;);
     j(-1,0)?(targ++;v+=vd;);
     j(1,0)?(targ++;v+=vf;);
     j(0,1)?(targ++;v+=vh;);
     targ?(v/=targ;I(#-2)=v;);
     0;
    ):i;"
   rm[-2,-1]
  fi
  rep_recpoltrans $point,-3
   if $5>0&&$5<1 f begin(sy=1/(((1-$5)*h)/h););i(x,y*sy,z,c,2); fi
   if $7||s==1
    channels {s-1}
    if $8
     if $7==3||$7==1 . n. 0,1 l. +f 1 rv a c endl store. details
     else echo "Details cannot be preserved using binary mode!"
     fi
    fi
    rep_axis_streak 1,!$6,$3,$9
    if $4>0&&$4<1
     f i>(1-$4)?i:(1-$4)
     n 0,1
    fi
    if $7==2 f i>0?1:0
    elif $7==3 +f i>0?1:0 a c fi
    if $8
     if $7==3||$7==1
      $details
      s. c,-{s-1}
      j[-3] [-2],0,0,0,0,1,[-1],1
      rm[-2,-1]
     fi
    fi
   else
    if $8 +store details fi
    if $4>0&&$4<1
     +channels {s-1}
     rep_axis_streak. 1,!$6,$3,$9
     f. i>(1-$4)?i:(1-$4)
     f. i>im#-1?1:0
    fi
    rep_axis_streak[0] 1,!$6,$3,$9
    if $4>0&&$4<1
     sh[0] {s#0-1}
     f. i0#-2*i
     k[0]
    fi
    if $8
     $details
     s. c,-{s-1}
     j[-3] [-2],0,0,0,0,1,[-1],{iM#-1}
     rm[-2,-1]
    fi
   fi
  rep_recpoltrans $point,2,$orientation
 else echo "Not applicable to images with 3 channels!"
 fi
endl done
#@cli rep_axis_streak: orientation,direction,_alpha_exponential_factor,_maxval>0_cmykmode={ 0=non-cmyk | 1=cmyka_mode }
#@cli : Streaks pixels based on distance away from center and placement of visible objects.
#@cli : '_alpha_exponential_factor' is used to manipulate the alpha mixing within pixels. The more power that is assigned to the alpha, the more mixing there would be.
#@cli : '_maxval' divides the alpha channel internally to normalize ranges to 0-1. A error will appear if not normalized. By default, it used the max alpha channel value.
#@cli : '_cmykmode' is only used in case of using only cmyk images. Not needed in normal cases at all.
#@cli : Default values: '_alpha_exponential_factor=0','_maxalp=n/a','_cmykmode=0'
#@cli :
#@cli : Author: Reptorian.
rep_axis_streak:
skip ${3=0},${4=},${5=0}
repeat $! l[$>]
 if s==1 rep_axis_streak_distance $*
 else rep_axis_streak_color $*
 fi
endl done
#@cli rep_axis_streak_distance: orientation,direction,_alpha_exponential_factor,_maxval
#@cli : Extract the alpha, then streaks pixels based on distance away from center and placement of visible objects.
#@cli : '_alpha_exponential_factor' is used to manipulate the alpha mixing within pixels. The more power that is assigned to the alpha, the more mixing there would be.
#@cli : '_maxval' divides the alpha channel internally to normalize ranges to 0-1. A error will appear if not normalized. By default, it used the max alpha channel value.
#@cli : Default values: '_alpha_exponential_factor=0','_maxalp=n/a'
#@cli :
#@cli : Author: Reptorian.
rep_axis_streak_distance:
skip ${3=0},${4=}

repeat $! l[$>]

 sh {s-1}
 if !iv#-1 rm. break else rm. fi

 if s>1 channels {s-1} fi

 if narg($4) alp={abs($4)}
 else alp={iM#-1}
 fi
 / $alp
 if iM>1||im<0 error alpval(valid)==F fi
 if $3<=-1 exp_f=-{1-10^-8} else exp_f=$3 fi
 f i^(1+$exp_f)

 if $1
  outdata_dim={w},1,{d},1
  outdata_coords=x,yy,z
  outdata_dimref=hh
  outdata_pos=yy
  if $2
   direction=yy=hh,yy>0,yy--
   end_level=yy
  else
   direction=yy=0,yy<hh,yy++
   end_level=(hh-yy)
  fi
 else
  outdata_dim=1,{h},{d},1
  outdata_coords=xx,y,z
  outdata_dimref=ww
  outdata_pos=xx
  if $2
   direction=xx=0,xx<ww,xx++
   end_level=(ww-xx)
  else
   direction=xx=ww,xx>0,xx--
   end_level=xx
  fi
 fi

 $outdata_dim,":begin(
  const ww=w#0-1;
  const hh=h#0-1;
 );
 mode=0;
 for("$direction",
  imgval=i(#-1,"$outdata_coords");
  !mode?(imgval?mode=1;);
  mode==1?(z_level="$outdata_dimref";mode=2;alp=imgval;);
  mode==2?(
   alp=alp+(1-alp)*imgval;
   z_level="$end_level"*imgval+(1-imgval)*z_level;
   i(#-1,"$outdata_coords")="$end_level"/z_level*alp;
  );
 );"
 rm.

endl done
#@cli rep_axis_streak_color: orientation,direction,_alpha_exponential_factor,_maxval>0,_add2new={ 0=add2old | 1=add2new },_cmykmode={ 0=non-cmyk | 1=cmyka_mode }
#@cli : Streaks colored pixels taking into account of opacity.
#@cli : '_alpha_exponential_factor' is used to manipulate the alpha mixing within pixels. The more power that is assigned to the alpha, the more mixing there would be.
#@cli : '_maxval' divides the alpha channel internally to normalize ranges to 0-1. A error will appear if not normalized. By default, it used the max alpha channel value.
#@cli : '_add2new' defines whether to streak data on old image or to streak pixel data onto a new image. Used for Perspective Streak.
#@cli : '_cmykmode' is only used in case of using only cmyk images. Not needed in normal cases at all.
#@cli : Default values: '_alpha_exponential_factor=0','_maxalp=n/a','_cmykmode=0'
#@cli :
#@cli : Author: Reptorian.
rep_axis_streak_color:
skip ${3=0},${4=},${5=0},${6=0}

tcr=3

if $6 tcr+=1 fi

if narg($4) if $4==0 return fi fi

repeat $! l[$>]

 if s==1||s==$tcr break fi

 vv=0
 repeat s
  sh $>
  vv+={iv#-1}
  rm.
 done
 if !$vv break fi

 sh. 0,{s-2}
 sh.. {s}
 f.. i#-1?I
 if narg($4) alp={abs($4)}
 else alp={iM#-1}
 fi
 /. $alp
 if iM#-1>1||im#-1<0 error alpval(valid)==F fi
 if $3<=-1 exp_f=-{1-10^-8} else exp_f=$3 fi
 f. i^(1+$exp_f)

 if $1
  outdata_dim={w},1,{d},{s#0}
  outdata_coords=x,yy
  if $2 direction=yy=hh-1,yy>=0,yy--
  else direction=yy=0,yy<hh,yy++
  fi
 else
  outdata_dim=1,{h},{d},{s#0}
  outdata_coords=xx,y
  if $2 direction=xx=0,xx<ww,xx++
  else direction=xx=ww-1,xx>=0,xx--
  fi
 fi

 if $5 {w#0},{h#0},{d#0},{s#0}
  col_info=-3
  alp_info=-2
  targ_info=#-1
  outdata_gen_1=I($targ_info,$outdata_coords,z)=temp;
 else
  col_info=-2
  alp_info=-1
  targ_info=#0
  outdata_gen_0=I($targ_info,$outdata_coords,z)=temp;
 fi

 $outdata_dim,":begin(
   const ww=w#0;
   const hh=h#0;
  );
  start_val=1;
  for("$direction",
   start_val?(
    start_val=0;
    col=I(#"$col_info","$outdata_coords",z);
    alp=i(#"$alp_info","$outdata_coords",z,0);
    temp=[col,alp];
   ):(
    newcol=I(#"$col_info","$outdata_coords",z);
    newalp=i(#"$alp_info","$outdata_coords",z,0);
    newinfo=[newcol,newalp];
    !newalp?(I("$targ_info","$outdata_coords",z)=temp;):
    newalp==1?(temp=newinfo;
    ):(
      "$outdata_gen_1"
      col=newcol*newalp+(1-newalp)*col;
      alp=alp+newalp*(1-alp);
      temp=[col,alp];
      "$outdata_gen_0"
    );
   );
  );"

 if $5 rm[^-2]
 else rm[1-3]
 fi

 sh. {s-1}
 *. $alp
 rm.

endl done
#@cli rep_mn: eq. to 'rep_multinormalize' : (+)
rep_mn: rep_multinormalize $*
#@cli rep_multinormalize: values
#@cli : Normalize based on channels using values.
#@cli : (eq. to 'rep_mn').\n
#@cli : Author: Reptorian.
rep_multinormalize:
$=a
repeat $! l[$>]
 repeat s
  val_a=${a{$>*2+1}}
  val_b=${a{$>*2+2}}
  sh $>
  normalize. $val_a,$val_b
  rm.
 done
endl done
#@cli rep_mc: eq. to 'rep_multicut' : (+)
rep_mc: rep_multicut $*
#@cli rep_multicut: values
#@cli : Cut based on channels using values.
#@cli : (eq. to 'rep_mc').\n
#@cli : Author: Reptorian.
rep_multicut:
$=a
repeat $! l[$>]
 repeat s
  val_a=${a{$>*2+1}}
  val_b=${a{$>*2+2}}
  sh $>
  cut. $val_a,$val_b
  rm.
 done
endl done
#@cli rep_cr: eq. to 'rep_cr'. : (+)
rep_cr: rep_channels_range
#@cli rep_2d_channels_ranges:
#@cli : Return the minimal and maximum values per channels in a image.\n
#@cli : Author: Reptorian.
rep_channels_range:
if $!>1 error "Cannot be used on more than 1 images!" fi
repeat s
 if $>==0
  sh $>
  minv={im#-1}
  maxv={iM#-1}
  cv=[$minv,$maxv]
  rm.
 else
  sh $>
  minv={im#-1}
  maxv={iM#-1}
  tcv=[$minv,$maxv]
  cv=[$cv,$tcv]
  rm.
 fi
done
u {"chv="$cv";(chv)"}
#@cli rep_ol: eq. to 'rep_orientation_list'. : (+)
#@cli : Return dimensions of selected images.
rep_ol: rep_orientation_list
#@cli rep_orientation_list:
#@cli : Return orientation of selected images.
#@cli : (eq. to rep_ol).
rep_orientation_list: _rep_orientation_list
_rep_orientation_list: ti={$!} u {"ro=vector$ti(0);for (k=0,k<$ti,++k,if(h#k>w#k,ro[k]=1,ro[k]=0););(ro)"}
#@cli rep_recpoltrans: eq. to 'rep_rectangular_polar_transformation'. : (+)
rep_recpoltrans: rep_rectangular_polar_transformation $*
#@cli rep_rectangular_polar_transformation : -1>=_xpos<=1,-1>=_ypos<=1,_from_to={ -3=to_inverted_rectangular_polar_preserved_details | -2=from_rectangular_polar_preserved_details_to_cartesian | -1=to_inverted_rectangular_polar | 0=to_rectangular_polar | 1=to_rectangular_polar_preserved_details| 2=from_preserved_details_inverted_rectangular_polar },orientation_0={ 0=landscape | 1=portrait },...,orientation_n
#@cli : Converts images to inversion of rectangular polar format or to rectangular polar format. Adapted for development of perspective filters. The first two variables defines the coordinates of revolution based on -1,1 ranges. 1,1 means the point of revolution is on top-right part of the image.
#@cli : (eq. to rep_recpoltrans).\n
#@cli : Note: When using 2 for $3, you need to define the orientation of every images. For every images, insert one argument per image after $3.
#@cli : Default values: '_xpos=0','_ypos=0','_from_to=0'
#@cli :
#@cli : Author: Reptorian.
rep_rectangular_polar_transformation:
skip ${1=0},${2=0},${3=0}
if $1<-1||$1>1 error "($1>=-1&&$1<=1)=0" fi
if $2<-1||$2>1 error "($2>=-1&&$2<=1)=0" fi
repeat $! l[$>]
 ov=${-rep_cr}
 if $3==-3
  maxlength={max(w,h)}
  perimeter={(w+h)*2}
  {$perimeter*2},{$maxlength*2},{d},{s},":begin(
   const ww=w#0;
   const hh=h#0;
   const point_x=(($1*-1)*.5+.5)*ww;
   const point_y=($2*.5+.5)*hh;
   const inv_point_x=ww-point_x;
   const inv_point_y=hh-point_y;
   const cut_ang_s0=abs(atan2(inv_point_y,inv_point_x)*180/pi);
   const cut_ang_s1=180-abs(atan2(inv_point_y,point_x)*180/pi);
   const cut_ang_s2=180+abs(atan2(point_y,point_x)*180/pi);
   const cut_ang_s3=360-abs(atan2(point_y,inv_point_x)*180/pi);
   distanceaway(value)=(
    value==0?ww-point_x:
    value==1?hh-point_y:
    value==2?point_x:
    point_y;
    );
   );
  surface_angle=(x/w)*360;
  surface_angle>cut_ang_s0&&surface_angle<=cut_ang_s1?side=1:
  surface_angle>cut_ang_s1&&surface_angle<=cut_ang_s2?side=2:
  surface_angle>cut_ang_s2&&surface_angle<=cut_ang_s3?side=3:
  side=0;
  mdist=abs(side%2?1/sin((surface_angle/180)*pi):1/cos((surface_angle/180)*pi));
  dix=(point_x+cos((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((ww-1)/ww);
  diy=(point_y+sin((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((hh-1)/hh);
  I(#0,ww-(dix+1),hh-(diy+1),z,2);
  "
  k.
 elif $3==-1||$3==-2
  f ":begin(
   const point_x=(($1*-1)*.5+.5)*w;
   const point_y=($2*.5+.5)*h;
   const inv_point_x=w-point_x;
   const inv_point_y=h-point_y;
   const cut_ang_s0=abs(atan2(inv_point_y,inv_point_x)*180/pi);
   const cut_ang_s1=180-abs(atan2(inv_point_y,point_x)*180/pi);
   const cut_ang_s2=180+abs(atan2(point_y,point_x)*180/pi);
   const cut_ang_s3=360-abs(atan2(point_y,inv_point_x)*180/pi);
   distanceaway(value)=(
    value==0?ww-point_x:
    value==1?hh-point_y:
    value==2?point_x:
    point_y;
    );
  );
  surface_angle=(x/w)*360;
  surface_angle>cut_ang_s0&&surface_angle<=cut_ang_s1?side=1:
  surface_angle>cut_ang_s1&&surface_angle<=cut_ang_s2?side=2:
  surface_angle>cut_ang_s2&&surface_angle<=cut_ang_s3?side=3:
  side=0;
  mdist=abs(side%2?1/sin((surface_angle/180)*pi):1/cos((surface_angle/180)*pi));
  dix=(point_x+cos((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((w-1)/w);
  diy=(point_y+sin((surface_angle/180)*pi)*distanceaway(side)*mdist*y/h)*((h-1)/h);
  I(w-(dix+1),h-(diy+1),z,2);
  "
  if $3<-1 r2dx 50%,6 fi
 elif $3==0||$3==1
  if $3>0 r2dx 200%,6 fi
  f ":begin(
   const ww=w-1;
   const hh=h-1;
   const sd=max(w,h)/min(w,h);
   const sx=w>h?sd:1;
   const sy=w>h?1:sd;
   const cx=.5+$1*.5;
   const cy=.5+$2*.5;
   const px=cx*w;
   const py=(1-cy)*h;
   const sxl=(w/2)/px;
   const sxr=(w/2)/(w-px);
   const syt=(h/2)/py;
   const syb=(h/2)/(h-py);
  );
  atx=(x/ww-cx)*sx;
  aty=(y/hh-(1-cy))*sy;
  sur_atan=(atan2(aty,atx)+pi)/(2*pi);
  xl=-1+(x/ww)*2*sxl;
  xr=1-(1-x/ww)*2*sxr;
  yt=-1+(y/hh)*2*syt;
  yb=1-(1-y/hh)*2*syb;
  xx=x>=px?xr:xl;
  yy=y>=py?yb:yt;
  sur_max=max(abs(xx),abs(yy));
  I(sur_atan*w,sur_max*h,z,2,2);
  "
  if $3>0 sharpen 2 fi
 elif $3==2
  $=val
  orientation=${val{$>+4}}
  half_perimeter={w/2}
  length_1={$half_perimeter-h}
  length_2={$half_perimeter-$length_1}
  if $orientation
   width={min($length_1,$length_2)}
   height={max($length_1,$length_2)}
  else
   width={max($length_1,$length_2)}
   height={min($length_1,$length_2)}
  fi
  $width,$height,{d},{s},":begin(
   const ww=w#0;
   const hh=h#0;
   const ox=$width;
   const oy=$height;
   const sd=max(ox,oy)/min(ox,oy);
   if(w>h,
    const sxf=ox>oy?sd:1;
    const syf=ox>oy?1:sd;
   ,
    const sxf=ox<oy?1:sd;
    const syf=ox<oy?sd:1;
   );
   const cx=.5+$1*.5;
   const cy=.5+$2*.5;
   const px=cx*ww;
   const py=(1-cy)*hh;
   const sxl=(ww/2)/px;
   const sxr=(ww/2)/(ww-px);
   const syt=(hh/2)/py;
   const syb=(hh/2)/(hh-py);
  );
  xx=(x/(w-1))*ww;
  yy=(y/(h-1))*hh;
  xl=-1+(xx/ww)*2*sxl;
  xr=1-(1-xx/ww)*2*sxr;
  yt=-1+(yy/hh)*2*syt;
  yb=1-(1-yy/hh)*2*syb;
  nxx=xx>px?xr:xl;
  nyy=yy>py?yb:yt;
  ay=max(abs(nxx),abs(nyy));
  ax=(atan2((yy/hh-(1-cy))*syf,(xx/ww-cx)*sxf)+pi)/(2*pi);
  I(#0,abs(ax*ww),abs(ay*hh),z,2,1);
  "
  r2dx. 50%,6
  k.
 else error "$3|"$"3!=intnum[-3,2]"
 fi
 rep_multicut $ov
endl done
#@cli rep_sd: eq. to 'rep_spiral_distort'. : (+)
rep_sd: rep_spiral_distort $*
#@cli rep_spiral_distort: _revolution!=0,_height!=0,_refraction>0,_direction={ 0=clockwise | 1=counterclockwise },_angle,_continuous_spiral={ 0=periodic | 1=continuous },-1<=_preshift_x<=1,-1<=_preshift_y<=1,_preshift_boundary={ 0=periodic | 1=mirror },_skew_x,_skew_y,_skew_m,_scale_coord_x,_scale_coord_y,_offx,_offy,_spiral_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest | 1=average | 2=linear | 3=bicubic | 4=lanczos }
#@cli : Transform images into spiral by using spiral gradient for x coordinate, and radial gradient for y coordinate.
#@cli : (eq. to 'rep_sd').\n
#@cli : '_revolution' defines the number of revolution within the spiral assuming coordinates range of [-1,1].
#@cli : '_height' is the height of spiral. The higher the height of the spiral, the more duplicates will repeat within one revolution.
#@cli : '_refraction' refers to the logarithmic distortion within spiral.
#@cli : '_direction' determines if it clockwise or counter-clockwise.
#@cli : '_angle' determines the function angle.
#@cli : '_continuous_spiral' determines whether the spiral distortion is continuous or not.
#@cli : '_preshift_x' shifts the images before the spiral distortion along the x-axis.
#@cli : '_preshift_y' shifts the image before the spiral distortion along the y-axis.
#@cli : '_preshift_boundary' determines the boundary within the preliminary shift.
#@cli : '_skew_x' skews the distortion alongside the x-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_skew_y' skews the distortion alongside the y-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_skew_m' is the multiplier for skewing.
#@cli : '_scale_x' scales the coordinates alongside the x-axis.
#@cli : '_scale_y' scales the coordinates alongside the y-axis.
#@cli : '_offx' determines the offset-placement of the distortion alongside the x-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_offy' determines the offset-placement of the distortion alongside the y-axis. It is recommended to keep ranges to -100% to 100%.
#@cli : '_spiral_boundary' determines how the out-of-bound values is to be evaluated.
#@cli : '_interpolation' determines the interpolation of the spiral distortion.\n
#@cli : Default values: '_frequency=1','_height=1','_refraction=0','_direction=0','_angle=0','_continuous_spiral=0','_preshift_x=0','_preshift_y=0','_preshift_boundary=0','_skew_x=0','_skew_y=0','_skew_m=1','_scale_x=1','_scale_y=1','_offx=0','_offy=0','_spiral_boundary=3','_interpolation=4'\n
#@cli : Author: Reptorian.
#@cli : $ sp car rep_spiral_distort 1,2,2,1,30,1,50%,50%,1,1,.25
rep_spiral_distort:
skip ${1=1},${2=1},${3=0},${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=0},${12=1},${13=1},${14=1},${15=0},${16=0},${17=3},${18=4}
if !$! v + error "No images to perform spiral distortion on" v - fi
if $1==0 v + error ""$"1/_revolution cannot be 0!" v - fi
if $2==0 v + error ""$"2/_height cannot be 0!" v - fi
if $3==-1 v + error ""$"3/_refraction cannot be -1!" v - fi
if !$13||!$14 v + error ""$"13/_scale_x and "$"14/_scale_y cannot be 0!" v - fi
v -
skew_m={abs(2*$12)}

direction=${arg\ $4+1,counterclockwise,clockwise}
spiral_mode=${arg\ $6+1,continuous,periodic}
periodic_boundary=${arg\ (abs($9)?1)+1,mirror,periodic}
spiral_boundary=${arg\ abs($17)+1,none,neumann,periodic,mirror}
interpolation=${arg\ abs($18)+1,nearest,average,linear,bicubic,lanczos}

if abs($7)||abs($8) preshift="Preshift of {$7*100}% alongside the x-axis, and {$8*100}% alongside the y-axis has been applied before the distortion using "$preshift_boundary" boundary condition."
else preshift=""
fi

v +

e[] "Apply spiral distortion at coordinates $15,$16 with scale factor of $13 within x-axis and $14 within y-axis and skew-"$skew_m" distortion utilizing factor of $10 within x-axis and factor of $11 within y-axis to images using "$direction" "$spiral_mode" spiral with revolution of $1, height of $2, refraction factor of $3 using "$spiral_boundary" boundary condition and "$interpolation" interpolation. "$preshift""

v +

if abs($18)>1 r2dx 200%,{abs($18)>2?abs($18)+2:abs($18)+1} fi
if abs($7)||abs($8)
 e[] "Apply of {$7*100}% alongside the x-axis, and {$8*100}% alongside the y-axis"
 f "begin(
   const offx=(w/2)*$7*-1;
   const offy=(h/2)*$8;
   const interpolation=abs($18)>2?2:abs($18);
   const boundary=(abs($9)+2);
  );
  J(offx,offy,z,interpolation,boundary);"
fi
if $4 mirror x fi
f "begin(
  const sd=max(w,h)/min(w,h);
  const sx=w>h?sd:1;
  const sy=w>h?1:sd;
  const ang=pi*($5*-1/180);
  const skew_x=($10*-1)/abs($13);
  const skew_y=$11/abs($14);
  const skew_m=abs(2*$12);
  const offx=-.5+($15*-1/2);
  const offy=-.5+($16*-1/2);
  const nw=abs(w*sin(ang))+abs(h*cos(ang));
  const nh=abs(w*cos(ang))+abs(h*sin(ang));
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  const interpolation=abs($18)>2?2:abs($18);
  const boundary=abs($17);
 );
 XX=(x/w+offx)*sx*$13;
 YY=(y/h+offy)*sy*$14;
 xx=(rot_x(XX,YY)*(skew_m^(rot_x(XX,YY)*skew_x)))*2;
 yy=(rot_y(XX,YY)*(skew_m^(rot_y(XX,YY)*skew_y)))*2;
 radial=norm(xx,yy);
 if($4,sur_atan=1-(atan2(xx,yy)+pi)/(2*pi);,sur_atan=(atan2(xx,yy)+pi)/(2*pi););
 es=sur_atan+radial*$1;
 es=es-floor(es);
 if($6,es=(es>.5?1-es:es)*2;);
 I((es^(1+$3))*w*$2,radial*h,z,interpolation,boundary);"
 if abs($18)>1 r2dx 50%,{abs($18)>2?abs($18)+2:abs($18)+1} fi
v -
#@cli rep_fibo_fill: eq. to 'rep_fibonacci_fill' : (+)
rep_fibo_fill: rep_fibonacci_fill $*
#@cli rep_fibonacci_fill: stack={ 0= top-left | 1= top-right | 2= bottom-left | 3= bottom-right },output_mode={ 0=corner | 1=spiral }, _initial_orientation={ 0=landscape | 1=portrait },_iteration>=0,_int_scale>0,{ boundary={0=periodic | 1=mirror} | -1<=spiral_location_x<=1 },{ append_mode={ 0=x | 1=y } | -1<=spiral_location_y<=1 },_palette_cycle,negate,_[palette],_seed_a...
#@cli : Generated filled image of fibonacci. If you need a complete fibonacci to use as a base, then execute 'gmic h +rep_fibonacci' for more information.
#@cli :
#@cli : (eq. to 'rep_fibo_fill')
#@cli : 1) stack defines the stacking of the fibonacci spiral. The options that are provided represent initial vector or orientation of the fibonacci spiral.
#@cli : 2) output_mode defines the style of stacking of the fibonacci base. If it is 1, then it's a spiral, otherwise, corner stacking.
#@cli : 3) _initial_orientation defines the initial stacking of the first two iteration of the fibonacci.
#@cli : 4) _iteration defines the number of iteration. 0 will automatically find the number of iterations requires for the maximum 2 dimensions to fit in.
#@cli : 5) If _iteration==0, and _output_mode==1, this option would be spiral_location_x. Otherwise, it would become boundary which is only applicable for _iteration>0.
#@cli : 6) If _iteration==0, and _output_mode==1, this option would be spiral_location_y. Otherwise, it would become append_mode which is only applicable for _iteration>0.
#@cli : 7) _palette_cycle* defines the shift of palette.
#@cli : 8) _negate defines whether to invert the order of palette.
#@cli : 9) _[palette]* defines the palette to be used for filling the fibonacci.
#@cli : 10) _seed* would define the seed to be used for generating order.
#@cli :
#@cli : *=See rep_custom_map for more details on how these options would work.
#@cli : Default values: '_initial_orientation=0','_iteration=0','{ boundary={0=periodic | 1=mirror} | -1<=spiral_location_x<=1 }=0','{ append_mode={ 0=x | 1=y } | -1<=spiral_location_y<=1 }}=0','_palette_cycle=n/a','_[palette]=n/a','seed=n/a'
#@cli :
#@cli : Author: Reptorian
rep_fibonacci_fill:
skip ${3=1},${4=0},${5=1},${6=0},${7=0},${8=},${9=0},${10=}

check $!>0

r 100%,100%,100%,1,-1

timg={$!}

mw=${-max_w}
mh=${-max_h}

+rep_fibonacci ${1-5}

fibo_id={$!-1}

if $4
 if narg(${10--1})>1
  .
  pass$10 0
  rep_custom_map[-3,-2] ${8--1}
  rm.
 else
  +negate.
  if $7<0 rv[-2,-1] fi
  if narg($8,$9) rep_custom_map[-2,-1] $8,$9 fi
 fi

 if $6
  r.. 200%,200%,1,100%,0,3,1,1
  r. 200%,200%,1,100%,0,3,1,0
 fi

 if ($7+($7<0))%2 a[-2,-1] x
 else a[-2,-1] y
 fi

 nw={ceil($mw/w#-1)*w#-1}
 nh={ceil($mh/h#-1)*h#01}

 r. $nw,$nh,100%,100%,0,2,.5,.5

 repeat $!-1
  +r. {w#$>},{h#$>},100%,100%,0,0,.5,.5
  rv[$>,-1]
  rm.
 done

else

 if $2
  f[^-1] "begin(
    const ww=w-1;
    const hh=h-1;
    const ox=(1+cut($6,-1,1))/2;
    const oy=(1+cut($7,-1,1))/2;
    const center_point=int($5/2);
    const px=int(xm#-1+center_point-ww*ox);
    const py=int(ym#-1+center_point-hh*oy);
   );
   i(#-1,px+x,py+y,z,0);"
 else
  if $1==0   j[^-1] [-1],0~,0~
  elif $1==1 j[^-1] [-1],1~,0~
  elif $1==2 j[^-1] [-1],0~,1~
  else       j[^-1] [-1],1~,1~
  fi
 fi

 if narg(${8--1})
  if narg($10)
   pass$10 0
   rep_custom_map[0--3] $8,$9,[-1],${11--1}
   rm.
  else
   rep_custom_map[^-1] $8,$9
  fi
 fi

fi

rm.
#@cli +rep_fibonacci: stack={ 0= top left | 1= top right | 2= bottom left | 3= bottom right }, output_mode={ 0=corner | 1=spiral }, _start_orientation={ 0=landscape | 1=portrait },_iteration>=0,int_scale>0
#@cli : stack defines the way that the fibonacci generator will stack within iterations.
#@cli : output_mode defines the style of stacking.
#@cli : _start_orientation defines the orientation of the first two iteration.
#@cli : _iteration defines the number of iteration. 0 means it will auto-find the number of generation.
#@cli :
#@cli : Author: Reptorian
+rep_fibonacci:
skip ${3=0},${4=0},${5=1}
check "$5&&($5==int($5))"
# _stack=={ 0= top left | 1= top right | 2= bottom left | 3= bottom right }
# _spiral_mode={ 0= non-spiral | 1= spiral_fill }
# _start_pos
# _iteration

dir={$1%4}

if $4==1 1 return fi

use_dim_lim={!$4}

if $4
 iter_lim=$4
else
 iter_lim=inf
 mw=${-max_w}
 mh=${-max_h}
fi

__size_n=2
size_1=1
size_2=2

__iter=2

m "swap: rv[-2,-1]"
m "join: a[-2,-1] $""1"

center_point={$5>1?int($5/2)}

if $5>1
 m "ins_north: ns={$__size_n*$5} $ns,$ns,1,1,$__iter swap join y"
 m "ins_south: ns={$__size_n*$5} $ns,$ns,1,1,$__iter join y"
 m "ins_west: ns={$__size_n*$5} $ns,$ns,1,1,$__iter swap join x"
 m "ins_east: ns={$__size_n*$5} $ns,$ns,1,1,$__iter join x"
else
 m "ins_north: $__size_n,$__size_n,1,1,$__iter swap join y"
 m "ins_south: $__size_n,$__size_n,1,1,$__iter join y"
 m "ins_west: $__size_n,$__size_n,1,1,$__iter swap join x"
 m "ins_east: $__size_n,$__size_n,1,1,$__iter join x"
fi

na={$2?4:2}

if $3
 if $2 #Spiral Mode#
  if $1%2 1,2,1,1,1-y
  else    1,2,1,1,y
  fi
  if $5>1 r2dx. {$5*100}%,1 fi
  if $dir==0   ins_arg=ins_west,ins_south,ins_east,ins_north
  elif $dir==1 ins_arg=ins_west,ins_north,ins_east,ins_south
  elif $dir==2 ins_arg=ins_east,ins_south,ins_west,ins_north
  else         ins_arg=ins_east,ins_north,ins_west,ins_south
  fi
 else #Corner Mode#
  if $dir<2 1,2,1,1,y
  else      1,2,1,1,1-y
  fi
  if $5>1 r2dx. {$5*100}%,1 fi
  if $dir==0   ins_arg=ins_east,ins_south
  elif $dir==1 ins_arg=ins_west,ins_south
  elif $dir==2 ins_arg=ins_east,ins_north
  else         ins_arg=ins_west,ins_north
  fi
 fi
else
 if $2 #Spiral Mode#
  if $1%2 2,1,1,1,x
  else    2,1,1,1,1-x
  fi
  if $5>1 r2dx. {$5*100}%,1 fi
  if $dir==0   ins_arg=ins_north,ins_west,ins_south,ins_east
  elif $dir==1 ins_arg=ins_north,ins_east,ins_south,ins_west
  elif $dir==2 ins_arg=ins_south,ins_west,ins_north,ins_east
  else         ins_arg=ins_south,ins_east,ins_north,ins_west
  fi
 else #Corner Mode#
  if $1%2 2,1,1,1,1-x
  else      2,1,1,1,x
  fi
  if $5>1 r2dx. {$5*100}%,1 fi
  if $dir==0   ins_arg=ins_south,ins_east
  elif $dir==1 ins_arg=ins_south,ins_west
  elif $dir==2 ins_arg=ins_north,ins_east
  else         ins_arg=ins_north,ins_west
  fi
 fi
fi

do

 if $__iter==$iter_lim break fi

 if $use_dim_lim
  if w#-1>$mw&&h#-1>$mh
   if $2
    if {"
     center_point=$center_point;
     mw=$mw;
     mh=$mh;
     xp=xm#-1+center_point;
     yp=ym#-1+center_point;
     lxp=xp-mw;
     rxp=xp+mw;
     typ=yp-mh;
     byp=yp+mh;
     cond_a=i(#-1,lxp,typ,0,0,0,0);
     cond_b=i(#-1,rxp,typ,0,0,0,0);
     cond_c=i(#-1,lxp,byp,0,0,0,0);
     cond_d=i(#-1,rxp,byp,0,0,0,0);
     cond_a&&cond_b&&cond_c&&cond_d;
    "} break fi
   else break
   fi
  fi
 fi

 ${arg\ ($__iter%$na)+1,$ins_arg}

 __size_n={$size_1+$size_2}
 size_1=$size_2
 size_2=$__size_n

 __iter+=1
while $__iter<$iter_lim
um swap,join,ins_north,ins_south,ins_west,ins_east
#@cli rep_gv: eq. to 'rep_glass_vignette'. : (+)
rep_gv: rep_glass_vignette $*
#@cli rep_glass_vignette: refraction,_refraction_power,_len_size=1,_chromatic_aberration,-100%<=_preliminary_shift_x<=100%,-100%<=_preliminary_shift_y<=100%,_image_additional_zoom>0,-360<=_image_angle<=360,_distortion_scale_x,_distortion_scale_y,_distortion_scale_xy>0,-360<=_distortion_angle<=360,_distortion_offset_x,_distortion_offset_y,_subpixel>0,0<=_colorspace<=1,_boundary={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest | 1=average | 2=linear | 3=grid | 4=bicubic | 5=lanczos }
#@cli : Distorts images as if it is based from the view of a bulged car mirror or camera len. This G'MIC filter is a heavily extended version of TR's Glass Vignette plugin made for Paint.NET by TechnoRobbo. It can also be used for generating abstract art as well.
#@cli : (eq. to 'rep_gv').
#@cli :
#@cli : 'refraction' defines the strength of distortion. The farther the values from 0, the greater the distortion is. It is recommended to use percentage alongside a number.
#@cli : '_refraction_power' defines the distortion factor within the refraction. The farther the values from 0, the greater the distortion is. It is recommended to use percentage alongside a number.
#@cli : '_len_size' is the size of distortion accordingly to the terminal ends of the lens distortion.
#@cli : '_chromatic_aberration' is the degree of aberration within channels. The farther the values from 0, the greater the distortion per channels would be. It is recommended to use percentage alongside a number.
#@cli : '_preliminary_shift_x' is the preshift of images before the distortion effect. This is used in the original plugin. It is recommended to use percentage alongside a number.
#@cli : '_preliminary_shift_y' is the preshift of images before the distortion effect. This is used in the original plugin. It is recommended to use percentage alongside a number.
#@cli : '_image_additional_zoom' defines the scaling based on scaling of coordinates of image within the distortion effect. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_image_angle' defines the angle of image within the distortion.
#@cli : '_distortion_scale_x' is the scaling of distortion within the x-axis. When this is set to 0, the ratio of image is used instead. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_distortion_scale_y' is the scaling of distortion within the y-axis. When this is set to 0, the ratio of image is used instead. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_distortion_scale_xy' is the scaling of distortion within the x and y axis at the same time.
#@cli : '_distortion_angle' is the angle of distortion effect. 0 starts with scaling of 1x, and 1 means scaling of 2x.
#@cli : '_distortion_offset_x' is the displacement of distortion within the x-axis. It is recommended to use percentage alongside a number.
#@cli : '_distortion_offset_y' is the displacement of distortion within the y-axis. It is recommended to use percentage alongside a number.
#@cli : '_subpixel' is the level of subpixel sampling to be used.
#@cli : '_colorspace' defines the color space of the image to process distortion on.
#@cli : '_boundary' defines how the out-of-bound areas is to be behave.
#@cli : '_interpolation' defines the interpolation within distortion.
#@cli : Default values: '_refraction_power=0','_lensize=1','_chromatic_aberration=0','_preliminary_shift_x=0','_preliminary_shift_y=0','_image_zoom=0','_image_angle=0','_distortion_scale_x=1','_distortion_scale_y=1','_distortion_scale_xy=1','_distortion_angle=0','_distortion_offset_x=0','_distortion_offset_y=0','_subpixel=1','_colorspace=0','_boundary=3','_interpolation=5',
#@cli :
#@cli : Author: Reptorian.
rep_glass_vignette:
skip ${1=100%},${2=0%},${3=100%},${4=0%},${5=0},${6=0},${7=0},${8=0},${9=100%},${10=100%},${11=100%},${12=0},${13=100%},${14=100%},,${15=1}${16=0},${17=3},${18=2}

convert_colors_fwd=${arg\ 1+$16,,rgb2srgb,rgb2ryb,rgb2cmy,,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch,rgb2yiq,rgb2yuv,rgb2ycbcr,rgb2ycbcrglic,rgb2xyz,rgb2yes,rgb2k1}
convert_colors_bwd=${arg\ 1+$16,,srgb2rgb,ryb2rgb,cmy2rgb,,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb,yiq2rgb,yuv2rgb,ycbcr2rgb,ycbcrglic2rgb,xyz2rgb,yes2rgb,k12rgb}

convert_back=0

sub={1+abs($15)}

repeat $! l[$>]

 v +
  e[^-1] "Distorts image at angle of $12 with refraction factor of $1, chromatic aberration of $4, zoom factor of $7, preliminary shift of $5, preliminary shift of $6, scale x-axis distortion by $9 multiplied by $11, scale y-axis distortion by $10 multiplied by $11, refraction index by power of $2 placed at $13,$14 at angle of $8."
 v -

 if (s==3||s==4)&&$16
  convert_back=1
  if $16!=4
   $convert_colors_fwd.
  else
   if s==3 rgb2cmyk
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
  fi
 fi

 shift $5,$6,0,0,$17

 r2dx {$sub*100}%,1

 f "*begin(
   const abr=((1-$1)-.001)/.999;
   const aberate=sqr(1*abr+(1-$4)*(1-abr));
   const offset_x=w/2*(1-$13);
   const offset_y=h/2*(1-$14);
   $9&&$10?(
    const mx=1/($9*(1/$11));
    const my=1/($10*(1/$11));
   ):(
    w>h?(
     const mx=1/(1*(1/$11));
     const my=1/((h/w)*(1/$11));
    ):(
     const mx=1/((w/h)*(1/$11));
     const my=1/(1*(1/$11));
    );
   );
   const ang=pi*($8/180);
   const dang=pi*($12/180);
   const distrad=1*10^($2/10);
   const cos_ang=cos(ang);
   const sin_ang=sin(ang);
   const cos_dang=cos(dang);
   const sin_dang=sin(dang);
   rot_x(a,b)=a*cos_ang-b*sin_ang;
   rot_y(a,b)=a*sin_ang+b*cos_ang;
   dist_rot_x(a,b)=a*cos_dang-b*sin_dang;
   dist_rot_y(a,b)=a*sin_dang+b*cos_dang;
   const sd=max(w,h)/min(w,h);
   const sx=w>h?sd:1;
   const sy=w>h?1:sd;
   rx(a)=((a/2+.5*sx)/sx)*w;
   ry(a)=((a/2+.5*sy)/sy)*h;
   eucl_norm(a,b)=sqrt(a^2+b^2);
   const cv=(eucl_norm(rot_x(sx,sy)/2,rot_y(sx,sy)/2))*(pi/2)*(max(w,h)/min(w,h))*$3;
   off_x_primary(a,b)=cos(a)*b*(abs($7)+1);
   off_y_primary(a,b)=sin(a)*b*(abs($7)+1);
   off_secondary(a,b,c)=a*(1-c)+b*c;
   const interpolation=min(abs($18),2);
   const mxsx=mx*sx;
   const mysy=my*sy;
   const expf=1-$1;
   s==1?result()=vectors(i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17)):
   s==2?result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17)):
   s==3?result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17),i(fax,fay,0,2,interpolation,$17)):
   s==4?result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17),i(fax,fay,0,2,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,3,interpolation,$17)):
        result()=vectors(i(fbx,fby,z,0,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,1,interpolation,$17),i(fax,fay,0,2,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,3,interpolation,$17),i(avg_fax_fbx,avg_fay_fby,z,4,interpolation,$17));
  );
  XX=((x+offset_x)/w-.5)*2;
  YY=((y+offset_y)/h-.5)*2;
  xx=dist_rot_x(XX,YY);
  yy=dist_rot_y(XX,YY);
  xx*=mxsx;
  yy*=mysy;
  XX=rot_x(xx,yy);
  YY=rot_y(xx,yy);
  far=norm(XX,YY);
  rad=atan2(YY*distrad,XX);
  eff=far/cv;
  RB=far^expf;
  RA=RB*aberate;
  off_xS=off_x_primary(rad,far);
  off_xA=off_x_primary(rad,RA);
  off_xB=off_x_primary(rad,RB);
  off_yS=off_y_primary(rad,far);
  off_yA=off_y_primary(rad,RA);
  off_yB=off_y_primary(rad,RB);
  offxA=off_secondary(off_xS,off_xA,eff);
  offyA=off_secondary(off_yS,off_yA,eff);
  offxB=off_secondary(off_xS,off_xB,eff);
  offyB=off_secondary(off_yS,off_yB,eff);
  fax=rx(offxA);
  fay=ry(offyA);
  fbx=rx(offxB);
  fby=ry(offyB);
  avg_fax_fbx=avg(fax,fbx);
  avg_fay_fby=avg(fay,fby);
  result();"

 r2dx {(1/$sub)*100}%,{abs($18%6)+1}

 if $convert_back
  if $16!=4
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 fi

endl done
#@cli rep_cube2equi: eq. to 'rep_cube_map_to_equirectangular_panorama'. : (+)
rep_cube2equi: rep_cube_map_to_equirectangular_panorama $*
#@cli rep_cube_map_to_equirectangular_panorama: 0<=_top_face_placement<=3,0<=_bottom_face_placement<=3
#@cli : An extension of a code provided by 'Bartosz' at stackoverflow to solve conversion from cube map to equirectangular panorama. Source: https://stackoverflow.com/questions/34250742/converting-a-cubemap-into-equirectangular-panorama
#@cli : (eq. to 'rep_cube2equi').\n
#@cli : Default values: '_top_face_placement=1','_bottom_face_placement=_top_face_placement'\n
#@cli : Author: Reptorian.
rep_cube_map_to_equirectangular_panorama:
skip ${1=1}
if $#>2 error narg(\$\*)<3==F fi
if $1<0||$-1<0||$1>3||$-1>3||!isint($1)||!isint($-1) error intargs(\$\*)==F\ ||\ (\ (\$"1"<3==F||\$"2"<3==F)\ ||\ absargs(\$\*)==F\ ) fi
repeat $! l[$>]
v + e[^-1] "Convert cube map to equirectangular panorama using face $1 for top placement and face $-1 for bottom placement!" v -
ratio={h/w}
if $ratio<1.5 r {w},{.75*w},100%,100%,5
else r {1.5*h},{h},100%,100%,5
fi
f "begin(
    const a1=$1;
    const a2=$1+1;
    const b1=$-1;
    const b2=$-1+1;
    const edge=h/3;
    const tl_edge=edge*a1;
    const tr_edge=edge*a2;
    const bl_edge=edge*b1;
    const br_edge=edge*b2;
    const bottom_edge=edge*2;
);
if(((y>=edge)&&(y<bottom_edge))||(y<bottom_edge?(x>=tl_edge&&x<tr_edge):(x>=bl_edge&&x<br_edge))
,i
,
    (j(0,-1)&&j(1,0))?(avg(j(0,-1),j(1,0))):
    (j(-1,0)&&j(0,-1))?(avg(j(-1,0),j(0,-1))):
    (j(-1,0)&&j(0,1))?(avg(j(-1,0),j(0,1))) :
    (j(0,1)&& j(1,0))?(avg(j(0,1),j(1,0))) :
    j(1,0)?j(1,0):
    j(-1,0)?j(-1,0):
    j(0,1)?j(0,1):
    j(0,-1)?j(0,-1)
    ;
);"
{w},{w/2},100%,100%,"
begin(
    const ww=w-1;
    const hh=h-1;
    const cubeface_w=w#0/4;
    const cubeface_h=(h#0-.5)/3;
    const xpb=$-1<2;
    const ypb=!($-1%3)?1;
    const xpt=$1<2;
    const ypt=($1%3)?1;
    yp=-1;
);
if(y!=yp,v=1-y/hh;theta=v*pi;yp++;);
u=x/ww;
phi=u*2*pi;
xc=cos(phi)*sin(theta);
yc=cos(theta);
zc=sin(phi)*sin(theta)*-1;
a=max(abs(xc),abs(yc),abs(zc));
xa=xc/a;
ya=yc/a;
za=zc/a;
xa==1?(
    xp=((za+1)/2-1)*cubeface_w;
    xo=0;
    yp=((ya+1)/2)*cubeface_h;
    yo=cubeface_h;
):
xa==-1?(
    xp=((za+1)/2)*cubeface_w;
    xo=cubeface_w*2;
    yp=((ya+1)/2)*cubeface_h;
    yo=cubeface_h;
):
ya==1?(
    xp=((($-1%2?xa:za)+1)/2-xpb)*cubeface_w;
    xo=cubeface_w*$-1;
    yp=((($-1%2?za:xa)+1)/2-ypb)*cubeface_h;
    yo=2*cubeface_h;
):
ya==-1?(
    xp=((($1%2?xa:za)+1)/2-xpt)*cubeface_w;
    xo=cubeface_w*$1;
    yp=((($1%2?za:xa)+1)/2-ypt)*cubeface_h;
    yo=0;
):
za==1?(
    xp=((xa+1)/2)*cubeface_w;
    xo=cubeface_w*3;
    yp=((ya+1)/2)*cubeface_w;
    yo=cubeface_h;
):
za==-1?(
    xp=((xa+1)/2-1)*cubeface_w;
    xo=cubeface_w;
    yp=((ya+1)/2)*cubeface_w;
    yo=cubeface_h;

):(
    nan;
);
xp=abs(xp)+xo;
yp=abs(yp)+yo;
i(#0,xp,yp,z,c,1,1);
"
rm..
endl done
#@cli rep_equi2cube: eq. to 'rep_equirectangular_panorama_to_cube_map'. : (+)
rep_equi2cube: rep_equirectangular_panorama_to_cube_map $*
#@cli rep_equirectangular_panorama_to_cube_map: 0<=_top_face_placement<=3,0<=_bottom_face_placement<=3
#@cli : An extension of a code provided by 'Salix alba' at stackoverflow to solve conversion from equirectangular panorama to cube map. Source: https://stackoverflow.com/questions/29678510/convert-21-equirectangular-panorama-to-cube-map
#@cli : (eq. to 'rep_equi2cube').\n
#@cli : Note: _bottom_face_placement will use placement of _top_face_placement when not specified.
#@cli : Default values: '_top_face_placement=1','_bottom_face_placement=_top_face_placement'\n
#@cli : Author: Reptorian.
rep_equirectangular_panorama_to_cube_map:
skip ${1=1}
if $#>2 error narg(\$\*)<3==F fi
if $1<0||$-1<0||$1>3||$-1>3||!isint($1)||!isint($-1) error intargs(\$\*)==F\ ||\ (\ (\$"1"<3==F||\$"2"<3==F)\ ||\ absargs(\$\*)==F\ ) fi
repeat $! l[$>]
 v + e[^-1] "Convert equirectangular panorama to cube map using face $1 for top placement and face $-1 for bottom placement!" v -
 ratio={w/h}
 if $ratio<2 r {w},{.5*w},100%,100%,5
 else r {2*h},{h},100%,100%,5
 fi
 {w},{.75*w},100%,100%,"begin(
   edge=w/4;
   outImgToXYZ(xc,yc,face,edge)=(
    a=2*xc/edge;b=2*yc/edge;
    if(face==0,ret=[-1,1-a,3-b];); #Left Face#
    if(face==1,ret=[a-3,-1,3-b];); #Front Face#
    if(face==2,ret=[1,a-5,3-b];); #Right Face#
    if(face==3,ret=[7-a,1,3-b];); #Back Face#

    if($1==0,if(face==4,ret=[1-b,1-a,1];); #Top Face#
    ,if($1==1,if(face==4,ret=[a-3,1-b,1];);
    ,if($1==2,if(face==4,ret=[b-1,a-5,1];);
    ,if($1==3,if(face==4,ret=[7-a,b-1,1];);
    );
    );
    );
    );

    if($-1==0,if(face==5,ret=[b-5,1-a,-1;]); #Bottom Face#
    ,if($-1==1,if(face==5,ret=[a-3,b-5,-1;]);
    ,if($-1==2,if(face==5,ret=[5-b,a-5,-1;]);
    ,if($-1==3,if(face==5,ret=[7-a,5-b,-1;]);
    );
    );
    );
    );
    ret;
   );
  );
  face2=int(x/edge);
  if(y<edge,face2=4;);
  if(y>edge*2,face2=5;);
  coord3=outImgToXYZ(x,y,face2,edge);
  theta=atan2(coord3[1],coord3[0]);
  r=norm(coords3[0],coords3[1]);
  phi=atan2(coord3[2],r);
  uf=((theta+pi)/pi)*edge*2;
  vf=((pi/2-phi)/pi)*edge*2;
  if($1==$-1,if((x>=edge*$1&&x<edge*($1+1))||(y>=edge&&y<edge*2),i(#0,uf,vf,z,c,2,2););, #If first and last variable are the same, then visible output will show top and bottom faces along the same face#
  if(y<edge*2,if((x>=edge*$1&&x<edge*($1+1))||(y>=edge&&y<edge*2),i(#0,uf,vf,z,c,2,2););,if((x>=edge*$-1&&x<edge*($-1+1))||(y>=edge&&y<edge*2),i(#0,uf,vf,z,c,2,2);););); #If first and last variable are not the same, then visible output will show top and bottom faces along the same face#"

 rm..
endl done
#@cli rep_trps: eq. to 'rep_tr_pixel_sharpener'. : (+)
rep_trps: rep_tr_pixel_sharpener $*
#@cli rep_tr_pixel_sharpener: sharpen,_internal_blur>=0,_type= { 0=Photo | 1= Horizontal | 2= Vertical | 3= One-Axis Angle | 4= Two-Axis Angle | 5= Two-Axis Disconnected},-360<=_sharpening_angle_a<=360,-360<=_sharpening_angle_b<=360
#@cli : Extended version of the original TR's Pixel Sharpener for Paint.NET. Some code were changed to make more sense or is more practical. Negative values are enabled for first variable in the G'MIC version. The original code this was based on was created by TechnoRobbo. Source code - https://forums.getpaint.net/topic/26783-trs-pixel-sharpener-plugin-v20-dec-21-2014/
#@cli : (eq. to 'rep_trps').\n
#@cli : Default values: '_internal_blur=0','_blur_type=0','_sharpening_angle=0'\n
#@cli : Author: Reptorian.
rep_tr_pixel_sharpener:
skip ${2=0},${3=0},${4=0},${5=0}
f "begin(
  const ang=pi*($4/180);
  const ang2=pi*($5/180);
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  const cos_ang2=cos(ang2);
  const sin_ang2=sin(ang2);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  rot_y_alt(a,b)=a*sin_ang2+b*cos_ang2;
  const blur=(round(abs($2)+1)-1)*2+3;
  const qblur=sqr(blur);
  const eblur=floor(blur/2);
  const sblur=floor(blur/-2);
  const coeff=$1/100;
  const mult=qblur*coeff+eblur/round(abs($2)+1);
  const choice=abs($3)<=2?abs($3):0;
  $3==5?(
   fnx()=x+rot_x(j,k);
   fny()=y+rot_y_alt(j,k);
  ):
  $3==4?(
   fnx()=x+rot_x(j,k);
   fny()=y+rot_y(j,k);
  ):
  $3==3?(
   fnx()=x+rot_x(j,0);
   fny()=y+rot_y(j,0);
  ):
  $3==2?(
   fnx()=x;
   fny()=y+k;
  ):
  $3==1?(
   fnx()=x+j;
   fny()=y;
  ):(
   fnx()=x+j;
   fny()=y+k;
  );
 );
 sum=i*mult;
 for(k=int(sblur),k<=eblur,k++,
  for(j=int(sblur),j<=eblur,j++,
   if(k!=0&j!=0,
    nx=fnx();
    ny=fny();
    nfcalc=i(nx,ny,z,c,0,1);
    sum-=nfcalc*coeff;
   );
  );
 );
 sum;"
#@cli rep_trif: eq. to 'rep_technorobbo_intense_filtration'. : (+)
rep_trif: rep_technorobbo_intense_filtration $*
#@cli rep_technorobbo_intense_filtration: 0<=hue<=360,_gain,_mix,_style_based_on={ 0=Original | 1=Grayscale | 2=Hue },_use_255={ 0=1 | 1=255 }
#@cli : This command is a color filter and augmenter. The code is based from TechnoRobbo's Intense Filtration source code - https://forums.getpaint.net/topic/30148-trs-intense-filtration-v-13-oct-092014/
#@cli : (eq. to 'rep_trif').\n
#@cli : Warning: This command only works on images with 3 or 4 channel image. It doesn't discriminate between CMYK and RGBA image! So, make sure they're all RGB/RGBA images before using this command!\n
#@cli : 'hue' defines the color to augment.
#@cli : '_gain' defines the coefficient of image or number to multiple on data based on original image.
#@cli : '_mix' defines the strength of the filter.
#@cli : '_style_based_on' defines the style output of the filter based on corresponding name for number defined by filter.
#@cli : '_use_255' defines the maximum value for RGB image. If using float values from 0-1 range, then set to 0, else set to 1.\n
#@cli : Default values: '_gain=2','_mix=1','_style_based_on=0','_use_255=1'\n
#@cli : Author: Reptorian.
rep_technorobbo_intense_filtration:
skip ${2=2},${3=1},${4=0},${5=1}
hue={abs($1)-floor(abs($1)/360)*360}
($hue^1^1)
hsv2rgb. /. 255
repeat $!-1
    if s#$>==3||s#$>==4
        sh[$>] 0,2

        f. "begin(
          endval(a,b)=(a*mix+(b-b*mix));
          const mv=$5?255:1;
          const mixval=abs($3)>1?1:abs($3);
          const mix=1-mixval;
          const thresh=abs($2)>1?mv/2:mv;
          const himax=mv*abs($2)-thresh;
          $4==2?result()=endval(gv,tmpv):
          $4==1?result()=endval(gray,tmpv):
                result()=endval(cv,tmpv);
         );
         tmpv=i*abs($2)*i(#-2,0,0);
         tmpv=tmpv>mv?mv:tmpv;
         gray=((i0+i1+i2)/3)*abs($2);
         gray=gray>mv?mv:gray;
         cv=i*abs($2);
         cv=cv>thresh?(cv-thresh)*(mv-thresh)/himax+thresh:cv;
         graymix=gray/mv;
         gv=i(#-2,0,0)*graymix*mv*abs($2);
         gv>mv?mv:gv;
         result()"

        rm.
    else v + error "Image \["$>"\] contains "{s#$>}" channels which does not meet the requirement of 3 or 4 channels!" v -
    fi
done
rm.
#@cli rep_colmt: eq. to 'rep_color_modulo_texture'. : (+)
rep_colmt: rep_color_modulo_texture $*
#@cli rep_color_modulo_texture: colorspace={ 0=rgb | 1=ryb | 2=cmy | 3=cmyk | 4=hsi | 5=hsl | 6=hsv | 7=lab | 8=lch | 9=yiq | 10=yuv | 11=ycbcr | 12=ycbcrglic | 13=xyz | 14=yes },_include_alpha={ 0=no_alpha | 1=alpha},0<=_channel_order<{ 6 | 24 },_flip_diagonal={ 0=do_not_flip | 1=flip },sublevel>=0,interpolation>=0,_modulo_method_1= { 0=Mod | 1=Reflected Mod | 2=Divmod | 3=Reflected Divmod },_modulo_value_a_1>0,_modulo_value_b_1>0,_angle_1<=360,_value_shift_1>0,_centered_1= { 0=Not centered | 1=Centered },_negate_mod_1= { 0=Not Negated | 1=Negated },_normalize_bool_1= { 0=Do not Normalize | 1=Normalize }..._negate_mod_3
#@cli : Inspired by MadJik's Color Modulo Texture for Paint.NET, this is a extension of that filter converted into G'MIC form. New features is being able to change color space, allow alpha, and anti-aliasing.
#@cli : (eq. to 'rep_colmt').\n
#@cli : '_modulo_method' defines what method of modulo operation would be applied to each channel.
#@cli : '_modulo_value_a' and 'modulo_value_b' is value used for calculation of modulo of function per channel.
#@cli : '_angle' defines the function angle.
#@cli : '_centered' defines if the function are centered.
#@cli : '_value_shift' adds value to function before modulo calculation.
#@cli : '_centered' is used to define whether the modulo is center.
#@cli : '_negate_mod' negates the end modulo value.
#@cli : '_normalize_bool' is used to normalize values. Note - This can be used to make the filter behave similar to Madjik's Color Modulo Texture filter.
#@cli : '_diagonal_flip' is used to flip diagonal function.
#@cli : '_colorspacemode' defines the color space of modulo.
#@cli : '_contain_alpha' adds alpha value to modulo. In the case of CMYK, this option is nullified, and K is used to replace alpha instead.
#@cli : '_subpixel_processing_level' defines the subpixel processing level.
#@cli : '_interpolation' defines the method of interpolation.
#@cli : '_channel_num' defines the order of channel.
#@cli : Default values: '_include_alpha=0','_channel_order=0','_flip_diagonal=0','_sublevel=1','_interpolation=1','_modulo_method_n=3','_modulo_value_a_n=196','_modulo_value_b_n=255','_angle_n=0','_value_shift_n=0','_center_n=0','_negate_n=0','_normalize_n=0'
rep_color_modulo_texture:
skip ${2=0},${3=0},${4=0},${5=1},${6=5},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=},${16=},${17=},${18=},${19=},${20=},${21=},${22=},${23=},${24=},${25=},${26=},${27=},${28=},${29=},${30=},${31=},${32=},${33=},${34=},${35=},${36=},${37=},${38=}
if narg($7)  modulo_method_0={$7%4}  else modulo_method_0=3 fi
if narg($8)  modvalue_a_0={abs($8)}  else modvalue_a_0=196 fi
if narg($9)  modvalue_b_0={abs($9)}  else modvalue_b_0=255 fi
if narg($10) angle_0=$10             else angle_0=0 fi
if narg($11) value_shift_0=$11       else value_shift_0=0 fi
if narg($12) center_0=$12            else center_0=1 fi
if narg($13) negate_0=$13            else negate_0=0 fi
if narg($14) normalize_0=$14         else normalize_0=0 fi
if narg($15) modulo_method_1={$15%4} else modulo_method_1=$modulo_method_0 fi
if narg($16) modvalue_a_1={abs($16)} else modvalue_a_1=$modvalue_a_0 fi
if narg($17) modvalue_b_1={abs($17)} else modvalue_b_1=$modvalue_b_0 fi
if narg($18) angle_1=$18             else angle_1=$angle_0 fi
if narg($19) value_shift_1=$19       else value_shift_1=$value_shift_0 fi
if narg($20) center_1=$20            else center_1=$center_0 fi
if narg($21) negate_1=$21            else negate_1=$negate_0 fi
if narg($22) normalize_1=$22         else normalize_1=$normalize_0 fi
if narg($23) modulo_method_2={$23%4} else modulo_method_2=$modulo_method_1 fi
if narg($24) modvalue_a_2={abs($24)} else modvalue_a_2=$modvalue_a_1 fi
if narg($25) modvalue_b_2={abs($25)} else modvalue_b_2=$modvalue_b_1 fi
if narg($26) angle_2=$26             else angle_2=$angle_1 fi
if narg($27) value_shift_2=$27       else value_shift_2=$value_shift_1 fi
if narg($28) center_2=$28            else center_2=$center_1 fi
if narg($29) negate_2=$29            else negate_2=$negate_1 fi
if narg($30) normalize_2=$30         else normalize_2=$normalize_1 fi
if narg($31) modulo_method_3={$31%4} else modulo_method_3=$modulo_method_2 fi
if narg($32) modvalue_a_3={abs($32)} else modvalue_a_3=$modvalue_a_2 fi
if narg($33) modvalue_b_3={abs($33)} else modvalue_b_3=$modvalue_b_2 fi
if narg($34) angle_3=$34             else angle_3=$angle_2 fi
if narg($35) value_shift_3=$35       else value_shift_3=$value_shift_2 fi
if narg($36) center_3=$36            else center_3=$center_2 fi
if narg($37) negate_3=$37            else negate_3=$negate_2 fi
if narg($38) normalize_3=$38         else normalize_3=$normalize_2 fi
modnum_0={min($modvalue_a_0,$modvalue_b_0)}
modnum_1={min($modvalue_a_1,$modvalue_b_1)}
modnum_2={min($modvalue_a_2,$modvalue_b_2)}
modnum_3={min($modvalue_a_3,$modvalue_b_3)}
maxmodnum_0={max($modvalue_a_0,$modvalue_b_0)}
maxmodnum_1={max($modvalue_a_1,$modvalue_b_1)}
maxmodnum_2={max($modvalue_a_2,$modvalue_b_2)}
maxmodnum_3={max($modvalue_a_3,$modvalue_b_3)}

check "$maxmodnum_0>1||$maxmodnum_1>1||$maxmodnum_2>1||$maxmodnum_3>1"

flip_diag={$4%2}
sublevel={abs($5)+1}
interpolation={max(1,abs($6)+(abs($6)>3?1))}

cs={$1%15}
kalp={$2||$cs==3}

if $cs bwd_cs=${arg\ $cs,ryb2rgb,cmy2rgb,cmyk2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,ycbcr2rgb,ycbcrglic2rgb,xyz82rgb,yes82rgb} fi

if $flip_diag d_a=2 d_b=3
else  d_b=3 d_a=2
fi

if $kalp
 channel_ord=[{([0,1,2,3,0,1,3,2,0,2,1,3,0,2,3,1,0,3,1,2,0,3,2,1,1,0,2,3,1,0,3,2,1,2,0,3,1,2,3,0,1,3,0,2,1,3,2,0,2,0,1,3,2,0,3,1,2,1,0,3,2,1,3,0,2,3,0,1,2,3,1,0,3,0,1,2,3,0,2,1,3,1,0,2,3,1,2,0,3,2,0,1,3,2,1,0])[($3%24)*4,4]}]
else
 channel_ord=[{([0,1,2,0,2,1,1,0,2,1,2,0,2,0,1,2,1,0])[($3%6)*3,3]}]
fi

ts={size($channel_ord)}

m "axis_func: f \"begin(
  const ww=w-1;
  const hh=h-1;
  const cx=ww/2;
  const cy=hh/2;
  const ang=$""1°;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  const axis_mode=$""2;
  const sublevel=$""3;
  const value_shift=$""5*($""6?1:-1);
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  $""4?(
   calc_ix(a)=($""6?ww-a:a)-cx+value_shift;
   calc_iy(a)=($""6?hh-a:a)-cy+value_shift;
  ):(
   calc_ix(a)=x+value_shift;
   calc_iy(a)=y+value_shift;
  );
  axis_mode?(
   surface()=rot_x(ix,iy);
  ):(
   surface()=rot_y(ix,iy);
  );
 );
 ix=calc_ix(x);
 iy=calc_iy(y);
 surface=surface()/sublevel;\""
 
m "diagonal_func: f \"begin(
  const ww=w-1;
  const hh=h-1;
  const cx=ww/2;
  const cy=hh/2;
  const ang=$""1°;
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  const diag_mode=$""2;
  const sublevel=$""3;
  rot_x(a,b)=a*cos_ang-b*sin_ang;
  rot_y(a,b)=a*sin_ang+b*cos_ang;
  $""4?(
   calc_ix(a)=a-cx;
   calc_iy(a)=a-cy;
  ):(
   calc_ix(a)=x;
   calc_iy(a)=y;
  );
  diag_mode?(
   mod_base(a,b)=abs(abs(a)-abs(b));
  ):(
   mod_base(a,b)=abs(abs(a)+abs(b));
  );
 );
 ix=calc_ix(x);
 iy=calc_iy(y);
 xx=rot_x(ix,iy);
 yy=rot_y(ix,iy);
 mod_base(xx,yy)/sublevel;\"
 +. $""5"

repeat $! l[$>]

 ow={w}
 oh={h}
 
 {w*$sublevel},{h*$sublevel},1,$ts rm..
 
 repeat $ts
 
  pos={($channel_ord)[$>]}
  sh. $pos

  if !($>>=2)
   axis_func. ${angle_$>},$>,$sublevel,${center_$>},${value_shift_$>},${negate_$>}
  else
   if $flip_diag diagonal_func. ${angle_$>},{$>%2},$sublevel,${center_$>},${value_shift_$>}
   else diagonal_func. ${angle_$>},{$>%2+1},$sublevel,${center_$>},${value_shift_$>}
   fi
  fi

  modf. ${modulo_method_$>},${maxmodnum_$>},{(${maxmodnum_$>}-${modnum_$>})/${maxmodnum_$>}}
  
  if ${normalize_$>} /. {${maxmodnum_$>}/255} fi
  if ${negate_$>} f. max(iM#-1,255)-i fi
  
  rm.
  
 done
 
 if $cs $bwd_cs fi
 
 if $sublevel r $ow,$oh,1,100%,$interpolation fi
endl done

um diagonal_func,axis_func
#@cli rep_shape_brick: brick_width>0,brick_height>0,_mortar_width>0,_mortar_height>0,_outline>=0,_bevel>=0,_bevel_style= { 0=round | 1=inverse_round | 2=diamond },-1>=_shift_val>=1,_shift_direction= { 0=horizontal | 1=vertical },_flip_offset= { 0= Do Not Flip | 1= Flip },_subpixel_processing_level>=0
#@cli : 'brick_width' - Width of brick(s)
#@cli : 'brick_height' - Height of brick(s)
#@cli : '_mortar_width' - Filling width between brick(s)
#@cli : '_mortar_height' - Filling height between brick(s)
#@cli : '_outline' - Thickness of outline of brick(s)
#@cli : '_bevel' - Beveling of corners of brick(s)
#@cli : '_bevel_style' - Form of beveling of brick(s)
#@cli : '_shift_val' - Shift of bricks
#@cli : '_shift_direction' - Direction of shift
#@cli : '_flip_offset' - Determines which order the offset from original, to original.
#@cli : '_subpixel_level' - Degree of antialiasing of brick(s)\n
#@cli : Default values: '_mortar_width','_mortar_height','_outline'\n
#@cli : Author: Reptorian.
rep_shape_brick:
skip ${3=10},${4=10},${5=0},${6=0},${7=0},${8=1},${9=0},${10=0},${11=0}
v -
 sublevel={abs($11)}
 sublevel+=1
 brick_width={abs($1)*$sublevel}
 brick_height={abs($2)*$sublevel}
 mortar_width={abs($3)*$sublevel}
 mortar_height={abs($4)*$sublevel}
 outline={abs($5)*$sublevel}
 bevel={abs($6)*$sublevel}
 bevel_style={abs($7)>2?2:abs($7)}
 shift_val=$8
 shift_direction=$9
 flip_offset=$10

 if $bevel_style==2 brick_bevel_style="Diamond"
 elif $bevel_style==1 brick_bevel_style="Inverse-Round"
 else brick_bevel_style="Round"
 fi

 if $shift_direction dir="Every two column has displacement of"
 else dir="Every two row has displacement of"
 fi

 if abs($shift_val) no={$shift_val*100} offset=""$dir" "$no""%" from original point."
 else offset=""
 fi

 if $outline linethick={abs($5)} linethick=" with outline of "$linethick" px"
 else linethick=""
 fi
v +

e[] "Generate brick of "$brick_width" px and "$brick_height" px with mortar width of "$mortar_width" px and mortar height "$mortar_height" px"$linethick". "$offset""

v +

if !(($brick_width&&$brick_height)||$bevel) v + error "Brick Area must be greater than 0!" v - fi

if $bevel
 if $bevel_style==0||$bevel_style==1 shape_circle {$bevel*2}
 else shape_diamond {$bevel*2} fi
 *. 2
 if $outline
  if $bevel_style==0||$bevel_style==1 shape_circle {($bevel+$outline)*2}
  else shape_diamond {floor($bevel+($outline*(cos(45/180*pi)+sin(45/180*pi))))*2} r. {($bevel+$outline)*2},{($bevel+$outline)*2},100%,100%,0,0,.5,.5 fi
  j[-1] [-2],.5~,.5~,0,0,.5,[-2]
  rm..
 fi
 s. x,2
 s[-2,-1] y,2
fi

{$brick_width<$bevel*2?$bevel*2:$brick_width},{$brick_height<$bevel*2?$bevel*2:$brick_height},1,1,1

if $outline expand_xy. $outline,0 fi +. 1

if $bevel if $bevel_style==1 negate[-5--2] +f[-5--2] i==2?0:1 fi fi

if $bevel
 if $bevel_style==1
 j[-5] [-9],1~,1~,0,0,1,[-4]
 j[-5] [-8],1~,0~,0,0,1,[-3]
 j[-5] [-7],0~,1~,0,0,1,[-2]
 j[-5] [-6],0~,0~,0,0,1,[-1]
 rm[-4--1]
 else
 j[-1] [-5],0~,0~
 j[-1] [-4],0~,1~
 j[-1] [-3],1~,0~
 j[-1] [-2],1~,1~
 fi
 rm[-5--2]
fi

r. {w+$mortar_width},{h+$mortar_height},100%,100%,0,0,{!$flip_offset},{!$flip_offset}

if $shift_val
 if $shift_direction +shift. 0,{($shift_val/2)*100}%,0,0,2 a[-2,-1] x if $flip_offset mirror. x fi
 else +shift. {($shift_val/2)*100}%,0,0,0,2 a[-2,-1] y if $flip_offset mirror. y fi
 fi
fi

if $sublevel-1 r2dx. {(1/$sublevel)*100}%,5 fi

v -
#@cli rep_z_render: _reverse_z_layer={ 0=first_layer | last_layer },_z_depth_value>0,_mirror_order={ 0=do_not_mirror | 1=mirror },_color_z_render={ 0=image_z_per_luminosity | 1=image_z_per_channel }
#@cli : Generates the resulting image based on z-map layer.\n
#@cli : '_reverse_z_layer' determines whether the first or last layer should be used to determine the "frame" to use.
#@cli : '_z_depth_value' can be described as how smooth the transition between images should be
#@cli : '_mirror_order' can be used to reorder the image transition
#@cli : '_color_z_render' sets whether the transition are separated by channels or not.
#@cli : Note: Try to use gradient as the z-layer.\n
#@cli : Default values: '_reverse_layer=0','_z_depth_value=255','_mirror_order=0','_color_z_render=0'\n
#@cli : Author: Reptorian.
rep_z_render:
skip ${1=0},${2=255},${3=0},${4=0}
if $!<3 v + error "You need at least 3 images!" v - fi

if $1 rv[0,-1] rv[0,-2] fi

if !$4 to_gray[0] fi

rep_aspect_crop_2d[^0] {w#0},{h#0}

r[^0] {w#0},{h#0},100%,100%,3
a[^0] z
n[0] 0,$2
r[^0] 100%,100%,$2,100%,3

if $3 negate[0] fi

r[0] 100%,100%,100%,{s#-1}
f[0] i(#-1,x,y,i,c,3,1)
k[0]
#@cli rep_acb: (eq. to rep_autofill_coloring_book)
rep_acb: rep_autofill_coloring_book $*
#@cli rep_autofill_coloring_book: 0<threshold<1,_dilate_erode>=0,_color_mode={ 0=hard | 1= soft },0<=_alpha_threshold<1,_seed
#@cli : rep_autofill_coloring_book is used for automatically coloring pictures with lines.\n
#@cli : _threshold defines the value that is to be split into binary values. If it over _threshold, then it becomes 1.
#@cli : _dilate_erode defines the increase/decrease in line. Values over 0 implies increase in thickness while values less than 1 implies decrease in thickness.
#@cli : _color_mode defines whether the black line is going to be black or smooth.
#@cli : _alpha threshold defines the value of alpha to be cutoff by percentage
#@cli : _seed can be seen as premade random result.\n
#@cli : Default values: '_threshold=128','_dilate_erode=0','_color_mode=1','_alpha_threshold=0','_seed='
rep_autofill_coloring_book:
skip ${2=0},${3=1},${4=0},${5=}
if narg($5) srand $5 fi

repeat $! l[$>]
 sh 0,2
 if s#0==4 sh.. {s} vv={iv#-1} fi
 rep_acb_color[1] ${1-3}

 if s#0==4
  if ($4>0&&$4<1)&&$vv f. i>(iM*$4)?255:0 fi
 fi

 k[0]
endl done

rep_acb_color:
if $1<=0 v + error "threshold must be greater than 0" v - fi
if $1>=1 v + error "threshold must be less than 1" v - fi

to_gray n 0,1

if !iv#-1 v + error "Invalid Image!" v - fi
if $3 +store line fi

f i>=$1?1:0

if abs($2)
 if $2<0 dilate {abs($2)}
 else erode {abs($2)}
 fi
fi

label_fg 0,1

cv={iM}
min_t=1
max_t={round(16777215/$cv)}
nt={$min_t}
ntt={$max_t}

1

repeat $cv
 1,1,1,1,round(u($nt,$ntt))
 nt={iM#-1+1}
 ntt={$nt+$max_t}
 a[-2,-1] x
done

repeat $cv
 temp_1={i(round(u(1,$cv)))}
 temp_2={i(round(u(1,$cv)))}
 if $temp_1!=$temp_2
  f. i==$temp_1?$temp_2:(i==$temp_2?$temp_1:i)
 fi
done

{w},1,1,3,[i0#-1%256,floor(i0#-1/256)%256,floor(i0#-1/(256^2))]

map... . rm[-2,-1]

if $3
 +select_color 0,0,0
 inpaint_pde [1],0,0,0
 rm.
 $line
 f.. i*i0#-1
 rm.
fi

#@cli rep_recc: eq. to 'rep_reverse_engineer_color_curves'. : (+)
rep_recc: rep_reverse_engineer_color_curves $*
#@cli rep_reverse_engineer_color_curves: _array_size>0
#@cli : Automatically reverse engineer color curves. All images after [0] will be converted into color curve map while [0] is the reference image.
#@cli : (eq. to 'rep_recc').
#@cli : '_array_size' is used to define the depth of gradient map, if you're using float, then you need to scale image to something higher than 256. If array size is not inserted, then this filter will automatically find the array size.
#@cli : Default values: '_array_size=n/a'
#@cli :
#@cli : Author: Reptorian.
rep_reverse_engineer_color_curves:
skip ${1=}

if !$!>1 error n(imgs)>2==F fi

ww={w#0}
hh={h#0}
dd={d#0}
ss={s#0}

if narg($1)
 if im#0<0 mv={abs(im#0)+abs($1)} -[0] {im#0}
 else mv={abs($1)} fi
else
 if im#0<0 -[0] {im#0} fi
 mv={iM#0}
fi

store[0] refimg

repeat $!,img_id
 pos={$img_id+1}
 if w#$img_id!=$ww||h#$img_id!=$hh||d#$img_id!=$dd||s#$img_id!=$ss error dims(#$pos)!=dims(ref) fi
done

repeat $! l[$>]
 $refimg
 _rep_recc[0,-1] $mv
endl done

_rep_recc:
rv
$1,1,1,100% .
repeat s
 sh $>
 rm[-4--1]
 f[-4] i(#-2,i,0,0)+=i#-3-i#-4;i(#-1,i,0,0)+=1;i
done
+eq. 0
+.. .
/... ..
rm..
repeat s
 sh.. $>
 sh.. $>
 inpaint_pde.. .
 rm[-2,-1]
done
f.. i+x
cut.. 0,{$1-1}
k..
#@cli rep_regm: eq. to 'rep_reverse_engineer_gradient_map'. : (+)
rep_regm: rep_reverse_engineer_gradient_map $*
#@cli rep_reverse_engineer_gradient_map: _array_size>0,_norm={ 0=do_not_norm | 1=norm }
#@cli : Automatically reverse engineer gradient map. All images after [0] will be converted into gradient map while [0] is the gray reference.
#@cli : (eq. to 'rep_regm').
#@cli : '_array_size' is used to define the depth of gradient map, if you're using float, then you need to scale image to something higher than 256. If array size is not inserted, then this filter will automatically find the array size.
#@cli : '_normalize' is used to normalize image to max array id number. Useful when using float as reference.
#@cli : Default values: '_array_size=n/a','_normalize=0'
#@cli :
#@cli : Author: Reptorian, Garagecoder.
rep_reverse_engineer_gradient_map:
skip ${1=},${2=0}

if !$!>1 error n(imgs)>2==F fi

ww={w#0}
hh={h#0}
dd={d#0}

if s#0==2 s[0] c rm[1]
elif s#0==3 to_rgb[0] rgb2hsl8[0] channels[0] 2
elif s#0==4 s[0] c,-3 to_rgb[0] rm[1] rgb2hsl8[0] channels[0] 2
fi

if narg($1)
 if im#0<0 mv={abs(im#0)+abs($1)} -[0] {im#0}
 else mv={abs($1)} fi
else
 if im#0<0 -[0] {im#0} fi
 mv={iM#0}
fi

if $2&&narg($1) n[0] 0,{$mv-1} fi

store[0] refimg

repeat $!
 pos={$>+1}
 if w#$>!=$ww||h#$>!=$hh||d#$>!=$dd error dims(#$pos)!=dims(ref) fi
done

repeat $! l[$>]
 $refimg
 gcd_regm[0,-1] $mv
endl done

gcd_regm:
rv
round.. 1
$1,1,1,{s#-1}
f[0] "I[#-1,i]+=I(#1,x,y,z);i"
+histogram[0] $1,0,$1
+eq. 0
add[-2] [-1]
div[-3,-2]
inpaint_pde.. .
rm[-4,-3,-1]
#@cli rep_primelist:
#@cli : Return vector of boolean values up to the maximum image value rounded. Values are found by whether the argument number within vector is a prime.
rep_primelist:
maxn=0
repeat $! maxn={ceil(max($maxn,max(abs(im#$>),iM#$>)))} done
u {"
const mv="$maxn";
prime=vectormv(1);
prime[0]=prime[1]=0;
for(p=2,sqr(p)<=mv,p++,
 if(prime[p],
  for(v=sqr(p),v<=mv,v+=p,
   prime[v]=0;
  );
 );
);
(prime)
"}
#@cli rep_isprime:
#@cli : Values of image are changed to either 1 or 0 depending on the value is a prime number.
rep_isprime:
f "begin(prime=["${-rep_primelist}"];);
 prime[round(abs(i))];"
#@cli rep_prime_surface: _width,_height,_negate= { 0=do_not_negate | 1=negate },_mirror
#@cli : Creates a simple prime surface by combining rep_primelist and spiralbw.
#@cli : Default values: '_width=last_image_width','_height=last_image_height'
rep_prime_surface:
skip ${1=w},${2=h},${3=1},${4=0}
spiralbw {abs($1)},{abs($2)}
l.
 if $3 negate. fi
 if abs($4)==1 mirror. x
 elif abs($4)==2 mirror. y
 fi
 f "begin(prime=["${-rep_primelist}"];);
 prime[round(abs(i))];
 "
endl
#@cli rep_ced8: eq. to 'rep_color_existence_distribution_rgb8'. : (+)
rep_ced8: rep_color_existence_distribution_rgb8 $*
#@cli rep_color_existence_distribution_rgb8: _bool_found= { 0=colour_nonexistence | colour_existence }
#@cli : This cli command is used to find which colors exist within the color lookup table generated from 8-bit positive-only colors that ranges from 0-255. Millions of colors that does not exist within a image can be picked from a image generated with this command.
#@cli : (eq. to 'rep_ced8').\n
#@cli : Author: Reptorian.
rep_color_existence_distribution_rgb8:
nk=$1
nk_1={$nk?255:0}
nk_2={$nk?0:255}
repeat $! l[$>]
 256,256,256 eval.. "++i(#-1,R,G,B)" k.
 4096,4096,1,4,[x%256,y%256,floor(x/256)+(floor(y/256)*16),i(#-1,x%256,y%256,floor(x/256)+(floor(y/256)*16))?$nk_1:$nk_2] k.
endl done
#@cli rep_sdaxy: eq. to 'rep_shift_distance_angle_xy'. : (+)
rep_sdaxy: rep_shift_distance_angle_xy $*
#@cli rep_shift_distance_angle_xy: _offset>0,_angle,_boundary_condition={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_interpolation={ 0=nearest_neighbor | 1=linear }
#@cli : Offset images at angle and distance.
#@cli : (eq. to 'rep_sdaxy').\n
#@cli : _offset refers to the displacement of image.\n
#@cli : Default value: 'boundary_condition=3','interpolation=1'\n
#@cli : Author: Reptorian.
rep_shift_distance_angle_xy:
skip ${3=3},${4=1}
rad_ang={$2/180*pi}
shift {cos($rad_ang)*$1},{sin($rad_ang)*$1},0,0,$3,$4
#@cli rep_dupsdaxy: eq. to 'rep_duplicate_by_shift_distance_angle_xy'. : (+)
rep_dupsdaxy: rep_duplicate_by_shift_distance_angle_xy $*
#@cli rep_duplicate_by_shift_distance_angle_xy: duplicates_count>=2,_radius_offset>0,_offset_angle,_keep_original={ 0=remove_original | 1=keep_original },_boundary_condition={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_interpolation={ 0=nearest_neighbor | 1=linear }
#@cli : Creates copies of image at a distance from original point.
#@cli : (eq. to 'rep_dupsdaxy').\n
#@cli : _radius_offset refers to the distance the duplicates are from the original image. Each circular duplicates are of the same distance. radius_offset can be in percentage form, or in integer form. When it is in percentage form, the length of each duplicates offset is equal to the percentage of diagonal of image.
#@cli : _offset_angle refers to the starting angle the original duplicate is at. The primary duplicate starts from the right.\n
#@cli : Default value: '_radius_offset={sqrt(w^2+h^2)*.05}','_offset_angle=0','_keep_original=0','_boundary_condition=0','_interpolation=1'\n
#@cli : Author: Reptorian.
rep_duplicate_by_shift_distance_angle_xy:
skip ${2={norm(w,h)*.05}},${3=0},${4=0},${5=1},${6=1}
if $1<2 v + error "Invalid duplicate numbers!" fi
aang={360/$1}
repeat $1 +rep_shift_distance_angle_xy[0] $2,{$>*$aang+$3},$5,$6 done if !$4 rm[0] fi
#@cli rep_frblur: eq. to 'rep_fragment_blur'. : (+)
rep_frblur: rep_fragment_blur $*
#@cli rep_fragment_blur: duplicates_count>=2,_radius_offset>0,_offset_angle,_keep_original={ 0=remove_original | 1=keep_original },_boundary_condition={ 0=None | 1=Neumann | 2=Periodic | 3=Mirror },_interpolation={ 0=nearest_neighbor | 1=linear },_color_space={ 0=RGB | 1=SRGB | 2=RYB | 3=CMYK | 4=HCY | 5=HSI | 6=HSL | 7=HSV | 8=LAB | 9=LCH }
#@cli : Fragment Blur is a effect that originated from the Windows software named Paint.NET. Copies or "fragments" of images are superimposed over their respective images. Copies are redrawn at a distance, and starting copy starts from the right at 0.
#@cli : (eq. to 'rep_frblur').\n
#@cli : _radius_offset refers to the distance the duplicates are from the original image. Each circular duplicates are of the same distance. radius_offset can be in percentage form, or in integer form. When it is in percentage form, the length of each duplicates offset is equal to the percentage of diagonal of image.
#@cli : _offset_angle refers to the starting angle the original duplicate is at. The primary duplicate starts from the right.
#@cli : _keep_original options is to keep the original image as a duplicate without offsetting it.\n
#@cli : Default values: '_radius_offset=5%','_offset_angle=0','_keep_original=0','_boundary_condition=1','_interpolation=1','_color_space=0'\n
#@cli : Author: Reptorian.
rep_fragment_blur:
skip ${2=5%},${3=0},${4=0},${5=1},${6=0},${7=0}

convert_colors_fwd=${arg\ 1+$7,,rgb2srgb,rgb2ryb,,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch}
convert_colors_bwd=${arg\ 1+$7,,srgb2rgb,ryb2rgb,,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb}

_frblur_iter_ang,_frblur_shift_ang,_ti,_frblur_dist={(2*pi)/$1},{deg2rad($3)},{abs($1)+($4?1)},1

if $6

 m "rep_frblur_sdaxy_add :
  100%,100%,100%,100% .
  
  $1,1,1,2,\"begin(
    const iter_ang=$_frblur_iter_ang;
    const shift_ang=$_frblur_shift_ang;   
   );
   [cos(x*iter_ang+shift_ang)*$""1,sin(x*iter_ang+shift_ang)*$""1];\"
  
  repeat $1
   j.. [0]
   shift.. {I(#-1,$>)},0,0,$5,1
   add... ..
  done
  
  if $4 k[0,-3] add else k... fi"
  
else
 if $5 # Boundary
 
  m "rep_frblur_sdaxy_add :
   dist={ceil($""1)}
   
   100%,100%,100%,100%
   
   +expand_xy[0] $dist,$5
   
   $1,1,1,2,\"begin(
     const offset=$dist;
     const iter_ang=$_frblur_iter_ang;
     const shift_ang=$_frblur_shift_ang;
    );
    [round(cos(x*iter_ang+shift_ang)*$""1-offset),round(sin(x*iter_ang+shift_ang)*$""1-offset)];\"
    
   repeat $1
    j[1] [-2],{I(#-1,$>)},0,0,-1
   done

   if $4 k[0,1] add else k[1] fi"
   
 else # No Boundary

  m "rep_frblur_sdaxy_add :
   100%,100%,100%,100%
   
   $1,1,1,2,\"begin(
     const iter_ang=$_frblur_iter_ang;
     const shift_ang=$_frblur_shift_ang;
    );
    [round(cos(x*iter_ang+shift_ang)*$""1),round(sin(x*iter_ang+shift_ang)*$""1)];\"
    
   repeat $1
    j[1] [0],{I(#-1,$>)},0,0,-1
   done
   
   if $4 k[0,1] add else k[1] fi"
   
 fi
fi

m "rep_frblur_alp :
 sh 0,{s-2} sh.. {s} maxa={iM#-1} /. $maxa *.. . rm[-2,-1]
 rep_frblur_sdaxy_add $""1
 sh 0,{s-2} sh.. {s} f.. I/(i0#-1?i0#-1:1) *. {$maxa/iM#-1} rm[-2,-1]"
 
m "rep_frblur_nalp : rep_frblur_sdaxy_add $""1 / $_ti"

repeat $! l[$>]
 if ${is_percent\ $2} dist={abs($2)*norm(w,h)/2}
 else dist={abs($2)} fi
 
 tcr,convert_back=3,0
 
 if (s==3||s==4)&&$7
  convert_back=1
  if $7!=3
   $convert_colors_fwd.
  else
   if s==3 tcr+=1 rgb2cmyk
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
  fi
 fi
 
 if !(s==1||s==$tcr)
  rep_frblur_alp $dist
 else
  rep_frblur_nalp $dist
 fi
 
 if $convert_back
  if $7!=3
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 fi
 
endl done

um rep_frblur_sdaxy_add,rep_frblur_alp,rep_frblur_nalp
#@cli rep_ncee: _distance>0,0<=_angle<=360,boundary_condition={ 0=none | 1=neumann | 2=periodic | 3=mirror },_interpolation={ 0=nearest_neighbor | 1=linear },_contrast>=0,_process_alpha={ 0=do_not_process_alpha | 1=process_alpha },_color_space,_blend_mode,0<=_blend_opacity[%]<=1
#@cli : Default value: 'boundary_condition=3','interpolation=1','contrast=1','process_alpha=1','color_space=0','blend_mode=1','blend_opacity=100%'\n
#@cli : Author: Reptorian.
rep_ncee:
skip ${3=3},${4=1},${5=1},${6=1},${7=0},${8=1},${9=1}

convert_colors_fwd=${arg\ $7+1,,rgb2ryb,rgb2cmy,rgb2cmyk,rgb2hsi8,rgb2hsl8,rgb2hsv8,rgb2lab8,rgb2lch8,rgb2yiq8,rgb2yuv8,rgb2xyz8,rgb2yes8,rgb2k18,rgb2ohta8}
convert_colors_bwd=${arg\ $7+1,,ryb2rgb,cmy2rgb,cmyk2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,xyz82rgb,yes82rgb,k182rgb,ohta82rgb}

-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"

to_a

split_opacity

l[0]
$convert_colors_fwd
[0] l[1]
rep_dupsdaxy 2,$1,$2,0,$3,$4 tci={$!} f. "255-i"  add / $tci - 127.5 * {2*$5} + 127.5 cut 0,255
endl
if $7!=3
blend ${_mode{$8+1}},$9
$convert_colors_bwd
elif $7==3
s c repeat 4 l[$>,{$!-1}] to_rgb blend ${_mode{$8+1}},$9 endl done a c cmyk2rgb
fi
endl
l[1]
if $6 rep_dupsdaxy 0,2,$1,$2,$3,$4 tai={$!} add / $tai fi
endl a c
#@cli +pal: 0<="palette_id"<=223
#@cli : Inserts pre-made user-made palette or palette that are based off older consoles or software.\n
#@cli : - The following list contains valid inputs directly next to their name, but anything after dashes is only for information purpose. Equal sign means that the commands are identical. -\n
#@cli : +pal 0 = +pal bw -- Black & White
#@cli : +pal 1 = +pal rgb -- Red-Green-Blue
#@cli : +pal 2 = +pal b_rgb -- Black w/ Red-Green-Blue
#@cli : +pal 3 = +pal bw_rgb -- Black & White w/ Red-Green-Blue
#@cli : +pal 4 = +pal cmy -- Cyan-Magenta-Yellow
#@cli : +pal 5 = +pal cmyk -- Cyan-Magenta-Yellow-Black
#@cli : +pal 6 = +pal wcmyk -- White-Cyan-Magenta-Yellow-Black
#@cli : +pal 7 = +pal rgbcmy -- Red-Green-Blue w/ Cyan-Magenta-Yellow
#@cli : +pal 8 = +pal 1bitrgb -- 1 BPC RGB
#@cli : +pal 9 = +pal aurora -- Aurora by GrafxKid
#@cli : +pal 10 = +pal playpal -- PLAYPAL by id Tech 1/DOOM Engine
#@cli : +pal 11 = +pal srb2 -- Sonic Robo Blast 2
#@cli : +pal 12 = +pal famicube -- Famicube by Arne
#@cli : +pal 13 = +pal kens16 -- Andrew Kensler - 16 by Andrew Kensler
#@cli : +pal 14 = +pal kens32 -- Andrew Kensler - 32 by Andrew Kensler
#@cli : +pal 15 = +pal kens54 -- Andrew Kensler - 54 by Andrew Kensler
#@cli : +pal 16 = +pal aap12 -- AAP-Micro 12 by Adigun A. Polack
#@cli : +pal 17 = +pal aap16 -- AAP-16 by Adigun A. Polack
#@cli : +pal 18 = +pal aap64 -- AAP-64 by Adigun A. Polack
#@cli : +pal 19 = +pal aap128 -- AAP-SPLENDOR128 by Adigun A. Polack
#@cli : +pal 20 = +pal db8 -- DB8 by DawnBringer
#@cli : +pal 21 = +pal db16 -- DB16 by DawnBringer
#@cli : +pal 22 = +pal db32 -- DB32 by DawnBringer
#@cli : +pal 23 = +pal db_iso22 -- DB-ISO22 by DawnBringer
#@cli : +pal 24 = +pal dimwid17 -- DimWiddy 17 by DimWiddy
#@cli : +pal 25 = +pal dimwid23 -- DimWiddy 23 by DimWiddy
#@cli : +pal 26 = +pal edg4 -- Endesga-4 by Endesga
#@cli : +pal 27 = +pal edg8 -- Endesga-8 by Endesga
#@cli : +pal 28 = +pal edg16 -- Endesga-16 by Endesga
#@cli : +pal 29 = +pal edg32 -- Endesga-32 by Endesga
#@cli : +pal 30 = +pal edg36 -- Endesga-36 by Endesga
#@cli : +pal 31 = +pal edg64 -- Endesga-64 by Endesga
#@cli : +pal 32 = +pal juicy32 -- Juicy-32 by Real Juice
#@cli : +pal 33 = +pal juicy56 -- Juicy-56 by Real Juice
#@cli : +pal 34 = +pal xaiue -- XAIUE-22 by xaiue
#@cli : +pal 35 = +pal 15pdx -- 15P-DX by GrafxKid
#@cli : +pal 36 = +pal 20pdx -- 20P-DX by GrafxKid
#@cli : +pal 37 = +pal 24pdx -- 24P-DX by GrafxKid
#@cli : +pal 38 = +pal cabana64 -- Cabana-64 by Crabby
#@cli : +pal 39 = +pal fant16 -- Fantasy 16 by Brettybooop
#@cli : +pal 40 = +pal fant24 -- Fantasy 24 by Gabriel C.
#@cli : +pal 41 = +pal tf23 -- Tranquil Fantasy 23 by windfall.apples
#@cli : +pal 42 = +pal tfp39 -- Tranquility Plus 39 by windfall.apples
#@cli : +pal 43 = +pal faraway48 -- Faraway 48 by Igor Ferreira.
#@cli : +pal 44 = +pal fleja_m -- Fleja Master Palette by Fleja
#@cli : +pal 45 = +pal koni 32 -- Koni32 by Konic
#@cli : +pal 46 = +pal linearbasic -- Linear Color Palette Basic by GrafxKid
#@cli : +pal 47 = +pal vinelinear -- Vines Flexible Linear Ramps by Vine 2D
#@cli : +pal 48 = +pal arcade29 -- Arcade Standard 29 by GrafxKid
#@cli : +pal 49 = +pal arq16 -- ARQ16 by Endesga
#@cli : +pal 50 = +pal blk36 -- BLK 36 by BlackedIRL.
#@cli : +pal 51 = +pal blkneo -- BLK-NEO by BlackedIRL.
#@cli : +pal 52 = +pal brokefac -- Broken Facility by u/telepathic-melon
#@cli : +pal 53 = +pal bubblegum -- Bubblegum-16 by PineTreePizza
#@cli : +pal 54 = +pal cade15 -- Cade 15 by MonstersGoBoom
#@cli : +pal 55 = +pal calder8 -- Calder 8 by Philip Dodderige
#@cli : +pal 56 = +pal chrom16 -- Chromatic16 by DragonDePlatino
#@cli : +pal 57 = +pal cdbac -- CD-BAC by DimWiddy
#@cli : +pal 58 = +pal cgarne -- CG Arne by Arne Niklas Jansson
#@cli : +pal 59 = +pal cpcboy -- CPC BOY by Arne Niklas Jansson
#@cli : +pal 60 = +pal dino -- Dinoknight 16 by Retrospec
#@cli : +pal 61 = +pal 4l -- ||||-22 by ||||
#@cli : +pal 62 = +pal ftzeth16 -- FZT Ethereal 16 by Fusionnist
#@cli : +pal 63 = +pal gzxp -- GZXP by GrafxKid
#@cli : +pal 64 = +pal indc -- Indecision by Nelson SMG
#@cli : +pal 65 = +pal island16 -- Island Joy 16 by Kerrie Lake
#@cli : +pal 66 = +pal journey -- Journey by PineTreePizza
#@cli : +pal 67 = +pal juicy -- Juicy 17 by JerryPie
#@cli : +pal 68 = +pal oak -- Oak21 by Dan Oak
#@cli : +pal 69 = +pal nature55 -- Nature's Embrace 55 by GrafxKid
#@cli : +pal 70 = +pal nauris16 -- Nauris-16 by Nauris
#@cli : +pal 71 = +pal pear36 -- Pear 36 by PineTreePizza
#@cli : +pal 72 = +pal peach -- Peachy Pop 16 by Kerrie Lake
#@cli : +pal 73 = +pal pineapple32 -- Pineapple 32 by PineTreePizza
#@cli : +pal 74 = +pal resurrect -- Resurrect 32 by Kerrie Lake
#@cli : +pal 75 = +pal rosy42 -- Rosy 42 by PineTreePizza
#@cli : +pal 76 = +pal slso -- SLSO-CLR17 by Luis Miguel Maldonado
#@cli : +pal 77 = +pal softy15 -- Softy 15 by Eggy
#@cli : +pal 78 = +pal spec12 -- SPEC12 by Smalls
#@cli : +pal 79 = +pal starmancer -- Starmancer by Ominux Games
#@cli : +pal 80 = +pal sup8 -- Superb 8 by BigPotato
#@cli : +pal 81 = +pal superfuture -- SuperFuture25 by Endesga
#@cli : +pal 82 = +pal sweetie16 -- Sweetie 16 by GrafxKid
#@cli : +pal 83 = +pal taffy16 -- Taffy 16 by PineTreePizza
#@cli : +pal 84 = +pal todayland -- Todayland Palette V2 by GrafxKid
#@cli : +pal 85 = +pal vivid17 -- Vivid-17 by Irenaart
#@cli : +pal 86 = +pal voodo -- Voodo34 by Shamaboy
#@cli : +pal 87 = +pal zu32 -- Zughy 32 by Zughy
#@cli : +pal 88 = +pal enos16 -- ENOS16 by Endesga
#@cli : +pal 89 = +pal undertones -- Undertones-17 by Irenaart
#@cli : +pal 90 = +pal equpix15 -- Equpix 15 by Night
#@cli : +pal 91 = +pal night16 -- Night 16 by Night
#@cli : +pal 92 = +pal star29 -- Star 29 by Starlane
#@cli : +pal 93 = +pal star34 -- Star 34 by Starlane
#@cli : +pal 94 = +pal stilllife -- Still-Life by cure
#@cli : +pal 95 = +pal simjpc16 -- SimpleJPC-16 by Adigun A. Polack
#@cli : +pal 96 = +pal acid15 -- Acid 15 by pyrometal
#@cli : +pal 97 = +pal battery24 -- Battery 24 by Battery Jellyfish
#@cli : +pal 98 = +pal clump18 -- Clumpy 18 by windfall.apples
#@cli : +pal 99 = +pal cthul -- Cthulhu by Starlane
#@cli : +pal 100 = +pal crimso11 -- Crimso 11 by Crimso
#@cli : +pal 101 = +pal coptec -- Copper-Tech by Arne Niklas Jansson
#@cli : +pal 102 = +pal drz15 -- DRZ15A by Drazille
#@cli : +pal 103 = +pal eggy15 -- Eggy 15 by Eggy
#@cli : +pal 104 = +pal eroge -- Eroge-Copper by Arne Niklas Jansson
#@cli : +pal 105 = +pal europa -- Europa 16 by Starlane
#@cli : +pal 106 = +pal greyt -- GreyT-bit by Sam Keddy
#@cli : +pal 107 = +pal jewel -- Jewel by AprilSundae
#@cli : +pal 108 = +pal polar11 -- Polar 11 by Smalls
#@cli : +pal 109 = +pal sheltzy -- Sheltzy 32 by Please Check - NatTorpedia
#@cli : +pal 110 = +pal rube-goldberg -- Rube-Goldberg
#@cli : +pal 111 = +pal boomboom -- BoomBoom by Salman_Shh
#@cli : +pal 112 = +pal g8 -- Generic-8 by GrafxKid
#@cli : +pal 113 = +pal matriax8c -- Matriax8c by Davit Masia
#@cli : +pal 114 = +pal nt1h -- NT1H by NatTorpedia
#@cli : +pal 115 = +pal au15 -- Autum 15 by jok
#@cli : +pal 116 = +pal au15y -- Autum 15 [Yellow] by jok
#@cli : +pal 117 = +pal jerrypie22 -- JerryPie 22 by JerryPie
#@cli : +pal 118 = +pal naji16 -- Naji 16 by Naji
#@cli : +pal 119 = +pal blessing -- Blessing by Maruki
#@cli : +pal 120 = +pal crayola -- Crayola Blind
#@cli : +pal 121 = +pal easter -- Easter Island by skamocore
#@cli : +pal 122 = +pal fairy -- Fairy Tales by lollige
#@cli : +pal 123 = +pal fuzz4 -- Fuzzy Four by P-Tux7
#@cli : +pal 124 = +pal xdb_01 -- 0xdb-01 by 0xDB
#@cli : +pal 125 = +pal ocaso -- Ocaso by Minord
#@cli : +pal 126 = +pal pastel -- Oh Hell, Pastel by StarlitSunset
#@cli : +pal 127 = +pal pastel17 -- 17 Pastels by Irenaart
#@cli : +pal 128 = +pal pollen8 -- Pollen-8 by Conker
#@cli : +pal 129 = +pal nopal -- Nopal-12 by BlackedIRL.
#@cli : +pal 130 = +pal sy17 -- Sy17 by xaiue
#@cli : +pal 131 = +pal syz15 -- Syz15 by Fusionnist
#@cli : +pal 132 = +pal tui15 -- TUI-15 by Jeremy
#@cli : +pal 133 = +pal cave -- Cave by PineTreePizza
#@cli : +pal 134 = +pal psygnosia -- Psygnosia by Arne Niklas Jansson
#@cli : +pal 135 = +pal marshmellow32 -- MarshMellow32 by FormalPrejudice
#@cli : +pal 136 = +pal rabbit7 -- Rabbit 7 by GrafxKid
#@cli : +pal 137 = +pal finlal11 -- Finlal 11 by Finlal
#@cli : +pal 138 = +pal vinik24 -- Vinik 24 by Vinik
#@cli : +pal 139 = +pal ykb22 -- YKB-22 by yahkehbu
#@cli : +pal 140 = +pal graveyard -- Graveyard-21 by AprilSundae
#@cli : +pal 141 = +pal steamlords -- Steam Lords by Slynyrd
#@cli : +pal 142 = +pal aaprad -- AAP-RadiantXV by Adigun A. Polack
#@cli : +pal 143 = +pal aapmaj -- AAP-Majesty XVII by Adigun A. Polack
#@cli : +pal 144 = +pal daruda -- Daruda 22 by daruda
#@cli : +pal 145 = +pal rust6 -- Rust-6 by Blue Phoenix
#@cli : +pal 146 = +pal xaiue_rad -- XAIUE-Radiant by xaiue
#@cli : +pal 147 = +pal firestorm -- Firestorm by theartistjulian
#@cli : +pal 148 = +pal supernova7 -- SuperNova 7 by Blue Phoenix
#@cli : +pal 149 = +pal nyx8 -- NYX8 by Javier Guerrero
#@cli : +pal 150 = +pal oil6 -- OIL6 by GrafxKid
#@cli : +pal 151 = +pal sgm -- SGM-Palette 2 by s.g.m
#@cli : +pal 152 = +pal fornaxvoid1 -- Fornax Void I by Fornax Void
#@cli : +pal 153 = +pal fornaxvoid2 -- Fornax Void II by Fornax Void
#@cli : +pal 154 = +pal pixelwave -- Pixelwave by Reptorian
#@cli : +pal 155 = +pal spaceyeaster -- Spacey Easter by Spark Norris
#@cli : +pal 156 = +pal moon39 -- Moonlit-39 by theartistjulian
#@cli : +pal 157 = +pal pet8 -- Petite-8 by Adigun A. Polack
#@cli : +pal 158 = +pal pet8d -- Petite-8 Afterdark by Adigun A. Polack
#@cli : +pal 159 = +pal autochrome -- Autochrome 3 by Reptorian
#@cli : +pal 160 = +pal autochrome5 -- Autochrome 5 by Reptorian
#@cli : +pal 161 = +pal gb_d_1 -- GB Default #1
#@cli : +pal 162 = +pal gb_d_2 -- GB Default #2
#@cli : +pal 163 = +pal gb_andrade -- GB Andrade by Andrade
#@cli : +pal 164 = +pal gb_blue -- GB Blue Seni by WildLeoKnight
#@cli : +pal 165 = +pal gb_bz -- GB Blackzone
#@cli : +pal 166 = +pal gb_crimson -- GB Crimson by WildLeoKnight
#@cli : +pal 167 = +pal gb_didi -- GB Didi by DidiGameboy
#@cli : +pal 168 = +pal gb_dirty -- GB Dirty by WildLeoKnight
#@cli : +pal 169 = +pal gb_arne -- GB Arne by Arne
#@cli : +pal 170 = +pal gb_easy -- GB Easy by GrafxKid
#@cli : +pal 171 = +pal gb_forest -- GB Forest
#@cli : +pal 172 = +pal gb_hg -- GB Harsh Green by WildLeoKnight
#@cli : +pal 173 = +pal gb_lg -- GB Light Green by WildLeoKnight
#@cli : +pal 174 = +pal gb_nostalgia -- GB Nostalgia by WildLeoKnight
#@cli : +pal 175 = +pal gb_platinum -- GB Platinum by WildLeoKnight
#@cli : +pal 176 = +pal gb_kirokaze -- GB Kirokaze by Kirokaze
#@cli : +pal 177 = +pal gb_pj -- GB PJ
#@cli : +pal 178 = +pal gb_cyber -- GB Cyber
#@cli : +pal 179 = +pal gb_wish -- GB Wish by Kerrie Lake
#@cli : +pal 180 = +pal gb_grapefruit -- GB Grapefruit by GrafxKid
#@cli : +pal 181 = +pal gb_ice_cream -- GB Ice Cream by Kerrie Lake
#@cli : +pal 182 = +pal gb_rb -- GB Red_Blue
#@cli : +pal 183 = +pal gb_space -- GB Spacehaze by WildLeoKnight
#@cli : +pal 184 = +pal gb_choco -- GB Chocolate by GrafxKid
#@cli : +pal 185 = +pal gb_purpdawn -- GB Purple Dawn by WildLeoKnight
#@cli : +pal 186 = +pal gb_gray -- GB Gray by GrafxKid
#@cli : +pal 187 = +pal arne4 -- ARNE4 by Arne
#@cli : +pal 188 = +pal hal4 -- HallowPumpkin by WildLeoKnight
#@cli : +pal 189 = +pal amiga2600ntsc -- Amiga 2600 NTSC
#@cli : +pal 190 = +pal amiga2600pal -- Amiga 2600 PAL
#@cli : +pal 191 = +pal amiga2600secam -- Amiga 2600 SECAM
#@cli : +pal 192 = +pal amiga7800mess -- Amiga 7800 M.E.S.S by Nabuko78
#@cli : +pal 193 = +pal amiga7800 -- Amiga 7800
#@cli : +pal 194 = +pal amstrad_cpc -- Amstrad CPC
#@cli : +pal 195 = +pal apple2 -- Apple II
#@cli : +pal 196 = +pal cga -- CGA
#@cli : +pal 197 = +pal cga00 -- CGA Mode 0 [Low]
#@cli : +pal 198 = +pal cga01 -- CGA Mode 0 [High]
#@cli : +pal 199 = +pal cga10 -- CGA Mode 1 [Low]
#@cli : +pal 200 = +pal cga11 -- CGA Mode 1 [High]
#@cli : +pal 201 = +pal cga20 -- CGA Mode 2 [Low]
#@cli : +pal 202 = +pal cga21 -- CGA Mode 2 [High]
#@cli : +pal 203 = +pal c64_pepto -- Commodore 64 - https://www.pepto.de/projects/colorvic/2001/
#@cli : +pal 204 = +pal c64_colodore -- Commodore 64 - https://www.pepto.de/projects/colorvic/
#@cli : +pal 205 = +pal com_vic_20 -- Commodore VIC-20
#@cli : +pal 206 = +pal colecovision -- Colecovision
#@cli : +pal 207 = +pal jmp -- Japanese Machine Palette by Arne Niklas Jansson
#@cli : +pal 208 = +pal mac2 -- Macintosh II
#@cli : +pal 209 = +pal nes -- NES
#@cli : +pal 210 = +pal pico_8 -- PICO-8 by Lexaloffle Games
#@cli : +pal 211 = +pal risc -- RISC OS
#@cli : +pal 212 = +pal samcoupe -- SAM Coupe
#@cli : +pal 213 = +pal mo5 -- Thomson MO5
#@cli : +pal 214 = +pal vga -- VGA
#@cli : +pal 215 = +pal zx -- ZX Spectrum
#@cli : +pal 216 = +pal gnome32 -- GNOME 32
#@cli : +pal 217 = +pal elc22 -- Electronic Crayon 22
#@cli : +pal 218 = +pal chip16 -- Chip16
#@cli : +pal 219 = +pal msx -- MSX
#@cli : +pal 220 = +pal deluxepaint -- Deluxe Paint
#@cli : +pal 221 = +pal lms -- Legacy Paint
#@cli : +pal 222 = +pal msxp -- XP Paint
#@cli : +pal 223 = +pal vis -- Vista Paint\n
#@cli : Author: Reptorian.
+pal:
v - _gmic_s=$? v +
_$0 $*
+_pal:
$=val
repeat narg($*)
 mode=${val{$>+1}}
 if isnum($mode) if isint($mode)
 if $mode!=abs($mode) mode="i" else
 mode=${arg\ 1+$mode,bw,rgb,b_rgb,bw_rgb,cmy,cmyk,wcmyk,rgbcmy,1bitrgb,aurora,playpal,srb2,famicube,kens16,kens32,kens54,aap12,aap16,aap64,aap128,db8,db16,db32,db_iso22,dimwid17,dimwid23,edg4,edg8,edg16,edg32,edg36,edg64,juicy32,juicy56,xaiue,15pdx,20pdx,24pdx,cabana64,fant16,fant24,tf23,tfp39,faraway48,fleja_m,koni32,linearbasic,vinelinear,arcade29,arq16,blk36,blkneo,brokefac,bubblegum,cade15,calder8,chrom16,cdbac,cgarne,cpcboy,dino,4l,fzteth16,gzxp,indc,island16,journey,juice,oak,nature55,nauris16,pear36,peach,pineapple32,resurrect,rosy42,slso,softy15,spec12,starmancer,sup8,superfuture,sweetie16,taffy16,todayland,vivid17,voodo,zu32,enos16,undertones,equpix15,night16,star29,star34,stilllife,simjpc16,acid15,battery24,clump18,cthul,crimso11,coptec,drz15,eggy15,eroge,europa,greyt,jewel,polar11,sheltzy,rube_goldberg,boomboom,g8,matriax8c,nt1h,au15,au15y,jerrypie22,naji16,blessing,crayola,easter,fairy,fuzz4,xdb_01,ocaso,pastel,pastel17,pollen8,nopal,sy17,syz15,tui15,cave,psygnosia,marshmellow32,rabbit7,finlal11,vinik24,ykb22,graveyard,steamlords,aaprad,aapmaj,daruda,rust6,xaiue_rad,firestorm,supernova7,nyx8,oil6,sgm,fornaxvoid1,fornaxvoid2,pixelwave,spaceyeaster,moon39,pet8,pet8d,autochrome3,autochrome5,gb_d_1,gb_d_2,gb_andrade,gb_blue,gb_bz,gb_crimson,gb_didi,gb_dirty,gb_arne,gb_easy,gb_forest,gb_hg,gb_lg,gb_nostalgia,gb_platinum,gb_kirokaze,gb_pj,gb_cyber,gb_wish,gb_grapefruit,gb_ice_cream,gb_rb,gb_space,gb_choco,gb_purpdawn,gb_gray,arne4,hal4,amiga2600ntsc,amiga2600pal,amiga2600secam,amiga7800mess,amiga7800,amstrad_cpc,apple2,cga,cga00,cga01,cga10,cga11,cga20,cga21,c64_pepto,c64_colodore,com_vic_20,colecovision,jmp,mac2,nes,pico_8,risc,samcoupe,mo5,vga,zx,gnome32,elc22,chip16,msx,deluxepaint,lms,msxp,vis}
 fi fi fi
 v + e[^-1] "Create palette '"$mode"'." v -
 +_pal_$mode
done
+_pal_i: if $!==2 if w#1==1||h#1==1 if w#1>256||h#1>256 v + error "ERROR: There are no palette!" fi to_rgb. elif w#0==1||h#0==1 if w#0>256||h#0>256 v + error "ERROR: There are no palette!" fi rv to_rgb. else +autocrop _ia={w#2*h#2}  _ib={w#3*h#3} _ic={$_ia>$_ib} rm[^0-1] if !$_ic rv fi fx_extract_objects. 0,0,0,0,0,0,1 rm. if h#1*w#1>255 v + error "ERROR: There are no palette!" fi if h#1>w#1 rotate. 90 fi s. y,{h#1} autocrop. 0,0,0,0 a[^0] x to_rgb. fi else v + error "ERROR: You must have use only two images to use this command!" fi
+_pal_bw:(0,255^0,255^0,255)
+_pal_rgb:(255,0,0^0,255,0^0,0,255)
+_pal_b_rgb:(0,255,0,0^0,0,255,0^0,0,0,255)
+_pal_bw_rgb:(0,255,255,0,0^0,255,0,255,0^0,255,0,0,255)
+_pal_cmy:(0,255,255^255,0,255^255,255,0)
+_pal_cmyk:(0,255,255,0^255,0,255,0^255,255,0,0)
+_pal_wcmyk:(255,0,255,255,0^255,255,0,255,0^255,255,255,0,0)
+_pal_rgbcmy:(255,0,0,0,255,255^0,255,0,255,0,255^0,0,255,255,255,0)
+_pal_1bitrgb:(255,0,255,0,0,0,255,255^255,0,0,255,0,255,0,255^255,0,0,0,255,255,255,0)
+_pal_aurora:(0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,0,63,0,191,129,0,63,0,15,127,191,245,253,255,255,255,191,127,85,127,191,255,255,255,255,191,127,0,63,0,175,0,0,75,188,203,166,126,110,126,160,192,208,225,235,245,246,245,127,87,115,142,171,199,227,248,227,196,143,115,59,65,115,143,162,181,199,218,237,199,171,142,115,88,70,25,35,59,80,59,87,115,100,143,162,225,180,171,135,80,15,30,35,59,100,143,171,199,190,171,168,143,87,87,59,15,31,59,73,87,115,118,143,171,208,227,171,143,115,87,60,70,114,143,171,171,235,255,227,225,215,199,200,195,75,50,40,64,98,165,218,213,255,245,255,246,255,215,218,180,160,95,83,98,140,172,177,230,255,255,200,155,150,115,106,60,40,32,12,20,10,20,125,75,0,5,28,18,18,6,0,45,60,106,145,85,125,8,16,5,22,15,0,50,0,24,35,105,74,144,90,190,120,74,98,60,16,0,35,12,80,96,135,156,189,185,215,215,248,230,255,218,189,189,140,90,100,65,50,85,160,200,255,255,250,252,230,189,152,145^0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,127,191,255,255,129,0,63,0,15,0,63,0,129,192,129,0,63,0,20,63,127,127,191,255,255,191,127,127,191,255,255,191,127,125,175,170,160,148,130,110,105,120,138,155,170,185,200,225,0,59,65,85,115,143,171,210,199,158,115,87,45,65,115,143,162,181,199,218,237,227,199,190,143,125,80,30,80,87,100,115,143,171,192,199,216,248,238,227,180,125,105,45,65,115,171,199,227,241,210,199,185,171,143,115,87,25,31,59,73,87,110,118,143,171,218,227,143,87,87,59,35,50,64,87,87,115,172,220,199,185,160,143,125,90,40,22,10,24,24,20,32,82,60,90,98,189,165,155,110,90,75,50,80,98,128,148,177,213,213,234,255,240,220,200,168,110,52,70,92,150,215,230,255,240,197,180,140,56,152,196,222,235,254,255,235,230,215,222,156,90,44,55,74,100,82,106,120,157,164,176,197,185,110,90,65,60,28,16,16,33,16,16,50,65,98,145,165,195,198,115,82,32,41,16,20,24,20,0,10,25,25,0,80,106,160,58,30,16,52,20^0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,127,191,255,255,255,255,191,127,80,127,191,245,255,203,129,0,63,0,20,0,63,0,129,191,0,63,0,0,63,0,175,255,255,200,192,137,144,148,135,96,95,114,116,125,140,155,175,210,255,59,60,85,115,143,171,218,171,115,87,59,31,35,59,87,85,114,143,171,199,171,143,85,87,62,50,15,55,59,80,73,87,115,130,143,162,250,202,197,142,95,70,35,70,115,171,199,227,241,240,227,220,199,199,143,115,45,59,87,115,143,170,202,199,227,248,255,199,199,143,115,60,70,114,143,171,171,225,245,227,210,190,185,160,145,55,35,30,17,0,10,16,74,10,50,98,49,60,15,10,0,5,20,10,0,90,0,10,90,16,74,65,70,25,5,5,20,5,8,12,5,10,10,115,90,20,80,78,50,128,145,106,168,165,205,255,255,240,213,222,92,82,125,156,150,246,189,220,195,255,255,255,250,240,255,246,245,218,189,148,72,176,208,210,255,255,255,255,250,252,255,255,224,255,197,190,123,100,98,70,55,130,120,191,197,185,140,120,57,77,55)
+_pal_playpal:(0,31,23,75,255,27,19,11,7,47,35,23,15,79,71,63,255,247,243,235,231,223,219,211,203,199,191,187,179,175,167,163,155,151,143,139,131,127,119,115,107,103,95,91,83,79,71,67,255,255,255,255,255,255,255,255,255,247,239,231,223,215,207,203,191,179,171,163,155,143,135,127,119,107,95,83,75,63,51,43,239,231,223,219,211,203,199,191,183,179,171,167,159,151,147,139,131,127,119,111,107,99,91,87,79,71,67,59,55,47,39,35,119,111,103,95,91,83,75,67,63,55,47,39,31,23,19,11,191,183,175,167,159,155,147,139,131,123,119,111,103,95,87,83,159,143,131,119,103,91,79,67,123,111,103,91,83,71,63,55,255,235,215,195,175,155,135,115,255,255,255,255,255,255,255,255,239,227,215,203,191,179,167,155,139,127,115,103,91,231,199,171,143,115,83,55,27,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,243,235,223,215,203,195,183,175,255,255,255,255,255,255,255,167,159,147,135,79,67,55,47,0,0,0,0,0,0,255,255,255,255,207,159,111,167^0,23,15,75,255,27,19,11,7,55,43,31,23,59,51,43,183,171,163,151,143,135,123,115,107,99,91,87,79,71,63,59,51,47,43,35,31,27,23,19,15,11,7,7,7,0,0,0,235,227,219,211,207,199,191,187,179,171,163,155,147,139,131,127,123,115,111,107,99,95,87,83,79,71,67,63,55,47,43,35,239,231,223,219,211,203,199,191,183,179,171,167,159,151,147,139,131,127,119,111,107,99,91,87,79,71,67,59,55,47,39,35,255,239,223,207,191,175,159,147,131,115,99,83,67,51,35,23,167,159,151,143,135,127,123,115,107,99,95,87,83,75,67,63,131,119,107,95,83,71,59,51,127,115,107,99,87,79,71,63,255,219,187,155,123,91,67,43,219,187,155,123,95,63,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,231,199,171,143,115,83,55,27,0,0,0,0,0,0,0,0,235,215,199,179,163,143,127,115,111,103,95,87,79,71,67,255,255,255,255,255,255,255,63,55,47,35,59,47,35,27,0,0,0,0,0,0,159,231,123,0,0,0,0,107^0,11,7,75,255,27,19,11,7,31,15,7,0,43,35,27,183,171,163,151,143,135,123,115,107,99,91,87,79,71,63,59,51,47,43,35,31,27,23,19,15,11,7,7,7,0,0,0,223,211,199,187,179,167,155,147,131,123,115,107,99,91,83,79,75,71,67,63,59,55,51,47,43,39,35,31,27,23,19,15,239,231,223,219,211,203,199,191,183,179,171,167,159,151,147,139,131,127,119,111,107,99,91,87,79,71,67,59,55,47,39,35,111,103,95,87,79,71,63,55,47,43,35,27,23,15,11,7,143,135,127,119,111,107,99,91,87,79,75,67,63,55,51,47,99,83,75,63,51,43,35,27,99,87,79,71,59,51,43,39,115,87,67,47,31,19,7,0,219,187,155,123,95,63,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,227,203,179,155,131,107,83,219,187,155,123,91,59,27,23,15,15,11,7,0,0,0,215,179,143,107,71,35,0,0,0,0,0,39,27,19,11,71,59,47,35,23,11,67,75,255,255,207,155,107,107)
+_pal_srb2:(255,247,239,231,223,215,207,199,191,183,175,167,159,151,143,135,127,119,111,103,95,87,79,71,63,55,47,39,31,23,15,7,0,191,183,175,167,159,150,142,134,126,117,109,101,93,84,76,67,191,179,171,163,155,143,135,127,119,107,95,83,75,63,51,43,255,255,255,255,255,255,255,255,255,247,239,231,223,215,207,203,255,255,255,255,255,255,255,255,243,229,216,203,190,177,164,151,255,255,255,255,255,255,255,255,255,207,175,143,111,79,47,15,255,235,215,195,175,155,135,115,255,255,255,255,255,255,255,255,239,223,207,191,175,159,143,127,111,95,79,63,47,31,15,255,243,231,219,203,191,179,167,142,134,126,117,109,101,93,85,119,112,105,97,90,82,75,67,60,53,45,38,30,23,15,7,222,199,173,149,124,100,74,50,0,0,0,0,0,0,0,0,255,255,223,191,159,127,95,63,233,196,157,119,84,65,46,27,213,191,170,149,128,106,85,63,55,47,39,31,0,0,0,0,231,198,173,140,115,82,49,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,207,183,159,135,111,87,63,39^255,247,239,231,223,215,207,199,191,183,175,167,159,151,143,135,127,119,111,103,95,87,79,71,63,55,47,39,31,23,15,7,0,167,160,152,144,137,129,121,114,106,98,90,83,75,67,60,51,123,115,111,107,99,95,87,83,79,71,67,63,55,47,43,35,235,227,219,211,207,199,191,187,179,171,163,155,147,139,131,127,238,220,203,185,168,151,134,117,109,101,93,85,77,69,61,54,255,255,255,255,255,255,255,255,255,207,175,143,111,79,47,15,255,219,187,155,123,91,67,43,223,191,159,127,95,63,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,183,163,143,123,107,91,79,63,46,39,32,25,18,11,5,0,255,240,224,208,192,176,160,144,128,112,96,80,64,48,32,15,255,228,200,173,146,119,90,63,255,223,191,159,127,95,63,31,111,0,0,0,0,0,0,0,233,196,157,119,84,65,46,27,241,235,227,221,214,207,200,191,157,143,119,95,191,127,95,63,231,198,173,140,115,82,49,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,127,111,95,79,63,47,31,15^255,247,239,231,223,215,207,199,191,183,175,167,159,151,143,135,127,119,111,103,95,87,79,71,63,55,47,39,31,23,15,7,0,143,136,128,120,113,105,97,90,82,74,66,59,51,43,36,27,75,71,67,63,59,55,51,47,43,39,35,31,27,23,19,15,223,211,199,187,179,167,155,147,131,123,115,107,99,91,83,79,220,185,151,117,85,54,25,0,0,0,0,0,0,0,0,0,239,207,175,143,111,79,47,15,0,0,0,0,0,0,0,0,115,87,67,47,31,19,7,0,223,191,159,127,95,63,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,183,163,143,123,107,91,79,63,0,0,0,0,0,0,0,0,79,75,70,65,60,55,50,45,40,35,30,25,20,15,10,4,168,148,128,107,88,68,48,29,0,0,0,0,0,0,0,0,255,255,223,191,159,127,95,63,243,225,206,187,167,131,92,52,255,255,255,255,255,255,255,255,223,191,159,127,191,127,95,63,255,255,255,255,255,255,255,255,255,231,206,181,156,132,107,82,79,63,55,39,31,15,7,255,207,183,159,135,111,87,63,39)
+_pal_famicube:(0,224,255,215,168,123,52,21,13,65,113,189,37,10,0,0,32,88,19,0,23,55,106,140,190,238,182,147,204,255,255,246,173,35,92,174,197,226,79,130,218,225,245,255,255,207,135,163,204,213,254,226,166,106,90,33,61,98,155,152,91,10,2,0^0,60,255,215,168,123,52,21,32,93,166,255,226,152,82,96,181,211,157,78,40,109,180,214,235,255,193,151,143,187,231,143,78,23,60,108,151,215,21,60,101,130,183,233,130,60,22,40,105,156,201,201,117,49,25,22,52,100,160,220,168,137,74,23^0,40,255,215,168,123,52,21,48,102,161,202,205,172,128,75,98,50,8,0,8,3,23,18,113,169,33,23,21,49,55,55,26,18,13,55,130,181,7,61,94,137,132,197,206,113,70,179,228,252,237,255,254,202,145,64,165,220,239,255,255,255,202,125)
+_pal_kens16:(0,255,201,110,232,239,106,25,22,50,5,63,186,255,227,122^0,255,143,78,2,227,137,86,237,193,127,50,170,148,14,36^0,255,76,35,0,5,39,72,117,195,193,174,255,157,194,61)
+_pal_kens32:(214,254,161,250,251,230,153,71,5,79,45,0,111,8,42,6,0,74,142,183,255,172,130,90,174,247,244,155,86,17,81,8^160,59,44,47,159,28,47,1,17,2,105,166,235,162,102,54,0,73,123,192,255,190,124,59,101,170,234,149,98,150,225,253^144,30,50,122,218,247,124,31,85,236,203,238,255,154,106,25,0,87,164,255,255,156,112,28,7,48,92,0,4,59,19,204)
+_pal_kens54:(5,50,56,0,28,42,45,0,80,162,132,170,205,5,73,47,56,120,187,142,31,37,114,164,245,223,168,54,36,127,71,147,151,229,213,221,242,238,158,78,91,94,126,162,224,255,255,223,171,238,193,248,234,161^254,175,114,0,51,82,132,183,254,209,146,186,255,220,159,109,148,206,198,140,100,71,98,141,184,111,49,16,18,35,26,39,104,126,48,56,128,41,40,33,80,77,117,175,245,251,255,185,140,193,144,203,121,94^193,135,97,0,42,25,48,22,52,142,108,179,241,221,170,130,215,248,236,253,244,126,159,181,244,241,238,227,103,135,58,78,119,163,157,90,113,17,31,26,88,40,26,34,63,198,255,186,118,145,41,26,36,48)
+_pal_aap12:(4,28,71,108,227,216,161,78,154,240,249,138^3,22,65,140,210,128,61,40,64,212,245,143^3,24,107,80,69,56,59,46,126,114,239,196)
+_pal_aap16:(7,51,119,204,153,221,255,255,85,17,68,51,85,85,170,255^7,34,68,136,51,119,221,255,170,85,238,136,68,85,187,255^8,34,51,85,17,17,85,51,68,34,187,221,170,119,187,255)
+_pal_aap64:(6,20,59,115,180,223,250,249,255,255,214,156,89,20,26,36,18,20,40,36,32,166,255,254,250,245,232,188,121,64,36,34,50,113,187,219,244,218,179,139,109,74,51,66,91,142,186,233,227,185,132,88,71,35,50,93,146,205,228,199,160,121,90,66^6,16,23,23,32,62,106,163,213,252,242,219,193,160,122,82,32,52,92,159,214,252,255,243,214,160,106,74,58,51,34,28,43,65,117,164,210,224,185,147,117,84,57,36,49,82,117,181,230,191,155,141,125,103,132,175,220,247,210,176,134,103,78,57^8,19,37,45,42,35,10,27,65,64,100,67,53,46,62,59,32,100,196,222,199,219,255,192,184,151,115,155,128,83,52,26,40,59,71,99,156,234,209,175,141,98,65,51,56,82,106,163,255,251,228,190,133,78,100,141,186,226,170,139,98,85,68,52)
+_pal_aap128:(5,14,45,97,185,241,252,255,255,255,248,232,176,103,39,76,133,211,248,213,173,127,88,51,24,41,71,97,143,196,208,151,89,66,61,39,20,27,43,39,66,115,241,201,138,69,73,120,156,206,250,238,212,144,23,55,105,178,226,246,252,236,203,166,128,89,50,79,140,198,214,180,114,69,97,147,198,239,181,134,93,72,44,23,44,70,100,138,175,220,184,136,94,72,40,70,105,154,197,230,238,227,191,135,86,50,54,101,150,192,212,234,241,221,189,136,89,51,178,225,248,255,253,246,226,178,100,42^4,12,27,39,69,100,165,224,255,240,197,138,91,57,31,61,95,151,246,220,184,142,99,60,28,63,114,165,208,241,255,237,207,164,111,65,18,36,78,137,191,239,242,212,161,114,65,100,139,170,214,181,128,82,21,51,91,139,178,216,247,235,198,158,123,87,50,52,91,133,168,117,75,42,104,148,184,221,231,198,155,104,59,24,52,84,135,196,233,234,204,163,113,82,44,71,102,151,199,231,230,205,165,115,79,47,40,73,104,144,184,224,235,206,164,110,77,39,148,191,227,233,201,162,114,82,54,30^3,12,30,33,29,31,112,183,255,137,58,54,44,49,27,46,57,65,68,29,52,68,53,36,25,33,56,63,50,41,234,202,147,89,67,45,29,71,149,205,232,232,255,253,246,227,130,198,219,237,255,156,187,188,22,52,89,120,126,150,190,231,193,154,122,87,50,47,62,86,81,56,44,27,58,70,88,145,203,154,121,89,57,25,56,86,140,195,223,238,216,188,142,98,60,98,130,185,221,240,234,223,201,143,91,53,43,86,136,169,184,221,219,191,153,106,77,42,118,137,152,227,201,168,133,102,75,35)
+_pal_db8:(0,85,100,215,80,100,230,220^0,65,105,115,140,185,200,245^0,95,100,85,215,100,110,255)
+_pal_db16:(20,68,48,78,133,52,208,117,89,210,133,109,210,109,218,222^12,36,52,74,76,101,70,113,125,125,149,170,170,194,212,238^28,52,109,78,48,36,72,97,206,44,161,44,153,202,94,214)
+_pal_db32:(0,34,69,102,143,223,217,238,251,153,106,55,75,82,50,63,48,91,99,95,203,255,155,132,105,89,118,172,217,215,143,138^0,32,40,57,86,113,160,195,242,229,190,148,105,75,60,63,96,110,155,205,219,255,173,126,106,86,66,50,87,123,151,111^0,52,60,49,59,38,102,154,54,80,48,110,47,36,57,116,130,225,255,228,252,255,183,135,106,82,138,50,99,186,74,48)
+_pal_db_iso22:(12,76,112,188,206,228,144,105,77,38,44,60,85,116,240,207,182,132,85,116,107,147^8,65,80,95,145,218,196,142,97,50,75,115,141,186,250,182,124,90,84,102,123,147^22,56,58,78,72,108,70,52,60,60,115,115,222,234,255,144,116,120,97,88,137,136)
+_pal_dimwid17:(20,103,117,135,139,119,14,41,87,240,177,179,221,248,254,242,173^4,16,75,123,157,202,103,48,125,121,111,60,128,204,201,254,211^21,16,55,86,83,115,63,101,172,163,185,111,34,1,175,255,254)
+_pal_dimwid23:(0,250,224,226,186,185,235,195,228,187,113,81,137,203,166,58,56,158,171,24,93,30,7^0,232,205,225,183,171,167,190,114,102,137,154,127,70,72,109,102,31,44,55,32,22,6^0,233,242,92,169,250,80,33,81,227,229,75,127,103,135,105,44,113,41,118,62,71,13)
+_pal_edg4:(251,229,66,32^247,176,110,40^243,131,93,61)
+_pal_edg8:(253,211,218,230,40,45,123,27^253,39,125,218,198,147,83,28^248,52,34,41,65,221,173,51)
+_pal_edg16:(228,184,116,63,158,229,251,255,99,50,25,79,175,255,44,4^166,111,63,40,40,59,146,231,198,115,61,103,191,255,232,132^114,80,57,50,53,68,43,98,77,69,63,129,210,255,244,209)
+_pal_edg32:(190,215,234,228,184,115,62,162,228,247,254,254,99,62,38,25,18,0,44,255,192,139,90,58,38,24,255,104,181,246,232,194^74,118,212,166,111,62,39,38,59,118,174,231,199,137,92,60,78,153,232,255,203,155,105,68,43,20,0,56,80,117,183,133^47,67,170,114,80,57,49,51,68,34,52,97,77,72,66,62,137,219,245,255,220,180,136,102,68,37,68,108,136,122,150,105)
+_pal_edg36:(219,163,103,78,57,38,20,123,80,46,26,15,13,15,14,19,65,240,229,197,148,98,70,151,229,247,251,254,237,196,120,53,77,127,180,227^224,172,112,83,58,36,16,207,155,106,69,39,47,77,130,178,243,210,174,129,85,53,33,67,112,172,223,151,82,44,31,20,35,59,94,141^231,190,139,113,86,58,32,92,75,66,59,56,109,163,206,242,252,175,120,88,66,48,31,42,40,55,107,155,89,54,44,40,82,134,179,214)
+_pal_edg64:(255,19,27,39,61,93,133,180,255,199,146,101,66,42,26,14,28,57,93,138,191,230,246,249,237,224,198,142,255,237,255,255,255,211,153,90,51,30,19,12,0,0,0,0,12,148,253,243,219,122,48,12,3,59,98,147,202,200,246,245,234,196,137,87^0,19,27,39,61,93,133,180,255,207,161,115,76,47,25,7,18,31,44,72,111,156,202,230,171,116,69,37,80,118,162,200,235,252,230,197,152,111,76,46,57,105,152,205,241,253,210,137,63,9,3,2,25,20,36,56,82,80,129,85,50,36,30,28^64,19,27,39,61,93,133,180,255,221,185,146,110,78,50,27,28,33,40,54,74,105,159,207,80,56,36,29,0,20,20,37,87,126,95,79,75,80,76,68,109,170,220,249,255,255,237,245,253,250,217,147,63,67,97,143,201,134,135,93,60,48,43,39)
+_pal_juicy32:(51,102,153,204,255,229,178,127,61,7,79,135,216,255,255,178,80,37,16,10,18,56,107,184,255,145,53,62,25,91,165,211^14,36,76,137,204,114,53,24,6,0,31,77,157,199,235,214,178,124,84,57,29,71,122,197,255,224,130,106,40,53,82,116^34,53,76,124,181,57,53,75,61,14,27,54,97,89,140,96,71,73,72,71,53,102,153,216,242,204,130,178,102,130,139,132)
+_pal_juicy56:(0,255,200,165,120,85,55,25,20,15,15,65,115,220,178,140,90,55,255,245,230,195,140,65,125,170,215,240,255,255,190,100,35,15,15,130,65,20,20,15,15,60,100,160,230,255,75,130,180,230,255,255,230,190,150,110^0,255,225,190,145,100,65,30,70,115,165,205,255,155,98,60,20,10,210,165,110,65,35,0,0,20,45,105,170,230,215,165,125,85,50,255,215,160,105,55,15,30,45,65,90,140,20,10,35,80,140,205,155,105,70,40^5,255,235,205,165,125,90,60,90,115,105,115,115,120,71,50,35,20,165,110,70,45,35,65,65,60,45,35,50,90,45,30,20,25,35,225,215,205,195,155,105,140,180,215,230,200,60,100,110,120,140,180,150,115,95,80)
+_pal_xaiue:(252,135,8,55,91,159,107,179,175,77,75,181,229,224,112,61,43,29,109,182,206,243^250,116,6,46,77,126,205,214,176,140,76,69,139,218,176,127,64,24,67,102,152,215^228,105,11,35,33,43,99,239,233,211,183,55,55,44,60,79,75,62,105,166,155,189)
+_pal_15pdx:(110,187,223,236,131,39,23,4,23,129,253,199,135,70,32^50,87,146,210,168,114,59,104,161,219,249,178,113,63,23^50,53,69,116,22,36,71,148,169,205,241,149,91,60,8)
+_pal_20pdx:(23,71,120,177,235,104,169,217,235,82,129,188,235,14,4,1,85,23,90,177^13,71,120,185,255,41,68,126,208,60,96,139,205,76,110,163,222,121,178,227^32,87,118,166,218,62,0,0,0,20,49,87,147,88,146,195,183,71,23,41)
+_pal_24pdx:(23,72,137,201,252,111,192,238,255,76,142,204,247,13,32,102,201,0,0,111,99,183,255,255^15,69,122,183,245,36,70,131,196,44,83,140,199,65,121,182,226,113,171,221,44,70,121,189^7,66,108,156,232,29,14,0,45,53,64,88,139,87,73,50,81,157,196,213,83,108,134,169)
+_pal_cabana64:(0,167,103,71,48,58,90,195,241,253,255,255,240,224,178,130,255,255,169,109,69,104,149,218,242,255,255,255,221,192,144,96,74,210,163,97,51,63,97,143,210,242,218,150,57,34,52,34,16,105,162,113,67,44,8,27,91,182,209,170,76,28,13,10^0,154,84,53,32,22,38,104,110,164,226,216,157,105,78,51,255,252,128,71,45,11,28,72,118,175,245,118,57,34,12,1,74,204,146,84,47,13,24,75,145,237,255,218,174,116,58,20,16,132,188,159,86,50,67,116,190,255,255,255,212,131,57,37^0,95,31,19,26,3,11,10,3,20,44,135,81,38,44,20,255,219,90,52,37,118,188,221,255,252,246,147,57,20,71,25,74,243,212,118,58,118,148,236,255,255,254,255,255,255,241,120,16,156,197,147,85,51,57,74,97,140,204,216,148,147,111,99)
+_pal_fant16:(142,81,51,20,70,166,211,231,238,217,117,20,4,28,67,96^109,58,39,19,24,60,123,188,238,213,115,33,4,27,80,161^52,24,16,12,32,30,30,79,250,91,32,15,5,47,99,143)
+_pal_fant24:(31,57,165,239,239,171,24,239,239,165,119,114,42,57,104,146,39,239,69,60,155,54,85,48^36,87,140,172,216,92,63,105,183,98,52,65,29,42,76,126,100,58,35,159,26,23,15,15^10,28,39,40,161,28,57,47,117,67,33,19,13,28,60,106,104,12,13,156,10,12,10,10)
+_pal_tf23:(165,201,209,162,131,99,65,40,58,95,134,172,212,151,101,58,34,80,133,223,172,124,76^45,109,202,157,107,73,51,34,59,99,149,194,237,181,132,89,58,59,91,185,220,168,110^39,69,128,107,63,44,37,31,61,103,152,195,237,138,92,65,48,104,105,202,241,213,173)
+_pal_tfp39:(82,120,165,201,204,207,227,247,217,199,141,87,40,65,99,131,162,151,101,58,32,32,58,95,134,172,212,172,124,76,62,55,51,88,114,133,177,223,234^30,24,45,109,165,194,231,225,182,151,91,50,34,51,73,107,157,181,132,89,55,44,59,99,149,194,237,220,168,110,61,42,20,38,64,91,139,185,220^46,38,39,69,98,129,171,188,145,125,87,34,31,37,44,63,107,138,92,65,45,17,61,103,152,195,237,241,213,173,138,94,77,79,74,105,154,202,230)
+_pal_faraway48:(13,34,61,173,217,255,255,214,143,22,28,13,13,0,0,0,0,8,89,170,69,37,2,25,16,9,21,46,86,160,200,237,247,247,241,231,209,158,115,77,36,28,16,32,88,169,210,241^7,9,5,24,79,152,249,246,250,158,93,56,29,25,49,100,141,196,223,232,197,149,89,58,20,13,21,38,46,58,101,175,200,243,228,204,158,109,50,38,23,18,17,34,97,176,214,242^9,21,24,24,12,14,89,104,55,38,42,34,31,31,56,87,109,159,176,202,217,207,153,145,56,25,56,77,115,158,143,185,217,206,175,147,113,79,46,48,32,22,18,35,98,176,215,241)
+_pal_fleja_m:(31,43,65,104,144,182,255,252,181,138,92,201,222,255,255,252,180,81,48,35,38,35,65,76,99,148,184,60,70,130,247,194,133^24,46,72,113,161,203,255,191,128,80,58,48,106,173,229,249,214,196,156,109,79,54,114,147,194,210,253,41,39,100,164,113,45^51,66,89,122,168,207,255,138,87,62,65,56,56,59,150,96,69,63,99,122,110,99,145,173,201,212,255,64,92,129,139,130,102)
+_pal_koni32:(0,11,22,34,43,48,52,73,164,255,242,204,245,166,153,115,77,70,140,242,255,179,112,64,31,33,39,65,109,137,187,255^0,10,21,38,64,101,168,242,255,242,165,122,64,58,83,55,42,52,46,97,168,223,165,124,80,62,47,69,112,139,189,255^0,13,36,64,87,102,112,90,99,64,63,71,37,58,72,88,73,106,184,218,212,255,250,255,204,166,102,88,120,140,191,255)
+_pal_linearbasic:(14,95,153,220,247,159,98,143,197,238,252,218,250,151,75,61,49,65,73,114,86,89,71,129,194,240,253,211,170,119,72^12,45,57,74,134,41,35,64,96,142,203,78,203,218,167,115,65,112,167,214,152,86,53,86,120,179,247,191,141,92,59^12,86,112,123,151,78,47,41,37,46,163,56,62,63,71,79,82,137,144,206,204,189,121,170,208,221,237,169,122,85,58)
+_pal_vinelinear:(21,40,54,104,180,244,244,255,12,3,9,17,87,185,26,41,94,143,244,254,14,27,34,70,42,125,34,47,67,116,175,248,25,36,37,58,86,151^10,11,16,24,35,104,192,253,19,40,73,131,197,237,17,25,28,23,93,181,9,24,45,91,192,242,12,19,30,52,93,153,16,30,49,92,161,219^31,38,39,36,19,11,71,240,39,43,63,55,43,94,46,69,90,103,146,139,47,83,129,231,242,207,39,22,30,26,35,58,46,68,94,133,191,210)
+_pal_arcade29:(241,255,159,255,240,241,201,151,87,114,35,10,48,47,105,51,50,40,201,108,255,229,23,150,88,42,185,126,65^240,77,30,196,108,194,126,63,20,203,133,75,197,126,222,165,89,35,92,52,170,93,25,165,108,55,165,99,47^238,77,49,56,0,132,79,63,46,37,49,77,173,131,255,255,226,123,209,157,188,172,27,171,121,71,136,82,47)
+_pal_arq16:(255,255,174,77,233,16,81,5,241,130,255,90,255,125,235,30^255,209,181,128,56,8,30,68,137,62,169,225,233,62,108,138^255,157,189,201,65,32,67,148,45,44,169,80,71,191,130,76)
+_pal_blk36:(0,18,41,70,107,144,193,255,255,229,193,140,102,63,41,65,100,140,185,165,90,65,53,54,10,15,20,34,66,140,255,255,204,135,216,255^0,23,50,75,116,158,217,255,204,149,106,75,51,35,23,40,52,81,145,230,185,133,74,39,42,74,102,137,188,255,224,150,82,42,56,104^0,61,104,140,178,221,242,255,208,159,125,99,75,60,76,102,153,204,242,255,229,216,178,127,51,76,91,110,127,155,145,95,80,56,67,102)
+_pal_blkneo:(0,18,41,70,107,144,193,255,255,242,195,153,114,63,178,229,255,255,140,66,34,20,15,10,29,50,53,62,80,140,180,133,93,67,255,255,255,178,114,165,221,255,120,39,0,0^0,23,50,75,116,158,217,255,204,159,114,76,51,31,46,66,110,165,255,188,137,102,74,42,26,45,74,131,185,218,131,76,47,30,224,170,105,60,28,38,55,102,250,211,170,135^0,61,104,140,178,221,242,255,208,170,137,105,82,60,105,134,175,213,155,127,110,91,76,51,89,137,178,209,235,255,239,191,140,102,145,110,90,64,47,57,69,117,230,203,165,130)
+_pal_brokefac:(36,137,173,204,249,86,131,163,181,202,77,152,209,221,243,200,216,232,242,248,23,72,122,164,205,80,94,127,157,202,32,63,119,185,203,237,243,219,233,213^33,131,169,202,248,55,87,114,150,184,28,25,36,75,121,104,153,192,219,241,96,140,189,207,222,68,156,198,226,241,44,45,38,40,81,167,190,235,221,196^30,119,158,196,247,53,72,84,105,128,45,30,36,99,226,38,63,79,137,198,31,54,64,65,94,186,204,206,223,234,86,109,115,79,53,216,221,235,232,223)
+_pal_bubblegum:(22,127,214,255,255,250,255,255,148,67,35,104,191,16,0,0^23,6,36,132,209,253,128,38,33,0,73,174,255,210,120,40^26,34,17,38,0,255,164,116,106,103,117,212,60,117,153,89)
+_pal_cade15:(16,53,68,76,4,28,92,124,56,142,188,250,212,255,226^15,22,98,186,85,153,74,142,16,2,70,125,146,215,241^12,92,188,255,36,36,108,141,0,50,4,97,12,80,210)
+_pal_calder8:(213,12,4,226,235,0,8,33,253,117,128^4,37,121,201,73,95,164,67,170,29,123^7,165,55,6,29,168,132,203,29,107,115)
+_pal_chrom16:(0,144,255,128,255,160,255,255,255,32,64,0,48,0,160,255^0,176,255,0,0,80,128,192,255,172,255,48,112,208,0,96^0,176,255,24,0,0,0,128,0,0,0,112,176,255,224,255)
+_pal_cdbac:(0,218,127,196,244,199,119,49,55,142,214,245,253,206,93,48^0,131,55,196,251,240,226,152,54,100,151,206,245,63,9,20^0,92,16,102,74,220,142,63,141,227,255,230,249,80,41,33)
+_pal_cgarne:(0,94,34,76,12,108,68,123,138,235,92,226,170,255,181,255^0,96,52,129,126,217,170,226,54,138,46,61,92,217,181,255^0,110,209,251,69,71,204,249,34,96,120,105,61,63,181,255)
+_pal_cpcboy:(0,27,53,102,85,127,188,192,223,27,27,30,121,128,145,201,227,248,53,53,53,127,173,141,225,228,255,238,172,118,63,36^0,27,53,30,51,53,53,70,109,101,110,121,95,128,148,127,155,120,175,183,193,201,200,225,198,221,255,234,181,132,80,49^0,101,201,37,97,201,53,110,155,27,131,229,27,128,223,53,141,248,53,143,215,53,170,199,67,154,255,224,107,72,63,55)
+_pal_dino:(15,41,83,149,241,197,141,81,236,234,205,124,48,0,71,31^21,39,88,146,241,141,82,61,213,119,61,63,66,131,164,97^27,50,103,143,234,101,66,61,109,48,61,140,113,200,77,67)
+_pal_4l:(250,70,92,87,97,107,153,181,135,166,180,13,18,78,113,76,22,173,227,235,255,248^249,59,87,98,115,151,11,97,135,164,180,13,22,64,96,126,156,101,102,148,193,226^249,82,90,122,81,85,45,114,116,156,180,13,130,166,186,216,120,95,37,136,146,0)
+_pal_fzteth16:(243,249,184,94,162,194,143,193,108,0,0,221,0,7,0,5^243,194,112,13,158,89,39,0,96,71,168,180,73,134,195,28^243,164,14,36,180,223,184,43,111,237,243,17,82,92,125,37)
+_pal_gzxp:(0,173,243,159,218,170,232,0,14,31,68^0,155,234,37,98,124,202,106,175,29,88^0,168,215,63,82,20,0,20,3,175,214)
+_pal_indc:(255,143,68,40,47,75,69,242,212,227,148,87,156,209,180,109,44^244,204,148,87,43,59,124,182,110,66,53,37,101,180,186,140,27^224,203,137,99,92,156,214,61,51,98,61,59,108,140,71,50,46)
+_pal_island16:(13,79,130,197,240,251,255,190,123,116,65,50,42,125,193,232^8,43,91,145,189,223,249,187,178,173,128,83,35,56,108,153^13,36,49,84,119,155,228,178,78,187,160,95,73,64,91,115)
+_pal_journey:(5,17,59,105,156,212,245,255,255,255,214,148,66,34,16,37,61,115,189,237,255,255,198,119,66,44,21,5,14,12,3,20,72,120,176,250,199,146,91,57,36,14,19,26,16,40,61,248,240,207,143,82,15,53,100,155,212,237,255,212,156,105,69,45^9,5,6,23,50,100,161,207,122,65,26,0,0,0,7,8,17,38,64,123,184,245,216,176,144,100,60,33,4,11,39,68,139,215,255,255,212,143,83,41,20,15,34,70,144,192,255,255,194,150,87,41,2,0,0,14,30,76,151,102,52,27,12,0^20,36,58,73,71,83,93,142,125,125,136,122,78,41,38,44,50,61,53,57,74,64,49,42,88,94,74,55,33,66,105,145,212,255,241,255,225,184,125,70,44,44,67,107,142,116,110,184,151,140,101,75,46,59,76,62,60,64,87,47,26,34,40,46)
+_pal_juice:(225,37,84,55,60,99,215,160,163,130,114,198,209,233,215,117,72^246,34,180,79,114,228,233,113,172,132,89,148,198,157,80,78,216^210,44,60,122,82,116,91,77,166,132,151,168,170,70,60,59,206)
+_pal_oak:(248,179,98,174,238,255,177,82,24,32,37,116,86,62,56,129,163,69,110,175,255^135,73,26,57,141,244,211,127,40,67,118,241,149,76,18,74,119,75,120,188,255^61,91,142,172,255,159,110,85,58,74,119,235,217,146,50,84,95,78,128,197,255)
+_pal_nature55:(27,254,226,168,105,255,231,190,122,208,151,90,255,235,205,104,37,27,123,56,41,37,94,32,38,48,163,120,84,239,182,116,67,255,234,175,117,235,177,227,177,116,62,223,156,97,42,184,117,82,253,204,145,93,56^20,147,83,36,27,191,130,83,50,128,78,48,201,138,224,178,125,78,236,170,119,68,215,150,98,51,204,141,88,161,108,68,47,178,109,64,34,113,65,196,142,100,63,221,170,123,78,216,157,106,245,193,134,91,56^30,90,34,36,40,137,90,64,28,88,73,63,92,6,66,41,44,68,191,145,126,108,239,205,171,134,255,222,192,206,190,141,101,178,157,127,74,113,92,176,142,127,100,154,116,71,50,209,169,152,241,190,146,110,76)
+_pal_nauris16:(140,88,62,154,215,245,192,100,228,157,210,112,126,52,23,31^143,69,33,99,155,237,199,125,148,48,100,55,196,133,67,14^174,99,55,72,125,186,65,52,58,59,113,127,193,157,75,28)
+_pal_pear36:(94,140,186,242,255,207,143,60,61,50,50,71,75,77,102,255,194,126,96,67,39,62,87,150,227,255,255,235,176,115,66,90,128,189,255,255^49,63,97,166,228,255,222,163,110,62,41,59,91,166,255,255,194,126,96,67,39,35,41,66,105,181,145,86,48,39,36,38,54,72,107,181^91,93,86,94,120,112,93,112,112,79,71,120,171,255,227,235,209,143,112,79,54,71,75,83,86,112,102,75,92,92,69,94,107,130,151,181)
+_pal_peach:(253,255,251,206,143,83,173,159,86,10,39,12,172,255,255,255^255,134,71,24,11,3,109,185,127,84,140,231,252,236,167,64^255,134,113,106,95,75,234,255,235,123,127,167,173,109,99,64)
+_pal_pineapple32:(67,137,217,255,255,199,115,52,3,39,69,156,255,255,209,124,49,131,235,255,255,191,109,41,4,3,28,119,255,255,192,96^0,0,36,97,183,110,57,17,7,59,130,185,216,130,64,25,12,63,156,218,255,195,138,59,21,62,146,214,224,136,59,23^42,39,60,87,98,70,46,31,16,45,57,59,50,59,31,26,27,52,110,172,228,198,141,73,40,94,167,193,220,169,148,97)
+_pal_resurrect:(255,251,232,131,195,240,246,252,227,171,150,98,62,11,11,30,145,251,251,205,158,122,107,144,168,234,143,77,77,72,48,143^255,107,59,28,36,79,129,167,200,148,108,85,53,94,138,188,219,255,185,104,69,48,62,94,132,173,211,155,101,74,225,248^255,29,59,93,84,120,129,144,150,122,108,101,70,101,143,115,105,134,84,61,57,69,117,169,243,237,255,230,180,119,185,226)
+_pal_rosy42:(33,59,125,171,207,240,255,200,99,59,47,40,27,43,58,76,79,146,245,223,163,104,64,44,20,75,105,156,204,255,255,255,230,173,120,79,41,61,82,143,189,255^24,32,56,81,117,181,238,212,171,125,87,53,31,43,63,104,164,232,255,224,167,111,73,53,24,29,36,42,47,82,194,137,69,47,29,29,29,41,51,77,106,174^27,39,51,48,43,65,131,93,63,79,83,64,33,69,94,133,184,192,232,232,194,153,115,77,46,82,100,112,123,119,161,51,57,69,79,76,43,54,63,87,98,112)
+_pal_slso:(46,62,85,116,65,42,59,36,86,198,243,196,181,97,143,234,193^44,65,96,125,222,164,119,147,190,222,194,101,65,64,61,97,229^59,95,125,136,149,170,166,55,68,120,32,28,49,122,167,157,234)
+_pal_softy15:(217,241,34,62,190,208,156,14,159,189,101,153,21,64,92^246,218,23,201,211,168,179,168,184,102,113,17,96,19,52^234,4,44,238,220,65,26,74,174,102,64,156,144,109,17)
+_pal_spec12:(15,145,214,217,219,168,120,142,50,47,48,217^8,140,217,209,110,45,28,217,186,99,24,190^8,137,208,93,59,45,38,89,59,189,143,147)
+_pal_starmancer:(27,41,31,37,42,46,50,29,43,71,105,136,170,222,52,81,120,162,190,233,250,77,128,186,228,234,255,255,10,13,7,10,14,8,8,16,21,18,14,12,18,33,38,64,101,132,168,200,221,9,25,83^32,51,68,97,129,162,187,24,32,45,60,70,86,115,19,25,32,40,53,69,106,36,66,95,137,178,227,245,35,64,97,128,158,200,231,32,50,76,112,157,203,233,41,65,106,141,176,205,227,7,26,85^55,98,125,165,203,235,248,38,55,88,129,160,185,223,26,34,41,40,34,37,57,22,39,28,20,8,69,108,31,53,70,87,94,116,123,48,66,93,121,148,175,193,51,76,115,144,179,207,227,17,35,94)
+_pal_sup8:(246,238,237,61,8,119,230,0^250,234,196,156,145,107,40,8^255,24,149,9,205,125,0,0)
+_pal_superfuture:(16,24,96,183,255,44,150,219,248,192,28,54,112,255,77,97,210,255,228,255,0,0,69,156,255^8,30,111,217,255,25,80,147,218,192,51,105,195,255,77,27,53,128,187,0,255,128,16,9,0^32,51,171,238,255,35,57,87,172,192,45,67,59,0,77,50,47,0,64,64,225,255,126,204,255)
+_pal_sweetie16:(26,87,177,238,255,160,56,39,41,64,79,134,244,147,85,50^28,41,65,123,208,240,184,110,54,91,164,236,244,182,113,64^44,86,86,88,121,114,110,123,111,208,247,248,244,193,133,86)
+_pal_taffy16:(34,98,163,250,255,255,220,63,68,43,167,255,245,219,166,54^37,117,192,255,171,108,67,72,141,219,245,235,137,75,61,53^51,186,230,252,123,122,91,194,231,114,71,51,49,61,87,77)
+_pal_todayland:(20,49,90,148,237,94,174,227,244,69,126,198,240,27,33,52,152,33,38,30,108,68,142,228,242^20,56,103,168,239,22,36,112,191,35,66,119,183,56,103,176,232,35,75,143,213,28,48,98,180^20,61,108,170,239,50,50,23,66,35,58,66,132,69,95,111,138,99,164,222,228,92,127,154,183)
+_pal_vivid17:(7,45,60,74,129,49,85,247,226,255,200,149,241,120,83,98,170^8,39,73,74,97,145,246,255,190,223,107,39,89,85,111,149,231^24,71,101,168,197,231,255,224,87,49,54,74,169,55,97,60,93)
+_pal_voodo:(17,55,98,131,189,28,45,90,141,51,106,164,236,41,20,85,160,58,128,244,107,198,248,254,199,225,232,242,58,101,134,122,185,248^20,61,103,142,208,33,66,119,201,39,68,103,152,72,157,191,231,195,243,251,24,34,66,149,45,93,147,216,34,50,82,98,137,208^38,95,137,168,239,83,128,185,242,93,138,195,247,74,99,65,114,144,181,248,48,78,132,205,30,44,31,51,34,35,52,64,104,148)
+_pal_zu32:(71,94,122,160,191,238,244,182,113,57,60,48,90,125,160,207,223,138,40,57,57,57,86,142,205,255,244,244,230,169,130,79^45,54,68,91,121,161,204,213,170,123,89,44,83,112,147,198,246,235,204,120,71,49,64,71,96,174,180,126,72,59,112,84^60,67,74,83,88,96,161,60,52,68,86,46,83,113,142,184,245,241,223,168,120,75,100,140,147,182,27,27,46,59,148,107)
+_pal_enos16:(250,212,157,75,249,234,249,231,154,88,141,68,195,149,186,148^250,212,157,75,211,175,147,89,209,174,237,197,167,105,181,142^250,212,157,75,129,77,138,82,249,238,167,91,225,200,170,130)
+_pal_undertones:(20,65,58,53,143,94,69,220,255,255,204,161,164,244,194,129,188^25,65,127,227,217,187,131,211,254,208,146,92,47,91,73,88,176^35,104,167,227,112,73,82,123,229,53,69,62,59,122,152,141,194)
+_pal_equpix15:(82,42,62,132,56,92,16,178,212,85,128,236,139,255,255^60,42,84,84,96,122,16,126,78,168,172,138,208,204,248^78,58,66,92,124,86,36,86,82,148,64,75,186,104,192)
+_pal_night16:(15,255,12,72,121,176,101,63,185,255,221,154,100,51,118,197^15,248,33,88,160,206,127,69,157,221,148,81,75,48,112,163^30,188,51,109,176,157,73,54,106,145,91,66,72,51,136,179)
+_pal_star29:(142,241,83,44,13,27,37,45,54,92,255,179,116,68,32,186,236,123,81,50,108,211,63,33,96,175,53,34,17^36,34,31,18,18,29,49,71,109,196,255,179,122,76,40,93,129,57,37,22,50,60,38,24,163,239,109,68,31^54,60,40,29,25,70,105,141,192,249,255,225,165,108,56,47,47,42,32,21,150,242,104,57,61,73,50,43,25)
+_pal_star34:(13,27,63,108,211,240,255,241,142,83,44,37,45,54,92,179,116,68,32,50,81,123,170,217,238,255,245,236,186,17,34,53,96,175^18,29,38,50,60,104,255,34,36,31,18,49,71,109,196,179,122,76,40,22,37,57,100,153,202,206,158,129,93,31,68,109,163,239^25,70,104,150,242,125,255,60,54,40,29,105,141,192,249,225,165,108,56,21,32,42,57,90,146,95,63,47,47,25,43,50,61,73)
+_pal_stilllife:(63,122,209,224,93,104,179,18,81,40,155,168,204,199^40,34,59,127,133,193,232,38,49,111,139,228,130,181^17,34,39,138,58,39,104,21,85,184,255,212,24,129)
+_pal_simjpc16:(5,34,84,155,225,245,254,139,124,103,49,64,161,165,154,234^4,31,53,110,176,238,254,225,194,143,111,74,77,104,147,145^3,49,22,45,71,155,254,224,100,203,35,104,63,212,183,130)
+_pal_acid15:(23,64,143,211,128,55,227,244,28,9,28,33,201,181,192^3,7,30,96,128,190,218,249,13,68,81,151,130,215,248^38,61,64,54,128,161,120,210,89,64,130,59,155,55,175)
+_pal_battery24:(248,51,87,120,143,166,217,224,230,232,232,226,252,118,58,201,181,65,70,76,73,70,66,48^255,36,55,68,71,76,87,70,99,152,203,237,255,232,224,250,242,196,179,144,119,98,74,48^186,49,82,101,106,108,124,70,76,81,88,130,222,86,86,117,107,124,142,161,145,135,112,66)
+_pal_clump18:(112,178,224,236,236,179,123,96,73,38,70,86,120,181,231,219,184,153^26,42,132,188,229,203,130,26,17,24,32,76,127,197,232,192,131,78^106,121,172,210,255,255,254,188,115,29,27,56,83,155,183,158,71,46)
+_pal_cthul:(29,165,240,82,43,30,59,82,125,199,184,126,143,229,206,133^37,229,250,165,98,48,66,123,193,255,203,141,169,222,160,71^49,197,253,147,103,58,81,146,193,243,216,161,144,187,97,49)
+_pal_crimso11:(255,243,191,118,203,142,122,94,142,134,69,61,53,35,65,17^255,215,150,154,94,57,73,69,195,118,110,98,61,46,41,11^227,98,81,85,49,61,98,49,207,150,81,134,90,50,45,17)
+_pal_coptec:(0,38,53,96,137,90,145,255,244,191,197,158,95,220,110,22^0,33,82,116,137,168,217,255,205,181,136,91,67,57,169,81^0,68,120,138,137,178,243,255,114,136,67,71,81,45,44,221)
+_pal_drz15:(20,57,102,165,216,242,255,255,81,83,128,133,164,255,207^20,47,72,93,114,154,227,255,90,127,130,171,219,191,238^25,71,81,82,114,128,91,238,142,59,126,221,114,252,247)
+_pal_eggy15:(46,14,70,73,240,202,60,196,158,246,43,234,175,221,249^64,12,9,82,242,30,155,27,126,52,207,157,216,212,217^61,27,161,102,208,15,135,227,116,104,242,24,126,203,85)
+_pal_eroge:(13,79,130,197,240,251,255,190,123,116,65,50,42,125,193,232^8,43,91,145,189,223,249,187,178,173,128,83,35,56,108,153^13,36,49,84,119,155,228,178,78,187,160,95,73,64,91,115)
+_pal_europa:(255,117,49,40,26,46,79,164,236,148,59,32,81,164,220,240^255,206,122,55,27,53,102,188,248,212,120,50,32,62,125,204^255,234,215,133,53,78,120,194,96,70,80,46,49,75,94,144)
+_pal_greyt:(87,132,207,248,141,105,209,255^67,136,211,200,219,207,179,142^104,211,193,104,52,239,255,101)
+_pal_jewel:(50,102,184,210,242,240,223,188,121,86,74,77,115,116,156^30,36,40,106,197,232,183,123,65,96,143,193,227,130,172^45,49,28,18,60,156,127,98,107,148,169,179,123,161,186)
+_pal_polar11:(10,171,209,245,245,135,153,95,51,45,47^10,41,105,202,241,140,194,148,157,98,43^10,41,31,47,237,129,78,72,181,150,107)
+_pal_sheltzy:(140,69,131,201,70,21,44,34,86,139,204,255,204,163,104,0,56,102,139,156,94,57,128,195,255,189,236,255,255,255,244,255^255,184,151,236,198,137,91,42,106,171,226,219,172,109,60,0,0,59,114,216,150,83,12,75,148,31,97,164,246,218,176,255^222,179,64,133,87,104,109,92,137,191,225,165,104,62,52,0,44,147,222,252,221,192,83,145,179,63,74,104,174,112,60,255)
+_pal_rube_goldberg:(225,243,203,240,206,240,4,84,35^225,215,190,189,108,52,176,160,39^223,84,173,138,55,40,216,79,34)
+_pal_boomboom:(0,36,255,190,68,49,27^0,36,255,38,137,162,38^0,35,255,51,26,242,50)
+_pal_g8:(28,237,161,243,238,45,64,37^17,236,59,127,150,83,169,166^33,233,59,154,26,101,51,197)
+_pal_matriax8c:(240,250,16,0,210,160,115,16^240,200,200,160,64,105,100,24^220,0,64,200,64,75,100,32)
+_pal_nt1h:(255,172,70,21,34,66,101,143,189,171,139,86,56,255,237,222,194,75,138,188,228,255,156,94,57,25^255,246,198,137,47,93,144,185,223,209,171,106,58,241,198,153,94,0,0,19,54,154,216,150,83,21^255,147,87,104,70,105,139,172,204,210,191,137,99,141,96,60,34,59,71,52,54,112,252,221,192,127)
+_pal_au15:(102,0,51,85,136,170,187,255,255,85,153,102,187,68,17^102,17,17,0,34,102,153,221,255,85,153,119,221,51,34^119,34,17,0,17,34,119,187,238,51,68,170,255,68,68)
+_pal_au15y:(85,136,204,221,255,221,153,85,255,187,102,102,68,34,17^0,34,136,187,221,204,153,85,255,221,119,102,51,51,17^0,17,68,153,187,119,68,51,238,255,170,119,68,85,34)
+_pal_jerrypie22:(30,36,55,156,220,196,147,121,82,157,118,41,52,64,114,83,207,224,210,53,25,85^36,81,150,198,239,215,121,65,60,125,68,71,119,213,178,137,190,110,57,41,23,46^49,104,155,217,248,164,70,34,32,174,110,45,80,142,69,71,91,54,28,29,22,65)
+_pal_naji16:(16,61,100,72,63,106,116,89,183,141,100,192,200,220,242,230^26,14,17,46,66,52,67,85,62,109,150,113,146,162,201,209^58,38,61,105,90,101,74,121,98,156,124,159,108,134,102,213)
+_pal_blessing:(116,150,247,255,216^86,251,255,179,191^155,199,174,203,216)
+_pal_crayola:(142,202,255,252,147,181,2,0,255^49,52,145,214,223,179,164,70,255^121,53,164,103,184,92,211,140,255)
+_pal_easter:(246,230,134,121,245,237,204,202,57,141,129,104,157,126,86,5^246,209,134,71,225,195,141,101,212,188,132,96,192,167,120,22^191,209,145,101,122,141,134,126,185,210,171,134,133,136,100,37)
+_pal_fairy:(14,210,77,255,75,131,112,173^48,0,217,230,49,96,143,184^166,0,40,0,89,111,77,112)
+_pal_fuzz4:(48,255,0,255^35,55,250,253^135,150,172,175)
+_pal_xdb_01:(32,64,150,220,255,156,217,242,247,82,195,48,99,157,74,153,255^32,64,150,220,255,31,122,187,237,202,217,153,226,182,82,54,89^64,96,150,192,230,46,70,104,124,100,76,156,212,255,194,151,136)
+_pal_ocaso:(75,126,207,243,250,185,126,82,76,118,98,203,254,255,191,152,146^65,89,104,147,218,199,182,166,119,109,87,129,142,249,240,184,153^74,86,90,106,109,115,120,126,104,109,96,119,143,187,240,209,173)
+_pal_pastel:(252,252,250,255,247,163,128,87,81,112,109,88,132,190,222^153,189,230,247,246,217,217,207,192,165,116,68,89,87,118^119,144,170,213,166,106,155,201,219,212,207,120,201,194,165)
+_pal_pastel17:(55,104,94,37,17,105,239,248,163,109,161,249,200,247,155,28,89^50,53,107,113,171,246,240,229,231,68,101,139,76,145,156,134,177^84,111,130,140,190,191,215,116,92,66,87,183,102,82,130,109,94)
+_pal_pollen8:(115,171,238,255,255,255,114,52^70,86,106,167,224,231,220,172^76,117,124,165,126,214,187,186)
+_pal_nopal:(226,197,168,146,255,251,241,204,241,228,202,171^228,207,181,146,236,212,180,163,234,219,193,164^223,196,174,156,237,210,180,163,182,160,138,123)
+_pal_sy17:(253,37,128,187,111,57,62,76,153,218,193,179,102,2,68,144,198^253,42,128,191,160,114,93,143,191,213,162,112,64,2,64,95,141^248,140,128,221,192,190,88,73,105,115,167,182,150,7,34,63,65)
+_pal_syz15:(14,157,242,176,201,216,82,14,104,141,18,83,34,18,34^12,31,140,86,173,225,180,79,6,90,111,38,20,47,52^25,47,140,33,35,169,102,56,47,136,126,154,82,112,33)
+_pal_tui15:(29,19,23,70,120,16,21,162,43,240,178,197,240,124,226^13,34,55,58,77,66,112,109,161,176,162,180,194,219,231^13,66,39,49,48,172,155,61,195,63,131,208,152,207,249)
+_pal_cave:(0,16,54,68,143,199,156,245^0,0,29,63,86,144,228,245^0,41,35,79,179,101,199,245)
+_pal_psygnosia:(0,27,54,68,82,100,115,119,158,203,224,162,0,8,84,81^0,30,39,63,82,100,97,120,164,232,139,50,51,74,106,108^0,41,71,65,76,124,80,91,167,247,121,78,8,60,0,191)
+_pal_marshmellow32:(43,58,87,140,63,85,118,164,89,115,140,184,193,175,144,113,60,84,161,182,226,178,124,75,60,78,110,143,32,35,45,94^63,83,121,166,62,87,127,171,50,65,80,122,188,164,123,85,60,74,98,130,181,178,124,80,58,60,77,97,65,91,128,179^65,86,125,151,32,53,69,121,52,65,77,102,172,145,103,74,60,68,59,65,95,178,124,83,63,92,126,154,91,124,166,188)
+_pal_rabbit7:(212,232,236,79,170,59,92^117,196,236,164,211,50,97^100,152,224,165,149,74,130)
+_pal_finlal11:(23,83,34,175,59,35,159,136,189,203,228^20,12,53,52,102,132,132,158,160,201,229^25,30,85,81,136,51,116,183,188,144,241)
+_pal_vinik24:(0,111,154,197,139,195,165,102,154,194,124,65,141,190,104,56,110,147,110,85,157,126,93,67^0,103,154,204,85,136,147,96,79,141,161,106,98,149,172,112,105,161,170,112,159,158,104,52^0,118,151,184,128,144,165,146,80,117,192,163,104,92,169,128,98,103,120,100,127,153,114,85)
+_pal_ykb22:(207,156,40,72,128,184,210,210,231,128,116,104,74,83,165,141,71,64,174,207,138,169^207,156,37,46,74,146,183,194,229,120,91,74,104,161,199,169,126,72,134,157,95,119^201,151,42,43,62,134,174,174,209,104,65,69,93,112,135,174,136,89,178,185,103,119)
+_pal_graveyard:(133,163,190,138,118,27,48,69,91,117,143,166,141,118,101,79,108,123,131,159,189^122,138,181,105,91,26,45,60,77,99,122,147,127,116,104,85,111,132,135,168,201^104,121,144,102,98,31,51,73,94,118,141,160,152,136,111,79,101,122,152,179,206)
+_pal_steamlords:(33,58,79,161,119,119,96,59,23,47,67,79,101,124,160,192^59,96,119,159,116,92,59,33,14,33,58,82,115,148,185,209^37,74,84,124,79,79,58,55,25,59,96,119,140,161,186,204)
+_pal_aaprad:(7,33,82,138,193,234,160,83,66,89,107,184,121,87,148^5,25,58,107,156,219,179,124,60,111,185,170,112,98,91^5,25,42,62,77,116,53,68,86,175,182,176,126,122,40)
+_pal_aapmaj:(244,177,109,49,15,118,173,212,234,151,88,43,56,44,108,118,196^243,137,83,35,12,38,80,147,207,171,120,64,78,153,220,56,84^222,97,79,44,15,38,35,34,90,57,42,36,150,204,213,88,113)
+_pal_daruda:(222,15,35,64,86,112,109,129,146,159,176,185,191,207,213,224,232,232,231,231,232,231^229,14,10,0,0,13,41,50,61,74,83,105,129,146,166,188,207,227,232,160,169,181^217,19,41,45,44,26,28,33,19,20,2,21,9,19,39,37,80,111,141,121,163,198)
+_pal_rust6:(35,113,165,225,240,255^0,47,73,136,187,226^0,48,50,102,156,198)
+_pal_xaiue_rad:(241,222,199,140,124,108,69,44,106,173,222,163,204,123,73,22,45,62,118,169,161,95^239,215,164,123,90,71,56,30,103,139,213,121,188,108,71,18,47,79,130,172,148,102^183,92,57,38,38,43,29,18,58,69,170,99,142,92,63,18,59,128,158,183,143,121)
+_pal_firestorm:(27,70,249,253,236,255,255,253,255^32,52,94,75,103,132,161,222,236^50,74,62,53,86,95,95,133,179)
+_pal_supernova7:(26,61,84,119,167,207,255^8,32,50,58,82,120,206^14,59,70,77,82,98,156)
+_pal_nyx8:(8,15,32,246,195,153,129,78^20,42,57,214,163,117,98,73^30,63,79,189,138,119,113,95)
+_pal_oil6:(39,73,139,198,242,251^39,77,109,159,211,245^68,126,156,165,171,239)
+_pal_sgm:(17,51,68,102,102,119,187,221,255,255,255,255,255,187,119,170,221^17,17,34,68,85,136,187,221,238,238,204,136,51,68,68,102,153^17,51,85,119,187,255,255,255,255,153,102,119,136,102,85,102,136)
+_pal_fornaxvoid1:(122,117,112,108,103,99,94,89,85,80,76,71,66,62,57,53,47,55,63,70,78,86,93,101,109,116,124,132,139,147,155,162,0,7,13,20,26,32,39,45,52,58,64,71,77,84,90,96,240,224,208,192,176,160,144,128,112,96,80,64,48,32,16,0,255,242,230,218,206,194,181,169,157,145,133,120,108,96,84,72,243,231,219,208,196,185,173,161,150,138,127,115,103,92,80,69,255,255,255,255,255,255,255,255,224,192,160,128,96,64,48,32,216,196,176,157,137,117,98,78,58,39,19,0,0,0,0,0,255,238,221,204,187,170,153,136,119,102,85,68,51,34,17,0,0,5,9,13,18,22,26,30,35,39,43,47,52,56,60,64,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,238,221,204,187,170,153,136,119,102,85,68,51,34,17,0,0,16,31,46,61,76,91,106,122,137,152,167,182,197,212,227,255,242,229,217,204,192,176,160,128,96,80,64,48,40,32,16,166,178,189,200,211,222,233,244,255,218,182,145,109,72,36,0,227,211,196,181,166,151,136,121,105,90,75,60,45,30,15,0^37,42,47,51,56,60,65,70,74,79,83,88,93,97,102,106,222,214,206,198,190,182,174,166,158,150,142,134,126,118,110,102,204,195,186,177,168,160,151,142,133,124,116,107,98,89,80,72,240,233,226,220,213,206,200,193,186,180,173,166,160,153,146,140,255,242,230,218,206,194,181,169,157,145,133,120,108,96,84,72,142,136,130,124,118,112,106,100,94,88,82,76,70,64,58,53,216,194,172,150,128,96,64,0,0,0,0,0,0,0,0,0,216,196,176,157,137,117,98,78,58,39,19,0,0,0,0,0,43,40,38,36,34,32,30,28,25,23,21,19,17,15,13,11,0,5,9,13,18,22,26,30,35,39,43,47,52,56,60,64,255,240,225,210,195,180,165,150,136,121,106,91,76,61,46,32,160,157,155,153,151,149,147,145,142,140,138,136,134,132,130,128,0,9,18,27,36,45,54,63,72,81,90,99,108,117,126,134,192,172,153,134,115,96,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,227,211,196,181,166,151,136,121,105,90,75,60,45,30,15,0^255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,235,242,249,255,255,255,255,255,255,255,255,255,255,255,255,255,204,208,211,215,218,221,225,228,232,235,238,242,245,249,252,255,240,233,226,220,213,206,200,193,186,180,173,166,160,153,146,140,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,224,192,160,128,96,64,48,32,255,247,240,232,225,217,210,202,195,187,180,173,145,118,91,64,255,246,238,229,221,212,204,195,187,178,170,161,153,144,136,128,0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,255,240,225,210,195,180,165,150,136,121,106,91,76,61,46,32,255,246,238,229,221,212,204,195,187,178,170,161,153,144,136,128,0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,255,255,255,255,255,255,255,255,232,208,192,128,96,80,64,48,255,223,191,159,127,95,63,31,0,10,19,28,37,46,55,64,255,240,225,210,195,180,165,150,136,121,106,91,76,61,46,32)
+_pal_fornaxvoid2:(32,48,64,96,128,160,192,224,255,255,255,255,255,255,255,255,16,32,40,48,64,80,96,128,160,176,192,204,217,229,242,255,69,80,92,103,115,127,138,150,161,173,185,196,208,219,231,243,255,238,221,204,187,170,153,136,119,102,85,68,51,34,17,0,32,64,128,192,255,255,255,255,0,0,0,0,1,128,192,232,0,0,0,0,32,64,128,160,192,216,36,72,109,145,182,218,0,0,0,0,0,1,32,64,128,192,224,255,0,0,0,0,0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255^0,0,0,0,0,0,0,0,0,64,96,128,150,172,194,216,0,0,0,0,0,0,0,0,0,48,96,115,134,153,172,192,53,58,64,70,76,82,88,94,100,106,112,118,124,130,136,142,154,155,156,158,159,161,162,163,165,166,168,169,170,172,173,175,0,0,0,0,0,128,192,232,32,64,128,192,255,255,255,255,0,0,0,0,32,64,128,160,192,216,0,0,0,0,0,0,32,64,128,192,224,255,32,64,128,192,224,255,25,51,76,102,0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255^32,48,64,96,128,160,192,224,255,255,255,255,255,255,255,255,48,64,80,96,128,192,208,232,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,250,244,238,233,227,221,216,210,204,199,193,187,182,176,170,0,0,0,0,0,128,192,232,0,0,0,0,0,128,192,232,64,128,192,255,255,255,255,255,255,255,219,183,146,110,73,37,32,64,128,192,224,255,0,0,0,0,0,0,230,205,179,154,0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255)
+_pal_pixelwave:(28,82,136,166,145,117,90,82,123,171,213,255^5,14,23,37,59,82,105,131,163,196,225,255^41,117,194,249,255,255,255,255,255,255,255,255)
+_pal_spaceyeaster:(32,79,207,101,127,225,125,54,154,78,171,229,182,66,53,132,65^28,75,42,54,123,77,72,48,26,43,162,109,133,25,24,201,132^52,88,131,125,141,157,152,66,95,97,191,174,207,47,68,245,175)
+_pal_moon39:(126,159,188,42,42,44,38,131,52,36,54,33,40,26,54,32,71,125,88,76,61,56,63,21,113,112,104,127,101,53,128,103,66,40,36,17,104,137,39^177,211,221,129,106,90,103,204,166,75,105,65,79,51,61,63,71,219,110,103,104,96,112,84,184,181,172,205,169,119,209,178,129,98,84,54,179,221,72^213,249,244,152,152,122,103,194,196,103,73,89,107,70,84,86,76,206,103,108,110,98,122,80,161,157,156,173,154,105,174,155,124,107,103,82,156,181,97)
+_pal_pet8:(10,24,39,71,123,197,239,248^10,27,47,83,128,175,217,244^16,34,59,78,70,99,141,228)
+_pal_pet8d:(7,13,22,39,75,119,160,187^8,15,28,43,74,97,124,154^16,17,32,41,39,49,67,103)
+_pal_autochrome3:(88,31,223^66,106,85^147,56,41)
+_pal_autochrome5:(88,31,223,126,13^66,106,85,141,203^147,56,41,227,163)
+_pal_gb_d_1:(51,166,214,247^30,55,142,231^80,37,73,198)
+_pal_gb_d_2:(8,52,136,224^24,104,192,248^32,86,112,208)
+_pal_gb_andrade:(32,94,174,227^32,103,186,238^32,69,137,192)
+_pal_gb_blue:(208,112,60,28^244,176,52,8^248,192,104,32)
+_pal_gb_bz:(46,56,87,126^70,93,123,132^61,73,70,22)
+_pal_gb_crimson:(27,122,186,239^3,28,80,249^38,75,68,214)
+_pal_gb_didi:(33,58,119,220^11,101,175,254^46,90,104,207)
+_pal_gb_dirty:(196,139,77,31^207,149,83,31^161,109,60,31)
+_pal_gb_arne:(36,63,118,172^49,80,132,181^55,63,72,107)
+_pal_gb_easy:(0,13,161,235^67,136,188,221^51,51,0,119)
+_pal_gb_forest:(90,107,123,255^57,140,198,255^33,66,123,181)
+_pal_gb_hg:(23,55,106,190^40,109,180,235^8,3,23,113)
+_pal_gb_lg:(244,104,30,5^251,207,145,36^208,104,120,31)
+_pal_gb_nostalgia:(208,160,112,64^208,168,128,80^88,64,40,16)
+_pal_gb_platinum:(24,80,168,224^48,120,192,240^48,104,176,232)
+_pal_gb_kirokaze:(51,70,148,226^44,135,227,243^80,143,68,228)
+_pal_gb_pj:(31,77,139,196^31,83,149,207^31,60,109,161)
+_pal_gb_cyber:(16,66,111,206^37,103,158,206^51,142,223,206)
+_pal_gb_wish:(98,117,96,139^46,80,143,229^76,232,207,255)
+_pal_gb_grapefruit:(101,183,244,255^41,101,178,245^108,145,107,221)
+_pal_gb_ice_cream:(124,235,249,255^63,107,168,246^88,111,117,211)
+_pal_gb_rb:(24,132,247,255^16,115,181,239^16,156,140,255)
+_pal_gb_space:(11,107,204,248^6,31,52,227^48,177,149,196)
+_pal_gb_choco:(255,220,169,66^228,164,96,41^194,86,76,54)
+_pal_gb_purpdawn:(0,45,154,238^27,117,123,253^46,126,188,237)
+_pal_gb_gray:(43,112,168,224^43,107,159,219^38,102,148,205)
+_pal_arne4:(0,0,184,175^0,81,75,216^0,156,18,79)
+_pal_hal4:(48,96,248,248^0,40,144,240^48,120,32,136)
+_pal_amiga2600ntsc:(252,232,208,184,160,132,100,68,44,76,104,132,156,180,204,224,200,180,156,132,108,80,52,20,0,32,64,92,116,140,164,184,164,144,124,104,80,56,28,0,0,28,56,80,104,124,144,164,164,144,124,104,80,56,28,0,0,28,56,80,104,124,144,164,188,168,148,124,104,76,48,20,72,96,120,140,160,180,196,212,236,220,208,192,176,160,140,120,136,156,176,192,208,224,236,252,252,236,224,208,192,172,152,132,112,132,152,172,188,204,220,232,252,232,208,184,160,132,100,68,0,64,108,144,176,200,220,236^224,204,180,156,132,104,72,40,48,80,112,140,168,192,212,236,252,228,204,180,152,124,92,56,60,92,124,156,180,208,228,252,252,228,208,180,156,124,92,64,44,76,104,132,156,180,204,224,200,180,156,136,112,84,56,24,0,32,64,92,116,140,164,184,180,160,136,112,88,60,32,0,0,32,60,88,112,132,156,176,176,156,132,112,88,60,32,0,0,32,60,88,112,136,160,180,188,168,148,128,104,80,52,24,40,68,92,120,140,160,180,204,252,232,208,184,160,132,100,68,0,64,108,144,176,200,220,236^140,124,108,88,68,48,24,0,0,28,52,76,100,120,136,156,164,144,124,104,80,56,28,0,0,32,64,92,116,140,164,184,212,192,172,148,128,100,72,44,92,120,144,172,192,212,232,252,252,236,220,204,188,168,144,124,136,156,176,192,208,224,236,252,252,236,224,208,192,172,152,132,120,144,164,184,204,220,236,252,224,208,192,176,156,136,116,92,0,32,60,88,112,136,160,180,148,128,112,92,72,48,24,0,0,20,40,60,76,92,104,124,104,92,80,64,52,36,16,0,0,64,108,144,176,200,220,236)
+_pal_amiga2600pal:(112,136,160,180,200,220,236,252,224,208,196,180,168,148,132,112,88,108,128,148,164,180,196,212,200,184,168,148,128,108,84,60,0,32,60,88,112,132,156,176,164,144,124,104,80,56,28,0,0,28,56,80,104,124,144,164,176,156,132,112,88,60,32,0,0,32,60,88,112,132,156,176,212,192,176,160,140,116,92,68,128,148,168,188,204,220,236,252,252,236,220,200,180,160,136,112,0,64,108,144,176,200,220,236^0,32,60,88,112,132,156,176,176,156,132,112,88,60,32,0,0,32,60,88,112,132,156,176,176,156,132,112,88,60,32,0,0,32,60,88,112,132,156,176,200,180,160,136,116,88,60,32,60,88,116,140,164,184,204,224,236,220,200,184,164,140,116,92,100,128,152,176,196,216,232,252,252,232,212,192,172,144,120,92,88,112,132,156,172,192,208,224,212,192,172,152,132,104,80,52,0,64,108,144,176,200,220,236^20,52,80,108,132,156,180,200,224,208,192,176,156,136,116,92,112,136,160,180,200,220,236,252,252,236,220,204,188,168,148,128,136,156,176,192,208,224,236,252,252,236,220,200,180,160,136,112,112,136,160,180,200,220,236,252,236,220,200,184,164,140,116,92,20,52,80,108,132,156,180,200,176,156,132,112,88,60,32,0,0,32,60,88,112,132,156,176,176,156,132,112,88,60,32,0,0,64,108,144,176,200,220,236)
+_pal_amiga2600secam:(0,33,240,255,127,127,255,255^0,33,60,80,255,255,255,255^0,255,121,255,0,255,63,255)
+_pal_amiga7800mess:(1,46,61,89,119,132,160,183,205,216,221,224,234,240,246,255,255,254,255,254,255,255,255,255,255,255,216,187,153,119,84,65,71,114,160,179,200,228,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,253,243,231,212,191,176,157,122,95,75,127,179,200,223,237,251,252,254,255,255,255,255,255,255,255,254,255,255,255,255,251,239,228,215,202,187,170,149,129,103,74,73,92,101,122,146,157,166,177,188,196,206,213,218,222,225,230,205,192,176,159,152,144,128,113,101,90,79,68,37,9,6,5,12,32,54,70,87,97,109,123,137,145,157,167,178,187,195,211,208,195,175,155,147,141,112,86,77,73,51,29,29,30,29,29,2,2,1,2,2,2,1,1,27,62,101,118,138,155,177,199,208,200,182,162,134,125,115,82,78,55,40,25,15,4,0,0,22,28,35,40,46,58,71,81,93,113,133,141,151,165,184,185,242,232,219,206,194,184,171,158,139,121,108,96,72,69,57,44,70,76,85,109,144,172,194,209,223,231,238,247,253,255,255,255,254,254,254,254,252,249,237,225,208,191,181,171,141,113,88,65^1,46,61,89,119,132,160,183,205,216,221,224,234,240,246,255,255,255,249,244,230,216,208,197,171,145,128,104,79,55,40,32,25,30,37,57,81,106,130,140,153,174,196,197,198,214,228,231,218,209,194,178,164,152,138,121,110,98,78,54,47,43,36,31,23,26,29,33,37,60,82,96,112,127,144,158,170,185,200,202,184,175,165,157,141,126,114,103,90,77,61,45,24,3,1,1,3,4,14,35,59,69,79,90,101,109,118,131,144,156,170,182,211,203,190,178,170,160,146,131,117,104,90,76,61,48,38,30,8,28,49,66,83,93,105,119,133,141,152,164,175,184,193,209,237,233,228,223,220,216,198,182,169,154,134,113,92,73,56,41,76,93,112,132,153,171,188,207,220,225,231,234,237,240,243,246,255,255,255,255,236,227,217,205,186,164,147,127,117,107,84,72,64,83,102,120,140,152,165,175,187,207,227,235,245,255,255,255,255,252,239,225,214,204,191,178,159,141,127,113,86,82,68,53,58,63,70,88,118,140,161,176,190,198,205,218,230,242,249,249,212,203,198,193,183,173,160,147,133,119,100,81,58,37,31,26^1,46,61,89,119,132,160,183,205,216,221,224,234,240,246,255,172,153,120,86,81,77,60,29,29,30,23,24,16,6,1,0,4,17,30,33,34,32,31,37,45,56,84,89,109,136,162,171,209,196,179,158,139,125,105,85,75,63,43,36,15,16,13,14,4,13,23,25,28,57,85,97,99,126,143,159,173,190,206,222,236,234,232,230,226,218,206,195,182,169,154,137,116,96,75,55,109,136,145,166,190,201,210,221,232,240,249,255,255,254,254,255,255,255,255,255,255,255,255,255,255,255,237,222,213,202,165,131,121,141,163,179,196,207,218,232,247,254,255,255,254,255,255,255,255,254,254,254,254,255,254,255,236,217,207,199,172,147,119,92,90,111,132,156,182,202,221,244,255,254,255,254,255,255,255,254,208,200,182,162,134,125,115,82,77,55,39,25,15,4,0,0,0,0,1,1,0,12,25,35,47,67,87,95,105,150,151,151,171,121,108,84,83,73,60,47,28,10,1,0,0,0,0,0,9,10,9,9,8,11,32,47,61,69,77,101,125,164,197,212,152,131,113,96,92,89,78,68,58,48,39,31,19,8,5,3)
+_pal_amiga7800:(0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,255,255,247,230,213,196,179,162,145,128,111,94,77,60,43,26,49,66,83,100,117,134,151,168,185,202,219,236,253,255,255,255,255,255,255,255,249,232,215,198,181,164,147,130,113,96,79,62,63,80,97,114,131,148,165,182,199,216,233,250,255,255,255,255,255,255,255,255,238,221,204,187,170,153,136,119,102,85,68,51,29,46,64,81,98,115,132,149,166,183,200,217,233,251,255,255,255,240,223,206,189,172,155,138,121,104,87,70,53,36,19,2,0,0,8,25,42,59,76,93,110,127,144,161,178,195,212,229,206,189,172,155,138,121,104,87,70,53,36,19,2,0,0,0,0,0,0,0,6,23,40,57,74,91,108,125,142,159,176,193,192,175,158,141,124,107,90,73,56,39,22,5,0,0,0,0,0,0,0,0,16,33,50,67,84,101,118,135,152,169,186,203,225,208,191,174,157,140,123,106,89,72,55,38,21,4,0,0,0,14,31,48,65,82,99,116,133,150,167,184,201,218,235,252,255,255,246,229,212,195,178,161,144,127,110,93,76,59,42,25^0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,247,245,228,211,194,177,160,143,126,109,92,75,58,41,24,7,0,6,23,40,57,74,91,108,125,142,159,176,193,210,227,244,229,212,195,178,161,144,127,110,93,76,59,42,25,8,0,0,0,0,0,15,32,49,66,83,100,117,134,151,168,185,202,219,216,199,182,165,148,131,114,97,80,63,46,29,12,0,0,0,0,0,0,16,33,50,67,84,101,118,135,152,169,186,203,220,232,215,198,181,164,147,130,113,96,79,62,45,28,11,0,0,0,10,27,44,61,78,95,112,129,146,163,180,197,214,231,248,255,248,231,214,197,180,163,146,129,112,95,78,61,44,27,10,26,43,60,77,94,111,128,145,162,179,196,213,230,247,255,255,255,255,255,240,223,206,189,172,155,138,121,104,87,70,53,36,39,56,73,90,107,124,141,158,175,192,209,226,243,255,255,255,255,255,255,239,222,205,188,171,154,137,120,103,86,69,52,35,23,40,57,74,91,108,125,142,159,176,193,210,227,244,255,255,255,245,228,211,194,177,160,143,126,109,92,75,58,41,24,7^0,17,34,51,68,85,102,119,136,153,170,187,204,221,238,255,151,131,111,94,77,60,43,26,9,0,0,0,0,0,0,0,0,0,0,0,0,0,10,27,44,61,78,95,112,133,156,178,218,196,174,152,131,115,98,81,64,47,30,13,0,0,0,0,3,15,27,43,60,77,94,111,128,145,162,179,200,222,239,244,243,238,233,228,228,211,194,177,160,143,126,109,92,76,65,53,92,104,116,132,149,166,183,200,217,234,235,235,236,235,239,244,248,247,247,247,247,247,247,242,225,208,191,174,157,140,125,113,104,124,144,161,178,195,212,229,246,255,255,255,255,255,255,255,255,255,255,255,255,255,245,228,211,194,177,160,143,121,99,77,38,60,82,104,124,141,158,175,192,209,226,243,255,255,255,255,253,241,229,213,196,179,162,145,128,111,94,77,56,34,16,11,12,17,22,27,27,44,61,78,95,112,129,146,163,179,191,203,163,151,139,122,105,88,71,54,37,20,19,19,19,19,16,10,7,8,8,8,8,8,8,13,30,47,64,81,98,115,130,142,150,130,111,94,77,60,43,26,9,0,0,0,0,0,0,0)
+_pal_amstrad_cpc:(0,128,255,128,255,255,255,255,255,128,0,0,128,128,0,0,0,128,0,0,128,128,255,255,255,128,0^0,128,255,0,0,128,128,255,255,128,128,255,255,255,255,128,255,255,128,0,0,128,128,0,0,0,0^0,128,255,0,0,128,0,128,0,0,0,0,0,128,128,128,255,255,255,128,255,255,255,255,128,128,255)
+_pal_apple2:(0,81,132,234,81,232,245,0,0,145,201,0,152,200,255^0,92,61,125,72,93,183,103,200,145,209,166,219,193,255^0,22,82,39,136,239,201,82,44,145,153,240,201,247,255)
+_pal_cga:(0,85,170,255,0,85,0,85,0,85,170,255,170,255,170,255^0,85,170,255,0,85,170,255,170,255,0,85,0,85,85,255^0,85,170,255,170,255,0,85,170,255,0,85,170,255,0,85)
+_pal_cga00:(0,0,170,170^0,170,0,85^0,0,0,0)
+_pal_cga01:(0,85,255,255^0,255,85,255^0,85,85,85)
+_pal_cga10:(0,170,0,170^0,0,170,170^0,170,170,170)
+_pal_cga11:(0,255,85,255^0,85,255,255^0,255,255,255)
+_pal_cga20:(0,170,0,170^0,0,170,170^0,0,170,170)
+_pal_cga21:(0,255,85,255^0,85,255,255^0,85,255,255)
+_pal_c64_pepto:(0,98,137,173,255,159,203,109,161,201,154,92,106,136,80,160^0,98,137,173,255,78,126,84,104,212,226,171,191,126,69,87^0,98,137,173,255,68,117,18,60,135,155,94,198,203,155,163)
+_pal_c64_colodore:(0,74,123,178,255,129,196,85,142,237,169,86,117,112,46,142^0,74,123,178,255,51,108,56,80,241,255,172,206,109,44,60^0,74,123,178,255,56,113,0,41,113,159,77,200,235,155,151)
+_pal_com_vic_20:(0,255,168,233,119,182,133,197,168,233,85,146,66,126,189,255^0,255,115,178,45,104,212,255,95,157,158,223,52,112,204,255^0,255,74,135,38,98,220,255,180,245,74,135,139,202,113,176)
+_pal_colecovision:(0,33,66,41,90,156,57,214,255,222,214,24,214,206,255^0,173,214,49,115,41,231,57,115,231,214,123,49,206,255^0,24,90,214,255,24,247,33,90,41,123,16,231,206,255)
+_pal_jmp:(0,25,70,161,69,118,131,158,220,225,214,233,33,211,175,245^0,16,175,214,62,100,49,194,83,141,185,216,108,101,170,244^0,40,69,133,120,254,41,232,75,121,123,161,75,200,185,235)
+_pal_mac2:(255,255,255,220,255,54,0,0,0,0,101,151,185,134,69,0^255,255,101,0,0,0,0,151,168,101,54,101,185,134,69,0^255,0,0,0,151,151,202,255,0,0,0,54,185,134,69,0)
+_pal_nes:(0,252,248,188,124,164,60,0,0,184,104,0,0,216,152,104,68,248,248,216,148,248,248,228,168,240,248,248,168,252,252,228,136,248,248,172,80,216,184,0,0,184,88,0,0,184,88,0,0,0,0,0,0,248,120^0,252,248,188,124,228,188,120,0,184,136,88,0,184,120,68,40,184,120,0,0,164,88,0,0,208,120,56,16,224,160,92,20,216,184,124,48,248,248,184,120,248,216,168,104,248,248,168,88,252,232,136,64,216,120^0,252,248,188,124,252,252,248,252,248,252,248,188,248,248,252,188,248,248,204,132,192,152,88,32,176,88,0,0,168,68,16,0,120,0,0,0,120,24,0,0,184,84,0,0,216,152,68,0,252,216,136,88,248,120)
+_pal_pico_8:(0,95,194,255,255,255,255,171,255,255,131,126,41,29,0,0^0,87,195,241,236,163,204,82,119,0,118,37,173,43,135,228^0,79,199,232,39,0,170,54,168,77,156,83,255,83,81,54)
+_pal_risc:(255,220,185,151,118,85,54,0,0,237,5,220,237,85,255,4^255,220,185,151,118,85,54,0,69,237,202,0,237,134,185,185^255,220,185,151,118,85,54,0,151,4,0,0,185,0,0,255)
+_pal_samcoupe:(0,0,73,73,0,0,73,73,36,36,109,109,36,36,109,109,0,0,73,73,0,0,73,73,36,36,109,109,36,36,109,109,146,146,219,219,146,146,219,219,182,182,255,255,182,182,255,255,146,146,219,219,146,146,219,219,182,182,255,255,182,182,255,255,0,0,73,73,0,0,73,73,36,36,109,109,36,36,109,109,0,0,73,73,0,0,73,73,36,36,109,109,36,36,109,109,146,146,219,219,146,146,219,219,182,182,255,255,182,182,255,255,146,146,219,219,146,146,219,219,182,182,255,255,182,182,255,255^0,0,0,0,73,73,73,73,36,36,36,36,109,109,109,109,0,0,0,0,73,73,73,73,36,36,36,36,109,109,109,109,0,0,0,0,73,73,73,73,36,36,36,36,109,109,109,109,0,0,0,0,73,73,73,73,36,36,36,36,109,109,109,109,146,146,146,146,219,219,219,219,182,182,182,182,255,255,255,255,146,146,146,146,219,219,219,219,182,182,182,182,255,255,255,255,146,146,146,146,219,219,219,219,182,182,182,182,255,255,255,255,146,146,146,146,219,219,219,219,182,182,182,182,255,255,255,255^0,73,0,73,0,73,0,73,36,109,36,109,36,109,36,109,146,219,146,219,146,219,146,219,182,255,182,255,182,255,182,255,0,73,0,73,0,73,0,73,36,109,36,109,36,109,36,109,146,219,146,219,146,219,146,219,182,255,182,255,182,255,182,255,0,73,0,73,0,73,0,73,36,109,36,109,36,109,36,109,146,219,146,219,146,219,146,219,182,255,182,255,182,255,182,255,0,73,0,73,0,73,0,73,36,109,36,109,36,109,36,109,146,219,146,219,146,219,146,219,182,255,182,255,182,255,182,255)
+_pal_mo5:(0,187,255,221,238,255,221,0,119,0,187,255,255,221,0,119^0,187,0,119,187,255,221,255,221,255,255,255,0,119,0,119^0,187,0,119,0,0,119,0,119,255,255,255,255,238,255,221)
+_pal_vga:(0,0,0,0,170,170,170,170,85,85,85,85,255,255,255,255,16,32,53,69,101,117,138,154,186,202,223,239,0,65,130,190,255,255,255,255,255,255,255,255,255,190,130,65,1,1,1,1,1,0,0,0,130,158,190,223,255,255,255,255,255,255,255,255,255,223,190,158,130,130,130,130,130,130,130,130,186,202,223,239,255,255,255,255,255,255,255,255,255,239,223,202,186,186,186,186,186,186,186,186,0,28,57,85,113,113,113,113,113,113,113,113,113,85,57,28,0,0,0,0,0,0,0,0,57,69,85,97,113,113,113,113,113,113,113,113,113,97,85,69,57,57,57,57,57,57,57,57,81,89,97,105,113,113,113,113,113,113,113,113,113,105,97,89,81,81,81,81,81,81,81,81,0,16,32,49,65,65,65,65,65,65,65,65,65,49,32,16,0,0,0,0,0,0,0,0,32,40,49,57,65,65,65,65,65,65,65,65,65,57,49,40,32,32,32,32,32,32,32,32,45,49,53,61,65,65,65,65,65,65,65,65,65,61,53,49,45,45,45,45,45,45,45,45^0,0,170,170,0,0,85,170,85,85,255,255,85,85,255,255,16,32,53,69,101,117,138,154,186,202,223,239,0,0,0,0,0,0,0,0,0,65,130,190,255,255,255,255,255,255,255,255,255,190,130,65,130,130,130,130,130,130,130,130,130,158,190,223,255,255,255,255,255,255,255,255,255,223,190,158,186,186,186,186,186,186,186,186,186,202,223,239,255,255,255,255,255,255,255,255,255,239,223,202,0,0,0,0,0,0,0,0,0,28,57,85,113,113,113,113,113,113,113,113,113,85,57,28,57,57,57,57,57,57,57,57,57,69,85,97,113,113,113,113,113,113,113,113,113,97,85,69,81,81,81,81,81,81,81,81,81,89,97,105,113,113,113,113,113,113,113,113,113,105,97,89,0,0,0,0,0,0,0,0,0,16,32,49,65,65,65,65,65,65,65,65,65,49,32,16,32,32,32,32,32,32,32,32,32,40,49,57,65,65,65,65,65,65,65,65,65,57,49,40,45,45,45,45,45,45,45,45,45,49,53,61,65,65,65,65,65,65,65,65,65,61,53,49^0,170,0,170,0,170,0,170,85,255,85,255,85,255,85,255,16,32,53,69,101,117,138,154,186,202,223,239,255,255,255,255,255,190,130,65,0,0,0,0,0,0,0,0,0,65,130,190,255,255,255,255,255,255,255,255,255,223,190,158,130,130,130,130,130,130,130,130,130,158,190,223,255,255,255,255,255,255,255,255,255,239,223,202,186,186,186,186,186,186,186,186,186,202,223,239,255,255,255,255,113,113,113,113,113,85,57,28,0,0,0,0,0,0,0,0,0,28,57,85,113,113,113,113,113,113,113,113,113,97,85,69,57,57,57,57,57,57,57,57,57,69,85,97,113,113,113,113,113,113,113,113,113,105,97,89,81,81,81,81,81,81,81,81,81,89,97,105,113,113,113,113,65,65,65,65,65,49,32,16,0,0,0,0,0,0,0,0,0,16,32,49,65,65,65,65,65,65,65,65,65,57,49,40,32,32,32,32,32,32,32,32,32,40,49,57,65,65,65,65,65,65,65,65,65,61,53,49,45,45,45,45,45,45,45,45,45,49,53,61,65,65,65,65)
+_pal_zx:(0,255,255,0,0,255,255,0,192,0,0,192,192,0,192^0,255,0,255,0,255,0,255,0,192,0,192,0,192,192^0,255,0,0,255,0,255,255,0,0,192,0,192,192,192)
+_pal_gnome32:(234,186,128,86,197,131,93,68,224,193,136,102,173,136,98,73,157,117,75,49,239,224,179,130,223,153,238,209,70,38,255,0^232,181,125,82,210,166,117,86,182,102,70,56,167,127,91,64,184,144,105,78,224,195,145,102,66,0,214,148,160,119,255,0^227,171,116,72,200,127,85,50,175,90,49,34,200,163,129,102,210,174,131,108,205,158,105,71,30,0,128,12,70,38,255,0)
+_pal_elc22:(0,85,168,255,168,254,168,254,254,168,255,4,6,4,6,0,0,0,118,168,254,254^0,69,168,255,0,0,85,118,168,168,255,168,255,168,255,118,0,0,0,0,0,0^0,85,168,255,0,0,0,0,118,0,4,0,4,168,255,255,168,255,255,168,255,118)
+_pal_chip16:(214,58,0,83,112,6,99,142,89,124,86,234,196,111,229,216^75,35,0,140,198,62,114,55,142,182,83,200,133,26,229,162^97,51,20,193,229,76,114,55,51,73,73,121,78,113,229,162)
+_pal_msx:(0,202,255,183,217,254,202,221,60,64,115,89,126,100,181^0,202,255,94,100,135,193,206,160,182,206,85,117,218,101^0,202,255,81,89,124,94,133,66,74,124,223,240,238,179)
+_pal_deluxepaint:(0,170,101,223,207,223,207,138,81,65,32,0,0,0,0,0,48,69,69,48,138,69,207,223,211,178,146,113,81,65,32,0,227,195,178,146,130,0,0,0,0,0,113,81,65,48,32,0,0,0,0,0,0,243,227,211,195,178,162,243,227,211,211,195,178,178,162,146,130,113,97,81,65,146,130,113,97,81,65,48,32,243,243,243,243,243,243,243,243,243,243,243,243,243,243,243,243,243,243,227,195,178,146,227,195,178,146,130,97,81,65,243,243,243,243,243,243,243,243,243,243,227,227,211,211,195,227,195,178,146,130,113,81,65,178,178,162,162,146,211,195,178,162,146,130,113,97,130,130,113,113,97,97,81,211,178,146,130,97,65,32,1,65,48,32,1,0,0,0,0,243,243,130,130,130,178,243,0,0,0,0,0,0,195,195,195,195,195,146,113,65,211,178,146,113,81,65,32,1,32,32,32,32,32,32,32,32,1,0,0,0,0,0,0,0,81,130,178,195,195,195,243^0,170,101,223,48,138,223,138,178,178,162,146,130,113,97,81,138,223,223,138,138,48,48,138,211,178,146,130,97,65,32,0,227,195,178,146,130,0,0,0,0,0,113,81,65,48,32,0,0,0,0,0,0,0,0,0,0,0,0,211,178,146,113,81,65,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,211,178,146,113,81,65,32,178,146,113,81,65,32,0,162,146,130,113,97,97,81,65,0,0,0,0,0,0,0,0,243,243,243,243,243,243,243,243,227,211,195,178,178,162,146,211,195,162,146,130,97,81,65,130,113,113,97,81,243,243,243,243,227,195,178,146,65,48,48,32,32,16,16,243,243,243,243,243,243,243,243,16,0,0,227,211,195,178,162,178,243,243,243,130,130,130,146,130,113,97,81,65,32,65,113,146,195,195,195,195,243,243,243,243,243,243,243,243,195,195,195,195,162,113,81,32,227,195,178,146,130,113,81,65,32,32,32,32,32,32,243^0,170,101,223,69,69,69,48,243,243,243,243,227,195,178,146,69,69,207,207,223,207,207,207,243,243,243,243,243,243,243,243,227,195,178,146,130,227,211,195,178,162,113,81,65,48,32,146,130,113,97,81,65,0,0,0,0,0,0,243,243,243,243,243,243,243,243,0,0,0,0,0,0,227,195,178,146,130,113,81,65,211,178,146,113,81,65,32,243,243,243,243,243,243,243,81,65,32,0,0,0,0,0,227,195,178,146,130,113,81,65,211,178,146,113,81,65,32,0,211,195,178,162,146,146,130,0,0,0,0,0,0,0,0,113,97,97,81,65,81,65,32,0,0,0,0,0,48,48,32,32,16,16,16,211,178,146,113,81,65,32,0,0,0,0,0,0,0,0,0,130,130,130,243,243,243,243,0,0,0,0,0,0,32,32,32,32,32,32,32,32,243,243,243,243,243,243,243,243,48,81,130,178,195,195,195,195,227,195,178,146,130,113,81,65,195,195,195,162,130,81,243)
+_pal_lms:(0,126,190,255,126,254,4,6,255,126,0,0,126,254,4,6^0,126,190,255,0,0,126,255,255,126,0,0,0,0,126,255^0,126,190,255,0,0,0,4,4,0,126,255,126,255,126,255)
+_pal_msxp:(0,128,192,255,128,255,128,255,0,0,0,0,0,0,128,255,128,255,0,0,0,128,0,128,128,255,128,255^0,128,192,255,0,0,128,255,128,255,128,255,0,0,0,0,128,255,64,255,128,255,64,128,0,0,64,128^0,128,192,255,0,0,0,0,0,0,128,255,128,255,128,255,64,128,64,128,255,255,128,255,255,128,0,64)
+_pal_vis:(0,70,120,180,220,255,153,156,237,255,255,229,255,245,255,255,168,211,34,157,0,153,77,112,47,84,111,181^0,70,120,180,220,255,0,90,28,163,126,170,194,228,242,249,230,249,177,187,183,217,109,154,54,109,49,165^0,70,120,180,220,255,48,60,36,177,0,122,14,156,0,189,29,188,76,97,239,234,243,209,153,142,152,213)
#@cli pal_t : eq. to 'palette_transfer'. : (+)
pal_t: palette_transfer $*
#@cli palette_transfer : 0<=_palette_id<=142,0<=_indexing_style<=4,0<=_color_dithering[%]<=1,_transfer_rgb={0=No | 1=Yes },0<=_alpha_count,0<=_alpha_dithering<=1,_special_effect_factor>=0,0<=_initial_resize_method<=5,_activate_upscaling_stimulation={ 0=Does not activate | 1=Activate Upscale},_pixel_width>=1,_pixel_height>=1,_activate_hardware_stimulation={ 0=Does not activate | 1= Stimulate hardware restriction },1<=_color_section_of_hardware_restriction_precision_factor,_hardware_restriction_by_tile_width>0,_hardware_restriction_by_tile_height>0,_hardware_color_precision>2,_hardware_color_mapping_method={0=Median Cut | Median Cut and K-Means},alpha_precion_factor>2,alpha_mapping_method_for_hardware_stimulation={0=Median Cut | Median Cut and K-Means}
#@cli : Transfer Colors to images using a palette. If using negative number or "i" for first variable, there must be exactly two layers.
#@cli : (eq. to 'pal_t').\n
#@cli : Default value: 'transfer_rgb=0', 'alpha_count=0', 'alpha_dithering=0%', 'special_effect_factor=.5', 'initial_resize_method=0','activate_upscaling_stimulation=0','pixel_width=1','pixel_height=1','activate_hardware_stimulation=0','color_section_of_hardware_restriction_precision_factor=10','hardware_restriction_by_tile_width=5','hardware_restriction_by_tile_height=5','_hardware_color_precision=4','hardware_color_mapping_method=1','alpha_precion_factor=10','alpha_mapping_method_for_hardware_stimulation=1'
#@cli : For 2 layers where one is a palette - $ palette_transfer -1,0,.5 ,
#@cli : To apply palette colors to multiple layers - $ repeat $! l[$<] palette_transfer db32,0,.5 endl done ,\n
#@cli : Author: Reptorian.
palette_transfer:
_iw={w}
_ih={h}
skip ${4=0},${5=2},${6=0},${7=.5},${8=0}${9=0},${10=1},${11=1},${12=0},${13=10},${14=5},${15=5},${16=4},${17=1},${18=10},${19=1}
pw=$10
ph=$11
if $8||$9 if $pw<=0||$ph<=0 v + error "Invalid input for pixel scale factor(s)!" fi
r={$pw>$ph?$pw/$ph:$ph/$pw} fi
_CI={$2}
AlpC=$5 AlpD=$6 SF=$7
+pal $1
if $9 r[0] {$r*100}%,{$r*100}%,1,4,$8 fi
if $8 r[0] {100/$10}%,{100/$11}%,1,4,$8 fi
split_opacity[0]
l[^1] if $4 to_rgb transfer_rgb.. . fi if $_CI==0 if $12>0 l[0] ahre_rgb $13,$14,$15,$16,$3,$17 endl index.. .,0,1 else index.. .,$3,1 fi rm.
elif $_CI==1 to_rgba ${_iw},${_ih},1,4 noise. {$SF*75} to_graya. blend[^1] difference,1 to_rgb if $12>0 l[0] ahre_rgb $13,$14,$15,$16,$3,$17 endl index.. .,0,1 else index.. .,$3,1 fi rm.
elif $_CI==2 pal 0 [0] index. ..,1,1 rm.. +blend[^1] interpolation,{$5/20} rm[0,2] rv if $12>0 l[0] ahre_rgb $13,$14,$15,$16,$3,$17 endl index.. .,0,1 else index.. .,$3,1 fi rm.
else if $CI>2 if ($_CI-3)==0 +f[0] "x%2*255" else +f[0] "y%2*255" fi fi blend[^1] multiply,{$SF/4} if $12>0 l[0] ahre_rgb $13,$14,$15,$16,$3,$17 endl index.. .,0,1 else index.. .,$3,1 fi rm. fi
endl
if $5<2 rm. if $8 r {100*$10}%,{100*$11}%,1,3,1 fi else
l[1] ${AlpC},1,1,1 f. "x" n. 0,255 if $12>0&&$5>2 l[0] ahre_bw $18,${AlpC},$14,$15,$16,${AlpD},$19 endl index.. .,0,1 else index.. .,${AlpD},1 fi rm. endl a c if $8 r {100*$10}%,{100*$11}%,1,4,1 fi fi
#@cli pal_l :
#@cli : Convert palettes to layers\n
#@cli : Author: Reptorian.
pal_l :
repeat $! l[$>]
_iw={w}
if h=1 repeat ${_iw}-1 [0] done repeat ${_iw} crop[$>] $>,0,$>,0 done else v + error "This is not a palette!" fi endl done
#@cli ahre_rgb: eq. to 'auto_hardware_restriction_emulation_RGB'. : (+)
ahre_rgb : auto_hardware_restriction_emulation_RGB $*
#@cli auto_hardware_restriction_emulation_RGB : _precision_factor>1,_tile_size_width>0,_tile_size_height>0,_colors_per_tiles>0,dithering[%]>=1,mapping_method={0=median-cut | 1=median-cut and k-means}
#@cli : Emulates hardware restriction automatically being based on the image using spectrum of 3.
#@cli : (eq. to 'ahre_rgb').\n
#@cli : Author: Reptorian.
auto_hardware_restriction_emulation_RGB :
repeat $! l[$>] remove_opacity to_rgba repeat $1 [0] done l[$1] +colormap $1,0,0 at[0] "s c f "ia" a c",$2,$3,,,,,3 index.. .,0,1 pal_l. r[1-{$1}] {w#0},{h#0},1,4,1 l[0] repeat $1-1 [0] done endl repeat $1 l[$>,{$>+$1}] f[0] "i#0==i#1?255:0" endl done k[0-{$1-1}] to_gray endl to_rgb[0-{$1-1}] repeat $1 a[$>,$1] c done repeat $1 l[$>] +solidify 0,0,0,0,0 blend normal endl done ac "autoindex $4,$5,$6",rgb blend alpha to_rgb endl done
#@cli ahre_bw: eq. to 'auto_hardware_restriction_emulation_BW'. : (+)
ahre_bw: auto_hardware_restriction_emulation_BW $*
#@cli auto_hardware_restriction_emulation_BW : _precision_factor>1,_tile_size_width>0,_tile_size_height>0,_shades_per_tiles>0,dithering[%]>=1,mapping_method={0=median-cut | 1=median-cut and k-means}
#@cli : Emulates hardware restriction automatically being based on the image using spectrum of 1.
#@cli : (eq. to 'ahre_bw').\n
#@cli : Author: Reptorian.
auto_hardware_restriction_emulation_BW : repeat $! l[$>]
to_gray _l={im} _h={iM} $1,1,1,1 f. "x" n. 0,255 +at.. "f "ia"",$3,$4,,,,,3 index. ..,0,1 rv[^0] pal_l. r[^0-1] {w#0},{h#0},1,1,1 repeat $1 l[1,{$>+2}] f[1] "i#0==i#1?255:0" endl done rm[1] repeat $1 +a[0,{$>+1}] c done rm[0-5] repeat $1 l[$>] +solidify 0,0,0,0,0 blend normal endl done ac "autoindex $5,$6,$7",rgb blend alpha to_gray n ${_l},${_h} $2,1,1,1 f. "x" n. 0,255 index.. .,0,1 rm. to_gray endl done
#@cli rep_modo_mc: eq. to 'rep_modular_operation_multiple_channels' : (+)
rep_modo_mc: rep_modular_operation_multiple_channels $*
#@cli rep_modular_operation_multiple_channels: operation,max_channel_value,channel_value(%)...operation_n,max_channel_value_n,channel_value_n
#@cli : Apply modular operation for every 2 layers, and for each channels. Either by blending or applying modf function to every 2 layer per channels.
#@cli : (eq. to 'rep_modo_mc').\n
#@cli : If there is only one set of rep_modo variables,max_channel_value,channel_value, then the values applied here will be applied to the rest of the channels per layers.
#@cli : If there is more than one set, then values will be applied with periodic condition.
#@cli : If channel_value is less than 0 and greater than or equal to -1, then rep_modular_operation function will use layer blending techniques for 2 layers for every 2 layers. If channel value is less than -1, then operation is disabled on that channel (Only applicable with more than one set of rep_modo variables, and one more layer.).\n
#@cli : Note: You can actually assign cmyk mode with this filter by typing 'u cmyk' before 'rep_modo_mc' as the filter will detect if using cmyk instead.\n
#@cli : See 'gmic h rep_modf' for more details on variables.\n
#@cli : Author: Reptorian.
rep_modular_operation_multiple_channels:

cmyk=0

if '${}'=='cmyk' cmyk=1 fi

tcr={$cmyk?4:3}

total_set_of_operation={narg($*)/3}

if $total_set_of_operation!=int($total_set_of_operation) error narg("$*")/3==F fi

oper_cond={max(0,$total_set_of_operation-2)}

if $oper_cond
 {$oper_cond+1},1,1,3,"begin(argset=[${1--1}]);argset[3*x+c];"
 s. c

 oper_set={crop(#-3)}
 maxchanval_set={crop(#-2)}
 perc_set={crop(#-1)}

 rm[-3--1]
else
 oper_set=$1
 maxchanval_set=$2
 perc_set=$3
fi

if $total_set_of_operation>1
 nset={$total_set_of_operation-1}
else
 nset=1
fi

if $!==1
 if s==2||s>$tcr
  ss={s-1}
  t_color_oper_set={vector$nset($oper_set)}
  t_color_maxchanval_set={vector$nset($maxchanval_set)}
  t_color_perc_set={vector$nset($perc_set)}
  color_oper=[{vector$tcr($t_color_oper_set)}]
  color_maxchanval=[{vector$tcr($t_color_maxchanval_set)}]
  color_perc=[{vector$tcr($t_color_perc_set)}]
  repeat $ss
   sh. $>
   if ($color_perc)[$>]>=0
    modf. {($color_oper)[$>]},{($color_maxchanval)[$>]},{abs(($color_perc)[$>])}
   fi
   rm.
  done
  if $-1>=0
   sh. $ss
   modf. $-3,$-2,$-1
   rm.
  fi
 else
  color_oper=[{vectors($oper_set)}]
  color_maxchanval=[{vectors($maxchanval_set)}]
  color_perc=[{vectors($perc_set)}]
  repeat s
   sh. $>
   if ($color_perc)[$>]>=0
    modf. {($color_oper)[$>]},{($color_maxchanval)[$>]},{abs(($color_perc)[$>])}
   fi
   rm.
  done
 fi
else
 if min($perc_set)>=0&&$-1>=0
  repeat $! l[$>]
   if s==2||s>$tcr
    ss={s-1}
    t_color_oper_set={vector$nset($oper_set)}
    t_color_maxchanval_set={vector$nset($maxchanval_set)}
    t_color_perc_set={vector$nset($perc_set)}
    color_oper=[{vector$tcr($t_color_oper_set)}]
    color_maxchanval=[{vector$tcr($t_color_maxchanval_set)}]
    color_perc=[{vector$tcr($t_color_perc_set)}]
   else
    ss={s}
    color_oper=[{vectors($oper_set)}]
    color_maxchanval=[{vectors($maxchanval_set)}]
    color_perc=[{vectors($perc_set)}]
   fi
   repeat $ss
    sh. $>
    if ($color_perc)[$>]>=0
     modf. {($color_oper)[$>]},{($color_maxchanval)[$>]},{abs(($color_perc)[$>])}
    fi
    rm.
   done
   if s==2||s>$tcr
    sh. {s-1}
    modf. ${-3--1}
    rm.
   fi
  endl done
 else
  repeat int($!/2) l[{$>*2},{$>*2+1}]
   loc_a={$>*2}
   loc_b={$>*2+1}
   if s#0!=s#1 error (s#0#$loc_a!=s#1#$loc_b)==F fi
   if s==2||s>$tcr
    ss={s-1}
    t_color_oper_set={vector$nset($oper_set)}
    t_color_maxchanval_set={vector$nset($maxchanval_set)}
    t_color_perc_set={vector$nset($perc_set)}
    color_oper=[{vector$tcr($t_color_oper_set)}]
    color_maxchanval=[{vector$tcr($t_color_maxchanval_set)}]
    color_perc=[{vector$tcr($t_color_perc_set)}]
   else
    ss={s}
    color_oper=[{vectors($oper_set)}]
    color_maxchanval=[{vectors($maxchanval_set)}]
    color_perc=[{vectors($perc_set)}]
   fi
   repeat $ss
    if ($color_perc)[$>]>=-1
     sh[0] $>
     sh[1] $>
     rep_modo[-2,-1] {($color_oper)[$>]},{($color_maxchanval)[$>]},{($color_perc)[$>]}
     rm[-2,-1]
    fi
   done
   if ($-1>=-1)&&(s==2||s>$tcr)
    v + echo pass v -
    sh[0] {s#0-1}
    sh[1] {s#0-1}
    rep_modo[-2,-1] ${-3--1}
    rm[-2,-1]
   fi
  endl done
 fi
fi
#@cli rep_modo: eq. to 'rep_modular_operation'. : (+)
rep_modo: rep_modular_operation $*
#@cli rep_modular_operation: operation,max_channel_value,channel_value(%)
#@cli : Apply modular operation to every 2 layers. Either by blending layers or applying modf function to every 2 layers.
#@cli : (eq. to 'rep_modo').\n
#@cli : If channel_value is less than 0, then rep_modular_operation function will use layer blending techniques for 2 layers for every 2 layers.
#@cli : See 'gmic h rep_modf' for more details.\n
#@cli : Author: Reptorian.
rep_modular_operation:rv={int($!/2)}
if $!>1&&$3<0
 repeat $rv l[{$>*2},{$>*2+1}] +modf[-1] $1,$2,[-2] modf[0] $1,$2,[1] rm.. endl done
else
 if $!%2
  if $!>2
   modf[^-1] $1,$2,$3
  else
   modf $1,$2,$3
  fi
 else
  modf $1,$2,$3
 fi
fi
#@cli modf: eq. to 'modular_formula'. : (+)
modf: if ${is_image_arg\ $3} pass$3 0 modular_formula $1,$2,[-1] rm.
else modular_formula ${1-3}
fi
#@cli modular_formula : operation,max_channel_value,channel_value(%) : operation,max_channel_value,[image]
#@cli : Apply modular formulas into selected images. 'channel_value' can be values outside the channel ranges of image.\n
#@cli : (eq. to 'modf').\n
#@cli : operation can be { 0=modulo | 1=modulo continuous | 2=divisive | 3=divisive continuous | 4=additive | 5=additive continuous}\n
#@cli : Author: Reptorian.
modular_formula:
if ${is_image_arg\ $3} arg_img=-2 e[] "Apply modular formulas using image as reference for variable value."
else arg_img=-1 e[] "Apply modular formulas using {$3*abs($2)} as variable value. "
fi
if $1<0||$1>5 error ""$"1<6||"$"1>=0 => F" fi
if $1!=int($1) error ""$"1!=INT" fi
if $arg_img==-2 pass$3 1 fi
f[0-{$arg_img}] "begin(eps=10^-8;image=1;skip=1;);
 if(image,
  if("$arg_img"==-2
   ,var3_mod=i#-1/abs($2);
   ,var3_mod=$3;image-=1;
  );
  if(!var3_mod,var3_mod=eps);
  maxnum=$1<2?var3_mod*abs($2)+eps:abs($2)+eps;
  var3_mod=var3_mod*abs($2);
  mf(a)=a-maxnum*floor(a/maxnum);
  amf(a)=(if(floor(a/maxnum)%2,(maxnum-eps)-mf(a),mf(a)));
 );
 if(skip,skip-=1;
   if($1>3,
    if(!($1%2)
      ,calc(a)=mf(a+var3_mod);
      ,calc(a)=amf(a+var3_mod);
     );
   ,if($1>1,
    if(!($1%2)
      ,calc(a)=mf(a*(abs($2)/var3_mod));
      ,calc(a)=amf(a*(abs($2)/var3_mod));
     );
   ,if(!($1%2)
      ,calc(a)=mf(a);
      ,calc(a)=amf(a);
     );
    );
   );
 );
 calc(i);
 end(if(!image,
   maxnum=maxnum;
   var3_mod=var3_mod;
  );
  if(!skip;
   if($1>3,
    if(!($1%2)
      ,calc(a)=mf(a+var3_mod);
      ,calc(a)=amf(a+var3_mod);
     );
   ,if($1>1,
    if(!($1%2)
      ,calc(a)=mf(a*(abs($2)/var3_mod));
      ,calc(a)=amf(a*(abs($2)/var3_mod));
     );
   ,if(!($1%2)
      ,calc(a)=mf(a);
      ,calc(a)=amf(a);
     );
    );
   );
  );
 );
"
replace_nan 0
if $arg_img==-2 rm. fi
#@cli rep_bchstatfunc: eq. to 'rep_by_channel_statistical_function'. : (+)
rep_bchstatfunc : rep_by_channel_statistical_function $*
#@cli rep_by_channel_statistical_function: _variable,_resize_bool={ 0=Do not resize | 1= Resize to 1x1 }
#@cli : Creates 1x1 image based on defined variables that depends on image value (minimum, maximum, average, variance, sum, product and median)
#@cli : (eq. to 'rep_bchstatfunc').\n
#@cli : Default value: 'resize_bool=0'
rep_by_channel_statistical_function:
v - _gmic_s="$?" v +
_$0 $"*"
_rep_by_channel_statistical_function:
skip ${2=1}
v - mvcma="$1"
if isnum("$1") if isint("$1") mvcma=${arg\ 1+$1,min,max,avg,var,sum,pro,med} fi fi
repeat $! l[$>] v - _rep_bchstatfunc_$mvcma $2 endl done
_rep_bchstatfunc_im : _rep_bchstatfunc_min $1
_rep_bchstatfunc_minimum : _rep_bchstatfunc_min $1
_rep_bchstatfunc_min : repeat s sh $> f. im#-1 rm. done if $1 r 1,1,1,{s},0 fi
_rep_bchstatfunc_iM : _rep_bchstatfunc_max $1
_rep_bchstatfunc_maximum : _rep_bchstatfunc_max $1
_rep_bchstatfunc_max : repeat s sh $> f. iM#-1 rm. done if $1 r 1,1,1,{s},0 fi
_rep_bchstatfunc_ia : _rep_bchstatfunc_avg $1
_rep_bchstatfunc_average : _rep_bchstatfunc_avg $1
_rep_bchstatfunc_avg : repeat s sh $> f. ia#-1 rm. done if $1 r 1,1,1,{s},0 fi
_rep_bchstatfunc_iv : _rep_bchstatfunc_var $1
_rep_bchstatfunc_variance : _rep_bchstatfunc_var $1
_rep_bchstatfunc_var : repeat s sh $> f. iv#-1 rm. done if $1 r 1,1,1,{s},0 fi
_rep_bchstatfunc_is : _rep_bchstatfunc_sum $1
_rep_bchstatfunc_total : _rep_bchstatfunc_sum $1
_rep_bchstatfunc_sum : repeat s sh $> f. is#-1 rm. done if $1 r 1,1,1,{s},0 fi
_rep_bchstatfunc_ip : _rep_bchstatfunc_pro $1
_rep_bchstatfunc_product : _rep_bchstatfunc_pro $1
_rep_bchstatfunc_pro : repeat s sh $> f. ip#-1 rm. done if $1 r 1,1,1,{s},0 fi
_rep_bchstatfunc_ic : _rep_bchstatfunc_med $1
_rep_bchstatfunc_median : _rep_bchstatfunc_med $1
_rep_bchstatfunc_med : repeat s sh $> f. ic#-1 rm. done if $1 r 1,1,1,{s},0 fi
#@cli rep_lbchstatfunc_to_pal: eq. to 'rep_layers_by_channel_statistical_function_to_palette'. : (+)
rep_lbchstatfunc_to_pal: rep_layers_by_channel_statistical_function_to_palette $*
#@cli rep_layers_by_channel_statistical_function_to_palette: _variable
#@cli : Converts layers to palette using statistical function by channels per layers into 1x1 tile, then append them.
#@cli : (eq. to 'rep_layers_by_channel_statistical_function_to_palette').
rep_layers_by_channel_statistical_function_to_palette: rep_bchstatfunc $1 a x
#@cli rep_photomosaic : {foldername|[images_arg]},_tile_width>=0,_tile_height>=0,_dithering<=1,0<=_interpolation<=5,_palette={ 0=average, 1=median},_autocrop,_maxalp
#@cli : Generates mosaic using multiple pictures using indexing methodology, and uses either average or median to determine the mapping based on colors. Tile_Width and Tile_Height cannot be both zero!\n
#@cli : Author: Reptorian.
#@cli : Default value: 'tile_height=0', 'interpolation=5', 'autocrop=0'
rep_photomosaic:
skip ${3=0},${4=.5},${5=0},${6=0},${7=0},${8=255}

include_image_as_arg=${"is_image_arg $1"}
tile_width={round(abs($2))}
tile_height={round(abs($3))}
half_perimeter={$tile_width*$tile_height}
non_zero_length={$tile_width+$tile_height}
total_target_img={$!}
if !$tile_width&&!$tile_height error "($"1>0")"&&"($"2>0")"==F fi
e[^-1] "Generating Mosaic!"

if $include_image_as_arg
 pass$1 0
else
 ig $1
fi

total_end_img={$!}

if ($!-$total_target_img<2) error "_"#"imports>=2==F" fi

diff={$total_end_img-$total_target_img}

if ${-max_s}==4 to_rgba
elif ${-max_s}==3 to_rgb
elif ${-max_s}==2 to_graya
elif ${-max_s}==1 to_gray
fi

if s==2||s>3 contain_alpha=1
else contain_alpha=0
fi

endchan={s-2}

if $tile_width&&$tile_height
 if $7 autocrop[$total_target_img--1] fi
 rep_aspect_crop_2d[$total_target_img--1] $tile_width,$tile_height

 if $contain_alpha
  sh[$total_target_img--1] 0,{s-2}
  if $5==1 +rep_lbchstatfunc_to_pal[$total_end_img--1] median
  else +rep_lbchstatfunc_to_pal[$total_end_img--1] average
  fi
  rm[$total_end_img--2]
 else
  if $5==1 +rep_lbchstatfunc_to_pal[$total_target_img--1] median
  else +rep_lbchstatfunc_to_pal[$total_target_img--1] average
  fi
 fi

 repeat $total_target_img
  mini_width={ceil(w#$>/$tile_width)}
  mini_height={ceil(h#$>/$tile_height)}
  r[$>] {$mini_width*$tile_width},{$mini_height*$tile_height},100%,100%,0,1,.5,.5
  r[$>] $mini_width,$mini_height,100%,100%,{abs($6)+1}
  if $contain_alpha
   sh[$>] 0,$endchan
   index. [-2],$4,1
   f. "begin(const length=w#-2;);
   repeat(length,v,
   if(I==I(#-2,v,0),break(););
   );
   v+$total_target_img;
   "
   rm.
  else
   index[$>] [-1],$4,1
   f[$>] "begin(const length=w#-1;);
   repeat(length,v,
   if(I==I(#-1,v,0),break(););
   );
   v+$total_target_img;
   "
  fi
 done
 rm.

 r[$total_target_img--1] $tile_width,$tile_height,100%,100%,{abs($6)+1}
 r[0-{$total_target_img-1}] {$tile_width*100}%,{$tile_height*100}%,100%,100%,1
 if $contain_alpha
  f[0-{$total_target_img-1}] c<s-1?i(#i,x%$tile_width,y%$tile_height,z,c):i/$8*i(#i0,x%$tile_width,y%$tile_height,z,s-1)
 else
  f[0-{$total_target_img-1}] i(#i,x%$tile_width,y%$tile_height,z,c)
 fi
 k[0-{$total_target_img-1}]
else
 same_dim=0

 if $total_target_img>1
  continue_loop=1
  count=1
  do
   if (w#0==w#$count)&&(h#0==h#$count)
    same_dim=1
   else
    same_dim=0
    continue_loop=0
   fi
   count+=1
  while $count<$total_target_img&&$continue_loop
 fi

 if $total_target_img==1||$same_dim
  temp_tile_width={floor(w#0>h#0?$non_zero_length:w#0/h#0*$non_zero_length)}
  temp_tile_height={floor(h#0>w#0?$non_zero_length:h#0/w#0*$non_zero_length)}
  tile_width={$temp_tile_width}
  tile_height={$temp_tile_height}
  mini_width={ceil(w#0/$tile_width)}
  mini_height={ceil(h#0/$tile_height)}

  if $7 autocrop[$total_target_img--1] fi
  rep_aspect_crop_2d[$total_target_img--1] $tile_width,$tile_height

  if $contain_alpha
   sh[$total_target_img--1] 0,{s-2}
   if $5==1 +rep_lbchstatfunc_to_pal[$total_end_img--1] median
   else +rep_lbchstatfunc_to_pal[$total_end_img--1] average
   fi
   rm[$total_end_img--2]
  else
   if $5==1 +rep_lbchstatfunc_to_pal[$total_target_img--1] median
   else +rep_lbchstatfunc_to_pal[$total_target_img--1] average
   fi
  fi

  r[0-{$total_target_img-1}] {$mini_width*$tile_width},{$mini_height*$tile_height},100%,100%,0,3,.5,.5
  r[0-{$total_target_img-1}] $mini_width,$mini_height,100%,100%,{abs($6)+1}

  repeat $total_target_img
   if $contain_alpha
    sh[$>] 0,$endchan
    index. [-2],$4,1
    f. "begin(const length=w#-2;);
    repeat(length,v,
    if(I==I(#-2,v,0),break(););
    );
    v+$total_target_img;
    "
    rm.
   else
    index[$>] [-1],$4,1
    f[$>] "begin(const length=w#-1;);
    repeat(length,v,
    if(I==I(#-1,v,0),break(););
    );
    v+$total_target_img;
    "
   fi
  done
  rm.

  r[$total_target_img--1] $tile_width,$tile_height,100%,100%,{abs($6)+1}
  r[0-{$total_target_img-1}] {$tile_width*100}%,{$tile_height*100}%,100%,100%,1
  if $contain_alpha
   f[0-{$total_target_img-1}] c<s-1?i(#i,x%$tile_width,y%$tile_height,z,c):i/$8*i(#i0,x%$tile_width,y%$tile_height,z,s-1)
  else
   f[0-{$total_target_img-1}] i(#i,x%$tile_width,y%$tile_height,z,c)
  fi
  k[0-{$total_target_img-1}]

 else
  if $7 autocrop[$total_target_img--1] fi
  repeat $total_target_img
   temp_tile_width={floor(w#$>>h#$>?$non_zero_length:w#$>/h#$>*$non_zero_length)}
   temp_tile_height={floor(h#$>>w#$>?$non_zero_length:h#$>/w#$>*$non_zero_length)}
   tile_width={$temp_tile_width}
   tile_height={$temp_tile_height}
   mini_width={ceil(w#$>/$tile_width)}
   mini_height={ceil(h#$>/$tile_height)}

   +rep_aspect_crop_2d[$total_target_img--1] $tile_width,$tile_height

   if $contain_alpha
    l[$total_end_img--1]
     endid={$!}
     sh 0,{s-2}
     if $5==1 +rep_lbchstatfunc_to_pal[$endid--1] median
     else +rep_lbchstatfunc_to_pal[$endid--1] average
     fi
     rm[$endid--2]
    endl
   else
    if $5==1 +rep_lbchstatfunc_to_pal[$total_end_img--1] median
    else +rep_lbchstatfunc_to_pal[$total_end_img--1] average
    fi
   fi

   r[$>] {$mini_width*$tile_width},{$mini_height*$tile_height},100%,100%,0,3,.5,.5
   r[$>] $mini_width,$mini_height,100%,100%,{abs($6)+1}

   if $contain_alpha
    sh[$>] 0,$endchan
    index. [-2],$4,1
    f. "begin(const length=w#-2;);
    repeat(length,v,
    if(I==I(#-2,v,0),break(););
    );
    v+$total_end_img;
    "
    rm.
   else
    index[$>] [-1],$4,1
    f[$>] "begin(const length=w#-1;);
    repeat(length,v,
    if(I==I(#-1,v,0),break(););
    );
    v+$total_end_img;
    "
   fi
   rm.

   r[$total_end_img--1] $tile_width,$tile_height,100%,100%,{abs($6)+1}
   r[$>] {$tile_width*100}%,{$tile_height*100}%,100%,100%,1
   if $contain_alpha
    f[$>] c<s-1?i(#i,x%$tile_width,y%$tile_height,z,c):i/$8*i(#i0,x%$tile_width,y%$tile_height,z,s-1)
   else
    f[$>] i(#i,x%$tile_width,y%$tile_height,z,c)
   fi
   k[0-{$total_end_img-1}]
  done
  k[0-{$total_target_img-1}]
 fi
fi
#@cli rep_aspect_crop_2d: _width_ratio>=1,_height_ratio>=1,-1<=_shift_factor[%]<=1,_interpolation={ 0=nearest | 1=linear }
#@cli : Crop images based on specified aspect ratio.
#@cli : Default value: 'shift_factor=0'\n
#@cli : Author: Reptorian.
rep_aspect_crop_2d:
skip ${3=0},${4=0}
repeat $! l[$>]
A=$1
B=$2
shift_factor=$3
if $A==$B if w>h r {h},100%,1,100%,0,0,{.5+$shift_factor/2},.5 else r 100%,{w},1,100%,0,0,0.5,{.5+$shift_factor/2} fi else
if ($A/$B)>(w/h) r 100%,{$B/$A*(w/h)*100}%,1,100%,0,0,0.5,{.5+$shift_factor/2} else r {$A/$B/(w/h)*100}%,100%,1,100%,0,0,{.5+$shift_factor/2},0.5 fi fi
endl done
#@cli rep_nebulous: _main_surf_xy_factor>0,_main_surf_x_factor>0,_main_surf_y_factor>0,-100<=_x_center[%]<=100,-100<=_y_center[%]<=100,0<=_fxyangle<=360,_wave,0<=_lighting_angle<=360,_disturbance>=0,_distx,_disty,0<=_distangle<=360,_disturbance_mode={ 0= do_not_scale | 1=scale_by_axisfact },_color={ 0=gray | 1=color },_alpha_base={ 0=None | 1=hard_light | 2=hard_shade | 3=soft_light | 4=soft_light },_subpixelevel>=0,subpixelprocessingmethod={ 0=Average | 1=Linear | 2=Grid | 3=Bicubic | 4=Lanczos }
#@cli : Creates a Nebulous texture inspired by its Paint.NET plugin equivalent made by MadJik.\n
#@cli : '_main_surf_xy_factor' - Amount of waves by xy-axis.
#@cli : '_main_surf_x_factor' - Amount of waves by x-axis.
#@cli : '_main_surf_y_factor' - Amount of waves by y-axis.
#@cli : '_x_center' - Placement of Nebulous texture relative to the center by x-axis.
#@cli : '_y_center' - Placement of Nebulous texture relative to the center by y-axis.
#@cli : '_fxyangle' - Function angle of Nebulous texture.
#@cli : '_wave' - Amount of waves within waves.
#@cli : '_lighting_angle' - Shifts color output within waves
#@cli : '_disturbance' - Multiplier for distortion.
#@cli : '_distx' - Distorts function by x-axis.
#@cli : '_disty' - Distorts function by y-axis.
#@cli : '_distangle' - Distortion function Angle
#@cli : '_disturbance_mode' - Influences how the distortion result is calculated.
#@cli : '_color' - Color Output
#@cli : '_alpha_base' - determines the alpha based on waves angle.
#@cli : '_subpixelevel' - Subpixel processing level
#@cli : '_subpixelprocessingmethod' - Subpixel processing method. Only applicable when '_subpixelevel' is greater than 0.\n
#@cli : Default value: '_main_surf_x_factor=10','_main_surf_y_factor=10','_x_center[%]=0','_y_center[%]=0','_fxangle=0','_wave=1','_lighting_angle=0','_disturbance=0','_distx=100','_disty=100','_distangle=0','_disturbance_mode=0','_color=1','_alpha_base=0','_subpixellevel=1','_subpixelprocessingmethod=1'\n
#@cli : Author: Reptorian.
#@cli : $ 640,480,1,1 rep_nebulous 10,,,,,45,,,750,100,100,15,0,1,3 n 0,255 drgba
rep_nebulous:
skip ${2=10},${3=10},${4=0},${5=0},${6=0},${7=1},${8=0},${9=0},${10=100},${11=100},${12=0},${13=0},${14=1},${15=0},${16=0},${17=1}
if $1==0||$2==0||$3==0 v + error "Variable 1 to 3 cannot be zero!" v - fi
if $9<0 v + error "Disturbance factor cannot be less than 0!" v - fi
use_sub={abs($16)}
sublevel={$use_sub+1}
spec_count={!14?0+($15?1:0):3+($15?1:0)}
repeat $! l[$>]
 iw={w}
 ih={h}
 {$use_sub?w*$sublevel:w},{$use_sub?h*$sublevel:h},1,$spec_count,"begin(
   const sd=w/h;
   const shx=($4*w)/2;
   const shy=($5*h)/2;
   const sx=w>h?1:1/sd;
   const sy=w>h?sd:1;
   const sx2=2/sx;
   const sy2=2/sy;
   const ang=-pi*$6/180;
   const cos_ang=cos(ang);
   const sin_ang=sin(ang);
   const distlvl=$9*$1;
   const dist=pi/(distlvl/100);
   const disth=$10;
   const distv=$11;
   const dang=-pi*$12/180;
   const cos_dang=cos(dang);
   const sin_dang=sin(dang);
   const k=pi+((-pi+(pi*$7))*10)/10;
   const ld=-($8-$6)*pi/180;
   const IX_mul=$2*4;
   const IY_mul=$3*4;
   const cx_mul=$13?$2:1;
   const cy_mul=$13?$3:1;
   const iml=1.5*($1*10);
   const angld=ang+ld;
   const hpi=pi/2;
  );
  ix=(((x+shx)/w-.5)*iml)/sx;
  iy=(((y+shy)/h-.5)*iml)/sy;
  IX=ix*cos_ang-iy*sin_ang;
  IY=ix*sin_ang+iy*cos_ang;
  IX*=IX_mul;
  IY*=IY_mul;
  if(distlvl,
   dix=(x/w-.5)*sx2;
   diy=(y/h-.5)*sy2;
   DIX=dix*cos_dang-diy*sin_dang;
   DIY=dix*sin_dang+diy*cos_dang;
   cx=DIX*cx_mul;
   cy=DIY*cy_mul;
   fsd=sin(((cx+cy)/2)/dist);
   fcd=cos(((cy-cx)/2)/dist);
   IX+=disth*(fsd-fcd);
   IY-=distv*(fsd+fcd);
  );
  t=atan2(IY,IX);
  r=norm(IX,IY)/100;
  ti=sin(t)*cos(r)*k+r+angld;
  $15?(
   cg=[sin(pi+ti),sin(hpi+ti),sin(ti)];
   g=sum(cg);
   alp=$15>2?($15==3?g:g*-1):($15==2?(g*-1<0?-1:1):(g<0?-1:1));
   $14?[cg,alp]:[g,alp];
  ):(
   $14?[sin(pi+ti),sin(hpi+ti),sin(ti)]:sin(ti)+sin(hpi+ti)+sin(pi+ti);
  );"
 rm..
 if $use_sub r $iw,$ih,1,{s},{$17+2} fi
endl done
#@cli rep_sptbwgp: eq. to 'rep_shift_pixel_to_boundary_with_group_pixels' : (+)
rep_sptbwgp: rep_shift_pixel_to_boundary_with_group_pixels $*
#@cli rep_shift_pixel_to_boundary_with_group_pixels: -1<=_position<=1,_axis={ 0=Horizontal | 1=Vertical },0<=_influence_factor<=1,_threshold>=0,_channel_mode
#@cli : Shifts pixels to boundary by percentage using grouped pixels. position less than .5 means shift will be negative, and position greater than .5 means shift will be positive.
#@cli : Assign an argument to _channel_mode if you want to disable restricting effect on alpha channel or avoid manipulating 4 channels image in case of CMYKA image. Only use in rare cases!
#@cli : Default values: '_position=-1','_axis=1','_influence_factor=1','_threshold=0','_channel_mode='
rep_shift_pixel_to_boundary_with_group_pixels:
skip ${1=-1},${2=1},${3=1},${4=0},${5=}

influence_factor={min(abs($3),1)}

if $influence_factor&&$!

 any_channels=0
 tcr=3
 position={cut(sum($1,1)/2,0,1)}

 if $2 position={1-$position} fi

 arg=""

 if narg($5)
  if $5>0
   tcr+=1
  else
   args.={abs($5)}
   any_channels=1
  fi
 fi

 args.=,{abs($4)},$position,$influence_factor

 if $2 m "shift_pixels: new_rep_sptbwgp_shift_vertical "$args""
 else m "shift_pixels: new_rep_sptbwgp_shift_horizontal "$args""
 fi

 repeat $! l[$>]
  if s==2||s>$tcr||$any_channels shift_pixels fi
 endl done

 um shift_pixels
fi

new_rep_sptbwgp_shift_horizontal:
skip "${1=}","${2=}","${3=0}"

#$1==channel#
#$2==tolerance#
#$3==position#
#$4==influence_factor#

if narg($1)
 sh {$1%s}
else
 sh {s-1}
fi

cond=>0

if narg($2) if min($2,iM#-1) cond=>={min($2,iM#-1)} fi fi

100%,100%,100%,{s#0}

1,{h#1},{d#1},1,:sum([crop(#1,0,y,z,0,{w#1},1,1,1)]$cond)

if iM#-1=={w#0}
 f.. :i(#-1,0,y)==w?I(#0);
fi

if {$4}==1 new_pixel_position=new_position
else new_pixel_position=round(lerp(pixel_position,new_position,{$4}))
fi

f. :"begin(
  const max_index=w#-2;
  const shift_position=$3;
 );
 num_of_pixels=i%max_index;
 if(num_of_pixels,
  pixel_position=0;
  start_place_test=max_index-num_of_pixels;
  new_position=int(shift_position*start_place_test);
  do(
   i(#1,pixel_position,y)"$cond"?(
    I(#2,"$new_pixel_position",y)=I(#0,pixel_position,y);
    new_position++;
    num_of_pixels--;
   );
   pixel_position++;
  ,num_of_pixels);
 );"

k..

new_rep_sptbwgp_shift_vertical:
skip "${1=}","${2=}","${3=0}"

#$1==channel#
#$2==tolerance#
#$3==position#
#$4==influence_factor#

if narg($1)
 sh {$1%s}
else
 sh {s-1}
fi

cond=>0

if narg($2) if min($2,iM#-1) cond=>={min($2,iM#-1)} fi fi

100%,100%,100%,{s#0}

{w#1},1,{d#1},1,:sum([crop(#1,x,0,z,0,1,{h#-1},1,1)]$cond)

if iM#-1=={h#0}
 f.. :i(#-1,x,0)==h?I(#0);
fi

if {$4}==1 new_pixel_position=new_position
else new_pixel_position=round(lerp(pixel_position,new_position,{$4}))
fi

f. :"begin(
  const max_index=h#-2;
  const shift_position=$3;
 );
 num_of_pixels=i%max_index;
 if(num_of_pixels,
  pixel_position=0;
  start_place_test=max_index-num_of_pixels;
  new_position=int(shift_position*start_place_test);
  do(
   i(#1,x,pixel_position)"$cond"?(
    I(#2,x,"$new_pixel_position")=I(#0,x,pixel_position);
    new_position++;
    num_of_pixels--;
   );
   pixel_position++;
  ,num_of_pixels);
 );"

k..
#@cli rep_sinowaterdist: (eq. to rep_sinusoidal_water_distortion)
rep_sinowaterdist: rep_sinusoidal_water_distortion $*
#@cli rep_sinusoidal_distortion: _xbalance>0,_ybalance>0,_scale>=0,_interpolation,_boundary_condition
#@cli : Shift by sinusoidal distortion formula.
rep_sinusoidal_water_distortion:
skip ${4=2},${5=1}
f
"
balanceY=y*sin(180)/$3*10;
balanceX=x*cos(180)/$3*10;
vx=x+cos(balanceY)*$1;
vy=y+sin(balanceX)*$2;
i(vx,vy,z,c,$4,($5?3:2));
"
#@cli rep_binaltquad: eq. to 'rep_binary_alterating_quad_texture'. : (+)
rep_binaltquad: rep_binary_alterating_quad_texture $*
#@cli rep_binary_alterating_quad_texture: _style={ 0 = Horizontal , 1 = Diagonal , 2 = Simple },_variable_1>=0,_variable_2>=0,_variable_3>=0,0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted },_modnum>0
#@cli : Generates a texture full of alternating quadrilateral shapes using binary logic. Converted, and extended from Asmageddon Quaddro Bumperoo/Inverto Paint.NET source code.
#@cli : (eq. to 'rep_binaltquad').\n
#@cli : Author: Reptorian.
rep_binary_alterating_quad_texture:
skip ${4=128},${5=2},${6=0},${7=0},${8=0},${9=256},${10=255},${11=1}
channels 0
style=$1
var_1=$2
var_2=$3
var_3=$4
operand={$1!=2?$5:2}
angle=$6
x_dir=$7
y_dir=$8
modnum=$9
normalize=$10
allow_normal=$11
f begin(ang=pi*($angle/180);sd=w/h;);ix=((x/w)-.5)/(h>w?1/sd:1);iy=((y/h)-.5)/(w>h?sd:1);IX=ix*cos(ang)-iy*sin(ang);IY=ix*sin(ang)+iy*cos(ang);ix=IX;iy=IY;ix+=.5/(h>w?1/sd:1);iy+=.5/(w>h?sd:1);ix=(w>h?ix*w:ix*h);iy=(w>h?iy*w:iy*h);ix=round(ix)+1;iy=round(iy)+1;$style==2?((!$x_dir?xor(ix,$var_1):xor(w-ix,$var_1))+(!$y_dir?xor(iy,$var_2):xor(h-iy,$var_2)))%$modnum:(int(((($style==1?($operand?($operand==1?(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))):($operand?($operand==1?(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))))/(int($operand!=2?$var_3:-$var_3)*2))-int(($style==1?($operand?($operand==1?(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))):($operand?($operand==1?(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))))/(int($operand!=2?$var_3:-$var_3)*2)))*($style==1?($operand?($operand==1?(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))):($operand?($operand==1?(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2))))))<int($operand!=2?$var_3:-$var_3)?($style==1?($operand?($operand==1?(abs($modnum)-1)-(((($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))%$modnum):($operand?($operand==1?(abs($modnum)-1)-(((($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))%$modnum)):($style==1?($operand?($operand==1?(abs($modnum)-1)-(((-($x_dir?w-ix:ix)|int($var_1))+(($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(($y_dir?h-iy:iy)&int($var_2)))%$modnum):($operand?($operand==1?(abs($modnum)-1)-(((-($x_dir?w-ix:ix)|int($var_1))+(-($y_dir?h-iy:iy)|int($var_2)))%$modnum):(xor(-($x_dir?w-ix:ix),int($var_1))+xor(-($y_dir?h-iy:iy),int($var_2)))%$modnum):((-($x_dir?w-ix:ix)&int($var_1))+(-($y_dir?h-iy:iy)&int($var_2)))%$modnum)))
if $allow_normal n 0,$normalize fi
#@cli rep_binaltquadc: eq. to 'rep_binary_alterating_quad_c'. : (+)
rep_binaltquadc: rep_binary_alterating_quad_c $*
#@cli rep_binary_alterating_quad_c: 0<=_colorspace<=13,_contain_alpha= { 0=No Alpha | 1=Alpha Included },_8bitmode= { 0=Not 8-Bit Value | 1=8-Bit Value } \ 0<=_channel_order<=5,0<=_channel_order<=5,0<=_channel_order<=5,0<=_channel_order<=5,0<=_channel_order<=5, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }, \
#_variable_1>=0,_variable_2>=0,_variable_3>=0,_style={ 0 = Horizontal | 1 = Diagonal },0<=_operand<=2,0<=_angle<=360,_x_dir= { 0 = normal | 1 = inverted },_y_dir= { 0=normal | 1 = inverted }
#@cli : Generates a texture full of alternating quadrilateral shapes using binary logic. Converted, and extended from Asmageddon Quaddro Bumperoo/Inverto Paint.NET source code.
#@cli : (eq. to 'rep_binaltquadc').
rep_binary_alterating_quad_c:
repeat $! l[$>]
cs_mode=$1
cmyk_mode={$cs_mode==3?4:3}
contain_alpha={$2?1:0}
bitmode=$3
tch={$cmyk_mode+$contain_alpha}

skip ${7=0},${8=0},${9=0},${10=0},${11=0},${12=0},${13=0},${14=0},${15=0},${16=0},${17=0},${18=0},${19=0},${20=0},${21=0},${22=0},${23=0},${24=0},${25=0},${26=0},${27=0},${28=0},${29=0},${30=0},${31=0},${32=0},${33=0},${34=0},${35=0},${36=0},${37=0},${38=0},${39=0},${40=0},${41=0},${42=0},${43=0},${44=0},${45=0},${46=0},${47=0},${48=0},${49=0}

channels 0
r 100%,100%,100%,$tch

if $tch==3 ($4,$5,$6)
elif $tch==4 ($4,$5,$6,$7)
elif $tch==5 ($4,$5,$6,$7,$8)
fi

tc={w#1} s. x remove_duplicates tw={$!-1} if $tw<$tc v + error "Invalid Channel Order!" v - fi
a[^0] x rv
($*)
if ($cs_mode==3||(($cs_mode>8&&$cs_mode<11)||$cs_mode<3))||$bitmode (256,256,256,256,255)
else
    if $cs_mode>3&&$cs_mode<7 (361,101,101,256)
    elif $cs_mode==7 (101,201,201,256)
    elif $cs_mode==8 (101,129,{ceil((pi)*200)},256)
    elif $cs_mode==11 (301,301,301,256)
    elif $cs_mode==12 (256,301,301,256)
    elif $cs_mode==13 (301,301,301,256)
    fi
fi
fact=9
repeat $tch
sh[1] {i(#0,$>,0)}
rep_binaltquad. {i(#2,8+$fact*$>,0)},{i(#2,9+$fact*$>,0)},{i(#2,10+$fact*$>,0)},{i(#2,11+$fact*$>,0)},{i(#2,12+$fact*$>,0)},{i(#2,13+$fact*$>,0)},{i(#2,14+$fact*$>,0)},{i(#2,15+$fact*$>,0)},{i(#3,$>,0)},{i(#3,$>,0)-1},{i(#2,16+$fact*$>,0)}
rm.
done
k[1]
if $cs_mode==3
    if $contain_alpha
    s c
    a[0-{$!-2}] c
    cmyk2rgb..
    *.. {255/254}
    a c
    else
    cmyk2rgb
    * {255/254}
    fi
else
    if ($cs_mode>8&&$cs_mode<11)||$cs_mode<3
        if $cs_mode==1 ac "ryb2rgb",rgb
        elif $cs_mode==2 ac "cmy2rgb",rgb
        elif $cs_mode==9 ac "ycbcr2rgb",rgb
        elif $cs_mode==10 ac "ycbcrglic2rgb",rgb
        fi
        cut 0,255
    else
        if $bitmode
            if $cs_mode==1 ac "ryb2rgb",rgb
            elif $cs_mode==4 ac "hsi82rgb",rgb
            elif $cs_mode==5 ac "hsv82rgb",rgb
            elif $cs_mode==6 ac "hsl82rgb",rgb
            elif $cs_mode==7 ac "lab82rgb",rgb
            elif $cs_mode==8 ac "lch82rgb",rgb
            elif $cs_mode==11 ac "yiq82rgb",rgb
            elif $cs_mode==12 ac "yuv82rgb",rgb
            elif $cs_mode==13 ac "xyz82rgb",rgb
            fi
            cut 0,255
        else
            if $cs_mode>3&&$cs_mode<7
                f s<4?[i0,i1/100,i2/100,i3]:[i0,i1/100,i2/100]
                if $cs_mode==4 hsi2rgb
                elif $cs_mode==5 hsv2rgb
                elif $cs_mode==6 hsl2rgb
                fi
                cut 0,255
            elif $cs_mode==7
                f s<4?[i0,i1-100,i2-100,i3]:[i0,i1-100,i2-100]
                lab2rgb
            elif $cs_mode==8
                f s<4?[i0,i1,((i2-314.5)*(pi/3.145)/100),i3]:[i0,i1,((i2-314.5)*(pi/3.145)/100)]
                sh 0,2
                lch2rgb.
                rm.
            elif $cs_mode==11
            f s<4?[i0,i1-150,i2-150,i3]:[i0,i1-150,i2-150]
            yiq2rgb
            elif $cs_mode==12
            f s<4?[i0/255,(i1-150)/150,(i2-150)/150,i3]:[i0/255,(i1-150)/150,(i2-150)/150]
            yuv2rgb
            elif $cs_mode==13
            f s<4?[i0/300,i1/300,i2/300,i3]:[i0/300,i1/300,i2/300]
            xyz2rgb
            fi
        fi
    fi
fi
endl done
#@cli rep_strbul: eq. to 'rep_strange_bulger'. : (+)
rep_strbul: rep_strange_bulger $*
#@cli rep_strange_bulger : 0<=_angle<=360,_axis={ 0 = X-Axis | 1 = Y-Axis },_interpolation,_boundary_condition
#@cli : Performs a bulge effect found in Strange Bulger Series made by Asmageddon for Paint.NET.
#@cli : (eq. to 'rep_strbul').\n
#@cli : _angle refers to the angle of distortion.
#@cli : _axis_of_bulge refers to the axis that is the distortion is based from.\n
#@cli : Author: Reptorian.
rep_strange_bulger:
f "begin(
const BulgeAng=$1*(pi/180);
const cX=w/2;
const cY=h/2;
);
vx=$2?x:cX-x;
vy=$2?cY-y:y;
vx=(vx^2)/cX;
vy=(vy^2)/cY;
vx=(x+(x-vx)*cos(BulgeAng)+(y-vy)*sin(BulgeAng));
vy=(y+(x-vx)*sin(BulgeAng)+(y-vy)*cos(BulgeAng));
i(vx,vy,z,c,$3,($4?3:2));
"
#@cli rep_strbulkal: eq. to 'rep_strange_bulger_kaleidoscope'. : (+)
rep_strbulkal:rep_strange_bulger_kaleidoscope $*
#@cli rep_strange_bulger_kaleidoscope: 0<=_bulge_ang<=360,_axis_of_bulge= { 0=horizontal | 1=vertical },_scale>0,-1<_offset_main_x<=1,-1<_offset_main_y<=1,-1<_offset_kaleido_x<=1,-1<_offset_kaleido_y,-360<=surface_ang<=360,_mirror_placement= { 0=inside-out | 1=outside-in },_boundary_condition= { 0=Periodic | 1=Mirror },1<=_interpolation<=5,_dimension_reference>0
#@cli : Distorts image using bulge effect found in Strange Bulger Series made by Asmageddon for Paint.NET. This is the Kaleidoscope version of Strange Bulger.
#@cli : (eq. to 'rep_strbulkal').\n
#@cli : _bulge_ang refers to the angle of distortion.
#@cli : _axis_of_bulge refers to the axis that is the distortion is based from.
#@cli : _scale refers to the scaling of the distortion. The larger the _scale value is, the more areas is revealed.
#@cli : _offset_main_x refers to the horizontal displacement of the initial image
#@cli : _offset_main_y refers to the vertical displacement of the initial image
#@cli : _offset_kaleido_x refers to the horizontal displacement of the center of the distortion
#@cli : _offset_kaleido_y refers to the vertical displacement of the center of the distortion
#@cli : _surface_ang refers to the angle of distortion
#@cli : _mirror_placement refers to whether the displacement is mirror from the center or not.
#@cli : _dimension_reference refers to the base dimension used for calculation of bulging, it uses the biggest dimension as a reference for scaling. The PDN version of Strange Bulger Kaleidoscope does not have a dimension reference which means that bulges are dependent on the image size. This is to ensure that preview stays consistent with the end result. What you see is what you get as _dimension_reference variable is a internal dimension processing variable.\n
#@cli : Author: Reptorian.
rep_strange_bulger_kaleidoscope:
skip ${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=3},${12=1024}
if $3<10^-8 v + error "Scale cannot be 0 or less than 0!" v - fi
if $12==0 v + error "dimension_reference cannot be 0!" v - fi

shift {50*$4}%,{50*$5}%,0,0,3,1

f "begin(
const BulgeAng=pi*((h>w?360-$1:$1)/180);
const ang=pi*($8/180);
const sd=w/h;
const iox=$6/(h>w?1/sd:1);
const ioy=($7*-1)/(w>h?sd:1);
const cos_ang=cos(ang);
const sin_ang=sin(ang);
const ox=iox*cos_ang-ioy*sin_ang;
const oy=iox*sin_ang+ioy*cos_ang;
const ed=abs(int($12));
const id=w>h?ed/w:ed/h;
const iw=w*id;
const ih=h*id;
const cx=iw/2;
const cy=ih/2;
);
ix=((x/w)-.5)/(h>w?1/sd:1);
iy=((y/h)-.5)/(w>h?sd:1);
IX=ix*cos_ang-iy*sin_ang;
IY=ix*sin_ang+iy*cos_ang;
ix=IX;
iy=IY;
ix+=.5/(h>w?1/sd:1);
iy+=.5/(w>h?sd:1);
ix*=ed;
iy*=ed;
xx=sqrt(abs(ix-cx-ox*(cx>cy?cx:cy)));
yy=sqrt(abs(iy-cy-oy*(cx>cy?cx:cy)));
xx*=$3*ed;
yy*=$3*ed;
xx/=100;
yy/=100;
vx=(w>h?$2:!$2)?xx:cx-xx;
vy=(w>h?$2:!$2)?cy-yy:yy;
vx=vx^2/cx;
vy=vy^2/cy;
vx=(xx+(xx-vx)*cos(BulgeAng)+(yy-vy)*sin(BulgeAng));
vy=(yy+(xx-vx)*sin(BulgeAng)+(yy-vy)*cos(BulgeAng));
vx*=w/ed;
vy*=h/ed;
i(vx,vy,z,c,$11,($10?3:2));
"
if $9 shift 50%,50%,0,0,3,1 fi
#@cli rep_logpindis: eq. to 'rep_logarithmic_pinching_distortion'. : (+)
rep_logpindis: rep_logarithmic_pinching_distortion $*
#@cli rep_logarithmic_pinching_distortion: _distortion_main>=0,-1<=_preshift_x<=1,-1<=_preshift_y<=1,-1<=_effposition_x<=1,-1<=_effposition_y<=1,_prescale_x,_prescale_y,_afterscale_x,_afterscale_y,0<=_angle<=360,_mirror_placement= { 0=outside-in | 1=inside-out },_lx_axis= { 0=different axis | 1=same axis},_ly_axis= { 0=different axis | 1=same axis},ix_dir={ 0=negative | 1=positive },iy_dir={ 0=negative | 1=positive },_boundary= { 0=Periodic | 1=Mirror },1<=_interpolation<=5,_dimension_ref>0
#@cli : (eq. to 'rep_logpindis').\n
#@cli : Author: Reptorian.
rep_logarithmic_pinching_distortion:
skip ${2=0},${3=0},${4=0},${5=0},${6=1},${7=1},${8=1},${9=1},${10=0},${11=0},${12=1},${13=0},${14=1},${15=0},${16=0},${17=5},${18=1024}
if $6==0||$7==0||$8==0||$9==0 v + error "Scale cannot be 0!" v - fi
if $17<1 v + error "interpolation cannot be less than 1" v - fi

shift {50*$2}%,{50*$3}%,0,0,3,1
f "
begin(
const sd=w/h;
const ang=pi*($10/180);
const cos_ang=cos(ang);
const sin_ang=sin(ang);
const iox=($4*-1)/(h>w?1/sd:1);
const ioy=$5/(w>h?sd:1);
const ox=iox*cos_ang-ioy*sin_ang;
const oy=iox*sin_ang+ioy*cos_ang;
const ed=int(abs($18))/2;
const dx=$14?1:-1;
const dy=$15?1:-1;
const iend=$16?3:2;
);
ix=((x/w)-.5)/(h>w?1/sd:1);
iy=((y/h)-.5)/(w>h?sd:1);
IX=ix*cos_ang-iy*sin_ang;
IY=ix*sin_ang+iy*cos_ang;
ix=IX;
iy=IY;
ix=abs(ix+ox/2)*$6;
iy=abs(iy+oy/2)*$7;
ix*=ed;
iy*=ed;
lx=ix==0||iy==0?log(1^-8)*$1:log($12?iy^2:ix*iy)*$1;
ly=ix==0||iy==0?log(1^-8)*$1:log($13?ix^2:ix*iy)*$1;
ix-=lx*dx;
iy-=ly*dy;
ix*=w/ed;
iy*=h/ed;
ix*=$8;
iy*=$9;
i(ix,iy,z,c,$17,iend);
"
if $11 shift 50%,50%,0,0,3,1 fi
#@cli rep_sqrlogpindis: eq. to rep_square_root_logarithmic_pinching_distortion : (+)
rep_sqrlogpindis: rep_square_root_logarithmic_pinching_distortion $*
#@cli rep_square_root_logarithmic_pinching_distortion: _distortion_main>=0,-1<=_preshift_x<=1,-1<=_preshift_y<=1,-1<=_effposition_x<=1,-1<=_effposition_y<=1,_prescale_x,_prescale_y,_afterscale_x,_afterscale_y,0<=_angle<=360,_mirror_placement= { 0=outside-in | 1=inside-out },_lx_axis= { 0=different axis | 1=same axis},_ly_axis= { 0=different axis | 1=same axis},ix_dir={ 0=negative | 1=positive },iy_dir={ 0=negative | 1=positive },_boundary= { 0=Periodic | 1=Mirror },1<=_interpolation<=5,_dimension_ref>0
#@cli : (eq. to 'rep_sqrlogpindis').\n
#@cli : Author: Reptorian.
rep_square_root_logarithmic_pinching_distortion:
skip ${2=0},${3=0},${4=0},${5=0},${6=1},${7=1},${8=1},${9=1},${10=0},${11=0},${12=1},${13=0},${14=1},${15=0},${16=0},${17=5},${18=1024}
if $6==0||$7==0||$8==0||$9==0 v + error "Scale cannot be 0!" v - fi
if $17<1 v + error "interpolation cannot be less than 1" v - fi

shift {50*$2}%,{50*$3}%,0,0,3,1

f "begin(
const ed=int(abs($18));
const sd=w/h;
const ang=pi*($10/180);
ox=$4;
oy=$5*-1;
ox/=h>w?1/sd:1;
oy/=w>h?sd:1;
OX=ox*cos(ang)-oy*sin(ang);
OY=ox*sin(ang)+oy*cos(ang);
ox=OX;
oy=OY;
);
ix=((x/w)-.5)/(h>w?1/sd:1);
iy=((y/h)-.5)/(w>h?sd:1);
IX=ix*cos(ang)-iy*sin(ang);
IY=ix*sin(ang)+iy*cos(ang);
ix=IX;
iy=IY;
ix+=.5/(h>w?1/sd:1);
iy+=.5/(w>h?sd:1);
iw=w/(h>w||w==h?1/sd:1);
ih=h/(w>h||w==h?1:1/sd);
id=ed/w;
iw*=id;
ih*=id;
cx=iw/2;
cy=ih/2;
ix*=1;
iy*=1;
xx=sqrt(abs(ix*ed-cx-cx*ox))*$6;
yy=sqrt(abs(iy*ed-cy-cx*oy))*$7;
vx=xx*100;
vy=yy*100;
lx=xx==0||yy==0?log(1^-8)*$1:log($12?yy^2:xx*yy)*$1;
ly=xx==0||yy==0?log(1^-8)*$1:log($13?xx^2:xx*yy)*$1;
vx+=($14?-1:1)*lx;
vy+=($15?-1:1)*ly;
vx*=w/ed;
vy*=h/ed;
vx*=$8;
vy*=$9;
i(vx,vy,z,c,$17,($16?3:2));
"

if $11 shift 50%,50%,0,0,3,1 fi
#@cli rep_stitch: _offset,_thickness,_modulo,_interpolation,_boundary,0<_sublevel,randomize_stitching,0<=_angle<=360..._angle
#@cli : Multiple angles are permitted.\n
#@cli : Author: Reptorian.
rep_stitch:
e[] "Stitches image with offset of $1 px, and thickness of $2 px."
repeat $! l[$>]
is={s}
iw={w}
ih={h}
l[0] ($*) rv endl
if $4<0 v + error "Interpolation cannot be less than zero!" v - fi
f[0] "x==3?i+1:i"
if w#0<8 v + error "There must be angle input!" v - fi
if w#0==8 _rep_stitch. {i(#0,0,0)},{i(#0,7,0)},{crop(#0,1,0,6,1)} rm[0]
else
interpolation={i(#0,3,0)}
repeat w#0-8 . done
repeat w#0-7 _rep_stitch[{$<+1}] {i(#0,0,0)},{i(#0,{7+$<},0)},{crop(#0,1,0,6,1)},0,1 done
repeat w#0-8 add[2,{4+$>}] done
f[2] i%{w#0-7} +[2] 1 rv[0,2] rm[2] r[0] 100%,100%,100%,$is f[0] i(#i0) k[0]
r $iw,$ih,100%,100%,$interpolation
fi
endl done
_rep_stitch:
#Warning! _rep_stitch is a local command! Remove the _ in left side to make it nonlocal! angle is $2 #
skip ${3=1},${4=20},${5=3},${6=1},${7=1},${8=0},${9=1},${10=0}
if $7<0 v + error "Sublevel cannot be zero!" v - fi
ang={pi*($2/180)}
ang2={pi*(($2+90)/180)}
iw={w}
ih={h}
if $5>0 r {($7+1)*100}%,{($7+1)*100}%,100%,100%,1 fi
{w},{h},1,1,sur=x*cos($ang)+y*sin($ang);res=floor(sur/($3*($7+1)));$4?abs(res)%$4:abs(res)
{max(1,round(iM,1,1))},1,1,1,u(-1,1) n. -1,1 map.. . rm.
repeat s#0
    sh[0] $>
    f. "
    sx=($7+1)*$1*cos($ang2)*i#1;
    sy=($7+1)*$1*sin($ang2)*i#1;
    sx+=x;
    sy+=y;
    i(sx,sy,z,c,$5,$6)" rm.
done
if !$10 k[0] else k[0,1] if !$8 f. sur=x*cos($ang)+y*sin($ang);res=floor(sur/($3*($7+1)));abs(res)%2 fi fi
if $5>0 if $9 r[0] {$iw},{$ih},100%,100%,$5 fi fi
#@cli rep_polkal: (eq. to rep_polar_kaleidoscope)
rep_polkal:rep_polar_kaleidoscope $*
#@cli rep_polar_kaleidoscope: _angle_cut_repeat>0,_radial_cut_repeat>0,_angle,-1<=_shift_x<=1,-1<=_shift_y<=1,_flip_x= { 0=Original | 1=Flipped },_flip_y= { 0=Original | 1=Flipped },_edge_x= { 0=Repeat | 1=Alternating },0<=_edge_y<=2,_radial_fit_dimension= { 0=Minimum | 1=Maximum },_conical_start_ang= { 0=90 | 1=0 },_sublevel>0,0<_interpolation<=5
#@cli : _angle_cut_repeat refers to the amount of time a image will repeat along the center.
#@cli : _radial_cut_repeat refers to the amount of time a image will repeat from the center.
#@cli : _angle refers to the angle of the filter function.
#@cli : _shift_x refers to the horizontal distance distance from the center in relative to the center of the target image(s)
#@cli : _shift_y refers to the verticla distance of the center in relative to the center of the target image(s).
#@cli : _flip_x mirrors the image horizontally prior to the polar effect.
#@cli : _flip_y mirrors the image vertically prior to the polar effect.
#@cli : _radial_fit_dimension fits the end of radius cut to the min or max dimension.
#@cli : _conical_start_ang starts the polar image from the standard interpretation or straight up.
#@cli : _sublevel refers to the antialiasing degree of the polar effect.
#@cli : Default value: '_angle_cut_repeat=2','_radial_cut_repeat=1','_angle=0','_shift_x=0','_shift_y=0','_flip_x=0','_flip_y=0','_edge_x=1','_edge_y=1','_radial_fit_dimension=0','_conical_start_ang=0','_sublevel=.5','_interpolation=2'\n
#@cli : Author: Reptorian.
rep_polar_kaleidoscope:
skip ${1=2},${2=1},${3=0},${4=0},${5=0},${6=0},${7=0},${8=1},${9=1},${10=0},${11=0},${12=.5},${13=2}
if $1==0 v + error "Invalid Number - Variable 1" v - fi
if $2==0 v + error "Invalid Number - Variable 2" v - fi
if $4<-1||$4>1 v + error "Invalid Number - Variable 3" v - fi
if $5<-1||$5>1 v + error "Invalid Number - Variable 4" v - fi
if $12<0 v + error "Invalid Number - Variable" 12 v - fi
if $13<=0 v + error "Invalid Number - Variable" 13 v - fi
r2dx {($12+1)*100}%,$13
f "begin(const dr=max(w,h)/min(w,h);const ang=pi*(($3*-1)/180););
xx=((x-$4*w/2)/w-.5)*2;
yy=((y+$5*h/2)/h-.5)*2;
xx*=w>h?dr:1;
yy*=w>h?1:dr;
XX=xx*cos(ang)-yy*sin(ang);
YY=xx*sin(ang)+yy*cos(ang);
xx=XX;
yy=YY;
xs=($11?atan2(yy,xx)+pi:atan2(xx,yy)+pi)/(2*pi);
xs*=$1;
ys=norm(xx,yy)/($10?dr/1:1);
ys*=$2;
xs=$8?(int(xs)%2!=0?1-(xs-floor(xs)):xs-floor(xs)):xs-floor(xs);
ys=$9?($9-1?(int(ys)%2!=0?1-(ys-floor(ys)):ys-floor(ys)):ys-floor(ys)):ys;
xs=$6?1-xs:xs;
ys=$7?1-ys:ys;
polkal_a=i(abs(xs*w),ys*h,z,c,0,0);
polkal_b=i(xs*w,ys*h,z,c,1,1);
$9?polkal_b:polkal_a;
"
r2dx {(1/($12+1))*100}%,$13
#@cli rep_objvf: eq. to 'rep_objvolumefilt' : (+)
rep_objvf: rep_objvolumefilt $*
#@cli rep_objvolumefilt: 0<=_v1<=100%,0<=_v2<=100%,_mode={ -2=preserve_exterior_filter_max_out || -1=preserve_interior_filter_max_out || 0=preserve_interior || 1=preserve_exterior },_colour1...
#@cli : _v1 and _v2 refers to boundary in percent. By default, this command use alpha as reference unless all channel values are specified next to mode.
#@cli : (eq. to 'rep_objvf').\n
#@cli : Default value: '_mode=1'\n
#@cli : Author: Reptorian.
rep_objvolumefilt:
skip ${3=0},${4=}
if $1<0||$2<0||$1>1||$2>1 error ""(""$"1>=0&&"$"1"<=1)"&&"(""$"2>=0&&"$"2"<=1)==F"" fi
if (max($1,$2)-min($1,$2))==1 error "max"(""$"1,"$"2")"-min"(""$"1,"$"2")"<1==F" fi
if ($1!=$2)
repeat $! l[$>]
 ssize={s}
 if narg(${4--1})&&s>1
  if (narg(${4--1})<($ssize-1)) error "{narg(${4--1})}>={$ssize-1}==F" fi
  if narg(${4--1})<$ssize +channels {s-1} colormap. 0,1,2 alp={i(#-1,0,0)} rm. fi
  100%,100%,100%,1,"begin(
   const ss=$ssize-1;
   ref_color=vectorss(${4--1});
  );
  vectorss(I#0)!=ref_color?1:0
  "
  if narg(${4--1})<$ssize End={vector$ssize(${4--1},$alp)}
  else End={vector$ssize(${4--1})}
  fi
 else
  +channels {s-1}
  End={vector$ssize(0)}
 fi
 if !iv#-1 error "Variance>0==F" fi
 f. i?1 area_fg. 0,1
 if $3<0 f. i==iM?0:i fi
 +f. i==0?iM:i
 newmin={im#-1}
 rm.
 MM={iM#-1-$newmin}
 area_1={$1*$MM}
 area_2={$2*$MM}
 area_1+=$newmin
 area_2+=$newmin
 minarea={min($area_1,$area_2)}
 maxarea={max($area_1,$area_2)}
 if $3>=0
  if $3 f.. !(i0#-1>=$minarea&&i0#-1<=$maxarea)?I:[$End]
  else  f.. i0#-1>=$minarea&&i0#-1<=$maxarea?I:[$End]
  fi
 else
  if $3<-1 f.. if(i0#-1,(!(i0#-1>=$minarea&&i0#-1<=$maxarea)?I:[$End]),I)
  else     f.. if(i0#-1,(i0#-1>=$minarea&&i0#-1<=$maxarea?I:[$End]),I)
  fi
 fi
 rm.
 vv=0
 repeat s
  sh $>
  vv+={iv#-1}
  rm.
 done
 if !$vv error "Final Variance>0==F" fi
endl done
fi
#@cli rep_form_pixel: form_id,form_quad_lx!=0,form_quad_ly!=0,_form_ratio[%]!=0,_angle, 0<=_reflect_dir<=2,_sublevel,_tile_boundary={ 0=periodic | 1=mirror_x | 2=mirror_y | 3=mirror_xy },_image_boundary={ 0=neumann | 1=periodic | 2=mirror},_abs_zconvf>=0,_zconv_boundary={0=periodic | 1= mirror},_interpolation={ 0=nearest | 1=average | 2=grid | 3=linear | 4=bicubic | 5=lanczos},cs_mode={ 0=rgb | 1=ryb | 2=cmyk | 3=hcy | 4=hsi | 5=hsl | 6=hsv | 7=lab | 8=lch },_fit_tile={ 0=squash_to_fit | 1=resize_to_fit },_kdol={ 0=default | 1=old_dim | 2=new_layer | 3=new_layer_old_dim },shape_option_1..._shape_option_n
#@cli : _form_id refers to the id or name of shape. circle is a valid form id, and any integer number that is 0-24 inclusive is a form id. You can also use image as an argument, so you can use any arbitrary shapes.
#@cli : _form_quad_lx refers to the size of the tile in pixel form. It cannot be 0 unless you want to use _form_quad_ly variable to define the tile width.
#@cli : _form_quad_ly refers to the size of the tile in pixel form. It cannot be 0 unless you want to use _form_quad_lx variable to define it tile height.
#@cli : _form_ratio refers to the how much the shape fills each tile.
#@cli : _angle refers to the rotation of shapes per tile
#@cli : _reflect_dir refers to the mirroring of each shape. 1,2 means the mirroring is applied.
#@cli : _sublevel refers to the initial size of the shape to be scaled down to fit tiles.
#@cli : _tile_boundary refers to how the tiles are repeated within the canvas
#@cli : _image_boundary refers to how the pixels are treated when out-of-range of original canvas before generating tiles
#@cli : _abs_zconvf defines the contrast level of each tiles using z-convolution within a small color tile reference 3D image.
#@cli : _zconv_boundary defines how out-of-range value within z-convolution kernet are treated.
#@cli : _interpolation refers to the interpolation of the scaling of shapes to fit each tile. See 'gmic h resize' _interpolation.
#@cli : _cs_mode refers to the color processing space that form_pixel filter utilize.
#@cli : _fit_tile is a parameter used for whether to fit tile into specified tile width and height or to use stretch resize =method.
#@cli : _kdol can be used to resize the generated result to original dimension and/or to create new layer on top of existing image.
#@cli : _shape_option are used to define the behavior of shapes when available.
#@cli :
#@cli : -- form_id --
#@cli : string | shape_name_id | shape_options
#@cli :
#@cli : [image] ---- image_as_shape
#@cli : 0  - australia
#@cli : 1  - barbedwire
#@cli : 2  - circle
#@cli : 3  - crosshair
#@cli : 4  - cupid
#@cli : 5  - diamond
#@cli : 6  - dragon ------ dragon_recursion>=0,-360<=dragon_curve_rotation_angle>=360
#@cli : 7  - dragonfly
#@cli : 8  - fern - size>=0,density[%]>=0,ang,0<=opacity<=1,type={ 0=Black Spleenwort | 1=Marsh }
#@cli : 9  - flip
#@cli : 10 - gear  ------- teeth>0,0<height<=100,0<=offset_teeth=100,0<ratio<=100
#@cli : 11 - gumleaf
#@cli : 12 - heart
#@cli : 13 - information
#@cli : 14 - kookaburra
#@cli : 15 - mail
#@cli : 16 - mapleleaf
#@cli : 17 - paint_splat
#@cli : 18 - paw
#@cli : 19 - phone
#@cli : 20 - polygon  ------- vertices>0
#@cli : 21 - rooster
#@cli : 22 - shopping_cart
#@cli : 23 - snowflake  ------- 1<=recursion<=6
#@cli : 24 - star  ------- branches>3,thickness[%]
#@cli :
#@cli : -- end of form_id --
#@cli :
#@cli : Note: _shape_option_1 can be empty. n refers to corresponding shape option.
#@cli : Default value: '_form_ratio=1','_ang=0','_reflect_dir=0','_sublevel=.5','_interpolation=2','tile_boundary=0','_image_boundary=2','_fit_tile=1','_kodl=0'\n
#@cli :
#@cli : Author: Reptorian.
#@cli : $ sp landscape rep_form_pixel star,20,,90%,45,0,1,1,2,75%,0,5,2,0,0
rep_form_pixel:
skip ${2=},${3=},${4=},${5=},${6=},${7=},${8=},${9=},${10=},${11=},${12=},${13=},${14=},${15=}

if narg($2)  form_quad_lx=$2 else form_quad_lx=$3 fi
if narg($3)  form_quad_ly=$3 else form_quad_ly=$2 fi

form_ratio,ang,mirror,sub,tile_boundary,image_boundary,z_convolve,z_convolve_boundary,interpolation,cs_mode,fit_tile,var_kodl={narg($4)?abs($4):1},{narg($5)?$5:0},{narg($6)?abs($6)%3:0},{narg($7)?abs($7)+1:2},{narg($8)?abs($8)%4:0},{narg($9)?abs($9)+1:2},{narg($10)?abs($10):.5},{narg($11)?abs($11)%2+1:1},{narg($12)?abs($12)+1:5},{narg($13)?abs($13)%9:7},{narg($14)?abs($14):1},{narg($15)?abs($15)%4:0}

convert_colors_fwd=${arg\ 1+$cs_mode,none,rgb2ryb,cs_error,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch}
convert_colors_bwd=${arg\ 1+$cs_mode,none,ryb2rgb,cs_error,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb}

if $cs_mode>2
 if $cs_mode>=3&&$cs_mode<7 cutf_vals=0,360,0,100,0,1,0,255
 elif $cs_mode==7 cutf_vals=0,100,-176,176,-176,176,0,255
 else cutf_vals=0,100,0,255,{-pi},{pi},0,255
 fi
fi

if $z_convolve
 offpixel={$z_convolve*-1}
 onpixel={($z_convolve)*2+1}
 ($offpixel/$onpixel/$offpixel)
 store. zmap
fi

tile_w={abs($form_quad_lx)}
tile_h={abs($form_quad_ly)}
if $tile_w&&$tile_w<4 __$tw=4 fi
if $tile_h&&$tile_h<4 __$th=4 fi
if !($tile_w||$tile_h) error "\$tile_w||\$tile_h==F"  fi
tile_w={!$tile_w?$tile_h:$tile_w}
tile_h={!$tile_h?$tile_w:$tile_h}
tile_wh={$tile_w*$tile_h}

mw=${-max_w}
mh=${-max_h}
nw={ceil($mw/$tile_w)*$tile_w}
nh={ceil($mh/$tile_h)*$tile_h}

if ${is_image_arg\ $1}
 pass$1 0
 if s<=4&&s>1
  if s==3
   to_gray.
  else
   s. c,{if(s==4,-3,if(s==2,-1,-s))}
   to_gray..
   *[-2,-1]
  fi
 elif s==5
  s. c,-4 cmyk2rgb.. to_gray.. *[-2,-1]
 fi
else
 sid="$1"
 if isnum($1) if isint($1)
  sid=${"-arg "1+$sid"","australia,barbedwire,circle,crosshair,cupid,diamond,dragon,dragonfly,fern,flip,gear,gumleaf,heart,information,kookaburra,mail,mapleleaf,paint_splat,paw,phone,polygon,rooster,shopping_cart,snowflake,star"}
 fi fi
 if $#>15 shape_$sid {max($tile_w,$tile_h)*$sub},${16--1}
 else shape_$sid {max($tile_w,$tile_h)*$sub}
 fi
 r. {ceil(w/$tile_w)*$tile_w},{ceil(h/$tile_h)*$tile_h},100%,100%,0,0,.5,.5
fi

if $ang-360*floor($ang/360) rotate. $ang,1 fi

if   $mirror==1 mirror. x
elif $mirror==2 mirror. y
fi

n. 0,1 autocrop. 0

if $fit_tile
 shape_image_ratio={w#-1/h#-1}
 target_image_ratio={$tile_w/$tile_h}
 resize_width={$target_image_ratio>$shape_image_ratio?w#-1*($tile_h/h#-1):$tile_w}
 resize_height={$target_image_ratio>$shape_image_ratio?$tile_h:h#-1*($tile_w/w#-1)}
 r. {$resize_width*$form_ratio},{$resize_height*$form_ratio},1,1,{$interpolation},0,.5,.5
 r. $tile_w,$tile_h,1,1,0,0,.5,.5
else
 r. {w#-1*(1/$form_ratio)},{h#-1*(1/$form_ratio)},1,1,0,0,.5,.5
 r. $tile_w,$tile_h,1,1,{$interpolation},0,.5,.5
fi

cut. 0,1 n. 0,1

avgc={avg(crop(#-1))}

if $tile_boundary
 if $tile_boundary==1
  +mirror. x
  a[-2,-1] z
 elif $tile_boundary==2
  +mirror. y
  a[-2,-1] z
 else
  +mirror. x
  +mirror.. y
  +mirror. x
  a[-4--1] z
 fi
fi

repeat $!-1 l[$<,-1]
 ntw={ceil(w#0/$tile_w)}
 nth={ceil(h#0/$tile_h)}
 rw={$ntw*$tile_w}
 rh={$nth*$tile_h}
 ss={s#0}

 if $var_kodl>1
  if $var_kodl==3 +store[0] kodl_image fi
  ow={w#0}
  oh={h#0}
  r[0] $rw,$rh,100%,100%,0,$image_boundary,.5,.5
 elif $var_kodl==1
  r[0] $rw,$rh,100%,100%,0,$image_boundary,.5,.5
  +store[$<] kodl_image
 else
  r[0] $rw,$rh,100%,100%,0,$image_boundary,.5,.5
 fi
 
 if $cs_mode&&(s#0>=3)
  if $cs_mode!=2
   $convert_colors_fwd[0]
  else
   if s#$<==3 rgb2cmyk[0]
   else l[0] s c,-3 rgb2cmyk.. a c endl
   fi
  fi
 fi

 $ntw,$nth,2,{s#0},:"begin(
  const avg_c=$avgc;
  const tw=$tile_w;
  const th=$tile_h;
  const wwhh=$tile_wh;
  const w_avg=wwhh*avg_c;
  const iw_avg=wwhh-w_avg;
  $tile_boundary>2?(
   find_pos()=1+x%2+y%2*2;
   ti_0=crop(#-1,0,0,0,0,$tile_w,$tile_h,1,1);
   ti_1=crop(#-1,0,0,1,0,$tile_w,$tile_h,1,1);
   ti_2=crop(#-1,0,0,2,0,$tile_w,$tile_h,1,1);
   ti_3=crop(#-1,0,0,3,0,$tile_w,$tile_h,1,1);
   i_ti_0=1-ti_0;
   i_ti_1=1-ti_1;
   i_ti_2=1-ti_2;
   i_ti_3=1-ti_3;
   generate_color_a()=(
    if(z
    ,sum(crop_area*i_ti_0)/iw_avg;
    ,sum(crop_area*ti_0)/w_avg;
    );
   );
   generate_color_b()=(
    if(z
    ,sum(crop_area*i_ti_1)/iw_avg;
    ,sum(crop_area*ti_1)/w_avg;
    );
   );
   generate_color_c()=(
    if(z
    ,sum(crop_area*i_ti_2)/iw_avg;
    ,sum(crop_area*ti_2)/w_avg;
    );
   );
   generate_color_d()=(
    if(z
    ,sum(crop_area*i_ti_3)/iw_avg;
    ,sum(crop_area*ti_3)/w_avg;
    );
   );
   generate_color()=arg(find_pos(),generate_color_a(),generate_color_b(),generate_color_c(),generate_color_d());
  ):
  $tile_boundary?(
   $tile_boundary==2?(find_pos()=y%2;):(find_pos()=x%2;);
   ti_0=crop(#-1,0,0,0,0,$tile_w,$tile_h,1,1);
   ti_1=crop(#-1,0,0,1,0,$tile_w,$tile_h,1,1);
   i_ti_0=1-ti_0;
   i_ti_1=1-ti_1;
   generate_color()=(
    find_pos()?(
     if(z
     ,sum(crop_area*i_ti_1)/iw_avg;
     ,sum(crop_area*ti_1)/w_avg;
     );
    ):(
     if(z
     ,sum(crop_area*i_ti_0)/iw_avg;
     ,sum(crop_area*ti_0)/w_avg;
     );
    );
   );
  ):(
   ti_0=crop(#-1,0,0,0,0,$tile_w,$tile_h,1,1);
   i_ti_0=1-ti_0;
   generate_color()=(
    if(z
    ,sum(crop_area*i_ti_0)/iw_avg;
    ,sum(crop_area*ti_0)/w_avg;
    );
   );
  );
 );
 crop_area=crop(#0,x*$tile_w,y*$tile_h,0,c,$tile_w,$tile_h,1,1);
 generate_color();"
 
 if $z_convolve
  $zmap
  convolve.. .,$z_convolve_boundary
  rm.
 fi
 
 if $cs_mode>=2&&(s#-1>=3)
  if $cs_mode!=2
   sh. 0,2
   if $z_convolve rep_mc. $cutf_vals fi
   $convert_colors_bwd.
   rm.
  else
   if s#-1==4 cmyk2rgb.
   else s. c,-4 cmyk2rgb.. a[-2,-1] c
   fi
   if $z_convolve cut. 0,255 fi
  fi
 else
  if $cs_mode $convert_colors_bwd. fi
  if $z_convolve cut. 0,255 fi
 fi
 
 $ntw,$nth,1,1,:"begin(
  const ss=s#-1;
  const length=$tile_wh*ss;
  nv()=vc_0+vc_1*tile_v;
  $tile_boundary==3?(
   find_pos()=1+x%2+y%2*2;
   ti_0=crop(#-2,0,0,0,0,$tile_w,$tile_h,1,1);
   ti_1=crop(#-2,0,0,1,0,$tile_w,$tile_h,1,1);
   ti_2=crop(#-2,0,0,2,0,$tile_w,$tile_h,1,1);
   ti_3=crop(#-2,0,0,3,0,$tile_w,$tile_h,1,1);
   tile_v0=resize(ti_0,length,0,2);
   tile_v1=resize(ti_1,length,0,2);
   tile_v2=resize(ti_2,length,0,2);
   tile_v3=resize(ti_3,length,0,2);
   generate_tile()=(
    tile_v=arg(find_pos(),tile_v0,tile_v1,tile_v2,tile_v3);
    nv=nv();
    draw(#0,nv,x*$tile_w,y*$tile_h,0,0,$tile_w,$tile_h,1,ss);    
   );
  ):
  $tile_boundary?(
   $tile_boundary==2?(find_pos()=y%2;):(find_pos()=x%2;);
   ti_0=crop(#-2,0,0,0,0,$tile_w,$tile_h,1,1);
   ti_1=crop(#-2,0,0,1,0,$tile_w,$tile_h,1,1);
   tile_v0=resize(ti_0,length,0,2);
   tile_v1=resize(ti_1,length,0,2);
   generate_tile()=(
    tile_v=find_pos()?tile_v1:tile_v0;
    nv=nv();
    draw(#0,nv,x*$tile_w,y*$tile_h,0,0,$tile_w,$tile_h,1,ss);
   );
  ):(
   ti=crop(#-2,0,0,0,0,$tile_w,$tile_h,1,1);
   tile_v=resize(ti,length,0,2);
   generate_tile()=(
    nv=nv();
    draw(#0,nv,x*$tile_w,y*$tile_h,0,0,$tile_w,$tile_h,1,ss);
   );
  );
 );
 c0=J(#-1,0,0,1);
 c1=I(#-1);
 diff_colors=c1-c0;
 vc_0=resize(c0,length,1,0);
 vc_1=resize(diff_colors,length,1,0);
 generate_tile();"
 
 if $var_kodl
  l[0]
   if $var_kodl==1 r 100%,100%,100%,$ss $kodl_image rv
   else
    if $var_kodl==3 
     $kodl_image 
     rv 
    fi
    r $ow,$oh,100%,$ss,0,0,.5,.5
   fi
  endl
 else
  r[0] 100%,100%,100%,$ss,0,0
 fi
 
 rm[-2,-1]
endl done
rm.
#@cli rep_tfrac: eq. to 'rep_thorn_fractal' : (+)
rep_tfrac: rep_thorn_fractal $*
#@cli rep_thorn_fractal: -inf<=style<=47,_escape>0,_iteration>0,_subsampling_level>=1,_dx,_dy,_r_xy>0,_r_x>0,_r_y>0,_r_pi= { 0=r_xy multiplied by 1 | 1=r_xy multiplied by pi },_o_x,_o_y,_function_angle,_vx,_vy,..._vx_n,vy_n : \ : \ -inf<=style<=47,_escape>0,_iteration>0,_subsampling_level>=1,_dx,_dy,_r_xy>0,_r_x>0,_r_y>0,_r_pi= { 0=r_xy multiplied by 1 | 1=r_xy multiplied by pi },_o_x,_o_y,_function_angle,_vx,_vy,..._vx_n,vy_n,ovx,ovy,overload_freq>=1 : \ : \ -inf<=style<=47,_escape>0,_iteration>0,_subsampling_level>=1,_dx,_dy,_r_xy>0,_r_x>0,_r_y>0,_r_pi= { 0=r_xy multiplied by 1 | 1=r_xy multiplied by pi },_o_x,_o_y,_function_angle,_vx,_vy,..._vx_n,vy_n,ovx,ovy,cfa,cfb,overload_freq>=1
#@cli : Thorn Fractal is the fractal attributed to Andrew Wayne Graff, alternatively named the "Secant Sea". The code was adapted from Sample C source code provided by Adam Majewski.
#@cli :
#@cli : Source - http://paulbourke.net/fractals/thorn/#dane
#@cli :
#@cli : Alternating Chaos Formula are alternating formula founded by MadJik and are originally implemented in Fractal Attractor Plugin for Paint.NET. They use overload functions rather than a simple switch.
#@cli :
#@cli : (eq. to 'rep_tfrac').
#@cli : 'style' variable is used to define how the thorn fractal will look like with predefined formula. Use a integer value less than 0 to use custom formula, and use a integer value less than -1 to use custom alternating formula. See lists of available style and their corresponding id below.
#@cli : 'escape' variable is used to define the minimum value to escape from the iterative loop.
#@cli : 'iteration' variable defines how much repetition of loop used to find the end value.
#@cli : 'subsampling_level' defines the subsampling level of image.
#@cli : 'dx' is a number used to add to a variable involving distortion within the x-axis during the loop used for fractal generation.
#@cli : 'dy' is a number used to add to a variable involving distortion within the y-axis during the loop used for fractal generation.
#@cli : 'r_xy' defines how much the general infinite line boundary will repeat within the xy axis.
#@cli : 'r_x' defines how much the general infinite line boundary will repeat within the x axis.
#@cli : 'r_y' defines how much the general infinite line boundary will repeat within the y axis.
#@cli : 'r_pi' is used as a multiple to r_xy or to normalize the xmin and xmax to pi ranges.
#@cli : 'o_x' offset the resulting image within the x-direction.
#@cli : 'o_y' offset the resulting image within the y-direction.
#@cli : 'ang' defines the function angle of the thorn fractal.
#@cli : 'vx' variable is used to define custom formula for vx variable for the thorn fractal formula by default.
#@cli : 'vy' variable is used to define custom formula for vy variable for the thorn fractal formula by default.
#@cli : 'vx_n' variable defines a custom formula used for vx variable depending on altern number.
#@cli : 'vy_n' variable defines a custom formula used for vy variable depending on altern number.
#@cli : 'ovx' variable defines a custom formula to be used when the altern is greater than the range of cardinality of set of set[vx,vy]. 'o' in ovx stands for overload.
#@cli : 'ovx' variable defines a custom formula to be used when the altern is greater than the range of cardinality of set of set[vx,vy]. 'o' in ovx stands for overload.
#@cli : 'cfa' variable defines a variable that is used by overload formulas. Used as a temporary constant for each number that exceed the cardinality of set of set[vx,vy].
#@cli : 'cfb' variable defines a variable that is used by overload formulas. Used as a temporary constant for each number that exceed the cardinality of set of set[vx,vy].
#@cli : 'overload_freq' defines how much the ovx,and ovy formula will be applied when altern is greater than the range of cardinality of set of set[vx,vy].
#@cli : - Note on custom formula usage -\n
#@cli : Available adjustible variable: v,vx,vy,dx,dy,a,b,cfa,cfb\n
#@cli : 'v' is the iteration number within loop.
#@cli : 'vx' is the output of distortion function for x-axis.
#@cli : 'vy' is the output of distortion function for y-axis.
#@cli : 'dx' is the distortion-x number.
#@cli : 'dy' is the distortion-y number.
#@cli : 'a' defines result of number defined by vx equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.
#@cli : 'b' defines result of number defined by vy equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.
#@cli : 'cfa' is the output of overload function for x-axis.
#@cli : 'cfb' is the output of overlload function for x-axis.
#@cli :
#@cli : Multiple expressions are supported, and they are separated by the character semicolon-[;]. Furthermore, the usage of commas-[,] requires you to wrap them around with quotation marks-["]. See example of usage with commas. If it the only expression, then it would be used for calculation of vx or vy. Otherwise, the first expression may be the only one used for calculation of vx or vy.
#@cli :
#@cli : - End of Note on custom formula usage -
#@cli :
#@cli : - Style List -
#@cli :
#@cli : List here below contains all the list of style. The 'asterisk' or * means the line contains a note.
#@cli :
#@cli :   n<-1* = Custom Alternating Formula
#@cli :   -1 = Custom Formula
#@cli :   0  = Normal
#@cli :   1  = Normal Inverted
#@cli :   2  = Arcangent
#@cli :   3  = Tangent
#@cli :   4  = Tanh Stroke
#@cli :   5  = Asymphological Vibrato
#@cli :   6  = Asymphological Basic
#@cli :   7  = Asymphological Basic 2
#@cli :   8  = Asymphochaos
#@cli :   9  = Petallian
#@cli :   10 = Semi-Thorny Petallian
#@cli :   11 = Thorny Petal
#@cli :   12 = Thorny Petal 2
#@cli :   13 = Inflation
#@cli :   14 = Inflation 2
#@cli :   15 = Chaotic Creation
#@cli :   16 = Earthing
#@cli :   17 = Acrylic Earthing
#@cli :   18 = Unearthing Origami
#@cli :   19 = Cubic Unearthing
#@cli :   20 = Webbing Cubic Unearthing
#@cli :   21 = Unearthing Chaotic Hooks
#@cli :   22 = Chaotic Hooks
#@cli :   23 = Sinusoidal Liquid
#@cli :   24 = Cosinusoidal Liquid
#@cli :   25 = Echo Wide
#@cli :   26 = Echo Squircle
#@cli :   27 = Echo Hall
#@cli :   28 = Echo Hall 2
#@cli :   29 = Liquid Parabolic
#@cli :   30 = Chaos-Vibrato
#@cli :   31 = Chaos Deep-Vibrato
#@cli :   32 = Chaos Spacetime
#@cli :   33 = Parabolic
#@cli :   34 = Parabolic Chaos
#@cli :   35 = Cubic-Diamond Chaos
#@cli :   36 = C-Line
#@cli :   37 = Contour Chaos
#@cli :   38 = Spiderweb-Diamond
#@cli :   39 = Acrylica
#@cli :   40 = Refractive Space
#@cli :   41 = Smooth-Artistry
#@cli :   42 = Ferrofluid
#@cli :   43 = Triangular Interweaving
#@cli :   44 = Fabric Chaos
#@cli :   45 = Reverse Tangent Division
#@cli :   46 = Chaotic Tangent
#@cli :   47 = Alternating Chaos 0
#@cli :   48 = Alternating Chaos 1 (Legacy)
#@cli :   49 = Alternating Chaos 2 (Legacy)
#@cli :   50 = Alternating Chaos 3 (Legacy)
#@cli :   51 = Alternating Chaos 4 (Legacy)
#@cli :   52 = Alternating Chaos 5 (Legacy)
#@cli :   53 = Alternating Chaos 1
#@cli :   54 = Alternating Chaos 2
#@cli :   55 = Alternating Chaos 3
#@cli :   56 = Alternating Chaos 4
#@cli :   57 = Alternating Chaos 5
#@cli :
#@cli : * = The absolute of value is the numbers of vx,vy next to '_function_angle'. Per loop, every two different functions are assigned instead.
#@cli :
#@cli : - End Style List -
#@cli :
#@cli : Author: Reptorian.
#@cli : Default values: '_escape=50000','_iteration=255','_subsampling_level=4','_dx=0','_dy=0','_r_xy=1','_r_x=1','_r_y=1','_r_pi=1','_o_x=0','_o_y=0','_function_angle=0','_custom_x=','_custom_y='
#@cli : $ 1024,1024 rep_thorn_fractal -1,10000,255,4,2.544,-5.2424,1,1,1/2,1,0,0,30,atan2(a"^"2\,b"^"2)/cos(b),b/sin(a)
rep_thorn_fractal:
skip ${2=50000},${3=255},${4=4},${5=0},${6=0},${7=1},${8=1},${9=1},${10=1},${11=0},${12=0},${13=0},${14=},${15=}
if $1<0 if !(narg($14)&&narg($15)) error "When using custom formula, there must be an arguments into custom_x and custom_y variables" fi fi
if $1>57 error "$"1<57==F fi
if $2<=0 error "$"2>0==F fi
if $3<1 error "$"3>0==F fi
if $4<1 error "$"4>0==F fi
if !(($7>0&&$8>0)&&$9>0) error "Repeat variables cannot be 0!" fi

if $1>52
 chaos_a=a/cfb
 chaos_b=b/cfa
else
 chaos_a=a
 chaos_b=b
fi

if $1<0
 bounds=abs($1)*2
 if narg($*)==18+$bounds activate_overload=2
 elif narg($*)==16+$bounds activate_overload=1
 else activate_overload=0
 fi
else activate_overload=0
fi

if $activate_overload!=2&&$1<0
 repeat narg(${14--1})
  $=t
  it=${t{$>+14}}
  n={$>+14}
  strcontains $it,cfa
  if ${} error \$\-1!=2?!incl(\$$n,cfa):T==F fi
  strcontains $it,cfb
  if ${} error \$\-1!=2?!incl(\$$n,cfb):T==F fi
  if ('$it'=='cfa')||('$it'=='cfb') error overload!=2?str_incl(cfa):T==F fi
 done
fi

if $activate_overload==2
 fta=$-3
 ftb=$-2
 if $-1>0 ovf_place_pos=if(use_altlim,if(altern==altlim,cfa=fta();cfb=ftb();););
 elif $-1<0 ovf_place_neg=if(use_altlim,if(altern==altlim,cfa=fta();cfb=ftb();););
 else activate_overload=0
 fi
else
 fta=atan(vx)
 ftb=atan(vy)
 if $1>52 ovf_place_pos=if(use_altlim,if(altern==altlim,cfa=fta();cfb=ftb(););); fi
fi

repeat $! l[$>]

 ww={w}
 hh={h}

 iw={int($4*$ww)}
 ih={int($4*$hh)}

 if !($iw%2) iw+=1 fi
 if !($ih%2) ih+=1 fi

 $iw,$ih,1,1 k.

 f "begin(altern=0;
  vec_w=expr('const hw=w/2;(x/hw)-1;',w,1,1,1);
  vec_h=expr('const hw=w/2;(x/hw)-1;',h,1,1,1);
  const sd=max(w,h)/min(w,h);
  if(w>h,vec_w*=sd;,vec_h*=sd;);
  const chaos=$1>46;
  const ang=pi*($13/180);
  const cos_ang=cos(ang);
  const sin_ang=sin(ang);
  const ox=$11*cos_ang-$12*sin_ang;
  const oy=$11*sin_ang+$12*cos_ang;
  const dx=$5;
  const dy=$6;
  const rpi=($10?pi:1);
  const szx=$8*rpi*$7;
  const szy=$9*rpi*$7;
  const overload=$activate_overload;
  const activate_alt_bool=chaos||$1<-1||($1==-1&&overload);
  const use_altlim=($1<0&&(overload==2))||$1>52;
  chaos?(const altlim=3;)
  :(use_altlim?(
    const max_vec_pos=(overload?($-1<0?0:1):1);
    const altlim=abs($1)-max_vec_pos;
    const overlim=altlim+max_vec_pos;
   ):(
    const altlim=abs($1)-1;
    const overlim=altlim+1;
   );
  );
  cfa=cfb=1;
  vx=vy=0;
  fta()="$fta";
  ftb()="$ftb";
  overload?(const count_overload=abs($-1);):(const count_overload=0;);
  chaos?(
   if(use_altlim
   ,const ff=$1-49;
   ,const ff=$1-44;
   );
  ):(const ff=abs($1)-1+count_overload;);
  ($1<-1||($1==-1&&overload))?(
   overload?(
    use_altlim?(
     vxf(a,b)=arg(min(altern,overlim)+1,${14--4:2});
     vyf(a,b)=arg(min(altern,overlim)+1,${15--4:2});
    ):(
     vxf(a,b)=arg(min(altern,overlim)+1,${14--2:2});
     vyf(a,b)=arg(min(altern,overlim)+1,${15--2:2});
    );
   ):(
    vxf(a,b)=arg(altern+1,${14--1:2});
    vyf(a,b)=arg(altern+1,${15--1:2});
   );
  ):
  $1==-1?(
   vxf(a,b)=$14;
   vyf(a,b)=$15;
  ):
  $1==0?(
   vxf(a,b)=a/cos(b);
   vyf(a,b)=b/sin(a);
  ):
  $1==1?(
   vxf(a,b)=a/sin(b);
   vyf(a,b)=b/cos(a);
  ):
  $1==2?(
   vxf(a,b)=a/atan(b);
   vyf(a,b)=b/atan(a);
  ):
  $1==3?(
   vxf(a,b)=a/tan(b);
   vyf(a,b)=b/tan(a);
  ):
  $1==4?(
   vxf(a,b)=a/cos(b)*sin(b);
   vyf(a,b)=b/sin(a)*cos(a);
  ):
  $1==5?(
   vxf(a,b)=a*tan(a*b)/sin(b);
   vyf(a,b)=b*tan(a*b)/cos(a);
  ):
  $1==6?(
   vxf(a,b)=(a+tan(a*b))/sin(b);
   vyf(a,b)=(b+tan(a*b))/cos(a);
  ):
  $1==7?(
   vxf(a,b)=(a-tan(a*b))/sin(b);
   vyf(a,b)=(b-tan(a*b))/cos(a);
  ):
  $1==8?(
   vxf(a,b)=a/cos(b)+a/sin(b);
   vyf(a,b)=b/cos(a)+b/sin(a);
  ):
  $1==9?(
   vxf(a,b)=a/(cos(b)*sin(b));
   vyf(a,b)=b/(sin(a)*cos(a));
  ):
  $1==10?(
   vxf(a,b)=a/(cos(tan(b))*sin(tan(b)));
   vyf(a,b)=b/(sin(tan(a))*cos(tan(a)));
  ):
  $1==11?(
   vxf(a,b)=(tan(a)+b)/(cos(tan(b))*sin(tan(b)));
   vyf(a,b)=(tan(b)+a)/(sin(tan(a))*cos(tan(a)));
  ):
  $1==12?(
   vxf(a,b)=(a+tan(a)+tan(b))/(cos(tan(b))*sin(tan(b)));
   vyf(a,b)=(b+tan(a)+tan(b))/(sin(tan(a))*cos(tan(a)));
  ):
  $1==13?(
   vxf(a,b)=(a+tan(a)+tan(b))/cos(a);
   vyf(a,b)=(b+tan(a)+tan(b))/sin(a);
  ):
  $1==14?(
   vxf(a,b)=(a+tan(a)+tan(b))/sin(b);
   vyf(a,b)=(b+tan(a)+tan(b))/cos(a);
  ):
  $1==15?(
   vxf(a,b)=a/sin(cos(b)*sin(b));
   vyf(a,b)=b/cos(sin(a)*cos(a));
  ):
  $1==16?(
   vxf(a,b)=(a+tan(a)/tan(b))/cos(a);
   vyf(a,b)=(b+tan(a)/tan(b))/sin(b);
  ):
  $1==17?(
   vxf(a,b)=(b+tan(a)/tan(b))/cos(a);
   vyf(a,b)=(a+tan(a)/tan(b))/sin(b);
  ):
  $1==18?(
   vxf(a,b)=(b+tan(b)/tan(a))/cos(a);
   vyf(a,b)=(a+tan(a)/tan(b))/sin(b);
  ):
  $1==19?(
   vxf(a,b)=(b+tan(b)/tan(a))/cos(a);
   vyf(a,b)=(a+tan(b)/tan(a))/sin(b);
  ):
  $1==20?(
   vxf(a,b)=(b+tan(a)/tan(a))/cos(a);
   vyf(a,b)=(a+tan(b)/tan(a))/sin(b);
  ):
  $1==21?(
   vxf(a,b)=b+tan(a)/a/cos(b)+a/sin(b);
   vyf(a,b)=a+tan(b)/b/cos(a)+b/sin(a);
  ):
  $1==22?(
   vxf(a,b)=b+tan(a)/(a/cos(b))+a/sin(b);
   vyf(a,b)=a+tan(b)/(b/cos(a))+b/sin(a);
  ):
  $1==23?(
   vxf(a,b)=a+3*sin(b)-pi;
   vyf(a,b)=a+b+3*sin(a)-pi;
  ):
  $1==24?(
   vxf(a,b)=a+3*cos(b)-pi;
   vyf(a,b)=a+b+3*cos(a)-pi;
  ):
  $1==25?(
   vxf(a,b)=a/sin(a/sin(b));
   vyf(a,b)=b/cos(b/cos(a));
  ):
  $1==26?(
   vxf(a,b)=a/cos(a/sin(b));
   vyf(a,b)=b/sin(b/cos(a));
  ):
  $1==27?(
   vxf(a,b)=a/cos(a/atan(sin(b)));
   vyf(a,b)=b/sin(b/atan(cos(a)));
  ):
  $1==28?(
   vxf(a,b)=a/sin(a/atan(cos(b)));
   vyf(a,b)=b/cos(b/atan(sin(a)));
  ):
  $1==29?(
   vxf(a,b)=a/atan(cos(b));
   vyf(a,b)=b/atan(sin(a));
  ):
  $1==30?(
   vxf(a,b)=(a+tanh(a*b))/cos(b);
   vyf(a,b)=(b+tanh(a*b))/sin(a);
  ):
  $1==31?(
   vxf(a,b)=b+tan(b)/(a/(cos(b)))+a/(sin(a));
   vyf(a,b)=a+tan(a)/(b/(cos(a)))+b/(sin(b));
  ):
  $1==32?(
   vxf(a,b)=(a+tanh(a+b))/cos(b);
   vyf(a,b)=(b+tanh(a+b))/sin(a);
  ):
  $1==33?(
   vxf(a,b)=a/sin(b)/tan(b);
   vyf(a,b)=b/cos(a)/tan(a);
  ):
  $1==34?(
   vxf(a,b)=a/(tan(b)*cos(b)*sin(b));
   vyf(a,b)=b/(tan(a)*cos(a)*sin(a));
  ):
  $1==35?(
   vxf(a,b)=a/tan(cos(b));
   vyf(a,b)=b/tan(sin(a));
  ):
  $1==36?(
   vxf(a,b)=(a+tanh(a*b))/(cos(b)*sin(a));
   vyf(a,b)=(b+tanh(a*b))/(sin(b)*cos(a));
  ):
  $1==37?(
   vxf(a,b)=(a+tan(cos(a)*sin(b)))/cos(a);
   vyf(a,b)=(b+tan(sin(a)*cos(b)))/sin(b);
  ):
  $1==38?(
   vxf(a,b)=(tan(a+b)*b)/cos(b);
   vyf(a,b)=(tan(a-b)*a)/sin(a);
  ):
  $1==39?(
   vxf(a,b)=a/cos(b)*sin(a);
   vyf(a,b)=b/sin(a)*cos(b);
  ):
  $1==40?(
   vxf(a,b)=a/tan(cos(b)+sin(b));
   vyf(a,b)=b/tan(cos(a)+sin(a));
  ):
  $1==41?(
   vxf(a,b)=a+(tanh(a+b)/cos(b));
   vyf(a,b)=b+(tanh(a+b)/sin(a));
  ):
  $1==42?(
   vxf(a,b)=(a/(cos(b)))/(b/(sin(a)));
   vyf(a,b)=(b/(cos(a)))/(a/(sin(b)));
  ):
  $1==43?(
   vxf(a,b)=(a*tan(a+b))/sin(b);
   vyf(a,b)=(b*tan(a+b))/cos(a);
  ):
  $1==44?(
   vxf(a,b)=a/(atan2(b^2,a^2)*tan(b));
   vyf(a,b)=b/(atan2(b^2,a^2)*tan(a));
  ):
  $1==45?(
   vxf(a,b)=tan(a)/b;
   vyf(a,b)=tan(b)/a;
  ):
  $1==46?(
   vxf(a,b)=a/atan(b/cos(a/sin(a)));
   vyf(a,b)=b/atan(a/sin(b/cos(b)));
  ):
  $1>46?(
   vxf(a,b)=
    altern==0?a/cos(b):
    altern==1?a/sin(b):
    altern==2?a/tan(b):
    altern==3?a/atan(b):
             "$chaos_a";
   vyf(a,b)=
    altern==0?b/sin(a):
    altern==1?b/cos(a):
    altern==2?b/tan(a):
    altern==3?b/atan(a):
             "$chaos_b";
  );
 );
 xx=vec_w[x];
 yy=vec_h[y];
 zx=szx*((xx*cos_ang-yy*sin_ang)+ox);
 zy=szy*((xx*sin_ang+yy*cos_ang)+oy);
 vx=zx;
 vy=zy;
 repeat($3,v,
  a=vx;
  b=vy;
  "$ovf_place_neg"
  vx=vxf(a,b);
  vy=vyf(a,b);
  "$ovf_place_pos"
  vx+=dx;
  vy+=dy;
  if(activate_alt_bool,
   altern++;
   if(altern>ff,altern=0);
  );
  if((vx^2+vy^2)>$2,break());
 );
 abs(zx)!=0&&abs(zy)!=0?v;"
 r {$ww},{$hh},1,1,5
endl done
#@cli rep_noise_poissondisk_to_coordinates : _radius[%]>0,_max_sample_attempts>0,_use_mask={ 0=ignore_mask | 1=utilize_mask }
#@cli : Generates coordinates utilizing a fast poisson disk generation. Forked from Garagecoder original code just for this purpose. Requires a image to have a mask.
#@cli : Implements the algorithm from the article "Fast Poisson Disk Sampling in Arbitrary Dimensions",
#@cli : by Robert Bridson (SIGGRAPH'2007).
#@cli : Default values: 'radius=8' and 'max_sample_attempts=30'.
#@cli : $ 300,300 rep_noise_poissondisk_to_coordinates 8
rep_noise_poissondisk_to_coordinates :
skip "${3=0}"
check "${1=8}>0 && ${2=50}>0"
e[^-1] "Extract poisson disk sampling points coordinates with radius $1 and max sample attempts $2."
repeat $! l[$>]

 R={${"is_percent $1"}?max(w,h,d)*$1:$1}

 dim={d>1?3:h>1?2:1}
 cw={0.999*$R/sqrt($dim)}

 ({[w,h,d,1]}) y. c

 {[ceil(I/$cw)]}

 r[1] 1,1,1,$dim,-1

 1,1,1,$dim 1,1,1,1

 {vector$dim(2*ceil(sqrt($dim))+1)}

 r. 100%,100%,100%,2

 f. "P=[x,y,z]-int([w/2,h/2,d/2]);[sum(sqr(P)),dot(P,[1,w#2,w#2*h#2])]"

 r. {[whd,s,1,1,-1]} sort. +,x z. 0,1,100%,100% y. c

 eval ${-math_lib}"

  begin(
   dotoff = resize([ 1,w#2,w#2*h#2 ],d#2>1?3:h#2>1?2:1,0););
   const N = "$dim";
   const radius = "$R";
   const grid_cw = "$cw";
   const max_sample_attempts = $2;
   const value = iM#0 + (im#0==iM#0);
   const use_mask = $3;

   mag2(vec) = sum(sqr(vec));
   prox = I#5;
   lim = I#1;
   dar_insert(#3,I#1,0);               # dummy sample to simplify bounds checks
   dar_insert(#3,u(I#1),1);            # add initial sample to list
   dar_insert(#4,1,0);                 # add its index to active list
   I(#2,int(I[#3,1]/grid_cw)) = 1;     # add its index to grid cell
   I(#0,I[#3,1]) = value;              # draw the point

   while (dar_size(#4)>0,

    R = int(u(dar_size(#4)-1e-4));    # choose a random active list index
    P = i[#4,R];                      # get the index of that sample
    T = I[#3,P];                      # position vector of that sample

    repeat (max_sample_attempts,attempts,

     do (S = 4*(u(vectorN(1)) - 0.5); M = mag2(S), M <= 1 || M > 4);
     X = T + radius * S;
     if (min(X)<0 || min(lim-X)<0, continue());
     G = int(X/grid_cw);
     GI = dot(G,dotoff);

     for (K = 0; rejected = 0, K<size(prox), ++K,
      V = i[#2,GI+prox[K]];         # sample index from grid to check
      if (V>0 && mag2(I[#3,V]-X)<sqr(radius), rejected = 1; break())
     );

     if (!rejected,
      if(use_mask,!sum(I(#0,X))?break(););
      Q = dar_size(#3);               # sample found, get new index
      dar_insert(#3,X);               # insert into samples list
      dar_insert(#4,Q);               # insert its index into active
      I(#2,G) = Q;                    # insert its index into grid
      break();
     );
    );
    if (attempts==max_sample_attempts, dar_remove(#4,R));
   );
   end(resize(#3,1,dar_size(#3),1,s(#3),0););
   "
   td={(w#0>1)+(h#0>1)+(d#0>1)}
   td-=1
   channels[3] 0,$td
   k[3]
endl done
#@gui _<b>Testing</b>
#@gui <i>Reptorian</i>
#@gui Modulos Operation:fx_rep_modo,fx_rep_modo_preview
#@gui :_=note("<b>Initial</b>")
#@gui :Colour Space=choice(0,"RGB","sRGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui :Edit Multiple Channels at once?=bool(0)
#@gui :Reverse Layers?=bool(0)
#@gui :_=separator(),_=note("<b>Operation</b>")
#@gui :Channel Set=choice(0,"Color Channels","Alpha")
#@gui :Channel=choice(0,"First","Second","Third")
#@gui :Channel=choice(0,"First","Second","Third","Fourth")
#@gui :Channel=choice(0,"First","Second","Third","Fourth","Fifth")
#@gui :Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
#@gui :Factor (%)=float(100,0,100)
#@gui :Use Layer as Factor instead?=bool(0)
#@gui :Negate?=bool(0)
#@gui :Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
#@gui :Factor (%)=float(100,0,100)
#@gui :Use Layer as Factor instead?=bool(0)
#@gui :Negate?=bool(0)
#@gui :Disable Effect for Channel #1=bool(0)
#@gui :Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
#@gui :Factor (%)=float(100,0,100)
#@gui :Use Layer as Factor instead?=bool(0)
#@gui :Negate?=bool(0)
#@gui :Disable Effect for Channel #2=bool(0)
#@gui :Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
#@gui :Factor (%)=float(100,0,100)
#@gui :Use Layer as Factor instead?=bool(0)
#@gui :Negate?=bool(0)
#@gui :Disable Effect for Channel #3=bool(0)
#@gui :Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
#@gui :Factor (%)=float(100,0,100)
#@gui :Use Layer as Factor instead?=bool(0)
#@gui :Negate?=bool(0)
#@gui :Disable Effect for Channel #4=bool(0)
#@gui :Operation=choice(3,"Modulo","Modulo - Continuous","Divisive Modulo","Divisive Modulo - Continuous","Additive Modulo","Additive Modulo Continuous")
#@gui :Factor (%)=float(100,0,100)
#@gui :Use Layer as Factor instead?=bool(0)
#@gui :Negate Alpha?=bool(0)
#@gui :Disable Effect for Alpha=bool(1)
#@gui :Disable Effect for Colour Channel #1=bool(0)
#@gui :Disable Effect for Colour Channel #2=bool(0)
#@gui :Disable Effect for Colour Channel #3=bool(0)
#@gui :Disable Effect for Colour Channel #4=bool(0)
#@gui :Disable Effect for Alpha Channel?=bool(1)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/10/20</i>.</small>")
fx_rep_modo:
if ($1>=0&&$1<4)||$1>=9 color_id=[{vector3(255)}]
elif $1==4 color_id=[{vector4(255)}]
elif $1<9 color_id=[360,1,1]
fi

if $1==4 v_n={$2?(!$37&&$11):(!$16&&$15)},{$2?(!$38&&$11):(!$21&&$20)},{$2?(!$39&&$11):(!$26&&$25)},{$2?(!$40&&$11):(!$31&&$30)},{$2?(!$41&&$11):(!$36&&$35)}
else v_n={$2?(!$37&&$11):(!$16&&$15)},{$2?(!$38&&$11):(!$21&&$20)},{$2?(!$39&&$11):(!$26&&$25)},{$2?(!$41&&$11):(!$36&&$35)}
fi

use_negate=max($v_n)
v_n=[$v_n]

color_channels={$1==4?4:3}

convert_colors_fwd=${arg\ $1+1,,rgb2srgb,rgb2ryb,rgb2cmy,,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab8,rgb2lch8,rgb2yiq8,rgb2yuv8,rgb2ycbcr,rgb2ycbcrglic,rgb2xyz8,rgb2yes8,rgb2k18,rgb2ohta8}
convert_colors_bwd=${arg\ $1+1,,srgb2rgb,ryb2rgb,cmy2rgb,,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,ycbcr2rgb,ycbcrglic2rgb,xyz82rgb,yes82rgb,k182rgb,ohta82rgb}

if $1
 repeat $! l[$>]
  if $1!=4
   $convert_colors_fwd.
  else
   if s==3 rgb2cmyk
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
   u cmyk
  fi
 endl done
fi

if $color_channels==3
 modo_variables={$2?$8:$12},{($color_id)[0]},{$2?($37?-2:($10?-1:$9%)):($16?-2:($14?-1:$13%))},{$2?$8:$17},{($color_id)[1]},{$2?($38?-2:($10?-1:$9%)):($21?-2:($19?-1:$18%))},{$2?$8:$22},{($color_id)[2]},{$2?($39?-2:($10?-1:$9%)):($26?-2:($24?-1:$23%))},$32,255,{($2?$41:$36)?-2:($34?-1:$33%)}
else
 modo_variables={$2?$8:$12},{($color_id)[0]},{$2?($37?-2:($10?-1:$9%)):($16?-2:($14?-1:$13%))},{$2?$8:$17},{($color_id)[1]},{$2?($38?-2:($10?-1:$9%)):($21?-2:($19?-1:$18%))},{$2?$8:$22},{($color_id)[2]},{$2?($39?-2:($10?-1:$9%)):($26?-2:($24?-1:$23%))},{$2?$8:$27},{($color_id)[3]},{$2?($40?-2:($10?-1:$9%)):($31?-2:($29?-1:$28%))},$32,255,{($2?$41:$36)?-2:($34?-1:$33%)}
fi

rep_modo_mc $modo_variables

if $use_negate
 repeat $! l[$>]
  ss={s-1}
  repeat s
   if $>!=$ss if ($v_n)[$>] sh. $> f. ($color_id)[$>]-i rm. fi
   else if ($v_n)[$>] sh. $> f. 255-i rm. fi
   fi
  done
 endl done
fi

if $1
 repeat $! l[$>]
  if $1!=4
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 endl done
fi

if !$3 rv fi
if '$_host'=='paintdotnet' k[0] fi

fx_rep_modo_preview:
two_plus_layer={$!>1}
ms=${-max_s}
rv gui_split_preview "fx_rep_modo ${1-41}",${-3--1}
contain_alpha={$ms>3}
activate_individual_channels={!$2?2}
mode_0={$contain_alpha&&$2?2}
mode_1={!$contain_alpha&&!$2?2}
mode_2={$1!=4?(($contain_alpha&&!$2)?2):((!$contain_alpha&&!$2)?2)}
mode_3={!$2?(($1==4&&$contain_alpha)?2)}
use_channel_1_a={$5==0?2}
use_channel_1_b={$6==0?2}
use_channel_1_c={$7==0?2}
use_channel_2_a={$5==1?2}
use_channel_2_b={$6==1?2}
use_channel_2_c={$7==1?2}
use_channel_3_a={$5==2?2}
use_channel_3_b={$6==2?2}
use_channel_3_c={$7==2?2}
activate_a={!$2?(($mode_1?$use_channel_1_a:($mode_2?$use_channel_1_b:$use_channel_1_c))?2)}
activate_b={($mode_1?$use_channel_2_a:($mode_2?$use_channel_2_b:$use_channel_2_c))?2}
activate_c={($mode_1?$use_channel_3_a:($mode_2?$use_channel_3_b:$use_channel_3_c))?2}
activate_d={$1==4?($mode_2?($6==3?2):($mode_3?($7==3?2)))}
activate_e={$2?($mode_0?($4==1?2)):($contain_alpha?($1!=4?($mode_2?($6==3?2):($7==4?2)):($mode_3?$7==4?2)))}
activate_csm={$2&&!$4?2}
activate_bottom_sec={$2?2}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{$mode_0}\
"{$5}_"{$mode_1}\
"{$6}_"{$mode_2}\
"{$7}_"{$mode_3}\
"{$8}_"{$activate_csm}\
"{$9}_"{$activate_csm}\
"{$10}_"{$two_plus_layer?$activate_csm}\
"{$11}_"{$activate_csm}\
"{$12}_"{$activate_a}\
"{$13}_"{$activate_a}\
"{$14}_"{$two_plus_layer?$activate_a}\
"{$15}_"{$activate_a}\
"{$16}_"{$activate_a}\
"{$17}_"{$activate_b}\
"{$18}_"{$activate_b}\
"{$19}_"{$two_plus_layer?$activate_b}\
"{$20}_"{$activate_b}\
"{$21}_"{$activate_b}\
"{$22}_"{$activate_c}\
"{$23}_"{$activate_c}\
"{$24}_"{$two_plus_layer?$activate_c}\
"{$25}_"{$activate_c}\
"{$26}_"{$activate_c}\
"{$27}_"{$activate_d}\
"{$28}_"{$activate_d}\
"{$29}_"{$two_plus_layer?$activate_d}\
"{$30}_"{$activate_d}\
"{$31}_"{$activate_d}\
"{$32}_"{$activate_e}\
"{$33}_"{$activate_e}\
"{$34}_"{$two_plus_layer?$activate_e}\
"{$35}_"{$activate_e}\
"{$36}_"{!$2?$activate_e}\
"{$37}_"{$activate_bottom_sec}\
"{$38}_"{$activate_bottom_sec}\
"{$39}_"{$activate_bottom_sec}\
"{$40}_"{$2?($1==4?2)}\
"{$41}_"{($2&&$contain_alpha)?2}\
"{$42}"\
"{$43,$44}"
#@gui Channel Overblur-Overline-Blur-Sharpen:fx_OOBS,_fx_OOBS_preview(0)
#@gui :_=separator()
#@gui :Color Space=choice("RGB&#47;sRGB","HSV&#47;HSV8","HSL&#47;HSL8","HSI&#47;HSI8","LCH&#47;LCH8","Lab&#47;Lab8","YCbCr&#47;YCbCrGLIC","YIQ&#47;YIQ8","YUV&#47;YUV8","XYZ&#47;XYZ8")
#@gui :Alt Choice=bool(0)
#@gui :_=separator()
#@gui :_=note("Configuration for OOBS filter")
#@gui :Use Master Editor(Manipulate Multiple Channels at Once?)=bool(1)
#@gui :Edit Channel #1?=bool(1)
#@gui :Edit Channel #2?=bool(1)
#@gui :Edit Channel #3?=bool(1)
#@gui :Edit Alpha Channel?=bool(0)
#@gui :_=separator()
#@gui :_=note("<b>Master Editor</b>")
#@gui :Overblur/Overline/Sharpen/Blur=choice ("Overblur","Overline","Blur","Sharpen")
#@gui :Effect Factor=float (1,.1,100)
#@gui :Multiplication Factor=float (1,.1,10)
#@gui :Blend Operation=choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui :Blending Opacity=float (100,.01,100)
#@gui :_=separator(),_=note("<u>Individual Channels</u>"), _=separator()
#@gui :_=note("<b>Channel #1</b>")
#@gui :Overblur/Overline/Sharpen/Blur=choice ("Overblur","Overline","Blur","Sharpen")
#@gui :Effect Factor=float (1,.1,10)
#@gui :Multiplication Factor=float (1,.1,10)
#@gui :Blend Operation=choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui :Blending Opacity=float (100,.01,100)
#@gui :_=separator()
#@gui :_=note("<b>Channel #2</b>")
#@gui :Overblur/Overline/Sharpen/Blur=choice ("Overblur","Overline","Blur","Sharpen")
#@gui :Effect Factor=float (1,.1,10)
#@gui :Multiplication Factor=float (1,.1,10)
#@gui :Blend Operation=choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui :Blending Opacity=float (100,.01,100)
#@gui :_=separator()
#@gui :_=note("<b>Channel #3</b>")
#@gui :Overblur/Overline/Sharpen/Blur=choice ("Overblur","Overline","Blur","Sharpen")
#@gui :Effect Factor=float (1,.1,10)
#@gui :Multiplication Factor=float (1,.1,10)
#@gui :Blend Operation=choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui :Blending Opacity=float (100,.01,100)
#@gui :_=separator()
#@gui :_=note("<b>Alpha Channel</b>")
#@gui :Overblur/Overline/Sharpen/Blur=choice ("Overblur","Overline","Blur","Sharpen")
#@gui :Effect Factor=float (1,.1,10)
#@gui :Multiplication Factor=float (1,.1,10)
#@gui :Blend Operation=choice (21,"add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor")
#@gui :Blending Opacity=float (100,.01,100)
#@gui :_=separator(),Preview type=choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2019/01/7</i>.</small>")
fx_OOBS:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","lighten","linearburn","linearlight","multiply","normal","negation","or","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","vividlight","xor","edges","error"
split_opacity
local[0]
if $2==0
if $1==1 rgb2hsv
elif $1==2 rgb2hsl
elif $1==3 rgb2hsi
elif $1==4 rgb2lch
elif $1==5 rgb2lab
elif $1==6 rgb2ycbcr
elif $1==7 rgb2yiq
elif $1==8 rgb2yuv
elif $1==9 rgb2xyz
fi
elif $2==1
if $1==0 rgb2srgb
elif $1==1 rgb2hsv8
elif $1==2 rgb2hsl8
elif $1==3 rgb2hsi8
elif $1==4 rgb2lch8
elif $1==5 rgb2lab8
elif $1==6 rgb2ycbcrglic
elif $1==7 rgb2yiq8
elif $1==8 rgb2yuv8
elif $1==9 rgb2xyz8
fi fi
s c
if $3==1
if $4==1 local[0] +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 endl fi
if $5==1 local[1] +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 endl fi
if $6==1 local[2] +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 endl fi
elif $3==0
if $4==1 local[0] +oobs_edit[0] $13,$14,$15 -blend[0,1] ${_mode{$16+1}},$17/100 endl fi
if $5==1 local[1] +oobs_edit[0] $18,$19,$20 -blend[0,1] ${_mode{$21+1}},$22/100 endl fi
if $6==1 local[2] +oobs_edit[0] $23,$24,$25 -blend[0,1] ${_mode{$26+1}},$27/100 endl fi
fi
a c
if $2==0
if $1==1 hsv2rgb
elif $1==2 hsl2rgb
elif $1==3 hsi2rgb
elif $1==4 lch2rgb
elif $1==5 lab2rgb
elif $1==6 ycbcr2rgb
elif $1==7 yiq2rgb
elif $1==8 yuv2rgb
elif $1==9 xyz2rgb
fi
elif $2==1
if $1==0 srgb2rgb
elif $1==1 hsv82rgb
elif $1==2 hsl82rgb
elif $1==3 hsi82rgb
elif $1==4 lch82rgb
elif $1==5 lab82rgb
elif $1==6 ycbcrglic2rgb
elif $1==7 yiq82rgb
elif $1==8 yuv82rgb
elif $1==9 xyz82rgb
fi fi
endl
local[1]
if $3==1 if $7==1 +oobs_edit[0] $8,$9,$10 -blend[0,1] ${_mode{$11+1}},$12/100 fi
elif $3==0 if $7==1 +oobs_edit[0] $28,$29,$30 -blend[0,1] ${_mode{$31+1}},$32/100 fi
fi
endl
a c
oobs_edit :
if $1==0 -overblur_overline[0] 0,$2,$3 fi
if $1==1 -overblur_overline[0] 1,$2,$3 fi
if $1==2 -blur[0] {$2*$3} fi
if $1==3 -sharpen[0] {$2*$3} fi
overblur_overline :
if $1==0 +blur[0] $2
elif $1==1 +sharpen[0] $2
fi
+blend[0,1] difference
mul[2] $3
remove[1]
-blend[0,1] add
_fx_OOBS_preview :
gui_split_preview "fx_OOBS ${1--2}",$-1
#@gui Vibrato:fx_vibrato,_fx_vibrato_preview(0)
#@gui :_=note("This is the advanced version of the Vibrato filter. If you do want to manipulate multiple channels at once, use <u>Vibrato - Basic</u> filter. <i>Note: Disable channel mulplication for non-transparent images.</i> \n\n")
#@gui :_=note("This filter is the one of the G'MIC version of <b>MadJik's</b> <i>Paint.NET plugin</i>")
#@gui :_=separator()
#@gui :Colour Space=choice("RGB", "CMY", "HSI", "HSL", "HSV", "LAB", "LCH", "YCbCr", "YCbCr-Glic", "YUV", "YIQ", "XYZ", "Bayer")
#@gui :_=separator()
#@gui :Manipulate Multiple Channels at Once?=bool(1)
#@gui :Process Channel 1?=bool(1)
#@gui :Process Channel 2?=bool(1)
#@gui :Process Channel 3?=bool(1)
#@gui :Process Alpha Channel?=bool(1)
#@gui :Inherit Alpha?=bool(1)
#@gui :X-Orientation=bool(1)
#@gui :Y-Orientation=bool(1)
#@gui :U- Factor=float(.85,.1,15)
#@gui :V- Factor=float(.85,.1,15)
#@gui :X-Scale Factor=float(1,.1,15)
#@gui :Y-Scale Factor=float(1,.1,15)
#@gui :XY-Scale Factor=float(1,.1,3)
#@gui :Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui :Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui :Elevation=float(.7,-100,100)
#@gui :Multiply Blending=bool(0)
#@gui :Invert Vibrato=bool(0)
#@gui :Vibrato Blending Factor=float (100,0,100)
#@gui :Channel Influence Factor=float(1,-8,8)
#@gui :Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui :_=separator()
#@gui :_=note("- <b>Channel #1</b> - ")
#@gui :Process Channel?=bool(1)
#@gui :X-Orientation=bool(1)
#@gui :Y-Orientation=bool(1)
#@gui :U-Factor=float(.85,.1,15)
#@gui :V-Factor=float(.85,.1,15)
#@gui :X-Scale Factor=float(1,.1,15)
#@gui :Y-Scale Factor=float(1,.1,15)
#@gui :XY-Scale Factor=float(1,.1,3)
#@gui :Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui :Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui :Elevation=float(.7,-100,100)
#@gui :Multiply Blending=bool(0)
#@gui :Invert Vibrato=bool(0)
#@gui :Vibrato Blending Factor=float (100,0,100)
#@gui :Channel Influence Factor=float(1,-8,8)
#@gui :Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui :_=separator()
#@gui :_=note("- <b>Channel #2</b> - ")
#@gui :Process Channel?=bool(1)
#@gui :X-Orientation=bool(1)
#@gui :Y-Orientation=bool(1)
#@gui :U-Factor=float(.85,.1,15)
#@gui :V-Factor=float(.85,.1,15)
#@gui :X-Scale Factor=float(1,.1,15)
#@gui :Y-Scale Factor=float(1,.1,15)
#@gui :XY-Scale Factor=float(1,.1,3)
#@gui :Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui :Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui :Elevation=float(.7,-100,100)
#@gui :Multiply Blending=bool(0)
#@gui :Invert Vibrato=bool(0)
#@gui :Vibrato Blending Factor=float (100,0,100)
#@gui :Channel Influence Factor=float(1,-8,8)
#@gui :Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui :_=separator()
#@gui :_=note("- <b>Channel #3</b> - ")
#@gui :Process Channel?=bool(1)
#@gui :X-Orientation=bool(1)
#@gui :Y-Orientation=bool(1)
#@gui :U-Factor=float(.85,.1,15)
#@gui :V-Factor=float(.85,.1,15)
#@gui :X-Scale Factor=float(1,.1,15)
#@gui :Y-Scale Factor=float(1,.1,15)
#@gui :XY-Scale Factor=float(1,.1,3)
#@gui :Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui :Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui :Elevation=float(.7,-100,100)
#@gui :Multiply Blending=bool(0)
#@gui :Invert Vibrato=bool(0)
#@gui :Vibrato Blending Factor=float (100,0,100)
#@gui :Channel Influence Factor=float(1,-8,8)
#@gui :Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui :_=separator()
#@gui :_=note("- <b>Alpha Channel #1</b> - ")
#@gui :Process Channel?=bool(0)
#@gui :X-Orientation=bool(1)
#@gui :Y-Orientation=bool(1)
#@gui :U-Factor=float(.85,.1,15)
#@gui :V-Factor=float(.85,.1,15)
#@gui :X-Scale Factor=float(1,.1,15)
#@gui :Y-Scale Factor=float(1,.1,15)
#@gui :XY-Scale Factor=float(1,.1,3)
#@gui :Percentage-Based X Pixel Shift=float(0,-200,200)
#@gui :Percentage-Based Y Pixel Shift=float(0,-200,200)
#@gui :Elevation=float(.7,-100,100)
#@gui :Multiply Blending=bool(1)
#@gui :Invert Vibrato=bool(0)
#@gui :Vibrato Blending Factor=float (100,0,100)
#@gui :Channel Influence Factor=float(1,-8,8)
#@gui :Final Channel Modulos Multiplication Factor=float(1,1,32)
#@gui :_=separator(),Preview type=choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2018/12/19</i>.</small>")

fx_vibrato:
split_opacity
local[0]
if $1==1 rgb2cmy
elif $1==2 rgb2hsi8
elif $1==3 rgb2hsl8
elif $1==4 rgb2hsv8
elif $1==5 rgb2lab8
elif $1==6 rgb2lch8
elif $1==7 rgb2ycbcr
elif $1==8 rgb2ycbcrglic
elif $1==9 rgb2yuv8
elif $1==10 rgb2yiq8
elif $1==11 rgb2xyz8
elif $1==12 rgb2bayer 0
fi

s c

if $2==1
if $3==1 -vibrato[0] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
if $4==1 -vibrato[1] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
if $5==1 -vibrato[2] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22 fi
elif $2==0
if $23==1 -vibrato[0] $24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38 fi
if $39==1 -vibrato[1] $40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53,$54 fi
if $55==1 -vibrato[2] $56,$57,$58,$59,$60,$61,$62,$63,$64,$65,$66,$67,$68,$69,$70 fi
fi
a c

if $1==1 cmy2rgb
elif $1==2 hsi82rgb
elif $1==3 hsl82rgb
elif $1==4 hsv82rgb
elif $1==5 lab82rgb
elif $1==6 lch82rgb
elif $1==7 ycbcr2rgb
elif $1==8 ycbcrglic2rgb
elif $1==9 yuv82rgb
elif $1==10 yiq82rgb
elif $1==11 xyz82rgb
elif $1==12 bayer2rgb 0,0,0
fi
endl
if $2==1
if $6==1 -vibrato[1] $8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$7,$19,$20,$21,$22 fi
elif $2==0
if $71==1 -vibrato[1] $72,$73,$74,$75,$76,$77,$78,$79,$80,$81,$82,$83,$84,$85,$86 fi
fi
a c

vibrato:
repeat $! l[$>]
n 0,255
f "
q=($8/100)*w;
l=($9/100)*h;
X=(($1?w-x+q:x+q)/w-.5) * 2 * 1/$5 * 1/$7;
Y=(($2?h-y+l:y+l)/h-.5) * 2 * 1/$6 * 1/$7;
U=sqrt($3);
V=sqrt($4);
Z=((X-Y) * (X-U) * (X+U) * (Y-V) * (Y+V))+ $10;
C=(Z+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$14)*(Z+((1-i/255)/(($3>1?$3:1/$3)*($4>1?$4:1/$4)))*$14);
F=abs(C)>1?C-int(C):C;
A=$12?F:1-F;
B=$11?(i*A):A*200;
E=$13/100*B+(1-$13/100)*i;
" n 0,255 mul $15 mod 256
endl done
_fx_vibrato_preview :
gui_split_preview "fx_vibrato ${1--2}",$-1
#@gui Construction Material Texture:_cons_turb,_cons_turb_preview(0)
#@gui :_=note("Construction Material Texture filter is based off the following tutorial by <b>theonlychad</b> for Paint.NET software: <a href="https://forums.getpaint.net/topic/16075-concrete-texture-tutorial/">Concrete Texture Tutorial</a>.\n")
#@gui :_=separator(),_=note("<b>Turbulance Texture</b>")
#@gui :1. Radius=float(88,1,1024)
#@gui :2. Octaves=int(8,1,12)
#@gui :3. Damping per Octave=float(2.5,1,10)
#@gui :4. Mode=choice(2,"Turbulence","Turbulence 2","Fractal Noise","Fractured Clouds","Stardust","Pea Soup")
#@gui :5-7. Color Balance = color(128,128,128)
#@gui :_=separator(),_=note("<b>Noise Processing</b>")
#@gui :8. Amplitude=float(20,0,200)
#@gui :9. Noise Type=choice(3,"Gaussian","Uniform","Salt and Pepper","Poisson")
#@gui :_=separator()
#@gui :10. Channel(s)=choice(0,"RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui :11. Value Action=choice(1,"None","Cut","Normalize")
#@gui :_=separator(),_=note("<b>Grayscale Processing</b>")
#@gui :12. Colour Space=choice("RGB","sRGB")
#@gui :13. Channel 1=float(1,0,3)
#@gui :14. Channel 2=float(1,0,3)
#@gui :15. Channel 3=float(1,0,3)
#@gui :16. Normalise=bool(1)
#@gui :17. Desaturation (%)=float(100,0,100)
#@gui :_=separator(),_=note("<b>Self-Image Processing</b>")
#@gui :18. Self-Blending=choice(20,"add","burn","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","linearburn","linearlight","luminance","multiply","negation","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","vividlight")
#@gui :19. Self-Blending Opacity (%)=float (100,0,100)
#@gui :20. Self-Blending V. Original Blending=choice(15,"add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor")
#@gui :21. Self-Blend V. Original Opacity (%)=float (100,0,100)
#@gui :_=separator(),_=note("<b>Value Processing</b>")
#@gui :22. Value Action=choice(2,"None","Cut","Normalize")
#@gui :23. Number #1=float(0,0,255)
#@gui :24. Number #2=float(188,0,255)
#@gui :25. Equalize?=bool(0)
#@gui :26. Negate?=bool(0)
#@gui :_=separator(),_=note("<b>Warp by Intensity</b>")
#@gui :27. X-Factor=float(0.19,-6,6)
#@gui :28. Y-Factor=float(0.52,-6,6)
#@gui :_=separator()
#@gui :29. X-Offset=float(128,0,255)
#@gui :30. Y-Offset=float(128,0,255)
#@gui :_=separator()
#@gui :31. Correlated Channels=bool(0)
#@gui :32. Interpolation=choice(1,"Nearest Neighbor","Linear")
#@gui :33. Boundary=choice(2,"Transparent","Nearest","Periodic","Mirror")
#@gui :_=separator()
#@gui :34. Channel(s)=choice("All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]","Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]","YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]","YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]","Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]","HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]","CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]")
#@gui :_=separator(),_=note("<b>Style Processing</b>")
#@gui :35. Blur Original=float(0,0,16)
#@gui :_=separator(),_=note("<b>Butterworth Bandpass Processing</b>")
#@gui :36. Activate Butterworth Bandpass Processing=bool(0)
#@gui :37. Create Copy?=bool(0)
#@gui :38. LP Frequency Power=float(3,0,16)
#@gui :39. LP Order Cube Root=float(2,0,4)
#@gui :40. LP Resonance=float(0,0,5)
#@gui :41. HP Frequency Power=float(4,0,16)
#@gui :42. HP Order Cube Root=float(2,0,4)
#@gui :43. HP Resonance=float(2,0,4)
#@gui :44. Colour Space=choice("RGB","sRGB","HSV8","HSV","HSL8","HSL","HSI8","HSI","LCH8","LCH","Lab8","Lab","YCbCr","YCbCrGLIC","YCbCrJPEG","YIQ8","YIQ","YUV8","YUV","HCY","XYZ8","XYZ","CMY","CMYK","Bayer")
#@gui :45. Absolute=bool(1)
#@gui :46. Makeup Gain=bool(1)
#@gui :_=separator(),_=note("<b>Relief Processing</b>")
#@gui :47. Activate Relief Processing=bool(1)
#@gui :48. Radius=int(5,5,100)
#@gui :49. Angle=float(0,-180,180)
#@gui :50. Sigma=float(.5,.05,4)
#@gui :51. Value Scale=float(2,.5,10)
#@gui :52. Output Color=bool(1)
#@gui :53. Blending Mode=choice(0,"Grain Extract","Grain Merge")
#@gui :54. Blending Opacity (%)=float(100,0,100)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/12/07</i>.</small>")
_cons_turb :
repeat $! l[$>] cons_turb $* endl done
cons_turb :
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"

fill_color 0,0,0
turbulence ${1-3},0,$4
balance_gamma ${5-7}

remove_opacity

if $10<=4 ac "_fx_noise $8,$9",{$10+2},$11
else ac "_fx_noise $8,$9",{$10+3},$11
fi

remove_opacity

+jr_desaturate ${12-16}

blend normal,$17/100

+cons_self_blend $18,$19

blend ${_mode{$20+1}},$21/100

if $22==1 cut $23,$24
elif $22==2 n $23,$24
fi

if $25 ac "equalize",rgb fi
if $26 negate fi

fx_make_seamless 256

fx_warp_by_intensity ${27-34}

if $36
 if !$37
  blur $35
  fx_butterworth_bp ${38-44},0,${45-46}
  if $45==1
   +rep_emboss_relief ${48-51},0,$52
  fi
 else
  +fx_butterworth_bp ${38-44},0,${45-46}
  blur[0] $35
  if $47==1
   rep_emboss_relief[1] ${48-51},0,$52
  fi
 fi
else
 blur $35
 if $47
  +rep_emboss_relief ${48-51},0,$52
 fi
fi
if $47 if $53 blend grainmerge,{$54/100} else blend grainextract,{$54/100} fi fi
cons_self_blend :
-m "MergeChoice : $""=_mode" -MergeChoice "add","burn","dodge","exclusion","freeze","grainextract","grainmerge","hardlight","hardmix","interpolation","linearburn","linearlight","luminance","multiply","negation","overlay","pinlight","reflect","screen","shapeaverage","softburn","softdodge","softlight","stamp","vividlight","edges","error"
[0]
blend ${_mode{$1+1}},$2/100
_cons_turb_preview :
gui_split_preview "_cons_turb $*",${-3--1}
#@gui Emboss-Relief:fx_emboss_relief,fx_emboss_relief_preview(0)
#@gui :Radius=int(5,5,100)
#@gui :Angle=float(0,-180,180)
#@gui :Sigma=float(.5,.05,4)
#@gui :Value Scale=float(2,.5,10)
#@gui :Output=choice(0,"Emboss","Relief")
#@gui :Output Color=bool(1)
#@gui :Preserve Alpha?=bool(1)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/12/07</i>.</small>")
fx_emboss_relief: 
if !$7 remove_opacity fi
rep_emboss_relief ${1-6}
fx_emboss_relief_preview: gui_split_preview "fx_emboss_relief ${1-7}",${-3--1}
#@gui Premade Palette:palgen,palgen
#@gui :_=note("This filter creates palettes. Credits are given below. "), _=separator()
#@gui :Palette=choice(10,"BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :X-Position=choice(1,"Left","Middle","Right")
#@gui :Y-Position=choice(1,"Top","Middle","Bottom")
#@gui :Palette Width=int(1,1,32)
#@gui :Palette Scaling=int(1,1,25)
#@gui :Flip Palette Rows=bool(0)
#@gui :Palette Rotation=choice(0,"0","90","270,"360")
#@gui :Mirror X-Axis Palette=bool(0)
#@gui :Mirror Y-Axis Palette=bool(0)
#@gui :Blend Palette to Image(s)?=bool(1)
#@gui :_=separator(),Preview type=choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<b>Palette CLI Information</b>\n\n <i>Main Source of Palettes - </i><a href=\"https://lospec.com/palette-list\"> LoSpec Palette List</a>\n\nPalette Number -- pal number_id = pal name_id -- Full Palette Name by Author[if mentioned]\n\n1 -- pal 0 = pal bw -- Black & White\n2 -- pal 1 = pal rgb -- Red-Green-Blue\n3 -- pal 2 = pal b_rgb -- Black w/ Red-Green-Blue\n4 -- pal 3 = pal bw_rgb -- Black & White w/ Red-Green-Blue\n5 -- pal 4 = pal cmy -- Cyan-Magenta-Yellow\n6 -- pal 5 = pal cmyk -- Cyan-Magenta-Yellow-Black\n7 -- pal 6 = pal wcmyk -- White-Cyan-Magenta-Yellow-Black\n8 -- pal 7 = pal rgbcmy -- Red-Green-Blue w/ Cyan-Magenta-Yellow\n9 -- pal 8 = pal 1bitrgb -- 1 BPC RGB\n10 -- pal 9 = pal aurora -- Aurora by GrafxKid\n11 -- pal 10 = pal playpal -- PLAYPAL by id Tech 1/DOOM Engine\n12 -- pal 11 = pal srb2 -- Sonic Robo Blast 2\n13 -- pal 12 = pal famicube -- Famicube by Arne\n14 -- pal 13 = pal kens16 -- Andrew Kensler - 16 by Andrew Kensler\n15 -- pal 14 = pal kens32 -- Andrew Kensler - 32 by Andrew Kensler\n16 -- pal 15 = pal kens54 -- Andrew Kensler - 54 by Andrew Kensler\n17 -- pal 16 = pal aap12 -- AAP-Micro 12 by Adigun A. Polack\n18 -- pal 17 = pal aap16 -- AAP-16 by Adigun A. Polack\n19 -- pal 18 = pal aap64 -- AAP-64 by Adigun A. Polack\n20 -- pal 19 = pal aap128 -- AAP-SPLENDOR128 by Adigun A. Polack\n21 -- pal 20 = pal db8 -- DB8 by DawnBringer\n22 -- pal 21 = pal db16 -- DB16 by DawnBringer\n23 -- pal 22 = pal db32 -- DB32 by DawnBringer\n24 -- pal 23 = pal db_iso22 -- DB-ISO22 by DawnBringer\n25 -- pal 24 = pal dimwid17 -- DimWiddy 17 by DimWiddy\n26 -- pal 25 = pal dimwid23 -- DimWiddy 23 by DimWiddy\n27 -- pal 26 = pal edg4 -- Endesga-4 by Endesga\n28 -- pal 27 = pal edg8 -- Endesga-8 by Endesga\n29 -- pal 28 = pal edg16 -- Endesga-16 by Endesga\n30 -- pal 29 = pal edg32 -- Endesga-32 by Endesga\n31 -- pal 30 = pal edg36 -- Endesga-36 by Endesga\n32 -- pal 31 = pal edg64 -- Endesga-64 by Endesga\n33 -- pal 32 = pal juicy32 -- Juicy-32 by Real Juice\n34 -- pal 33 = pal juicy56 -- Juicy-56 by Real Juice\n35 -- pal 34 = pal xaiue -- XAIUE-22 by xaiue\n36 -- pal 35 = pal 15pdx -- 15P-DX by GrafxKid\n37 -- pal 36 = pal 20pdx -- 20P-DX by GrafxKid\n38 -- pal 37 = pal 24pdx -- 24P-DX by GrafxKid\n39 -- pal 38 = pal cabana64 -- Cabana-64 by Crabby\n40 -- pal 39 = pal fant16 -- Fantasy 16 by Brettybooop\n41 -- pal 40 = pal fant24 -- Fantasy 24 by Gabriel C.\n42 -- pal 41 = pal tf23 -- Tranquil Fantasy 23 by windfall.apples\n43 -- pal 42 = pal tfp39 -- Tranquility Plus 39 by windfall.apples\n44 -- pal 43 = pal faraway48 -- Faraway 48 by Igor Ferreira.\n45 -- pal 44 = pal fleja_m -- Fleja Master Palette by Fleja\n46 -- pal 45 = pal koni 32 -- Koni32 by Konic\n47 -- pal 46 = pal linearbasic -- Linear Color Palette Basic by GrafxKid\n48 -- pal 47 = pal vinelinear -- Vines Flexible Linear Ramps by Vine 2D\n49 -- pal 48 = pal arcade29 -- Arcade Standard 29 by GrafxKid\n50 -- pal 49 = pal arq16 -- ARQ16 by Endesga\n51 -- pal 50 = pal blk36 -- BLK 36 by BlackedIRL.\n52 -- pal 51 = pal blkneo -- BLK-NEO by BlackedIRL.\n53 -- pal 52 = pal brokefac -- Broken Facility by u/telepathic-melon\n54 -- pal 53 = pal bubblegum -- Bubblegum-16 by PineTreePizza\n55 -- pal 54 = pal cade15 -- Cade 15 by MonstersGoBoom\n56 -- pal 55 = pal calder8 -- Calder 8 by Philip Dodderige\n57 -- pal 56 = pal chrom16 -- Chromatic16 by DragonDePlatino\n58 -- pal 57 = pal cdbac -- CD-BAC by DimWiddy\n59 -- pal 58 = pal cgarne -- CG Arne by Arne Niklas Jansson\n60 -- pal 59 = pal cpcboy -- CPC BOY by Arne Niklas Jansson\n61 -- pal 60 = pal dino -- Dinoknight 16 by Retrospec\n62 -- pal 61 = pal 4l -- ||||-22 by ||||\n63 -- pal 62 = pal ftzeth16 -- FZT Ethereal 16 by Fusionnist\n64 -- pal 63 = pal gzxp -- GZXP by GrafxKid\n65 -- pal 64 = pal indc -- Indecision by Nelson SMG\n66 -- pal 65 = pal island16 -- Island Joy 16 by Kerrie Lake\n67 -- pal 66 = pal journey -- Journey by PineTreePizza\n68 -- pal 67 = pal juicy -- Juicy 17 by JerryPie\n69 -- pal 68 = pal oak -- Oak21 by Dan Oak\n70 -- pal 69 = pal nature55 -- Nature's Embrace 55 by GrafxKid\n71 -- pal 70 = pal nauris16 -- Nauris-16 by Nauris\n72 -- pal 71 = pal pear36 -- Pear 36 by PineTreePizza\n73 -- pal 72 = pal peach -- Peachy Pop 16 by Kerrie Lake\n74 -- pal 73 = pal pineapple32 -- Pineapple 32 by PineTreePizza\n75 -- pal 74 = pal resurrect -- Resurrect 32 by Kerrie Lake\n76 -- pal 75 = pal rosy42 -- Rosy 42 by PineTreePizza\n77 -- pal 76 = pal slso -- SLSO-CLR17 by Luis Miguel Maldonado\n78 -- pal 77 = pal softy15 -- Softy 15 by Eggy\n79 -- pal 78 = pal spec12 -- SPEC12 by Smalls\n80 -- pal 79 = pal starmancer -- Starmancer by Ominux Games\n81 -- pal 80 = pal sup8 -- Superb 8 by BigPotato\n82 -- pal 81 = pal superfuture -- SuperFuture25 by Endesga\n83 -- pal 82 = pal sweetie16 -- Sweetie 16 by GrafxKid\n84 -- pal 83 = pal taffy16 -- Taffy 16 by PineTreePizza\n85 -- pal 84 = pal todayland -- Todayland Palette V2 by GrafxKid\n86 -- pal 85 = pal vivid17 -- Vivid-17 by Irenaart\n87 -- pal 86 = pal voodo -- Voodo34 by Shamaboy\n88 -- pal 87 = pal zu32 -- Zughy 32 by Zughy\n89 -- pal 88 = pal enos16 -- ENOS16 by Endesga\n90 -- pal 89 = pal undertones -- Undertones-17 by Irenaart\n91 -- pal 90 = pal equpix15 -- Equpix 15 by Night\n92 -- pal 91 = pal night16 -- Night 16 by Night\n93 -- pal 92 = pal star29 -- Star 29 by Starlane\n94 -- pal 93 = pal star34 -- Star 34 by Starlane\n95 -- pal 94 = pal stilllife -- Still-Life by cure\n96 -- pal 95 = pal simjpc16 -- SimpleJPC-16 by Adigun A. Polack\n97 -- pal 96 = pal acid15 -- Acid 15 by pyrometal\n98 -- pal 97 = pal battery24 -- Battery 24 by Battery Jellyfish\n99 -- pal 98 = pal clump18 -- Clumpy 18 by windfall.apples\n100 -- pal 99 = pal cthul -- Cthulhu by Starlane\n101 -- pal 100 = pal crimso11 -- Crimso 11 by Crimso\n102 -- pal 101 = pal coptec -- Copper-Tech by Arne Niklas Jansson\n103 -- pal 102 = pal drz15 -- DRZ15A by Drazille\n104 -- pal 103 = pal eggy15 -- Eggy 15 by Eggy\n105 -- pal 104 = pal eroge -- Eroge-Copper by Arne Niklas Jansson\n106 -- pal 105 = pal europa -- Europa 16 by Starlane\n107 -- pal 106 = pal greyt -- GreyT-bit by Sam Keddy\n108 -- pal 107 = pal jewel -- Jewel by AprilSundae\n109 -- pal 108 = pal polar11 -- Polar 11 by Smalls\n110 -- pal 109 = pal sheltzy -- Sheltzy 32 by Please Check - NatTorpedia\n111 -- pal 110 = pal rube-goldberg -- Rube-Goldberg\n112 -- pal 111 = pal boomboom -- BoomBoom by Salman_Shh\n113 -- pal 112 = pal g8 -- Generic-8 by GrafxKid\n114 -- pal 113 = pal matriax8c -- Matriax8c by Davit Masia\n115 -- pal 114 = pal nt1h -- NT1H by NatTorpedia\n116 -- pal 115 = pal au15 -- Autum 15 by jok\n117 -- pal 116 = pal au15y -- Autum 15 [Yellow] by jok\n118 -- pal 117 = pal jerrypie22 -- JerryPie 22 by JerryPie\n119 -- pal 118 = pal naji16 -- Naji 16 by Naji\n120 -- pal 119 = pal blessing -- Blessing by Maruki\n121 -- pal 120 = pal crayola -- Crayola Blind\n122 -- pal 121 = pal easter -- Easter Island by skamocore\n123 -- pal 122 = pal fairy -- Fairy Tales by lollige\n124 -- pal 123 = pal fuzz4 -- Fuzzy Four by P-Tux7\n125 -- pal 124 = pal xdb_01 -- 0xdb-01 by 0xDB\n126 -- pal 125 = pal ocaso -- Ocaso by Minord\n127 -- pal 126 = pal pastel -- Oh Hell, Pastel by StarlitSunset\n128 -- pal 127 = pal pastel17 -- 17 Pastels by Irenaart\n129 -- pal 128 = pal pollen8 -- Pollen-8 by Conker\n130 -- pal 129 = pal nopal -- Nopal-12 by BlackedIRL.\n131 -- pal 130 = pal sy17 -- Sy17 by xaiue\n132 -- pal 131 = pal syz15 -- Syz15 by Fusionnist\n133 -- pal 132 = pal tui15 -- TUI-15 by Jeremy\n134 -- pal 133 = pal cave -- Cave by PineTreePizza\n135 -- pal 134 = pal psygnosia -- Psygnosia by Arne Niklas Jansson\n136 -- pal 135 = pal marshmellow32 -- MarshMellow32 by FormalPrejudice\n137 -- pal 136 = pal rabbit7 -- Rabbit 7 by GrafxKid\n138 -- pal 137 = pal finlal11 -- Finlal 11 by Finlal\n139 -- pal 138 = pal vinik24 -- Vinik 24 by Vinik\n140 -- pal 139 = pal ykb22 -- YKB-22 by yahkehbu\n141 -- pal 140 = pal graveyard -- Graveyard-21 by AprilSundae\n142 -- pal 141 = pal steamlords -- Steam Lords by Slynyrd\n143 -- pal 142 = pal aaprad -- AAP-RadiantXV by Adigun A. Polack\n144 -- pal 143 = pal aapmaj -- AAP-Majesty XVII by Adigun A. Polack\n145 -- pal 144 = pal daruda -- Daruda 22 by daruda\n146 -- pal 145 = pal rust6 -- Rust-6 by Blue Phoenix\n147 -- pal 146 = pal xaiue_rad -- XAIUE-Radiant by xaiue\n148 -- pal 147 = pal firestorm -- Firestorm by theartistjulian\n149 -- pal 148 = pal supernova7 -- SuperNova 7 by Blue Phoenix\n150 -- pal 149 = pal nyx8 -- NYX8 by Javier Guerrero\n151 -- pal 150 = pal oil6 -- OIL6 by GrafxKid\n152 -- pal 151 = pal sgm -- SGM-Palette 2 by s.g.m\n153 -- pal 152 = pal fornaxvoid1 -- Fornax Void I by Fornax Void\n154 -- pal 153 = pal fornaxvoid2 -- Fornax Void II by Fornax Void\n155 -- pal 154 = pal pixelwave -- Pixelwave by Reptorian\n156 -- pal 155 = pal spaceyeaster -- Spacey Easter by Spark Norris\n157 -- pal 156 = pal moon39 -- Moonlit-39 by theartistjulian\n158 -- pal 157 = pal pet8 -- Petite-8 by Adigun A. Polack\n159 -- pal 158 = pal pet8d -- Petite-8 Afterdark by Adigun A. Polack\n160 -- pal 159 = pal autochrome -- Autochrome 3 by Reptorian\n161 -- pal 160 = pal autochrome5 -- Autochrome 5 by Reptorian\n162 -- pal 161 = pal gb_d_1 -- GB Default #1\n163 -- pal 162 = pal gb_d_2 -- GB Default #2\n164 -- pal 163 = pal gb_andrade -- GB Andrade by Andrade\n165 -- pal 164 = pal gb_blue -- GB Blue Seni by WildLeoKnight\n166 -- pal 165 = pal gb_bz -- GB Blackzone\n167 -- pal 166 = pal gb_crimson -- GB Crimson by WildLeoKnight\n168 -- pal 167 = pal gb_didi -- GB Didi by DidiGameboy\n169 -- pal 168 = pal gb_dirty -- GB Dirty by WildLeoKnight\n170 -- pal 169 = pal gb_arne -- GB Arne by Arne\n171 -- pal 170 = pal gb_easy -- GB Easy by GrafxKid\n172 -- pal 171 = pal gb_forest -- GB Forest\n173 -- pal 172 = pal gb_hg -- GB Harsh Green by WildLeoKnight\n174 -- pal 173 = pal gb_lg -- GB Light Green by WildLeoKnight\n175 -- pal 174 = pal gb_nostalgia -- GB Nostalgia by WildLeoKnight\n176 -- pal 175 = pal gb_platinum -- GB Platinum by WildLeoKnight\n177 -- pal 176 = pal gb_kirokaze -- GB Kirokaze by Kirokaze\n178 -- pal 177 = pal gb_pj -- GB PJ\n179 -- pal 178 = pal gb_cyber -- GB Cyber\n180 -- pal 179 = pal gb_wish -- GB Wish by Kerrie Lake\n181 -- pal 180 = pal gb_grapefruit -- GB Grapefruit by GrafxKid\n182 -- pal 181 = pal gb_ice_cream -- GB Ice Cream by Kerrie Lake\n183 -- pal 182 = pal gb_rb -- GB Red_Blue\n184 -- pal 183 = pal gb_space -- GB Spacehaze by WildLeoKnight\n185 -- pal 184 = pal gb_choco -- GB Chocolate by GrafxKid\n186 -- pal 185 = pal gb_purpdawn -- GB Purple Dawn by WildLeoKnight\n187 -- pal 186 = pal gb_gray -- GB Gray by GrafxKid\n188 -- pal 187 = pal arne4 -- ARNE4 by Arne\n189 -- pal 188 = pal hal4 -- HallowPumpkin by WildLeoKnight\n190 -- pal 189 = pal amiga2600ntsc -- Amiga 2600 NTSC\n191 -- pal 190 = pal amiga2600pal -- Amiga 2600 PAL\n192 -- pal 191 = pal amiga2600secam -- Amiga 2600 SECAM\n193 -- pal 192 = pal amiga7800mess -- Amiga 7800 M.E.S.S by Nabuko78\n194 -- pal 193 = pal amiga7800 -- Amiga 7800\n195 -- pal 194 = pal amstrad_cpc -- Amstrad CPC\n196 -- pal 195 = pal apple2 -- Apple II\n197 -- pal 196 = pal cga -- CGA\n198 -- pal 197 = pal cga00 -- CGA Mode 0 [Low]\n199 -- pal 198 = pal cga01 -- CGA Mode 0 [High]\n200 -- pal 199 = pal cga10 -- CGA Mode 1 [Low]\n201 -- pal 200 = pal cga11 -- CGA Mode 1 [High]\n202 -- pal 201 = pal cga20 -- CGA Mode 2 [Low]\n203 -- pal 202 = pal cga21 -- CGA Mode 2 [High]\n204 -- pal 203 = pal c64_pepto -- Commodore 64 - <a href="https://www.pepto.de/projects/colorvic/2001/">[Pepto Interpretation]</a>\n205 -- pal 204 = pal c64_colodore -- Commodore 64 - <a href="https://www.pepto.de/projects/colorvic/">[Colodore Interpretation]</a>\n206 -- pal 205 = pal com_vic_20 -- Commodore VIC-20\n207 -- pal 206 = pal colecovision -- Colecovision\n208 -- pal 207 = pal jmp -- Japanese Machine Palette by Arne Niklas Jansson\n209 -- pal 208 = pal mac2 -- Macintosh II\n210 -- pal 209 = pal nes -- NES\n211 -- pal 210 = pal pico_8 -- PICO-8 by Lexaloffle Games\n212 -- pal 211 = pal risc -- RISC OS\n213 -- pal 212 = pal samcoupe -- SAM Coupe\n214 -- pal 213 = pal mo5 -- Thomson MO5\n215 -- pal 214 = pal vga -- VGA\n216 -- pal 215 = pal zx -- ZX Spectrum\n217 -- pal 216 = pal gnome32 -- GNOME 32\n218 -- pal 217 = pal elc22 -- Electronic Crayon 22\n219 -- pal 218 = pal chip16 -- Chip16\n220 -- pal 219 = pal msx -- MSX\n221 -- pal 220 = pal deluxepaint -- Deluxe Paint\n222 -- pal 221 = pal lms -- Legacy Paint\n223 -- pal 222 = pal msxp -- XP Paint\n224 -- pal 223 = pal vis -- Vista Paint")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2019/5/18</i>.</small>")
palgen:
repeat $! l[$>]
 +pal $1
 to_rgba

 l.
  s x,{-$4}
  if $6
   repeat $! l[$>]
   if $>%2 mirror x fi
   endl done
  fi
  a y
 endl

 if $7%2
  if $9 mirror. x fi
  if $8 mirror. y fi
 else
  if $8 mirror. x fi
  if $9 mirror. y fi
 fi

 rotate. {$7*90}
 r2dx. {$5*100}%,1

 if $2==2 xx="1~"
 elif $2==1 xx=".5~"
 else xx="0~"
 fi

 if $3==2 yy="1~"
 elif $3==1 yy=".5~"
 else yy="0~"
 fi

 if !$10 f.. 0 fi

 sh. {s-1}

 j... ..,$xx,$yy,0,0,1,[-1],255

 rm[-2,-1]

endl done
#@gui Transfer Colors [Reduced Colors]:tcrc,tcrc_preview(0)
#@gui :_=note("<b>- Notes -</b> \n\nThis filter is used to stimulate pixel art or can be used for testing palettes. If you picked Auto for method of color transfer, that means palettes are automatically generated from images, and depending on your input layer choices, the top could be the reference image or the target image.\n\nWhen using pre-made palettes, the order of layers don't really matter unless you picked image as a reference for palette.In the case that you picked a image as a reference, you must make sure that the image in question is only 1px vertically, and the width is no more than 256 colors."), _=separator()
#@gui :_=note("<b>Color-mapping Preliminary Setup</b>")
#@gui :Method of Color Transfer=choice(0,"Auto","Palette")
#@gui :Palette to Use=choice(10,"By Layer","BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Layer to Use=choice(0,"Top Layer","Bottom Layer")
#@gui :Indexing Style=choice(0,"Regular [No Special Effect]","Noise","Luminance-Indexing","Vertical","Horizontal")
#@gui :Color Count=int(16,2,256)
#@gui :Color Dithering (%)=float(50,0,100)
#@gui :Transfer Color to Target Image?=bool(0)
#@gui :Alpha Count=int(2,1,256)
#@gui :Alpha Dithering (%)=float(50,0,100)
#@gui :Special Effect (%)=float(50,0,100)
#@gui :_=separator(),_=note("<b>Pixel Ratio and Interpolation</b")
#@gui :Initial Rescale Method=choice(0,"Disabled","Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui :Upscale?=bool(0)
#@gui :Pixel Width=int(2,1,16)
#@gui :Pixel Height=int(2,1,16)
#@gui :_=separator(),_=note("<b>Hardware Restriction Stimulation</b>\nWarning: This is computationally intensive!")
#@gui :Hardware Stimulation?=bool(0)
#@gui :Hardware Stimulation Precision Factor=int(2,2,32)
#@gui :_=separator(),_=note("<i>Preliminary Processing Area for Hardware Stimulation</i>")
#@gui :Hardware Restriction Data Size=choice(2,"By Width","By Height","Specified Width and Height")
#@gui :Row/Column Thickness=int(1,1,40)
#@gui :Tile Width=int(16,2,40)
#@gui :Tile Height=int(16,2,40)
#@gui :_=separator()_=note("<i>Color Restrictions Information</i>")
#@gui :Hardware Color Restriction=int(2,2,16)
#@gui :Hardware Color Mapping=choice(1,"Median Cut","Median Cut and K-Means")
#@gui :Alpha Precision=int(2,2,32)
#@gui :Alpha Mapping=choice(1,"Median Cut","Median Cut and K-Means")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/5/18</i>.</small>")
tcrc: if $1==0 if $3==1 rv fi repeat $!-1 l[0,{$>+1}] +colormap.. $5,1,1 to_rgb. pal_t[^0] -1,$4,{$6/100},0,$8,{$9/100},{$10/100},$11,$12,$13,$14,$15,$16,{$17==2?$19:($17==0?$18:{w})},{$17==2?$20:($17==0?{h}:$18)},$21,$22,$23,$24 rv endl done if $!>2 rv[{$!-1},1] fi if $3==1 rv fi else if $2!=0 repeat $! l[$>]  pal_t {$2-1},$4,{$6/100},$7,$8,{$9/100},{$10/100},$11,$12,$13,$14,$15,$16,{$17==2?$19:($17==0?$18:{w})},{$17==2?$20:($17==0?{h}:$18)},$21,$22,$23,$24 endl done else if $3==1 rv fi repeat $!-1 l[0,{$>+1}] [0] pal_t[^0] -1,$4,{$6/100},$7,$8,{$9/100},{$10/100},$11,$12,$13,$14,$15,$16,{$17==2?$19:($17==0?$18:{w})},{$17==2?$20:($17==0?{h}:$18)},$21,$22,$23,$24 endl done if $3!=1 rv fi fi fi
tcrc_preview:
tcrc $*
gui_split_preview "tcrc $*",${-3--1}

set_a={$1==1?2:0}
set_b={$11==0?0:2}
set_c={$15==0?0:2}
set_d={$15==0?0:($17==2?2:0)}

u "{$1}"\
"{$2}_"$set_a\
"{$3}_"{$1==0||($1==1&&$2==0)?2:1}\
"{$4}"\
"{$5}_"{$1==1?0:2}\
"{$6}"\
"{$7}_"$set_a\
"{$8}{$9}"\
"{$10}_"{$4==0?1:2}\
"{$11}"\
"{$12}_"$set_b\
"{$13}_"$set_b\
"{$14}_"$set_b\
"{$15}"\
"{$16}_"$set_c\
"{$17}_"$set_c\
"{$18}_"{$15==0?0:($17==2?0:2)}\
"{$19}_"$set_d\
"{$20}_"$set_d\
"{$21}_"$set_c\
"{$22}_"$set_c\
"{$23}_"$set_c\
"{$24}_"$set_c\
"{$25}{$26,$27}"
#@gui Goofy Resampling:goof_res,goof_res_preview(0)
#@gui :_=note("This filter is inspired by a method to divide images with a pasta maker, and alternate the strips of a picture which was cut using a pasta maker."),_=separator()
#@gui :Amount of Cut-Out=int(8,4,64)
#@gui :Line Cutout Direction=choice(0,"Horizontal","Vertical")
#@gui :End Connectin Direction=choice(0,"Horizontal","Vertical")
#@gui :Reverse Ordering?=bool(0)
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2019/2/22</i>.</small>")
goof_res: repeat $! l[$>] if $2 s x,$1 repeat $1/2-1 a[0,{$>+2}] x done a[^0] x if $4 rv fi if $3 a y else a x fi else  $2 s y,$1 repeat $1/2-1 a[0,{$>+2}] y done a[^0] y if $4 rv fi if $3 a y else a x fi fi endl done
goof_res_preview: goof_res $*
#@gui Color Modulo Texture:gui_rep_colmt,gui_rep_colmt_preview
#@gui :_=note("This filter is inspired by <a href="https://forums.getpaint.net/topic/111782-color-modulo-texture-tool-ymd20170922/">Color Modulo</a> plugin made by <b>MadJik</b> for <a href="https://www.getpaint.net/">Paint.NET</a> software.\n\nPreview is inaccurate! Use 100% Zoom Preview for most accuracy!"), _=separator()
#@gui :_=note("<b>Colour and Channel Setting</b>"), _=separator()
#@gui :_=note("- Colour Space and Alpha Setting -")
#@gui :Colour Space=choice(0,"RGB-8","RYB-8","CMY-8","CMYK-8","HSI-8","HSL-8","HSV-8","LAB-8","LCH-8","YIQ-8","YUV-8","YCbCr-8","YCbCrGLIC-8","XYZ-8","YES-8")
#@gui :Contain Alpha?=bool(0)
#@gui :_=separator(),_=note("- Channel Setting -")
#@gui :Channel Order=choice(0,"1-2-3-4","1-2-4-3","1-3-2-4","1-3-4-2","1-4-2-3","1-4-3-2","2-1-3-4","2-1-4-3","2-3-1-4","2-3-4-1","2-4-1-3","2-4-3-1","3-1-2-4","3-1-4-2","3-2-1-4","3-2-4-1","3-4-1-2","3-4-2-1","4-1-2-3","4-1-3-2","4-2-1-3","4-2-3-1","4-3-1-2","4-3-2-1")
#@gui :Channel Order=choice(0,"1-2-3","1-3-2","2-1-3","2-3-1","3-1-2","3-2-1")
#@gui :Edit Multiple Channel Separately?=bool(1)
#@gui :_=separator(),_=note("<b>Diagonal Setting</b>"), _=separator()
#@gui :Flip Diagonal?=bool(0)
#@gui :_=separator(),_=note("<b>Modulo Texture Setting</b>")
#@gui :_=separator(),_=note("- Multichannel Editing-")
#@gui :Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui :Modulo Variable #1=int(0,0,786)
#@gui :Modulo Variable #2=int(255,0,786)
#@gui :Function Angle=float(0,-180,180)
#@gui :Value Shift=int(0,0,786)
#@gui :Centered=bool(1)
#@gui :Negate=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=note("<small>Option available when <u>Edit Multiple Channel Separately</u> is turned off</small>")
#@gui :_=separator(),_=note("- Separate Channel Editing -")
#@gui :Channel Section=choice(0,"Channel #1","Channel #2","Channel #3","Channel #4")
#@gui :Channel Section=choice(0,"Channel #1","Channel #2","Channel #3")
#@gui :_=note("<small>Option available when <u>Edit Multiple Channel Separately</u> is turned on</small>"), _=separator()
#@gui :Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui :Modulo Variable #1=int(0,0,786)
#@gui :Modulo Variable #2=int(255,0,786)
#@gui :Function Angle=float(0,-180,180)
#@gui :Value Shift=int(0,0,786)
#@gui :Centered=bool(1)
#@gui :Negate=bool(0)
#@gui :Normalize=bool(1)
#@gui :Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui :Modulo Variable #1=int(0,0,786)
#@gui :Modulo Variable #2=int(255,0,786)
#@gui :Function Angle=float(0,-180,180)
#@gui :Value Shift=int(0,0,786)
#@gui :Centered=bool(1)
#@gui :Negate=bool(0)
#@gui :Normalize=bool(1)
#@gui :Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui :Modulo Variable #1=int(0,0,786)
#@gui :Modulo Variable #2=int(255,0,786)
#@gui :Function Angle=float(0,-180,180)
#@gui :Value Shift=int(0,0,786)
#@gui :Centered=bool(1)
#@gui :Negate=bool(0)
#@gui :Normalize=bool(1)
#@gui :Modulo Mode=choice(3,"Regular Modulo","Continuous Regular Modulo","Divisive Modulo","Continuous Divisive Modulo")
#@gui :Modulo Variable #1=int(0,0,786)
#@gui :Modulo Variable #2=int(255,0,786)
#@gui :Function Angle=float(0,-180,180)
#@gui :Value Shift=int(0,0,786)
#@gui :Centered=bool(1)
#@gui :Negate=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=note("<small>Option available when <u>Edit Multiple Channel Separately</u> is turned on</small>")
#@gui :_=separator(),_=note("<b>Subpixel Processing Setting</b>"), _=separator()
#@gui :Subpixel Rendering Level=float(1,0,1)
#@gui :Subpixel Interpolation=choice(5,"Nearest","Average","Grid","Linear","Bicubic","Lanczos")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/10/07</i>.</small>")
gui_rep_colmt:
cs=$1
alp=$2
tc={$cs!=3?3+$alp:4}
pos={$tc==4?$3:$4}
argset=${1-2},$pos,$6,${49-50}
if $5 rep_color_modulo_texture $argset,${17-48}
else rep_color_modulo_texture $argset,${7-14}
fi
gui_rep_colmt_preview:
gui_rep_colmt $*
cs=$1
alp={$2?1}
tc={$cs!=3?3+$alp:4}
set_a={!$5?2:0}
set_b={$5?($tc==4?($15==0?2:0):($16==0?2:0)):0}
set_c={$5?($tc==4?($15==1?2:0):($16==1?2:0)):0}
set_d={$5?($tc==4?($15==2?2:0):($16==2?2:0)):0}
set_e={$5?($tc==4?($15==3?2:0):0):0}

u "{$1}"\
"{$2}_"{$1==3?0:2}\
"{$3}_"{$tc==4?2:0}\
"{$4}_"{$tc==3?2:0}\
"{$5}"\
"{$6}"\
"{$7}_"$set_a\
"{$8}_"$set_a\
"{$9}_"$set_a\
"{$10}_"$set_a\
"{$11}_"$set_a\
"{$12}_"$set_a\
"{$13}_"$set_a\
"{$14}_"$set_a\
"{$15}_"{$5&&$tc==4?2:0}\
"{$16}_"{$5&&$tc==3?2:0}\
"{$17}_"$set_b\
"{$18}_"$set_b\
"{$19}_"$set_b\
"{$20}_"$set_b\
"{$21}_"$set_b\
"{$22}_"$set_b\
"{$23}_"$set_b\
"{$24}_"$set_b\
"{$25}_"$set_c\
"{$26}_"$set_c\
"{$27}_"$set_c\
"{$28}_"$set_c\
"{$29}_"$set_c\
"{$30}_"$set_c\
"{$31}_"$set_c\
"{$32}_"$set_c\
"{$33}_"$set_d\
"{$34}_"$set_d\
"{$35}_"$set_d\
"{$36}_"$set_d\
"{$37}_"$set_d\
"{$38}_"$set_d\
"{$39}_"$set_d\
"{$40}_"$set_d\
"{$41}_"$set_e\
"{$42}_"$set_e\
"{$43}_"$set_e\
"{$44}_"$set_e\
"{$45}_"$set_e\
"{$46}_"$set_e\
"{$47}_"$set_e\
"{$48}_"$set_e\
"{$49}"\
"{$50}"
#@gui Picture Mosaic:fx_rep_photomosaic,fx_rep_photomosaic_preview
#@gui :_=note("Generates picture mosaic using indexing,color searching, and scaling.\n\n<b>Note - </b>Instruction are found below!"),_=separator()
#@gui :_=note("<b>- Input -<b>")
#@gui :Use Folder?=bool(0)
#@gui :Mosaic Tile Pictures=folder()
#@gui :Target Layer=choice(0,"Top","Bottom"),_=separator(),_=note("<b>- Mosaic Generation -</b>\n\n<small><i>Note: When either tile_height or tile_width is equal to 0, it will automatically create the tile ratio based on which side is smaller.</i></small>")
#@gui :Tile Width=int(15,0,50)
#@gui :Tile Height=int(0,0,50)
#@gui :Dithering (%)=float(50,0,100)
#@gui :Scaling Interpolation=choice(0,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui :Palette Choice=choice(0,"Average","Median")
#@gui :Autocrop=bool(0)
#@gui :Preserve Original Dimension=bool(0),_=separator(),_=note("<b>Paint.NET Workaround</b>")
#@gui :Workaround Mode=choice(1,"Export","Clipped-Center",Both")
#@gui :Folder=folder()
#@gui :Filename=text("mosaic.png")
#@gui :_=note("<small>This section is only for Paint.NET users! If you don't use this this software, then you don't need use this section!</small>")
#@gui :_=separator(),_=note("<b>- Information -</b>\n\n<b>Do not be alarmed when multiple command prompt shows up when using folder input as it is a normal process!</b>\n\nThis filter is used for generation of mosaic pictures. Also, the mosaic cli command cannot support a number of images that is less than 3, so this gui filter will automatically use folder input option instead. So, you need at least 2 images inside a folder for the mosaic filter to work when using folder input. For more information, see below.\n\n<b>-Software Usage -</b>\n\n<b>For Krita, and GIMP: </b> Set to input layers to <b>All</b> assuming 3 or more layers are in your file to create mosaic using the top image as a mosaic target.If you are using folder input instead, it is recommended to set layer input to <b>Active</b>.\n\n<b>For Paint.NET: </b> Using 3 or more layer is unsupported due to the Paint.NET plugin restriction, so you can only use folder input. This is a workaround as G'MIC itself supports more than 2 layers.")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/5/1</i>.</small>")
fx_rep_photomosaic:
fileloc="$2"
filename="$12/$13"

ww={w}
hh={h}

if '$_host'=='paintdotnet'
 k[0] ig $fileloc rep_photomosaic[0] [^0],$4,$5,{$6/100},${7-9} k[0]
 if $11==0||$11==2 o[0] $filename fi
 if $11 r $ww,$hh,100%,100%,0,0,.5,.5 fi
else
  if ($!>2)&&!$1
   if $3 rv fi rep_photomosaic[0] [^0],$4,$5,{$6/100},${7-9} if !$3 k[0] fi
  else
   imgs={$!} ig $fileloc rep_photomosaic[0-{$imgs-1}] [$imgs--1],$4,$5,{$6/100},${7-9} k[0-{$imgs-1}]
  fi
 if $10 r $ww,$hh,100%,100%,0,0,.5,.5 fi
fi
fx_rep_photomosaic_preview:
if '$_host'=='paintdotnet' pdn=1 else pdn=0 fi
imgs={$!}
fx_rep_photomosaic $1,"$2",${3-11},"$12","$13"

a={$pdn?($11==0||$11==2?2:1)}

u "{$1}_"{!$pdn?($imgs<2?1:2)}\
"{$2}_"{!$pdn?($imgs>2?($1?2:1):2):2}\
"{$3}_"{!$pdn?($imgs>2?(!$1?2:1):2)}\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}_"{!$pdn?2}\
"{$11}_"{$pdn?2}\
"{$12}_"$a\
"{$13}_"$a
#@gui Non-Convolution Edge Extraction:fx_ncee,fx_ncee_preview(0)
#@gui :_=note("Based off PS Embossing filtering. The way it works is that you duplicate once and then shift with wrap-around using original image data using an angle and offset. Then finally, you invert one of the layer, and average those values. In this filter, you have several options when it comes to alpha and how the image wrap-around. Also, CMYK mode may be fixed later as I'm trying to avoid the problem with Alpha mode and CMYK mode.")
#@gui :_=separator()
#@gui :Colour Space=choice(0,"RGB8","RYB8","CMY8","CMYK8","HSI8","HSL8","HSV8","LAB8","LCH8","YIQ8","YUV8","XYZ8","YES8","Kodak 1-8","Ohta8")
#@gui :_=separator()
#@gui :Angle=float(0,0,360)
#@gui :Offset=float(1,.5,256)
#@gui :Contrast Factor [%]=float(100,0,500)
#@gui :Wraparound Mode=choice(2,"Dirichlet","Neumann","Periodic","Mirror")
#@gui :Interpolation=bool(0)
#@gui :_=separator(),_=note("Alpha Processing")
#@gui :Alpha Mode=choice(0,"Preserve Original Alpha","Multiply Alphas")
#@gui :_=separator(),_=note("Blending Processing\n\n<i>If you're looking for normal blending mode, you do not need to touch this and if you did, set mode to alpha and opacity to 100.</i>")
#@gui :Blending Mode=choice(1,"add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor")
#@gui :9. Blending Opacity=float(100,0,100)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian Latest Update: <i>2019/4/25</i>.</small>")
fx_ncee:
repeat $! l[$>] rep_ncee $3,$2,$5,$6,{$4/100},$7,$1,$8,{$9/100} endl done
fx_ncee_preview:
gui_split_preview "fx_ncee $*",${-3--1}
#@gui Fragment Blur:gui_rep_frblur,gui_rep_frblur_preview(0)
#@gui :_=note("Inspired by the Paint.NET Fragment Blur filter, this implementation improves upon it by adding color space options, preservation of original image as a option, boundary condition option, and interpolation option.\n\n<b>Warning -</b> Preview may not be accurate with image with completely opaque images. The output will not show any transparency regardless."), _=separator(), _=note("<b>Main Setting</b>")
#@gui :Color Space=choice(0,"RGB","sRGB","RYB","CMYK","HCY","HSI","HSL","HSV","LAB","LCH")
#@gui :Additional Duplicates Count=int(10,2,100)
#@gui :Half Image-Diagonal (%)=float(5,0,100)
#@gui :Angle=float(0,-180,180)
#@gui :Superimpose with Original?=bool(0)
#@gui :_=separator(),_=note("<b>Secondary Setting</b>")
#@gui :Boundary=choice(1,"None","Neumann","Periodic","Mirror")
#@gui :Shift Linear Interpolation? =bool(0)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author : <i>Reptorian</i>      Latest update: <i>2019/9/26</i>.</small>")
gui_rep_frblur: rep_frblur $2,$3%,$4,$5,$6,$7,$1
gui_rep_frblur_preview: gui_split_preview "gui_rep_frblur $*",${-3--1}
#@gui Nebulous:fx_rep_nebulous,fx_rep_nebulous_preview
#@gui :_=note("Based off <a href="https://forums.getpaint.net/topic/111774-nebulous-texture-update-ymd20170922/?tab=comments#comment-535865">MadJik's PDN Nebulous plugin</a>. The G'MIC version of Nebulous allows you to manipulate the result by angle within the main surface and the distortion surface, and allows you to shift the positioning of the Nebulous surface. Furthermore, the G'MIC version of Nebulous doesn't use integer on the output of surface."), _=separator()
#@gui :_=note("<b>Surface Theme</b>"), Colour Space Mode=choice (0,"RGB8","RYB8","HSI8","HSL8","HSV8","LAB8","LCH8","YIQ8","YUV8","XYZ8","YES8","Kodak 1-8","Ohta8"), _=separator()
#@gui :_=note("<b>Surface Generation</b>")
#@gui :XY-Factor=float(4,.1,1000)
#@gui :X-Factor=float(10,.01,1000)
#@gui :Y-Factor=float(10,.01,1000)
#@gui :X-Shift (%)=float(0,-10,10)
#@gui :Y-Shift (%)=float(0,-10,10)
#@gui :Angle of Main Nebulous Surface=float(0,-180,180)
#@gui :Wave(s)=float(1,-25,25)
#@gui :Lighting Angle=float(0,-180,180)
#@gui :Surface Disturbance=float(0,0,2000)
#@gui :Surface Disturbance Multiplier=float(1,1,500)
#@gui :Disturbance X=float(0,0,1000)
#@gui :Disturbance Y=float(0,0,1000)
#@gui :Angle of Disturbance Surface=float(0,-180,180)
#@gui :Disturbance Scale-By-Factor=bool(0)
#@gui :Output Mode=choice(2,"Built-in Gray","Luminosity from Color","Color")
#@gui :Alpha Mode=choice(0,"None","Hard Light","Hard Dark","Smooth Light","Smooth Dark")
#@gui :_=separator()
#@gui :_=note("<b>Subpixel Processing</b>\n\n You do not need to touch this unless you want higher amount of precision, but the difference is small. If you are using a very small surface or hard alpha mode, then it makes sense to touch subpixel processing variables.")
#@gui :Subpixel Level=float(1,0,3)
#@gui :Subpixel Interpolation=choice(3,"Average","Linear","Grid","Bicubic","Lanczos")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2019/5/11</i>.</small>")
fx_rep_nebulous:
convert_colors=${arg\ 1+$1,to_rgb,ryb2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,xyz82rgb,yes82rgb,k182rgb,ohta82rgb}
repeat $! l[$>]
 rep_nebulous ${2-8},{$1>4&&$1<9?$9+180:$9},{$10*$11},${12-16},{$1>4&&$1<9?$17!=0?($17>=3?3+(4-$17):1+(2-$17)):$17},{$18+1},$19 + 1 * 127.5
 if $1&&$16
  $convert_colors.
 fi
 if $16==1
  s c,{if(s==4,-3,if(s==2,-1,-s))}
  if $!==2
   to_gray.. a c
  else
   to_gray
  fi
 fi
endl done
fx_rep_nebulous_preview:
fx_rep_nebulous $*
#@gui Grouped Pixel Axis-Based Shift:fx_rep_sptbwgp,fx_rep_sptbwgp_preview
#@gui :_=note("Based off MadJik's Paint.NET Gravity Plugin. New feature are shift position, and influence factor."),_=separator()
#@gui :Shift Position (%)=float(0,-100,100)
#@gui :Influence Factor (%)=float(0,0,100)
#@gui :Threshold (%)=float(0,0,100)
#@gui :Axis=choice(0,"Horizontal","Vertical")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/5/14</i>.</small>")
fx_rep_sptbwgp:
position={$1%}
axis=$4
threshold={$3%*255}
influence={$2%}
rep_sptbwgp $position,$axis,$influence,$threshold
fx_rep_sptbwgp_preview:
gui_split_preview "fx_rep_sptbwgp ${1-4}",${-3--1}
#@gui Binary Alternating Quaddro Texture [Basic]:rep_binary_quaddro_basic_gui,rep_binary_quaddro_basic_gui_preview(0)
#@gui :_=note("This filter is a extended version of a filter found in<a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui :_=note("<b>Channel Processing</b>"),Texture Output=choice(0,"Grayscale","Hue","Degradation Mode"),_=separator()
#@gui :_=note("<b>Main Texture Processing</b>")
#@gui :Style=choice(0,"Cracking Alternating Texture","Alternating Glasses","Simple")
#@gui :Variable#1=int(8,-512,512)
#@gui :Variable#2=int(8,-512,512)
#@gui :Variable#3=int(128,-200,200)
#@gui :Operand=choice(2,"AND","OR","XOR")
#@gui :Angle=float(0,-180,180)
#@gui :X-Flip=bool(0)
#@gui :Y-Flip=bool(0)
#@gui :Number Modulo=int(256,256,2048)
#@gui :Internal Normalize=int(255,255,2048)
#@gui :Internal Normalization=bool(1)
#@gui :Number Modulo=int(361,256,2048)
#@gui :Internal Normalize=int(361,360,2048)
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2018/12/19</i>.</small>")
rep_binary_quaddro_basic_gui:
if $1==0
rep_binaltquad ${2-12} % 256
elif $1==1
repeat $! l[$>] rep_binaltquad ${2-9},${13-14},1 % 361 +f 1 . a c hsv2rgb endl done
elif $1==2
repeat $! l[$>] +rep_binaltquad ${2-9},{w*h-1},{w*h-1} f.. I[i#1] k.. endl done
fi
rep_binary_quaddro_basic_gui_preview:
rep_binary_quaddro_basic_gui $*
a={$2!=2?2:0}
b={$1==0?2:0}
c={$1==1?2:0}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}_"$a\
"{$6}_"$a\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}_"$b\
"{$11}_"$b\
"{$12}_"$b\
"{$13}_"$c\
"{$14}_"$c
#@gui Binary Alternating Quaddro Texture [MultiChannel]:rep_binary_quaddro_mc_gui, rep_binary_quaddro_mc_gui_preview(0)
#@gui :_=note("This filter is a extended version of a filter found in <a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui :_=note("<b>Configuration</b>")
#@gui :Color Space=choice(0,"RGB","RYB","CMY","CMYK","HSI","HSV","HSL","LAB","LCH","YCbCr","YCbCrGLIC","YIQ","YUV","XYZ")
#@gui :Contain Alpha?=bool(0)
#@gui :8-Bit Mode?=bool(0)
#@gui :_=separator()
#@gui :_=note("<b>Channel Order</b>")
#@gui :Channel #1=choice(0,"0","1","2")
#@gui :Channel #2=choice(1,"0","1","2")
#@gui :Channel #3=choice(2,"0","1","2")
#@gui :Channel #1=choice(0,"0","1","2","3")
#@gui :Channel #2=choice(1,"0","1","2","3")
#@gui :Channel #3=choice(2,"0","1","2","3")
#@gui :Channel #4=choice(3,"0","1","2","3")
#@gui :Channel #1=choice(0,"0","1","2","3","4")
#@gui :Channel #2=choice(1,"0","1","2","3","4")
#@gui :Channel #3=choice(2,"0","1","2","3","4")
#@gui :Channel #4=choice(3,"0","1","2","3","4")
#@gui :Channel #5=choice(4,"0","1","2","3","4")
#@gui :_=separator()
#@gui :_=note("<b>Main Texture Processing</b>")
#@gui :_=note("<i>Channel #1</i>")
#@gui :Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui :Variable#1=int(8,-512,512)
#@gui :Variable#2=int(8,-512,512)
#@gui :Variable#3=int(128,-200,200)
#@gui :Operand=choice(2,"AND","OR","XOR")
#@gui :Angle=float(0,-180,180)
#@gui :X-Flip=bool(0)
#@gui :Y-Flip=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=separator()
#@gui :_=note("<i>Channel #2</i>")
#@gui :Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui :Variable#1=int(8,-512,512)
#@gui :Variable#2=int(8,-512,512)
#@gui :Variable#3=int(128,-200,200)
#@gui :Operand=choice(2,"AND","OR","XOR")
#@gui :Angle=float(0,-180,180)
#@gui :X-Flip=bool(0)
#@gui :Y-Flip=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=separator()
#@gui :_=note("<i>Channel #3</i>")
#@gui :Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui :Variable#1=int(8,-512,512)
#@gui :Variable#2=int(8,-512,512)
#@gui :Variable#3=int(128,-200,200)
#@gui :Operand=choice(2,"AND","OR","XOR")
#@gui :Angle=float(0,-180,180)
#@gui :X-Flip=bool(0)
#@gui :Y-Flip=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=separator()
#@gui :_=note("<i>Channel #4</i>")
#@gui :Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui :Variable#1=int(8,-512,512)
#@gui :Variable#2=int(8,-512,512)
#@gui :Variable#3=int(128,-200,200)
#@gui :Operand=choice(2,"AND","OR","XOR")
#@gui :Angle=float(0,-180,180)
#@gui :X-Flip=bool(0)
#@gui :Y-Flip=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=separator()
#@gui :_=note("<i>Channel #5</i>")
#@gui :Style=choice(0,"Bumping Alternating Texture","Alternating Glasses","Simple")
#@gui :Variable#1=int(8,-512,512)
#@gui :Variable#2=int(8,-512,512)
#@gui :Variable#3=int(128,-200,200)
#@gui :Operand=choice(2,"AND","OR","XOR")
#@gui :Angle=float(0,-180,180)
#@gui :X-Flip=bool(0)
#@gui :Y-Flip=bool(0)
#@gui :Normalize=bool(1)
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2018/12/19</i>.</small>")
rep_binary_quaddro_mc_gui:
cs_mode=$1
cmyk_mode={$cs_mode==3?4:3}
contain_alpha={$2?1:0}
tch={$cmyk_mode+$contain_alpha}
if $tch==3 rep_binary_alterating_quad_c $1,$2,$3,$4,$5,$6,${14-42}
elif $tch==4 rep_binary_alterating_quad_c $1,$2,$3,$7,$8,$9,$10,${15-51}
else rep_binary_alterating_quad_c $1,$2,$3,$11,$12,$13,$14,$15,${16-60}
fi
rep_binary_quaddro_mc_gui_preview:
cs_mode=$1
cmyk_mode={$1==3?4:3}
contain_alpha={$2?1:0}
tch={$cmyk_mode+$contain_alpha}
rep_binary_quaddro_mc_gui $*

set_a={$tch==3?2:0}
set_b={$tch==4?2:0}
set_c={$tch==5?2:0}
set_d={$16!=2?2:0}
set_e={$24!=2?2:0}
set_f={$34!=2?2:0}
set_g={$tch>=4?2:0}
set_h={$tch>=4?($43!=2?2:0):0}
set_i={$tch>=5?($43!=2?2:0):0}
set_j={$tch>=5?2:0}

u "{$1}"\
"{$2}"\
"{$3}_"{(($cs_mode>8&&$cs_mode<11)||$cs_mode<=3)?0:2}\
"{$4}_"$set_a\
"{$5}_"$set_a\
"{$6}_"$set_a\
"{$7}_"$set_b\
"{$8}_"$set_b\
"{$9}_"$set_b\
"{$10}_"$set_b\
"{$11}_"$set_c\
"{$12}_"$set_c\
"{$13}_"$set_c\
"{$14}_"$set_c\
"{$15}_"$set_c\
"{$16}"\
"{$17}"\
"{$18}"\
"{$19}_"$set_d\
"{$20}_"$set_d\
"{$21}"\
"{$22}"\
"{$23}"\
"{$24}"\
"{$25}"\
"{$26}"\
"{$27}"\
"{$28}_"$set_e\
"{$29}_"$set_e\
"{$30}"\
"{$31}"\
"{$32}"\
"{$33}"\
"{$34}"\
"{$35}"\
"{$36}"\
"{$37}_"$set_f\
"{$38}_"$set_f\
"{$39}"\
"{$40}"\
"{$41}"\
"{$42}"\
"{$43}_"$set_g\
"{$44}_"$set_g\
"{$45}_"$set_g\
"{$46}_"$set_h\
"{$47}_"$set_h\
"{$48}_"$set_g\
"{$49}_"$set_g\
"{$50}_"$set_g\
"{$51}_"$set_g\
"{$52}_"$set_j\
"{$53}_"$set_j\
"{$54}_"$set_j\
"{$55}_"$set_i\
"{$56}_"$set_i\
"{$57}_"$set_j\
"{$58}_"$set_j\
"{$59}_"$set_j\
"{$60}_"$set_j
#@gui Sinusoidal Water Distortion:rep_sinowaterdist_gui,rep_sinowaterdist_gui_preview(0)
#@gui :X-Balance=float(0,-100,100)
#@gui :Y-Balance=float(0,-100,100)
#@gui :Scale=float(.5,.1,100)
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :Boundary Condition=choice(0,"Periodic","Mirror")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_sinowaterdist_gui:
rep_sinowaterdist $1,$2,{($3/100)*(w>h?w:h)},$4,$5
rep_sinowaterdist_gui_preview:
gui_split_preview "rep_sinowaterdist_gui $*",${-3--1}
#@gui Strange Bulger: rep_strbul,rep_strbul_preview(0)
#@gui :Angle=float(0,-180,180)
#@gui :Axis=choice(0,"X-Axis","Y-Axis")
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :Boundary Condition=choice(0,"Periodic","Mirror")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_strbul_preview:
gui_split_preview "rep_strbul $*",${-3--1}
#@gui Strange Bulger Kaleidoscope:rep_strbulkal_gui,rep_strbulkal_gui_preview(0)
#@gui :_=note("This filter is a extended version of the filters named 'Strange Bulger A', and 'Strange Bulger B' found in<a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using source code for Asmageddon's tool, and then extended."),_=separator()
#@gui :Bulge Angle=float(0,-180,180)
#@gui :Axis of Bulge=choice(0,"X-Axis","Y-Axis")
#@gui :Scale=float(1,.1,10)
#@gui :Preliminary Surface Shift = point(50,50,0,1,128,128,128,255)
#@gui :Distortion Surface Position = point(50,50,0,1,255,255,255,255)
#@gui :Distortion Surface Angle=float(0,0,360)
#@gui :Placement=choice(0,"Inside-Out","Outside-In")
#@gui :Boundary Condition=choice(0,"Periodic","Mirror")
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :Base Reference Dimension=int(1024,10,4096)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_strbulkal_gui:
rep_strbulkal ${1-3},{(($4/100)-.5)*2},{(($5/100)-.5)*-2},{(($6/100)-.5)*2},{(($7/100)-.5)*-2},${8-12}
rep_strbulkal_gui_preview:
gui_split_preview "rep_strbulkal_gui $*",${-3--1}
#@gui Logarithmic Distortion:rep_logpindis_gui,rep_logpindis_gui_preview(0)
#@gui :_=note("This filter is a extended version of a filter found in <a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui :Distortion Factor=float(1,.1,1000)
#@gui :Preliminary Surface Shift = point(50,50,0,1,128,128,128,255)
#@gui :Distortion Surface Position = point(50,50,0,1,255,255,255,255)
#@gui :Preliminary X-Axis Scaling=float(1,.1,10)
#@gui :Preliminary Y-Axis Scaling=float(1,.1,10)
#@gui :Effect X-Axis Scaling=float(1,.1,10)
#@gui :Effect Y-Axis Scaling=float(1,.1,10)
#@gui :Distortion Surface Angle=float(0,0,360)
#@gui :Placement=choice(0,"Inside-Out","Outside-In")
#@gui :Logarithmic Distortion Axis Combination for X-Axis=choice(0,"Different Axis","Same Axis")
#@gui :Logarithmic Distortion Axis combination for y-Axis=choice(0,"Different Axis","Same Axis")
#@gui :Logarithmic Distortion X-Axis Direction=choice(0,"Negative","Positive")
#@gui :Logarithmic Distortion Y-Axis Direction=choice(0,"Negative","Positive")
#@gui :Boundary Condition=choice(0,"Periodic","Mirror")
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :Base Reference Dimension=int(1024,10,4096)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_logpindis_gui:
rep_logpindis $1,{(($2/100)-.5)*2},{(($3/100)-.5)*-2},{(($4/100)-.5)*2},{(($5/100)-.5)*-2},${6-18}
rep_logpindis_gui_preview:
gui_split_preview "rep_logpindis_gui $*",${-3--1}
#@gui Squareroot - Logarithmic Distortion:rep_sqrlogpindis_gui,rep_sqrlogpindis_gui_preview(0)
#@gui :_=note("This filter is a extended version of a filter found in <a href="https://forums.getpaint.net/topic/6845-asmageddon-tools-pack-v3/">Asmageddon Tools Pack v3</a>. Translated to G'MIC using a source code, and then extended. It is a mixture of two texture filters."),_=separator()
#@gui :Distortion Factor=float(1,.1,1000)
#@gui :Preliminary Surface Shift = point(50,50,0,1,128,128,128,255)
#@gui :Distortion Surface Position = point(50,50,0,1,255,255,255,255)
#@gui :Preliminary X-Axis Scaling=float(1,.1,10)
#@gui :Preliminary Y-Axis Scaling=float(1,.1,10)
#@gui :Effect X-Axis Scaling=float(1,.1,10)
#@gui :Effect Y-Axis Scaling=float(1,.1,10)
#@gui :Distortion Surface Angle=float(0,0,360)
#@gui :Placement=choice(0,"Inside-Out","Outside-In")
#@gui :Logarithmic Distortion Axis Combination for X-Axis=choice(0,"Different Axis","Same Axis")
#@gui :Logarithmic Distortion Axis combination for y-Axis=choice(0,"Different Axis","Same Axis")
#@gui :Logarithmic Distortion X-Axis Direction=choice(0,"Negative","Positive")
#@gui :Logarithmic Distortion Y-Axis Direction=choice(0,"Negative","Positive")
#@gui :Boundary Condition=choice(0,"Periodic","Mirror")
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :Base Reference Dimension=int(1024,10,4096)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
rep_sqrlogpindis_gui:
rep_sqrlogpindis $1,{(($2/100)-.5)*2},{(($3/100)-.5)*-2},{(($4/100)-.5)*2},{(($5/100)-.5)*-2},${6-18}
rep_sqrlogpindis_gui_preview:
gui_split_preview "rep_sqrlogpindis_gui $*",${-3--1}
#@gui Stitch :rep_stitch_gui,rep_stitch_gui_preview(0)
#@gui :_=note("This is a extended version of a existing filter within the Paint.NET software named <a href="https://forums.getpaint.net/topic/5936-stitch/">Stitch</a> which was made by pyrochild. The extension would be that it supports 1 angle, and it can support more than 2 angles. Anti-aliasing via interpolation and subpixel processing, along with boundary options are also supported.\n\n<i>Warning!Preview is only for giving a idea on the result!</i>"), _=separator()
#@gui :Pixel Offset of Image-Diagonal(%)=float(5,0,100)
#@gui :Thickness of Stitches=float(3,1,20)
#@gui :Stitches Repeat Pattern (0 means no repeat)=int(10,0,500)
#@gui :Interpolation=choice(4,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui :Boundary=choice(1,"None","Neumann","Repeat","Mirror")
#@gui :Subpixel Processing Level=float(1,0,5)
#@gui :Randomize Stitching?=bool(0), _=separator()
#@gui :_=note("<b>Angle Inputs</b>\n\nOnly numbers are accepted!")
#@gui :Angle Count=int(2, 1, 12)
#@gui :Angle#1=float(45,-180,180)
#@gui :Angle#2=float(-45,-180,180)
#@gui :Angle#3=float(90,-180,180)
#@gui :Angle#4=float(0,-180,180)
#@gui :Angle#5=float(60,-180,180)
#@gui :Angle#6=float(-60,-180,180)
#@gui :Angle#7=float(15,-180,180)
#@gui :Angle#8=float(-15,-180,180)
#@gui :Angle#9=float(30,-180,180)
#@gui :Angle#10=float(-30,-180,180)
#@gui :Angle#11=float(5,-180,180)
#@gui :Angle#12=float(-5,-180,180)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/7/24</i>.</small>")
rep_stitch_gui:
img_diag={norm(w,h)*($1/100)}
if $8==1 rep_stitch $img_diag,${2-7},$9
elif $8==2 rep_stitch $img_diag,${2-7},${9-10}
elif $8==3 rep_stitch $img_diag,${2-7},${9-11}
elif $8==4 rep_stitch $img_diag,${2-7},${9-12}
elif $8==5 rep_stitch $img_diag,${2-7},${9-13}
elif $8==6 rep_stitch $img_diag,${2-7},${9-14}
elif $8==7 rep_stitch $img_diag,${2-7},${9-15}
elif $8==8 rep_stitch $img_diag,${2-7},${9-16}
elif $8==9 rep_stitch $img_diag,${2-7},${9-17}
elif $8==10 rep_stitch $img_diag,${2-7},${9-18}
elif $8==11 rep_stitch $img_diag,${2-7},${9-19}
elif $8==12 rep_stitch $img_diag,${2-7},${9-20}
fi
rep_stitch_gui_preview:
gui_split_preview "rep_stitch_gui $*",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}_"{$8>=2?2:0}\
"{$11}_"{$8>=3?2:0}\
"{$12}_"{$8>=4?2:0}\
"{$13}_"{$8>=5?2:0}\
"{$14}_"{$8>=6?2:0}\
"{$15}_"{$8>=7?2:0}\
"{$16}_"{$8>=8?2:0}\
"{$17}_"{$8>=9?2:0}\
"{$18}_"{$8>=10?2:0}\
"{$19}_"{$8>=11?2:0}\
"{$20}_"{$8>=12?2:0}\
"{$21}"\
"{$22}"
#@gui Kaleidoscope [Reptorian-Polar]:gui_rep_polkal,gui_rep_polkal
#@gui :Angle Cut=float(2,.01,100)
#@gui :Radius Cut=float(1,.01,100)
#@gui :Surface Angle=float(0,-180,180)
#@gui :Center (%)=point(50,50)
#@gui :Flip Angle Direction?=bool(0)
#@gui :Flip Radial Direction?=bool(0)
#@gui :Angle Edge Behaviour=choice(1,"Repeat","Alternating")
#@gui :Radial Edge Behaviour=choice(2,"None","Repeat","Alternating")
#@gui :Fit Radial End to Min/Max Dimension=choice(0,"Minimum Dimension","Maximum Dimension")
#@gui :Conical Start at 0?=bool(1)
#@gui :_=note("<small>Conical start is only used for matching other software filter behavior with conical gradients</small>")
#@gui :_=separator()
#@gui :Sublevel=float(.5,0,3)
#@gui :Interpolation=choice(2,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/9/7</i>.</small>")
gui_rep_polkal: rep_polkal ${1-3},{($4-50)*2}%,{($5-50)*-2}%,${6--1}
#@gui Object Size Filtering: gui_rep_objvf,gui_rep_objvf_preview(0)
#@gui :Mode of Object Filtering=choice(0,"Auto","Alpha","Colour")
#@gui :Threshold for Auto-Mode Switching(%)=float(10,0,100)
#@gui :_=separator(),_=note("<b>Object Filtering Options</b>")
#@gui :Volume 1 (%)=float(1,0,100)
#@gui :Volume 2 (%)=float(99,0,100)
#@gui :Preserve=choice(0,"Inclusive","Exclusive")
#@gui :Preserve=choice(0,"Inclusive by Secondary Max Area","Exclusive by Secondary Max Area")
#@gui :Use Secondary Maximum Area?=bool(0)
#@gui :Colour=color(0,0,0,0)
#@gui :_=separator(),_=note("<b>Preview Settings</b>")
#@gui :Reveal Erased Objects?=bool(1)
#@gui :Colour of Erased Object=color(127,127,127)
#@gui :Render Mode=choice(0,"Main","Removed Alpha Mode","Alpha Details")
#@gui :List Percentiles?=bool(0)_0
#@gui :_=separator(),_=note("<b>-Instruction-</b>\n\nThe purpose of this filter is to filter objects based on their volume. It is based on the principle of the <a href="https://forums.getpaint.net/topic/113962-object-pruner/">Object Pruner plugin</a> for Paint.NET made by <b>MJW</b>.\n\n<b>Note:</b> Use Colour Mode for fully opaque image.\n<b>Alternative Note:</b> Use Colour Mode with Alpha or Auto.\n\n<b>Special Note:</b> If you're seeing error, switch the render mode and pick the colors until error no longer show up on Main Render Mode.Sometimes changing Mode of Object Filtering can resolve it.\n----\n<b>Warning:</b> Untested on GIMP!")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/2/21</i>.</small>")
gui_rep_objvf:
if $7 preserve_choice={($6+1)*-1}
else preserve_choice=$5
fi

if !$1
 repeat $! l[$>]
  colour={vectors(${8-11})}
  if s==2||s>3
   ss={s-1}
   colour={vector$ss(${8-11})}
   sh {s-1}
   maxalp={iM#-1}
   +f. i#-1?1
   sumnalp={1-(is#-1/wh#-1)}
   rm.
   if $sumnalp>$2%
    rm.
    rep_objvf $3%,$4%,$preserve_choice
   else
    if !iv#-1
     alp=$maxalp
    else
     alp=0
    fi
    rm.
    rep_objvf $3%,$4%,$preserve_choice,$colour,$alp
   fi
  else
   colour={vectors(${8-11})}
   rep_objvf $3%,$4%,$preserve_choice,$colour
  fi
 endl done
elif $1==1
 rep_objvf $3%,$4%,$preserve_choice
else
 colour={vectors(${8-11})}
 rep_objvf $3%,$4%,$preserve_choice,$colour
fi
gui_rep_objvf_preview:
show_colour=0
current_layer=0

if !$1
 do
  l[$current_layer]
   if s==2||s>3
    {w},{h},100%,1,i(#-1,x,y,z,s-1)?1
    sumnalp={1-(is#-1/wh#-1)}
    if $1>$2% show_colour=1 fi
    rm.
   fi
  endl
  current_layer+=1
 while !$show_colour&&$current_layer<$!
elif $1==2 show_colour=1
fi

if $16==2
 channels {s-1}
elif $16==1
 channels 0,{s-2}
else
 if $12
  +gui_rep_objvf ${1-11}
  f begin(ss={s-1};);if(i(x,y,z,ss),i,0);
  f.. I!=I#-1?[${13-15},255]:I
 else
  gui_rep_objvf ${1-11}
 fi
fi
u "{$1}"\
"{$2}"_{!$1?2:0}\
"{$3}"\
"{$4}"\
"{$5}"_{!$7?2:0}\
"{$6}"_{$7?2:0}\
"{$7}"\
"{$8,$9,$10,$11}"_{$show_colour?2:0}\
"{$12}"_{!$16?2:1}\
"{$13,$14,$15}"_{($12&&!$16)?2:1}\
"{$16}"\
"{$17}"_0
#@gui Tiled Form:gui_rep_form_pixel,gui_rep_form_pixel_preview
#@gui :_=note("<b>Colour Space Processing</b>")
#@gui :Colour Space=choice(0,"RGB","RYB","CMYK","HCY","HSI","HSL","HSV","LAB","LCH")
#@gui :_=separator(),_=note("<b>Tile Shape</b>")
#@gui :Tiled Shape=choice(3,"By Layer","Australia","Barbedwire","Circle","Crosshair","Cupid","Diamond","Dragon Curve-[D]","Dragonfly","Fern-[D]","Flip","Gear-[D]","Gumleaf","Heart","Information","Kookaburra","Mail","Mapleleaf","Paint Splat","Paw","Phone","Polygon-[D]","Rooster","Shopping Cart","Snowflake-[D]","Star-[D]")
#@gui :Reverse Layer=bool(0)
#@gui :_=note("<small>For the first option, you must use at least 2 layer to use layer as shape reference, else it'll use the only image itself as shape reference. Reverse Layer option might have to be used to generate the proper result when using first option.</small>")
#@gui :_=separator(),_=note("<b>Tiles</b>")
#@gui :Shape Width (px)=int(30,0,512)
#@gui :Shape Height (px)=int(30,0,512)
#@gui :Shape Ratio (%)=float(100,5,100)
#@gui :Shape Rotation=float(0,-180,180)
#@gui :Shape Mirror Axis=choice(0,"None","X","Y")
#@gui :Subpixel Level=float(.5,0,2)
#@gui :Z-Convolution Factor (%)=float(50,0,200)
#@gui :Z-Convolution Boundary=choice(0,"Neumann","Periodic")
#@gui :Interpolation=choice(5,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui :Tile Boundary=choice(0,"Periodic","Mirror - X","Mirror - Y","Mirror - XY")
#@gui :Preprocess Boundary=choice(2,"Neumann","Periodic","Mirror")
#@gui :Fit Tile?=bool(1)
#@gui :Output=choice(0,"New Dimension","New Dimension - New Layer","Old Dimension","Old Dimension - New Layer")
#@gui :_=note("<b>If using Krita and New Layer option, then you may have to reorder one layer.</b>")
#@gui :_=separator(),_=note("<b>Dynamic Shape</b>")
#@gui :Dragon Curve Recursion=int(10,0,30)
#@gui :Dragon Curve Rotation=float(0,-180,180)
#@gui :Fern Type=choice("Asplenium Adiantum-Nigrum","Thelypteridaceae")
#@gui :Fern Density (%)=float(100,0,300)
#@gui :Gear Teeth Count=int(8,3,32)
#@gui :Gear Height (%)=float(25,0.1,100)
#@gui :Gear Offset Teeth (%)=float(0,0,100)
#@gui :Gear Inner Ratio (%)=float(50,0.1,100)
#@gui :Polygon Vertices=int(5,3,100)
#@gui :Snowflake Recursion=int(5,1,6)
#@gui :Star Branches=int(3,5,100)
#@gui :Star Thickness (%)=float(38,.1,100)
#@gui :_=note("<small>Dynamic Shapes Options are only visible for dynamic shapes!</small>")
#@gui :_=separator(),_=note("Original idea comes from <a href="https://forums.getpaint.net/topic/26758-trs-tiled-pixels-v12/">TR's Tiled Pixels V1.2</a> plugin by <b>TechnoRobbo</b> for Paint.NET. This version is a extended version utilizing weighted average sampling per area per tile, boundary option, anti-aliasing, dynamic shape, color space,and transformation. Dynamic shapes are also supported by this filter.")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/15</i>.</small>")
gui_rep_form_pixel:
use_dynamic=0
ti={$!}
if $3 rv fi
if $2==7
 form_id=dragon
 form_var=${17-18}
 use_dynamic=1
elif $2==9
 form_id=fern
 form_var=$20%,0,1,$19
 use_dynamic=1
elif $2==11
 form_id=gear
 form_var=${21-24}
 use_dynamic=1
elif $2==21
 form_id=polygon
 form_var=$25
 use_dynamic=1
elif $2==24
 form_id=snowflake
 form_var=$26
 use_dynamic=1
elif $2==25
 form_id=star
 form_var=$27,{$28/100}
 use_dynamic=1
else
 form_id={$2-1}
fi
if !$2
 if $ti==1 . fi
 rep_form_pixel[^0] [0],${4-5},$6%,${7-9},${13-14},$10%,${11-12},$1,${15-16}
else
 if $use_dynamic
  rep_form_pixel $form_id,${4-5},$6%,${7-9},${13-14},$10%,${11-12},$1,${15-16},$form_var
 else
  rep_form_pixel $form_id,${4-5},$6%,${7-9},${13-14},$10%,${11-12},$1,${15-16}
 fi
fi
if !$2 rv fi
if ('$_host'=='paintdotnet')&&!$2 rm[0] fi
gui_rep_form_pixel_preview:
if $3 rv fi
if !$2
 if $!==1 +store _ref
 else store[0] _ref
 fi
fi
if $3 rv fi
if !$2
 if $!==1 +store _ref
 else store[0] _ref
 fi
fi
gui_split_preview "if !$2 $_ref rv fi gui_rep_form_pixel ${1-28}",${-3--1}

set_a={$2==7?2}
set_b={$2==9?2}
set_c={$2==11?2}
set_d={$2==25?2}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}_"{$10?2:1}\
"{$12}"\
"{$13}"\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}_"$set_a\
"{$18}_"$set_a\
"{$19}_"$set_b\
"{$20}_"$set_b\
"{$21}_"$set_c\
"{$22}_"$set_c\
"{$23}_"$set_c\
"{$24}_"$set_c\
"{$25}_"{$2==21?2}\
"{$26}_"{$2==24?2}\
"{$27}_"$set_d\
"{$28}_"$set_d\
"{$29}"\
"{$30,$31}"
#@gui Color Existence Distribution [RGB-8]:rep_color_existence_distribution_rgb8,rep_color_existence_distribution_rgb8
#@gui :_=note("This filter is used to find colors that does or does not exist within a image.\n\n For <b>Paint.NET users</b>, please refer to this tutorial named <a href="https://forums.getpaint.net/topic/115124-finding-millions-of-colors-that-does-or-does-not-exist-gmic-qt-tutorial/?tab=comments#comment-562927">Finding millions of colors that does or does not exist - G'MIC QT Tutorial</a>")
#@gui :sep separator()
#@gui :Set of Color(s)=choice(1,"Nonexistent Colors","Existing Colors")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/9/20</i>.</small>")
#@gui Reverse Engineer Gradient Map: gui_rep_regm, gui_rep_regm_preview(0)
#@gui :_=note("Reverse engineer gradient map. You must export, and then import to your program of choice!"),_=separator()
#@gui :_=note("<b>Processing</b>")
#@gui :Gradient Thickness=int(10,1,100)
#@gui :Use first layer?=bool(1)
#@gui :Normalize?=bool(0)
#@gui :_=separator(),_=note("<b>Export</b>")
#@gui :Folder=folder()
#@gui :Filename=text("gradient.png")
#@gui :Export Gradient=button()
#@gui :_=separator(),_=note("<b>Preview</b>")
#@gui :Preview all gradient at once?=bool(1)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/27</i>.</small>")
gui_rep_regm: error "Use Export Button to export gradient! This filter does nothing on host!"
gui_rep_regm_preview:
filename="$4/$5"
if $2 mv. 0 fi
if $6
 rep_reverse_engineer_gradient_map 256,$3
 r 100%,$1
 o $filename
 remove_opacity to "Exported!",.5~,.5~,50%,2,255
else
 rep_reverse_engineer_gradient_map 256,$3
 r 100%,$1
 if $7 a y fi
fi
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{0}"\
"{$7}"
#@gui Reverse Engineer Color Curve: gui_rep_recc, gui_rep_recc_preview(0)
#@gui :_=note("Reverse engineer color curves map. You must export, and then import to your program of choice!"),_=separator()
#@gui :_=note("<b>Processing</b>")
#@gui :Gradient Thickness=int(10,1,100)
#@gui :Use first layer?=bool(1)
#@gui :_=separator(),_=note("<b>Export</b>")
#@gui :Folder=folder()
#@gui :Filename=text("gradient.png")
#@gui :Export Gradient=button()
#@gui :_=separator(),_=note("<b>Preview</b>")
#@gui :Preview all gradient at once?=bool(1)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/1/2</i>.</small>")
gui_rep_recc: error "Use Export Button to export color curve map! This filter does nothing on host!"
gui_rep_recc_preview:
filename="$3/$4"
remove_opacity
if $2 mv. 0 fi
if $5
 rep_recc 256
 r 100%,$1
 o $filename
 to "Exported!",.5~,.5~,50%,2,255
else
 rep_recc 256
 r 100%,$1
 if $6 a y fi
fi
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{0}"\
"{$6}"
#@gui Autofill Coloring Book :gui_rep_acb,gui_rep_acb_preview(0)
#@gui :_=note("This filter is specifically designed to autofill areas with random colors that only appear once.\n\n<b>Don't trust the preview for colors, test the result first!</b>")
#@gui :_=separator()
#@gui :Line Threshold=int(180,1,254)
#@gui :Dilate/Erode=int(0,-3,3)
#@gui :Line Mode=choice(1,"Hard","Soft")
#@gui :Alpha Threshold=int(0,0,254)
#@gui :Coloring Seed=int(250000,0,500000)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/6/4</i>.</small>")
gui_rep_acb: rep_acb {$1/255},$2,$3,{$4/255},$5
gui_rep_acb_preview:
gui_split_preview "gui_rep_acb $*",${-3--1}

#@gui __<b>Rendering</b>
#@gui Thorn Fractal - Secant Sea:gui_rep_tfrac,gui_rep_tfrac_preview
#@gui :_=note("Thorn Fractal is the fractal attributed to Andrew Wayne Graff, alternatively named the "Secant Sea".\nThe code was adapted from <a href="http://paulbourke.net/fractals/thorn/thorn_code.c">Sample C source code</a> provided by Adam Majewski.\n\nDocumentation - <a href="http://paulbourke.net/fractals/thorn/#dane">Thorn Fractal</a> by <a href="http://paulbourke.net/fractals/">Paul Bourke</a>\n\nAlternating Chaos formula are made by <a href="https://forums.getpaint.net/profile/45895-madjik/">MadJik</a>, and they are originally used in <a href="https://forums.getpaint.net/topic/111491-fractal-attractor-ymd170628/">Fractal Attractor</a> plugin for Paint.NET software."), _=separator()
#@gui :_=note("<b>Style Setting</b>")
#@gui :Predefined Formula=choice(0,"Normal","Normal Inverted","Arctangent","Tangent","Tanh Stroke","Asymphological Vibrato","Asymphological Basic","Asymphological Basic 2","Asymphochaos","Petallian","Semi-Thorny Petallian","Thorny Petal 1","Thorny Petal 2","Inflation","Inflation 2","Chaotic Creation","Earthing","Acrylic Earthing","Unearthing Origami","Cubic Unearthing","Webbing Cubic Unearthing","Chaotic Hooks Unearthing","Chaotic Hooks","Sinusoidal Liquid","Cosinusoidal Liquid","Echo Wide","Echo Squircle","Echo Hall","Echo Hall 2","Liquid Parabolic","Chaos-Vibrato","Chaos Deep-Vibrato","Chaos Spacetime","Parabolic","Parabolic Chaos","Cubic-Diamond Chaos","C-Line","Contour Chaos","Spiderweb-Diamond","Acrylica","Refractive Space","Smooth-Artistry","Ferrofluid","Triangular Interweaving","Fabric Chaos","Reverse Tangent Division","Chaotic Tangent","Alternating Chaos 0","Alternating Chaos 1 [Legacy]","Alternating Chaos 2 [Legacy]","Alternating Chaos 3 [Legacy]","Alternating Chaos 4 [Legacy]","Alternating Chaos 5 [Legacy]","Alternating Chaos 1","Alternating Chaos 2","Alternating Chaos 3","Alternating Chaos 4","Alternating Chaos 5")
#@gui :Custom Formula=choice(0,"None","Custom Formula","Alternating Custom Formula Level 1","Alternating Custom Formula Level 2","Alternative Custom Formula Level 3","Alternating Custom Formula Level 4")
#@gui :_=separator()
#@gui :_=note("<b>Fractal Calculation Constraints</b>")
#@gui :_=note("<small>Information at bottom of filter. Some predefined formulas requires you to use low values. You may need to type in values from 5-1024 manually.</small>")
#@gui :Escape Value=int(10000,5,3000000)
#@gui :Loop Limitation=int(255,1,1024)
#@gui :Subsampling Level=float(3,1,10)
#@gui :_=separator(),_=note("<b>Distortion Factors</b>")
#@gui :Distortion X-[dx]=float(0,-50,50)
#@gui :Distortion Y-[dy]=float(0,-50,50)
#@gui :_=separator(),_=note("<b>Transformations</b>"),_=note("- Scaling -")
#@gui :Scaling XY-Axis=float(1,.1,15)
#@gui :Scaling X-Axis=float(1,.1,15)
#@gui :Scaling Y-Axis=float(1,.1,15)
#@gui :PI-Based Scaling=bool(1)
#@gui :_=separator(),_=note("- Displacement -")
#@gui :Offset X-Transformation=float(0,-5,5)
#@gui :Offset Y-Transformation=float(0,-5,5)
#@gui :_=separator(),_=note("- Rotation -")
#@gui :Function Angle=float(0,-180,180)
#@gui :_=separator(),_=note("<b>Custom Formula</b>)
#@gui :_=note("<small>See bottom of this filter to see instruction of usage</small>")
#@gui :Custom A-X-[vx]=text{a/sin(b)}
#@gui :Custom A-Y-[vy]=text{b/cos(a)}
#@gui :Custom B-X-[vx]=text{sin(a)/cos(b)}
#@gui :Custom B-Y-[vy]=text{b/cos(a)}
#@gui :Custom C-X-[vx]=text{a/sin(b)}
#@gui :Custom C-Y-[vy]=text{b/cos(a+b)}
#@gui :Custom D-X-[vx]=text{a}
#@gui :Custom D-Y-[vy]=text{b}
#@gui :Custom E-X-[vx]=text{a}
#@gui :Custom E-Y-[vy]=text{b}
#@gui :_=separator(), _=note("- Overload -")
#@gui :Activate Overload Functions=bool(0)
#@gui :Enable CFA/CFB* Formulas for OVX and OVY formulas?=bool(1)
#@gui :Overload X=text{a/(cfb*cos(b))}
#@gui :Overload Y=text{b/(cfa*sin(a))}
#@gui :CFA-[cfa]=text{cos(vx)/tan(vx)}
#@gui :CFB-[cfb]=text{sin(vy)/tan(vy)}
#@gui :Overload Count**=int(1,1,4)
#@gui :Use Negative Overload=bool(0)
#@gui :_=note("<small>*=cfa and cfb must be lowercase when using in overload formula!\n\n**=Negative Overload Count utilize last vector number rather than second last to find cfa,cfb.</small>")
#@gui :_=separator(),_=note("<b>Colour Setting</b>)
#@gui :Fractal Mapping=choice(0,"Grayscale","Hue","Random Color Map")
#@gui :Colours=int(3,3,8)
#@gui :Colour Generation Seed=int(0,0,5000)
#@gui :_=separator(),_=note("<b>Information of Thorn Fractal - Secant Sea filter</b>"),_=separator(), _=note("<i>Fractal Calculation Constraints</i>\n\n<b>Escape Value</b> defines the minimum value to escape from the loop used to determine the amount of iteration needed to be bigger than the specified value per pixels. The lower the value, the more contrast at a sacrifise of details.\n\n<b>Iterations</b> defines the maximum possible amount of loop per pixels when escape value is not reached. The lower the value, the more contrast and the more posterization of values.\n\n<b>Subsampling Level</b> is used to alter the dimensions before calculation of fractal, and it is resized to the original dimension after the fractal has been generated. The bigger the value, the more computationally intensive it is. In fact, this has the most consistent impact on performance."), _=separator(),_=note("<i>Custom Formula</i>\n\nTo use this, type in a formula utilizing the syntax given by the G'MIC reference manual. Use notes given the information provided below.\n\nMultiple expressions are supported, and they are separated by \";\" character. If it the only expression, then it would be used for calculation of vx or vy. Otherwise, the first expression may be the only one used for calculation of vx or vy.\n\n<i>Available variables - </i> v,vx,vy,dx,dy,a,b,cfa,cfb\n\n<b>v</b> - Iteration number within Thorn Fractal.\n\n<b>vx</b> - Output of distortion function for x-axis.\n\n<b>vy</b> - Output of distortion function for y-axis.\n\n<b>dx</b> - Distortion-X Number.\n\n<b>dy</b> - Distortion-Y Number.\n\n<b>a</b> - Value of <b>a</b> is given by vx equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.\n\n<b>b</b> - Value of <b>b</b> is given by vx equation based on the number of repeats needed to escape from the iterative loop to check when resulting value is greater than escape number.\n\n<b>cfa</b> - Output of <b>CFA</b> function. Useful if and only if using overload function.\n\n<b>cfb</b> - Output of <b>CFB</b> function. Useful if and only if using overload function.")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/6/13</i>.</small>")
gui_rep_tfrac:
srand $35
if !$2 rep_thorn_fractal $1,${3-14}
else
 if $2==1   formulas="$15","$16"
 elif $2==2 formulas="$15","$16","$17","$18"
 elif $2==3 formulas="$15","$16","$17","$18","$19","$20"
 elif $2==4 formulas="$15","$16","$17","$18","$19","$20","$21","$22"
 elif $2==5 formulas="$15","$16","$17","$18","$19","$20","$21","$22","$23","$24"
 fi
 if $25
  if $26 rep_thorn_fractal {-1*$2},${3-14},$formulas,"$27","$28","$29","$30",{$31*($32?-1:1)}
  else rep_thorn_fractal {-1*$2},${3-14},$formulas,"$27","$28",{$31*($32?-1:1)}
  fi
 else rep_thorn_fractal {-1*$2},${3-14},$formulas
 fi
fi
if $33==0 n 0,255
elif $33==1 n 0,360 r 100%,100%,100%,3 f [i0,1,1] hsv2rgb
else n 0,1 $34,1,1,1 f. u(x/w#-1,(x+1)/w#-1) n. 0,16777215 r. 100%,100%,1,3 f. [i0-256*floor(i0/256),floor(i0/256)-256*floor(floor(i0/256)/256),i0/(256^2)] r. 4096,1,100%,100%,5 r[^-1] 100%,100%,100%,3 f[^-1] i(#-1,i0*w#-1,0,z,c,2) rm.
fi
gui_rep_tfrac_preview:
gui_rep_tfrac ${1-14},"$15","$16","$17","$18","$19","$20","$21","$22","$23","$24",$25,$26,"$27","$28","$29","$30",${31-35}

set_a={$2>=1?2:0}
set_b={$2>=2?2:0}
set_c={$2>=3?2:0}
set_d={$2>=4?2:0}
set_e={$2>=5?2:0}
set_f={$2?($25&&abs($31)?2:1)}
set_g={$2?($26&&abs($31)?($25?2:1):1)}
set_h={$2?($25?2:1)}
set_i={$33==2?2:0}

u "{$1}_"{!$2?2:1}\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}"\
"{$15}_"$set_a\
"{$16}_"$set_a\
"{$17}_"$set_b\
"{$18}_"$set_b\
"{$19}_"$set_c\
"{$20}_"$set_c\
"{$21}_"$set_d\
"{$22}_"$set_d\
"{$23}_"$set_e\
"{$24}_"$set_e\
"{$25}_"{$2?2}\
"{$26}_"$set_f\
"{$27}_"$set_f\
"{$28}_"$set_f\
"{$29}_"$set_g\
"{$30}_"$set_g\
"{$31}_"$set_h\
"{$32}_"$set_h\
"{$33}"\
"{$34}_"$set_i\
"{$35}_"$set_i
#@gui _<b>Testing</b>
#@gui <i>Reptorian</i>

#@gui Z-Time:rep_z_render
#@gui :_=note("Z-Time Rendering is a filter that utilize the value of a layer to represent the frame where frames are interpolated and normalized to the value of that layer. In other word, the reference layer can be seen as a representative of time.<b>Note:</b>Try to use a gradient for top or bottom layer depending on option you use.\n\n<b>Z-Depth Values</b> is recommended to be altered when using float image as reference. Use values less than 255 in order to posterize.\n\n<b>This filter do not work with Paint.NET as you need 3 images!</b>"), _=separator()
#@gui :Layer to use as time reference?=choice(0,"Top Layer","Bottom Layer")
#@gui :Z-Depth Values=int(255,3,1024)
#@gui :Mirror Frame Ordering?=bool(0)
#@gui :Separate time by channels?=bool(0)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/10/13</i>.</small>")
#@gui Bricks: gui_rep_shape_brick
#@gui :_=note("This filter on the <a href="https://forums.getpaint.net/topic/8251-bricks-updated-with-examples/">Bricks plugin for Paint.NET</a> made by <a href="https://forums.getpaint.net/profile/49909-jchunn/">Jesse Chunn</a> as part of his <a href="https://forums.getpaint.net/index.php?/topic/8408-jesse-chunn-plugin-pack-march-8-2008/">plugin pack</a>.\n\n This is a extended version of the bricks filter with bevel options, and blending mode option.")
#@gui :_=separator(),_=note("<b>Brick Main Setting</b>")
#@gui :Brick Width (px)=int(150,4,2048)
#@gui :Brick Height (px)=int(150,4,2048)
#@gui :Mortar Width (px)=int(5,0,512)
#@gui :Mortar Height (px)=int(5,0,512)
#@gui :Outline (px)=int(0,0,50)
#@gui :_=separator(),_=note("<b>Offset Setting</b>)
#@gui :Brick Offset (%)=float(0,-100,100)
#@gui :Offset Direction=choice(0,"Horizontal","Vertical")
#@gui :Reverse Offset=bool(0)
#@gui :_=separator(),_=note("<b>Bevel Setting</b>)
#@gui :Bevel Radius (px)=int(0,0,50)
#@gui :Bevel Style=choice(0,"Round","Inverse Round","Chamfer")
#@gui :_=separator(),_=note("<b>Colouring and Blending Options</b>")
#@gui :Brick Colour=color(170,0,0,255)
#@gui :Brick Outline=color(85,0,0,255)
#@gui :Mortar Colour=color(121,77,2,255)
#@gui :Use Blending Mode?=bool(0)
#@gui :Blending Mode=choice(41,"add","alpha","and","average","blue","burn","darken",
#@gui :"difference","divide","dodge","exclusion","freeze",
#@gui :"grainextract","grainmerge","green","hardlight","hardmix",
#@gui :"hue","interpolation","lighten","lightness","linearburn",
#@gui :"linearlight","luminance","multiply","negation","or",
#@gui :"overlay","pinlight","red","reflect","saturation","screen",
#@gui :"shapeaverage","softburn","softdodge","softlight","stamp",
#@gui :"subtract","value","vividlight","xor")
#@gui :Opacity (%)=float(100,0,100)
#@gui :_=separator(),_=note("<b>Antialias</b>)
#@gui :Antialias Level=float(0,0,3)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/10/15</i>.</small>")
gui_rep_shape_brick:
-m "MergeChoice : $""=_mode" -MergeChoice "add","alpha","and","average","blue","burn","darken","difference","divide","dodge","exclusion","freeze","grainextract","grainmerge","green","hardlight","hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance","multiply","negation","or","overlay","pinlight","red","reflect","saturation","screen","shapeaverage","softburn","softdodge","softlight","stamp","subtract","value","vividlight","xor","edges","error"
repeat $! l[$>]
to_a
rep_shape_brick $1,$2,$3,$4,$5,$9,$10,$6%,$7,$8,$26
n. 0,1
r. {w#-2},{h#-2},100%,{s#-2},0,2,0,0
if $5 ($19,$15,$11^$20,$16,$12^$21,$17,$13^$22,$18,$14)
else ($19,$11^$20,$12^$21,$13^$22,$14)
fi
r. {($26+1)*100}%,100%,100%,100%,3
f.. i(#-1,(w#-1-1)*i,0,z,c,3) rm.
if $23 blend ${_mode{$24+1}},{$25%}
else k. fi
endl done
#@gui TR's Intense Filtration:gui_rep_trif,gui_rep_trif_preview(0)
#@gui :Hue=float(45,0,360)
#@gui :Image Coefficient (%)=float(100,0,200)
#@gui :Mix Factor (%)=float(0,0,100)
#@gui :Style Base=choice(0,"Based from Original Image","Based on Grayscale","Based on Hue")
#@gui :_=separator(),_=note("<b>Preview Setting</b>"), Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<b>TR's Intense Filtration</b> is a filter that filters out colors and augment a color based on hue. The formula for the filter is created by <b>TechnoRobbo</b>. The code for this filter is based on the <a href="https://forums.getpaint.net/topic/30148-trs-intense-filtration-v-13-oct-092014/">source code</a> of <b>TechnoRobbo's Intense Filtration v1.3</b> plugin for <b>Paint.NET.</b>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/11/1</i>.</small>")
gui_rep_trif: rep_trif $1,$2%,$3%,$4
gui_rep_trif_preview: gui_split_preview "gui_rep_trif ${1-4}",${-3--1}
#@gui TR's Pixel Sharpener: gui_rep_trps,gui_rep_trps_preview(0)
#@gui :Sharpening=float(0,0,50)
#@gui :Internal Blurring=int(0,0,4)
#@gui :Blur Type=choice(0,"Photo","Horizontal","Vertical","Angle - One Axis","Angle - Two Axis","Angle - Two Axis [Disconnected]")
#@gui :Angle= float(0,-180,180)
#@gui :Angle 2= float(0,-180,180)
#@gui :Channel(s)=choice(11,"All","RGBA [All]","RGB [All]","RGB [Red]","RGB [Green]","RGB [Blue]","RGBA [Alpha]",
#@gui :"Linear RGB [All]","Linear RGB [Red]","Linear RGB [Green]","Linear RGB [Blue]","YCbCr [Luminance]",
#@gui :"YCbCr [Blue-Red Chrominances]","YCbCr [Blue Chrominance]","YCbCr [Red Chrominance]",
#@gui :"YCbCr [Green Chrominance]","Lab [Lightness]","Lab [ab-Chrominances]","Lab [a-Chrominance]",
#@gui :"Lab [b-Chrominance]","Lch [ch-Chrominances]","Lch [c-Chrominance]","Lch [h-Chrominance]","HSV [Hue]",
#@gui :"HSV [Saturation]","HSV [Value]","HSI [Intensity]","HSL [Lightness]","CMYK [Cyan]","CMYK [Magenta]",
#@gui :"CMYK [Yellow]","CMYK [Key]","YIQ [Luma]","YIQ [Chromas]","RYB [All]","RYB [Red]","RYB [Yellow]","RYB [Blue]")
#@gui :_=separator(),_=note("This is a extended filter which was based on a Paint.NET plugin that was created by <b>TechnoRobbo</b> - <a href="https://forums.getpaint.net/topic/26783-trs-pixel-sharpener-plugin-v20-dec-21-2014/">TR's Pixel Sharpener</a>")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/11/2</i>.</small>")
gui_rep_trps: ac "rep_tr_pixel_sharpener ${1-5}",$6
gui_rep_trps_preview: gui_split_preview "gui_rep_trps ${1-6}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{$3>2?2:0}\
"{$5}_"{$3>4?2:0}\
"{$6}"\
"{$7}"\
"{$8}"
#@gui Glass Vignette:gui_rep_gv, gui_rep_gv_preview(0)
#@gui :_=note("<small>Distorts images as if it is based from the view of a bulged car mirror or camera len. This G'MIC filter is a heavily extended version of <a href="https://forums.getpaint.net/topic/28355-trs-glass-vignette/">TR's Glass Vignette</a> plugin made by TechnoRobbo for Paint.NET. It can also be used for generating abstract art as well.</small>"), _=separator()
#@gui :_=note("<b>Refraction Settings</b>")
#@gui :Refraction (%)=float(100,-200,200)
#@gui :Refraction Power (%)=float(0,-200,200)
#@gui :Len Size (%)=float(100,25,200)
#@gui :Chromatic Aberration (%)=float(0,-100,100)
#@gui :_=separator(),_=note("<b>Transformations Settings</b>")
#@gui :_=note("<small><i>Preliminary Image Transformations</i></small>")
#@gui :Preliminary Image Shift=point(50,50,0,1,128,128,128,255)
#@gui :Image Additional Zoom (%)=float(0,0,500)
#@gui :Image Angle=float(0,-180,180)
#@gui :_=separator(),_=note("<small><i>Distortion Transformations</i></small>")
#@gui :Distortion Scale by X-Axis (%)=float(100,0,1000)
#@gui :Distortion Scale by Y-Axis (%)=float(100,0,1000)
#@gui :Distortion Scale by XY-Axis (%)=float(100,0.01,500)
#@gui :Distortion Angle=float(0,-180,180)
#@gui :Distortion Offset=point(50,50,0,1,255,255,255,255)
#@gui :_=note("<small><i>When Distortion Scale by X-Axis and/or Y-Axis is 0, then distortion will be based on image ratio.</i></small>")
#@gui :_=separator(),_=note("<b>Processing Settings</b>")
#@gui :Colour Space=choice(0,"RGB","sRGB","RYB","CMY","CMYK",HCY",HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui :Boundary=choice(3,"None","Neumann","Periodic","Mirror")
#@gui :Interpolation=choice(5,"Nearest","Average","Linear","Grid","Bicubic","Lanczos")
#@gui :Subpixel=float(1,0,2)
#@gui :_=separator(),_=note("<b>Preview Settings</b>"), Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/04/06</i>.</small>")
gui_rep_gv: rep_gv $1%,$2%,$3%,$4%,{$5-50}%,{$6-50}%,$7%,$8,$9%,$10%,$11%,$12,{$13+50}%,{$14+50}%,$18,${15-17}
gui_rep_gv_preview: gui_split_preview "gui_rep_gv ${1-18}",${-3--1}
#@gui Fibonacci: fx_rep_fibonacci,fx_rep_fibonacci
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :Fill Mode=choice(1,"Textile","Fill")
#@gui :Iterations=int(10,3,20)
#@gui :Direction=choice(0,"Top Left","Top Right","Bottom Left","Bottom Right")
#@gui :Fibonacci Style=choice(0,"Corner","Spiral")
#@gui :Initial Orientation=choice(0,"Landscape","Portrait")
#@gui :Center - Point=point(50,50)
#@gui :Boundary=choice(0,"Periodic","Mirror")
#@gui :Attachment=choice(0,"A","B")
#@gui :Integer Scale=int(1,1,10)
#@gui :_=separator(),_=note("<b>Coloring/Shading</b>")
#@gui :Palette=choice(0,"Normalized Grayscale","BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Cycle Color(%)=float(0,0,100)
#@gui :Color Random Ordering Seed=int(2500,0,5000)
#@gui :Color Random Ordering Seed A=int(100,0,5000)
#@gui :Color Random Ordering Seed B=int(500,0,5000)
#@gui :Negate?=bool(0)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/09/22</i>.</small>")
fx_rep_fibonacci:
if $1
 if $11
  pal {$11-1}
  rep_fibonacci_fill[^-1] ${3-5},0,$10,{($6-50)/100*2},{($7-50)/100*2},$12%,$16,[-1],$13
  rm.
 else
  rep_fibonacci_fill ${3-5},0,$10,{($6-50)/100*2},{($7-50)/100*2},$12%,$16
  n 0,255
 fi
else
 if $11
  pal {$11-1}
  rep_fibonacci_fill[^-1] ${3-5},$2,$10,$8,$9,$12%,$16,[-1],$14,$15
  rm.
 else
  rep_fibonacci_fill ${3-5},$2,$10,$8,$9,$12%,$16
  n 0,255
 fi
fi
u "{$1}"\
"{$2}_"{$1?0:2}\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6,$7}_"{$1?($4?2:0):0}\
"{$8}_"{$1?0:2}\
"{$9}_"{$1?0:2}\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}_"{$1?($11?2:1):0}\
"{$14}_"{$1?0:($11?2:1)}\
"{$15}_"{$1?0:($11?2:1)}\
"{$16}"
#@gui Spiral Distortion:gui_rep_sd,gui_rep_sd_preview(0)
#@gui :_=note("Transform image using spiral gradient for x-coordinate, and radial gradient for y-coordinate."),_=separator()
#@gui :Revolution=float(1,.1,10)
#@gui :Spiral Height=float(1,.5,10)
#@gui :Refraction Power=float(0,-.99,2)
#@gui :Direction=choice(0,"Clockwise","Counterclockwise")
#@gui :Angle=float(0,-180,180)
#@gui :Spiral Mode=choice(0,"Periodic","Continuous")
#@gui :Preshift Position=point(50,50,0,1,200,200,200,255)
#@gui :Preshift Boundary=choice(0,"Periodic","Mirror")
#@gui :Skew Position (%)=point(50,50,0,1,100,100,100,255)
#@gui :Skew Multiplier=float(1,-.5,3)
#@gui :Offset (%)=point(50,50,0,1,255,255,255,255)
#@gui :Scale X-Coordinate (%)=float(100,1,1000)
#@gui :Scale Y-Coordinate (%)=float(100,1,1000)
#@gui :Boundary Condition=choice(3,"None","Neumann","Periodic","Mirror")
#@gui :Interpolation=choice(4,"Nearest","Average","Linear","Bicubic","Lanczos")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/10/15</i>.</small>")
gui_rep_sd: rep_sd ${1-6},{($7-50)*2}%,{($8-50)*2}%,$9,{($10-50)*2}%,{($11-50)*-2}%,$12,{($15-50)*2}%,{($16-50)*2}%,{($13-50)*2}%,{($14-50)*2}%,$17,$18
gui_rep_sd_preview: gui_split_preview "gui_rep_sd ${1-18}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}_"{(($7!=50)||($8!=50))?2:1}\
"{$10,$11}"\
"{$12}_"{($10!=50)||($11!=50)?2:1}\
"{$13,$14}"\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18}"\
"{$19}"\
"{$20,21}"
#@gui Perspective Streak:gui_rep_perspective_streak,gui_rep_perspective_streak_preview(0)
#@gui :_=note("Creates streak effect toward vanishing point. Read notes below the filter option for more instructions.\n\n<b>Warning - </b> This is a computationally intensive filter.\n\n<small><b>Note - </b>Future versions may come with easier way to utilize this filter.</small>"),_=separator(),_=note("<b>Main</b>")
#@gui :Vanishing Point (%)=point(50,50,0,1,128,128,128,255)
#@gui :Alpha Exponential Factor (%)=float(0,-100,500)
#@gui :Distance Threshold (%)=float(100,.1,100)
#@gui :Distance Start (%)=float(0,0,99.99)
#@gui :Streak Direction=choice(0,"Inside","Outside")
#@gui :_=separator(),_=note("<b>Info Output</b>")
#@gui :Streak Mode=choice(0,"Color","Grayscale","Binary","Grayscale+Binary")
#@gui :Preserve Edges=bool(1)
#@gui :_=note("<small>Preserve Edges are not available on binary mode.</small>")
#@gui :_=separator(),_=note("<b>Preview</b>")Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<b>- Instruction Notes-</b>\n\n<small><b>Note 1 - </b>To effectively use this filter, experiment using <b>Secondary Settings</b> on <u>multiple copies of original image[s]</u>.\n\n<b>Note 2 - </b>Use blending modes.\n\n<b>Note 3 - </b>If your software supports alpha inheritance, use that to advantage.</small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/8</i>.</small>")
gui_rep_perspective_streak:
px={(($1-50)*2)/100}
py={(($2-50)*-2)/100}
if $px<-1 px=-1
elif $px>1 px=1
fi
if $py<-1 px=-1
elif $py>1 px=1
fi
rep_pstrk $px,$py,$3%,$4%,$5%,$6,$7,$8,255
if $7 * 255 fi
gui_rep_perspective_streak_preview:
gui_split_preview "gui_rep_perspective_streak ${1-8}",${-3--1}
u "{$1,$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}_"{$7!=2?2:1}\
"{$9,$10}"\
"{$11}"
#@gui Axis Streak:gui_axis_streak,gui_axis_streak_preview
#@gui :_=note("Streaks pixel taking into account of opacity by blending pixels-by-pixels."),_=separator()
#@gui :Orientation=choice(0,"Horizontal","Vertical")
#@gui :Direction=choice(0,"Left","Right")
#@gui :Direction=choice(0,"Up","Down")
#@gui :Alpha Exponential Factor(%)=float(0,-100,500)
#@gui :_=separator(),_=note("<b>Preview</b>")Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/7</i>.</small>")
gui_axis_streak:
if $1 rep_axis_streak $1,!$3,$4%,255
else rep_axis_streak $1,$2,$4%,255
fi
gui_axis_streak_preview:
gui_split_preview "gui_axis_streak ${1-4}",${-3--1}
u "{$1}"\
"{$2}"_{$1?0:2}\
"{$3}"_{$1?2:0}\
"{$4}"\
"{$5,$6}"\
"{$7}"
#@gui Majority:gui_rep_majority,gui_rep_majority_preview
#@gui :_=separator(),_=note("<b>Filter Options</b>")
#@gui :Color Space=choice(11,"RGB","sRGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui :Contain Alpha=bool(0)
#@gui :Kernel Size=int(5,2,50)
#@gui :Mode=choice(0,"Soft Regular","Soft Average Channels","Hard Regular,"Hard Average Channels")
#@gui :Convert to Black and White?=bool(0)
#@gui :_=separator(),_=note("<b>Preview Setting</b>"), Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<b>Info about filter</b>\n\n<small>Majority effects comes in one of those two version.\n\n1- Use a predefined value to take either the value of the min/max values within kernel.\n\n2-Automatically let the average of kernel to define which values to take which can be either min/max value within kernel.</small>"),_=separator(),_=note("<small>More information - <a href="https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/">Paint.NET Majority Effect</a></small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/31</i>.</small>")
gui_rep_majority:
rep_major $3,$4,$1,$2
if $5 to_graya fi
gui_rep_majority_preview:
gui_split_preview "gui_rep_majority ${1-5}",${-3--1}
#@gui Majority [Threshold]:gui_rep_majority_threshold,gui_rep_majority_threshold_preview
#@gui :_=separator(),_=note("<b>Filter Options</b>")
#@gui :Color Space=choice(11,"RGB","sRGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YIQ","YUV","YCbCr","YCbCrGLIC","XYZ","YES","Kodak 1","Ohta")
#@gui :Contain Alpha=bool(0)
#@gui :Kernel Size=int(5,2,50)
#@gui :Tolerance (%)=float(50,0,100)
#@gui :Conditional Mode=choice(1,"Less Than","Greater Than")
#@gui :Output Mode=choice(0,"Soft","Hard")
#@gui :Convert to Black and White?=bool(0)
#@gui :_=separator(),_=note("<b>Preview Setting</b>"), Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<b>Info about filter</b>\n\n<small>Majority effects comes in one of those two version.\n\n1- Use a predefined value to take either the value of the min/max values within kernel.\n\n2-Automatically let the average of kernel to define which values to take which can be either min/max value within kernel.</small>"),_=separator(),_=note("<small>More information - <a href="https://forums.getpaint.net/topic/3978-majority-color-effect-ymd100726/">Paint.NET Majority Effect</a></small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2019/12/31</i>.</small>")
gui_rep_majority_threshold:
rep_major_t $3,$4%,$5,$6,$1,$2
if $7 to_graya fi
gui_rep_majority_threshold_preview:
gui_split_preview "gui_rep_majority_threshold ${1-7}",${-3--1}
#@gui Newton Fractal [MadJik Style]:rep_mj_newf,rep_mj_newf
#@gui :_=note("<b>Warning-</b> Filter is very hard to control!Also,filter is computationally intensive!\n\nMight be solved later."),_=separator()
#@gui :Zoom=float(16,1,1000000)
#@gui :X-Pan=float(0,-10000,10000)
#@gui :Y-Pan=float(0,-10000,10000)
#@gui :Color Range=float(128,0,255)
#@gui :Factor A=float(9,-100,100)
#@gui :Factor B=float(0,-100,100)
#@gui :Factor C=float(75,-100,100)
#@gui :Factor D=float(5,-100,100)
#@gui :Exponent=float(10,0,17)
#@gui :Depth=float(50,1,500)
#@gui :Background Frequency=float(50,1,500)
#@gui :Color Angle=float(45,-180,180)
#@gui :Alternate Color Function=bool(0)
#@gui :Symmetry=bool(0)
#@gui :Channel Swap=bool(0)
#@gui :_=separator(),_=note("<small>Original Code made by MadJik - <a href="https://forums.getpaint.net/topic/111758-newton-fractal-texture-ymd-170915/">Newton Fractal texture (ymd 170915)</a></small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/1/2</i>.</small>")
#@gui Graduated Filter: fx_rep_graduated_filter,fx_rep_graduated_filter_preview(0)
#@gui :Strength (%)=float(50,0,100)
#@gui :Luminosity Filtering Strength (%)=float(100,0,100)
#@gui :Placement (%)=float(50,0,100)
#@gui :Filtering Angle=float(0,-180,180)
#@gui :Graduated Filter Color=color(0,0,0)
#@gui :_=separator(),Preview type=choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/1/4</i>.</small>")
fx_rep_graduated_filter: rep_graduated_filter $1%,$2%,$3%,$4,,${5-7}
fx_rep_graduated_filter_preview: gui_split_preview "fx_rep_graduated_filter ${1-7}",${-3--1}
#@gui Rectangle-Square Fill:fx_rep_rand_sqrrecfill,fx_rep_rand_sqrrecfill
#@gui :_=note("<b>Main</b>")
#@gui :1.Palette=choice(0,"None","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :2.Use Random Color Instead?=bool(0)
#@gui :3.Square Size=int(15,2,150)
#@gui :4.Max Primary Dimension of Rectangle=int(2,1,10)
#@gui :5.Max Secondary Dimension of Rectangle=int(1,1,10)
#@gui :6.Frequency of Rectangle=float(1,0,1)
#@gui :7.Line Erosion=int(0,-15,15)
#@gui :8.Line Output=bool(1)
#@gui :9.Reduce Non-Rectangular Shape=bool(1)
#@gui :10.Remove Black from Palette?=bool(1)
#@gui :Seed=int(0,0,50000)
#@gui :Colour Space=choice(0,"RGB-8","RYB-8","HSI-8","HSL-8","HSV-8","LAB-8","LCH-8","YIQ-8","YUV-8")
#@gui :_=separator(),_=note("<b>Extra</b>")
#@gui :Output Mode=choice(0,"Clipped","Enlarged","Shrinked")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/1/8</i>.</small>")
fx_rep_rand_sqrrecfill:
ww={w}
hh={h}
if $-1!=1
 square_size=$3
 if $8
  if abs($7)
   if $7>0 square_size+={abs($5)}
   else square_size+=1
   fi
  fi
 fi
 rw={w-$square_size*2}
 rh={h-$square_size*2}
 nw={floor($rw/($square_size*($8?(($3+1)/$3):1)))*$square_size}
 nh={floor($rh/($square_size*($8?(($3+1)/$3):1)))*$square_size}
 if $-1==2 r $nw,$nh,100%,100% fi
fi

if $2 rep_rand_sqrrecfill -1,${3--2}
else
 rep_rand_sqrrecfill $1,${3--3}
 if $1==0 n. 0,255 fi
fi

if $-1!=1 if $-1==2 f. 255-i fi r. $ww,$hh,100%,100%,0,0,.5,.5 if $-1==2 f. 255-i fi fi
k.
u "{$1}_"{$2?1:2}\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}_"{(($1==0&&$2==0)?0:$8)?2:1}\
"{$8}_"{$1==0&&$2==0?1:2}\
"{$9}"\
"{$10}"_{!($1==0&&$2!=1)?2:1}\
"{$11}"\
"{$12}_"{$2?2:1}\
"{$13}"
#@gui Point Warp:gui_rep_pw,gui_rep_pw_preview(0)
#@gui :Point Width=float(100,0,100)
#@gui :Distance=float(100,0,100)
#@gui :Radial Influence=float(0,0,100)
#@gui :Placement of Distortion=point(50,50,0,1,128,128,128,255)
#@gui :Distortion Angle=float(0,-180,180)
#@gui :Boundary Condition=choice(3,"None","Neumann","Periodic","Mirror")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>This is a modified code of a conversion of Illab2014's Paint.NET plugin named <a href="https://forums.getpaint.net/topic/32180-point-warp-engorged-smudge-aug-20-2015/">Point Warp</a>. The difference between this and Illab2014's filter is that this one takes into account of image size and contains boundary conditions.</small>")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/2/26</i>.</small>")
gui_rep_pw:
rep_pw $1%,$2%,$3%,{($4/100-.5)*2},{($5/100-.5)*-2},$6,$7
gui_rep_pw_preview:
gui_split_preview "gui_rep_pw ${1-7}",${-3--1}
#@gui Prime Surface:gui_rep_prime_surface
#@gui :Negate Direction?=bool(0)
#@gui :Mirror Direction=choice(0,"None","X","Y")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/2/26</i>.</small>")
gui_rep_prime_surface:
rep_prime_surface {w},{h},$1,$2 k. n 0,255
#@gui Pixel Push:fx_rep_pxpush,fx_pxpush_preview(0)
#@gui :Push Point=point(50,50,0,1,255,255,255,255)
#@gui :_=separator(),_=note("Recreation of filter from source code to TR's Pixel Push plugin for Paint.NET.Currently only Bezier option is supported until the secondary option is figured out.")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/2/26</i>.</small>")
fx_rep_pxpush: rep_pxpush {($1/100-.5)*2},{($2/100-.5)*2}
fx_pxpush_preview: gui_split_preview "fx_rep_pxpush $*",${-3--1}
#@gui Rotate by Torus Map:fx_rep_rbtt,fx_rep_rbtt_preview(0)
#@gui :_=note("<b>Main</b>")
#@gui :Circumference A (%)=float(100,0,100)
#@gui :Circumference B (%)=float(50,0,100)
#@gui :_=separator()_=note("<b>Distortion</b>")
#@gui :Distortion Angle=float(-180,-720,720)
#@gui :Distortion Mode=choice(3,"Soft","Medium","Hard","Alternative Hard","Distroy","Inverse-Distroy","Quad Extrude","Hexagonal Extrude")
#@gui :Distortion Mode A=choice(3,"Soft","Medium","Hard","Alternative Hard","Distroy","Inverse-Distroy","Quad Extrude","Hexagonal Extrude")
#@gui :Distortion Mode B=choice(7,"Soft","Medium","Hard","Alternative Hard","Distroy","Inverse-Distroy","Quad Extrude","Hexagonal Extrude")
#@gui :Distortion Mode Blending (%)=float(50,0,100)
#@gui :Enable Distortion Mode Blending=bool(1)
#@gui :Distortion Position=point(50,50,0,1,255,255,255,255)
#@gui :Wraparound Distortion?=bool(1)
#@gui :_=separator(),_=note("<b>Additional</b>")
#@gui :Remove Background?=bool(0)
#@gui :Activate Isolated Torus Mode?=bool(0)
#@gui :_=separator(),_=note("<b>Rendering</b>")
#@gui :Interpolation=choice(1,"None","Linear")
#@gui :Boundary Condition=choice(2,"None","Neumann","Periodic","Mirror")
#@gui :_=separator(),_=note("<b>Preview</b>"), Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<b>Information</b>\n"),_=note("This filter is inspired by <a href="https://forums.getpaint.net/topic/23400-donut-distortion-effect-plugin/">Donut Distortion Paint.NET plugin</a> by <a href="https://forums.getpaint.net/profile/45895-madjik/">MadJik</a>.\n\n This G'MIC version includes additional modes,wraparound mode, and special mode which isolates the distortion.")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/11/08</i>.</small>")
fx_rep_rbtt:
to_a
if $8 rep_rbtt {$1/100},{$2/100},$3,$5,$6,{$7/100},{($9/100-.5)*2},{($10/100-.5)*-2},$11,$12,$13,$14,$15
else  rep_rbtt {$1/100},{$2/100},$3,$4,,,{($9/100-.5)*2},{($10/100-.5)*-2},$11,$12,$13,$14,$15
fi
fx_rep_rbtt_preview: gui_split_preview "fx_rep_rbtt ${1-13},{$14*-1},$15",${-3--1}
a={$8?2:1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{!$8?2:1}\
"{$5}_"$a\
"{$6}_"$a\
"{$7}_"$a\
"{$8}"\
"{$9,$10}"\
"{$11}"\
"{$12}"\
"{$13}_"{$12?2:1}\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17,$18}"
#@gui RGB-Gray Linear Interpolation:fx_rep_lerp_rgb_gray,fx_rep_lerp_rgb_gray_preview(0)
#@gui :_=note("<b>Formula</b>")
#@gui :Mode=choice(0,"Luminosity A","Luminosity B","Lightness","Minimum","Maximum","Average",Weighted")
#@gui :Limit Factor to 100%=bool(0)
#@gui :_=separator(),_=note("<b>Channel Factor</b>")
#@gui :Red Factor (%)=float(100,0,150)
#@gui :Green Factor (%)=float(100,0,150)
#@gui :Blue Factor (%)=float(100,0,150)
#@gui :Red Factor (%)=float(100,0,100)
#@gui :Green Factor (%)=float(100,0,100)
#@gui :Blue Factor (%)=float(100,0,100)
#@gui :Red Weight=float(1,0,1)
#@gui :Green Weight=float(1,0,1)
#@gui :Blue Weight=float(1,0,1)
#@gui :_=separator(),_=note("<b>Preview</b>"),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/14/3</i>.</small>")
fx_rep_lerp_rgb_gray:
if $1==6
 if $2 rep_lerp_rgb_gray $6%,$7%,$8%,${9-11}
 else  rep_lerp_rgb_gray $3%,$4%,$5%,${9-11}
 fi
else
 if $2 rep_lerp_rgb_gray $6%,$7%,$8%,$1
 else  rep_lerp_rgb_gray $3%,$4%,$5%,$1
 fi
fi
fx_rep_lerp_rgb_gray_preview:
if $2 r1,g1,b1,r2,g2,b2={[$6<100?$6:$3,$7<100?$7:$4,$8<100?$8:$5,$6,$7,$8]}
else r1,g1,b1,r2,g2,b2={[$3,$4,$5,$3,$4,$5]}
fi
gui_split_preview "fx_rep_lerp_rgb_gray ${1-11}",${-3--1}

a={$2?0:2}
b={$2?2:0}
c={$1==6?2:0}

u "{$1}"\
"{$2}"\
"{"$r1"}_"$a\
"{"$g1"}_"$a\
"{"$b1"}_"$a\
"{"$r2"}_"$b\
"{"$g2"}_"$b\
"{"$b2"}_"$b\
"{$9}_"$c\
"{$10}_"$c\
"{$11}_"$c\
"{$12}"\
"{$13,$14}"
#@gui Trigonometry Mapping: fx_rep_tg3,fx_rep_tg3_preview(0)
#@gui :_=note("<b>Processing</b>)
#@gui :Colour Space=choice(0,"RGB-8","RYB-8","CMY-8","HSI-8","HSL-8","HSV-8","LAB-8","LCH-8","YIQ-8","YUV-8","XYZ-8","YES-8","OHTA-8","Kodak 1-8")
#@gui :Mode=choice(0,"Direct Trig-3","Luminosity to Trig-3")
#@gui :Preserve Luminosity=bool(1),_=separator()
#@gui :_=note("<b>Mapping</b>)
#@gui :Channel Order=choice(0,"First-Second-Third","First-Third-Second","Second-First-Third","Second-Third-First","Third-First-Second","Third-Second-Third")
#@gui :Channel=choice(0,"First","Second","Third")
#@gui :Channel=choice(0,"First","Third","Second")
#@gui :Channel=choice(0,"Second","First","Third")
#@gui :Channel=choice(0,"Second","Third","First")
#@gui :Channel=choice(0,"Third","First","Second")
#@gui :Channel=choice(0,"Third","Second","First")
#@gui :Formula=choice(0,"Sinusoidal","Cosinusodial","Cubic Sinusoidal","Cubic Cosinusodial","Cubic Sinusoidal-Cosinusodial")
#@gui :Multiplier=float(1,.1,5)
#@gui :Value Shift=float(0,-1,1)
#@gui :Midgray Exponential Factor=float(1,.01,2)
#@gui :Lightness Merge Factor=float(1,0,1)
#@gui :Lightness Exponential Factor=float(1,.01,5)
#@gui :End Value to Base Factor=float(1,0,1)
#@gui :Formula=choice(0,"Sinusoidal","Cosinusodial","Cubic Sinusoidal","Cubic Cosinusodial","Cubic Sinusoidal-Cosinusodial")
#@gui :Multiplier=float(1,.1,5)
#@gui :Value Shift=float(0,-1,1)
#@gui :Midgray Exponential Factor=float(1,.01,2)
#@gui :Lightness Merge Factor=float(1,0,1)
#@gui :Lightness Exponential Factor=float(1,.01,5)
#@gui :End Value to Base Factor=float(1,0,1)
#@gui :Formula=choice(0,"Sinusoidal","Cosinusodial","Cubic Sinusoidal","Cubic Cosinusodial","Cubic Sinusoidal-Cosinusodial")
#@gui :Multiplier=float(1,.1,5)
#@gui :Value Shift=float(0,-1,1)
#@gui :Midgray Exponential Factor=float(1,.01,2)
#@gui :Lightness Merge Factor=float(1,0,1)
#@gui :Lightness Exponential Factor=float(1,.01,5)
#@gui :End Value to Base Factor=float(1,0,1)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2020/8/9</i>.</small>")
fx_rep_tg3:
if $1
 convert_colors_fwd=${arg\ $1,rgb2ryb,rgb2cmy,rgb2hsi8,rgb2hsl8,rgb2hsv8,rgb2lab8,rgb2lch8,rgb2yiq8,rgb2yuv8,rgb2xyz8,rgb2yes8,rgb2ohta8,rgb2k18}
 convert_colors_bwd=${arg\ $1,ryb2rgb,cmy2rgb,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,yiq82rgb,yuv82rgb,xyz82rgb,yes82rgb,ohta82rgb,k182rgb}
fi
repeat $! l[$>]
 if s==4 s c,-3 +store.. color store. alpha contain_alpha=1
 elif s<2 continue
 else +store color contain_alpha=0
 fi

 sh. 0,2
 if $1 $convert_colors_fwd. fi

 if $2 rep_tg3. 8il,$4,${11-31}
 else  rep_tg3. 8i,$4,${11-31}
 fi

 if $1 $convert_colors_bwd. fi

 cut. 0,255
 rm.

 if $3 $color blend luminance fi
 if $contain_alpha $alpha a c fi
endl done
fx_rep_tg3_preview:

cc1,cc2,cc3,cc4,cc5,cc6=$5,$6,$7,$8,$9,$10
cc=[$cc1,$cc2,$cc3,$cc4,$cc5,$cc6]
cc={($cc)[$4]}
cc1,cc2,cc3,cc4,cc5,cc6={[$cc,$cc,$cc,$cc,$cc,$cc]}

gui_split_preview "fx_rep_tg3 ${1-31}",${-3--1}

a={((($4==0&&$5==0)||($4==1&&$6==0))||(($4==2&&$7==0)||($4==3&&$8==0)))||(($4==4&&$9==0)||($4==5&&$10==0))?2:0}
b={((($4==0&&$5==1)||($4==1&&$6==1))||(($4==2&&$7==1)||($4==3&&$8==1)))||(($4==4&&$9==1)||($4==5&&$10==1))?2:0}
c={((($4==0&&$5==2)||($4==1&&$6==2))||(($4==2&&$7==2)||($4==3&&$8==2)))||(($4==4&&$9==2)||($4==5&&$10==2))?2:0}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{"$cc1"}_"{$4==0?2:0}\
"{"$cc2"}_"{$4==1?2:0}\
"{"$cc3"}_"{$4==2?2:0}\
"{"$cc4"}_"{$4==3?2:0}\
"{"$cc5"}_"{$4==4?2:0}\
"{"$cc6"}_"{$4==5?2:0}\
"{$11}_"$a\
"{$12}_"$a\
"{$13}_"$a\
"{$14}_"$a\
"{$15}_"$a\
"{$16}_"$a\
"{$17}_"$a\
"{$18}_"$b\
"{$19}_"$b\
"{$20}_"$b\
"{$21}_"$b\
"{$22}_"$b\
"{$23}_"$b\
"{$24}_"$b\
"{$25}_"$c\
"{$26}_"$c\
"{$27}_"$c\
"{$28}_"$c\
"{$29}_"$c\
"{$30}_"$c\
"{$31}_"$c\
"{$32}"\
"{$33,$34}"
#@gui Attractor:fx_rep_trsa,fx_rep_trsa_preview(0)
#@gui :_=note("Generates <b>Attractor</b> fractal."),_=separator()
#@gui :_=note("<b>Input</b>")
#@gui :Algorithm=choice(0,A,B,C,D,E,F,G)
#@gui :Density=float(7,.5,50)
#@gui :Scale=float(1,.1,3)
#@gui :_=note("<b>Parameters</b>)
#@gui :A=float(1,-1,1)
#@gui :B=float(1,-1,1)
#@gui :C=float(1,-1,1)
#@gui :D=float(1,-1,1)
#@gui :E=float(1,-1,1)
#@gui :F=float(1,-1,1)
#@gui :G=float(1,-1,1)
#@gui :H=float(1,-1,1)
#@gui :I=float(1,-1,1)
#@gui :Randomize Parameters=button(),_=separator()
#@gui :_=note("<b>Output</b>")
#@gui :Mode=choice(0,"A","A/B","A/A")
#@gui :Negative Exponential Factor=float(1,1,10)
#@gui :Multiplier=float(1,1,10)
#@gui :Quality=float(1,1,3),_=separator()
#@gui :_=note("<b>Preview</b>")
#@gui :Fill Percentage=bool(0)
#@gui :_=separator(),_=note("<b>Instruction</b>"),_=note("Attractor are fractals in which values lean toward a location within phase space.\n\n<b>1. </b><u>Input</u> setting defines the format of attractor fractal as well as its density and scaling.\n\n<b>2. </b> <u>Parameters</u> are different variables with different numbers assigned. This is used to alter the forms of attractor.\n\n<b>3.</b> <u>Output</u> influence the shading of attractor. A implies that negative exponental factor is applicable while B means that it's not applicable. In case of two letter, the last letter is the alpha channel. The greater the negative exponential factor value is, the more visible the attractor will be.\n\n<b>4. Quality</b> resizes the image and multiply the density by the quality number, then resize the image back to the original size. It is used to reduce noise.\n\n<b>5. Fill Percentage</b> is used as a way to diagnose whether there is a fractal appearing or not. A very low percentage means there is no fractal. Percentage higher than 100% implies some values are out of range in respect to the image boundary.")
#@gui :_=separator(),_=note("<b>Info</b>"),_=note("Conversion of a PDN plugin made by TechnoRobbo.\n\nSource Code: <a href=\"https://forums.getpaint.net/topic/28512-trs-strange-attractors-v113-august-8th-2014/">TR's Strange Attractor Plugin</a>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/3/29</i>.</small>")
fx_rep_trsa:
skip ${18=0},${19=1}
l.
    ww={w} hh={h}
    channels 0 f 0
    r2dx {$17*100}%
    rep_trsa $1,{$2*$17},${3-12},$19
    u {${}/wh#-1}
    n 0,1
    if $14 r 100%,100%,100%,2 fi
    if $14<1 f [i^(1/$15)]
    else f i^(1/$15)
    fi
    r $ww,$hh,1,{s},2
    * 255 * $16
endl
fx_rep_trsa_preview:

param1,param2,param3,param4,param5,param6,param7,param8,param9=$4,$5,$6,$7,$8,$9,$10,$11,$12
if $13
 param1,param2,param3,param4,param5,param6,param7,param8,param9={[u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1),u(-1,1)]}
fi

fx_rep_trsa ${1-3},$param1,$param2,$param3,$param4,$param5,$param6,$param7,$param8,$param9,0,${14-17},,0

fill_decimal={${}}
fill_perc={round($fill_decimal*10000)/100}
if $18 to $fill_perc"%" fi

a={$1!=3?2}
b={$1>3?2}
c={$1==5?2}

u "{$1}"\
"{$2}"\
"{$3}"\
"{"$param1"}"\
"{"$param2"}"\
"{"$param3"}_"$a\
"{"$param4"}_"$a\
"{"$param5"}_"$b\
"{"$param6"}_"$b\
"{"$param7"}_"$c\
"{"$param8"}_"$c\
"{"$param9"}_"$c\
"{0}"\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18}"
#@gui Non-Isometric RPG Tiler (Interactive):fx_rep_rpgtiler_noniso,fx_rep_rpgtiler_noniso_preview
#@gui :_=note("Launch the interactive non-isometric RPG Tiling toolkit.\n\n<b>Note : </b>When using Custom Tileset, you must load the file in tileset!\n\n<u>Please Read Instruction Below!</u>"),_=separator()
#@gui :_=note("<b>Tileset</b>")
#@gui :Premade Tileset=choice(0,LPC House Interior[32], Generic Platform[32], Metroid Like[16], Omega Team[16],Classic RPG[16],Dungeon[32],Happyland[16])
#@gui :Import Custom Tileset?=bool(0)
#@gui :Tileset=file(),_=separator(),_=note("<b>Interactive Window Setting</b>")
#@gui :Tile Size=int(32,3,128)
#@gui :Max Selection Increment=int(2,0,8)
#@gui :Interactive Tileset Width=int(16,2,64)
#@gui :Interactive Tileset Height=int(16,2,64)
#@gui :Layer as Placed Tiles?=bool(0)
#@gui :Apply Image Background on Final Image?=bool(0)
#@gui :Alpha to RGB Background Mode=choice(0,"Checkerboard","Colored")
#@gui :Background Colour=color(0,0,0)
#@gui :Grid Color=float(0,0,255)
#@gui :Trackpad Color=float(45,0,255)
#@gui :_=separator(),_=note("<b>Preprocessing</b>")
#@gui :Reverse Layers?=bool(0)
#@gui :_=note("<small>This option is usable for programs that supports editing on two or more layer at once with G'MIC-QT!</small>")
#@gui :_=separator(),_=note("<b>Preview</b>")
#@gui :Hide Background?=bool(0)
#@gui :Preview Grid and Tracker?=bool(1)
#@gui :Hide Tileset?=bool(0),_=separator(),_=note("<b>Paint.NET Workaround</b>")
#@gui :Output Mode=choice(0,"Center Result","Output to File")
#@gui :Output Folder=folder()
#@gui :Output Filename=text("placed_tile.png")
#@gui :_=note("<small>This section is only for Paint.NET users! If you don't use this this software, then you don't need use this section!</small>")
#@gui :_=separator()
#@gui :_=note("\n- <u><b>Instruction</b></u> -\n\n"),_=separator()
#@gui :_=note("<b>Section 1 - Preview Window</b>"),_=separator()
#@gui :_=note("Before processing to the interactive window - Test the following conditions:\n\n<b>1. </b>Tileset is correct\n<b>2. </b>Grid fits and is very visible\n<b>3. </b>Tracker is very visible\n\nIf the preview looks good, then proceed to the interactive tool by clicking OK.\n\n<b>Warning: </b>Apply will only waste your time!")
#@gui :_=separator(),_=note("<b>Section 2 - Interactive Windows</b>"),_=separator()
#@gui :_=note("Press Escape on Canvas Window to exit!\n\n<u>Main Editing Mode</u>\n\n<b>On Any Windows</b>\n\n- D: Switch between Place/Eraser Mode\n- R: Activate Replace Mode\n- W: Restore All Windows\n- SPACEBAR: Switch Editing Mode\n\n<b>On Canvas Window</b>\n\n- C: Copy Mode On/Off\n- X: Cut Mode On/Off\n- Z: Undo Canvas Change\n- F: Activate/Deactivate Background Tile Layering Mode\n- G: Grid Mode On/Off\n- Q: Remove/Restore Background\n- A: Tracker On/Off\n- S: Symmetry Mode On/Off\n\n=== On Canvas[Symmetry Mode] ===\n--- 1: Switch Symmetry Axis to X-Axis\n--- 2: Switch Symmetry Axis to Y-Axis\n--- 3: Switch Symmetry Axis to Cross XY-Axis\n--- 4: Switch Symmetry Axis to Mirror XY-Axis\n--- ARROWKEY: Move Symmetry Line\n--- B: Switch Axis in Symmetry Mode\n--- M: Switch Axis in Periodic/Mirror Mode\n--- J: Symmetry Line to Center\n--- S: Deactivate Symmetry Mode\n\n<b>On Tileset Window</b>\n\n- G: Grid Mode On/Off\n- CTRL+ARROWKEY : Resize Tile Selection\n- ARROWKEY : Scroll Through Tileset\n\n<b>On Tile Window</b>\n\n- CTRL+ARROWKEY : Resize Tile Selection\n- ARROWKEY : Scroll Through Tileset\n- MOUSE BUTTON : Switch Between Place/Eraser Mode\n\n=== On Tile[No Symmetry Mode] ===\n--- 1: Switch Fill Boundary to Periodic\n--- 2: Switch Fill Boundary to Mirror\n--- 3: Switch Fill Boundary to Mirror X\n--- 4: Switch Fill Boundary to Mirror Y\n--- B: Switch Fill Boundary Mode\n\n<u>Row/Column Editing Mode</u>\n\n<b>On Any Windows</b>\n\n- W: Restore All Windows\n- SPACEBAR: Switch Editing Mode\n\n<b>On Canvas Window</b>\n\n- Z: Undo Canvas Change\n- T: Enable Row/Column Shifting Mode\n- E: Place Mode On/Off\n- G: Grid Mode On/Off\n- Q: Remove/Restore Background\n- A: Tracker On/Off\n- S: Activate Symmetrical Selection Mode\n\n=== On Canvas[Selection] ===\n--- C: Keep Selected Row/Column\n--- X: Delete Selected Row/Column\n--- D: Select/Deselect\n--- R: Clear Selection\n--- V: View Selection Box/Hide Selection Box\n--- Mouse Button: Select/Deselect\n--- ARROWKEY: Switch between Row/Column Selection\n\n=== On Canvas[Symmetry Mode-Symmetry] ===\n--- J: Symmetry Line to Center\n--- ARROWKEY: Move Symmetry Line\n--- S: Deactivate Symmetrical Selection Mode\n\n=== On Canvas[Row/Column Shifting Mode] ===\n--- Mouse Button[1st Click]: Activate Shifting\n--- Mouse Button[2nd Click]: Finalize Shifting\n--- 0: Shift Boundary Mode - None\n--- 1: Shift Boundary Mode - Neumann [Periodic]\n--- 2: Shift Boundary Mode - Neumann [Mirror]\n--- 3: Shift Boundary Mode - Neumann [Alternating]\n--- 4: Shift Boundary Mode - Periodic\n--- 5: Shift Boundary Mode - Mirror\n--- ARROWKEY: Switch between Row/Column Selection\n--- T: Disable Row/Column Shifting Mode\n\n=== On Canvas[Place Mode] ===\n--- Mouse Button: Place Row/Column\n--- B: Switch between Replacement/Placement Mode\n--- F: Place Row/Column as Foreground/Background\n--- Mouse Button: Place Row/Column\n--- E: Deactivate Place Mode\n\n<b>On Tile Window</b>\n\n- ARROWKEY: Flip Row/Column")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/10/20</i>.</small>")
fx_rep_rpgtiler_noniso:
skip ${3=""}
ww={w}
hh={h}

if '$_host'=='paintdotnet' if $20 +store. pdnimage fi fi

if $2 fileloc="$3" fi

if $16 if $8 rv[^0] else rv fi fi

if $8 blend[^0] alpha
else blend alpha
fi

if $2 i $fileloc
else rep_tileset_n $1
fi

if $8
 if $10 rep_tiler_n[-2] [-1],${4-7},[0],$9,${11-15}
 else rep_tiler_n[-2] [-1],${4-7},[0],$9,,,,${14-15}
 fi
 k[-2]
else
 if $10 rep_tiler_n[-2] [-1],${4-7},,$9,${11-15}
 else rep_tiler_n[-2] [-1],${4-7},,$9,,,,${14-15}
 fi
 k[-2]
fi
if '$_host'=='paintdotnet' if $20 filename="$21/$22" o[0] $filename rm $pdnimage
else
r $ww,$hh,100%,100%,0,0,.5,.5
fi fi
fx_rep_rpgtiler_noniso_preview:
skip ${3=""}
if $2 fileloc="$3" fi

ww={w}
hh={h}

if $16 rv fi
if $17 f 0 fi
blend alpha
if !$19
 store. bg
 if $2 i $fileloc
 else rep_tileset_n $1
 fi
 tw={w#-1}
 th={h#-1}
 r. $ww,$hh,100%,100%,0,0
 shift. {floor((w/$4)/2)*$4-(floor($tw/$4/2)-(!$tw%2?1))*$4},{floor((h/$4)/2)*$4-(floor($th/$4/2)-($th%2?1))*$4}
 if !$17 $bg rv blend alpha fi
fi

if $10
 drgba ${11-13}
else
 drgba
fi

if $18
 f "
 begin(
  const psx=floor((w/2)/$4)*$4;
  const psy=floor((h/2)/$4)*$4;
  const border=2;
  const border_left=psx+border;
  const border_right=psx+$4-border;
  const border_up=psy+border;
  const border_down=psy+$4-border;
  const boundx=psx+$4;
  const boundy=psy+$4;
 );
 tracker=(x>psx&&x<boundx)&&(y>psy&&y<boundy)?((x<=border_left||x>=border_right)||(y<=border_up||y>=border_down)?(xor($15,i)>128?0:255):i):i;
 grid=!(((x%$4)==0||(y%$4)==0)||(x==(w-1)||y==(h-1)))?tracker:$14;
 "
fi
if '$_host'=='paintdotnet' pdn=1 else pdn=0 fi
u "{$1}_"{!$2?2:1}\
"{$2}"\
"{$3}_"{$2?2:1}\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11,$12,$13}_"{$10?2:1}\
"{$14}"\
"{$15}"\
"{$16}_"{!$pdn?2:0}\
"{$17}"\
"{$18}"\
"{$19}"\
"{$20}_"{$pdn?2:0}\
"{$21}_"{$pdn?($20?2:1):0}\
"{$22}_"{$pdn?($20?2:1):0}
#@gui Grouped Pixels Shift By Rectangular Polar Transformation: gui_rep_sptbwgp_recpoltrans,gui_rep_sptbwgp_recpoltrans_preview(0)
#@gui :_=note("Forces image to be within a point based on shape and boundary. Read notes below the filter option for more instructions.\n\n<b>Warning - </b> This is a computationally intensive filter.\n\n<small><b>Note - </b>Future versions may come with easier way to utilize this filter.</small>"),_=separator(),_=note("<b>Main</b>")
#@gui :Relative Position (%)=float(-100,-100,100)
#@gui :Influence Factor (%)=float(100,0,100)
#@gui :Threshold (%)=float(50,0,100)
#@gui :Vanishing Point (%)=point(50,50,0,1,128,128,128,255)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/5/10</i>.</small>")
gui_rep_sptbwgp_recpoltrans:
position={$1%}
influence={$2%}
threshold={$3%*255}
px={(($4-50)*2)/100}
py={(($5-50)*-2)/100}
rep_sptbwgp_recpoltrans $position,$influence,$threshold,$px,$py
gui_rep_sptbwgp_recpoltrans_preview:
gui_split_preview "gui_rep_sptbwgp_recpoltrans ${1-5}",${-3--1}
#@gui Ordered Dithering:fx_rep_loupasc_ordered_dither,fx_rep_loupasc_ordered_dither_preview
#@gui :Dithering Method=choice(4,"Checkerboard","Dispersed","Arcade","Ordered","Lines","Matrix","Random")
#@gui :Color Count=choice(3,"2","4","6","16")
#@gui :Use Luminosity?=bool(0)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse")
#@gui :Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Dithering algorithm developed by Pascal Ollive. - <a href="https://forums.getpaint.net/topic/116414-new-developer-new-plugin-ordered-dither/?tab=comments#comment-571305">Source Code Link</a></small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/5/15</i>.</small>")
fx_rep_loupasc_ordered_dither:
repeat $! l[$>]
 if $3
  to_graya sh. 0 rep_loupasc_ordered_dither. $1,$2 rm.
 else
  sh. 0,2 rep_loupasc_ordered_dither. $1,$2 rm.
 fi
endl done
fx_rep_loupasc_ordered_dither_preview:
gui_split_preview "fx_rep_loupasc_ordered_dither ${1-3}",${-3--1}
#@gui Edge Fade: fx_rep_edgefade,fx_rep_edgefade_preview(0)
#@gui :_=note("If your image has slim alpha, activate Use Max Distance for better control over the fade, however preview will not be as accurate unless you view the full image."),_=separator()
#@gui :_=note("<b>Main</b>")
#@gui :Half Image-Diagonal(%)=float(10,.1,100)
#@gui :Max Distance (%)=float(10,.1,100)
#@gui :Use Max Distance?=bool(0)
#@gui :Exponential Factor=float(2,0,3)
#@gui :_=separator(),_=note("<b>Local Normalization</b>")
#@gui :Amplitude=float(0,0,15)
#@gui :Neighborhood Smoothness (%)=float(4,.1,100)
#@gui :Average Smoothness (%)=float(2,.1,100)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/7/13</i>.</small>")
fx_rep_edgefade:
if $3
 rep_edgefade $2%,${4-5},$6%,$7%
else
 diag={round((norm(w,h)/2)*($1/100))}
 rep_edgefade $diag,${4-5},$6%,$7%
fi
fx_rep_edgefade_preview:
gui_split_preview "fx_rep_edgefade ${1-7}",${-3--1}
u "{$1}_"{!$3?2}\
"{$2}_"{$3?2}\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}_"{$5?2:1}\
"{$7}_"{$5?2:1}\
"{$8}"\
"{$9,$10}"
#@gui Bit Plane Shuffler: fx_rep_jr_bps,fx_rep_jr_bps_preview(0)
#@gui :Depth=choice(0,"8-Bit","16-Bit")
#@gui :Direction=choice(0,"Forward","Backward")
#@gui :Seed=int(5,0,15)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian.,Joan Rake Latest Update: <i>2020/7/18</i>.</small>")
fx_rep_jr_bps:
if $1 * 257 fi
rep_jr_bitplane_shuffler $3,!$2,{($1*8)+8}
if $1 / 257 fi
fx_rep_jr_bps_preview:
gui_split_preview "fx_rep_jr_bps ${1-3}",${-3--1}
#@gui Graphical Tiling Glitch (Interactive): fx_rep_x_graphical_tiling,fx_rep_x_graphical_tiling_preview(0)
#@gui :_=note("Launch the interactive graphical tiling window.\n\nDetails: The main purpose of this filter is to stimulate graphical tiling glitch observed in Microsoft Windows XP Operating System. However, you can also use it to tile images by hand to artistic purpose.\n\n<u>Please Read Instruction Below!</b>")
#@gui :_=separator(),_=note("<b>Main</b>)
#@gui :Initial Insertion Rate (milliseconds)=int(0,0,1000)
#@gui :Background Color=color(0,0,0)
#@gui :Autocrop and Separate?=bool(0)
#@gui :Reverse Layers?=bool(0)
#@gui :Output Mode=choice(1,"Tiled Only","New Layer","Blended")
#@gui :_=separator(),_=note("<b>Preview</b>)
#@gui :Background Mode=choice(0,"Image","Colored","Alpha")
#@gui :Offset=point(50,50,0,1,255,255,255,255)
#@gui :Duplicates=int(5,1,50)
#@gui :Display Message?=bool(1)
#@gui :_=separator(),_=note("<b><u>Instruction</u></b>)
#@gui :_=note("\n<b>All Mode</b>\n\n- O: Change Preview Mode\n- SPACE: Switch Mode\n- ESC: End Interactive Window\n\n<u>Important Note: Check the message in the title bar.</u>\n\n<b>Image Placement Mode</b>\n\n- D: Display Overlay Image\n- H: Flip Image Horizontally\n- V: Flip Image Vertically\n- Mouse Click: Move/Place Image\n- ARROW UP/DOWN: Change Tiling Image\n- ARROW LEFT/RIGHT: Rotate Image\n\n<b>Tiling Mode</b>\n\n- Mouse Move: Place Tile at Insertion Rate\n- ARROW UP/DOWN: Add/Subtract Insertion Rate by 100 ms\n- ARROW LEFT/RIGHT: Add/Subtract Insertion rate by 10 ms")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/8/9</i>.</small>")
fx_rep_x_graphical_tiling:
if !$6 rv fi
if $5 autocrop[^0]
else autocrop_components[^0] 0%,0%,1,1
fi
if $7 +rep_x_graphical_tiling[0] [1--1],$1,${2-4} k[0,-1] if $7==2 blend alpha fi
else rep_x_graphical_tiling[0] [1--1] k[0]
fi
fx_rep_x_graphical_tiling_preview:
if !$6 rv fi
if $5 autocrop[1]
else autocrop_components[1] 0%,0%,1,1
fi
k[0,1]
r. {w#0},{h#0},1,{s#0},0,0,.5,.5
r. 100%,100%,$11,100%,0,1
f. "begin(
const offx=(100-$9-50)%;
const offy=(100-$10-50)%;
);
j(offx*w*(z/(d-1)),offy*h*(z/(d-1)));
"
if $8 k. fi
s. z
if $8!=1 blend alpha
else blend alpha drgba ${2-4}
fi
if $12
if s==2||s==4
sh. 0,{s-2} fi
text="Interactive Filter" to. $text,.5~,.5~,10%
rm.
fi
#@gui Popcorn Fractal [Transformative]: fx_rep_pfrac_t,fx_rep_pfrac_t_preview
#@gui :_=note("Generates Transformative Pickover Popcorn Fractal. Discovered by T.Gangopadhyay at XLRI in C.H.Area[E],Jamshedpur,India in 2012."),_=separator()
#@gui :_=note("<b>Main</b>"),_=separator()
#@gui :Points=int(50,1,200)
#@gui :Density=float(1,.01,10)
#@gui :H Variable=float(.05,-5,5)
#@gui :K Variable=float(3,-75,75)
#@gui :Zoom=float(.5,.1,10)
#@gui :Angle=float(45,-180,180)
#@gui :Origin=point(50,50,0,1,255,255,255,255)
#@gui :_=separator(),_=note("<b>Trigonometric Function</b>")
#@gui :Input Set of Functions=choice(0,"ABAB","ABCD")
#@gui :_=separator(),_=note("Set A")
#@gui :Mode=choice(0,"Individual","Additive","Composite")
#@gui :Function=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(1,"X-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(3,"Y-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(1,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Include Iterated Value=bool(1)
#@gui :_=separator(),_=note("Set B")
#@gui :Mode=choice(0,"Individual","Additive","Composite")
#@gui :Function=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(0,"X-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(5,"Y-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(5,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Include Iterated Value=bool(1)
#@gui :_=separator(),_=note("Set C")
#@gui :Mode=choice(0,"Individual","Additive","Composite")
#@gui :Function=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(1,"X-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(3,"Y-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(1,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Include Iterated Value=bool(1)
#@gui :_=separator(),_=note("Set D")
#@gui :Mode=choice(0,"Individual","Additive","Composite")
#@gui :Function=choice(4,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(0,"X-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(5,"Y-Output","Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function A=choice(0,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Function B=choice(5,"Sine","Hyperbolic Sine","Cosine","Hyperbolic Cosine","Tangent","Hyperbolic Tangent")
#@gui :Include Iterated Value=bool(1)
#@gui :_=separator(),_=note("<b>Output</b>"),_=separator()
#@gui :Value Limit(%)=float(2,.5,100)
#@gui :Midpoint Shift=float(0,-1,1)
#@gui :Multiplier=float(1,.1,10)
#@gui :Normalize=bool(1)
#@gui :_=separator(),_=note("<b>Preview</b>"),_=separator()
#@gui :Show Fill Ratio?=bool(0)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/08/18</i>.</small>")
fx_rep_pfrac_t:
ox={(($7-50)/100)*2}
oy={(($8-50)/100)*-2}
main_args=${1-6},$ox,$oy
value_limit={$38%}
midpoint_shift={1-abs($39)}
if $9
 if $10==0 set_arg_a=0,$11
 elif $10==1 set_arg_a=1,${12-13}
 else set_arg_a=2,${14-16}
 fi
 if $17==0 set_arg_b=0,$18
 elif $17==1 set_arg_b=1,${19-20}
 else set_arg_b=2,${21-23}
 fi
 if $24==0 set_arg_c=0,$25
 elif $24==1 set_arg_c=1,${26-27}
 else set_arg_c=2,${28-30}
 fi
 if $31==0 set_arg_d=0,$32
 elif $31==1 set_arg_d=1,${33-34}
 else set_arg_d=2,${35-37}
 fi
 set_args=$set_arg_a,$set_arg_b,$set_arg_c,$set_arg_d
else
 if $10==0 set_arg_a=0,$11
 elif $10==1 set_arg_a=1,${12-13}
 else set_arg_a=2,${14-16}
 fi
 if $17==0 set_arg_b=0,$18
 elif $17==1 set_arg_b=1,${19-20}
 else set_arg_b=2,${21-23}
 fi
 set_args=$set_arg_a,$set_arg_b
fi
l[0]
 rep_popcorn_fractal_transformative $main_args,$set_args
 if $value_limit<1 cut 0,{$value_limit*iM} fi
 val_max={iM}
 n 0,1
 if $39>=0 f i^$midpoint_shift
 else f 1-((1-i)^$midpoint_shift)
 fi
 if $41 n 0,255
 else * {$40*$val_max}
 fi
endl
fx_rep_pfrac_t_preview:
fx_rep_pfrac_t ${1-41}
if $42
 +f[0] i>0?1
 fillperc={ia*100} rm.
 fillperc_l={int($fillperc)}
 fillperc_r={int(($fillperc-$fillperc_l)*100)}
 fillratio=$fillperc_l
 fillratio.=.
 fillratio.=$fillperc_r
 fillratio.=%
 to[0] $fillratio,.5~,.5~,18%
fi

k[0]

s_abcd={$9?2}

s_sa_a={$10==0?2}
s_sa_b={$10==1?2}
s_sa_c={$10==2?2}

s_sb_a={$17==0?2}
s_sb_b={$17==1?2}
s_sb_c={$17==2?2}

s_sc_a={$9?($24==0?2)}
s_sc_b={$9?($24==1?2)}
s_sc_c={$9?($24==2?2)}

s_sd_a={$9?($31==0?2)}
s_sd_b={$9?($31==1?2)}
s_sd_c={$9?($31==2?2)}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}_"$s_sa_a\
"{$12}_"$s_sa_b\
"{$13}_"$s_sa_b\
"{$14}_"$s_sa_c\
"{$15}_"$s_sa_c\
"{$16}_"$s_sa_c\
"{$17}"\
"{$18}_"$s_sb_a\
"{$19}_"$s_sb_b\
"{$20}_"$s_sb_b\
"{$21}_"$s_sb_c\
"{$22}_"$s_sb_c\
"{$23}_"$s_sb_c\
"{$24}_"$s_abcd\
"{$25}_"$s_sc_a\
"{$26}_"$s_sc_b\
"{$27}_"$s_sc_b\
"{$28}_"$s_sc_c\
"{$29}_"$s_sc_c\
"{$30}_"$s_sc_c\
"{$31}_"$s_abcd\
"{$32}_"$s_sd_a\
"{$33}_"$s_sd_b\
"{$34}_"$s_sd_b\
"{$35}_"$s_sd_c\
"{$36}_"$s_sd_c\
"{$37}_"$s_sd_c\
"{$38}"\
"{$39}"\
"{$40}"_{$41?1:2}\
"{$41}"\
"{$42}"
#@gui Popcorn Fractal: fx_rep_pfrac,fx_rep_pfrac_preview
#@gui :_=note("Fractal attributed to Clifford Pickover. Code adapted from Paul Bourke's C code."),_=separator()
#@gui :_=note("<b>Main</b>")
#@gui :Points=int(50,1,200)
#@gui :Density=float(1,.01,2)
#@gui :H Variable=float(.05,-5,5)
#@gui :K Variable=float(3,-75,75)
#@gui :Zoom=float(1,.1,10)
#@gui :Angle=float(0,-180,180)
#@gui :Origin=point(50,50,0,1,255,255,255,255)
#@gui :_=separator(),_=note("<b>Trigonometric</b>")
#@gui :Mode=choice(0,"Trig-4","Trig-6")
#@gui :XY-Axis Mode?=bool(1)
#@gui :X-Axis Formula S=choice(0,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :X-Axis Formula T=choice(1,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :X-Axis Formula U=choice(2,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :Y-Axis Formula S=choice(0,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :Y-Axis Formula T=choice(1,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :Y-Axis Formula U=choice(2,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :XY-Axis Formula S=choice(0,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :XY-Axis Formula T=choice(1,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :XY-Axis Formula U=choice(2,"Sinusoidal","Cosinusoidal","Tangent","Arc-Tangent")
#@gui :_=separator(),_=note("<b>Output</b>")
#@gui :Midpoint Shift=float(0,-1,1)
#@gui :Multiplier=float(1,.1,10)
#@gui :Normalize=bool(0)
#@gui :_=separator(),_=note("<b>Preview</b>")
#@gui :Show Fill Ratio?=bool(0)
#@gui :_=note("<small>Fill Ratio provides information on whether there is sufficient filled pixels on canvas. The closer to 100%, the more the canvas is filled.</small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/11/1</i>.</small>")
fx_rep_pfrac:
ox={(($7-50)/100)*2}
oy={(($8-50)/100)*-2}
setarg=${1-6},$ox,$oy
midpoint_shift={1-abs($20)}
if $10
 if $9 setarg2=${17-19}
 else setarg2=$17,$19
 fi
else
 if $9 setarg2=${11-16}
 else setarg2=$11,$13,$14,$16
 fi
fi
l[0]
 rep_pfrac $setarg,$9,$setarg2
 val_max={iM}
 n 0,1
 if $20>=0 f i^$midpoint_shift
 else f 1-((1-i)^$midpoint_shift)
 fi
 if $22 n 0,255
 else * {$21*$val_max}
 fi
endl
fx_rep_pfrac_preview:
fx_rep_pfrac ${1-22}
if $23
 +f[0] i>0?1
 fillperc={ia*100} rm.
 fillperc_l={int($fillperc)}
 fillperc_r={int(($fillperc-$fillperc_l)*100)}
 fillratio=$fillperc_l
 fillratio.=.
 fillratio.=$fillperc_r
 fillratio.=%
 to[0] $fillratio,.5~,.5~,18%
fi
k[0]

a={!$10?2:0}
b={$10?2:0}
c={!$10?($9?2:0):0}
d={$10?($9?2:0):0}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}_"$a\
"{$12}_"$c\
"{$13}_"$a\
"{$14}_"$a\
"{$15}_"$c\
"{$16}_"$a\
"{$17}_"$b\
"{$18}_"$d\
"{$19}_"$b\
"{$20}"\
"{$21}_"{$22?1:2}\
"{$22}"\
"{$23}"
#@gui Blur [Splinter]: fx_rep_blur_splinter,fx_rep_blur_splinter_preview
#@gui :_=note(" Apply Splinter Blur.\n\nBased off observation from using Splinter Blur plugin within Paint.NET made by Ed Harvey, and it is inspired by this filter.\n\nComputationally intensive!"),_=separator()
#@gui :Half Image-Diagonal(%) = float(20,0.1,100)
#@gui :Duplicates=int(3,3,100)
#@gui :Angle=float(0,-180,180)
#@gui :Thickness(%)=float(0,0,100)
#@gui :Contrast(%)=float(0,0,100)
#@gui :Balance(%)=float(0,-100,100)
#@gui :Boundary=choice(3,"None","Neumann","Periodic","Mirror")
#@gui :Use Bi-sided Convolution?=bool(0)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/10</i>.</small>")
fx_rep_blur_splinter:
rep_blur_splinter $1%,$2,$3,$4%,{$6%},{$5%},$7,$8 cut 0,255
fx_rep_blur_splinter_preview:
gui_split_preview "fx_rep_blur_splinter ${1-8}",${-3--1}
#@gui Diffusion Limited Aggregation: fx_rep_dla,fx_rep_dla_preview(0)
#@gui :_=note("Create Diffusion Limited Aggregation. "),_=separator()
#@gui :Pixel Proximity=int(2,1,8)
#@gui :Escape Point=int(100,50,500)
#@gui :Aggregation Mode=choice(0,"Corners","Axis[Slow!]","All-Around","Alternating")
#@gui :Target=choice(1,"Dark","Light")
#@gui :Border=int(0,0,200)
#@gui :Keep Mask?=bool(1)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/8/01</i>.</small>")
fx_rep_dla: rep_diffusion_limited_aggregation ${1-6} n 0,255
fx_rep_dla_preview: gui_split_preview "fx_rep_dla ${1-6}",${-3--1}
#@gui Pseudorandom Noise: fx_rep_mj_prn,fx_rep_mj_prn_preview
#@gui :_=note("Generates pseudorandom noise.\n\nBased off <a href="https://forums.getpaint.net/topic/111659-regular-noise-texture-ymd-20170815/">MadJik's Regular Noise Paint.NET Plugin</a>. This is a extended version. Preview may not be accurate!")
#@gui :_=separator(),_=note("<b>Preliminary</b>")
#@gui :K-1=float(8,-8,8)
#@gui :K-2=float(2,-8,8)
#@gui :K Mode=choice(0,"Mode 0","Mode 1")
#@gui :Shift=float(1,-256,256)
#@gui :_=separator(),_=note("<b>Non-K Factors</b>")
#@gui :Color Angle=float(0,-180,180)
#@gui :Pixel Size=int(1,1,16)
#@gui :Position=point(50,50,0,1,128,128,128,255)
#@gui :Formula=choice(1,"Gray","Sinusoidal","RGB","Tangent")
#@gui :Double Pixel Axis?=bool(0)
#@gui :_=separator(),_=note("<b>Grid</b>")
#@gui :Activate Grid?=bool(0)
#@gui :Shade=float(0,0,255)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/1/17</i>.</small>")
fx_rep_mj_prn:
pos_x={min(max(($7/100-.5)*2,-1),1)}
pos_y={min(max(($8/100-.5)*2,-1),1)}
rep_mj_prn ${1-2},${4-6},$pos_x,$pos_y,$9,$3,${11-12},$10
fx_rep_mj_prn_preview:
fx_rep_mj_prn $*
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}_"{$11?2:1}
#@gui HSX Posterize/Index: fx_rep_p_i,fx_rep_p_i_preview
#@gui :Hue Bands=int(10,1,100)
#@gui :Saturation Bands=int(10,1,100)
#@gui :Luminosity Bands=int(10,1,100)
#@gui :Dithering (%)=float(50,0,100)
#@gui :Use rounded coordinates?=bool(0)
#@gui :Colour Space=choice(0,"HSI","HSL","HSV","HCY")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/20</i>.</small>")
fx_rep_p_i:
if $5 rep_hsx_poster_index ${1-3},-1,$6
else rep_hsx_poster_index ${1-3},$4%,$6
fi
fx_rep_p_i_preview:
gui_split_preview "fx_rep_p_i ${1-6}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}_"{!$5?2:1}\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8,$9}"
#@gui Tiled Zoom: fx_rep_tz,fx_rep_tz_preview(0)
#@gui :_=note("Create tiled zoom."),_=separator()
#@gui :Square Width - Half Image-Diagonal(%)=float(10,1,100)
#@gui :Square Height - Half Image-Diagonal(%)=float(10,1,100)
#@gui :Scale=float(2,1,10)
#@gui :Boundary=choice(0,"None","Neumann","Periodic","Mirror")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/22</i>.</small>")
fx_rep_tz:
half_img_diag={norm(w,h)/2}
sw={$1%*$half_img_diag}
sh={$2%*$half_img_diag}
rep_tiled_zoom $sw,$sh,$3,$4
fx_rep_tz_preview:
gui_split_preview "fx_rep_tz ${1-4}",${-3--1}
#@gui Reverse Digits:fx_rep_rvi,fx_rep_rvi_preview(0)
#@gui :_=note("Reverses digits of image. Used for glitch art.\n\n<small><b>Note:</b>Max-1 for Out-Of-Bound Mode is only applicable in float color space.</small>"),_=separator()
#@gui :Colour Space=choice(0,"RGB-8","SRGB-8","RYB-8","CMY","CMYK","HSI-8,"HSL-8","HSV-8","LAB-8","LCH-8","YCBCR-8","YIQ-8","YUV-8","YES-8","K1-8","Ohta-8")
#@gui :Use Alpha?=bool(0)
#@gui :Out-Of-Bound Mode=choice(0,"None","Max-1","Periodic","Continuous")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/9/26</i>.</small>")
fx_rep_rvi:
if $1
 convert_colors_fwd=${arg\ $1,rgb2srgb,rgb2ryb,rgb2cmy,error,rgb2hsi8,rgb2hsl8,rgb2hsv8,rgb2lab8,rgb2lch8,rgb2ycbcr,rgb2yiq8,rgb2yuv8,rgb2yes8,rgb2k18,rgb2ohta8}
 convert_colors_bwd=${arg\ $1,srgb2rgb,ryb2rgb,cmy2rgb,error,hsi82rgb,hsl82rgb,hsv82rgb,lab82rgb,lch82rgb,ycbcr2rgb,yiq82rgb,yuv82rgb,yes82rgb,k182rgb,ohta82rgb}
fi

repeat $! l[$>]
 tcr=3
 convert_back=0
 if (s==3||s==4)&&$1
  convert_back=1
  if $1!=4
   $convert_colors_fwd
  else
   if s==3 tcr=4 rgb2cmyk
   elif s==4 tcr=4 s c,-3 rgb2cmyk.. a c
   fi
  fi
 fi
 if $2 rep_rvi
  if $3==1 cut. 0,255
  elif $3==2 %. 255
  elif $3==3 f. int(i/256)%2?255-i:i fi
 else sh 0,{$tcr-1} rep_rvi.
  if $3==1 cut. 0,255
  elif $3==2 %. 255
  elif $3==3 f. int(i/256)%2?255-i:i fi
  rm.
 fi
 if $convert_back
  if $1!=4
   $convert_colors_bwd
  else
   if s==4 cmyk2rgb
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 fi
endl done
fx_rep_rvi_preview:
gui_split_preview "fx_rep_rvi ${1-3}",${-3--1}
#@gui Chirikov-Taylor: fx_rep_cstdmap,fx_rep_cstdmap_preview
#@gui :_=note("Creates Chirikov-Taylor discrete map.")
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :Lines=int(500,1,10000)
#@gui :Points per line=int(5000,1,100000)
#@gui :K=float(1,-5,5)
#@gui :Mode=choice(0,"Regular","Symmetric Modified")
#@gui :Center Main Rotor=bool(0)
#@gui :Orientation=choice(0,"XY",YX")
#@gui :Multithreaded Processing=bool(1)
#@gui :_=separator(),_=note("<b>Scaling</b>")
#@gui :Factor=float(1,.1,10)
#@gui :Use Image Ratio?=bool(0)
#@gui :_=separator(),_=note("<b>Coloring</b>"),_=note("<u>Preliminary</u>")
#@gui :Mode=choice(0,"Grayscale","HSX","Palette","Random","From Image")
#@gui :Use Alpha?=bool(0)
#@gui :_=separator(),_=note("<u>Additional</u>")
#@gui :HSX Mode=choice(2,"HCY","HSI","HSL/HSV")
#@gui :Palette=choice(0,"RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Color Count=int(20,2,360)
#@gui :Color Seed=int(0,0,100000)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/28</i>.</small>")
fx_rep_cstdmap:
srand $15
if $10==4 $14,1,1,1,u(0,1) store. randorder fi
ww={w}
hh={h}
ld={w>h}
md={max(w,h)}
ti={$!-1}
rep_cstdmap {$9?-1*$8*100:$8*100}%,${1-7}
+f. i?1 store. chan

if $10==0
 if $11 +eq. 0 negate. -.. 1 *.. . n.. 0,255 *. 255 a[-2,-1] c
 else n. 0,255
 fi
elif $10==1 -. 1 *. {359.999999/iM#-1} $chan . if $11 . *. 255 fi a[^0-$ti] c
 if $12==0 sh. 2 *. .5 rm. hcy2rgb.
 elif $12==1 hsi2rgb.
 elif $12==2 hsv2rgb.
 fi
elif $10==2 r. 100%,100%,1,3,1 pal {$13+1} f.. i0?i(#-1,(i-1)%w#-1,0) rm. if $11 $chan *. 255 a[-2,-1] c fi
elif $10==3 r. 100%,100%,1,3,1 $14,1,1,3,u(0,255) f.. i0?i(#-1,(i-1)%w#-1,0) rm. if $11 $chan *. 255 a[-2,-1] c fi
elif $10==4 +channels[0] 0,2 +colormap. $14,0,0 rm.. $randorder pixelsort.. +,x,[-1] rm. r.. 100%,100%,1,3 f.. i0?i(#-1,(i-1)%w#-1,0) rm. if $11 $chan *. 255 a[-2,-1] c fi
fi

if $8<1
 if $ld r. {$ww*($6?($4&&$5?2:1):1)},{max($hh,$md)*($6?($4&&$5?2:1):1)},100%,100%,0,2,.5,.5
 else r. {max($ww,$md)*($6?($4&&$5?2:1):1)},{$hh*($6?($4&&$5?2:1):1)},100%,100%,0,2,.5,.5
 fi
elif $8>1
 if !$9 r. {$md*($6?($4&&$5?2:1):1)},{$md*($6?1:($4&&$5?2:1))},100%,100%,6
 else r. {$ww*($6?($4&&$5?2:1):1)},{$hh*($6?1:($4&&$5?2:1))},100%,100%,6
 fi
fi
mv. 0
if '$host'=='paintdotnet' k[0] fi
fx_rep_cstdmap_preview:
fx_rep_cstdmap $*
set_a={(($10==3)||($10==4))?2:0}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}_"{$10==1?2:0}\
"{$13}_"{$10==2?2:0}\
"{$14}_"$set_a\
"{$15}_"$set_a
#@gui Gaussian Blur By Color Space: fx_rep_blur_cs,fx_rep_blur_cs_preview
#@gui :XY-Amplitude=float(3,0,100)
#@gui :X-Amplitude=float(0,0,20)
#@gui :Y-Amplitude=float(0,0,20)
#@gui :Boundary=choice(1,"Black","Nearest")
#@gui :_=separator()
#@gui :Color Space=choice(0,"RGB","SRGB","RYB","CMY","CMYKA","HCY","HSI","HSL","HSV","LAB","LCH")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/10/04</i>.</small>")
fx_rep_blur_cs:
tcr=3
convert_colors_fwd=${arg\ 1+$5,none,rgb2srgb,rgb2ryb,rgb2cmy,cs_error,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch}
convert_colors_bwd=${arg\ 1+$5,none,srgb2rgb,ryb2rgb,cmy2rgb,cs_error,hcy2rgb,hsi2rgb,hsl2rgb,hsv2rgb,lab2rgb,lch2rgb}
repeat $! l[$>]
 if $5
  if $5!=4
   $convert_colors_fwd.
  else
   if s==3 rgb2cmyk tcr+=1
   elif s==4 s c,-3 rgb2cmyk.. a c
   fi
  fi
 fi
 _fx_gaussian_blur $1,$2,$3,$4
 if $5
  if $5!=4&&$5
   $convert_colors_bwd.
  else
   if s==4 cmyk2rgb tcr-=1
   elif s==5 s c,-4 cmyk2rgb.. a c
   fi
  fi
 fi
endl done
fx_rep_blur_cs_preview:
gui_split_preview "fx_rep_blur_cs ${1-5}",${-3--1}
#@gui Dynamic Contrast: rep_dynamic_contrast,rep_dynamic_contrast_preview
#@gui :Amount=float(0,-64,64)
#@gui :Threshold=float(128,0,255)
#@gui :Intensity=float(255,0,255)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("Code adapted from <a href="https://forums.getpaint.net/topic/117538-dynamic-contrast/?tab=comments#comment-578867">Source Code to Dynamic Contrast PDN plugin</a> made by Remake.")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2020/12/18</i>.</small>")
rep_dynamic_contrast_preview: gui_split_preview "rep_dynamic_contrast ${1-3}",${-3--1}
#@gui Panel Image: rep_fx_shift,rep_fx_shift_preview
#@gui :Offset=point(50,50,0,1,255,255,255,255)
#@gui :Boundary=choice(2,"None","Neumann","Periodic","Mirror")
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/2/04</i>.</small>")
rep_fx_shift: f "begin(const ox=($1-50)/100*(w-1);const oy=($2-50)/100*(h-1););
i(x-ox,y-oy,z,c,$4,$3);"
rep_fx_shift_preview: gui_split_preview "rep_fx_shift ${1-4}",${-3--1}
#@gui Henon Phase Diagram:fx_rep_henon_phase_diagram,fx_rep_henon_phase_diagram_preview
#@gui :_=note("Creates Henon Phase Diagram.\n\n<b>Warning!:</b> If your image does not show up as expected, you may have to increase points per line and/or lines. Preview is inaccurate!")
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :A-Factor=float(2.569,-3.1415,3.1415)
#@gui :Lines=int(500,1,1000000)
#@gui :Points Per Line=int(1000,1,2000)
#@gui :X0-Start=float(-.5,-5,0)
#@gui :X0-End=float(.5,0,5)
#@gui :X0-Increments=int(8,1,14)
#@gui :_=separator(),_=note("<b>Transformation</b>")
#@gui :Scale=float(1,.01,4)
#@gui :Rotation=float(0,-180,180)
#@gui :Position=point(50,50,0,1,255,255,255,255)
#@gui :_=separator(),_=note("<b>Post-Processing</b>")
#@gui :Subpixel Level=float(0,0,10)
#@gui :_=separator(),_=note("<b>Coloring</b>"),_=note("<u>Preliminary</u>")
#@gui :Mode=choice(0,"Grayscale","HSX","Palette")
#@gui :Use Alpha?=bool(0)
#@gui :_=separator(),_=note("<u>Additional</u>")
#@gui :Gray Output=choice(0,"Normalized","Cut","Threshold")
#@gui :Multiplier=float(1,.01,50)
#@gui :HSX Mode=choice(2,"HCY","HSI","HSL/HSV")
#@gui :Palette=choice(0,"RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Color Count=int(20,2,360)_0
#@gui :Color Seed=int(0,0,100000)_0
#@gui :Hue Shift(%)=float(0,0,100)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/3/14</i>.</small>")
fx_rep_henon_phase_diagram:
init_sub={abs($11)}
sub={$init_sub+1}
ww={w} hh={h}
{w*$sub},{h*$sub},1,1,-1
rm..

setarg=$1,$7,$8,$9%,$10%,${2-6}

if $12==0 #Grayscale Mode#

 if $13 #Use Alpha#
  rep_henon_phase_diagram $setarg,{$14==2?3:2}
  if $14==2 {w},{h},1,1,255 rv[-2,-1] a[-2,-1] c r. $ww,$hh,100%,100%,2 sh. 1 n. 0,255 rm.
  else
   inpaint_pde[-3] [-2],1,0,0,1 rm[-2] a[-2,-1] c r. $ww,$hh,100%,100%,2
   if $14 sh. 0 *. $15 cut. 0,255 rm. sh. 1 n. 0,255 rm.
   else sh. 0 sh.. 1 n[-2,-1] 0,255 rm[-2,-1]
   fi
  fi
 else #Do not use Alpha#
  rep_henon_phase_diagram $setarg,{$14>1?3}
  r. $ww,$hh,100%,100%,2
  if $14==1
   *. $15 cut. 0,255
  else
   n. 0,255
  fi
 fi

elif $12==1 #HSX Mode#

 if $13 #Use Alpha#
  rep_henon_phase_diagram $setarg,2
  n... 0,360
  inpaint_pde[-3] [-2],1,0,0,1 rm[-2]
  l.. {w},{h},100%,2,1 a[-2,-1] c endl
  if $16==0 hcy2rgb..
  elif $16==1 hsi2rgb..
  elif $16==2 hsv2rgb..
  fi
  a[-2,-1] c
  r. $ww,$hh,100%,100%,2
  sh. 3 n. 0,255 rm.
 else #Do not use Alpha#
  rep_henon_phase_diagram $setarg,1
  n.. 0,360
  r. 100%,100%,100%,2
  a[-2,-1] c
  if $16==0 hcy2rgb.
  elif $16==1 hsi2rgb.
  elif $16==2 hsv2rgb.
  fi
  r. $ww,$hh,100%,100%,2
 fi

elif $12==2 #Palette#

 +pal {$17+1}

 if $13 #Use Alpha#
  rep_henon_phase_diagram[-2] $setarg,2
  *[-4] {(w#-1-1)/iM#-4}
  vmin={im#-4}
  {w#-4},{h#-4},1,3,pos=i(#-4,x,y,0,0);pos!=$vmin?I(#-1,pos,0,0,1);
  inpaint_pde[-1] [-4],1,0,0,1
  rv[-1,-3] a[-1,-3] c
  rm[-4,-3,-1]
  r. $ww,$hh,100%,100%,2
  sh. 3 n. 0,255 rm.
 else #Do not use Alpha#
  rep_henon_phase_diagram[-2] $setarg
  *[-2] {(w#-1-1)/iM#-2}
  vmin={im#-2}
  {w#-2},{h#-2},1,3,pos=i(#-2,x,y,0,0);pos!=$vmin?I(#-1,pos,0,0,1);
  rm[-3,-2]
  r. $ww,$hh,100%,100%,2
 fi

#elif $12==3 TODO:Random#
#elif $12==4 TODO:From Image
fi
fx_rep_henon_phase_diagram_preview:
fx_rep_henon_phase_diagram $*
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9,$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}_"{!$12?2}\
"{$15}_"{!$12?($14==1?2)}\
"{$16}_"{$12==1?2}\
"{$17}_"{$12==2?2}\
"{$18}"\ #TODO#
"{$19}"\ #TODO#
"{$20}" #TODO#
#@gui Statistical Average: fx_rep_bchstatfunc_average,fx_rep_bchstatfunc_average_preview
#@gui :Mode=choice(0,"RGB","sRGB","RYB","LAB")
#@gui :Use Alpha?=bool(0)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/4/07</i>.</small>")
fx_rep_bchstatfunc_average:
convert_colors_fwd=${arg\ 1+$1,none,rgb2srgb,rgb2ryb,rgb2lab}
convert_colors_bwd=${arg\ 1+$1,none,srgb2rgb,ryb2rgb,lab2rgb}
use_alpha={!$2}
repeat $! l[$>]
 if s>=3
  if $1
   sh. 0,2
   $convert_colors_fwd.
   rep_bchstatfunc[$use_alpha] ia,0
   $convert_colors_bwd.
   rm.
  else
   sh. 0,2
   rep_bchstatfunc[$use_alpha] ia,0
   rm.
  fi
 else
  if s==2
   sh. 1
   rep_bchstatfunc[$use_alpha] ia,0
   rm.
  else
   rep_bchstatfunc ia,0
  fi
 fi
endl done
fx_rep_bchstatfunc_average_preview:
gui_split_preview "fx_rep_bchstatfunc_average ${1-2}",${-3--1}
#@gui Skew:rep_skew,rep_skew_preview
#@gui :Angle=float(0,-89.99,89.99)
#@gui :Position(%)=float(0,-100,100)
#@gui :Axis=choice(0,"X","Y")
#@gui :Boundary=choice(3,"None","Neumann","Periodic","Mirror")
#@gui :Interpolation=choice(2,"Nearest","Linear","Bicubic")
#@gui :Enlarge?=bool(0)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"),Preview Split=point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/4/16</i>.</small>")
fx_rep_skew:
rep_skew $1,$2%,${3-6}
rep_skew_preview:
gui_split_preview "fx_rep_skew ${1-6}",${-3--1}
#@gui Random Gradient Bars: fx_rep_randgradbar,fx_rep_randgradbar_preview
#@gui :_=note("Create Random Gradient Bar.\n\n<b>Note -</b> Preview is only for giving a idea.")
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :Seed=int(0,0,100000)
#@gui :Bar Size - Quarter Image-Diagonal(%)=float(2,0,100)
#@gui :Space Size - Quarter Image-Diagonal(%)=float(0,0,100)
#@gui :Angle=float(0,-180,180)
#@gui :Skew Angle=float(0,-89,89)
#@gui :Origin=point(50,50,0,1,255,255,255,255)
#@gui :Subsampling=float(1,0,3)
#@gui :_=separator(),_=note("<b>Gradient Transformation</b>")
#@gui :Shift=float(0,0,100)
#@gui :Multiplier A=float(1,.1,250)
#@gui :Multiplier B=float(100,.1,250)
#@gui :_=separator(),_=note("<b>Gradient Modulo</b>")
#@gui :Repetition=choice(0,"Random","Cut","Periodic","Continuous")
#@gui :Random Bar Repetition=choice(0,"All","Cut and Periodic","Cut and Continuous","Periodic and Continuous")
#@gui :Space Mode=choice(0,"Alpha","Cut","Gradient")
#@gui :Symmetry Mode=choice(0,"None","Symmetry A","Symmetry B")
#@gui :Inversion Mode=choice(0,"None","Random-Inversion","Full-Inversion")
#@gui :_=separator(),_=note("<b>Color</b>")
#@gui :Output Color=choice(0,"Grayscale","Duotone","RGB - Random Bars","HSV - Random Bars")
#@gui :Space Color A=color(255,0,127)
#@gui :Space Color B=color(249,215,45)
#@gui :_=separator(),_=note("<b>Animation</b>")
#@gui :Shift=float(0,-5,5)_0
#@gui :Multiplier A=float(1,.1,250)_0
#@gui :Multiplier B=float(100,.1,250)_0
#@gui :_=note("Under Development!")
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2021/5/24</i>.</small>")
fx_rep_randgradbar:
srand $1
repeat $! l[$>]
 if $12==0&&$13==0 rep_random_gradient_bars $2%,$3%,$4,$5,{$6/100-.5},{(100-$7)/100-.5},${8-11},-1,,$17,$14,${15-16},$18,$19,$20,$21,$22,$23
 else rep_random_gradient_bars $2%,$3%,$4,$5,{$6/100-.5},{(100-$7)/100-.5},${8-11},{$12-1},{$13-1},$17,$14,${15-16},$18,$19,$20,$21,$22,$23
 fi
 if $17==0 sh. 0 n. 0,255 rm. fi
endl done
fx_rep_randgradbar_preview:
fx_rep_randgradbar ${1-23}
use_color={$17==0?1:($17==1?2:(($3>0&&$14)?2:1))}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8}"\
"{$9}"\
"{$10}"\
"{$11}"\
"{$12}"\
"{$13}_"{!$12?2:1}\
"{$14}_"{$3?2:1}\
"{$15}"\
"{$16}"\
"{$17}"\
"{$18,$19,$20}_"$use_color\
"{$21,$22,$23}_"$use_color\
"{$24}"\
"{$25}"\
"{$26}"
#@gui Dungeon Floor (Super Slow!): fx_rep_dungeon_floor,fx_rep_dungeon_floor_preview
#@gui : Tile Size=choice(0,"1x1","2x2")
#@gui : Tile Choice (If 1x1)=choice(0,"1","2","3","4")
#@gui : Subsampling=float(2,0,5)
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2021/6/02</i>.</small>")
fx_rep_dungeon_floor:
ww={w}
hh={h}
sub={abs($3)+1}
f. 0 channels. 0
r. {$sub*w},{$sub*h},100%,100%,-1
{w},{h},1,1,"begin(
 const cx=(w-1)/2;
 const cy=(h-1)/2;
 const scaleP=$1?1:.5;
 const wx=.043333;
 const wy=.053333;
 const a=.7;
 const TWO_PI=pi*2;
 const off_x=cx*($1==0?((1-$2%2)?1));
 const off_y=cy*($1==0?($2>1?1));
);
xx=scaleP*x/w;
yy=scaleP*y/h;
for(n=0,n<10,n++,
 newx=xx+wx-a/(TWO_PI*sin(TWO_PI*yy));
 newy=yy+wy-a/(TWO_PI*sin(TWO_PI*xx));
 xx=(newx+off_x)%w;
 yy=(newy+off_y)%h;
 i(#0,xx,yy)++;
);
"
rm..
if $3!=0 r. $ww,$hh,100%,100%,2 fi
n. 0,255
fx_rep_dungeon_floor_preview:
fx_rep_dungeon_floor $*
u "{$1}"\
"{$2}_"{!$1?2:1}\
"{$3}"
#@gui Array [Random] [Jumble by px]:rep_array_random_jumble_by_px,rep_array_random_jumble_by_px(1)
#@gui :Source X-Tiles (px)=int(5,1,20)
#@gui :Source Y-Tiles=int(5,1,20)
#@gui :_=separator(),_=note("<small>Author: <i>Reptorian</i> Latest update: <i>2021/6/10</i>.</small>")
rep_array_random_jumble_by_px:
repeat $! l[$>]
 tile_w=$1
 tile_h=$2
 index_w={ceil(w/$tile_w)}
 index_h={ceil(h/$tile_h)}
 index_wh={$index_w*$index_h}

 $index_w,$index_h,1,2,"begin(
  const tile_w=$tile_w;
  const tile_h=$tile_h;
 );
 [x*tile_w,y*tile_h];"

 100%,100%,1,1,u(0,1)

 repeat 2
  pixelsort.. +,x,[-1]
  pixelsort.. +,y,[-1]
  f. u(0,1)
 done

 rm.

 {w#0},{h#0},{d#0},{s#0}

 eval.. "begin(
  const tile_w=$tile_w;
  const tile_h=$tile_h;
 );
 img_tile=crop(#0,I,0,0,tile_w,tile_h,1,s#0);
 draw(#-1,img_tile,x*tile_w,y*tile_h,0,0,tile_w,tile_h,1,s#0);"

 rm[-3,-2]
endl done
#@gui Weighted RGB To Grayscale: fx_rep_w_rgb82gray,fx_rep_w_rgb82gray_preview(0)
#@gui :_=note("Weigh the R-G-B Channel, and then output based on their weight")
#@gui :_=separator(),_=note("<b>Main RGB to Grayscale</b>")
#@gui :Red Weight(%)=float(33.33,0,100)
#@gui :Green Weight(%)=float(33.33,0,100)
#@gui :Blue Weight(%)=float(33.33,0,100)
#@gui :Use Weighted Ratio?=bool(1)
#@gui :_=separator(),_=note("<b>Min-Max Value</b>")
#@gui :Min Value Weight(%)=float(0,0,100)
#@gui :Max Value Weight(%)=float(0,0,100)
#@gui :Min-Max Interpolation=float(0,0,1)
#@gui :_=separator(),_=note("<b>Post-Process Adjustment</b>")
#@gui :Value Shift=float(0,-128,128)
#@gui :Midgray Shift=float(0,-1,1)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/6/25</i>.</small>")
fx_rep_w_rgb82gray:
rep_weighted_rgb82gray $1%,$2%,$3%,$4,$5%,$6%,$7,$8,$9
fx_rep_w_rgb82gray_preview:
gui_split_preview "fx_rep_w_rgb82gray ${1-9}",${-3--1}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}_"{$5&&$6?2:1}\
"{$8}"\
"{$9}"\
"{$10}"\
"{$11,$12}"
#@gui Markus-Lyapunov Fractal: fx_rep_mlfrac,fx_rep_mlfrac
#@gui :_=note("Create a mapping of Lyapunov exponent within two values or three values.")
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :ABC-String=text("ab")
#@gui :ABC-String Repeats=int(50,1,255)
#@gui :Subsampling Level=float(1,0,6)
#@gui :Viewport(%)=float(100,0,100)
#@gui :Position=point(50,50,0,1,255,255,255,255)
#@gui :C-Time(%)=float(50,0,100)
#@gui :_=separator(),_=note("<b>Output</b>")
#@gui :Mode=choice(0,"Grayscale","Duotone","Random","Palette","Layers")
#@gui :Use Inverted?=bool(0)
#@gui :Color A=color(0,0,255,255)
#@gui :Color B=color(255,255,0,255)
#@gui :Set of Palettes=choice(0,"Single","Double")
#@gui :Seed=int(0,0,10000000)
#@gui :Random Palette Color Count=int(8,2,64)
#@gui :Random Palette A Color Count=int(8,2,64)
#@gui :Random Palette B Color Count=int(8,2,64)
#@gui :Color Space=choice(0,"HSL","LAB","LCH")
#@gui :Palette=choice(12,"BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Palette Order=choice(0,"Default","Randomized","Mirrored")
#@gui :Palette A=choice(16,"BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Palette A Order=choice(0,"Default","Randomized","Mirrored")
#@gui :Palette B=choice(50,"BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Palette B Order=choice(0,"Default","Randomized","Mirrored")
#@gui :Color Count=int(8,2,64)
#@gui :Palette Order=choice(0,"Default","Randomized","Mirrored")
#@gui :Color Count A=int(8,2,64)
#@gui :Palette A Order=choice(0,"Default","Randomized","Mirrored")
#@gui :Color Count B=int(8,2,64)
#@gui :Palette B Order=choice(0,"Default","Randomized","Mirrored")
#@gui :Reverse Layers=bool(0)
#@gui :Reverse Non-Target Layers=bool(0)
#@gui :Mode=choice(0,"Import One File Only","Import Two Files")_0
#@gui :File=file()_0
#@gui :File A=file()_0
#@gui :File B=file()_0
#@gui :Color Count=int(8,2,64)_0
#@gui :Randomize Color Position=bool(0)_0
#@gui :Color Count A=int(8,2,64)_0
#@gui :Randomize Colors A Position=bool(0)_0
#@gui :Color Count B=int(8,2,64)_0
#@gui :Randomize Colors B Position=bool(0)_0
#@gui :_=separator(),_=note("<b>Orientation</b>")
#@gui :X-Direction=choice(0,"Default","Mirrored")_0
#@gui :Y-Direction=choice(0,"Default","Mirrored")_0
#@gui :_=note("<small>Under Development!</small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/08/25</i>.</small>")
fx_rep_mlfrac:
skip "${39=}","${40=}","${41=}"
srand $19
set_main_arg=${1-3},$4%,$5%,{100-$6}%,$7%
timg={$!}

if $8==0
 rep_markus_lyapunov_fractal[0] $set_main_arg,$9 n 0,255 if $timg>1 f[^0] I#0 fi
elif $8==1
 hex_col_a=${rep_int82hex\ ${10-13}}
 hex_col_b=${rep_int82hex\ ${14-17}}
 rep_markus_lyapunov_fractal[0] $set_main_arg,$hex_col_a,$hex_col_b
 if $timg>1 f[^0] I#0 fi
elif $8==2
 if $18 rep_markus_lyapunov_fractal[0] $set_main_arg,u,u,${21-23}
 else rep_markus_lyapunov_fractal[0] $set_main_arg,u,$20,$23
 fi
 if $timg>1 f[^0] I#0 fi
elif $8==3
 if $18
  +pal $26
  +pal $28
  rep_markus_lyapunov_fractal[0] $set_main_arg,[-2],[-1],$27,$29
  rm[-2,-1]
  if $timg>1 f[^0] I#0 fi
 else
  +pal $24
  rep_markus_lyapunov_fractal[0] $set_main_arg,[-1],$25
  rm.
  if $timg>1 f[^0] I#0 fi
 fi
else
 if $timg==2||$timg==3
  if $36 rv fi
  if $timg==2
   rep_markus_lyapunov_fractal[0] $set_main_arg,[1],$31,$30
  else
    if $37 rv[^0] fi
    rep_markus_lyapunov_fractal[0] $set_main_arg,[1],[2],$33,$35,$32,$34
  fi
 else
  error "Invalid number of layer(s) for this mode. 2 or 3 Layers Only!"
 fi
fi

use_time=${}
set_a_1={$8==1?2}
set_a_2={$8==2?2}
set_a_3={$8==2&&$18==1?2}
set_b_1={($8==2&&$18==0)?2}
set_b_2={($8==2&&$18==1)?2}
set_c_1={($8==3&&$18==0)?2}
set_c_2={($8==3&&$18==1)?2}
set_d_1={$8==4&&$timg==2?2}
set_d_2={$8==4&&$timg==3?2}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5,$6}"\
"{$7}_"$use_time\
"{$8}"\
"{$9}_"{!$8?2}\
"{$10,$11,$12,$13}_"$set_a_1\
"{$14,$15,$16,$17}_"$set_a_1\
"{$18}_"{$8>1&&$8<4?2}\
"{$19}_"{$8==2?2:$8==3?($18?(($27==1||$29==1)?2:1):($25==1?2:1)):$8==4?($timg==3?(($33==1||$35==1)?2:1):($31==1?2:1))}\
"{$20}_"{$8==2&&$18==0?2}\
"{$21}_"$set_a_3\
"{$22}_"$set_a_3\
"{$23}_"$set_a_2\
"{$24}_"$set_c_1\
"{$25}_"$set_c_1\
"{$26}_"$set_c_2\
"{$27}_"$set_c_2\
"{$28}_"$set_c_2\
"{$29}_"$set_c_2\
"{$30}_"$set_d_1\
"{$31}_"$set_d_1\
"{$32}_"$set_d_2\
"{$33}_"$set_d_2\
"{$34}_"$set_d_2\
"{$35}_"$set_d_2\
"{$36}_"{$8==4?2}\
"{$37}_"$set_d_2\
"{$38}"\
"{$39}"\
"{$40}"\
"{$41}"\
"{$42}"\
"{$43}"\
"{$44}"\
"{$45}"\
"{$46}"\
"{$47}"\
"{$48}"\
"{$49}"
#@gui Rainbowify: fx_rep_rainbowify,fx_rep_rainbowify_preview(0)
#@gui :_=note("Apply rainbowify effect into image. Inspired by <a href="https://blog.jfrech.com/180/">Rainbowify effect made by Jonathan Frech</a>."),_=separator()
#@gui :Hue Shift=float(0,-180,180)
#@gui :Gradient Angle=float(0,-180,180)
#@gui :Gradient Scale(%)=float(100,50,200)
#@gui :_=separator(),Preview Type=choice("Full","Forward Horizontal","Forward Vertical","Backward Horizontal","Backward Vertical","Duplicate Top","Duplicate Left","Duplicate Bottom","Duplicate Right","Duplicate Horizontal","Duplicate Vertical","Checkered","Checkered Inverse"), Preview Split = point(50,50,0,0,200,200,200,0,10)_0
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/7/26</i>.</small>")
fx_rep_rainbowify: rep_rainbowify ${1-2},$3%
fx_rep_rainbowify_preview:
gui_split_preview "fx_rep_rainbowify ${1-3}",${-3--1}
#@gui Complexion Burst: fx_rep_compb,fx_rep_compb_preview
#@gui :_=note("Complex-Plane adaptation of the Pickover Popcorn Fractal. Discovered By Reptorian."),_=separator()
#@gui :_=note("<b>Main</b>")
#@gui :Points=int(50,1,200)
#@gui :Density=float(1,.01,2)
#@gui :H-Real=float(.05,-75,75)
#@gui :H-Imag=float(3,-75,75)
#@gui :K-Real=float(3,-75,75)
#@gui :K-Imag=float(3,-75,75)
#@gui :Zoom=float(2,.1,20)
#@gui :Angle=float(0,-180,180)
#@gui :Origin=point(50,50,0,1,255,255,255,255)
#@gui :_=separator(),_=note("<b>Number Extraction</b>")
#@gui :Method=choice(0,"Per-Axis","Additive")
#@gui :_=separator(),_=note("<b>Complex Trigonometric</b>")
#@gui :Mode=choice(0,"Z-4","Z-6")
#@gui :Complex-Plane Mode?=bool(1)
#@gui :Real-Axis Formula S=choice(0,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :Real-Axis Formula T=choice(1,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :Real-Axis Formula U=choice(2,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :Imaginary-Axis Formula S=choice(0,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :Imaginary-Axis Formula T=choice(1,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :Imaginary-Axis Formula U=choice(2,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :XY-Axis Formula S=choice(0,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :XY-Axis Formula T=choice(1,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :XY-Axis Formula U=choice(2,"Complex Sinusoidal","Complex Cosinusoidal","Complex Tangent","Complex Log")
#@gui :_=separator(),_=note("<b>Output</b>")
#@gui :Value Limit(%)=float(.5,.5,100)
#@gui :Midpoint Shift=float(.5,-1,1)
#@gui :Multiplier=float(1,.1,10)
#@gui :Normalize=bool(1)
#@gui :_=separator(),_=note("<b>Preview</b>")
#@gui :Show Fill Ratio?=bool(0)
#@gui :_=note("<small>Fill Ratio provides information on whether there is sufficient filled pixels on canvas. The closer to 100%, the more the canvas is filled.</small>")
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/08/19</i>.</small>")
fx_rep_compb:
ox={(($9-50)/100)*2}
oy={(($10-50)/100)*-2}
setarg=${1-2},"[${3-4}]","[${5-6}]",${7-8},$ox,$oy
midpoint_shift={1-abs($24)}
if $13
 if $12 setarg2=${20-22}
 else setarg2=$20,$22
 fi
else
 if $12 setarg2=${14-19}
 else setarg2=$14,$16,$17,$19
 fi
fi
l[0]
 rep_complexion_burst $setarg,$11,$12,$setarg2
 val_max={iM}
 if ($23%)<1 cut 0,{iM*$23%} fi
 n 0,1
 if $24>=0 f i^$midpoint_shift
 else f 1-((1-i)^$midpoint_shift)
 fi
 if $26 n 0,255
 else * {$25*$val_max}
 fi
endl
fx_rep_compb_preview:
fx_rep_compb ${1-26}
if $27
 +f[0] i>0?1
 fillperc={ia*100} rm.
 fillperc_l={int($fillperc)}
 fillperc_r={int(($fillperc-$fillperc_l)*100)}
 fillratio=$fillperc_l
 fillratio.=.
 fillratio.=$fillperc_r
 fillratio.=%
 to[0] $fillratio,.5~,.5~,18%
fi
k[0]

a={!$13?2:0}
b={$13?2:0}
c={!$13?($12?2:0):0}
d={$13?($12?2:0):0}

u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9,$10}"\
"{$11}"\
"{$12}"\
"{$13}"\
"{$14}_"$a\
"{$15}_"$c\
"{$16}_"$a\
"{$17}_"$a\
"{$18}_"$c\
"{$19}_"$a\
"{$20}_"$b\
"{$21}_"$d\
"{$22}_"$b\
"{$23}"\
"{$24}"\
"{$25}_"{$26?1:2}\
"{$26}"\
"{$27}"
#@gui Ellsworth Kelly Board: fx_rep_ekb,fx_rep_ekb_preview
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :Square Size - Half Minimum-Dimension(%)=float(10,1,100)
#@gui :Border Size - Square Size(%)=float(10,-100,100)
#@gui :Border Size - Pixel=int(1,-50,50)
#@gui :Use Pixel Unit to define Border=bool(1)
#@gui :Frequency(%)=float(50,5,100)
#@gui :Output=choice(0,"Inside","Resized")
#@gui :_=separator(),_=note("<b>Color Options</b>")
#@gui :Unfilled Area Color=color(110,105,130)
#@gui :Keep Unfilled Area Empty?=bool(0)
#@gui :Exterior Border Color=color(255,255,255)
#@gui :Keep Exterior Border Color Empty?=bool(0)
#@gui :Border Value(%)=float(25,0,100)
#@gui :Palette=choice(0,"Predefined","Random")
#@gui :Number of Colors=int(12,5,100)
#@gui :Color Space=choice(0,"RGB","RYB","CMY","CMYK","HCY","HSI","HSL","HSV","LAB","LCH","YCbCr","YCbCrGLIC","YIQ","YUV","XYZ","YES")
#@gui :Predefined Palette=choice(10,"BW-RGB-{5}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21', "Nature's Embrace 55", 'Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 5","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :_=separator(),_=note("<b>Random</b>")
#@gui :Main=int(0,0,1000000)
#@gui :Color=int(0,0,1000000)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/09/16</i>.</small>")
fx_rep_ekb:
to_rgba

convert_colors_fwd=${arg\ $18+1,error,rgb2ryb,rgb2cmy,rgb2cmyk,rgb2hcy,rgb2hsi,rgb2hsl,rgb2hsv,rgb2lab,rgb2lch,rgb2ycbcr,rgb2ycbcrglic,rgb2yiq,rgb2yuv,rgb2xyz,rgb2yes}

#Random Below#
#Main=arg20#
#Color=arg21#

square_size={round(min(w,h)/2*$1%)}
if $4
 border_size=$3
else
 border_size=$2%
fi

main_arg=$square_size,$border_size,$15%,$5%

if !$10 ufc=${rep_int82hex\ ${7-9}} fi

second_set_arg=$6,$18

if !$14
 if $18&&$15
  1,1,1,3,[${11-13}]
  $convert_colors_fwd.
  second_set_arg.=,{crop(#-1)}
  rm.
 else
  second_set_arg.=,${11-13}
 fi
fi

if $16
 mimg={$!-1}
 if $18<4||$18==11 vcol=[u(255),u(255),u(255)]
 elif $18<8 vcol=[u(359.999),u(1),u(1)]
 elif $18==8 vcol=[u(0,100),u(-128,182),u(-155,155)]
 elif $18==9 vcol=[u(0,100),u(240),u(-pi,pi)]
 elif $18==10 vcol=[u(16.5,236),u(16.9375,240.0625),u(16.9375,240.0625)]
 elif $18==12 vcol=[u(255),u(-151.90757751464844,151.90757751464844),u(-133.26069641113281,133.26069641113281)]
 elif $18==13 vcol=[u(1),u(-.436,.436),u(-.615,.615)]
 elif $18==14 vcol=[u(1),u(1),u(1)]
 elif $18==15 vcol=[u(255),u(-127.5,127.5),u(-127.5,127.5)]
 fi
 $17,1,1,{$18==3?4:3},begin(srand($21));$vcol
 srand $20
 rep_ellsworth_kelly_board[0-$mimg] $main_arg,[-1],$ufc,$second_set_arg
 rm.
else
 ppc=${arg\ $19+1,3,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,160,189,190,191,192,193,194,195,196,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223}
 srand $20
 rep_ellsworth_kelly_board $main_arg,$ppc,$ufc,$second_set_arg
fi
fx_rep_ekb_preview:
fx_rep_ekb $*
a={$16?2:0}
u "{$1}"\
"{$2}"_{!$4?2:0}\
"{$3}"_{$4?2:0}\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7,$8,$9}"_{!$10?2:1}\
"{$10}"\
"{$11,$12,$13}"_{$6?0:!$14?2:1}\
"{$14}"_{$6?0:2}\
"{$15}"_{(($4?$3:$2)!=0)?2:1}\
"{$16}"\
"{$17}"_$a\
"{$18}"_$a\
"{$19}"_{!$16?2:0}\
"{$20}"\
"{$21}"_{$16?2:0}
#@gui Random Rectangle Division: fx_rep_rrd,fx_rep_rrd
#@gui :_=separator(),_=note("<b>Main</b>")
#@gui :Division=int(10,1,20)
#@gui :Additional Thickness=int(5,0,100)
#@gui :Maximum Division Iteration=int(5,2,40)
#@gui :Probability of Division(%)=float(95,20,100)
#@gui :Loop Limit=int(50000,1000,2097152)
#@gui :Seed=int(0,0,300)
#@gui :Border(%)=float(35,0,100)
#@gui :_=separator(),_=note("<b>Color</b>")
#@gui :Mode=choice(0,"Grayscale","Palette","Random")
#@gui :Normalize?=bool(1)
#@gui :Palette=choice(12,"BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Color Space=choice(0,"RGB","HSV")
#@gui :Number of Color=int(0,0,100)
#@gui :Seed=int(0,0,100000)
#@gui :Border=color(0,0,0)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/10/04</i>.</small>")
fx_rep_rrd:
border_size={max(0,round($2*$7/100))}
rgb_col=${rep_int82hex\ ${14-16}}
if $8==2
 if $12 rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col,${11-13}
 else rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col,$11,,$13
 fi
elif $8==1
 rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col,pal,$10,$13
else
 rep_random_rectangular_division ${1-3},$4%,$5,$7%,$6,$9,$rgb_col
fi
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6}"\
"{$7}"\
"{$8}"\
"{$9}"_{!$8?2}\
"{$10}"_{$8==1?2}\
"{$11}"_{$8==2?2}\
"{$12}"_{$8==2?2}\
"{$13}"_{$8?2}\
"{$14,$15,$16}"_{$border_size?2:1}
#@gui Three-Coupled Oscillators: fx_rep_tco,fx_rep_tco
#@gui :_=note("<b>Main</b>"),_=separator()
#@gui :Maximum Iteration=int(50,1,200)
#@gui :K-A Tau(%)=float(50,-100,100)
#@gui :K-B Tau(%)=float(-50,-100,100)
#@gui :Subpixel Level=float(1,0,2)
#@gui :Angle=float(0,-180,180)
#@gui :Position=point(50,50,0,1,128,128,128,255)
#@gui :Axis-Scale=float(1,1,15)
#@gui :_=note("<b>Coloring</b>"),_=separator()
#@gui :Mode=choice(0,"Grayscale","Palette","Random")
#@gui :Palette=choice(12,"BW-{2}","RGB-{3}","B-RGB-{4}","BW-RGB-{5}","CMY-{3}","CMYK-{4}","W-CMYK-{5}","RGBCMY-{6}","1-Bit-RGB-{8}","Aurora-{256}","PLAYPAL-{249}","Sonic Robo Blast 2-{256}","Famicube-{64}","Andrew Kensler - 16","Andrew Kensler - 32","Andrew Kensler - 54","AAP-Micro 12","AAP-16","AAP-64","AAP-SPLENDOR128","DB8","DB16","DB32","DB-ISO22","DimWiddy 17","DimWiddy 23","Endesga-4","Endesga-8","Endesga-16","Endesga-32","Endesga-36","Endesga-64","Juicy-32","Juicy-56","XAIUE-22","15P-DX","20P-DX","24P-DX","Cabana-64","Fantasy 16","Fantasy 24","Tranquil Fantasy 23","Tranquility Plus 39","Faraway 48","Fleja Master Palette-{33}","Koni32","Linear Color Palette Basic-{31}","Vines Flexible Linear Ramps-{38}","Arcade Standard 29","ARQ16","BLK 36","BLK-NEO-{46}","Broken Facility-{40}","Bubblegum-16","Cade 15","Calder 8-{11}","Chromatic16","CD-BAC-{16}","CG Arne-{16}","CPC BOY-{32}","Dinoknight 16","||||-22","FZT Ethereal 16","GZXP-{11}","Indecision-{17}","Island Joy 16","Journey-{64}","Juicy 17","Oak21","Nature's Embrace 55","Nauris-16","Pear 36","Peachy Pop 16-{16}","Pineapple 32","Resurrect 32-{32}","Rosy 42","SLSO-CLR17","Softy 15","SPEC12","Starmancer-{52}","Superb 8","SuperFuture25","Sweetie 16","Taffy 16","Todayland Palette V2-{25}","Vivid-17","Voodo34","Zughy 32","ENOS16","Undertones-17","Equpix 15","Night 16","Star 29","Star 34","Still-Life-{14}","SimpleJPC-16","Acid 15","Battery 24","Clumpy 18","Cthulhu-{16}","Crimso 11","Copper-Tech-{16}","DRZ15A","Eggy 15","Eroge-Copper","Europa 16-{16}","GreyT-bit-{8}","Jewel-{15}","Polar 11","Sheltzy 32","Rube-Goldberg-{9}","BoomBoom-{7}","Generic-8","Matriax8c","NT1H-{26}","Autum 15","Autum 15 [Yellow]","JerryPie 22","Naji 16","Blessing-{5}","Crayola Blind-{9}","Easter Island-{16}","Fairy Tales-{8}","Fuzzy Four-{4}","0xdb-01-{17}","Ocaso-{17}","Pastel-{15}","17 Pastels","Pollen-8","Nopal-12","Sy17","Syz15","TUI-15","Cave-{8}","Psygnosia-{16}","MarshMellow32","Rabbit 7","Finlal 11","Vinik 24","YKB-22","Graveyard-21","Steam Lords-{16}","AAP-RadiantXV-{15}","AAP-Majesty XVII-{17}","Daruda 22","Rust-6","XAIUE-Radiant-{22}","Firestorm-{9}","SuperNova 7","NYX8","OIL6","SGM-Palette 2-{17}","Fornax Void I-{256}","Fornax Void II-{128}","Pixelwave-{12}","Spacey Easter-{17}","Moonlit-39","Petite-8","Petite-8 Afterdark","Autochrome 3","Autochrome 5","GB Default #1-{4}","GB Default #2-{4}","GB Andrade-{4}","GB Blue Seni-{4}","GB Blackzone-{4}","GB Crimson-{4}","GB Didi-{4}","GB Dirty-{4}","GB Arne-{4}","GB Easy-{4}","GB Forest-{4}","GB Harsh Green-{4}","GB Light Green-{4}","GB Nostalgia-{4}","GB Platinum-{4}","GB Kirokaze-{4}","GB PJ-{4}","GB Cyber-{4}","GB Wish-{4}","GB Grapefruit-{4}","GB Ice Cream-{4}","GB Red_Blue-{4}","GB Spacehaze-{4}","GB Chocolate-{4}","GB Purple Dawn-{4}","GB Gray-{4}","ARNE4","HallowPumpkin-{4}","Amiga 2600 NTSC-{128}","Amiga 2600 PAL-{104}","Amiga 2600 SECAM-{8}","Amiga 7800 M.E.S.S-{256}","Amiga 7800-{256}","Amstrad CPC-{27}","Apple II-{15}","CGA-{16}","CGA Mode 0 [Low]-{4}","CGA Mode 0 [High]-{4}","CGA Mode 1 [Low]-{4}","CGA Mode 1 [High]-{4}","CGA Mode 2 [Low]-{4}","CGA Mode 2 [High]-{4}","Commodore 64 [Pepto Interpretation]-{16}","Commodore 64 [Colodore Interpretation]-{16}","Commodore VIC-20-{16}","Colecovision-{15}","Japanese Machine Palette-{16}","Macintosh II-{16}","NES-{52}","PICO-8-{16}","RISC OS-{16}","SAM Coupe-{128}","Thomson MO5-{16}","VGA-{244}","ZX Spectrum-{15}","GNOME 32-{32}","Electronic Crayon 22","Chip16","MSX-{15}","Deluxe Paint-{222}","Legacy Paint-{16}","XP Paint-{28}","Vista Paint-{28}")
#@gui :Number of Colors=int(6,2,100)
#@gui :Color Space=choice(0,"RGB","HSI","HCY","LAB")
#@gui :Seed=int(0,0,3000)
#@gui :Boundary=choice(1,"Periodic","Continous")
#@gui :Negate=bool(0)
#@gui :Shift Value=float(0,-1,1)
#@gui :Multiplier=float(1,.25,10)
#@gui :_=separator(),_=note("<small>Author: Reptorian. Latest Update: <i>2021/10/15</i>.</small>")
fx_rep_tco:
tau={2*pi}
ow={w}
oh={h}
mode={$14?2:1}
l[0]
 rep_three_coupled_oscillators $1,{$tau*$2%},{$tau*$3%},-$4,$5,{($6-50)/50},{($7-50)/-50},$8
 if $9==0
  if $-1!=1
   if $-1>1
    n 0,{255*$-1}
    if $-2!=0 + {$-2*255} fi
    modf {$-4?3:2},255,1
   else
    n 0,{255*$-1}
   fi
  else
   n 0,255
  fi
  if $-2!=0&&(!($-1>1))
   + {$-2*255}
   modf {$-4?3:2},255,1
  fi
  if $-3 negate fi
 elif $9==1 
  +pal $10
  n.. 0,{$-1*(w#-1-1)}
  if $-3 negate.. fi
  if $-2!=0 +.. {(w#-1-1)*$-2} fi
  rep_cubic_map.. [-1],$mode
  rm.
 fi
 if $9!=2 r $ow,$oh,100%,100%,6 fi
endl
if $9==2
 if $12 convert_colors_bwd=${arg\ $12,hsi2rgb,hcy2rgb,lab2rgb} fi
 ti={$!}
 if $ti>1 
  rm[^0] 
  repeat $ti-1 . done 
 fi
 repeat $! l[$>]
  if $12==3 $11,1,1,3,begin(srand($13+$>););[u(0,100),u(-128.014,182.136),u(-155.5,155.5)];
  elif $12 $11,1,1,3,begin(srand($13+$>););[u(0,359.999999),u(0,1),u(0,1)];
  else $11,1,1,3,begin(srand($13););u(255);
  fi
  n.. 0,{$-1*(w#-1-1)}
  if $-3 negate.. fi
  if $-2!=0 +.. {(w#-1-1)*$-2} fi
  rep_cubic_map.. [-1],$mode
  rm.
  if $12 $convert_colors_bwd. fi
  r $ow,$oh,100%,100%,6
 endl done
else
 ti={$!}
 if $ti>1 
  rm[^0] 
  repeat $ti-1 . done 
 fi
fi
rand_col_set={$9==2?2}
u "{$1}"\
"{$2}"\
"{$3}"\
"{$4}"\
"{$5}"\
"{$6,$7}"\
"{$8}"\
"{$9}"\
"{$10}"_{$9==1?2}\
"{$11}"_$rand_col_set\
"{$12}"_$rand_col_set\
"{$13}"_$rand_col_set\
"{$14}"\
"{$15}"\
"{$16}"\
"{$17}"
#@gui Color Harmonies [DEMO]: fx_rep_color_harmonies, fx_rep_color_harmonies_preview(0)
#@gui :_=note("<b>This is a demo filter!</b> This means it's only used to demonstrate capability of G'MIC. Right now, there is still a unresolved bug with regard to moving points. Until that can be fixed, this will remain a demo filter!")
#@gui :_=separator(),_=note("<b>Reference Point</b>")
#@gui :Hue=float(50,0,360)
#@gui :Saturation(%)=float(100,0,100)
#@gui :Shade/Tint(%)=float(0,-100,100)
#@gui :Color Space=choice(0,"RGB",RYB")
#@gui :_=separator(),_=note("<b>Additional Information</b>")
#@gui :Palette Mode=choice(0,"Neutral 8","Neutral 15","Analogous 30","Complementary","Split-Complementary","Triadic","Tetradic","Clash","Four Tones","Five Tones","Six Tones")
#@gui :_=separator(),_=note("<b>Output Color</b>")
#@gui :Color A=color(0,0,0)
#@gui :Color B=color(0,0,0)
#@gui :Color C=color(0,0,0)
#@gui :Color D=color(0,0,0)
#@gui :Color E=color(0,0,0)
#@gui :Color F=color(0,0,0)
#@gui :_=separator(),_=note("<b>Preview</b>")
#@gui :Color Point Position=point(50,50,0,1,128,128,128,255)
#@gui :Color Select Position(%)=float(10,10,50)
#@gui :Scaling(%)=float(90,30,100)
#@gui :Point-X=point(50,50,0,0,0,0,0,0,0)_0
#@gui :Color A=color(0,0,0)_0
#@gui :Color B=color(0,0,0)_0
#@gui :Color C=color(0,0,0)_0
#@gui :Color D=color(0,0,0)_0
#@gui :Color E=color(0,0,0)_0
#@gui :Color F=color(0,0,0)_0
#@gui :Hue=float(0,0,360)_0
#@gui :Saturation(%)=float(100,0,100)_0
#@gui :Shade/Tint(%)=float(0,-100,100)_0
#@gui :Hue=float(0,0,360)_0
#@gui :Saturation(%)=float(100,0,100)_0
#@gui :Shade/Tint(%)=float(0,-100,100)_0
#@gui :Hue=float(0,0,360)_0
#@gui :Saturation(%)=float(100,0,100)_0
#@gui :Shade/Tint(%)=float(0,-100,100)_0
#@gui :Hue=float(0,0,360)_0
#@gui :Saturation(%)=float(100,0,100)_0
#@gui :Shade/Tint(%)=float(0,-100,100)_0
#@gui :Hue=float(0,0,360)_0
#@gui :Saturation(%)=float(100,0,100)_0
#@gui :Shade/Tint(%)=float(0,-100,100)_0
#@gui :Hue=float(0,0,360)_0
#@gui :Saturation(%)=float(100,0,100)_0
#@gui :Shade/Tint(%)=float(0,-100,100)_0
#@gui :Color Space=choice(0,"RGB",RYB")_0
#@gui :Palette Mode=choice(0,"Neutral 8","Neutral 15","Analogous 30","Complementary","Split-Complementary","Triadic","Tetradic","Clash","Four Tones","Five Tones","Six Tones")_0
#@gui :Color Select Position(%)=float(10,10,50)_0
#@gui :Scaling(%)=float(90,30,100)_0
#@gui :Preview Palette?=bool(0)_0
#@gui :Orientation=choice(0,"Horizontal","Vertical")_0
#@gui :Palette X=choice(1,"Bottom","Middle","Top")_0
#@gui :Palette Y=choice(1,"Left","Middle","Top")_0
fx_rep_color_harmonies:
error demo_filter
fx_rep_color_harmonies_preview:
_hsl_h,_hsl_s,_hsl_l,\
_rgb_0_r,_rgb_0_g,_rgb_0_b,\
_rgb_1_r,_rgb_1_g,_rgb_1_b,\
_rgb_2_r,_rgb_2_g,_rgb_2_b,\
_rgb_3_r,_rgb_3_g,_rgb_3_b,\
_rgb_4_r,_rgb_4_g,_rgb_4_b,\
_rgb_5_r,_rgb_5_g,_rgb_5_b,\
_rgb_0_r_alt,_rgb_0_g_alt,_rgb_0_b_alt,\
_rgb_1_r_alt,_rgb_1_g_alt,_rgb_1_b_alt,\
_rgb_2_r_alt,_rgb_2_g_alt,_rgb_2_b_alt,\
_rgb_3_r_alt,_rgb_3_g_alt,_rgb_3_b_alt,\
_rgb_4_r_alt,_rgb_4_g_alt,_rgb_4_b_alt,\
_rgb_5_r_alt,_rgb_5_g_alt,_rgb_5_b_alt,\
_hsl_0_h,_hsl_0_s,_hsl_0_l,\
_hsl_1_h,_hsl_1_s,_hsl_1_l,\
_hsl_2_h,_hsl_2_s,_hsl_2_l,\
_hsl_3_h,_hsl_3_s,_hsl_3_l,\
_hsl_4_h,_hsl_4_s,_hsl_4_l,\
_hsl_5_h,_hsl_5_s,_hsl_5_l,\
_point_x_0,_point_y_0\
=${1-3},${6-23},${30-65},$24,$25

m "draw_points :
  eval[1] \"begin(
    const radius=9;
    const colsize=sqr(radius)*3;
    blkcol=vector(#colsize,128);
    circle_alpha_component=expr('begin(
     const ww=w-1;
     const hh=h-1;
     const cx=ww/2;
     const cy=hh/2;
    );
    xx=(x-cx)/cx;
    yy=(y-cy)/cy;
    inrange(norm(xx,yy),.4,1,1);'
    ,radius,radius,1,1);
   );
  m=(I/100)*[w#0,h#0];
  if(x,
   draw(#0,blkcol,round(m[0])-6,round(m[1])-6,0,0,radius,radius,1,3,1,circle_alpha_component,1);
  );
  \"
 "

m "gen_pt_info :

 width,height={w#0},{h#0}
 
 l..
 
  lightness={i(#-1,0,0,0,2)}
  
  {w},{h},{d},2,\"begin(
    const scale=$27%;
    const lightness=($lightness+100)/200;
    const width=$width;
    const height=$height;
    const ww=width-1;
    const hh=height-1;
    const cx=ww/2;
    const cy=hh/2;
    const ref_dim=min(cx,cy);
    const max_length=ref_dim*scale;
    const min_length=max_length*$26/100;
    const length=lerp(min_length,max_length,lightness);
   );
   rad_ang=((360-i(#-1,x,0,0,0))-90)°;
   center=[cx,cy];
   off=[cos(rad_ang)*length,sin(rad_ang)*length];
   point=center+off;
   point[0]/=ww;
   point[1]/=hh;
   point*=100;\"
   
  _point_x_0,_point_y_0={I(#-1,0)}
  rv
  
 endl
 
 draw_points "
 
# Below, this is a test code to see if I can fix the point location change bug.

m "gen_pt_info_alt :

 width,height={w#0},{h#0}
 
 l..
  {w},{h},{d},2,\"begin(
    const scale=$27%;
    const width=$width;
    const height=$height;
    const mx=width-1;
    const my=height-1;
    const cx=mx/2;
    const cy=my/2;
    const ref_dim=min(cx,cy);
    const max_length=ref_dim*scale;
    const min_length=max_length*$26/100;
    const pos_x=mx*$24/100;
    const pos_y=my*$25/100;
    const dx=pos_x-cx;
    const dy=pos_y-cy;
    const dist=cut(sqrt(dx^2+dy^2),min_length,max_length);
   );
   rad_ang=((360-i(#-1,x,0,0,0))-90)°;
   center=[cx,cy];
   off=[cos(rad_ang)*dist,sin(rad_ang)*dist];
   point=center+off;
   point[0]/=mx;
   point[1]/=my;
   point*=100;\"
   
   _point_x_0,_point_y_0=$24,$25
   rv
 endl
 
 draw_points "

m "gen_col_info : 

 if w==2
 
  _hsl_0_h,_hsl_1_h,\
  _hsl_0_s,_hsl_1_s,\
  _hsl_0_l,_hsl_1_l\
  ={crop(#-2)}
 
  _rgb_0_r,_rgb_1_r,\
  _rgb_0_g,_rgb_1_g,\
  _rgb_0_b,_rgb_1_b\
  ={crop(#-1)}
  
  _rgb_0_r_alt,_rgb_1_r_alt,\
  _rgb_0_g_alt,_rgb_1_g_alt,\
  _rgb_0_b_alt,_rgb_1_b_alt\
  ={crop(#-1)}
  
 elif w==3
 
  _hsl_0_h,_hsl_1_h,_hsl_2_h,\
  _hsl_0_s,_hsl_1_s,_hsl_2_s,\
  _hsl_0_l,_hsl_1_l,_hsl_2_l\
  ={crop(#-2)}
 
  _rgb_0_r,_rgb_1_r,_rgb_2_r,\
  _rgb_0_g,_rgb_1_g,_rgb_2_g,\
  _rgb_0_b,_rgb_1_b,_rgb_2_b\
  ={crop(#-1)}
  
  _rgb_0_r_alt,_rgb_1_r_alt,_rgb_2_r_alt,\
  _rgb_0_g_alt,_rgb_1_g_alt,_rgb_2_g_alt,\
  _rgb_0_b_alt,_rgb_1_b_alt,_rgb_2_b_alt\
  ={crop(#-1)}
  
 elif w==4
 
  _hsl_0_h,_hsl_1_h,_hsl_2_h,_hsl_3_h,\
  _hsl_0_s,_hsl_1_s,_hsl_2_s,_hsl_3_s,\
  _hsl_0_l,_hsl_1_l,_hsl_2_l,_hsl_3_l\
  ={crop(#-2)}
 
  _rgb_0_r,_rgb_1_r,_rgb_2_r,_rgb_3_r,\
  _rgb_0_g,_rgb_1_g,_rgb_2_g,_rgb_3_g,\
  _rgb_0_b,_rgb_1_b,_rgb_2_b,_rgb_3_b\
  ={crop(#-1)}
  
  _rgb_0_r_alt,_rgb_1_r_alt,_rgb_2_r_alt,_rgb_3_r_alt,\
  _rgb_0_g_alt,_rgb_1_g_alt,_rgb_2_g_alt,_rgb_3_g_alt,\
  _rgb_0_b_alt,_rgb_1_b_alt,_rgb_2_b_alt,_rgb_3_b_alt\
  ={crop(#-1)}
  
 elif w==5

  _hsl_0_h,_hsl_1_h,_hsl_2_h,_hsl_3_h,_hsl_4_h,\
  _hsl_0_s,_hsl_1_s,_hsl_2_s,_hsl_3_s,_hsl_4_s,\
  _hsl_0_l,_hsl_1_l,_hsl_2_l,_hsl_3_l,_hsl_4_l\
  ={crop(#-2)}
 
  _rgb_0_r,_rgb_1_r,_rgb_2_r,_rgb_3_r,_rgb_4_r,\
  _rgb_0_g,_rgb_1_g,_rgb_2_g,_rgb_3_g,_rgb_4_g,\
  _rgb_0_b,_rgb_1_b,_rgb_2_b,_rgb_3_b,_rgb_4_b\
  ={crop(#-1)}
  
  _rgb_0_r_alt,_rgb_1_r_alt,_rgb_2_r_alt,_rgb_3_r_alt,_rgb_4_r_alt,\
  _rgb_0_g_alt,_rgb_1_g_alt,_rgb_2_g_alt,_rgb_3_g_alt,_rgb_4_g_alt,\
  _rgb_0_b_alt,_rgb_1_b_alt,_rgb_2_b_alt,_rgb_3_b_alt,_rgb_4_b_alt\
  ={crop(#-1)}
  
 elif w==6
 
  _hsl_0_h,_hsl_1_h,_hsl_2_h,_hsl_3_h,_hsl_4_h,_hsl_5_h,\
  _hsl_0_s,_hsl_1_s,_hsl_2_s,_hsl_3_s,_hsl_4_s,_hsl_5_s,\
  _hsl_0_l,_hsl_1_l,_hsl_2_l,_hsl_3_l,_hsl_4_l,_hsl_5_l\
  ={crop(#-2)}
 
  _rgb_0_r,_rgb_1_r,_rgb_2_r,_rgb_3_r,_rgb_4_r,_rgb_5_r,\
  _rgb_0_g,_rgb_1_g,_rgb_2_g,_rgb_3_g,_rgb_4_g,_rgb_5_g,\
  _rgb_0_b,_rgb_1_b,_rgb_2_b,_rgb_3_b,_rgb_4_b,_rgb_5_b\
  ={crop(#-1)}
  
  _rgb_0_r_alt,_rgb_1_r_alt,_rgb_2_r_alt,_rgb_3_r_alt,_rgb_4_r_alt,_rgb_5_r_alt,\
  _rgb_0_g_alt,_rgb_1_g_alt,_rgb_2_g_alt,_rgb_3_g_alt,_rgb_4_g_alt,_rgb_5_g_alt,\
  _rgb_0_b_alt,_rgb_1_b_alt,_rgb_2_b_alt,_rgb_3_b_alt,_rgb_4_b_alt,_rgb_5_b_alt\
  ={crop(#-1)}
  
 fi"

if ([${1-3}]!=[${48-50}])||($4!=$66)||($5!=$67)
 rep_create_hsl_color_select $2%,{$26/100},$4,{$27/100}
 +rep_color_harmony_palette $1,{$2/100},{$3/100},$5,{$4+2}
 
 sh.. 2 *. 200 -. 100 sh... 1 *. 100 rm[-2,-1]
 
 gen_col_info gen_pt_info
 
elif [${6-23}]!=[${30-47}]

 eval "
  vec_a=[${6-23}];
  vec_b=[${30-47}];
  repeat(arg(1+$5,6,6,6,2,3,3,4,3,4,5,6),p,
   a=(vec_a)[3*p,3];
   b=(vec_b)[3*p,3];
   a!=b?(
    v=p;
    run('col_a=',vtos(a));
    run('col_b=',vtos(b));
    break();
   );
  );
  v;"
  
 1,1,1,3,([${6-23}])[3*${},3]
 1,1,1,3,([${30-47}])[3*${},3]
  
 if $4
  rgb2ryb[-2,-1]
  rgb2hsl[-2,-1]
 else
  rgb2hsl[-2,-1]
 fi
 
 hsl_base={"
  fmod(a)=a-360*floor(a/360);
  rescale_lightness(a)=(a+100)/200;
  new_col=crop(#-2);
  old_col=crop(#-1);
  diff=new_col-old_col;
  out_hsl=[${1-3}];
  out_hsl[1]/=100;
  out_hsl[2]=rescale_lightness(out_hsl[2]);
  out_hsl+=diff;
  out_hsl[2]=cut(out_hsl[2]*2-1,-1,1);
  out_hsl[1]=cut(out_hsl[1],0,1);
  out_hsl;
 "}
 
 rep_create_hsl_color_select {arg(2,$hsl_base)},{$26/100},$4,{$27/100}
 +rep_color_harmony_palette $hsl_base,$5,{$4+2}
 
 sh.. 2 *. 200 -. 100 sh... 1 *. 100 rm[-2,-1]
 
 _hsl_h,_hsl_s,_hsl_l={I(#-2,0)}
 
 gen_col_info gen_pt_info
 
elif [${24-25}]!=[${28-29}]

 rep_create_hsl_color_select $2%,{$26/100},$4,{$27/100}
 
 hsl_base={"
  const scale=$27%;
  const mx=w-1;
  const my=h-1;
  const cx=mx/2;
  const cy=my/2;
  const ref_dim=min(cx,cy);
  const max_length=ref_dim*scale;
  const min_length=max_length*$26/100;
  const length=max_length-min_length;
  const pos_x=mx*$24%;
  const pos_y=my*$25%;
  const dx=pos_x-cx;
  const dy=pos_y-cy;
  const hue=(atan2(dx,dy)+pi)/((pi*2)/360);
  const dist=2*((cut(sqrt(dx^2+dy^2),min_length,max_length)-min_length)/length)-1;
  [hue,$2/100,dist];
 "}
 
 +rep_color_harmony_palette $hsl_base,$5,{$4+2}
 
 sh.. 2 *. 200 -. 100 sh... 1 *. 100 rm[-2,-1]
 
 _hsl_h,_hsl_s,_hsl_l={I(#-2,0)}
 
 gen_col_info gen_pt_info_alt
 
else
 rep_create_hsl_color_select $2%,{$26/100},$4,{$27/100}
 +rep_color_harmony_palette $1,{$2/100},{$3/100},$5,{$4+2}
 gen_pt_info
fi

num_of_col={w+1}

um draw_points,gen_pt_info,gen_pt_info_alt,gen_col_info

u "{"$_hsl_h"}"\
"{"$_hsl_s"}"\
"{"$_hsl_l"}"\
"{$4}"\
"{$5}"\
"{"$_rgb_0_r","$_rgb_0_g","$_rgb_0_b"}"\
"{"$_rgb_1_r","$_rgb_1_g","$_rgb_1_b"}"\
"{"$_rgb_2_r","$_rgb_2_g","$_rgb_2_b"}_"{3<$num_of_col?2}\
"{"$_rgb_3_r","$_rgb_3_g","$_rgb_3_b"}_"{4<$num_of_col?2}\
"{"$_rgb_4_r","$_rgb_4_g","$_rgb_4_b"}_"{5<$num_of_col?2}\
"{"$_rgb_5_r","$_rgb_5_g","$_rgb_5_b"}_"{6<$num_of_col?2}\
"{"$_point_x_0","$_point_y_0"}"\
"{$26}"\
"{$27}"\
"{"$_point_x_0","$_point_y_0"}"\
"{"$_rgb_0_r_alt","$_rgb_0_g_alt","$_rgb_0_b_alt"}"\
"{"$_rgb_1_r_alt","$_rgb_1_g_alt","$_rgb_1_b_alt"}"\
"{"$_rgb_2_r_alt","$_rgb_2_g_alt","$_rgb_2_b_alt"}"\
"{"$_rgb_3_r_alt","$_rgb_3_g_alt","$_rgb_3_b_alt"}"\
"{"$_rgb_4_r_alt","$_rgb_4_g_alt","$_rgb_4_b_alt"}"\
"{"$_rgb_5_r_alt","$_rgb_5_g_alt","$_rgb_5_b_alt"}"\
"{"$_hsl_0_h"}"\
"{"$_hsl_0_s"}"\
"{"$_hsl_0_l"}"\
"{"$_hsl_1_h"}"\
"{"$_hsl_1_s"}"\
"{"$_hsl_1_l"}"\
"{"$_hsl_2_h"}"\
"{"$_hsl_2_s"}"\
"{"$_hsl_2_l"}"\
"{"$_hsl_3_h"}"\
"{"$_hsl_3_s"}"\
"{"$_hsl_3_l"}"\
"{"$_hsl_4_h"}"\
"{"$_hsl_4_s"}"\
"{"$_hsl_4_l"}"\
"{"$_hsl_5_h"}"\
"{"$_hsl_5_s"}"\
"{"$_hsl_5_l"}"\
"{$4}"\
"{$5}"\
"{$26}"\
"{$27}"\
"{$70}"\
"{$71}"\
"{$72}"\
"{$73}"
rep_create_hsl_color_select:
skip ${2=.25},${3=0},${4=.9}
ow,oh={w#0},{h#0}
rm
$ow,$oh,1,3,"*begin(
  const ww=w-1;
  const hh=h-1;
  const cx=ww/2;
  const cy=hh/2;
  const sd=max(w,h)/min(w,h);
  const scaling=1/$4;
  const sx=(w>h?sd:1)*scaling;
  const sy=(w>h?1:sd)*scaling;
  const cxsx=cx/sx;
  const cysy=cy/sy;
  const pt=$2;
  const ipt=1/(1-pt);
  const res_atan_end=(2*pi)/360;
  const saturation=$1;
  rescale_radial(a)=(a-pt)*ipt;
  rescale_atan2(a)=(a+pi)/res_atan_end;
  hsl2rgb(hue,saturation,lightness)=(
   H=(hue/60)%6;
   C=(1-abs(2*lightness-1))*saturation;
   X=C*(1-abs(H%2-1));
   m=lightness-C/2;
   RGB=arg(1 + int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
   (RGB+=m)*=255;
  );
  hsl2ryb2rgb(hue,saturation,lightness)=(
   H=(hue/60)%6;
   C=(1-abs(2*lightness-1))*saturation;
   X=C*(1-abs(H%2-1));
   m=lightness-C/2;
   RYB=arg(1+int(H),[C,X,0],[X,C,0],[0,C,X],[0,X,C],[X,0,C],[C,0,X]);
   RYB+=m*=255;
   red=RYB[0];
   yellow=RYB[1];
   blue=RYB[2];
   white=min(RYB);
   red-=white;
   yellow-=white;
   blue-=white;
   maxyellow=max(red,yellow,blue);
   green=min(yellow,blue);
   yellow-=green;
   blue-=green;
   blue>0&&green>0?(
    blue*=2; 
    green*=2
   );
   red+=yellow;
   green+=yellow;
   maxgreen = max(red,green,blue);
   maxgreen>0?(
    N=maxyellow/maxgreen;
    red*=N;
    green*=N;
    blue*=N;
   );
   red+=white;
   green+=white;
   blue+=white;
   [red,green,blue];
  );
  if($3
  ,calc(hue,saturation,lightness)=hsl2ryb2rgb(hue,saturation,lightness);
  ,calc(hue,saturation,lightness)=hsl2rgb(hue,saturation,lightness);
  );
  ev_light=vector(#3,255);
  ev_dark=vector(#3,0);
 );
 xx=(x-cx)/cxsx;
 yy=(y-cy)/cysy;
 radial_gradient=rescale_radial(norm(xx,yy));
 inrange(radial_gradient,0,1,1,1)?(
  conical_gradient=rescale_atan2(atan2(xx,yy));
  calc(conical_gradient,saturation,radial_gradient);
 ):(
  radial_gradient>.5?ev_light:ev_dark;
 );"
######################

# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
