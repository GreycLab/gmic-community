#@gmic
#
#  File        : jerome_boulanger.gmic
#                ( G'MIC commands file )
#
#  Description : Define a set of gmic commands (mostly useful for bioimage analysis)
#
#  Copyright   : Jerome Boulanger
#
#  Licenses        : This file is 'dual-licensed', you have to choose one
#                    of the two licenses below to apply.
#
#                    CeCILL-C
#                    The CeCILL-C license is close to the GNU LGPL.
#                    ( http://cecill.info/licences/Licence_CeCILL-C_V1-en.html )
#
#                or  CeCILL v2.1
#                    The CeCILL license is compatible with the GNU GPL.
#                    ( http://cecill.info/licences/Licence_CeCILL_V2.1-en.html )
#
#  This software is governed either by the CeCILL or the CeCILL-C license
#  under French law and abiding by the rules of distribution of free software.
#  You can  use, modify and or redistribute the software under the terms of
#  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
#  at the following URL: "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
#

#---------------------------------
#
#@cli :: Input / Output
#
#---------------------------------

#@cli tiff3d
#@cli : Input a 3D tif as a 3D image
#@cli : Note: This is useful for loading several 3D image stack
tiff3d : e[^-1] "Load the file $1 as a 3D image."
 n=$!
 i $1 a[{$n}--1] z

#@cli toff3d
#@cli : Output a 3D tif as a 3D image
toff3d : e[^-1] "Save the 3D image as a tiff file."
  repeat $!
    o[$>] ${"filename \"$1\","$>}
  done

#---------------------------------
#
#@cli :: 3D Rendering
#
#---------------------------------

#@cli jeje_boundingbox3d : _separation
#@cli : Bounding box of a 3D volume
#@cli : $ 100,100,100 jeje_boundingbox3d
jeje_boundingbox3d : skip ${1=10}
  e[^-1] "3D Bounding box."
  repeat $! l[$>]
    box3d {0,w},{0,h},{0,d} p3d. 1  o3d. 1
    if $1>0
      plane3d {0,w},{0,h},$1,{round({0,h}/{0,w}*$1)} p3d. 1 o3d. .1
    fi
    rm[0] +3d
  done done

#@cli render_volume : _size,_quality,_opacity
#@cli : Pseudo volumic rendering
#@cli : $ 100,100,100 noise 1 b 10,0 max 0 r 100%,100%,100%,3,0 n 0,100 f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' render_volume
render_volume : check "${1=8}>3&${2=5}>2&${3=.1}>0"
  repeat $! l[$>]
    mirror x
    +tones {$2+1} rm[1,2] r[1--1] 100%,100%,100%,{0,s} *[1--1] [0] rm[0]
    rv
    repeat $! i=$< l[$<]
      if im!=iM
        pointcloud3d gaussians3d $1,{$3*($i+1)/$2}
      else
        rm
      fi
    done done
    +3d md3d -1 +3d .5,.5,.5
  done done

#@cli display_volume : _size,_quality,_opacity
#@cli : Display the volume with black background, a bounding box
#@cli : and a volumic rendering of the data.
#@cli : $ 100,100,100 noise 1 b 10,0 max 0 r 100%,100%,100%,3,0 n 0,100 f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' display_volume 8,5,.1
display_volume : check "${1=8}>3&${2=5}>2&${3=.1}>0"
  e[^-1] "Display_volume with size $1 quality $2 and opactiy $3."
  repeat $! l[$>]
    +jeje_boundingbox3d 20
    render_volume[0] $1,$2,$3
    +3d
  done done

d3d_black : 1 d3d[0--2] . rm.

#@cli view3d : _angle1,_angle2
#@cli : Apply a 3D view defined by two angles
#@cli : $ 50,50,50,3 noise 10 b 5 max 0 n 0,255 display_volume 32,5,1 view3d
view3d : skip ${1=25},${2=-120}
  e[^-1] "Apply 3D view."
  repeat $! l[$>]
    r3d 0,0,1,$1 r3d 1,0,0,$2
  done done

#@cli colordepth
#@cli : Color depth coding
#@cli : $ 100,100,100 noise 1 b 10,0 max 0 colordepth 5
colordepth : skip ${1=5}
  e[^-1] "Colordepth coding with LUT $1."
  repeat $! l[$>]
    colordepth_volume $1 s z +
  done done

#@cli colordepth_volume
#@cli : Make a 3D volume of the same size, color it, resize orignal in color and multiply
colordepth_volume : skip ${1=5}
  repeat $! l[$>]
    i [0] f. 'z/(d-1)*255' map. $1 r[0] 100%,100%,100%,3 *
  done done

colordepth_scale : skip ${1=5}
  10,{0,h-10} f. '(h-y)/(h-1)*255' map. $1 frame. xy,5,0,0,0

#@cli make_axis : _xmin,_xmax,_ymin,_ymax
#@cli : Display an axis around an image
#@cli : $ image.jpg make_axis 0,1,0,1
make_axis :
  e[^-1] "Add axis."
  repeat $! l[$>]
    frame xy,1,0
    100%,24,1,3,255 axes. $1,$2,{-1},{-1}
    24,{0,h},1,3,255 axes. {w},{w},$4,$3 24,24,1,3,255 a[-1,-2] y
    a[0,1] y rv a[0,1] x
    frame xy,12,255 100%,5,1,3,255,255,255 rv a y
  done done

#@cli xlabel : _label
#@cli : Add a label to the x-axis (see make_axis)
#@cli : $ image.jpg make_axis 0,1,0,1 xlabel "x-axis"
xlabel :
  e[^-1] "Add a x label."
  repeat $! l[$>]
    0 t. "$1",0,0,18,1,255,255,255 negate. +lt. 90%
    j[0] ..,{{0,w}/2+12-{1,w}/2},{{0,h}-{1,h}},0,0,1,. k[0]
  done done

#@cli ylabel : _label
#@cli : Add a label to the y-axis (see make_axis)
#@cli : $ image.jpg make_axis 0,1,0,1 ylabel "y-axis"
ylabel :
  e[^-1] "Add a y label."
  repeat $! l[$>]
    0 t. "$1",0,0,18,1,255,255,255 negate.
    rotate. -90 +lt. 90%
    j[0] ..,0,{{0,h}/2-12-{1,h/2}},0,0,1,. k[0]
  done done

#@cli title : _label
#@cli : Add a title (see make_axis)
#@cli : $ image.jpg make_axis 0,1,0,1 title "title"
title :
  e[^-1] "Add a title."
  repeat $! l[$>]
    0 t. "$1",0,0,18,1,255,255,255 negate. +lt. 90%
    j[0] ..,{{0,w}/2-{1,w}/2},0,0,0,1,. k[0]
  done done

#---------------------------------
#
#@cli :: Feature detections
#
#---------------------------------

#@cli jeje_dog : scale1, scale2
#@cli : Difference of Gaussian filter
#@cli : $ sp 1 jeje_dog
jeje_dog : skip ${1=1},${2=2}
  e[^-1] "Difference of Gaussian."
  repeat $! l[$>] +b $2 b.. $1 - done done

#@cli quiver2d
#@cli : Display a sequence 2D vector field on a 2D image sequence
#@cli : both being represented az a 3D stack
quiver2d :
  e[^-1] "Cumulative sum along z-axis."
  s z repeat $!/2 l[$>,{$>+$!/2}] quiver[0] [1],10,1,1,1,255 done done rm[{$!/2}--1] a z

#@cli warp2d : [field]
#@cli : Warp a 2D image stack using a vector field
##@cli : $ movie.cimg  a z r 50%,50% +l[0] +lucas_kanade 5,1 cumulate. z frame xy,30,0 warp2d done frame[0] xy,30,0 a x
warp2d :
  e[^-1] "Warp a 3d stack using a displacement field."
  pass$1 0 repeat $!-1 l[$>,-1]
    s z repeat $!/2 l[$>,{$>+$!/2}]
      warp[0] [1],1,1,1
    done done rm[{$!/2}--1] a z
  done done

#@cli lucas_kanade: scale,smoothing
#@cli : Motion estimation using lucas and kanade approach
#@cli : Works on 2D+t image stacks/ has side effect
#@cli : [vx vy] = [Ixx Ixy; Ixy Iyy]^-1 [Ixt Iyt]
#@cli : $ image.jpg repeat 20 +shift. 1,0,0,0,2 done a z +lucas_kanade 2 n 0,255 frame xy,2 a x
#@cli : $ image.jpg repeat 20 +shift. 1,1,0,0,2 done a z +lucas_kanade 2  s z repeat $!/2 l[$>,{$>+$!/2}] quiver[0] [1] done done rm[{$!/2}--1] a z
lucas_kanade : skip ${1=2},${2=1}
  e[^-1] "Motion estimation with Lucas et Kanade algorithm."
  repeat $! l[$>]
    b xy,$2 structuretensors 0 b xy,$1,0 # abcdef
    +l s c rm[0,-1] *[1,2] *[0,2] rv - done  # dc-be
    +l[0] s c rm[3,5] *[0,3] *[1,2] - done # ae-bc
    l[0] s c rm[2,4,5] *[0,2] sqr[1] - done # ad-b2
    /[1,2] [0] rm[0] a c
  done done

#@cli unwarp2d : iteration,scales,smoothness,keep_field
#@cli : Unwarp a 2D+T volume
#@cli : $ image.jpg repeat 20 +shift. 1,0,0,0,2 done a z unwarp2d 10,20
unwarp2d : skip ${1=5},${2=5},${3=1},${4=0}
  e[^-1] "Unwarp a 2D+t volume with $1 iterations, $2 scales and smoothing $3."
  repeat $! l[$>]
    # [1] warped [2] field
    [0] 100%,100%,100%,2,0
    repeat $1
      k=$>
      repeat $2
        # Compute scale
        if $>==($2-1) s=1 else s={($>+1)/$2} fi scale={$s*100}%
        +e $k" "$>" "$s" "$scale" "{1/$s}" "{$3*$s}
        # Compute displacement field
        +l[1]
          norm
          r $scale,$scale,100%,1
          lucas_kanade {max(.75,$3*$s)}
          * {1/$s} cumulate z
        done
        # Scale & update the displacement field
        r. ..,5 +[-1,-2]
        # Warp the original image
        +warp2d[0] [2] rm[1] rv[-1,-2]
      done
    done
    if $4==0 rm[0,2] else rm[0,1] fi
  done done

#@cli estimate_shift_core [image]
#@cli : Estimate a translation with a reference images with sub-pixel accuray
#@cli : image.jpg  luminance +shift {u},{u},0,0,2 estimate_shift[1] [0]
estimate_shift_core :
  e[^-1] "Translation estimation with Lucas et Kanade algorithm."
  pass$1 0 repeat $!-1 l[$>,-1]
    b xy,1 +g[0] xy,0 -[0,1] +sqr[1,2] +*[1,2] [0] *[1,2] rm[0]
    Ixy={0,ia} Ixx={1,ia} Iyy={2,ia} Ixt={3,ia} Iyt={4,ia}
    vx={-($Iyy*$Ixt-$Ixy*$Iyt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
    vy={-($Ixx*$Iyt-$Ixy*$Ixt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
    rm 1,2,1,1,$vx,$vy
  done done

#@cli multi_resolution_pyramide : _number_of_scales
#@cli : Build a multi-resolution pyramid
multi_resolution_pyramide :
  repeat $! l[$<]
    repeat $1-1 +r. 50%,50%,50%,100%,2 done rv
  done done

#@cli shift_subpixel : [image]
#@cli : Shift an image with subpixel translation
#@cli : $ image.jpg 1,2,1,1,5,10.1 +shift_subpixel[0] [1]
shift_subpixel :
  pass$1 0 repeat $!-1 l[$>,-1]
    {0,w},{0,h},1,2 f. 'if(c==0,{1,i(0)},{1,i(0,1)})'
    warp[0] [2],1,2,1 rm[1,2]
  done done

#@cli estimate_shift [image]
#@cli : Estimate a translations between image and ref image [image]
#@cli : using a multi-resolution scheme
#@cli : $ image.jpg luminance +shift 2,3 crop 5%,5%,95%,95% estimate_shift[1] [0],3
estimate_shift :
  e[^-1] "Estimate translation between images and image [$1]."
  pass$1 0 repeat $!-1 l[$>,-1]
    N={round(log2(min({0,w},{0,h}))-2,1,-1)}
    multi_resolution_pyramide $N
    1,2
    repeat 3 repeat $N
      # Shift at current scale
      +*. {-2.0^(-($N-$>-1))} +shift_subpixel[{$N+$>}] . rm..
      # Compute new correction
      estimate_shift_core. [$>]
      # Convert correction to image scale
      *. {2.0^($N-$>-1)}
      # Add the correction
      +[-1,-2]
    done done
    k. *. -1
  done done

#@cli unshift : iterations,number_of_scales
#@cli : Correct drift along Z in a 3D volume (video stabilization)
#@cli : $ image.jpg  luminance repeat  10 +shift. {2*u},{2*u},0,0,2 done a z +unshift 1 a x
unshift : skip ${1=1}
  e[^-1] "Unshift image stack."
  repeat $! l[$>]
    repeat $1
      s z repeat $!-1 l[$>,{$>+1}]
        +estimate_shift[1] [0] *. -1
        shift_subpixel[1] . rm.
      done done
      a z
    done
  done done

#@cli register_lucas_kanade : _iterations, _scale
#@cli : Register images using lucas kanade motion estimation
##@cli : $ movie.cimg luminance r 50%,50% a z register_lucas_kanade 5,10
register_lucas_kanade : skip ${1=10},${2=10}
  +lucas_kanade $2 cumulate. z +warp2d
  repeat $1
    lucas_kanade. $2 cumulate. z +[-1,-2] +warp2d
  done

#@cli detect_events : _scale_xy,_scale_t,_threshold
#@cli : Detect space time events using space time interest points
#@cli : $ 100,100,100 noise 1 b 2 +detect_events , pointscoordinates. r[0] 100%,100%,100%,3,1 n[0] 0,255 circles[0] [1] k[0]
detect_events : skip ${1=1},${2=1},${3=9}
  e[^-1] "Detect events with scale_xy $1 scale_z $2 and threshold $3."
  repeat $! l[$>]
    b xy,$1 b z,$2 structuretensors b xy,$1 b z,$2
    s z apply_parallel "eigen k[0] s c k[2]" a z
    sqrt
    thres={{0,ia}+$3*sqrt({0,iv})}
    +max_patch[0] 8 threshold[0] $thres *
  done done

#@cli detect_spots : _scale,_threshold
#@cli : Detect spots in the image
#@cli : $ 100,100 noise .2,2 b 1 n 0,255 noise 5 +detect_spots , pointscoordinates. r[0] 100%,100%,1,3,1 circles[0] [1] k[0]
detect_spots : skip ${1=1},${2=4}
  e[^-1] "Detect events with scale $1 and threshold $2."
  repeat $! l[$>]
    b $1 +b $1 - thres={$2*${-mad[0]}}
    +max_patch[0] 3 +threshold[0] $thres *
  done done

#@cli measure_colocalization:
#@cli : Colocalization analysis
#@cli : Overlap RG/R RG/G RG/R+G MOC M1 and M2
#@cli : $ 256,256,1,2 noise 3 b 5 measure_colocalization
measure_colocalization :
  repeat $! l[$>]
    if {0,s==2}
      # r,g,r>0,g>0,r.r,g.g,r.g,(r>0).(g>0)
      s c +gt 0 +sqr[0,1] +*[0] [1] +*[2] [3] +or[2] [3]
      O1={{7,is}/{2,is}}
      O2={{7,is}/{3,is}}
      O={{7,is}/{8,is}}
      # r,g,(r>0).g,(g>0).r,r.r,g.g,r.g,(r>0).(g>0)
      *[2] [1] *[3] [0]
      MOC={{6,is}/sqrt({4,is}*{5,is})}
      M1={{3,is}/{0,is}}
      M2={{2,is}/{1,is}}
      rm 1,6,1,1,$O1,$O2,$O,$MOC,$M1,$M2
    else
      e "Needs images with two channels"
      1,6,1,1,0,0
    fi
  done done

#@cli measure_colocalization_object:
#@cli : Compute the number of intersecting objects
#@cli : in each channels versus the number of objects
#@cli : $ 256,256,1,2 noise 3 b 5 gt 0 measure_object_colocalization
measure_object_colocalization :
  repeat $! l[$>]
    if {0,s==2}
      gt 0 s c label_fg .1
      n1=0 repeat {0,iM}
        +eq[0] {$>+1} *. [1]
        if iM>0 n1={$n1+1} fi
        rm.
      done
      n1={0,100*$n1/iM}
      n2=0 repeat {1,iM}
        +eq[1] {$>+1} *. [0]
        if iM>0 n2={$n2+1} fi
        rm.
      done
      n2={1,100*$n2/iM}
      rm
      1,2,1,1,$n1,$n2
    else
      e "Needs images with two channels"
      1,6,1,1,0,0
    fi
  done done

#@cli local_moments : _scale
#@cli : Compute local second order moments tensor
#@cli : http://en.wikipedia.org/wiki/Image_moment
#@cli : $ image.jpg +local_moments 1
local_moments : skip ${1=1}
  repeat $! l[$>]
    norm
    if d==1
      +*[0] 'x'   +*[0] 'y'   +*[0] 'x*x'
      +*[0] 'x*y' +*[0] 'y*y' b $1
      +sqr[1] /. [0] -[3,-1] /[3] [0]
      +*[1,2] /. [0] -[4,-1] /[4] [0]
      +sqr[2] /. [0] -[5,-1] /[5] [0]
      k[3-5] a c
    else
      +*[0] 'x'   +*[0] 'y'   +*[0] 'z'   +*[0] 'x*x'
      +*[0] 'x*y' +*[0] 'x*z' +*[0] 'y*y' +*[0] 'y*z'
      +*[0] 'z*z' b $1
      +sqr[1] /. [0] -[4,-1] /[4] [0]
      +*[1,2] /. [0] -[5,-1] /[5] [0]
      +*[1,3] /. [0] -[6,-1] /[6] [0]
      +sqr[2] /. [0] -[7,-1] /[7] [0]
      +*[2,3] /. [0] -[8,-1] /[8] [0]
      +sqr[3] /. [0] -[9,-1] /[9] [0]
      k[4-9] a c
    fi
  done done

#@cli smooth_moments : _scale,_iterations,_dt
#@cli : Anisotropic diffusion using local moment tensors
#@cli : $ image.jpg +noise 10 +smooth_moments. 1,10,1 print_psnr
smooth_moments : check "${1=1}>0&${2=100}>0&${3=1}>0"
  repeat $! l[$>]
    +local_moments. $1 smooth[0] [1],$2,$3,0 k[0]
  done done

#@cli pointscoordinates
#@cli : Return the list of points in the image as 3xN or 2xN columns vector
#@cli : $ 100,100 noise .1,2 ==. 1 +pointscoordinates
pointscoordinates :
  e[^-1] "Return the list of points in the image."
  repeat $! l[$>]
    if d>1
      if iM>0 pointcloud3d s3d k[2] s y,{h/3} a x else 0 fi
    else
      if iM>0 pointcloud3d s3d k[2] s y,{h/3} a x else 0 fi
      rows 0,1
    fi
  done done

#@cli circles : [x,y,radius,opacity,color,..] ||  [x,y,z,radius,opacity,color,..]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 noise. 1 n. 0,512 circles[0] [1] k[0]
circles : skip ${2=3},${3=1}
  e[^-1] "Draw circles on the image."
  pass$1 0 repeat $!-1 l[$>,-1]
    if {0,d>1} # 3D case
      if {1,h<4} r[1] 100%,{5+{0,s}},1,1,0 l[1] s y f[3] $2 f[4] $3 f[5--1] 255 a y done fi
      repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} o={1,i($>,4)} i=$>
        repeat {0,s}
          if $z>=0&$z<{0,d}-1
            sh[0] $z,$z,$> ellipse. $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,5+$>)}
            rm.
          fi
        done
      done
    else # 2D case
      if {1,h<3} r[1] 100%,{4+{0,s}},1,1,0 l[1] s y f[2] $2 f[3] $3 f[4--1] 255 a y done fi
      repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} o={1,i($>,3)} i=$> col={1,i($>,4)}
        repeat {0,s}
          sh[0] 0,0,$> ellipse. $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,{4+$>})}
          rm.
        done
      done
    fi
  done done rm.

#@cli labels : [image]
#@cli : Draw labels on the image
#@cli : The labels are defined by image as
#@cli : in 2D [x,y,label,font_size,opacity,color]
#@cli : in 3D [x,y,z,label,font_size,opacity,color]
#@cli : $ 512,512,1,3 10,2 noise. 1 n. 0,512 labels[0] [1]
labels :
  e[^-1] "Draw labels on the image."
  pass$1 0 repeat $!-1 l[$>,-1]
    if {0,d>1} # 3D case
      if {1,h<4}
        r[1] 100%,{6+{0,s}},1,1,0
        l[1] s y f[3] 'x' f[4] 13 f[5] 1 f[6--1] 255 a y done
      fi
      repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} f={1,i($>,4)} o={1,i($>,5)} i=$>
        repeat {0,s}
          if $z>=0&$z<{0,d}
            sh[0] $z,$z,$> t. $r,$x,$y,$f,$o,{1,i($i,6+$>)}
            rm.
          fi
        done
      done
    else # 2D case
      if {1,h<3}
        r[1] 100%,{5+{0,s}},1,1,0 l[1] s y f[2] 'x' f[3] 13 f[4] 1 f[5--1] 255 a y done
      fi
      repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} f={1,i($>,3)} o={1,i($>,4)} i=$>
        repeat {0,s}
          sh[0] 0,0,$> t. $r,$x,$y,$f,$o,{1,i($i,5+$>)}
          rm.
        done
      done
    fi
    rm.
  done done

#@cli croparound : [x,y,dx,dy] || [x,y,z,dx,dy,dz]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 noise. 1 n. 0,512 circles[0] [1] k[0]
croparound : skip ${2=3},${3=3},${4=3}
  e[^-1] "Crop image at coordinates."
  pass$1 0 repeat $!-1 l[$>,-1]
    if {0,d>1} # 3D case
      if {1,h<6}
        r[1] 100%,6,1,1,0
        l[1] s y f[3] $2 f[4] $3 f[5] $4 a y done
      fi
      repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} dx={1,i($>,3)} dy={1,i($>,4)} dz={1,i($>,5)} i=$>
        +crop[0] {$x-$dx},{$y-$dy},{$z-$dz},{$x+$dx},{$y+$dy},{$z+$dz}
      done
    else # 2D case
      if {1,h<4} r[1] 100%,4,1,1,0 l[1] s y f[2] $2 f[3] $3 a y done fi
      repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} dx={1,i($>,2)} dy={1,i($>,3)} i=$>
        +crop[0] {$x-$dx},{$y-$dy},{$x+$dx},{$y+$dy}
      done
    fi
  done done rm[0,1]

#@cli random_walks : width,height,length,number,speed
#@cli : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@cli : $ 100,100,20 random_walks 100,100,20,5,1 circles[0] [1] k[0] blur xy,1 s z max
#@cli : $ 100,100,20 random_walks 100,100,20,10,1 circles[0] [1] k[0] b 1 n 0,255 display_volume 8,10,1 r3d 0,0,1,25 r3d 1,0,0,-120 snapshot3d 600,1,0,0,0 autocrop
random_walks :
  number=$4 width=$1 height=$2 length=$3 speed=$5
  $number,3
  l.
    noise 1,1
    sh 0,0,0,0 n. 1,{$width-1} rm.
    sh 1,1,0,0 n. 1,{$height-1} rm.
    sh 2,2,0,0 f. 0 rm.
    repeat $length-1 +l.
      noise 1
      sh 0,0,0,0 c. 1,{$width-2} rm.
      sh 1,1,0,0 c. 1,{$height-2} rm.
      sh 2,2,0,0 f. '$>+1' rm.
    done done a x
  done

#@cli fibers: number,length,curvature
#@cli : Draw a serie of fibers in 2D or 3D
#@cli : $ 600,400 fibers 10,200,10
fibers :
  repeat $! l[$>]
    $2,$1,1,{if(d>1,3,2)}
    l. noise. 10 b. x,$3 +norm / done
    if {0,d>1} s. c *[3] {0,2*d/(w+h)} a[1--1] c fi
    cumulate. x s. y
    repeat $!-1
      l[0,{$>+1}]
        s c
        +[1] {0,w/2}
        +[2] {0,h/2}
        if $!>3 +[3] {0,d/2} fi
        a[1--1] y
        circles[0] [1],0,-1
      done
    done
    k[0]
  done done

#---------------------------------
#
#@cli :: Filtering and deconvolution
#
#---------------------------------

#@cli movavg : _size>=1
#@cli : moving average of image list with a box filter of size _size
#@cli : $ 11 f 'x>w/2' +l. s x movavg 9 a x done  +b[0] 1.2 a c display_graph
movavg : check "$1>=1"
  e[^-1] "Moving average with size $1."
  n={$1-1}
  repeat $n
    repeat $!-1 ++[{$>},{$>+1}] *. .5 rm[$>] mv. $> done
    rv
  done
  if $n%2!=0 rv fi

#@cli zmean
#@cli : average along z-axis
zmean :
  repeat $! l[$>]
    n={0,d} s z + / $n
  done done

#@cli zstd
#@cli : standard deviation along z-axis
zstd :
  repeat $! l[$>]
    +zmean sqr.
    l[0] sqr zmean done
    -- sqrt
  done done

#@cli zmax
#@cli : maximum along z-axis
zmax :
  repeat $! l[$>] s z max done done

#@cli zmin
#@cli : maximum along z-axis
zmin :
  repeat $! l[$>] s z min done done

#@cli kymoline
#@cli : interactively select a line and extract a line profile
kymoline :
  +select 1
  x1={i(0,0)} y1={i(0,1)} x2={i(0,3)} y2={i(0,4)}
  d={sqrt(($x2-$x1)^2+($y2-$y1)^2)}
  u={($x2-$x1)/$d} v={($y2-$y1)/$d}
  rm.
  f 'if(x<=$d&&y==0,i($x1+x*$u,$y1+x*$v,z,c,1),5)'
  crop 0,0,{int($d-1)},0

#@cli fftshift
#@cli : Shift a image so that the fft has it center in the middle
#@cli : $ image.jpg fftshift
fftshift :
  repeat $! l[$>]
    shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
  done done

#@cli whiten_frequency : _alpha
#@cli : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@cli : $ image.jpg whiten_frequency
whiten_frequency : check "${1=.25}>=0"
  e[^-1] "Whiten the frequency with parameter $1."
  repeat $! l[$>]
    #E={0,sqrt(iv)}
    fft +a c norm. pow. $1 max. 1e-12 /. {ia} /[0-1] [2] rm[2] ifft k[0]
    #* {$E/sqrt(iv)}
  done done

#@cli deblur_upscale_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian },zoom=2
#@cli : Deblur and zoom x2 selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
##@cli : $ sp ? +blur 2 r. 50%,50% +deblur_upscale_goldmeinel. 1,10,1.3,0,2 r[1] [0] print_psnr
deblur_upscale_goldmeinel : check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" skip ${4=1} skip ${5=1} skip ${6=2} skip ${7=0}
  e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${arg\ 1+!$4,"",quasi-}"gaussian kernel, zoom $5 and regularization $6."
  repeat $! l[$>]
    ux={if(w>1,round($5*w),1)} uy={if(h>1,round($5*h),1)} uz={if(d>1,round($5*d),1)}  # bg={im} - $bg avg={ia}
    +r. $ux,$uy,$uz,100%,6 max 0
    repeat $2
      +b. {$1*$5},1,{$4!=0} r. [0] +/[0,-1] rm.. -^. $3 r.  $ux,$uy,$uz,100%,6 *[-1,-2] max 0 # u *= f / Hu
    done rm[0] # add $bg
  done done

#@cli deblur_upscale_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }, zoom=2
#@cli : Deblur and zoom selected images using Richardson-Lucy algorithm.
#@cli : Default values: 'nb_iter=50' and 'kernel_type=1'.
##@cli : $ sp ? +blur 2 r. 50%,50% +deblur_upscale_richardsonlucy. 1,30,0,2 r[1] [0] print_psnr
deblur_upscale_richardsonlucy : check "$1>=0 && ${2=50}>=0" skip ${3=1} skip ${4=1}
  e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${arg\ 1+!$3,"",quasi-}"gaussian kernel, zoom=$4."
  repeat $! l[$>]
    ux={if(w>1,round($4*w),1)} uy={if(h>1,round($4*h),1)} uz={if(d>1,round($4*d),1)}  #bg={im} - $bg avg={ia}
    +r $ux,$uy,$uz,100%,6
    repeat $2
      +b. {$1*$5},1,{$3!=0} r. [0] +/[0,-1] rm.. r. $ux,$uy,$uz,100%,6 b. $1,1,{$3!=0} *[-1,-2] max 0 # u *= H ( f / Hu )
    done rm[0]
  done done

#@cli correlate_fft
#@cli : Convolve selected images with image [$1]
#@cli : $ image.jpg 100%,100% gaussian. 20,1,45 +correlate_fft[0] [1]
correlate_fft :
  e[^-1] "Correlate image with image [$1]."
  pass$1 0 repeat $!-1 l[$>,-1]
    w2={int({0,w}/2)} h2={int({0,h}/2)} d2={int({0,d}/2)}
    r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5  shift[1] -$w2,-$h2,-$d2,0,2
    fft[0] fft[2] *[3] -1
    +*[-4] . +*[-4] ... +[-2,-1]
    *[-5,-3] *[-3,-2] -[-3,-2]
    ifft rm.
  done done

#@cli deconvolve_richardsonlucy : filter,nb_iter>=1, acceletation>=0
#@cli : Deconvolve images using the first one as a blur operator (PSF)
#@cli : $ image.jpg 16,16 gaussian. 2,1,45 +convolve_fft[0] [1] deconvolve_richardsonlucy. [1],100
deconvolve_richardsonlucy : check ${is_image_arg\ $1}" && ${2=5}>=1"
  e[^-1] "Deblur image using Richardson-Lucy algorithm with filter [$1]."
  pass$1 0
  repeat $!-1 l[$>,-1]
    r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 normalize_sum[1] [0]
    repeat $2
      +convolve_fft. [1] max. 1e-6 +/[0] . rm..
      correlate_fft. [1] *[-1,-2]   # u *= H ( f / Hu )
    done rm[0,1]
  done done

#@cli deconvolve_goldmeinel : filter,nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg 100%,100% gaussian. 5,1,45 +convolve_fft[0] [1] +deconvolve_goldmeinel. [2],5
deconvolve_goldmeinel : check ${is_image_arg\ $1}" && ${2=5}>=1 && ${3=1}>=1"
  e[^-1] "Deblur image using Gold-Meinel algorithm with filter $1, $2 iterationsand acceleration $3."
  pass$1 0
  repeat $!-1 l[$>,-1]
    r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 normalize_sum[1]
    +b[0] 0.75
    repeat $2
      +convolve_fft. [1] max. 1e-6 +/[0] . rm..
      -^. $3 *[-1,-2] # u *= (f / Hu)^$3
    done rm[0,1]
  done done

#@cli deconvolve_richardsonlucy_blind : nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
##@cli : $ sp 1 blur_linear 1,5,45 +deconvolve_richardsonlucy_blind.
deconvolve_richardsonlucy_blind : check "${1=5}>=1"
  e[^-1] "Deblur image using richardsonlucy algorithm with $1 iterations."
  repeat $! l[$>]
    - {im-1}
    # Periodize_poisson
    avg={0,ia}
    +b 0.75
    +l.. autocorrelate threshold 10%,1 normalize_sum done
    repeat $1
      +convolve_fft[1] [2] max. 1e-6 +/[0] . rm..
      correlate_fft. [2]
      *[1,3] # u *= H (f / Hu)
      *[1] {1,$avg/ia}
      l[1] +iee *. 0.01 + done
      +convolve_fft[2] [1] max. 1e-6 +/[0] . rm..
      correlate_fft. [1]
      *[2,3] # H *= u (f / Hu)
      normalize_sum[2]
      +l +powerspectrum n 0,255 append_tiles , t $> w rm done
    done rm[0]
 done done

#@cli blend_sharpness
#@cli : Blend images in the list according to their sharpness
blend_sharpness :
  e[^-1] "Blend images according to their sharpness (gradient norm)."
  N=$! +gradient_norm
  ++[$N--1] max[$N--1] .01 /[$N--2] . rm. a[$N--1] z d. s. z
  a[0-{$N-1}] x a[1--1] x * s x,$N +

#@cli reconstruct_laplacian : param
#@cli : Reconstruct an image from its laplacian
#@cli : $ image.jpg +laplacian reconstruct_laplacian. ,
reconstruct_laplacian : skip ${1=0}
  e[^-1] "Reconstruct an image from its laplacian."
  repeat $! l[$>]
    s c repeat $! l[$>]
      fft a={0,i(0,0)} b={1,i(0,0)}
      100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
      =. 1 +. $1
      /[0,1] . k[0,1] =[0] $a =[1] $b ifft k[0]
    done done a c
  done done

#@cli local_variance : _radius,_robust
#@cli : Local variance filter
#@cli : $ image.jpg  +local_variance
local_variance : skip ${1=2},${2=0}
  e[^-1] "Estimate local variance with scale "$1" and robustness $2."
  repeat $! l[$>]
    if $2==0
      +b $1,1,1 - sqr b $1,1,1
    else
      +median {2*$1+1} - abs median {2*$1+1} * 1.4826 sqr
    fi
  done done

#@cli local_noise_variance : _radius,_robust
#@cli : Local noise variance filter
#@cli : $ image.jpg  +local_variance
local_noise_variance : skip ${1=2},${2=0}
  e[^-1] "Estimate local variance with scale $1 and robustness $2."
  repeat $! l[$>]
    laplacian if d==1 * {1/sqrt(20)} else * {1/sqrt(42)} fi local_variance $1,$2
  done done

#@cli normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@cli : Local variance normalization
#@cli : $ image.jpg  +normalize_local_variance
normalize_local_variance : skip ${1=50},${2=2},${3=25},${4=1}
  e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
  repeat $! l[$>]
    repeat $4
      +local_variance $2 sqrt. max. $3 # compute local standard deviation
      +b[0] $2,1,1 +-[0,-1] /. [1] *. $1 +[-2,-1] k. # x = <x> + alpha * (x-<x>)/<x'x>
    done
  done done

#@cli local_wiener : _radius
#@cli : Local Wiener filtering
#@cli : http://en.wikipedia.org/wiki/Wiener_filter
#@cli : $ image.jpg +noise 10 +local_wiener. 1 print_psnr
local_wiener : skip ${1=2}
  e[^-1] "Local Wiener filtering."
  repeat $! l[$>]
    sigma=${-noise_std}
    +b $1 # mean
    +local_variance[0] $1 +-. {$sigma*$sigma} rv[-1,-2] /[-1,-2] # variance
    +-[0,1] # img-mean
    *[-1,-2] +[-1,-2] k.
  done done

#@cli periodize
#@cli : Periodization of the image
#@cli : $ image.jpg periodize
periodize :
  e[^-1] "Periodize."
  repeat $! l[$>]
    if w>1 +mirror x a x fi
    if h>1 +mirror y a y fi
    if d>1 +mirror z a z fi
  done done

#@cli tape
#@cli : Apply a Hann window (e.g. to compute a power spectrum)
#@cli : $ image.jpg tape
tape :
  e[^-1] "Apply a Hann tapering window."
  repeat $! l[$>]
    if w>1 f 'i*sin(pi*x/(w-1))^2' fi
    if h>1 f 'i*sin(pi*y/(h-1))^2' fi
    if d>1 f 'i*sin(pi*z/(d-1))^2' fi
  done done

#@cli powerspectrum :
#@cli : Compute power spectrum
#@cli : $ image.jpg powerspectrum
powerspectrum :
  e[^-1] "Compute power spectrum."
  repeat $! l[$>] display_fft k[0] done done

#@cli fouriermix : [image],_cut_of_frequency
#@cli :  Mix two images using their respectives low and high frequencies
##@cli : $ image1.jpg image2.jpg +fouriermix .5
fouriermix : skip ${2=10%}
  e[^-1] "Fourier mix images."
  pass$1 0 repeat $!-1 l[$>,-1]
    fft[0] fft[2] fftshift
    # Make a mask
    100%,100% circle. 50%,50%,$2,1,1 b. 1,1,1 n. 0,1 d
    *[0,1] . negate. *[2,3] . rm. +[0,2] +[1,2] fftshift
    ifft
  done done rm.

#@cli blend_fft : [image]
#@cli : blend images using strongest frequencies
blend_fft : skip ${2=2}
  pass$1 0
  +l.
    tape powerspectrum b 1 +b 2 -
    max '{ia+$2*sqrt(iv)}' circle 50%,50%,20,1,@{0,im} n 0,1 d
    fftshift
  done fft.. *[-2,-3] . negate.
  repeat $!-3 l[$>,-1,-2,-3]
    fft[0] *[0,1] . +[0] [2] +[1] [3] ifft[0,1] rm[1]
  done done rm[-1,-2,-3]

#@cli denoise_fft : _threshold
#@cli : Illustrate the thresholding of Fourier coefficients
#@cli : $ 256,256 f '128+128*sin(x+y)' +noise 50 +denoise_fft. 70%
denoise_fft : skip ${1=1}
  e[^-1] "Threshold Fourier coefficients with threshold $1."
  repeat $! l[$>]
    +l. tape powerspectrum threshold $1 fftshift done
    fft[0] *[0] . *[1] . rm. ifft k[0]
    n 0,255
  done done

#@cli unstrip : _smoothness,_scale,_threshold
#@cli : Remove stripes in an image
#@cli : $ image.jpg f '.5*i*(1+.25*sin(x))' +unstrip
unstrip : skip ${1=25},${2=20},${3=4}
  e[^-1] "Remove stripes."
  repeat $! l[$>]
    # Create a mask
    +l.
      tape powerspectrum norm detect_spots 1,$3 dilate_circ $2 gt 0
      n 0,1 negate circle 50%,50%,$2,1,1
      if im<.9 # check if some spots have been detected
        active=1 b $1 n 0,1 fftshift if iM==0 f 1 fi
      else
        active=0
      fi
    done
    # Apply the mask
    if $active==1
      fft[0] *[0] . *[1] . rm. ifft
    fi
    k[0]
  done done

#@cli autocorrelate
#@cli : Autocorrelation using fourier transform
#@cli : $ image.jpg autocorrelate
autocorrelate :
  e[^-1] "Compute autocorrelation."
  repeat $! l[$>] fft sqr + sqrt ifft k[0] fftshift done done

#@cli spotify : _scale>0,_nb_iter>0,
#@cli : Make everything look like a spot
#@cli : Default values '_nb_iter=1, _scale=1'
#@cli : $ image.jpg +spotify 1,10
#@cli : $ image.jpg +spotify 1,20 norm. gt. 5% b 1 *
spotify : check "${1=1}>0 && ${2=1}>0"
  e[^-1] "Spotify with scale $1 with $2 iterations."
  repeat $! l[$>]
    if {0,im!=iM}
      s={0,ia}
      repeat $2
        b $1 +b {2*$1} - max 0 * '{0,$s/ia}'
      done
    fi
  done done

#@cli mapblur : _levels
#@cli : Blur the image with a map
#@cli : $ image.jpg +f '10*x/w' mapblur
mapblur : check "${1=10}>0"
  e[^-1] "Blur images using a blur map (works using pairs of images)."
  repeat $!/2 l[{2*$>},{2*$>+1}]
    smin={1,im} smax={1,iM}
    l[0] repeat $1 +b[0] {$smin+$>*($smax-$smin)/($1)} done rm[0] a z done
    l[1] tones $1 gt 0 b 1 a z done
    * s z +
  done done

#@cli vesselness : _scale>0,coefA,coefB,coefC
#@cli : Frangi's vesselness filter based on the eigen value of the Hessian
#@cli : Reference:
#@cli : A. F. Frangi, W. J. Niessen, K. . L. Vincken, M. A. Viergever,
#@cli : "Multiscale vessel enhancement filtering"
#@cli : Medical Image Computing and Computer Assisted Intervention MICCAI'98,
#@cli : vol. 1496, pp. 130 137, 1998.
##@cli : $ vessel.png +negate -vesselness. 3
vesselness : skip ${1=1},${2=1},${3=1},${4=1}
  e[^-1] "Tubeness with scale $1."
  repeat $! l[$>]
    b $1
    s c repeat $! l[$>]
      # Hessian eigen values sorted by absolute value
      hessian a c eigen k[0] +sign abs.. sort.. +,c * +norm a c
      if d>1
        f 'if(i(x,y,z,1)<0&&i(x,y,z,2)<0,exp(-0.5/$2^2*(i(x,y,z,1)/i(x,y,z,2))^2)*exp(-0.5/$3^2*(i(x,y,z,0)^2/abs(i(x,y,z,1)*i(x,y,z,2))))*(1-exp(-0.5/$4^2*i(x,y,z,3)^2)),0)'
      else
        f 'if(i(x,y,z,1)<0,exp(-0.5/($2)^2*(i(x,y,z,0)/i(x,y,z,1))^2)*(1-exp(-0.5/($3)^2*i(x,y,z,2)^2)),0)'
      fi
    done done a c
  done done

#@cli _hessian_eigen_min : scale
#@cli : Compute the min eigen value of the Hessian matrix
_hessian_eigen_min : skip ${1==1}
  e[^-1] "Compute Hessian min eigen value."
  repeat $! l[$>] b $1 s c repeat $! l[$>]
    hessian a c eigen k[0] channels {s-1}
  done done a c done done

#@cli hessian_sharpen : nscales,strength
#@cli : Sharpen the image
hessian_sharpen :
  e[^-1] "Sharpen the image using its Hessian with $1 scales and strength $2."
  repeat $! l[$>]
    repeat $1 +_hessian_eigen_min[0] {2^$>} * {2^$>/($1-1)} done +[1--1] *. {-$2} +
  done done

#@cli smurf : zoom,iter,scale,strength
#@cli : enhance linear structures
#@cli : $  1024,1024 fibers 20,2000,50 gt 0 dilate_circ 3 +dilate_circ 3 - n 0,255 negate +b 3 r. 50%,50% +smurf. 2,8,0.25,5 r[0,1] [2]
#@cli : sp duck +smurf. 1,1,1,10 c 0,255
smurf :
  e[^-1] "Smurf."
  repeat $! l[$>]  factor={exp(log($1)/($2*$3))} sigma=$3 avg={ia}
    repeat $2*$3
      +l _hessian_eigen_min $sigma +_hessian_eigen_min {3*$sigma} -
        threshold {0.1*sqrt(iv)},1 * {-$4} done +
      r. {round(w*$factor)},{round(h*$factor)},100%,100%,6 max 0 * {$avg/ia}
      sigma={$sigma*$factor}
    done
  done done

#@cli bgsubstract : _length>0
#@cli : Substract the background using a temporal top-hat filter
#@cli : $ 100,100,100 noise 1 b 1 +bgsubstract 10
bgsubstract : check "${1=5}>0"
  e[^-1] "Temporal background substraction with length $1."
  repeat $! l[$>]
    1,1,$1 f. 1 +erode[0] [1] -[0] . rm[1,-1]
  done done

#@cli schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@cli : Schizo filter gives either a furry image or a smoothed image
#@cli : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@cli : $ image.jpg +schizo 100,-50 +schizo[0] -50,100 max 0
schizo : skip ${1=100},${2=-50},${3=5},${4=.75}
  e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
  repeat $! l[$>]
    [0]
    repeat $3
      l.
        +iee *. {$1/(0.0001+max(abs(im),abs(iM)))}
        +inn[0] *. {$2/(0.0001+max(abs(im),abs(iM)))}
        +
      done
      *. $4  +*[0] {1-$4} +[-1,-2]
    done rm[0]
  done done

#@cli scandoc : _smooth,_background,_black,_white
#@cli : improve scanned document
#@cli : $ image.jpg scandoc
scandoc : skip ${1=3},${2=100},${3=10%},${4=90%}
  repeat $! l[$>] split_opacity l[0]
    median $1 +b $2 - min 0
    s c n 0,1 a c c $3,$4 n 0,255
  done a c done done

#@cli warp_affine [3x3 affine matrix]
#@cli : Warp the image [0] using an 2D affine field defined by a 3x3 matrix
#@cli : $ image.jpg 3,1,1,1,1 diagonal. noise. .1 +warp_affine[0] [1]
warp_affine :
  e[^-1] "Warp image using affine transform defined by 3x3 image [$1]."
  pass$1 0 repeat $!-1 l[$>,-1]
    params=({1,i(0,0)},{1,i(1,0)},{1,i(2,0)};\
            {1,i(0,1)},{1,i(1,1)},{1,i(2,1)};\
            {1,i(0,2)},{1,i(1,2)},{1,i(2,2)})
    {0,w},{0,h},1,1,1 +f. x +f. y a[-3--1] c
    mix_channels. $params
    channels. 1,2
    warp[0] .,0,2,0 rm.
  done done rm.

#@cli solve_least_square: X
#@cli : Solves $|Ax-b|^2$
#@cli : $  (1,1,1,1;1,2,1,2;1,1,2,2) (-1,1,0;-2,0,1) m*[1] [0] solve_least_square[0] [1]
solve_least_square :
  e[^-1] "Solves least square."
  pass$1 0 repeat $!-1 l[$>,-1]
    +transpose +m*[0,2] +m*[0,3]
    k[-1,-2] invert[0] m* transpose
  done done

#@cli calibrate_affine_transform : image
calibrate_affine_transform :
  e[] "Interactive affine transformation calibration between image and image $1"
  e[] "- Use mouse button 1 to select matching points on the two images."
  e[] "- Use mouse button 2 to remove points in the list"
  e[] "- Press Space to re-init the list of points"
  e[] "- Close the window to finish\n"
  pass$1 0 repeat $!-1 l[$>,-1] rv
    0 0 (1,0,0;0,1,0;0,0,1) Z=0
    do
      x1={*1,x} y1={*1,y}
      x2={*2,x} y2={*2,y}
      if $x1>=0
        if {*1,b}&1 # if button 1 on window 1: add pts
          (1;{$x1/{*1,w}*{0,w}};{$y1/{*1,h}*{0,h}})
          if {2,h>1} a[2,-1] x else rm[2] mv. 2 fi
        else
          if {*1,b}&2 # if button 2 on window 1: rm pts
            if {2,w>1} columns[2] 0,{2,w-2} else rm[2] 0 mv. 2 fi
          fi
        fi
      fi
      if $x2>=0
        if {*2,b}&1  # if button 1 on window 2: add pts
          (1;{$x2/{*2,w}*{1,w}};{$y2/{*2,h}*{1,h}})
          if {3,h>1} a[3,-1] x else rm[3] mv. 3 fi
        else
          if {*2,b}&2 # if button 2 on window 2: rm pts
            if {3,w>1} columns[3] 0,{3,w-2} else rm[3] 0 mv. 3 fi
          fi
        fi
      fi
      # If space bar is pressed : reinitialize
      if {*0,SPACE}" || "{*1,SPACE}" || "{*2,SPACE} rm[2,3,4] 0 0 (1,0,0;0,1,0;0,0,1) fi
      if {*1,o} Z={max(0,min({0,d}-1,$Z+{*1,o}))} wait -1 fi
      if {*2,o} Z={max(0,min({0,d}-1,$Z+{*2,o}))} wait -1 fi
      if {*3,o} Z={max(0,min({0,d}-1,$Z+{*3,o}))} wait -1 fi
      # Number of paired points
      N={min({2,w},{3,w})}
      # if each list has at least one pts
      if {2,h}>1" && "{3,h}>1
        if $N<=3 # translation
          rm[4] +l[2,3]
            rows 1,2 columns 0,{$N-1} - s x + / $N
            (1,0,0;{-i(0,0)},1,0;{-i(0,1)},0,1) rm..
          done
        else # affine
          rm[4] +l[2,3] columns 0,{$N-1} solve_least_square[0] [1] rm[1] done
        fi
      fi
      # Display first image
      +l[0,2]
        if {0,d>1} slices[0] $Z fi
        r[0] 200%,200%,1,1,5
        r[0] 100%,100%,1,3,0 grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
        if {1,h>1} rows[1] 1,2  *[1] 2
          1,5,1,1,2,1,255,0,0 r. {0,w},100%,1,1,1  circles[0] [1]
          labels[0] [1]
        fi
        w1[0] -1,-1,-1,-1,"First image (n="{1,w}")" rm
      done
      # Display second image
      +l[1,3]
        if {0,d>1} slices[0] $Z fi
        r[0] 200%,200%,1,1,5
        r[0] 100%,100%,1,3,0  shift[0] 0,0,0,1 grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
        if {1,h>1} rows[1] 1,2 *[1] 2
          1,5,1,1,2,1,255,0,0 r. {0,w},100%,1,1,1  circles[0] [1]
          labels[0] [1]
        fi
        w2[0] -1,-1,-1,-1,"Second image (n="{1,w}")" rm
      done
      # Warp image 1 and display merge
      +l[0,1,4]
        if {0,d>1} slices[0,1] $Z fi
        warp_affine[1] [2] rm[2] a c
        r[0] 200%,200%,1,100%,5
        grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
        w3 -1,-1,-1,-1,"merge "$N" Z="$Z rm
      done
      wait
    while {*1}" && "!{*1,Q}" && "!{*1,ESC}" && "{*2}
    w1[] 0 w2[] 0 w3[] 0
    k.
  done done

#@cli vobs : _scale
#@cli : Motion quantity (Normal motion)  h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2
#@cli : Irani, Michal and Rousso, Benny and Peleg, Shmuel, Detecting and tracking multiple moving objects using temporal integration, ECCV'92.
#@cli : $ 100,100,10 noise 1 b 1 +vobs
vobs : check "${1=1}>0 && ${2=3}>0"
  e[^-1] "Motion quantity with scale $1."
  repeat $! l[$>]
    g a[0,1] c norm[0] abs[1] *[1] [0] sqr[0] b $1,1,1 rv max[1] 5% /
  done done

#@cli display_vobs
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 noise .7,2 ==. 1 b 2,1,1 repeat 20 +l. +laplacian *. .05 + done done  a z display_vobs
display_vobs :
  +vobs 1 A={round(im,0.001)} B={round(iM,0.001)} *. '{128/max(im,iM)}' +. 128  map. 5
  r[0] 100%,100%,100%,3,1 apply_gamma[0] 1.5 n[0] 0,255
  l[0] s z frame x,5,64 frame y,12,64 shift 0,5,0,0,2 t "Original sequence",5,0,13,1,255 a z done
  l[1] s z repeat $! l[$>] 1,100% f. 'h-y' n 0,255  map. 5 r. 5,{0,h},1,3,5 frame. x,3,64  r. 100%,{0,h},1,3,5 a x
  frame x,5,64 frame y,12,64 shift 0,5,0,0,2
  t "Vobs ["$A":"$B"]",5,0,13,1,255 done done a z done
  a x

#@cli display_pseudocolor : predefined_palette
#@cli : Display an indexed image in pseudocolors using a palette
#@cli : $ image.jpg luminance display_pseudocolor
display_pseudocolor : skip ${1=5}
  e[^-1] "Display an indexed image in pseudocolors using map $1."
  repeat $! l[$>]
    A={round(im,0.0001)} B={round(iM,0.0001)}
    n. 0,255 map. $1
    rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
    add_colorbar. {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255
  done done

#@cli display_colordepth : _dz
display_colordepth :
  e[^-1] "Display the 3D image with a depth color coded."
  repeat $! l[$>]
    H={d*$1} colordepth , a z min {ia+10*sqrt(iv)} n 0,255 s z
    rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
    add_colorbar. {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
  done done

#@cli map_hilo
#@cli : Map a grascale image to a RGB with maw in red and min in blue
#@cli : This help to check if images are saturated
map_hilo :
  repeat $! l[$>]
    round m={0,im} - $m
    1,1,1,3,0,0,{0,iM} {0,iM-1},1,1,3,'x+1' 1,1,1,3,{0,iM},0,0 a[1,2,3] x
    map[0] [1]
    + $m rm[1]
  done done

#@cli add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@cli : Add a colorbar
#@cli : $ image.jpg luminance map 5 add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar : skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
  e[^-1] "Add a colorbar."
  repeat $! l[$>]
    {$3-$1},{$4-$2} l. f 'h-y' n 0,255 map $10 done
    frame[1] xy,1,$8 j[0] [1],$1,$2,0,0,1 k[0]
    repeat $7
      val={round($5+$>/($7-1)*($6-$5),.001)}
      t "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
    done
  done done

#@cli local_diffusion_coefficient : _scale,_threshold
#@cli : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@cli : $ 100,100 noise .7,2 ==. 1 b 2,1,1 repeat 20 +l. +laplacian *. .05 + done done  a z local_diffusion_coefficient 2,.5
local_diffusion_coefficient : check "${1=2}>0 && ${2=.5}>=0"
  e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2."
  repeat $! l[$>]
    +l[0] s z laplacian a z done           # Ixx+Iyy
    +l[0] s z gradient_norm a z sqr done  # ||Ix+Iy||^2
    g[0] z,1                            # It
    l[0,1] # try to compute It/Ixx+Iyy as stably as possible
      R={1,ia+$2*sqrt(iv)}
      a c f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
      channels 0
    done
    *[0] [1] b $1,1,1 max[1] {1,ia+$2*sqrt(iv)}  /
    channels 0
  done done

ldc :
  local_diffusion_coefficient $*

ldc_residuals :
  +l[0] s z laplacian a z done
  g[0] z,1
  *[1,2]
  -- abs b 1

#@cli display_ldc :
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 noise .7,2 ==. 1 b 2,1,1 repeat 20 +l. +laplacian *. .05 + done done  a z display_ldc
display_ldc :
  +ldc 2,3 A={round(im,0.001)} B={round(iM,0.001)} *. '{128/max(im,iM)}' +. 128  map. 5
  r[0] 100%,100%,100%,3,1 apply_gamma[0] 1.5 n[0] 0,255
  l[0] s z frame x,5,64 frame y,12,64 shift 0,5,0,0,2 t "Original sequence",5,0,13,1,255 a z done
  l[1] s z repeat $! l[$>] 1,100% f. 'h-y' n 0,255  map. 5 r. 5,{0,h},1,3,5 frame. x,3,64
  r. 100%,{0,h},1,3,5 a x
  frame x,5,64 frame y,12,64 shift 0,5,0,0,2
  t "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 done done a z done
  a x

#@cli print_psnr : _max_value
#@cli : Display the psnr on the image list taking the first one as a reference
#@cli : $ image.jpg +noise 20 +b. 1 print_psnr
print_psnr : skip ${1=255}
  e[^-1] "Compute PSNR with image 0 and print it on the other images."
  +psnr $1
  repeat $!-2 to[{$>+1}] "PSNR:"{round(i(0,$>+1),.01)}"dB",5,5,30,1 done
  rm.

#@cli noise_std
#@cli : Estimate the noise variance
#@cli : $ image.jpg noise 10 sigma={round(${-noise_std},.1)} to "Noise std:"$sigma,5,5,30,1
noise_std :
  e[^-1] "Compute noise std."
  +laplacian if {0,d==1} u {${-mad.}/sqrt(20.0)} else u {${-mad.}/sqrt(42.0)} fi rm.

#@cli jeje_pca
#@cli : Principal component analysis
#@cli : $ image.jpg +l split_tiles 64,64 y y a x jeje_pca k. s x r 8,8,1,1,-1 n 0,255 frame xy,1,255 append_tiles , r. 400%,400% frame y,20 title dictionary done
jeje_pca :
  e[^-1] "Principal component analysis."
  repeat $! l[$>]
    n={w} - {ia} +transpose. m*[-2,-1] / $n eigen
  done done

jeje_spca : skip ${2=20}
  repeat $! l[$>]
    repeat $2
      p={sqrt(h)}
      +l +jeje_pca k[0,-1]  rv transpose[0] +m* threshold. $1,1 rm[1] transpose[0] m* done
      *[0] .25 *[1] .75 +
    done
    jeje_pca
  done done

#@cli denoise_karmuen_loeve : _number_of_components
#@cli : Denoise with a bloc Karumen-Loeve transform
#@cli : http://en.wikipedia.org/wiki/Karhunen%E2%80%93Lo%C3%A8ve_theorem
##@cli : $ image.jpg +noise 10 +denoise_karmuen_loeve. 8 print_psnr
denoise_karmuen_loeve :
  repeat $! l[$>]
    split_tiles 64,64 oW={0,w} oH={0,h} oS={0,s}
    y y a x +jeje_pca k[0,-1] rv crop[0] 0,$1
    transpose[0] +m* rm[1] transpose[0] m* s x
    r $oW,$oH,1,$oS,-1 append_tiles ,
  done done

#@cli denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@cli : Denoising using a dictionnary of patches learned on the image
#@cli : $ image.jpg +noise 10 +denoise_patch_dict[1] , print_psnr
denoise_patch_dict : skip ${1=8},${2=8},${3=1.1},${4=1.1}
  e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
  repeat $! l[$>]
    Sigma=${-noise_std[0]} # measure the noise level
    # mirror to prevent side effect
    +crop 0,0,$1,100% mirror. x rv +crop. {w-$1-1},0,100%,100% mirror. x a x
    +crop 0,0,100%,$1 mirror. y rv +crop. 0,{h-$1-1},100%,100% mirror. y a y
    # resize the image to get integer nb of tiles (using mirrored version)
    oW={0,w} oH={0,h} oS={0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
    +crop {2*$oW-$nW},0,100%,100% mirror. x a x
    +crop 0,{2*$oH-$nH},100%,100% mirror. y a y
    NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
    # compute a dictionnary (use several shifts)
    +l.
      repeat $2
        if $2>1 dx={round(u(0,$1))} dy={round(u(0,$1))} else dx=0 dy=0 fi
        +shift[0] $dx,$dy,0,0,2
        split_tiles. $NtileX,$NtileY pW={1,w} pH={1,h} # split the image
      done rm[0]
      y y a x n={w} - 'ia' +transpose. m*[-2,-1] / $n eigen # PCA
      # select components based on noise level
      l.. unroll x sqrt gt {$3*$Sigma} f 'abs(i(x+1)-i(x))' T={[xM,yM,zM,cM]} 4 f. $T T={i(0)} done
      if $T==0 T=100% fi k. columns 0,$T
    done
    # Denoise the image using the dictionnary
    repeat $2
      if $2>1 dx={round(u(0,$1))} dy={round(u(0,$1))} else dx=0 dy=0 fi
      +shift[0] $dx,$dy,0,0,2
      l[1,-1]
        l[1] split_tiles $NtileX,$NtileY unroll y a x done
        transpose[0] +m*                # project on the dictionnary
        t=${-mad.}                     # estimate variance of coefficients
        f. 'if(abs(i)<$4*$t,0,i)'     # threshold the coefficients
        rm[1] transpose[0] +m* rm.. # project back
      done
      l.
        s x r $pW,$pH,1,$oS,-1
        append_tiles $NtileX,$NtileY
        shift {-$dx},{-$dy},0,0,2
      done
    done
    rm[0,1]
    + / $2
    crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
  done done

std_noise :
   +laplacian. u {${-mad.}/sqrt(if(d==1,20,42))} rm.

#@cli iuwt : _nlevels>2,_spline>1
#@cli : Compute the "isotropic undecimated wavelet transform" using
#@cli : a trou algorithm for the B3-Spline wavelet.
#@cli : The inverse is obtained as the sum of all coefficients
#@cli : $ image.jpg iuwt 4,1 n 0,255 append_tiles
#@cli : $ image.jpg iuwt 3,1 +
iuwt : skip ${1=3},${2=3}
  e[^-1] "Compute isotropic undecimated wavelet transform."
  repeat $! l[$<]
    # Compute the Spline filter by succesive convolutions
    50
    l.
      f 'if(x==w/2|x==w/2-1,1,0)' i [0]
      repeat $2 convolve. [0] done
      k. autocrop 0 / {ia*w}
    done
    # Compute the decomposition
    repeat $1-1
      l[-1,-2]
        +convolve[0] [1]
        y[1] y convolve. [1]
        +-[0] . rm[0] rv
      done
      # add trou for the next scale
      l. y y 100% a x s y s x rm. a x done
    done
    rm. rv
  done done

#@cli iuwt_std : _nlevels>2,_spline>1
#@cli : Compute noise at each level of the iuwt
#@cli : $ image.jpg iuwt_std 10,10
iuwt_std :
  repeat $! l[$>]
    sigma=${-noise_std}
    if 1 # experimental measure
      f 1 noise $sigma iuwt $1,$2
      repeat $! l[$>]
        x={sqrt(iv)} rm 1 f $x
      done done a x
    else rm # try a theoritical formula (failed)
      50
      l.
        f 'if(x==w/2|x==w/2-1,1,0)' i [0]
        repeat $2 convolve. [0] done
        k. autocrop 0 / {ia*w}
      done
      sqr
      alpha={is} rm
      $1,1,1,1,'$sigma*sqrt((1+$alpha)*$alpha^(w-x-1))'
    fi
   done done

#@cli denoise_iuwt :_threshold>0,_nlevels>2,_spline>1
#@cli : Denoising by thresholding the coefficients of the
#@cli : "isotropic undecimated wavelet transform"
#@cli : $ image.jpg +noise 10 +denoise_iuwt. , print_psnr
denoise_iuwt : check "${1=1.4}>0&&${2=4}>1&&${3=1}>0"
  e[^-1] "Denoise using the isotropic undecimated B$3 spline wavelet transform."
  repeat $! l[$>]
    # Compute noise std at each level
    +iuwt_std[0] $2,$3 rv
    # compute the wavelet coefficient and threshold them
    iuwt. $2,$3
    repeat $!-2 threshold[{$>+2}] {0,$1*i($>+1)},1 done
    # reconstruct
    +[1--1]
    rm[0]
  done done

#@cli noise_poisson_gaussian : gain,offset,noise_std
camera_noise :
  repeat $! l[$>]
    noise 0,3 * $1 + $2 noise $3
  done done

#@cli analyze_camera_noise :
analyze_camera_noise :
  repeat $! l[$>]
    +local_noise_variance $1 b[0] $1 y a c
    display_parametric 800,600,.0,1,1,0,signal,noise
 done done

#@cli dehaze : scale,gamma1,min_va,max_val,gamma2
#@cli : Dehaze an image using Dark Channel Prior appraoch
#@cli : return the dehazed image and a transmittance image
##@cli : $ http://media.lcpc.fr/ext/img/prod/frida/K080-000000.jpg r 600,400,1,3,5 +dehaze
dehaze : skip ${1=5},${2=1},${3=.2},${4=1},${5=0},${6=0},${7=0}
  repeat $! l[$>]
    # Atmospheric light estimation
    +l
      +l s c min b 10 erode_circ $1 dilate_circ $1  done
      gt. 80% *
      s c aR={0,iM} aG={1,iM} aB={2,iM} rm
    done
    # transmitance map estimation
    +l
      s c /[0] $aR /[1] $aG /[2] $aB
      repeat 10 median 3 erode_circ $1 dilate_circ $1 done
      min f 'max($3,min($4,1-0.95*i))'
    done
    # correction
    pow[1] $2
    s[0] c -[0] $aR -[1] $aG -[2] $aB
    /[0-2] [3]
    +[0] $aR +[1] $aG +[2] $aB a[0-2] c
    c[0] 0,255
    adjust_colors[0] $5,$6,$7
  done done

#---------------------------------
#
#@cli :: Segmentation
#
#---------------------------------

#@cli contour2d : _tolerance
#@cli : Draw a 2D contour of regions with tolerance _tolerance
#@cli : Default value _tolerance=.1
#@cli : $ image.jpg norm b 1 gt 50% +contour2d
contour2d : skip ${1=.1}
  f 'if(abs(i-j(1,1))>$1||abs(i-j(1,0))>$1,1,0)'

#@cli segment_snake : _nb_iter,_time_step,_lambda,_threshold,_smoothness
#@cli : Segment an image using an adaptation of Chan and Vese's method.
#@cli : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@cli : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@cli : $ 256,128 t "GMIC",40,10,100,1,255 b 1 noise 20 +segment_snake , contour2d. , r. 100%,100%,1,3,0 n 0,255 +
segment_snake : skip ${1=100},${2=1},${3=.1},${4=.1},${5=10},${6=0}
  e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
  repeat $! l[$>]
    if s>1 luminance fi
    +b $5 gt. {ia+$4*sqrt(iv)}                                # initialization
    l. +distance 0 negate[0] distance[0] 0 *[0] -1 + done # levelset
    repeat $1
      # compute mean and variance of the two regions (original version is with mean only)
      # the molified step function is given by a blur of the sharp step function
      +lt. 0 b. 1 +*[0,-1] swx={ia} sw={-2,ia} M1={$swx/$sw}
      sqr. swx2={ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} rm[-1,-2]
      +gt. 0 b. 1 +*[0,-1] swx={ia} sw={-2,ia} M2={$swx/$sw}
      sqr. swx2={ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} rm[-1,-2]
      +iee.                                                     # regularization
      +f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)' # data term
      +[-2,-1]
      *. {$2/(0.0001+max(abs(im),abs(iM)))}           # adaptive time step
      +[-2,-1]
      if $6==1 # if display
      +l gt[1] 0 contour2d[1] , n 0,1 -a c t $>,0,0,13,1,{iM} w wait 10  rm done
      fi
      #if $>%10 l. gt 0 +distance 0 negate[0] distance[0] 0 *[0] -1 + done fi
    done
    #  +e "("$M1","{sqrt($S1)}");("$M2", "{sqrt($S2)}")"
    b. 1 gt. 0 rm[0]
  done done

#@cli segment_cells : scale1,scale2,threshold,size_threshold
#@cli : Cell segmentation using watershed
#@cli : $ 256,256 noise .05,2 ==. 1 b 10,1,1 min 80% noise 5% +segment_cells 2,10% contour2d. , r. 100%,100%,1,3,0 n 0,255 +
segment_cells : skip ${1=3},${2=10},${3=1},${4=3}
  e[^-1] "Cell segmentation using difference of Gaussians and watershed."
  repeat $! l[$>]
    jeje_dog $1,$2 +gt {ia+$3*${-mad}} area_fg 0 gt $4 +distance[1] 0
    max_patch[0] {round($4,1,1)} *[0] [1] label[0] 0 watershed[0] [2] rm. *
  done done

#@cli zernike :
zernike :
  skip  ${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=0},${12=0},${13=0},${14=0},${15=0},${16=0},${17=0},${18=0}
  f 'r=sqrt((x-$1)^2+(y-$2)^2);if(r<$3,a=atan2(y-$2,x-$1);$4+$5*2*r*sin(a)+$6*r*cos(a)+$7*sqrt(6)*r^2*sin(2*a)+$8*sqrt(3)*(2*r^2-1)+$9*sqrt(6)*r^2*cos(2*a)+$10*sqrt(8)*r^3*sin(3*a)+$11*sqrt(8)*(3*r^3-2*r)*sin(a)+$12*sqrt(8)*(3*r^3-2*r)*cos(a)+$13*sqrt(8)*r^3*cos(3*a)+$14*sqrt(10)*r^4*sin(4*a)+$15*sqrt(10)*(4*r^4-3*r^2)*sin(2*a)+$16*sqrt(5)*(6*r^4-3*r^2)*cos(2*a)+$17*sqrt(10)*(4*r^4-3*r^2)*cos(2*a)+$18*sqrt(10)*r^4*cos(4*a),0)'

#---------------------------------
#
#@cli :: Patterns
#
#---------------------------------

_challenge :
  108,86,1,3 l. fractional_brownian_motion .25  n 0,128 +norm gt. 60% * r 1080,860,1,3,1  +l. b 10 shift. 10,10 done max crop 10,10,100%,100% negate done n 0,255

#@cli periodic_dots : _nb_angles,_scale,_start_angle
#@cli : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@cli : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
##@cli : $ 64,64 periodic_dots 3,6,.1 repeat 34 i [0] done append_tiles
periodic_dots : skip ${1=6},${2=4},${3=.5}
  e[^-1] "Generate a periodic dot pattern with $1 angles, scale $2, and orientation $3."
  repeat $! l[$>]
    s c repeat $! l[$>]
      +r {max(w,h)},{max(w,h)},100%,100%,0
      l.
        f 0
        repeat $1
          circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
        done
        fft a c norm fftshift n 0,255
      done
      ri. [0],0
      k.
    done done a c
  done done

#@cli turing_pattern : iter,dt,a,b,q,r,D
#@cli : Generate Turing pattern using a rection-diffusion equation
#@cli : du/dt = au(1-qv²) + v(1-ru)
#@cli : dv/dt =  v(b-aquv) + u(-a+rv)
#@cli : the two parameters q and r are dictating the pattern final shape
#@cli : the diffusivity parameter influcences the scale
#@cli : http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf
#@cli : http://eprints.maths.ox.ac.uk/430/1/102.pdf
turing_pattern : skip ${1=2000},${2=.1},${3=0.855},${4=-0.95},${5=2},${6=.1},${7=.5},${8=0}
  repeat $! l[$>]
    r 100%,100%,100%,2 b 1 n 0,1
    repeat $1
      progress {$>/$1*100}
      +laplacian[0] mix_channels. ($7,0;0,1)
      +f[0] 'u=i(x,y,z,0);v=i(x,y,z,1);a=$3;b=$4;q=$5;r=$6;if(c==0,a*u*(1-q*v*v)+v*(1-r*u),v*(b+a*q*u*v)+u*(-a+r*v))'
      +[-1,-2]
      *. {$2/(1+max(abs(im),abs(iM)))}
      +
      if $8==1 +l s c n 0,1 a c t $> w rm done fi
    done
    s c n 0,1 a c
  done done

#@cli rays : _center_x,_center_y,_scale,_phase
#@cli : Generate rays patterns
#@cli : $ image.jpg +rays 155,127,10,10 n. 0,1 *
rays :
  e[^-1] "Generate a ray pattern centered in ($1,$2)."
  f 't=atan2(y-$2,x-$1);sin($3*t+$4)'

#@cli fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@cli : Generate fractional brownian motion nd signal
#@cli : Using a power low of the form (eps+|f|)^(-2^H-1)
#@cli : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@cli : (see also 'clouds')
#@cli : $ 400,300 fractional_brownian_motion
fractional_brownian_motion : skip ${1=.5},${2=1} check "$1>=0&&$1<=1" check "$2>0"
  e[^-1] "Generate pseudo fractional brownian motion."
  repeat $! l[$>]
    f 0 noise 1
    fft fftshift
    if {0,d==1}
      f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
    else
      f 'rx=x-w/2;ry=y-h/2;rz=z-d/2;i*($2+sqrt(rx*rx+ry*ry+rz*rz))^(-2*$1-1)'
    fi
    fftshift ifft
    k[0]
  done done

#@cli clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@cli : Generate clouds on the image (see also 'fractional_brownian_motion')
#@cli : $ 64,64 repeat 3 +clouds {10+20*$>}% done rm[0]
clouds : skip ${1=50%},${2=1},${3=.5},${4=1}
  e[^-1] "Generate a cloud."
  repeat $! l[$>]
    channels 0
    fractional_brownian_motion $3,$4 negate min $1 negate r 100%,100%,1,4
    n 0,255 s c n[0-2] 190,255  n[3] 0,255 a c
  done done

#@cli clearbluesky :
#@cli : Generate a Clear Blue Sky
#@cli : $ 400,300,1,3 clearbluesky +clouds 50% blend alpha
clearbluesky :
  e[^-1] "Generate a blue sky."
  repeat $! l[$>]
    1,2,1,3 f. '63,70,120,144,190,215' r. [0],5 k.
  done done

#@cli mm_mozaic : size
#@cli : Create a mozaic image from the selected image
#@cli : sp ? mm_mozaic
mm_mozaic : skip ${1=1}
  repeat $! l[$>]
    +gradient_norm negate.
    +l. b. .75 +ge $1 max_patch.. 3 d * done to_rgb. *[0,2] d
    watershed.. . rm.
  done done

segment_watershed2 : check "${1=2}>=0"
  e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
  repeat $! l[$>]
    min={im}
    + {1+$min} +gradient_norm
    if d>1 +f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
    else +f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    fi
    *[-3,-1] *. -1 watershed.. . rm.
    - {1+$min}
  done done

#@cli freqy_pattern
#@cli : Create a periodic pattern containing a lot of frequencies
#@cli : sp ? freqy_pattern
freqy_pattern : skip ${1=1%},${2=100}
  e[^-1] "Generate a periodic pattern with many frequencies with parameter $1,$2."
  repeat $! l[$>]
    fftpolar +gaussian $1 *[0] [2] rm. ifftpolar rm. n 0,{$2*pi} sin
  done done

#---------------------------------
#
#@cli ::  Colors
#
#---------------------------------

#@cli wavelength_color : _wavelength
#@cli : Convert a wavelength [380,780] to RGB color
#@cli : from http://scienceprimer.com
#@cli : $ 1,1,1,1,1 repeat 100 +wavelength_color[0] {380+3*$>} done rm[0] a x
wavelength_color :
  if $1>=380&$1<440
    R={-1*($1-440)/(440-380)}
    G=0
    B=1
  elif $1>=440&$1<490
    R=0
    G={($1-440)/(490-440)}
    B=1
  elif $1>=490&$1<510
    R=0
    G=1
    B={-1*($1-510)/(510-490)}
  elif $1>=510&$1<580
    R={($1-510)/(580-510)}
    G=1
    B=0
  elif $1>=580&$1<645
    R=1
    G={-1*($1-645)/(645-580)}
    B=0
  elif $1>=645&$1<780
    R=1
    G=0
    B=0
  else
    R=0
    G=0
    B=0
  fi
  repeat $! l[$>]
    mix_channels ($R;$G;$B)
  done done

#---------------------------------
#
#@cli ::  GIMP
#
#---------------------------------
#@gui _<b>Details</b>

#@gui Sharpen [Whiten] : jeje_whiten_frequency, jeje_whiten_frequency_preview(0)
#@gui : Alpha = float(50,0,100)
#@gui : Cut = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter equalizes frequencies in the image.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/06/01</i>.</small>")
jeje_whiten_frequency :
  repeat $! l[$>] split_opacity l[0]
    whiten_frequency {exp($1/100)-1}
    if $2 c 0,255 n 0,255 else n 0,255 fi
  done a c done done

jeje_whiten_frequency_preview :
  gui_split_preview "jeje_whiten_frequency $1,$2",$-1

#@gui Sharpen [Hessian] : jeje_hessian_sharpen, jeje_hessian_sharpen_preview(0)
#@gui : Number of scales = int(3,2,10)
#@gui : Strength = float(1,0,10)
#@gui : Repeat = float(1,1,5)
#@gui : Cut = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2019/04/30</i>.</small>")
jeje_hessian_sharpen :
  repeat $! l[$>]
    split_opacity l[0] repeat $3 hessian_sharpen $1,$2 done done a c
    if $4 c 0,255 n 0,255 else n 0,255 fi
  done done

jeje_hessian_sharpen_preview :
  gui_split_preview "jeje_hessian_sharpen $1,$2,$3,$4",$-1

#@gui _<b>Repair</b>
#@gui Smooth [Block PCA]: jeje_denoise_patch_dict, jeje_denoise_patch_dict_preview(0)
#@gui : Patch = choice(1,4,8,16,32)
#@gui : Cycles = int(8,1,32)
#@gui : Components = float(1.1,1,9)
#@gui : Coefficients = float(1.1,0,9)
#@gui : Remix = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter is quite time consuming.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
jeje_denoise_patch_dict :
  +denoise_patch_dict {2^($1+2)},$2,$3,$4
  *[0] $5 *[1] {1-$5} + c 0,255

jeje_denoise_patch_dict_preview :
  gui_split_preview "jeje_denoise_patch_dict ${1--2}",$-1

#@gui Smooth [Wiener] : jeje_local_wiener, jeje_local_wiener_preview(0)
#@gui : Scale = float(2,.5,10)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_local_wiener :
  ac "local_wiener $1",$2,$3

jeje_local_wiener_preview :
  gui_split_preview "jeje_local_wiener $*",$-1

#@gui Smooth [IUWT] : jeje_denoise_iuwt,jeje_denoise_iuwt_preview(0)
#@gui : Threshold = float(3,0,10)
#@gui : Number of Scales = int(4,2,6)
#@gui : Wavelet = choice(2,"Spline B1","Spline B2","Spline B3","Spline B4","Spline B5","Spline B6")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small><b>Note:</b>Denoise the image by thresholding the coefficient of the Isotropic Undecimated Wavelet Transform.</small>")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/17/12</i>.</small>")
jeje_denoise_iuwt :
  denoise_iuwt $1,$2,{$3+1}

jeje_denoise_iuwt_preview :
  gui_split_preview "jeje_denoise_iuwt $1,$2,$3",$-1

#@gui Unstrip : jeje_unstrip, jeje_unstrip_preview(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Size = float(20,1,50)
#@gui : Sensitivity = float(4,1,10)
#@gui : Normalize = bool(true)
#@gui : FFT Preview = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/10</i>.</small>")
jeje_unstrip :
  unstrip $1,$2,$3
  if $5 tape powerspectrum
  else
    if -$4 n 0,255 else c 0,255 fi
  fi

jeje_unstrip_preview :
  gui_split_preview "jeje_unstrip $1,$2,$3,$4,$5",$-1

#@gui Repair Scanned Document : jeje_scandoc, jeje_scandoc_preview(0)
#@gui : note = note(Use filter is useful to post process document you scan with a digital camera. It peforms smoothing, background correction and white balance adjustement)
#@gui : Smoothness = int(3,1,7)
#@gui : Background = float(1,10,100)
#@gui : White Level = float(90,0,100)
#@gui : Black Level = float(5,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/11/03</i>.</small>")
jeje_scandoc :
  scandoc $1,$2%,$3%,$4%

jeje_scandoc_preview :
  gui_split_preview "jeje_scandoc $1,$2,$3,$4",$-1

#@gui _<b>Patterns</b>
#@gui Periodic Dots : jeje_periodic_dots, jeje_periodic_dots_preview
#@gui : Number = int(6,2,32)
#@gui : Scale = float(4,1,12)
#@gui : Angle = float(0,0,360)
#@gui : Repeat = int(1,1,10)
#@gui : Map = choice(None,default,HSV,lines,hot,cool,jet,flag,cube)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_periodic_dots :
  tW={max(w,h)/$4}
  $tW,$tW
  periodic_dots. $*
  repeat $4*$4-1
    i .
  done
  append_tiles[1--1] $4,$4 k.
  if $5>0 n 0,255 map {$5-1} fi

jeje_periodic_dots_preview :
  jeje_periodic_dots $*

#@gui Turing : jeje_turing_pattern,gui_no_preview
#@gui : Scale = float(1,0,1)
#@gui : Iterations = int(2000,1,10000)
#@gui : Time Step = float(.1,.01,1)
#@gui : Alpha = float(.899,0,2)
#@gui : Beta = float(-.91,-2,2)
#@gui : Q = float(2,0,3)
#@gui : R = float(.1,0,3)
#@gui : Diffusivity = float(.25,.01,.6)
#@gui : sep = separator(), note = note(<small>Generate turing pattern using a system of coupled reaction/diffusion equations. The patterns can change from line to spots like structures depending on the parameters. You may use the 'Stencil' filter to achieve similar effects. http://en.wikipedia.org/wiki/The_Chemical_Basis_of_Morphogenesis</small>), note=note(<small>Since the computation is long there is no preview. </small>)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/01/16</i>.</small>")
jeje_turing_pattern :
  +l
    r {$1*w},{$1*h},1,2
    turing_pattern $2,$3,$4,$5,$6,$7,$8
  done
  r[1] 100%,100%,100%,3,0 r[1] [0],[0],1,100%,5 rm[0] b .75 n 0,255

#@gui Clouds : jeje_clouds, jeje_clouds_preview
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(.5,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_clouds :
  +clouds $1%,1,$2 blend alpha

jeje_clouds_preview :
  jeje_clouds $1,$2

#@gui Strip : jeje_strip, jeje_strip_preview
#@gui : Angle = float(45,0,90)
#@gui : Frequency = float(50,0,100)
#@gui : Phase =  float(0,0,180)
#@gui : Amplitude = float(1,0,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_strip :
  theta={pi*$1/180}
  f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
  c 0,255

jeje_strip_preview :
  gui_split_preview "jeje_strip $*",$-1

#@gui Rays : jeje_rays, jeje_rays_preview
#@gui : X Center = float(50,0,100)
#@gui : Y Center = float(50,0,100)
#@gui : Frequency = float(10,0,100)
#@gui : Angle = float(0,0,360)
#@gui : Proportion = float(0.5,0,1)
#@gui : Color 1 = color(255,0,0)
#@gui : Color 2 = color(255,255,0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2023/07/13</i>.</small>")
jeje_rays :
  foreach {
    100%,100% rays. {[w*$1,h*$2]%},$3,$4 gt. {$5*100}%
    ($6,$9^$7,$10^$8,$11) map.. . rm[0,-1]
  }

jeje_rays_preview :
  gui_split_preview "jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1

#@gui Fibers : jeje_fibers, jeje_fibers_preview
#@gui : Number = int(10,1,100)
#@gui : Length = int(50,1,100)
#@gui : Smoothness = float(10,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/07/17</i>.</small>")
jeje_fibers :
  100%,100%,1,1,0
  l.
    fibers $1,$2%,$3
    gt 0
    n 0,255
  done
  r. [0]
  max

jeje_fibers_preview :
  gui_split_preview "jeje_fibers $1,$2,$3",$-1

#@gui Freqy Pattern : jeje_freqy_pattern, jeje_freqy_pattern_preview
#@gui : Random = float(50,0,100)
#@gui : Scale 1 = float(33,1,100)
#@gui : Scale 2 = float(50,1,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/09/25</i>.</small>")
jeje_freqy_pattern :
  noise {$1*4}
  freqy_pattern {50/$2}%,{$3*2} n 0,255

jeje_freqy_pattern_preview :
  gui_split_preview "jeje_freqy_pattern $1,$2,$3",$4

#@gui _<b>Details</b>
#@gui Local Variance Normalization : jeje_normalize_local_variance, jeje_normalize_local_variance_preview
#@gui : Amplitude = float(50,0,100)
#@gui : Smoothness = float(5,0,20)
#@gui : Threshold = float(5,0,100)
#@gui : Repeat = int (1,1,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/30</i>.</small>")
jeje_normalize_local_variance :
  apply_channels "normalize_local_variance $1,$2,$3,$4",$5,0
  c 0,255

jeje_normalize_local_variance_preview :
  gui_split_preview "jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1

#@gui DCP Dehaze : jeje_dehaze,jeje_dehaze_preview
#@gui : Scale = int(5,1,20)
#@gui : Strength = float(1,0,2)
#@gui : Min = float(.2,0,1)
#@gui : Max = float(1,0,1)
#@gui : Brighness = float(0,-100,100)
#@gui : Contrast = float(0,-100,100)
#@gui : Gamma = float(0,-100,100)
#@gui : Transmittance Map = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Dark Channel Prior dehazing.Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/08/09</i>.</small>")
jeje_dehaze :
  apply_channels "dehaze {2*$1+1},$2,$3,$4,$5,$6,$7 if $8 k[1] n 0,255 to_rgb else k[0] fi",rgb,1

jeje_dehaze_preview :
  gui_split_preview "jeje_dehaze $1,$2,$3,$4,$5,$6,$7,$8",$9

#@gui Spotify : jeje_spotify,jeje_spotify_preview
#@gui : Scale = float(1,0.75,10)
#@gui : Iteration = int(1,1,50)
#@gui : Gamma = float(1,0,10)
#@gui : Cut = bool(1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/16</i>.</small>")
jeje_spotify :
  apply_channels "spotify $1,$2  apply_gamma $3 if $4 c 0,255 else n 0,255 fi",$5

jeje_spotify_preview :
  gui_split_preview "jeje_spotify $1,$2,$3,$4,$5",$6

#@gui _<b>Testing</b>
#@gui <i>J&#233;J&#233;</i>

#@gui 3D Rendering : jeje_render3d, jeje_render3d_preview
#@gui : Input Image = file()
#@gui : Size = int(8,4,16)
#@gui : Quality = int(6,2,16)
#@gui : Opacity = float(0.1,0,1)
#@gui : Angle X = float(240,0,360)
#@gui : Angle Y = float(0,0,360)
#@gui : Angle Z = float(30,0,360)
#@gui : Zoom = float(1,0,3)
#@gui : Top Color = color(32,32,64,255)
#@gui : Bottom Color = color(64,128,96,255)
#@gui : Render = bool(false)
#@gui : sep = separator(), note = note(<b>Note:</b>Adjust the 3D view first and then enable render to compute the volume rendering.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_render3d :
  W={0,w}
  1,2,1,4 f. $9,$13,$10,$14,$11,$15,$12,$16 r. {0,w},{0,h},1,4,5
  blend alpha
  i "$1" a[1--1] z
  l.
    if $17 display_volume $2,$3,$4 else jeje_boundingbox3d 20 fi
    r3d 0,0,1,$7
    r3d 0,1,0,$6
    r3d 1,0,0,$5
    c3d n3d *3d {3*$W*$8/4}
  done
  object3d[0] [1],50%,50%,0,1
  n 0,255
  rm[1]

jeje_render3d_preview :
  jeje_render3d $"*"

#@gui Deconvolve : jeje_deconvolve, jeje_deconvolve_preview
#@gui : Iterations = int(20,1,100)
#@gui : Algorithm = choice(0,"Richardson-Lucy","Gold-Meinel")
#@gui : sep = separator(), note = note{"Need two layers (top layer is the blur)<br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/22/02</i>.</small>"}
jeje_deconvolve :
  if $2==1
    deconvolve_goldmeinel[0] [1],$1 n[0] 0,255
  else
    deconvolve_richardsonlucy[0] [1],$1 n[0] 0,255
  fi

jeje_deconvolve_preview :
  jeje_deconvolve $1,$2

#@gui Zernike : jeje_zernike_preview
#@gui : X = float(50,0,100)
#@gui : Y = float(50,0,100)
#@gui : R = float(50,0,100)
#@gui : Piston = float(0,-1,1)
#@gui : Horizontal Tilt = float(0,-1,1)
#@gui : Vertical Tilt = float(0,-1,1)
#@gui : Oblique Astigmatism = float(0,-1,1)
#@gui : Defocus = float(0,-1,1)
#@gui : Vertical Astigmatism = float(0,-1,1)
#@gui : Vertical Trefoil = float(0,-1,1)
#@gui : Vertical Coma = float(0,-1,1)
#@gui : Horizontal Coma = float(0,-1,1)
#@gui : Oblique Trefoil = float(0,-1,1)
#@gui : Oblique Quadrafoil = float(0,-1,1)
#@gui : Oblique Secondary Astigmatism = float(0,-1,1)
#@gui : Primary Spherical = float(0,-1,1)
#@gui : Vertical Secondary Astigmatism = float(0,-1,1)
#@gui : Vertical Quadrafoil = float(0,-1,1)
#@gui : Binarize  = bool(false)
#@gui : Period = float(0,0,256)
#@gui : Cycle Ratio = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"https://en.wikipedia.org/wiki/Zernike_polynomials <br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/03/12</i>.</small>"}
jeje_zernike :
  zernike {$1*w/100},{$2*h/100},{$3*w/100},${4-18}
  n 0,255
  if $19 f '100*((i/$20)%1)<$21' n 0,255 fi

jeje_zernike_preview :
  gui_split_preview "jeje_zernike $*",$-1

# Local Variables:
# mode: sh
# time-stamp-pattern: "Lastest update: <i>%02y/%02m/%02d</i>"
# End:
#
# (End of G'MIC custom commands)
