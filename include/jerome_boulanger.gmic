#@gmic
#
#  File        : jerome_boulanger.gmic
#                ( G'MIC commands file )
#
#  Description : Define a set of gmic commands (mostly useful for bioimage analysis)
#
#  Copyright   : Jerome Boulanger
#
#  Licenses        : This file is 'dual-licensed', you have to choose one
#                    of the two licenses below to apply.
#
#                    CeCILL-C
#                    The CeCILL-C license is close to the GNU LGPL.
#                    ( http://cecill.info/licences/Licence_CeCILL-C_V1-en.html )
#
#                or  CeCILL v2.1
#                    The CeCILL license is compatible with the GNU GPL.
#                    ( http://cecill.info/licences/Licence_CeCILL_V2.1-en.html )
#
#  This software is governed either by the CeCILL or the CeCILL-C license
#  under French law and abiding by the rules of distribution of free software.
#  You can  use, modify and or redistribute the software under the terms of
#  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
#  at the following URL: "http://cecill.info".
#
#  As a counterpart to the access to the source code and  rights to copy,
#  modify and redistribute granted by the license, users are provided only
#  with a limited warranty  and the software's author,  the holder of the
#  economic rights,  and the successive licensors  have only  limited
#  liability.
#
#  In this respect, the user's attention is drawn to the risks associated
#  with loading,  using,  modifying and/or developing or reproducing the
#  software by the user in light of its specific status of free software,
#  that may mean  that it is complicated to manipulate,  and  that  also
#  therefore means  that it is reserved for developers  and  experienced
#  professionals having in-depth computer knowledge. Users are therefore
#  encouraged to load and test the software's suitability as regards their
#  requirements in conditions enabling the security of their systems and/or
#  data to be ensured and,  more generally, to use and operate it in the
#  same conditions as regards security.
#
#  The fact that you are presently reading this means that you have had
#  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
#

#---------------------------------
#
#@cli :: Input/Output
#
#---------------------------------

#@cli tiff3d
#@cli : Input a 3D tif as a 3D image
#@cli : Note: This is useful for loading several 3D image stack
tiff3d : e[^-1] "Load the file $1 as a 3D image"
-v - n=$!
i $1 a[{$n}--1] z
-v +

#@cli toff3d
#@cli : Output a 3D tif as a 3D image
toff3d : e[^-1] "Save the 3D image as a tiff file"
-v -
-repeat $!
-o[$>] ${"filename \"$1\","$>}
done
-v +

#---------------------------------
#
#@cli :: 3D Rendering
#
#---------------------------------

#@cli jeje_boundingbox3d : _separation
#@cli : Bounding box of a 3D volume
#@cli : $ 100,100,100 jeje_boundingbox3d
jeje_boundingbox3d : -skip ${1=10}
e[^-1] "3D Bounding box"
-v - -repeat $! l[$>]
  box3d {0,w},{0,h},{0,d} -primitives3d[-1] 1  -opacity3d[-1] 1
  if {$1>0}
     -plane3d {0,w},{0,h},$1,{round({0,h}/{0,w}*$1)} -primitives3d[-1] 1 -opacity3d[-1] .1
  endif
  -rm[0] -+3d
endl done -v +

#@cli render_volume  : _size,_quality,_opacity
#@cli : Pseudo volumic rendering
#@cli : $ 100,100,100 -noise 1 blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' -render_volume
render_volume: check "${1=8}>3&${2=5}>2&${3=.1}>0"
-v - -repeat $! l[$>]
-mirror x
+tones {$2+1} -rm[1,2] -r[1--1] 100%,100%,100%,{0,s} -*[1--1] [0] -rm[0]
-reverse
-repeat $! i=$< l[$<]
  if {im!=iM}
    -pointcloud3d gaussians3d $1,{$3*($i+1)/$2}
  else
    -rm
  endif
endl done
-+3d -md3d -1 -+3d {.5},{.5},{.5}
endl done -v +

#@cli display_volume : _size,_quality,_opacity
#@cli : Display the volume with black background, a bounding box
#@cli : and a volumic rendering of the data.
#@cli : $ 100,100,100 -noise 1 blur 10,0 -max 0 -resize 100%,100%,100%,3,0 -n 0,100 f 'if(c==0,z*i(x,y,z,0),if(c==1,i(x,y,z,0)*(100-z),0))' display_volume 8,5,.1
display_volume: check "${1=8}>3&${2=5}>2&${3=.1}>0"
e[^-1] "display_volume with size $1 quality $2 and opactiy $3"
-v - -repeat $! l[$>]
  +jeje_boundingbox3d 20
  -render_volume[0] $1,$2,$3
  -+3d
endl done -v +

d3d_black : 1 d3d[0--2] [-1] -rm[-1]

#@cli view3d : _angle1,_angle2
#@cli : Apply a 3D view defined by two angles
#@cli : $ 50,50,50,3 -noise 10 blur 5 -max 0 -n 0,255 display_volume 32,5,1 -view3d
view3d : -skip ${1=25},${2=-120}
e[^-1] "Apply 3D view"
-v - -repeat $! l[$>]
  -rotate3d 0,0,1,$1 -rotate3d 1,0,0,$2
endl done -v +

#@cli colordepth
#@cli : Color depth coding
#@cli : $ 100,100,100 -noise 1 blur 10,0 -max 0 colordepth 5
colordepth: -skip ${1=5}
e "colordepth coding with lut $1"
-v - -repeat $! l[$>]
  colordepth_volume $1 -s z -+
endl done -v +

#@cli colordepth_volume
#@cli : Make a 3D volume of the same size, color it, resize orignal in color and multiply
colordepth_volume: -skip ${1=5}
-v - -repeat $! l[$>]
  i [0] f[-1] 'z/(d-1)*255' -map[-1] $1 -resize[0] 100%,100%,100%,3 -*
endl done -v +

colordepth_scale: -skip ${1=5}
10,{0,h-10} f[-1] '(h-y)/(h-1)*255' -map[-1] $1 frame[-1] 5,5,0,0,0

#@cli make_axis: _xmin,_xmax,_ymin,_ymax
#@cli : Display an axis around an image
#@cli : $ image.jpg -make_axis 0,1,0,1
make_axis:
e[^-1] "Add axis"
-v - -repeat $! l[$>]
  frame 1,1,0
  100%,24,1,3,255 axes[-1] $1,$2,{-1},{-1}
  24,{0,h},1,3,255 axes[-1] {w},{w},$4,$3 24,24,1,3,255 a[-1,-2] y
  a[0,1] y -reverse a[0,1] x
  frame 12,12,255 100%,5,1,3,255,255,255 -reverse a y
endl done -v +

#@cli xlabel: _label
#@cli : Add a label to the x-axis (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -xlabel "x-axis"
xlabel:
e[^-1] "Add a x label"
-v - -repeat $! l[$>]
  0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1] +lt[-1] 90%
  image[0] [-2],{{0,w}/2+12-{1,w}/2},{{0,h}-{1,h}},0,0,1,[-1] k[0]
endl done -v +

#@cli ylabel: _label
#@cli : Add a label to the y-axis (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -ylabel "y-axis"
ylabel:
e[^-1] "Add a y label"
-v - -repeat $! l[$>]
  0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1]
  -rotate[-1] -90 +lt[-1] 90%
  image[0] [-2],0,{{0,h}/2-12-{1,h/2}},0,0,1,[-1] k[0]
endl done -v +

#@cli title: _label
#@cli : Add a title (see make_axis)
#@cli : $ image.jpg -make_axis 0,1,0,1 -title "title"
title:
e[^-1] "Add a title"
-v - -repeat $! l[$>]
  0 -text[-1] "$1",0,0,18,1,255,255,255 -negate[-1] +lt[-1] 90%
  image[0] [-2],{{0,w}/2-{1,w}/2},0,0,0,1,[-1] k[0]
endl done -v +

#---------------------------------
#
#@cli :: Feature detections
#
#---------------------------------

#@cli jeje_dog : scale1, scale2
#@cli : Difference of Gaussian filter
#@cli : $ sp 1 jeje_dog
jeje_dog: skip ${1=1},${2=2}
  e[^-1] "Difference of Gaussian"
  v - repeat $! l[$>] +b $2 b.. $1 sub endl done v +

#@cli quiver2d
#@cli : Display a sequence 2D vector field on a 2D image sequence
#@cli : both being represented az a 3D stack
quiver2d:
e[^-1] "Cumulative sum along z-axis"
-s z -repeat {$!/2} l[$>,{$>+$!/2}] -quiver[0] [1],10,1,1,1,255 endl done -rm[{$!/2}--1] a z

#@cli warp2d : [field]
#@cli : Warp a 2D image stack using a vector field
#@cli : $ movie.cimg  a z -resize 50%,50% +l[0] +lucas_kanade 5,1 cumulate[-1] z frame 30,30,0 -warp2d endl frame[0] 30,30,0 a x
warp2d:
  e[^-1] "Warp a 3d stack using a displacement field"
  -v - -pass$1 0 -repeat {$!-1} l[$>,-1]
    -s z -repeat {$!/2} l[$>,{$>+$!/2}]
      -warp[0] [1],1,1,1
    endl done -rm[{$!/2}--1] a z
  endl done -v +

#@cli lucas_kanade: scale,smoothing
#@cli : Motion estimation using lucas and kanade approach
#@cli : Works on 2D+t image stacks/ has side effect
#@cli : [vx vy] = [Ixx Ixy; Ixy Iyy]^-1 [Ixt Iyt]
#@cli : $ image.jpg -repeat 20 +shift[-1] 1,0,0,0,2 done a z +lucas_kanade 2 -n 0,255 frame 2 a x
#@cli : $ image.jpg -repeat 20 +shift[-1] 1,1,0,0,2 done a z +lucas_kanade 2  -s z -repeat {$!/2} l[$>,{$>+$!/2}] -quiver[0] [1] endl done -rm[{$!/2}--1] a z
lucas_kanade: -skip ${1=2},${2=1}
  e[^-1] "Motion estimation with Lucas et Kanade algorithm"
  -v - -repeat $! l[$>]
     blur_xy $2 -structuretensors 0 blur_xy $1,$1,0 # abcdef
     +l -s c -rm[0,-1] -*[1,2] -*[0,2] -reverse -- endl  # dc-be
     +l[0] -s c -rm[3,5] -*[0,3] -*[1,2] -- endl # ae-bc
     l[0] -s c -rm[2,4,5] -*[0,2] -sqr[1] -- endl # ad-b2
     -/[1,2] [0]  -rm[0] a c
  endl done -v +

#@cli unwarp2d : iteration,scales,smoothness,keep_field
#@cli : Unwarp a 2D+T volume
#@cli :
#@cli : $ image.jpg -repeat 20 +shift[-1] 1,0,0,0,2 done a z -unwarp 10,20
unwarp2d: -skip ${1=5},${2=5},${3=1},${4=0}
  e[^-1] "Unwarp a 2D+t volume with $1 iterations,
           $2 scales and smoothing $3"
  -v - -repeat $! l[$>]
  # [1] warped [2] field
  [0] 100%,100%,100%,2,0
  -repeat $1
    k=$>
    -repeat $2
    # compute scale
    if {$>==($2-1)} s=1 else  s={($>+1)/$2} endif scale={$s*100}%
    echo_stdout $k" "$>" "$s" "$scale" "{1/$s}" "{$3*$s}
    # compute displacement field
    +l[1]
      -norm
      -r $scale,$scale,100%,1
      lucas_kanade {max(.75,$3*$s)}
      -* {1/$s} cumulate z
    endl
    # scale & update the displacement field
    -r[-1] [-2],5 -+[-1,-2]
    # warp the original image
    +warp2d[0] [2] -rm[1] -reverse[-1,-2]
    done done
  if {$4==0} -rm[0,2] else -rm[0,1] endif
  endl done -v +

#@cli estimate_shift_core [image]
#@cli : Estimate a translation with a reference images with sub-pixel accuray
#@cli : image.jpg  luminance +shift {u},{u},0,0,2 estimate_shift[1] [0]
estimate_shift_core:
e[^-1] "Translation estimation with Lucas et Kanade algorithm"
-v - -pass$1 0 -repeat {$!-1} l[$>,-1]
  blur_xy 1 +gradient[0] xy,0 --[0,1] +sqr[1,2] +*[1,2] [0] -*[1,2] -rm[0]
  Ixy={0,ia} Ixx={1,ia} Iyy={2,ia} Ixt={3,ia} Iyt={4,ia}
  vx={-($Iyy*$Ixt-$Ixy*$Iyt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
  vy={-($Ixx*$Iyt-$Ixy*$Ixt)/max(1e-6,$Ixx*$Iyy-$Ixy*$Ixy)}
  -rm 1,2,1,1,$vx,$vy
endl done -v +

#@cli multi_resolution_pyramide : _number_of_scales
#@cli : Build a multi-resolution pyramid
multi_resolution_pyramide:
-v - -repeat $! l[$<]
  -repeat {$1-1} +resize[-1] 50%,50%,50%,100%,2 done -reverse
endl done -v +

#@cli shift_subpixel : [image]
#@cli : Shift an image with subpixel translation
#@cli : $ image.jpg 1,2,1,1,5,10.1 +shift_subpixel[0] [1]
shift_subpixel :
-v - -pass$1 0 -repeat {$!-1} l[$>,-1]
   {0,w},{0,h},1,2 f[-1] 'if(c==0,{1,i(0)},{1,i(0,1)})'
   -warp[0] [2],1,2,1 -rm[1,2]
endl done -v +

#@cli estimate_shift [image]
#@cli : Estimate a translations between image and ref image [image]
#@cli : using a multi-resolution scheme
#@cli : $ image.jpg luminance +shift 2,3 crop 5%,5%,95%,95% estimate_shift[1] [0],3
estimate_shift:
e[^-1] "Estimate translation between images and image [$1]"
-v - -pass$1 0 -repeat {$!-1} l[$>,-1]
  N={round(log2(min({0,w},{0,h}))-2,1,-1)}
  -multi_resolution_pyramide $N
  1,2
  -repeat 3 -repeat $N
    # shift at current scale
    +*[-1] {-2.0^(-($N-$>-1))} +shift_subpixel[{$N+$>}] [-1] -rm[-2]
    # compute new correction
    estimate_shift_core[-1] [$>]
    # convert correction to image scale
    -*[-1] {2.0^($N-$>-1)}
    # add the correction
    -+[-1,-2]
  done done
 k[-1] -*[-1] -1
endl done -v +

#@cli unshift : iterations,number_of_scales
#@cli : Correct drift along Z in a 3D volume (video stabilization)
#@cli : $ image.jpg  luminance -repeat  10 +shift[-1] {2*u},{2*u},0,0,2 done a z +unshift 1 a x
unshift: -skip ${1=1}
e[^-1] "unshift image stack"
-v - -repeat $! l[$>]
  -repeat $1
    -s z -repeat {$!-1} l[$>,{$>+1}]
      +estimate_shift[1] [0] -*[-1] -1
      -shift_subpixel[1] [-1] -rm[-1]
    endl done a z
  done
endl done -v +

#@cli register_lucas_kanade : _iterations, _scale
#@cli : Register images using lucas kanade motion estimation
#@cli : $ movie.cimg luminance -resize 50%,50% a z -register_lucas_kanade 5,10
register_lucas_kanade : -skip ${1=10},${2=10}
+lucas_kanade $2 cumulate[-1] z +warp2d
-repeat $1
lucas_kanade[-1] $2 cumulate[-1] z -+[-1,-2] +warp2d
done

#@cli detect_events : _scale_xy,_scale_t,_threshold
#@cli : Detect space time events using space time interest points
#@cli : $ 100,100,100 -noise 1 blur 2 +detect_events , -pointscoordinates[-1] -resize[0] 100%,100%,100%,3,1 -n[0] 0,255 circles[0] [1] k[0]
detect_events : -skip ${1=1},${2=1},${3=9}
  e[^-1] "detect events with scale_xy $1 scale_z $2 and threshold $3"
  -v - -repeat $! l[$>]
    blur_xy $1 blur_z $2 -structuretensors blur_xy $1 blur_z $2
    -s z apply_parallel "eigen k[0] -s c k[2]" a z
    -sqrt
    thres={{0,ia}+$3*sqrt({0,iv})}
    +max_patch[0] 8 -threshold[0] $thres -*
  endl done -v +

#@cli detect_spots : _scale,_threshold
#@cli : Detect spots in the image
#@cli : $ 100,100 -noise .2,2 blur 1 -n 0,255 -noise 5 +detect_spots , -pointscoordinates[-1] -resize[0] 100%,100%,1,3,1 circles[0] [1] k[0]
detect_spots : -skip ${1=1},${2=4}
  e[^-1] "detect events with scale $1 and threshold $2"
  -v - -repeat $! l[$>]
    blur $1 +blur $1 -- thres={$2*${-mad[0]}}
    +max_patch[0] 3 +threshold[0] $thres -*
  endl done -v +

#@cli measure_colocalization:
#@cli : Colocalization analysis
#@cli : Overlap RG/R RG/G RG/R+G MOC M1 and M2
#@cli : $ 256,256,1,2 -noise 3 blur 5 -measure_colocalization
measure_colocalization:
-v - -repeat $! l[$>]
  if {{0,s}==2}
   # r,g,r>0,g>0,r.r,g.g,r.g,(r>0).(g>0)
   -s c +gt 0 +sqr[0,1] +*[0] [1] +*[2] [3] +or[2] [3]
   O1={{7,is}/{2,is}}
   O2={{7,is}/{3,is}}
   O={{7,is}/{8,is}}
   # r,g,(r>0).g,(g>0).r,r.r,g.g,r.g,(r>0).(g>0)
   -*[2] [1] -*[3] [0]
   MOC={{6,is}/sqrt({4,is}*{5,is})}
   M1={{3,is}/{0,is}}
   M2={{2,is}/{1,is}}
   -rm  1,6,1,1,$O1,$O2,$O,$MOC,$M1,$M2
  else
   echo "needs images with two channels"
   1,6,1,1,0,0
  endif
endl done -v +

#@cli measure_colocalization_object:
#@cli : Compute the number of intersecting objects
#@cli : in each channels versus the number of objects
#@cli : $ 256,256,1,2 -noise 3 blur 5 gt 0 -measure_object_colocalization
measure_object_colocalization:
-v - -repeat $! l[$>]
  if {{0,s}==2}
    gt 0 -s c label_fg .1
    n1=0 -repeat {0,iM}
      +eq[0] {$>+1} -*[-1] [1]
      if  {iM>0} n1={$n1+1} endif
      -rm[-1]
    done
    n1={0,100*$n1/iM}
    n2=0 -repeat {1,iM}
    +eq[1] {$>+1} -*[-1] [0]
      if  {iM>0} n2={$n2+1} endif
      -rm[-1]
    done
    n2={1,100*$n2/iM}
    -rm
    1,2,1,1,$n1,$n2
  else
    echo "needs images with two channels"
    1,6,1,1,0,0
  endif
endl done -v +

#@cli local_moments : _scale
#@cli : Compute local second order moments tensor
#@cli : http://en.wikipedia.org/wiki/Image_moment
#@cli : $ image.jpg +local_moments 1
local_moments : -skip ${1=1}
-v - -repeat $! l[$>]
-norm
if {d==1}
  +mul[0] 'x'   +mul[0] 'y'   +mul[0] 'x*x'
  +mul[0] 'x*y' +mul[0] 'y*y' blur $1
  +sqr[1] -/[-1] [0] --[3,-1] -/[3] [0]
  +*[1,2] -/[-1] [0] --[4,-1] -/[4] [0]
  +sqr[2] -/[-1] [0] --[5,-1] -/[5] [0]
  k[3-5] a c
else
  +mul[0] 'x'   +mul[0] 'y'   +mul[0] 'z'   +mul[0] 'x*x'
  +mul[0] 'x*y' +mul[0] 'x*z' +mul[0] 'y*y' +mul[0] 'y*z'
  +mul[0] 'z*z' blur $1
  +sqr[1] -/[-1] [0] --[4,-1] -/[4] [0]
  +*[1,2] -/[-1] [0] --[5,-1] -/[5] [0]
  +*[1,3] -/[-1] [0] --[6,-1] -/[6] [0]
  +sqr[2] -/[-1] [0] --[7,-1] -/[7] [0]
  +*[2,3] -/[-1] [0] --[8,-1] -/[8] [0]
  +sqr[3] -/[-1] [0] --[9,-1] -/[9] [0]
  k[4-9] a c
endif
endl done -v +

#@cli smooth_moments : _scale,_iterations,_dt
#@cli : Anisotropic diffusion using local moment tensors
#@cli : $ image.jpg +noise 10 +smooth_moments[-1] 1,10,1 -print_psnr
smooth_moments: check "${1=1}>0&${2=100}>0&${3=1}>0"
-v - -repeat $! l[$>]
  +local_moments[-1] $1 -smooth[0] [1],$2,$3,0 k[0]
endl done -v +

#@cli pointscoordinates
#@cli : Return the list of points in the image as 3xN or 2xN columns vector
#@cli : $ 100,100 -noise .1,2 ==. 1 +pointscoordinates
pointscoordinates :
  e[^-1] "return the list of points in the image"
  -v - -repeat $! l[$>]
    if {d>1}
      if {iM>0} -pointcloud3d -s3d k[2] -split y,{h/3} a x else 0 endif
    else
      if {iM>0} -pointcloud3d -s3d k[2] -split y,{h/3} a x else 0 endif
      -rows 0,1
    endif
  endl done -v +

#@cli circles : [x,y,radius,opacity,color,..] ||  [x,y,z,radius,opacity,color,..]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 circles[0] [1] k[0]
circles: -skip ${2=3},${3=1}
e[^-1] "Draw circles on the image."
-v -  -pass$1 0 -repeat {$!-1} l[$>,-1]
    if {{0,d}>1} # 3D case
    if {1,h<4} -r[1] 100%,{5+{0,s}},1,1,0 l[1] -s y f[3] $2 f[4] $3 f[5--1] 255 a y endl endif
    -repeat {1,w}
      x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} o={1,i($>,4)} i=$>
      -repeat {0,s}
        if {$z>=0&$z<{0,d}-1}
          -sh[0] $z,$z,$> ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,5+$>)}
          -rm[-1]
	endif
      done
      done
    else # 2D case
      if {1,h<3} -r[1] 100%,{4+{0,s}},1,1,0 l[1] -s y f[2] $2 f[3] $3 f[4--1] 255 a y endl endif
    -repeat {1,w}
      x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} o={1,i($>,3)} i=$> col={1,i($>,4)}
      -repeat {0,s}
        -sh[0] 0,0,$> ellipse[-1] $x,$y,$r,$r,0,$o,0xFFFFFF,{1,i($i,{4+$>})}
        -rm[-1]
      done
     done
    endif
endl done -rm[-1] -v +

#@cli labels: [image]
#@cli : Draw labels on the image
#@cli : The labels are defined by image as
#@cli : in 2D [x,y,label,font_size,opacity,color]
#@cli : in 3D [x,y,z,label,font_size,opacity,color]
#@cli : $ 512,512,1,3 10,2 -noise[-1] 1 -n[-1] 0,512 labels[0] [1]
labels:
e[^-1] "Draw labels on the image."
-v -  -pass$1 0 -repeat {$!-1} l[$>,-1]
    if {{0,d}>1} # 3D case
    if {1,h<4}
      -r[1] 100%,{6+{0,s}},1,1,0
      l[1] -s y f[3] 'x' f[4] 13 f[5] 1 f[6--1] 255 a y endl
    endif
    -repeat {1,w}
      x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} r={1,i($>,3)} f={1,i($>,4)} o={1,i($>,5)} i=$>
      -repeat {0,s}
        if {$z>=0&$z<{0,d}}
          -sh[0] $z,$z,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,6+$>)}
          -rm[-1]
	endif
      done
      done
    else # 2D case
      if {1,h<3}
        -r[1] 100%,{5+{0,s}},1,1,0 l[1] -s y f[2] 'x' f[3] 13 f[4] 1 f[5--1] 255 a y endl
      endif
      -repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} r={1,i($>,2)} f={1,i($>,3)} o={1,i($>,4)} i=$>
	-repeat {0,s}
          -sh[0] 0,0,$> -text[-1] $r,$x,$y,$f,$o,{1,i($i,5+$>)}
          -rm[-1]
        done
      done
    endif
   -rm[-1]
endl done -v +

#@cli : croparound : [x,y,dx,dy] || [x,y,z,dx,dy,dz]
#@cli : Draw circles on an image
#@cli : $ 512,512,1,3 10,7 -noise[-1] 1 -n[-1] 0,512 circles[0] [1] k[0]
croparound: -skip ${2=3},${3=3},${4=3}
  e[^-1] "Crop image at coordinates "
  -v - -pass$1 0 -repeat {$!-1} l[$>,-1]
    if {0,d>1} # 3D case
      if {1,h<6}
        -r[1] 100%,6,1,1,0
        l[1] -s y f[3] $2 f[4] $3 f[5] $4 a y endl
       endif
      -repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} z={1,i($>,2)} dx={1,i($>,3)} dy={1,i($>,4)} dz={1,i($>,5)} i=$>
        +crop[0] {$x-$dx},{$y-$dy},{$z-$dz},{$x+$dx},{$y+$dy},{$z+$dz}
        done
    else # 2D case
      if {1,h<4} -r[1] 100%,4,1,1,0 l[1] -s y f[2] $2 f[3] $3 a y endl endif
      -repeat {1,w}
        x={1,i($>,0)} y={1,i($>,1)} dx={1,i($>,2)} dy={1,i($>,3)} i=$>
        +crop[0] {$x-$dx},{$y-$dy},{$x+$dx},{$y+$dy}
     done
    endif
  endl done -rm[0,1] -v +

#@cli random_walks : width,height,length,number,speed
#@cli : Generate random walks tracks (list of coordinates x,y,t as a Nx3 image.)
#@cli : $ 100,100,20 -random_walks 100,100,20,5,1 circles[0] [1] k[0] blur_xy 1 -s z -max
#@cli : $ 100,100,20 -random_walks 100,100,20,10,1 circles[0] [1] k[0] blur 1 -n 0,255 display_volume 8,10,1 -rotate3d 0,0,1,25 -rotate3d 1,0,0,-120 -snapshot3d 600,1,0,0,0 autocrop
random_walks :
number=$4 width=$1 height=$2 length=$3 speed=$5
$number,3
l[-1]
  -noise 1,1
  -sh 0,0,0,0 -n[-1] 1,{$width-1} -rm[-1]
  -sh 1,1,0,0 -n[-1] 1,{$height-1} -rm[-1]
  -sh 2,2,0,0 f[-1] 0 -rm[-1]
  -repeat {$length-1} +l[-1]
    -noise 1
    -sh 0,0,0,0 c[-1] 1,{$width-2} -rm[-1]
    -sh 1,1,0,0 c[-1] 1,{$height-2} -rm[-1]
    -sh 2,2,0,0 f[-1] '$>+1' -rm[-1]
  endl done a x
endl

#@cli fibers: number,length,curvature
#@cli : Draw a serie of fibers in 2D or 3D
#@cli : $ 600,400 -pelotte 10,200,10
fibers :
-repeat $! l[$>]
   $2,$1,1,{if(d>1,3,2)}
   l[-1] -noise[-1] 10 blur_x[-1] $3 +norm -/ endl
   if {0,d>1} -s[-1] c -*[3] {0,2*d/(w+h)} a[1--1] c endif
   cumulate[-1] x -s[-1] y
   -repeat {$!-1}
     l[0,{$>+1}]
        -s c
        -+[1] {0,w/2}
	-+[2] {0,h/2}
	if {$!>3} -+[3] {0,d/2} endif
	a[1--1] y
       circles[0] [1],0,-1
     endl
   done
   k[0]
   endl done


#---------------------------------
#
#@cli :: Filtering and deconvolution
#
#---------------------------------

#@cli movavg : _size>=1
#@cli : moving average of image list with a box filter of size _size
#@cli : $ 11 f 'x>w/2' +l[-1] -s x -movavg 9 a x endl  +blur[0] 1.2 a c display_graph
movavg : check "$1>=1"
e[^-1] "moving average with size "$1 -v -
n={$1-1}
-repeat $n
  -repeat {{$!}-1} ++[{$>},{$>+1}] -*[-1] .5 -rm[$>] -mv[-1] $> done
  -reverse
done
if {$n%2!=0} -reverse endif
-v +

#@cli zmean
#@cli : average along z-axis
zmean :
-v - -repeat $! l[$>]
n={0,d} -s z -+ -/ $n
endl done -v +

#@cli zstd
#@cli : standard deviation along z-axis
zstd :
-v - -repeat $! l[$>]
+zmean -sqr[-1]
l[0] -sqr -zmean endl
-- -sqrt
endl done -v +

#@cli zmax
#@cli : maximum along z-axis
zmax :
-v - -repeat $! l[$>] -s z -max endl done -v +

#@cli zmin
#@cli : maximum along z-axis
zmin :
-v - -repeat $! l[$>]  -s z -min endl done -v +

#@cli kymoline:
#@cli : interactively select a line and extract a line profile
kymoline:
+select 1
x1={i(0,0)} y1={i(0,1)} x2={i(0,3)} y2={i(0,4)}
d={sqrt(($x2-$x1)^2+($y2-$y1)^2)}
u={($x2-$x1)/$d} v={($y2-$y1)/$d}
-rm[-1]
f 'if(x<=$d&&y==0,i($x1+x*$u,$y1+x*$v,z,c,1),5)'
crop 0,0,{int($d-1)},0

#@cli fftshift
#@cli : Shift a image so that the fft has it center in the middle
#@cli : $ image.jpg fftshift
fftshift :
  -v - -repeat $! l[$>]
    -shift {-int(w/2)},{-int(h/2)},{-int(d/2)},0,2
  endl done -v +

#@cli whiten_frequency : _alpha
#@cli : Whitening filter (equalize the frequency of the image; nothing todo with color)
#@cli : $ image.jpg -whiten_frequency
whiten_frequency : check "${1=.25}>=0"
e[^-1] "Whiten the frequency with parameter "$1
-v - -repeat $! l[$>]
#E={0,sqrt(iv)}
fft +a c -norm[-1] -pow[-1] $1 -max[-1] 1e-12 -/[-1] {ia} -/[0-1] [2] -rm[2] ifft k[0]
#-* {$E/sqrt(iv)}
endl done -v +

#@cli deblur_upscale_goldmeinel : sigma>=0, _nb_iter>=0, _acceleration>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian },zoom=2
#@cli : Deblur and zoom x2 selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ sp ? +blur 2 r. 50%,50% +deblur_upscale_goldmeinel[-1] 1,10,1.3,0,2 r[1] [0] print_psnr
deblur_upscale_goldmeinel : check "$1>=0 && ${2=8}>=0 && ${3=1}>=0" -skip ${4=1} skip ${5=1} skip ${6=2} skip ${7=0}
  e[^-1] "Deblur image$? using Gold-Meinel algorithm, with sigma $1, $2 iterations, acceleration $3 and "${arg\ 1+!$4,"",quasi-}"gaussian kernel, zoom $5 and regularization $6"
  v - repeat $! l[$>]
    ux={if(w>1,round($5*w),1)} uy={if(h>1,round($5*h),1)} uz={if(d>1,round($5*d),1)}  # bg={im} sub $bg avg={ia}
    +r. $ux,$uy,$uz,100%,6 max 0
    repeat $2
      +b[-1] {$1*$5},1,{$4!=0} r[-1] [0] +div[0,-1] rm[-2] -^[-1] $3 r[-1]  $ux,$uy,$uz,100%,6 mul[-1,-2] max 0 # u *= f / Hu
    done rm[0] # add $bg
  endl done v +


#@cli deblur_upscale_richardsonlucy : sigma>=0, nb_iter>=0, _kernel_type={ 0=quasi-gaussian (faster) | 1=gaussian }, zoom=2
#@cli : Deblur and zoom selected images using Richardson-Lucy algorithm.
#@cli : Default values: 'nb_iter=50' and 'kernel_type=1'.
#@cli : $ sp ? +blur 2 r. 50%,50% +deblur_upscale_richardsonlucy. 1,30,0,2 r[1] [0] print_psnr
deblur_upscale_richardsonlucy : check "$1>=0 && ${2=50}>=0" -skip ${3=1} -skip ${4=1}
  e[^-1] "Deblur image$? using Richardson-Lucy algorithm, with sigma $1, $2 iterations and "${arg\ 1+!$3,"",quasi-}"gaussian kernel, zoom=$4"
    v - repeat $! l[$>]
    ux={if(w>1,round($4*w),1)} uy={if(h>1,round($4*h),1)} uz={if(d>1,round($4*d),1)}  #bg={im} sub $bg avg={ia}
    +r $ux,$uy,$uz,100%,6
    repeat $2
      +b[-1] {$1*$5},1,{$3!=0} r[-1] [0] +div[0,-1] rm[-2] r[-1] $ux,$uy,$uz,100%,6 b[-1] $1,1,{$3!=0} mul[-1,-2] max 0 # u *= H ( f / Hu )
    done -rm[0]
  endl done -v +

#@cli correlate_fft
#@cli : Convolve selected images with image [$1]
#@cli : $ image.jpg 100%,100% gaussian[-1] 20,1,45 +correlate_fft[0] [1]
correlate_fft :
  e[^-1] "Correlate image with image [$1]"
  -v - -pass$1 0 -repeat {$!-1} l[$>,-1]
    w2={int({0,w}/2)} h2={int({0,h}/2)} d2={int({0,d}/2)}
    -r[1] [0],[0],[0],1,0,0,0.5,0.5,0.5,0.5  -shift[1] -$w2,-$h2,-$d2,0,2
    fft[0] fft[2] -*[3] -1
    +*[-4] [-1] +*[-4] [-3] -+[-2,-1]
    -*[-5,-3] -*[-3,-2] --[-3,-2]
    ifft -rm[-1]
  endl done -v +

#@cli deconvolve_richardsonlucy : filter,nb_iter>=1, acceletation>=0
#@cli : Deconvolve images using the first one as a blur operator (PSF)
#@cli : $ image.jpg 16,16 gaussian[-1] 2,1,45 +convolve_fft[0] [1] deconvolve_richardsonlucy[-1] [1],100
deconvolve_richardsonlucy : check ${is_image_arg\ $1}" && ${2=5}>=1"
 e[^-1] "Deblur image using Richardson-Lucy algorithm with filter [$1]."
 -v - -pass$1 0
 -repeat {$!-1} -l[$>,-1]
   -r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1] [0]
   -repeat $2
     +convolve_fft[-1] [1] -max[-1] 1e-6 +/[0] [-1] -rm[-2]
     correlate_fft[-1] [1] -*[-1,-2]   # u *= H ( f / Hu )
   done -rm[0,1]
 endl done -v +

#@cli deconvolve_goldmeinel : filter,nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ image.jpg 100%,100% gaussian[-1] 5,1,45 +convolve_fft[0] [1] +deconvolve_goldmeinel[-1] [2],5
deconvolve_goldmeinel : check ${is_image_arg\ $1}" && ${2=5}>=1 && ${3=1}>=1"
 e[^-1] "Deblur image using Gold-Meinel algorithm with filter $1, $2 iterationsand acceleration $3."
 -v - -pass$1 0
  -repeat {$!-1} -l[$>,-1]
    -r[1] {0,w},{0,h},{0,d},100%,0,0,.5,.5,.5 -normalize_sum[1]
    +blur[0] 0.75
    -repeat $2
      +convolve_fft[-1] [1] -max[-1] 1e-6 +/[0] [-1] -rm[-2]
      -^[-1] $3 -*[-1,-2] # u *= (f / Hu)^$3
    done -rm[0,1]
    endl done -v +

#@cli deconvolve_richardsonlucy_blind : nb_iter>=1,acceleration>=0
#@cli : Deblur and zoom selected images using Gold-Meinel algorithm
#@cli : Default values: 'nb_iter=8', 'acceleration=1' and 'kernel_type=1'.
#@cli : $ sp 1 blur_linear 1,5,45 +deconvolve_richardsonlucy_blind[-1]
deconvolve_richardsonlucy_blind : check "${1=5}>=1"
e[^-1] "Deblur image using richardsonlucy algorithm with $1 iterations"
 v -
 repeat {$!} -l[$>]
    -- {im-1}
    #periodize_poisson
    avg={0,ia}
    +b 0.75
    +l.. autocorrelate threshold 10%,1 normalize_sum endl
    repeat $1
      +convolve_fft[1] [2] max[-1] 1e-6 +/[0] [-1] rm[-2]
      correlate_fft. [2]
      *[1,3] # u *= H (f / Hu)
      *[1] {1,$avg/ia}
      l[1] +iee *. 0.01 + endl
      +convolve_fft[2] [1] max[-1] 1e-6 +/[0] [-1] rm[-2]
      correlate_fft. [1]
      *[2,3] # H *= u (f / Hu)
      normalize_sum[2]
      +l +powerspectrum n 0,255 append_tiles , text $> w rm endl
    done rm[0]
 endl done v +


#@cli blend_sharpness
#@cli : Blend images in the list according to their sharpness
blend_sharpness:
  e[^-1] "Blend images according to their sharpness (gradient norm)"
  -v -
    N=$! +gradient_norm
    ++[$N--1] -max[$N--1] .01 -/[$N--2] [-1] -rm[-1] a[$N--1] z d[-1] -s[-1] z
    a[0-{$N-1}] x a[1--1] x -* -s x,$N -+
  -v +

#@cli reconstruct_laplacian : param
#@cli : Reconstruct an image from its laplacian
#@cli : $ image.jpg +laplacian -reconstruct_laplacian[-1] ,
reconstruct_laplacian: -skip ${1=0}
  e[^-1] "Reconstruct an image from its laplacian"
    -v - -repeat $! -l[$>]
    -s c -repeat $! -l[$>]
      fft a={0,i(0,0)} b={1,i(0,0)}
      100%,100%,1,1,'-(4-2*cos(2*x*pi/w)-2*cos(2*y*pi/h))'
      -=[-1] 1 -+[-1] $1
      -/[0,1] [-1] k[0,1] -=[0] $a -=[1] $b ifft k[0]
    endl done a c
  endl done -v +

#@cli local_variance : _radius,_robust
#@cli : Local variance filter
#@cli : $ image.jpg  +local_variance
local_variance: -skip ${1=2},${2=0}
  e[^-1] "Estimate local variance with scale "$1" and robustness "$2
  -v - -repeat $! -l[$>]
    if {$2==0}
      +blur $1,1,1 -- -sqr blur $1,1,1
    else
       +median {2*$1+1} -- abs -median {2*$1+1} -* 1.4826 -sqr
    endif
  endl done -v +

#@cli local_noise_variance : _radius,_robust
#@cli : Local noise variance filter
#@cli : $ image.jpg  +local_variance
local_noise_variance: -skip ${1=2},${2=0}
  e[^-1] "Estimate local variance with scale "$1" and robustness "$2
  -v - -repeat $! -l[$>]
    -laplacian if {d==1} -* {1/sqrt(20)} else -* {1/sqrt(42)} endif -local_variance $1,$2
  endl done -v +

#@cli normalize_local_variance : _amplitude,_radius,_threshold,_repeat
#@cli : Local variance normalization
#@cli : $ image.jpg  +normalize_local_variance
normalize_local_variance: -skip ${1=50},${2=2},${3=25},${4=1}
  e[^-1] "Normalize local variance with amplitude $1, scale $2, threshold $3 (x$4 times)."
  -v - -repeat $! -l[$>]
  -repeat $4
   +local_variance $2 -sqrt[-1] -max[-1] $3 # compute local standard deviation
   +blur[0] $2,1,1 +-[0,-1] -/[-1] [1] -*[-1] $1 -+[-2,-1] k[-1] # x = <x> + alpha * (x-<x>)/<x'x>
  done
  endl done -v +

#@cli local_wiener : _radius
#@cli : Local Wiener filtering
#@cli : http://en.wikipedia.org/wiki/Wiener_filter
#@cli : $ image.jpg +noise 10 +local_wiener[-1] 1 -print_psnr
local_wiener : -skip ${1=2}
  e[^-1] "Local Wiener filtering"
  -v - -repeat $! -l[$>]
    sigma=${-noise_std}
    +blur $1 # mean
    +local_variance[0] $1 +-[-1] {$sigma*$sigma} -reverse[-1,-2] -/[-1,-2] # variance
    +-[0,1] # img-mean
    -*[-1,-2] -+[-1,-2] k[-1]
  endl done -v +

#@cli periodize
#@cli : Periodization of the image
#@cli : $ image.jpg -periodize
periodize :
e[^-1] "periodize"
-v - -repeat $! -l[$>]
if {w>1} +mirror x a x endif
if {h>1} +mirror y a y endif
if {d>1} +mirror z a z endif
endl done -v +

#@cli tape
#@cli : Apply a Hann window (e.g. to compute a power spectrum)
#@cli : $ image.jpg -tape
tape :
  e[^-1] "apply a Hann tapering window"
  -v - -repeat $! -l[$>]
    if {w>1} f 'i*sin(pi*x/(w-1))^2' endif
    if {h>1} f 'i*sin(pi*y/(h-1))^2' endif
    if {d>1} f 'i*sin(pi*z/(d-1))^2' endif
  endl done -v +

#@cli powerspectrum :
#@cli : Compute power spectrum
#@cli : $ image.jpg -powerspectrum
powerspectrum :
  e[^-1] "Compute power spectrum"
  -v - -repeat $! -l[$>] display_fft k[0] endl done -v +

#@cli fouriermix : [image],_cut_of_frequency
#@cli :  Mix two images using their respectives low and high frequencies
#@cli : $ image1.jpg image2.jpg  +fouriermix .5
fouriermix : -skip ${2=10%}
  e[^-1] "fourier mix images."
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
  fft[0] fft[2] fftshift
    # make a mask
    100%,100% circle[-1] 50%,50%,$2,1,1 blur[-1] 1,1,1 -n[-1] 0,1 d
    -*[0,1] [-1] -negate[-1] -*[2,3] [-1] -rm[-1] -+[0,2] -+[1,2] fftshift
    ifft
  endl done -rm[-1] -v +

#@cli blend_fft: [image]
#@cli : blend images using strongest frequencies
blend_fft : -skip ${2=2}
  -v - -pass$1 0
  +l[-1]
    -tape -powerspectrum blur 1 +blur 2 --
    -max '{ia+$2*sqrt(iv)}' circle 50%,50%,20,1,@{0,im} -n 0,1 d
    fftshift
  endl fft[-2] -*[-2,-3] [-1] -negate[-1]
  -repeat {$!-3} -l[$>,-1,-2,-3]
    fft[0] -*[0,1] [-1] -+[0] [2] -+[1] [3] ifft[0,1] -rm[1]
  endl done -rm[-1,-2,-3] -v +

#@cli denoise_fft : _threshold
#@cli : Illustrate the thresholding of Fourier coefficients
#@cli : $ 256,256 f '128+128*sin(x+y)' +noise 50 +denoise_fft[-1] 70%
denoise_fft : -skip ${1=1}
  e[^-1] "Threshold Fourier coefficients with threshold "$1"."
  -v - -repeat $! -l[$>]
    +l[-1] -tape -powerspectrum -threshold $1 fftshift endl
    fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] ifft k[0]
    -n 0,255
  endl done -v +

#@cli unstrip : _smoothness,_scale,_threshold
#@cli : Remove stripes in an image
#@cli : $ image.jpg f '.5*i*(1+.25*sin(x))' +unstrip
unstrip : -skip ${1=25},${2=20},${3=4}
  e[^-1] "Remove stripes"
  -v - -repeat $! -l[$>]
  # create a mask
    +l[-1]
     -tape -powerspectrum -norm detect_spots 1,$3 dilate_circ $2 gt 0
     -n 0,1 -negate circle 50%,50%,$2,1,1
     if {im<.9} # check if some spots have been detected
       active=1 blur $1 -n 0,1 fftshift if {iM==0} f 1 endif
     else
       active=0
     endif
    endl
    #apply the mask
    if {$active==1}
      fft[0] -*[0] [-1] -*[1] [-1] -rm[-1] ifft
    endif
    k[0]
  endl done -v +

#@cli autocorrelate
#@cli : Autocorrelation using fourier transform
#@cli : $ image.jpg autocorrelate
autocorrelate :
  e[^-1] "Compute autocorrelation"
  -v - -repeat $! -l[$>] fft -sqr -+ -sqrt ifft k[0] fftshift endl done -v +

#@cli spotify : _scale>0,_nb_iter>0,
#@cli : Make everything look like a spot
#@cli : Default values '_nb_iter=1, _scale=1'
#@cli : $ image.jpg +spotify 1,10
#@cli : $ image.jpg +spotify 1,20 -norm[-1] gt[-1] 5% blur 1 -*
spotify : check "${1=1}>0 && ${2=1}>0"
e[^-1] "Spotify with scale $1 with $2 iterations"
-v - -repeat $! -l[$>]
  if {0,im!=iM}
    s={0,ia}
    -repeat $2
      b $1 +b {2*$1} -- -max 0 -* '{0,$s/ia}'
    done
  endif
endl done -v +

#@cli mapblur : _levels
#@cli : Blur the image with a map
#@cli : $ image.jpg +f '10*x/w' -mapblur
mapblur: check "${1=10}>0"
e[^-1] "Blur images using a blur map (works using pairs of images)."
-v - -repeat {$!/2} -l[{2*$>},{2*$>+1}]
  smin={1,im} smax={1,iM}
  -l[0] -repeat $1 +blur[0] {$smin+$>*($smax-$smin)/($1)} done -rm[0] a z endl
  -l[1] -tones $1 gt 0 blur 1 a z endl
  -* -s z -+
endl done -v +

#@cli vesselness : _scale>0,coefA,coefB,coefC
#@cli : Frangi's vesselness filter based on the eigen value of the Hessian
#@cli : Reference:
#@cli : A. F. Frangi, W. J. Niessen, K. . L. Vincken, M. A. Viergever,
#@cli : "Multiscale vessel enhancement filtering"
#@cli : Medical Image Computing and Computer Assisted Intervention MICCAI'98,
#@cli : vol. 1496, pp. 130 137, 1998.
#@cli : $ vessel.png +negate -vesselness[-1] 3
vesselness : -skip ${1=1},${2=1},${3=1},${4=1}
e[^-1] "Tubeness with scale $1."
-v - -repeat $! -l[$>]
  blur $1
  -s c -repeat $! -l[$>]
    # Hessian eigen values sorted by absolute value
    hessian a c eigen k[0] +sign abs[-2] -sort[-2] +,c -* +norm a c
    if {d>1}
      f 'if(i(x,y,z,1)<0&&i(x,y,z,2)<0,exp(-0.5/$2^2*(i(x,y,z,1)/i(x,y,z,2))^2)*exp(-0.5/$3^2*(i(x,y,z,0)^2/abs(i(x,y,z,1)*i(x,y,z,2))))*(1-exp(-0.5/$4^2*i(x,y,z,3)^2)),0)'
    else
      f 'if(i(x,y,z,1)<0,exp(-0.5/($2)^2*(i(x,y,z,0)/i(x,y,z,1))^2)*(1-exp(-0.5/($3)^2*i(x,y,z,2)^2)),0)'
    endif
  endl done a c
  endl done -v +

#@cli _hessian_eigen_min: scale
#@cli compute the min eigen value of the Hessian matrix
_hessian_eigen_min: -skip ${1==1}
e[^-1] "compute Hessian min eigen value"
 v - repeat $! l[$>] b $1 s c repeat $! l[$>]
   hessian a c eigen k[0] channels {s-1}
 endl done a c
 endl done v +

#@cli hessian_sharpen: nscales,strength
#@cli Sharpen the image
hessian_sharpen:
 e[^-1] "Sharpen the image using its Hessian with "$1" scales and strength "$2
 v - repeat $! l[$>]
   repeat $1 +_hessian_eigen_min[0] {2^$>} mul {2^$>/($1-1)} done add[1--1] mul. {-$2} add
 endl done v +

#@cli smurf: zoom,iter,scale,strength
#@cli : enhance linear structures
#@cli : $  1024,1024 fibers 20,2000,50 gt 0 dilate_circ 3 +dilate_circ 3 -- n 0,255 negate +b 3 r. 50%,50% +smurf. 2,8,0.25,5 r[0,1] [2]
#@cli : sp duck +smurf. 1,1,1,10 c 0,255
smurf:
  e[^-1] "smurf"
  v - repeat $! l[$>]  factor={exp(log($1)/($2*$3))} sigma=$3 avg={ia}
    repeat {$2*$3}
       +l _hessian_eigen_min $sigma +_hessian_eigen_min {3*$sigma} --
       threshold {0.1*sqrt(iv)},1 mul {-$4}  endl add
       r. {round(w*$factor)},{round(h*$factor)},100%,100%,6 max 0 mul {$avg/ia}
       sigma={$sigma*$factor}
     done
  endl done v +

#@cli bgsubstract : _length>0
#@cli : Substract the background using a temporal top-hat filter
#@cli : $ 100,100,100 -noise 1 blur 1 +bgsubstract 10
bgsubstract:  check "${1=5}>0"
  e[^-1] "Temporal background substraction with length $1."
  -v - -repeat $! -l[$>]
    1,1,$1 f[-1] 1 +erode[0] [1] --[0] [-1] -rm[1,-1]
  endl done -v +

#@cli schizo : _amplitude,_amplitude_normal,_nb_iterations,_strength
#@cli : Schizo filter gives either a furry image or a smoothed image
#@cli : Default values '_amplitude=100,amplitude_normal=-50 _nb_iter=5,_strength=.75'
#@cli : $ image.jpg +schizo 100,-50 +schizo[0] -50,100 -max 0
schizo : -skip ${1=100},${2=-50},${3=5},${4=.75}
  e[^-1] "Schizo filter smoothing with // $1 and T $2 and $3 iterations."
  -v - -repeat $! -l[$>]
  [0]
  -repeat $3
   -l[-1]
     +iee -*[-1] {$1/(0.0001+max(abs(im),abs(iM)))}
     +inn[0] -*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}
     -+
   endl
   -*[-1] $4  +*[0] {1-$4} -+[-1,-2]
   done -rm[0]
 endl done -v +

#@cli scandoc : _smooth,_background,_black,_white
#@cli : improve scanned document
#@cli : $ image.jpg -scandoc
scandoc: -skip ${1=3},${2=100},${3=10%},${4=90%}
  -v - -repeat $! -l[$>] -split_opacity -l[0]
    -median $1 +blur $2 -- -min 0
    -s c -n 0,1 a c c $3,$4 -n 0,255
  endl a c endl done -v +

#@cli warp_affine [3x3 affine matrix]
#@cli : Warp the image [0] using an 2D affine field defined by a 3x3 matrix
#@cli : $ image.jpg 3,1,1,1,1 diagonal[-1] -noise[-1] .1 +warp_affine[0] [1]
warp_affine :
  e[^-1] "Warp image using affine transform defined by 3x3 image ["$1"]"
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    params=({1,i(0,0)},{1,i(1,0)},{1,i(2,0)};\
           {1,i(0,1)},{1,i(1,1)},{1,i(2,1)};\
           {1,i(0,2)},{1,i(1,2)},{1,i(2,2)})
    {0,w},{0,h},1,1,1 +f[-1] x +f[-1] y a[-3--1] c
    -mix_channels[-1] $params
    channels[-1] 1,2
    -warp[0] [-1],0,2,0 -rm[-1]
  endl done -rm[-1] -v +

#@cli solve_least_square: X
#@cli : Solves $|Ax-b|^2$
#@cli : $  (1,1,1,1;1,2,1,2;1,1,2,2) (-1,1,0;-2,0,1) -mmul[1] [0] -solve_least_square[0] [1]
solve_least_square:
  e[^-1] "Solves least square"
  -v - -pass$1 0 -repeat {$!-1} -l[$>,-1]
    +transpose +mmul[0,2] +mmul[0,3]
    k[-1,-2] invert[0] -mmul -transpose
  endl done -v +

#@cli calibrate_affine_transform : image
calibrate_affine_transform :
e[] "Interactive affine transformation calibration between image and image $1"
e[] "- Use mouse button 1 to select matching points on the two images."
e[] "- Use mouse button 2 to remove points in the list"
e[] "- Press Space to re-init the list of points"
e[] "- Close the window to finish\n"
-v - -pass$1 0 -repeat {$!-1} -l[$>,-1] -reverse
 0 0 (1,0,0;0,1,0;0,0,1) Z=0
  do
    x1={*1,x} y1={*1,y}
    x2={*2,x} y2={*2,y}
    if {$x1>=0}
      if {{*1,b}&1} # if button 1 on window 1: add pts
        (1;{$x1/{*1,w}*{0,w}};{$y1/{*1,h}*{0,h}})
	if {2,h>1} a[2,-1] x else -rm[2] -mv[-1] 2 endif
      else
        if {{*1,b}&2} # if button 2 on window 1: rm pts
	  if {2,w>1} columns[2] 0,{2,w-2} else -rm[2] 0 -mv[-1] 2 endif
        endif
      endif
    endif
    if {$x2>=0}
      if {{*2,b}&1}  # if button 1 on window 2: add pts
        (1;{$x2/{*2,w}*{1,w}};{$y2/{*2,h}*{1,h}})
	if {3,h>1} a[3,-1] x else -rm[3] -mv[-1] 3 endif
      else
        if {{*2,b}&2} # if button 2 on window 2: rm pts
          if {3,w>1} columns[3] 0,{3,w-2} else -rm[3] 0 -mv[-1] 3 endif
        endif
      endif
    endif
    # if space bar is pressed : reinitialize
    if {{*0,SPACE}" || "{*1,SPACE}" || "{*2,SPACE}} -rm[2,3,4] 0 0 (1,0,0;0,1,0;0,0,1) endif
    if {*1,o} Z={max(0,min({0,d}-1,$Z+{*1,o}))} -wait -1 endif
    if {*2,o} Z={max(0,min({0,d}-1,$Z+{*2,o}))} -wait -1 endif
    if {*3,o} Z={max(0,min({0,d}-1,$Z+{*3,o}))} -wait -1 endif
    # number of paired points
    N={min({2,w},{3,w})}
    # if each list has at least one pts
    if {{2,h}>1" && "{3,h}>1}
      if {$N<=3} # translation
        -rm[4] +l[2,3]
          -rows 1,2 columns 0,{$N-1} -- -s x -+ -/ $N
    	  (1,0,0;{-i(0,0)},1,0;{-i(0,1)},0,1) -rm[-2]
        endl
      else # affine
        -rm[4] +l[2,3] columns 0,{$N-1} -solve_least_square[0] [1] -rm[1] endl
      endif
    endif
    # Display first image
    +l[0,2]
      if {{0,d}>1} -slices[0] $Z endif
      -r[0] 200%,200%,1,1,5
      -r[0] 100%,100%,1,3,0 grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
      if {1,h>1} -rows[1] 1,2  -*[1] 2
      1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  circles[0] [1]
      -labels[0] [1] endif -w1[0] -1,-1,-1,-1,"First image (n="{1,w}")" -rm
    endl
    # Display second image
    +l[1,3]
      if {{0,d}>1} -slices[0] $Z endif
      -r[0] 200%,200%,1,1,5
      -r[0] 100%,100%,1,3,0  -shift[0] 0,0,0,1 grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
      if {1,h>1} -rows[1] 1,2 -*[1] 2
      1,5,1,1,2,1,255,0,0 -r[-1] {0,w},100%,1,1,1  circles[0] [1]
      -labels[0] [1] endif -w2[0] -1,-1,-1,-1,"Second image (n="{1,w}")" -rm
    endl
    # warp image 1 and display merge
    +l[0,1,4]
      if {{0,d}>1} -slices[0,1] $Z endif
      -warp_affine[1] [2] -rm[2] a c
      -r[0] 200%,200%,1,100%,5
      grid[0] 10%,10%,0,0,.3,0xCCCCCCCC,255,128,32
      -w3 -1,-1,-1,-1,"merge "$N" Z="$Z -rm
    endl
  -wait
  -while {{*1}" && "!{*1,Q}" && "!{*1,ESC}" && "{*2}}
  -w1[] 0 -w2[] 0 -w3[] 0
  k[-1]
endl done -v +

#@cli vobs : _scale
#@cli : Motion quantity (Normal motion)  h * (|Ixy|^2 |It|/|Ixy|) / h * Ixy^2
#@cli : Irani, Michal and Rousso, Benny and Peleg, Shmuel, Detecting and tracking multiple moving objects using temporal integration, ECCV'92.
#@cli : $ 100,100,10 -noise 1 blur 1 +vobs
vobs : check "${1=1}>0 && ${2=3}>0"
  e[^-1] "Motion quantity with scale $1"
  -v - -repeat $! -l[$>]
    gradient a[0,1] c -norm[0] abs[1] -*[1] [0] -sqr[0] blur $1,1,1 -reverse -max[1] 5% -/
  endl done -v +

#@cli display_vobs
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 -noise .7,2 ==. 1 blur 2,1,1 -repeat 20 +l[-1] +laplacian -*[-1] .05 -+ endl done  a z display_vobs
display_vobs :
  +vobs 1 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
  -resize[0] 100%,100%,100%,3,1 apply_gamma[0] 1.5 -n[0] 0,255
  -l[0] -s z frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 a z endl
  -l[1] -s z -repeat $! -l[$>] 1,100% f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 frame[-1] 3,0,64  -resize[-1] 100%,{0,h},1,3,5 a x
  frame 5,12,64 -shift 0,5,0,0,2
  -text "Vobs ["$A":"$B"]",5,0,13,1,255 endl done a z endl
  a x

#@cli display_pseudocolor : predefined_palette
#@cli : Display an indexed image in pseudocolors using a palette
#@cli : $ image.jpg -luminance display_pseudocolor
display_pseudocolor : -skip ${1=5}
  e[^-1] "Display an indexed image in pseudocolors using map "$1
  -v - -repeat $! -l[$>]
    A={round(im,0.0001)} B={round(iM,0.0001)}
    -n[-1] 0,255 -map[-1] $1
    -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
    add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},$A,$B,6,255
  endl done -v +

#@cli display_colordepth : _dz
display_colordepth :
  e[^-1] "display the 3D image with a depth color coded."
  -v - -repeat $! -l[$>]
    H={d*$1} colordepth , a z -min {ia+10*sqrt(iv)} -n 0,255 -s z
    -rectangle {w-50-5},{h/4-5},{w-5},{h-h/4+5},.5,0,0,0
    add_colorbar[-1] {w-50},{h/4},{w-40},{h-h/4},0,$H,6,255
  endl done -v +

#@cli map_hilo
#@cli : Map a grascale image to a RGB with maw in red and min in blue
#@cli : This help to check if images are saturated
map_hilo:
-v - -repeat $! -l[$>]
  -round m={0,im} -- $m
  1,1,1,3,0,0,{0,iM} {0,iM-1},1,1,3,'x+1' 1,1,1,3,{0,iM},0,0 a[1,2,3] x
  -map[0] [1]
  -+ $m -rm[1]
endl done -v +

#@cli add_colorbar : x0,y0,x1,y1,_min,_max,_ntics,color,colormap
#@cli : Add a colorbar
#@cli : $ image.jpg -luminance -map 5 add_colorbar {w-40},20,{w-30},{h-20},0,255,6,255,5
add_colorbar : -skip ${5=0},${6=255},${7=6},${8=255},${9=""},${10=5}
  e[^-1] "Add a colorbar"
  -v - -repeat $! -l[$>]
    {$3-$1},{$4-$2} -l[-1] f 'h-y' -n 0,255 -map $10 endl
    frame[1] 1,1,$8 image[0] [1],$1,$2,0,0,1 k[0]
    -repeat $7
      val={round($5+$>/($7-1)*($6-$5),.001)}
       -text "- "$val" "$9,{$3+1},{$4-$>*($4-$2-5)/($7-1)-10},13,1,$8
    done
  endl done -v -

#@cli local_diffusion_coefficient : _scale,_threshold
#@cli : Estimate local diffusion coefficient It - D (Ixx+Iyy)=0 using D=It/(Ixx+Iyy)
#@cli : $ 100,100 -noise .7,2 ==. 1 blur 2,1,1 -repeat 20 +l[-1] +laplacian -*[-1] .05 -+ endl done  a z -local_diffusion_coefficient 2,.5
local_diffusion_coefficient : check "${1=2}>0 && ${2=.5}>=0"
e[^-1] "Local diffusion coefficient estimation using scale $1 and threshold $2"
-v - -repeat $! -l[$>]
   +l[0] -s z -laplacian a z endl           # Ixx+Iyy
   +l[0] -s z gradient_norm a z -sqr endl  # ||Ix+Iy||^2
   gradient[0] z,1                            # It
   -l[0,1] # try to compute It/Ixx+Iyy as stably as possible
     R={1,ia+$2*sqrt(iv)}
     a c f 'b=i(x,y,z,0);a=i(x,y,z,1);if(abs(a)>abs(b),b/a,if(abs(b)>$R,1/(b/a),0))'
     channels 0
   endl
   -*[0] [1] blur $1,1,1 -max[1] {1,ia+$2*sqrt(iv)}  -/
   channels 0
-v + endl done

ldc :
-local_diffusion_coefficient $*

ldc_residuals :
+l[0] -s z -laplacian a z endl
gradient[0] z,1
-*[1,2]
-- abs blur 1

#@cli display_ldc :
#@cli : Display local diffusion coefficient
#@cli : $ 200,100 -noise .7,2 ==. 1 blur 2,1,1 -repeat 20 +l[-1] +laplacian -*[-1] .05 -+ endl done  a z display_ldc
display_ldc :
+ldc 2,3 A={round(im,0.001)} B={round(iM,0.001)} -*[-1] '{128/max(im,iM)}' -+[-1] 128  -map[-1] 5
-resize[0] 100%,100%,100%,3,1 apply_gamma[0] 1.5 -n[0] 0,255
-l[0] -s z frame 5,12,64 -shift 0,5,0,0,2 -text "Original sequence",5,0,13,1,255 a z endl
-l[1] -s z -repeat $! -l[$>] 1,100% f[-1] 'h-y' -n 0,255  -map[-1] 5 -resize[-1] 5,{0,h},1,3,5 frame[-1] 3,0,64  -resize[-1]
       100%,{0,h},1,3,5 a x
frame 5,12,64 -shift 0,5,0,0,2
-text "Local diffusion coefficient ["$A":"$B"]",5,0,13,1,255 endl done a z endl
a x

#@cli print_psnr : _max_value
#@cli : Display the psnr on the image list taking the first one as a reference
#@cli : $ image.jpg +noise 20 +blur[-1] 1 -print_psnr
print_psnr : -skip ${1=255}
e[^-1] "Compute PSNR with image 0 and print it on the other images."
-v - +psnr $1
-repeat {$!-2} -text_outline[{$>+1}] "PSNR:"{round(i(0,$>+1),.01)}"dB",5,5,30,1 done
-rm[-1] -v +

#@cli noise_std
#@cli : Estimate the noise variance
#@cli : $ image.jpg -noise 10 sigma={round(${-noise_std},.1)} -text_outline "Noise std:"$sigma,5,5,30,1
noise_std :
e[^-1] "Compute noise std."
-v - +laplacian if {{0,d}==1}  -u {${-mad[-1]}/sqrt(20.0)} else -u {${-mad[-1]}/sqrt(42.0)} endif -rm[-1]
-v +

#@cli pca
#@cli : Principal component analysis
#@cli : $ image2.jpg +l -split_tiles 64,64 -y y a x -pca k[-1] -s x -r 8,8,1,1,-1 -n 0,255 frame 1,1,255 append_tiles , -r[-1] 400%,400% frame 0,20 -title dictionary endl
pca :
e[^-1] "Principal component analysis"
-v - -repeat $! -l[$>]
  n={w} -- {ia} +transpose[-1] -m*[-2,-1] -/ $n eigen
endl done -v +

spca: -skip ${2=20}
-v - -repeat $! -l[$>]
  -repeat $2
    p={sqrt(h)}
    +l +pca k[0,-1]  -reverse -transpose[0] +m* -threshold[-1] $1,1 -rm[1] -transpose[0] -m* endl
    -*[0] .25 -*[1] .75 -+
  done
  -pca
endl done -v +

#@cli denoise_karmuen_loeve : _number_of_components
#@cli : Denoise with a bloc Karumen-Loeve transform
#@cli : http://en.wikipedia.org/wiki/Karhunen%E2%80%93Lo%C3%A8ve_theorem
#@cli : $ image2.jpg +noise 10 +denoise_karmuen_loeve[-1] 8 -print_psnr
denoise_karmuen_loeve:
  -v - -repeat $! -l[$>]
    -split_tiles 64,64 oW={0,w} oH={0,h} oS={0,s}
    -y y a x +pca k[0,-1] -reverse crop[0] 0,$1
    -transpose[0] +m* -rm[1] -transpose[0] -m* -s x
    -resize $oW,$oH,1,$oS,-1 append_tiles ,
  endl done -v +

#@cli denoise_patch_dict : _patch_size,_nb_of_shifts,_thres_comp,_thres_coef
#@cli : Denoising using a dictionnary of patches learned on the image
#@cli : $ image.jpg +noise 10 +denoise_patch_dict[1] , -print_psnr
denoise_patch_dict: -skip ${1=8},${2=8},${3=1.1},${4=1.1}
e[^-1] "Denoising using a dictionnary of "$1"x"$1" patches with "$2" shifts, threshold $3x(noise std) for components and $4x(std) for coefficients."
-v - -repeat $! -l[$>]
  Sigma=${-noise_std[0]} # measure the noise level
  # mirror to prevent side effect
  +crop 0,0,$1,100% -mirror[-1] x -reverse +crop[-1] {w-$1-1},0,100%,100% -mirror[-1] x a x
  +crop 0,0,100%,$1 -mirror[-1] y -reverse +crop[-1] 0,{h-$1-1},100%,100% -mirror[-1] y a y
  # resize the image to get integer nb of tiles (using mirrored version)
  oW={0,w} oH={0,h} oS={0,s} nW={$1*round($oW/$1,1,1)} nH={$1*round($oH/$1,1,1)}
  +crop {2*$oW-$nW},0,100%,100% -mirror[-1] x a x
  +crop 0,{2*$oH-$nH},100%,100% -mirror[-1] y a y
  NtileX={round($nW/$1)}  NtileY={round($nH/$1)}
  # compute a dictionnary (use several shifts)
  +l[-1]
    -repeat $2
      if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} else dx=0 dy=0 endif
      +shift[0] $dx,$dy,0,0,2
      -split_tiles[-1] $NtileX,$NtileY pW={1,w} pH={1,h} # split the image
    done -rm[0]
    -y y a x n={w} -- 'ia' +transpose[-1] -m*[-2,-1] -/ $n eigen # PCA
    # select components based on noise level
    -l[-2] -unroll x -sqrt gt {$3*$Sigma} f 'abs(i(x+1)-i(x))'
    T={[xM,yM,zM,cM]} 4 f[-1] $T T={i(0)} endl
    if {$T==0} T=100% endif k[-1] columns 0,$T
  endl
  # denoise the image using the dictionnary
  -repeat $2
    if {$2>1} dx={round(u(0,$1))} dy={round(u(0,$1))} else dx=0 dy=0 endif
    +shift[0] $dx,$dy,0,0,2
    -l[1,-1]
      -l[1] -split_tiles $NtileX,$NtileY -unroll y a x endl
      -transpose[0] +m*                # project on the dictionnary
      t=${-mad[-1]}                     # estimate variance of coefficients
      f[-1] 'if(abs(i)<$4*$t,0,i)'     # threshold the coefficients
      -rm[1] -transpose[0] +m* -rm[-2] # project back
    endl
    -l[-1]
       -s x -resize $pW,$pH,1,$oS,-1
       append_tiles $NtileX,$NtileY
       -shift {-$dx},{-$dy},0,0,2
     endl
  done
  -rm[0,1]
  -+ -/ $2
  crop {$1+1},{$1+1},{$oW-$1-2},{$oH-$1-2}
endl done -v +

std_noise :
  -v - +laplacian[-1] -u {${-mad[-1]}/sqrt(if(d==1,20,42))} -rm[-1] -v +

#@cli iuwt : _nlevels>2,_spline>1
#@cli : Compute the "isotropic undecimated wavelet transform" using
#@cli : a trou algorithm for the B3-Spline wavelet.
#@cli : The inverse is obtained as the sum of all coefficients
#@cli : $ image.jpg iuwt 4,1 -n 0,255 append_tiles
#@cli : $ image.jpg iuwt 3,1 -+
iuwt: -skip ${1=3},${2=3}
  e[^-1] "Compute isotropic undecimated wavelet transform"
  -v - -repeat $! -l[$<]
  # Compute the Spline filter by succesive convolutions
  50
  -l[-1]
    f 'if(x==w/2|x==w/2-1,1,0)' i [0]
    -repeat $2 convolve[-1] [0] done
    k[-1] autocrop 0 -/ {ia*w}
  endl
  # Compute the decomposition
   -repeat {$1-1}
     -l[-1,-2]
      +convolve[0] [1]
      -y[1] y convolve[-1] [1]
      +-[0] [-1] -rm[0] -reverse
     endl
     # add trou for the next scale
     -l[-1] -y y 100% a x -s y -s x -rm[-1] a x endl
    done
    -rm[-1] -reverse
  endl done -v +

#@cli iuwt_std : _nlevels>2,_spline>1
#@cli : Compute noise at each level of the iuwt
#@cli : $ image.jpg iuwt_std 10,10
iuwt_std:
 -v - -repeat $! -l[$>]
   sigma=${-noise_std}
   if 1 # experimental measure
     f 1 -noise $sigma iuwt $1,$2
     -repeat $! -l[$>]
        x={sqrt(iv)} -rm 1 f $x
     endl done a x
   else -rm # try a theoritical formula (failed)
   50
   -l[-1]
   f 'if(x==w/2|x==w/2-1,1,0)' i [0]
   -repeat $2 convolve[-1] [0] done
   k[-1] autocrop 0 -/ {ia*w}
   endl
   -sqr
   alpha={is} -rm
   $1,1,1,1,'$sigma*sqrt((1+$alpha)*$alpha^(w-x-1))'
   endif
 endl done -v +

#@cli denoise_iuwt:_threshold>0,_nlevels>2,_spline>1
#@cli : Denoising by thresholding the coefficients of the
#@cli : "isotropic undecimated wavelet transform"
#@cli : $ image.jpg +noise 10 +denoise_iuwt[-1] , -print_psnr
denoise_iuwt: check "${1=1.4}>0&&${2=4}>1&&${3=1}>0"
  e[^-1] "Denoise using the isotropic undecimated B"$3" spline wavelet transform"
  -v - -repeat $! -l[$>]
    # Compute noise std at each level
    +iuwt_std[0] $2,$3 -reverse
    # compute the wavelet coefficient and threshold them
    iuwt[-1] $2,$3
    -repeat {$!-2} -threshold[{$>+2}] {0,$1*i($>+1)},1 done
    # reconstruct
    -+[1--1]
    -rm[0]
  endl done  -v +

#@cli noise_poisson_gaussian : gain,offset,noise_std
camera_noise:
-v - -repeat $! -l[$>]
 -noise 0,3 -* $1 -+ $2 -noise $3
endl done -v +

#@cli analyze_camera_noise :
analyze_camera_noise:
 -v - -repeat $! -l[$>]
   +local_noise_variance $1 blur[0] $1 -y a c
   display_parametric 800,600,.0,1,1,0,signal,noise
 endl done -v +

#@cli dehaze : scale,gamma1,min_va,max_val,gamma2
#@cli : Dehaze an image using Dark Channel Prior appraoch
#@cli : return the dehazed image and a transmittance image
#@cli : $ http://media.lcpc.fr/ext/img/prod/frida/K080-000000.jpg -r 600,400,1,3,5 +dehaze
dehaze: -skip ${1=5},${2=1},${3=.2},${4=1},${5=0},${6=0},${7=0}
  -v - -repeat $! -l[$>]
   # Atmospheric light estimation
  +l
    +l -s c -min blur 10 erode_circ $1 dilate_circ $1  endl
    gt[-1] 80% -*
    -s c aR={0,iM} aG={1,iM} aB={2,iM} -rm
  endl
   # transmitance map estimation
   +l
    -s c -/[0] $aR -/[1] $aG -/[2] $aB
    -repeat 10 -median 3 erode_circ $1 dilate_circ $1 done
    -min f 'max($3,min($4,1-0.95*i))'
    endl
   # correction
   -pow[1] $2
   -s[0] c --[0] $aR --[1] $aG --[2] $aB
   -/[0-2] [3]
   -+[0] $aR -+[1] $aG -+[2] $aB a[0-2] c
   c[0] 0,255
   adjust_colors[0] $5,$6,$7
  endl done -v +

#---------------------------------
#
#@cli :: Segmentation
#
#---------------------------------

#@cli contour2d: _tolerance
#@cli : Draw a 2D contour of regions with tolerance _tolerance
#@cli : Default value _tolerance=.1
#@cli : $ image.jpg -norm blur 1 gt 50% +contour2d
contour2d: -skip ${1=.1}
-v - f 'if(abs(i-j(1,1))>$1||abs(i-j(1,0))>$1,1,0)' -v +

#@cli segment_snake : _nb_iter,_time_step,_lambda,_threshold,_smoothness
#@cli : Segment an image using an adaptation of Chan and Vese's method.
#@cli : Default values _nb_iter=10,_time_step=1,_smoothness=100,_threshold=50%
#@cli : Reference Chan and L. Vese,Active contours without edges, IEEE transactions on image processing 10(2) (2001), pp. 266-277
#@cli : $ 256,128 -text "GMIC",40,10,100,1,255 blur 1 -noise 20 +segment_snake , contour2d[-1] , -resize[-1] 100%,100%,1,3,0 -n 0,255 blend add
segment_snake: -skip ${1=100},${2=1},${3=.1},${4=.1},${5=10},${6=0}
e[^-1] "Segment the image using active contours without edges using $1 iterations and time step $2, smoothness $3 and initialize with threshold of $4."
-v - -repeat $! -l[$>]
  if {s>1} -luminance endif
  +blur $5 gt[-1] {ia+$4*sqrt(iv)}                                # initialization
  -l[-1] +distance 0 -negate[0] distance[0] 0 -*[0] -1 -+ endl # levelset
  -repeat $1
    # compute mean and variance of the two regions (original version is with mean only)
    # the molified step function is given by a blur of the sharp step function
    +lt[-1] 0 blur[-1] 1 +*[0,-1] swx={ia} sw={-2,ia} M1={$swx/$sw}
    -sqr[-1] swx2={ia}  S1={max(1e-3,$swx2/$sw^2-$M1^2)} -rm[-1,-2]
    +gt[-1] 0 blur[-1] 1 +*[0,-1] swx={ia} sw={-2,ia} M2={$swx/$sw}
    -sqr[-1] swx2={ia}  S2={max(1e-3,$swx2/$sw^2-$M2^2)} -rm[-1,-2]
    +iee[-1]                                                     # regularization
    +f[0] '(1.0/$3)*(((i(x,y)-$M1)^2)/$S1-((i(x,y)-$M2)^2)/$S2)' # data term
    -+[-2,-1]
    -*[-1] {$2/(0.0001+max(abs(im),abs(iM)))}           # adaptive time step
    -+[-2,-1]
    if {$6==1} # if display
    +l gt[1] 0 contour2d[1] , -n 0,1 -a c -text $>,0,0,13,1,{iM} -w -wait 10  -rm endl
    endif
    #if {$>%10} -l[-1] gt 0 +distance 0 -negate[0] distance[0] 0 -*[0] -1 -+ endl endif
  done
#  echo_stdout "("$M1","{sqrt($S1)}");("$M2", "{sqrt($S2)}")"
  blur[-1] 1 gt[-1] 0 -rm[0]
endl done -v +

#@cli segment_cells: scale1,scale2,threshold,size_threshold
#@cli : Cell segmentation using watershed
#@cli : $ 256,256 noise .05,2 ==. 1 b 10,1,1 min 80% noise 5% +segment_cells 2,10% contour2d[-1] , r[-1] 100%,100%,1,3,0 n 0,255 blend add
segment_cells: skip ${1=3},${2=10},${3=1},${4=3}
  e[^-1] "Cell segmentation using difference of Gaussians and watershed"
  v - repeat $! l[$>]
    jeje_dog $1,$2 +gt {ia+$3*${-mad}} area_fg 0 gt $4 +distance[1] 0
    max_patch[0] {round($4,1,1)} mul[0] [1] label[0] 0 watershed[0] [2] rm[-1] mul
  endl done v +

#@cli zernike:

zernike:
-skip  ${4=0},${5=0},${6=0},${7=0},${8=0},${9=0},${10=0},${11=0},${12=0},${13=0},${14=0},${15=0},${16=0},${17=0},${18=0}
f 'r=sqrt((x-$1)^2+(y-$2)^2);if(r<$3,a=atan2(y-$2,x-$1);$4+$5*2*r*sin(a)+$6*r*cos(a)+$7*sqrt(6)*r^2*sin(2*a)+$8*sqrt(3)*(2*r^2-1)+$9*sqrt(6)*r^2*cos(2*a)+$10*sqrt(8)*r^3*sin(3*a)+$11*sqrt(8)*(3*r^3-2*r)*sin(a)+$12*sqrt(8)*(3*r^3-2*r)*cos(a)+$13*sqrt(8)*r^3*cos(3*a)+$14*sqrt(10)*r^4*sin(4*a)+$15*sqrt(10)*(4*r^4-3*r^2)*sin(2*a)+$16*sqrt(5)*(6*r^4-3*r^2)*cos(2*a)+$17*sqrt(10)*(4*r^4-3*r^2)*cos(2*a)+$18*sqrt(10)*r^4*cos(4*a),0)'

#---------------------------------
#
#@cli :: Patterns
#
#---------------------------------

_challenge:
108,86,1,3 -l[-1] fractional_brownian_motion .25  -n 0,128 +norm gt[-1] 60% -* -resize 1080,860,1,3,1  +l[-1] blur 10 -shift[-1] 10,10 endl -max crop 10,10,100%,100% -negate endl -n 0,255

#@cli periodic_dots : _nb_angles,_scale,_start_angle
#@cli : Generate a peridic dot pattern with 'nb angles', 'scale' and 'start angle'.
#@cli : Default values 'nb angle=6', 'scale=4' and 'start_angle=0'
#@cli : $ 64,64 -periodic_dots 3,6,.1 -repeat 34 i [0] done append_tiles
periodic_dots : -skip ${1=6},${2=4},${3=.5}
e[^-1] "Generate a periodic dot pattern with "$1" angles, scale "$2", and orientation "$3"."
-v - -repeat $! -l[$>]
 -s c -repeat $! -l[$>]
 +resize {max(w,h)},{max(w,h)},100%,100%,0
 -l[-1]
 f 0
 -repeat $1
   circle {w*(.5+.5/$2*cos(2*pi*($>+$3/180*pi)/$1))},{w*(.5+.5/$2*sin(2*pi*($>+$3/180*pi)/$1))},0,1,255
 done
 fft a c -norm fftshift -n 0,255
 endl
 -resize[-1] [0],0
 k[-1]
 endl done a c
endl done -v +

#@cli turing_pattern : iter,dt,a,b,q,r,D
#@cli : Generate Turing pattern using a rection-diffusion equation
#@cli : du/dt = au(1-qv) + v(1-ru)
#@cli : dv/dt =  v(b-aquv) + u(-a+rv)
#@cli : the two parameters q and r are dictating the pattern final shape
#@cli : the diffusivity parameter influcences the scale
#@cli : http://www.dna.caltech.edu/courses/cs191/paperscs191/turing.pdf
#@cli : http://eprints.maths.ox.ac.uk/430/1/102.pdf
turing_pattern: -skip ${1=2000},${2=.1},${3=0.855},${4=-0.95},${5=2},${6=.1},${7=.5},${8=0}
  -v - -repeat $! -l[$>]
    -r 100%,100%,100%,2 blur 1 -n 0,1
    -repeat $1
      -progress {$>/$1*100}
      +laplacian[0] -mix_channels[-1] ($7,0;0,1)
      +f[0] 'u=i(x,y,z,0);v=i(x,y,z,1);a=$3;b=$4;q=$5;r=$6;if(c==0,a*u*(1-q*v*v)+v*(1-r*u),v*(b+a*q*u*v)+u*(-a+r*v))'
      -+[-1,-2]
      -*[-1] {$2/(1+max(abs(im),abs(iM)))}
      -+
      if {$8==1} +l -s c -n 0,1 a c -text $> -w -rm endl endif
    done
    -s c -n 0,1 a c
  endl done -v +

#@cli rays : _center_x,_center_y,_scale,_phase
#@cli : Generate rays patterns
#@cli : $ image.jpg +rays 155,127,10,10 -n[-1] 0,1 -mul
rays :
  e[^-1] "Generate a ray pattern centered in ($1,$2)"
  f 't=atan2(y-$2,x-$1);sin($3*t+$4)'

#@cli fractional_brownian_motion : 0<=_hurst_index<=1,_epsilon>0
#@cli : Generate fractional brownian motion nd signal
#@cli : Using a power low of the form (eps+|f|)^(-2^H-1)
#@cli : where f is the module of the frequency, H the husrt index and eps _epsilon.
#@cli : (see also 'clouds')
#@cli : $ 400,300 fractional_brownian_motion
fractional_brownian_motion : -skip ${1=.5},${2=1} check "$1>=0&&$1<=1" check "$2>0"
  e[^-1] "Generate pseudo fractional brownian motion"
  -v - -repeat $! -l[$>]
    f 0 -noise 1
    fft fftshift
    if {{0,d}==1}
      f 'rx=x-w/2;ry=y-h/2;i*($2+sqrt(rx*rx+ry*ry))^(-2*$1-1)'
    else
      f 'rx=x-w/2;ry=y-h/2;rz=z-d/2;i*($2+sqrt(rx*rx+ry*ry+rz*rz))^(-2*$1-1)'
    endif
    fftshift ifft
    k[0]
  endl done -v +

#@cli clouds : _density_of_blue_sky>0,_amplitude,0<=_hurst_index<=1,_epsilon>0
#@cli : Generate clouds on the image (see also 'frational_brownian_motion')
#@cli : $ 64,64 -repeat 3 +clouds {10+20*$>}% done -rm[0]
clouds : -skip ${1=50%},${2=1},${3=.5},${4=1}
  e[^-1] "Generate a cloud"
  -v - -repeat $! -l[$>]
    channels 0
    fractional_brownian_motion $3,$4 -negate -min $1 -negate -resize 100%,100%,1,4
    -n 0,255 -s c -n[0-2] 190,255  -n[3] 0,255 a c
  endl done -v +

#@cli clearbluesky:
#@cli : Generate a Clear Blue Sky
#@cli : $ 400,300,1,3 clearbluesky +clouds 50% blend alpha
clearbluesky :
  e[^-1] "Generate a blue sky"
  -v - -repeat $! -l[$>]
    1,2,1,3 f[-1] '63,70,120,144,190,215' -resize[-1] [0],5 k[-1]
    endl done -v +

#@cli mm_mozaic: size
#@cli : Create a mozaic image from the selected image
#@cli : -sp ? -mm_mozaic
mm_mozaic: -skip ${1=1}
  -repeat $! -l[$>]
  +gradient_norm -negate.
  +l. b. .75 +ge $1 -max_patch.. 3 d -* endl -to_rgb. -*[0,2] d
  -watershed.. . -rm.
  endl done

segment_watershed2 : check "${1=2}>=0"
  e[^-1] "Apply watershed segmentation on image$?, with edge threshold $1."
  -v - -repeat $! -l[$>]
    min={im}
    -+ {1+$min} +gradient_norm
    if {d>1} +f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1) && i<j(0,0,1) && i<j(0,0,-1),1,0)"
    else +f. "if(i<$1 && i<j(1) && i<j(-1) && i<j(0,1) && i<j(0,-1),1,0)"
    endif
    -*[-3,-1] -*. -1 -watershed.. . -rm.
    -- {1+$min}
    endl done -v +

#@cli freqy_pattern
#@cli : Create a periodic pattern containing a lot of frequencies
#@cli : sp ? freqy_pattern
freqy_pattern: skip ${1=1%},${2=100}
  e[^-1] "Generate a periodic pattern with many frequencies with parameter $1,$2"
  v - repeat $! l[$>]
    fftpolar +gaussian $1 mul[0] [2] rm. ifftpolar rm. n 0,{$2*pi} sin
  endl done v +

#---------------------------------
#
#@cli ::  Colors
#
#---------------------------------
#@cli wavelength_color: _wavelength
#@cli : Convert a wavelength [380,780] to RGB color
#@cli : from http://scienceprimer.com
#@cli : $ 1,1,1,1,1 -repeat 100 +wavelength_color[0] {380+3*$>} done -rm[0] a x
wavelength_color:
-v -
if {$1>=380&$1<440}
  R={-1*($1-440)/(440-380)}
  G=0
  B=1
elif {$1>=440&$1<490}
  R=0
  G={($1-440)/(490-440)}
  B=1
elif {$1>=490&$1<510}
  R=0
  G=1
  B={-1*($1-510)/(510-490)}
elif {$1>=510&$1<580}
  R={($1-510)/(580-510)}
  G=1
  B=0
elif {$1>=580&$1<645}
  R=1
  G={-1*($1-645)/(645-580)}
  B=0
elif {$1>=645&$1<780}
  R=1
  G=0
  B=0
else
  R=0
  G=0
  B=0
endif
-repeat $! -l[$>]
-mix_channels ($R;$G;$B)
endl done

#---------------------------------
#
#@cli ::  GIMP
#
#---------------------------------
#@gui _<b>Details</b>

#@gui Sharpen [Whiten] : jeje_whiten_frequency, jeje_whiten_frequency_preview(0)
#@gui : Alpha = float(50,0,100)
#@gui : Cut = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter equalizes frequencies in the image.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/06/01</i>.</small>")
jeje_whiten_frequency :
  -repeat $! -l[$>] -split_opacity -l[0]
    -whiten_frequency {exp($1/100)-1}
    if $2 c 0,255 -n 0,255 else -n 0,255 endif
  endl a c endl done

jeje_whiten_frequency_preview :
  gui_split_preview "jeje_whiten_frequency $1,$2",$-1

#@gui Sharpen [Hessian] : jeje_hessian_sharpen, jeje_hessian_sharpen_preview(0)
#@gui : Number of scales = int(3,2,10)
#@gui : Strength = float(1,0,10)
#@gui : Repeat = float(1,1,5)
#@gui : Cut = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2019/04/30</i>.</small>")
jeje_hessian_sharpen:
  repeat $! l[$>]
    split_opacity l[0] repeat $3 hessian_sharpen $1,$2 done endl a c
    if $4 c 0,255 n 0,255 else n 0,255 endif
  endl done

jeje_hessian_sharpen_preview:
  gui_split_preview "jeje_hessian_sharpen $1,$2,$3,$4",$-1

#@gui _<b>Repair</b>
#@gui Smooth [Block PCA]: jeje_denoise_patch_dict, jeje_denoise_patch_dict_preview(0)
#@gui : Patch = choice(1,4,8,16,32)
#@gui : Cycles = int(8,1,32)
#@gui : Components = float(1.1,1,9)
#@gui : Coefficients = float(1.1,0,9)
#@gui : Remix = float(0,0,1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note(<b>Note:</b>This filter is quite time consuming.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>.      Latest update: <i>2013/03/29</i>.</small>")
jeje_denoise_patch_dict:
  +denoise_patch_dict {2^($1+2)},$2,$3,$4
  -*[0] $5 -*[1] {1-$5} -+ c 0,255

jeje_denoise_patch_dict_preview :
  gui_split_preview "jeje_denoise_patch_dict ${1--2}",$-1

#@gui Smooth [Wiener] : jeje_local_wiener, jeje_local_wiener_preview(0)
#@gui : Scale = float(2,.5,10)
#@gui : Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : Value Action = choice("None","Cut","Normalize")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_local_wiener :
ac "-local_wiener $1",$2,$3

jeje_local_wiener_preview:
gui_split_preview "jeje_local_wiener $*",$-1

#@gui Smooth [IUWT] : jeje_denoise_iuwt,jeje_denoise_iuwt_preview(0)
#@gui : Threshold = float(3,0,10)
#@gui : Number of Scales = int(4,2,6)
#@gui : Wavelet = choice(2,"Spline B1","Spline B2","Spline B3","Spline B4","Spline B5","Spline B6")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small><b>Note:</b>Denoise the image by thresholding the coefficient of the Isotropic Undecimated Wavelet Transform.</small>")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/17/12</i>.</small>")
jeje_denoise_iuwt :
denoise_iuwt $1,$2,{$3+1}

jeje_denoise_iuwt_preview:
gui_split_preview "jeje_denoise_iuwt $1,$2,$3",$-1

#@gui Unstrip : jeje_unstrip, jeje_unstrip_preview(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Size = float(20,1,50)
#@gui : Sensitivity = float(4,1,10)
#@gui : Normalize = bool(true)
#@gui : FFT Preview = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/10</i>.</small>")
jeje_unstrip :
  -unstrip $1,$2,$3
  if $5 -tape -powerspectrum else
  if -$4 -n 0,255 else c 0,255 endif
  endif

jeje_unstrip_preview :
  gui_split_preview "jeje_unstrip $1,$2,$3,$4,$5",$-1

#@gui Repair Scanned Document: jeje_scandoc, jeje_scandoc_preview(0)
#@gui : note = note(Use filter is useful to post process document you scan with a digital camera. It peforms smoothing, background correction and white balance adjustement)
#@gui : Smoothness = int(3,1,7)
#@gui : Background = float(1,10,100)
#@gui : White Level = float(90,0,100)
#@gui : Black Level = float(5,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/11/03</i>.</small>")
jeje_scandoc :
  -scandoc $1,$2%,$3%,$4%

jeje_scandoc_preview :
  gui_split_preview "jeje_scandoc $1,$2,$3,$4",$-1

#@gui _<b>Patterns</b>
#@gui Periodic Dots : jeje_periodic_dots, jeje_periodic_dots_preview
#@gui : Number = int(6,2,32)
#@gui : Scale = float(4,1,12)
#@gui : Angle = float(0,0,360)
#@gui : Repeat = int(1,1,10)
#@gui : Map = choice(None,default,HSV,lines,hot,cool,jet,flag,cube)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_periodic_dots:
  tW={max(w,h)/$4}
  $tW,$tW
  -periodic_dots[-1] $*
  -repeat {$4*$4-1}
   i [-1]
  done
  append_tiles[1--1] $4,$4 k[-1]
  if {$5>0} -n 0,255 -map {$5-1} endif

jeje_periodic_dots_preview:
  jeje_periodic_dots $*

#@gui Turing : jeje_turing_pattern,gui_no_preview
#@gui : Scale = float(1,0,1)
#@gui : Iterations = int(2000,1,10000)
#@gui : Time Step = float(.1,.01,1)
#@gui : Alpha = float(.899,0,2)
#@gui : Beta = float(-.91,-2,2)
#@gui : Q = float(2,0,3)
#@gui : R = float(.1,0,3)
#@gui : Diffusivity = float(.25,.01,.6)
#@gui : sep = separator(), note = note(<small>Generate turing pattern using a system of coupled reaction/diffusion equations. The patterns can change from line to spots like structures depending on the parameters. You may use the 'Stencil' filter to achieve similar effects. http://en.wikipedia.org/wiki/The_Chemical_Basis_of_Morphogenesis</small>), note=note(<small>Since the computation is long there is no preview. </small>)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/01/16</i>.</small>")
jeje_turing_pattern:
  +l
    -r {$1*w},{$1*h},1,2
    -turing_pattern $2,$3,$4,$5,$6,$7,$8
  endl
  -r[1] 100%,100%,100%,3,0 -r[1] [0],[0],1,100%,5 -rm[0] blur .75 -n 0,255

#@gui Clouds : jeje_clouds, jeje_clouds_preview
#@gui : Density = float(50,0,100)
#@gui : Smoothness = float(.5,0,1)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_clouds :
 +clouds $1%,1,$2 blend alpha

jeje_clouds_preview :
 jeje_clouds $1,$2

#@gui Strip : jeje_strip, jeje_strip_preview
#@gui : Angle = float(45,0,90)
#@gui : Frequency = float(50,0,100)
#@gui : Phase =  float(0,0,180)
#@gui : Amplitude = float(1,0,2)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/06/07</i>.</small>")
jeje_strip :
  theta={pi*$1/180}
  f '0.5*i*(1+$4*sin(2*pi*$2*(cos($theta)*x/w+sin($theta)*y/h)+2*pi*$3/180))'
  c 0,255

jeje_strip_preview :
  gui_split_preview "jeje_strip $*",$-1

#@gui Rays : jeje_rays, jeje_rays_preview
#@gui : X Center = float(50,0,100)
#@gui : Y Center = float(50,0,100)
#@gui : Frequency = float(10,0,100)
#@gui : Angle = float(0,0,360)
#@gui : Proportion = float(0.5,0,1)
#@gui : Color 1 = color(255,0,0)
#@gui : Color 2 = color(255,255,0)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/29</i>.</small>")
jeje_rays :
  -s c
  -l[0] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 gt $5 -n $6,$9 endl
  -l[1] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 gt $5 -n $7,$10 endl
  -l[2] -rays {w*$1/100},{h*$2/100},$3,$4 -n 0,1 gt $5 -n $8,$11 endl
  a c

jeje_rays_preview:
  gui_split_preview "jeje_rays $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11",$-1

#@gui Fibers: jeje_fibers, jeje_fibers_preview
#@gui : Number = int(10,1,100)
#@gui : Length = int(50,1,100)
#@gui : Smoothness = float(10,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2015/07/17</i>.</small>")
jeje_fibers :
  100%,100%,1,1,0
  -l[-1]
    fibers $1,$2%,$3
    gt 0
    -n 0,255
  endl
  -r[-1] [0]
  -max

jeje_fibers_preview :
gui_split_preview "jeje_fibers $1,$2,$3",$-1

#@gui Freqy Pattern: jeje_freqy_pattern, jeje_freqy_pattern_preview
#@gui : Random = float(50,0,100)
#@gui : Scale 1 = float(33,1,100)
#@gui : Scale 2 = float(50,1,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/09/25</i>.</small>")
jeje_freqy_pattern:
  noise {$1*4}
  freqy_pattern {50/$2}%,{$3*2} n 0,255

jeje_freqy_pattern_preview:
  gui_split_preview "jeje_freqy_pattern $1,$2,$3",$4

#@gui _<b>Details</b>
#@gui Local Variance Normalization : jeje_normalize_local_variance, jeje_normalize_local_variance_preview
#@gui : Amplitude = float(50,0,100)
#@gui : Smoothness = float(5,0,20)
#@gui : Threshold = float(5,0,100)
#@gui : Repeat = int (1,1,4)
#@gui : sep = separator(), Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/10/30</i>.</small>")
jeje_normalize_local_variance :
  apply_channels "-normalize_local_variance $1,$2,$3,$4",$5,0
  c 0,255

jeje_normalize_local_variance_preview:
gui_split_preview "jeje_normalize_local_variance $1,$2,$3,$4,$5",$-1

#@gui DCP Dehaze : jeje_dehaze,jeje_dehaze_preview
#@gui : Scale = int(5,1,20)
#@gui : Strength = float(1,0,2)
#@gui : Min = float(.2,0,1)
#@gui : Max = float(1,0,1)
#@gui : Brighness = float(0,-100,100)
#@gui : Contrast = float(0,-100,100)
#@gui : Gamma = float(0,-100,100)
#@gui : Transmittance Map = bool(false)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Dark Channel Prior dehazing.Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/08/09</i>.</small>")
jeje_dehaze:
  apply_channels "dehaze {2*$1+1},$2,$3,$4,$5,$6,$7 if $8 k[1] -n 0,255 -to_rgb else k[0] endif",rgb,1

jeje_dehaze_preview:
  gui_split_preview "jeje_dehaze $1,$2,$3,$4,$5,$6,$7,$8",$9

#@gui Spotify : jeje_spotify,jeje_spotify_preview
#@gui : Scale = float(1,0.75,10)
#@gui : Iteration = int(1,1,50)
#@gui : Gamma = float(1,0,10)
#@gui : Cut = bool(1)
#@gui : sep = separator(), Channel(s) = choice(11,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/12/16</i>.</small>")
jeje_spotify:
  apply_channels "-spotify $1,$2  apply_gamma $3 if $4 c 0,255 else -n 0,255 endif",$5

jeje_spotify_preview:
  gui_split_preview "jeje_spotify $1,$2,$3,$4,$5",$6

#@gui _<b>Testing</b>
#@gui <i>J&#233;J&#233;</i>
#@gui 3D Rendering: jeje_render3d, jeje_render3d_preview
#@gui : Input Image = file()
#@gui : Size = int(8,4,16)
#@gui : Quality = int(6,2,16)
#@gui : Opacity = float(0.1,0,1)
#@gui : Angle X = float(240,0,360)
#@gui : Angle Y = float(0,0,360)
#@gui : Angle Z = float(30,0,360)
#@gui : Zoom = float(1,0,3)
#@gui : Top Color = color(32,32,64,255)
#@gui : Bottom Color = color(64,128,96,255)
#@gui : Render = bool(false)
#@gui : sep = separator(), note = note(<b>Note:</b>Adjust the 3D view first and then enable render to compute the volume rendering.)
#@gui : sep = separator(), note = note("<small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2013/05/29</i>.</small>")
jeje_render3d:
  W={0,w}
  1,2,1,4 f[-1] $9,$13,$10,$14,$11,$15,$12,$16 -resize[-1] {0,w},{0,h},1,4,5
  blend alpha
  i "$1" a[1--1] z
  -l[-1]
  if $17 display_volume $2,$3,$4 else jeje_boundingbox3d 20 endif
  -rotate3d 0,0,1,$7
  -rotate3d 0,1,0,$6
  -rotate3d 1,0,0,$5
  c3d -n3d -*3d {3*$W*$8/4}
  endl
  -object3d[0] [1],50%,50%,0,1
  -n 0,255
  -rm[1]

jeje_render3d_preview:
    jeje_render3d $"*"

#@gui Deconvolve: jeje_deconvolve, jeje_deconvolve_preview
#@gui : Iterations = int(20,1,100)
#@gui : Algorithm = choice(0,"Richardson-Lucy","Gold-Meinel")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"Need two layers (top layer is the blur)<br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2016/22/02</i>.</small>"}
jeje_deconvolve:
  if {$2==1}
    deconvolve_goldmeinel[0] [1],$1 -n[0] 0,255
  else
    deconvolve_richardsonlucy[0] [1],$1 -n[0] 0,255
  endif

jeje_deconvolve_preview:
  gui_split_preview "jeje_deconvolve $1,$2,$3",$4


#@gui Zernike: jeje_zernike_preview
#@gui : X = float(50,0,100)
#@gui : Y = float(50,0,100)
#@gui : R = float(50,0,100)
#@gui : Piston = float(0,-1,1)
#@gui : Horizontal Tilt = float(0,-1,1)
#@gui : Vertical Tilt = float(0,-1,1)
#@gui : Oblique Astigmatism = float(0,-1,1)
#@gui : Defocus = float(0,-1,1)
#@gui : Vertical Astigmatism = float(0,-1,1)
#@gui : Vertical Trefoil = float(0,-1,1)
#@gui : Vertical Coma = float(0,-1,1)
#@gui : Horizontal Coma = float(0,-1,1)
#@gui : Oblique Trefoil = float(0,-1,1)
#@gui : Oblique Quadrafoil = float(0,-1,1)
#@gui : Oblique Secondary Astigmatism = float(0,-1,1)
#@gui : Primary Spherical = float(0,-1,1)
#@gui : Vertical Secondary Astigmatism = float(0,-1,1)
#@gui : Vertical Quadrafoil = float(0,-1,1)
#@gui : Binarize  = bool(false)
#@gui : Period = float(0,0,256)
#@gui : Cycle Ratio = float(0,0,100)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui : sep = separator(), note = note{"https://en.wikipedia.org/wiki/Zernike_polynomials <br><small>Author : <i>J&#233;r&#244;me Boulanger</i>. Latest update: <i>2018/03/12</i>.</small>"}
jeje_zernike:
  zernike {$1*w/100},{$2*h/100},{$3*w/100},${4-18}
  n 0,255
  if $19 f '100*((i/$20)%1)<$21' n 0,255 endif

jeje_zernike_preview:
 gui_split_preview "jeje_zernike $*",$-1




# Local Variables:
# mode: sh
# time-stamp-pattern: "Lastest update: <i>%02y/%02m/%02d</i>"
# End:
#
# (End of G'MIC custom commands)
