#@gmic

## Filtres Samj début , le fichier doit commencer par : #@gmic

## Sites :
##         http://www.aljacom.com/~gmic/
##         http://samjcreations.blogspot.ca/

## Les fichiers "sylvie_alexandre.gmic" / "samj.gmic" / "user.gmic" (Windows) sont édités avec Notepad++    http://notepad-plus-plus.org/
## Mise en forme avec Notepad++ , remplacer par itérations :            \n\r\n\r\n\r\n\r  \n\r\n\r\n\r       \n\n\n\n\n\n  \n\n\n\n\n

## La licence des filtres est la même que celle de G'MIC.

## Respectez notre univers et nos lois http://fr.wikipedia.org/wiki/Charte_de_la_langue_française , merci  :o)

##  Conseils pour modifier ces filtres
##
## Les sources des filtres sylvie_alexandre.gmic sont disponibles à partir de ce lien :
##  https://github.com/dtschump/gmic-community/blob/master/include/sylvie_alexandre.gmic
## Vous pouvez tester, modifier, améliorer les filtres proposés en modifiant le nom du fichier "sylvie_alexandre.gmic" en "user.gmic" pour Windows.

## Pièges
## titi=-30  toto={($titi)^2} text_outline $toto,2,2,23,2,1,255 # donne 900 , méthode à utiliser avec les parenthèses
## titi=-30  toto={$titi^2} text_outline $toto,2,30,23,2,1,255 # donne -900

#----------------------
#@gui _<b>Testing</b>
#@gui <i>Samj</i>
#----------------------

#@gui About : _none_, samj_about
#@gui :_=note("<b>Informations - Compilations :</b>)
#@gui :_=link("http://www.aljacom.com/~gmic/","http://www.aljacom.com/~gmic/")
#@gui :_=link("http://samjcreations.blogspot.ca/","http://samjcreations.blogspot.ca/")
#@gui :_=note("<b>Filtres :</b>)
#@gui :_=link("https://github.com/dtschump/gmic-community","https://github.com/dtschump/gmic-community")
#@gui :_=note("Les filtres contenus dans ce répertoire sont majoritairement traduits en français et/ou en cours de développement.")
#@gui :_=note("The filters included in this directory are mostly translated into French and/or experimental.")
#@gui :_=note("Version 2021/11/27 GMIC 3.0.0_pre")

samj_about :

 #Rays_Of_Colors
 Color_Intensity=480
 Color_Density=(16/512*{w})
 Radius=40
 Border_smoothness=16
 Border_width=38
 Merge_Layers=1
 R_a=16
 V_a=8
 B_a=0

 {w},{h},1,3
 fill_color[-1] $R_a,$V_a,$B_a
 repeat $Color_Intensity
  R_Couleur={round(u)*255}
  V_Couleur={round(u)*255}
  B_Couleur={round(u)*255}
  X_point={round((u)*{w})}
  Y_point={round((u)*{h})}
  polygon[-1] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
 done
 fx_textured_glass[-1] 40,40,1,1,0,2,0
 fx_map_sphere[-1] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
 fill_color[-2] $R_a,$V_a,$B_a
 repeat $Color_Intensity
  R_Couleur={round(u)*255}
  V_Couleur={round(u)*255}
  B_Couleur={round(u)*255}
  X_point={round((u)*{w})}
  Y_point={round((u)*{h})}
  polygon[-2] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
 done
 fx_textured_glass[-2] 40,40,1,1,0,2,0
 fx_map_sphere[-2] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
 if $Merge_Layers==1
  blend[-2,-1] add
 endif
 to_rgb[-1]
 text_outline[-1] "Bonjour!",{{min({w},{h})}/20},{{min({w},{h})}/20},{{min({w},{h})}/5},1,255,255,255,255
#################################################################################################################################################################################################
#
#                                                                                                                                                                                  ARRAYS & TILES
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_arrays_and_tiles :
 Je_passe_l_hiver_en_Floride[-1]

#@gui <b>Arrays & Tiles</b>

#################################################
##                                             ##
##          samj_Filtres_Sur_Tuiles            ##
##                                             ##
#################################################

#@gui Filters On Tiles : samj_Filtres_Sur_Tuiles, samj_Filtres_Sur_Tuiles
#@gui :_=note("L'image est découpée en tuiles puis réassemblée.")
#@gui :_=note("Chaque tuile est modifiable par les filtres définis au paramètre 3.")
#@gui :_=note("Les filtres du paramètre 4 modifient l'aspect final si validation dans paramètre 2.")
#@gui :_=separator()
#@gui :_=note("The image is cut into tiles and then reassembled.")
#@gui :_=note("Each tile can be modified by the filters defined in parameter 3.")
#@gui :_=note("The filters of parameter 4 modify the final appearance if validation is allowed in parameter 2.")
#@gui :_=link("PDF Reference","http://gmic.eu/reference/gmic_reference.pdf")
#@gui :_=separator()
#@gui : 1 - XY Découpage/Cutting =int(20,2,256)
#@gui : 2 - Filtres À Utiliser = choice(0,"Tuiles/Tiles","Tuiles+Réassemblage/Tiles+Reassembly")
#@gui : 3 - Tuiles/Tiles = text{"shift 2,2,0,0,0 mirror y"}
#@gui : 4 - Réassemblage/Reassembly = text{"dilate 20"}
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/16</i>.</small>")

samj_Filtres_Sur_Tuiles :
repeat $! l[$>]
Haut={h}
Larg={w}
if $1>{min($Larg,$Haut)/4} Decoup={round({min($Larg,$Haut)/4})} else Decoup=$1 endif
resize {round($Larg/$Decoup)*$Decoup},{round($Haut/$Decoup)*$Decoup}
split y,$Decoup
split x,$Decoup
to_rgba
$3
append x
split x,$Decoup
append y
resize $Larg,$Haut
if $2==1 $4 endif
endl done

#################################################
##                                             ##
##         FIN samj_Filtres_Sur_Tuiles         ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Montage_Cercle_Spirale         ##
##                                             ##
#################################################

#@gui Montage Cercle Spirale : samj_Montage_Cercle_Spirale, samj_Montage_Cercle_Spirale_preview
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/samuser-avec-gmic-gimp-filtre-montage_21.html")
#@gui :_=note("<small>Utiliser au moins 6 calques pour ce filtre. La qualité de la prévisualisation est limitée.</small>")
#@gui :_=note("<small>Use at least 6 layers for this filter. The quality of the preview is limited.</small>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Montage Cercle Spirale</b></span>")
#@gui : 1 - Dimensions Approx. Pixels = int(2400,800,5100)
#@gui : 2 - Nb Images = int(8,6,36)
#@gui : 3 - Sélection = choice(0,"Calques du Haut/Top Layers","Calques du Bas/Bottom Layers")
#@gui : 4 - Forme = choice(1,"Cercle","Spirale","Spirale Inversée")
#@gui : 5-6-7-8 Fond/Background = color(0,0,0,0)
#@gui : 9 - Rotation Angle = choice(0,"0","90","-90","180")
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/12/22</i>.</small>")

samj_Montage_Cercle_Spirale :
NbImg=$!
NbImgMont=6
# ajouter images nécessaires
if $NbImg<$NbImgMont
	repeat {$NbImgMont-$NbImg}
		+Je_passe_l_hiver_en_Floride[-$NbImg]
	done
endif
samj_montage_row_GUI $2,$3,1,{$1*4},0,0,0,0,0,0,0
if $4==0
	samj_pseudo_trans_c[-1] 3,$4,{$1*2.304},{$1*2.304},100,1,0,0
else
	samj_pseudo_trans_c[-1] 3,$4,{$1*1.945},{$1*1.945},100,1,0,0
endif
replace_color[-1] 1,0,0,0,0,0,$5,$6,$7,$8
if $9==1
	mirror[-1] x permute[-1] yx
elif $9==2
	permute[-1] yxzc mirror[-1] x		
elif $9==3
	mirror[-1] x mirror[-1] y
endif

samj_Montage_Cercle_Spirale_preview :
samj_Montage_Cercle_Spirale 800,$2,$3,$4,$5,$6,$7,$8,$9

#####
samj_pseudo_trans_c :
# samj_pseudo_trans_c $K_H,$Spirale,$MS_W,$MS_H,$MS_Rad,$MS_Dil,$MS_Fad,$MS_FadP
# samj_pseudo_trans_c 2,0,2400,2400,100,1,0,0
skip ${1=2} # multiplicateur hauteur de expand
skip ${2=0} # 0=cercle 1=spirale 2=spirale inverse
Larg={w}
Haut={h}
to_rgba
if $2>0
	samj_Ecraser_Etirer 12,2,0,0,100,0
	samj_inclinaison_h $2,$Haut
endif
expand_y {$Haut*$1},0,0
shift 0,{$Haut*{$1-1}}
#map_sphere : _width>0,_height>0,_radius,_dilation>0,_fading>=0,_fading_power>=0
map_sphere $3,$4,$5,$6,$7,$8
{w},{h},1,4
blend alpha
autocrop

#################################################
##                                             ##
##       FIN samj_Montage_Cercle_Spirale       ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Montage_Zigzag             ##
##                                             ##
#################################################

#@gui Montage Zigzag : samj_Montage_Zigzag, samj_Montage_Zigzag
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/samuser-avec-gmic-gimp-filtre-montage.html")
#@gui :_=note("La hauteur du montage sera automatiquement ajustée si la valeur du paramètre 1 est dépassée.")
#@gui :_=note("The mounting height will be automatically adjusted if the value of parameter 1 is exceeded.")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Largeur Max. Approximative/Approximate Maximum Width</b></span>")
#@gui : 1 - Dimensions Max. Pixels = int(4800,1200,11400)
#@gui :_=note("<span foreground="orangered"><b>Montage Zigzag</b></span>")
#@gui : 2 - Nb Images = int(8,1,200)
#@gui : 3 - Sélection = choice(1,"Calques du Bas/Bottom Layers","Calques du Haut/Top Layers")
#@gui : 4 - Demi Hauteur/Half Height = int(256,0,1200)
#@gui : 5 - Inverser Inclinaison/Reverse Tilt = bool(0)
#@gui : 6 - Adoucir/Smooth = int(0,0,100)
#@gui : 7-8-9-10 Fond/Background = color(0,0,0,0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/12/20</i>.</small>")

samj_Montage_Zigzag :
DH=$4
if $3==0 rv endif
if $!>$2 rm[-{$2+1}--$!] endif
NbImg=$!
Index=0
Wmax=0
Wtot=0
# trouver la somme Wtot et Htot
repeat $NbImg
	Index={$Index-1}
	Htemp={h(#$Index)}
	Wtemp={w(#$Index)}
	#if {h}>{w} resize $Haut,$Haut else resize {{w}/{h}*$Haut},$Haut endif
	if $Htemp>$Wtemp Wtemp=$DH else Wtemp={$Wtemp/$Htemp*$DH} endif
	Wtot={$Wtot+round($Wtemp)}
done
if $Wtot>$1 DH={round($DH/$Wtot*$1)} endif
Index=0
repeat $NbImg
	Index={$Index-1}
	if {abs($Index+$5)%2}==0
		samj_inclinaison_h[$Index] 0,$DH
		Wtemp={w(#$Index)}
		Htemp={h(#$Index)}
		if $6>0
			smooth[$Index] $6
			polygon[$Index] 3,0,0,{$Wtemp-1},0,0,{$DH-1},1,0,0,0,0
			polygon[$Index] 3,1,{$Htemp-1},{$Wtemp-1},$DH,{$Wtemp-1},{$Htemp-1},1,0,0,0,0
		endif
	else
		samj_inclinaison_h[$Index] 1,$DH
		Wtemp={w(#$Index)}
		Htemp={h(#$Index)}
		if $6>0
			smooth[$Index] $6
			polygon[$Index] 3,1,0,{$Wtemp-1},0,{$Wtemp-1},{$DH-1},1,0,0,0,0
			polygon[$Index] 3,0,$DH,{$Wtemp-1},{$Htemp-1},0,{$Htemp-1},1,0,0,0,0
		endif
	endif	
done
append x
replace_color[-1] 1,0,0,0,0,0,$7,$8,$9,$10

#####
samj_inclinaison_h :
skip ${1=2} # modulo = pente
skip ${2=128} # 1/2 hauteur
to_rgba
if {$1%2}==0
	#pente
	+samj_demi_haut $2
	rv
	samj_demi_bas[-1] $2
	append y
else
	#pente négative
	mirror y
	+samj_demi_haut $2
	rv
	samj_demi_bas[-1] $2
	append y
	mirror y
endif
samj_demi_haut :
skip ${1=256} # hauteur
Haut=$1
if {h}>{w} resize $Haut,$Haut else resize {{w}/{h}*$Haut},$Haut endif
split x,$Haut
Index=0
Decalage=1
repeat $Haut
	Index={$Index-1}
	shift[$Index] 0,$Decalage,0,0,0
	Decalage={$Decalage+1}
done 
append x
samj_demi_bas :
skip ${1=256} # hauteur
Haut=$1
if {h}>{w} resize $Haut,$Haut else resize {{w}/{h}*$Haut},$Haut endif
split x,$Haut
Index=0
Decalage=$Haut
mirror y
repeat {$Haut-1}
	Index={$Index-1}
	shift[$Index] 0,$Decalage,0,0,0
	Decalage={$Decalage-1}
done 
append x
mirror y

#################################################
##                                             ##
##           FIN samj_Montage_Zigzag           ##
##                                             ##
#################################################
#################################################
##                                             ##
##      samj_Montage_Figures_Geometriques      ##
##                                             ##
#################################################

#@gui Montage Geometric Figures : samj_Montage_Figures_Geometriques, samj_Montage_Figures_Geometriques
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/nouveaux-montages-dimages-avec-gmic.html")
#@gui :_=note("<span foreground="orangered"><b>Rapidité de traitement/Speed of image processing</b></span>")
#@gui : 1 - Dimensions Max. Pixels = int(4800,2400,11400)
#@gui :_=note("<span foreground="orangered"><b>Montage</b></span>")
#@gui : 2 - Colonnes/Columns - 0 Automatique = int(0,0,20)
#@gui : 3 - Colonnes vers Lignes / Columns to Rows = bool(0)
#@gui : 4 - Montage Type = choice(1,"Basique","Polygones - Param 17-18","Rideau - Param 19-20","Oeuf Egg Rosillo - Param 21-22","Kiss Curve","Fleur Flower")
#@gui : 5-6-7-8 Fond/Background = color(0,0,0,0)
#@gui :_=note("<span foreground="orangered"><b>Calques/Layers</b></span>")
#@gui : 9 - Sélection = choice(1,"Calques du Bas/Bottom Layers","Calques du Haut/Top Layers")
#@gui : 10 - Image Carrée / Square Image = bool(0)
#@gui : 11 - Décalage/Shift X (%) = float(0,-100,100)
#@gui : 12 - Décalage/Shift Y (%) = float(0,-100,100)
#@gui : 13 - Agrandissement/Enlarging = float(1,0.35,2.75)
#@gui : 14 - Contour/Padding = int(10,0,20)
#@gui : 15-16-17 Contour/Padding = color(255,255,255)
#@gui :_=note("<span foreground="orangered"><b>Polygones</b></span>")
#@gui : 18 - Nb Côtés/Sides Polygone = int(6,3,24)
#@gui : 19 - Rotation Polygone = float(30,0,360)
#@gui :_=note("<span foreground="orangered"><b>Rideau</b></span>")
#@gui : 20 - Effet / Effect = choice(1,"1","2","3","4","5","6","7","8","9","10","11","12")
#@gui : 21 - Intensité = int(-3,-5,1)
#@gui :_=note("<span foreground="orangered"><b>Oeuf Egg</b></span>")
#@gui : 22 - Forme = float(300,200,400)
#@gui : 23 - Angle = float(270,-360,360)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/12/17</i>.</small>")

samj_Montage_Figures_Geometriques :

Limite=$1
Col=$2
ColToRow=$3
MontType=$4
RBg=$5
VBg=$6
BBg=$7
ABg=$8
Select=$9
ImgCar=$10
ShiftX=$11
ShiftY=$12
Agr=$13
Padd=$14
RPad=$15
VPad=$16
BPad=$17
NbCotPoly=$18
RotPoly=$19
EffLig=$20
IntLig=$21
ForOeuf=$22
AngOeuf=$23

to_rgba
# Fond blanc systématiquement. À voir {i3}<1
NbImg=$!
Index=0
repeat $NbImg
	Index={$Index-1}
	Htemp={h(#$Index)}
	Wtemp={w(#$Index)}
	if $ImgCar==1
		if {$Wtemp}>{$Htemp}
			crop[$Index] {{{$Wtemp}-{$Htemp}}/2},0,{{$Htemp}+{{{$Wtemp}-{$Htemp}}/2}-1},{{$Htemp}-1}
		elif {$Wtemp}<{$Htemp}
			crop[$Index] 0,{{{$Htemp}-{$Wtemp}}/2},{{$Wtemp}-1},{{$Wtemp}+{{{$Htemp}-{$Wtemp}}/2}-1}
		endif
	endif
	Htemp={h(#$Index)}
	Wtemp={w(#$Index)}
	$Wtemp,$Htemp,1,4
	fill_color[-1] 255,255,255,255
	rv[-1,{$Index-1}]
	blend[-1,{$Index-1}] alpha
done
shift $ShiftX%,$ShiftY%,0,0,2
if $ColToRow==1 mirror y permute yx endif
if $Select==0 rv endif
NbImg=$!
if $Col==0
	NbCol={round($NbImg^0.5)}
	if {$NbImg%$NbCol}!=0  	NbCol={$NbCol+1} endif
else
	NbCol=$Col
endif
NbLig={round($NbImg/$NbCol)}
if {{$NbImg%$NbCol}!=0}&&{$Col>1}  NbLig={$NbLig+1} endif
DimMax={$Limite/max($NbCol,$NbLig)} # Faux mais valable pour le moment. Manque Agr et Padd.
W,H=${-max_wh}
if {{max($W,$H)}>$DimMax}
	if $DimMax<50
		DimMax=50
	endif
endif
# compromis pour l'agrandissement
if {$MontType==1&&$ImgCar==1} Agr={$Agr-0.18} endif
if {$MontType==3&&$ImgCar==1} Agr={$Agr-0.18} endif
if {$MontType==4&&$ImgCar==1} Agr={$Agr-0.17} endif
if {$MontType==5&&$ImgCar==1} Agr={$Agr-0.24} endif
rr2d {$DimMax*$Agr},{$DimMax*$Agr},2,1
if $MontType==0
	Hor={{h}/$Agr}
	Wor={{w}/$Agr}
	crop {{{w}-$Wor}/2},{{{h}-$Hor}/2},$Wor,$Hor
	autocrop
	frame_xy $Padd,$Padd,$RPad,$VPad,$BPad,255
elif $MontType==1
	to_rgb
	Index=0
	repeat $NbImg
		Index={$Index-1}
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		DimW={{min($Htemp,$Wtemp)}/$Agr}
		DimH=$DimW
		Ang={$RotPoly+{360/$NbCotPoly}}
		$DimW,$DimH,1,4
		samj_dessiner_un_polygone[-1] $NbCotPoly,50,50,$Ang,40,50,1,0,0,0,0,0,0,0,0,0,0,255,0,0,255,0,0,0,127,127,127,0,0,0,0,0,255,255,255,0,0,0,0,1,255,0,0,0,1
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		{$DimW+{3*$Padd}},{$DimH+{3*$Padd}},1,4
		samj_dessiner_un_polygone[-1] $NbCotPoly,50,50,$Ang,40,50,1,$RPad,$VPad,$BPad,0,0,0,0,0,0,0,255,0,0,255,0,0,0,127,127,127,0,0,0,0,0,255,255,255,0,0,0,0,1,255,0,0,0,1
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		replace_color[$Index] 2,0,0,0,0,0,0,0,0,0
		autocrop[$Index]
	done
elif $MontType==2
	to_rgb
	Index=0
	repeat $NbImg
		Index={$Index-1}
		autocrop[$Index]
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		Hor={{h(#$Index)}/$Agr}
		Wor={{w(#$Index)}/$Agr}
		crop[$Index] {{$Wtemp-$Wor}/2},{{$Htemp-$Hor}/2},$Wor,$Hor
		samj_Des_Lignes_002[$Index] {{$Htemp+$Wtemp}/2/abs($IntLig)*$Agr},0,0,255,255,255,255,0,$EffLig,1,50,50,0,0,0,0,1
		to_rgba[$Index]
		frame_xy[$Index] $Padd,$Padd,$RPad,$VPad,$BPad,255
	done
	RBg=255
	VBg=255
	BBg=255
	ABg=255
elif $MontType==3
	to_rgb
	Index=0
	repeat $NbImg
		Index={$Index-1}
		autocrop[$Index]
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		Hor={$Htemp/$Agr}
		Wor={$Wtemp/$Agr}
		RotOeuf=$AngOeuf
		if {$Wor<$Hor}&&{$AngOeuf<0}
			RotOeuf={$AngOeuf-90}
		endif
		$Wor,$Hor,1,4
		samj_Egg_Oeuf_Rosillo[-1] 50,50,40,200,$ForOeuf,$RotOeuf,255,255,255,255,1,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,1
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		{$Wor+{3*$Padd}},{$Hor+{3*$Padd}},1,4
		samj_Egg_Oeuf_Rosillo[-1] 50,50,40,200,$ForOeuf,$RotOeuf,255,255,255,255,1,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,1
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		replace_color[$Index] 2,0,0,0,0,0,0,0,0,0
		autocrop[$Index]
	done
elif $MontType==4
	to_rgb
	Index=0
	repeat $NbImg
		Index={$Index-1}
		autocrop[$Index]
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		Hor={$Htemp/$Agr}
		Wor={$Wtemp/$Agr}
		$Wor,$Hor,1,4
		samj_kiss_curve[-1]
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		{$Wor+{3*$Padd}},{$Hor+{3*$Padd}},1,4
		samj_kiss_curve[-1]
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		replace_color[$Index] 2,0,0,0,0,0,0,0,0,0
		autocrop[$Index]
	done
elif $MontType==5
	to_rgb
	Index=0
	repeat $NbImg
		Index={$Index-1}
		autocrop[$Index]
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		Hor={$Htemp/$Agr}
		Wor={$Wtemp/$Agr}
		$Wor,$Hor,1,4
		samj_Spirographe_Fleur[-1]
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		{$Wor+{3*$Padd}},{$Hor+{3*$Padd}},1,4
		samj_Spirographe_Fleur[-1]
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
		replace_color[$Index] 2,0,0,0,0,0,0,0,0,0
		autocrop[$Index]
	done
endif

append_tiles $Col
replace_color[-1] 1,0,0,0,0,0,$RBg,$VBg,$BBg,$ABg
if $ColToRow==1 mirror x permute yx endif


##### Kiss curve https://mathcurve.com/courbes2d/bouche/bouche.shtml    x=a*cos t    y=a*sin cube t
samj_kiss_curve :
X={round({{w}/2})}
Y={round({{h}/2})}
Valeur_A={round({{{w}+{h}}*0.2})}
Valeur_B={$Valeur_A*2}
Valeur_C={$Valeur_A*3}
Angle=0
X_Kiss_A_Imprimer=0
Y_Kiss_A_Imprimer=0
X_Kiss_A_Imprimer_Precedent={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
Y_Kiss_A_Imprimer_Precedent={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}
Nb_boucles=0
repeat 720
	Nb_boucles={$Nb_boucles+1}
	Angle={$Nb_boucles/2}
	X_Kiss_A_Imprimer={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
	Y_Kiss_A_Imprimer={$Y+{$Valeur_A*{{sin({pi/180*$Angle})}^3}}}
	polygon 3,$X,$Y,$X_Kiss_A_Imprimer_Precedent,$Y_Kiss_A_Imprimer_Precedent,$X_Kiss_A_Imprimer,$Y_Kiss_A_Imprimer,1,255,255,255,255
	X_Kiss_A_Imprimer_Precedent=$X_Kiss_A_Imprimer
	Y_Kiss_A_Imprimer_Precedent=$Y_Kiss_A_Imprimer
done

##### http://en.wikipedia.org/wiki/Spirograph
samj_Spirographe_Fleur :
theta=0
Rayon_1={{w}*300/{1000}}
Rayon_2={{w}*30/{1000}}
Position_Stylo={{w}*8/{1000}}
X={round({{w}/2})}
Y={round({{h}/2})}
Ancien_point_X=$X
Nouveau_point_X=$Y
Ancien_point_Y=$X
Nouveau_point_Y=$Y
repeat 720
	Nouveau_point_X={$X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
	Nouveau_point_Y={$Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
	polygon 3,$X,$Y,$Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,255,255,255,255
	Ancien_point_X=$Nouveau_point_X
	Ancien_point_Y=$Nouveau_point_Y
	theta={$theta+0.5}
done

#################################################
##                                             ##
##    FIN samj_Montage_Figures_Geometriques    ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Montage_Pappus_Chain          ##
##                                             ##
#################################################

#@gui Montage Pappus Chain : samj_Montage_Pappus_Chain, samj_Montage_Pappus_Chain_Preview
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/nouveaux-montages-dimages-avec-gmic.html")
#@gui :_=note("<small>Utiliser 10 calques pour ce filtre. La qualité de la prévisualisation est limitée.</small>")
#@gui :_=note("<small>Use 10 layers for this filter. The quality of the preview is limited.</small>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Rendu - Rendering</b></span>")
#@gui : 1 - Rayon Cercle Extérieur Pix. = int(1200,600,3600)
#@gui : 2 - Rotation Rendu/Rendering = float(0,0,360)
#@gui :_=note("<span foreground="orangered"><b>Images Montage</b></span>")
#@gui : 3 - Sélection = choice(1,"Calques du Bas/Bottom Layers","Calques du Haut/Top Layers")
#@gui : 4 - Rotation Angle = choice(0,"0","90","-90","180")
#@gui : 5 - Dimension Images = float(35,5,80)
#@gui : 6 - Agrandissement/Enlarging % = float(100,20,200)
#@gui : 7 - Décalage/Shift X (%) = float(0,-100,100)
#@gui : 8 - Décalage/Shift Y (%) = float(0,-100,100)
#@gui :_=note("<span foreground="orangered"><b>Fond/Background</b></span>")
#@gui : 9-10-11-12 Cercle Central = color(255,255,255,255)
#@gui : 13-14-15-16 Extérieur = color(0,0,0,0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/12/09</i>.</small>")

samj_Montage_Pappus_Chain :

X=$1
Y=$1
Rayon_Cercle_Exterieur=$1
Rayon_Premier_Cercle={round({$Rayon_Cercle_Exterieur*$6/100})}
Angle_inclinaison=$2
InvSelect=$3
Angle_Images=$4
Rayon_Premier_Cercle={round({$Rayon_Cercle_Exterieur*$5/100})}
Agr=$6
Shift_X=$7
Shift_Y=$8
R_CE=$9
V_CE=$10
B_CE=$11
A_CE=$12
R_Im=$13
V_Im=$14
B_Im=$15
A_Im=$16


# Positions - Rayons
X_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{cos({pi/180*$Angle_inclinaison})}}
Y_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{sin({pi/180*$Angle_inclinaison})}}
X_Cc={$Rayon_Premier_Cercle*{cos({pi/180*{$Angle_inclinaison+180}})}}
Y_Cc={$Rayon_Premier_Cercle*{sin({pi/180*{$Angle_inclinaison+180}})}}
R_Cc={$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}
#####
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=1
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_d={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Va={$R_Cc+$R_Cercle_d}
Vb={$Rayon_Premier_Cercle+$R_Cercle_d}
d_x={$X_Cb-$X_Cc}
d_y={$Y_Cb-$Y_Cc}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cc+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cc+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_da={$c_x2+$o_rx}
Y_Cercle_da={$c_y2+$o_ry}
X_Cercle_db={$c_x2-$o_rx}
Y_Cercle_db={$c_y2-$o_ry}
#####
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=4
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_e={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_e}
Va={$R_Cercle_d+$R_Cercle_e}
d_x={$X_Cc-$X_Cercle_da}
d_y={$Y_Cc-$Y_Cercle_da}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cercle_da+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_da+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_eb={$c_x2-$o_rx}
Y_Cercle_eb={$c_y2-$o_ry}
d_x={$X_Cc-$X_Cercle_db}
d_y={$Y_Cc-$Y_Cercle_db}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cercle_db+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_db+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_ea={$c_x2+$o_rx}
Y_Cercle_ea={$c_y2+$o_ry}
#####
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=9
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_f={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_f}
Va={$R_Cercle_e+$R_Cercle_f}
d_x={$X_Cc-$X_Cercle_ea}
d_y={$Y_Cc-$Y_Cercle_ea}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cercle_ea+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_ea+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_fa={$c_x2+$o_rx}
Y_Cercle_fa={$c_y2+$o_ry}
d_x={$X_Cc-$X_Cercle_eb}
d_y={$Y_Cc-$Y_Cercle_eb}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cercle_eb+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_eb+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_fb={$c_x2-$o_rx}
Y_Cercle_fb={$c_y2-$o_ry}
#####
R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
n_Pappus=16
b_Pappus={$R_Cc}
a_Pappus={$Rayon_Premier_Cercle}
R_Cercle_g={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}
Vb={$R_Cc+$R_Cercle_g}
Va={$R_Cercle_f+$R_Cercle_g}
d_x={$X_Cc-$X_Cercle_fa}
d_y={$Y_Cc-$Y_Cercle_fa}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cercle_fa+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_fa+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_ga={$c_x2+$o_rx}
Y_Cercle_ga={$c_y2+$o_ry}
d_x={$X_Cc-$X_Cercle_fb}
d_y={$Y_Cc-$Y_Cercle_fb}
d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
c_x2={$X_Cercle_fb+{$d_x*$d_p0_p2/$d_between_centers}}
c_y2={$Y_Cercle_fb+{$d_y*$d_p0_p2/$d_between_centers}}
d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
o_rx={-$d_y*$d_h/$d_between_centers}
o_ry={$d_x*$d_h/$d_between_centers}
X_Cercle_gb={$c_x2-$o_rx}
Y_Cercle_gb={$c_y2-$o_ry}

# Affichage
if $InvSelect==1 rv endif
NbImg=$!
NbImgMont=10
if $NbImg>$NbImgMont rm[-{$NbImgMont+1}--$!] endif

# Fond blanc systématiquement. À voir {i3}<1
NbImg=$!
Index=0
repeat $NbImg
	Index={$Index-1}
	Htemp={h(#$Index)}
	Wtemp={w(#$Index)}
	$Wtemp,$Htemp,1,4
	fill_color[-1] 255,255,255,255
	rv[-1,{$Index-1}]
	blend[-1,{$Index-1}] alpha
done

to_rgb

# ajouter images nécessaires
if $NbImg<$NbImgMont
	repeat {$NbImgMont-$NbImg}
		+Je_passe_l_hiver_en_Floride[-$NbImg]
	done
endif
{$X*2},{$Y*2},1,4
Nb_boucles=0
repeat 10
	Nb_boucles={$Nb_boucles+1}
	if $Nb_boucles==1
		Ray={round($Rayon_Premier_Cercle)}
		DepX={round({$X+$X_Cb})}
		DepY={round({$Y+$Y_Cb})}
	elif $Nb_boucles==2
		Ray={round($R_Cc)}
		DepX={round({$X+$X_Cc})}
		DepY={round({$Y+$Y_Cc})}
	elif $Nb_boucles==3
		Ray={round($R_Cercle_d)}
		DepX={round({$X+$X_Cercle_da})}
		DepY={round({$Y+$Y_Cercle_da})}
	elif $Nb_boucles==4
		Ray={round($R_Cercle_d)}
		DepX={round({$X+$X_Cercle_db})}
		DepY={round({$Y+$Y_Cercle_db})}
	elif $Nb_boucles==5
		Ray={round($R_Cercle_e)}
		DepX={round({$X+$X_Cercle_ea})}
		DepY={round({$Y+$Y_Cercle_ea})}
	elif $Nb_boucles==6
		Ray={round($R_Cercle_e)}
		DepX={round({$X+$X_Cercle_eb})}
		DepY={round({$Y+$Y_Cercle_eb})}
	elif $Nb_boucles==7
		Ray={round($R_Cercle_f)}
		DepX={round({$X+$X_Cercle_fa})}
		DepY={round({$Y+$Y_Cercle_fa})}
	elif $Nb_boucles==8
		Ray={round($R_Cercle_f)}
		DepX={round({$X+$X_Cercle_fb})}
		DepY={round({$Y+$Y_Cercle_fb})}
	elif $Nb_boucles==9
		Ray={round($R_Cercle_g)}
		DepX={round({$X+$X_Cercle_ga})}
		DepY={round({$Y+$Y_Cercle_ga})}
	elif $Nb_boucles==10
		Ray={round($R_Cercle_g)}
		DepX={round({$X+$X_Cercle_gb})}
		DepY={round({$Y+$Y_Cercle_gb})}
	endif

	Index=-3
	{$X*2},{$Y*2},1,4
	fill_color[-1] 0,0,0,0
	circle[-1] $DepX,$DepY,$Ray,1,0,0,0,255
	Wimg={w(#$Index)}
	Himg={h(#$Index)}
	RayD={$Ray*2}
	if $Wimg>$Himg
		resize[-3] {$Wimg/$Himg*$RayD},$RayD
	else
		resize[-3] $RayD,{$Himg/$Wimg*$RayD}
	endif
	if $Agr!=100 resize[-3] $Agr%,$Agr% endif
	if $Angle_Images==1
		mirror[-3] x permute[-3] yx
	elif $Angle_Images==2
		permute[-3] yxzc mirror[-3] x		
	elif $Angle_Images==3
		mirror[-3] x mirror[-3] y
	endif
	shift[-3] $Shift_X,$Shift_Y,0,0,2
	Wimg={w(#$Index)} # màj
	Himg={h(#$Index)} # màj
	DepXi={$DepX-$Ray-{{$Wimg-$RayD}/2}}
	DepYi={$DepY-$Ray-{{$Himg-$RayD}/2}}
	if $DepXi<0 DepXi=0 endif
	if $DepYi<0 DepYi=0 endif
	expand_x[$Index] $DepXi,0
	expand_y[$Index] $DepYi,0
	crop[$Index] 0,0,{{$X*2}-1},{{$Y*2}-1},0
	+Je_passe_l_hiver_en_Floride[-3]
	blend[-1,-2] alpha
	rm[-3]
	blend[-1,-2] alpha
done

if {$R_CE+$V_CE+$B_CE+$A_CE}>0
	{$X*2},{$Y*2},1,4
	ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
	rv[-1,-2]
	blend[-1,-2] alpha
endif

if {$R_Im+$V_Im+$B_Im+$A_Im}>0
	{$X*2},{$Y*2},1,4
	fill_color[-1] $R_Im,$V_Im,$B_Im,$A_Im
	rv[-1,-2]
	blend[-1,-2] alpha
endif

samj_Montage_Pappus_Chain_Preview :
samj_Montage_Pappus_Chain 400,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16

#################################################
##                                             ##
##        FIN samj_Montage_Pappus_Chain        ##
##                                             ##
#################################################
#################################################
##                                             ##
##      samj_Montage_Annular_Steiner_Chain     ##
##                                             ##
#################################################

#@gui Montage Annular Steiner Chain : samj_Montage_Annular_Steiner_Chain, samj_Montage_Annular_Steiner_Chain_Preview
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/nouveaux-montages-dimages-avec-gmic.html")
#@gui :_=note("<small>Utiliser au moins 4 calques pour ce filtre. La qualité de la prévisualisation est limitée.</small>")
#@gui :_=note("<small>Use at least 4 layers for this filter. The quality of the preview is limited.</small>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Image Finale</b></span>")
#@gui : 1 - Dimension Pix. = int(2400,800,7200)
#@gui : 2 - Nb Images Extérieures/Annular Chain = int(12,3,180)
#@gui : 3 - Sélection = choice(1,"Calques du Bas/Bottom Layers","Calques du Haut/Top Layers")
#@gui : 4-5-6-7 Fond/Background = color(0,0,0,0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Image Centrale</b></span>")
#@gui : 8 - Position X Origine (%) = float(0,-100,100)
#@gui : 9 - Position Y Origine (%) = float(0,-100,100)
#@gui : 10 - Agrandissement/Enlarging = float(1,1,100)
#@gui : 11 - Décalage/Shift X (%) = float(0,-100,100)
#@gui : 12 - Décalage/Shift Y (%) = float(0,-100,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Images Extérieures/Annular Chain</b></span>")
#@gui : 13 - Angle Décalage Image Contour = float(90,0,360)
#@gui : 14 - Rotation Images = bool(1)
#@gui : 15 - Image Contour Dimension = float(100,1,100)
#@gui : 16 - Angle Inclinaison/Tilt = float(0,0,360)
#@gui : 17 - Agrandissement/Enlarging = float(1,0.2,2)
#@gui : 18 - Décalage/Shift X (%) = float(0,-100,100)
#@gui : 19 - Décalage/Shift Y (%) = float(0,-100,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/12/09</i>.</small>")

samj_Montage_Annular_Steiner_Chain:

Dimension_Finale=$1
Nb_Circles_Surrounding=$2
InvSelect=$3
Rf=$4
Vf=$5
Bf=$6
Af=$7
varx=$8
vary=$9
Dimension_Image={101-$10}
Shift_X=$11
Shift_Y=$12
Decalage_Angle_Images_Contour=$13
RotAng=$14
Image_Contour_Dimension=$15
Angle_inclinaison=$16
Agr=$17
Shift_Xe=$18
Shift_Ye=$19

if $InvSelect==1 rv endif

NbImg=$!
NbImgMont={$Nb_Circles_Surrounding+1}
if $!>$NbImgMont rm[-{$NbImgMont+1}--$!] endif

# Fond blanc systématiquement. À voir {i3}<1
NbImg=$!
Index=0
repeat $NbImg
	Index={$Index-1}
	Htemp={h(#$Index)}
	Wtemp={w(#$Index)}
	$Wtemp,$Htemp,1,4
	fill_color[-1] 255,255,255,255
	rv[-1,{$Index-1}]
	blend[-1,{$Index-1}] alpha
done
to_rgb

# ajouter images nécessaires
Wsrc={w}
Hsrc={h}
WHsrc={$Wsrc/$Hsrc}
HWsrc={$Hsrc/$Wsrc}
NbImg=$! # màj
if $NbImg<4
	repeat {4-$NbImg}
		+Je_passe_l_hiver_en_Floride[-$NbImg]
	done
endif

NbImg=$! # màj
if $Nb_Circles_Surrounding>{$NbImg-1} Nb_Circles_Surrounding={$NbImg-1} endif
Angle_Theta={pi/$Nb_Circles_Surrounding}
# variables dimensions
Rayon_Cercle_Exterieur_Final={round({$Dimension_Finale/2})}
Rayon_Cercle_Centre_Final={round({{$Rayon_Cercle_Exterieur_Final*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}})}
Rayon_Cercles_Ext_Final={round({{$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final}/2})}
Rayon_Centres_C_Ext_Final={round({$Rayon_Cercle_Centre_Final+$Rayon_Cercles_Ext_Final})}
Rayon_Tang_Final={round({{{$Rayon_Centres_C_Ext_Final*$Rayon_Centres_C_Ext_Final}-{$Rayon_Cercles_Ext_Final*$Rayon_Cercles_Ext_Final}}^0.5})}
Dim_Img_Ext={round({{$Rayon_Centres_C_Ext_Final-$Rayon_Cercle_Centre_Final}*2*$Agr})}
X={round({$Wsrc*{$varx/100}})}
Y={round({$Hsrc*{$vary/100}})}
Fin_X={round({{$Wsrc-$X}*$Dimension_Image/{100}})}
Fin_Y={round({{$Hsrc-$Y}*$Dimension_Image/{100}})}

if $Fin_X>$Fin_Y
	Rayon_Cercle_Centre_Origine={$Fin_Y/2}
else
	Rayon_Cercle_Centre_Origine={$Fin_X/2}
endif

# masque image centrale
{$Rayon_Cercle_Centre_Final*2},{$Rayon_Cercle_Centre_Final*2},1,4
fill_color[-1] 0,0,0,0
circle[-1] 50%,50%,{{w}/2},1,0,0,0,255

# image centrale
shift[-2] $Shift_X%,$Shift_Y%,0,0,2
+Je_passe_l_hiver_en_Floride[-2]
crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
resize2dy[-1] {$Rayon_Cercle_Centre_Final*2}
blend[-1,-2] alpha,1,1
expand_xy[-1] {$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final},0
rm[-2]

Nb_boucles=0
X_ext=0
Y_ext=0
Angle=0
Dimension_Img_pivotee=0
X_Deplacement=0
Y_Deplacement=0

repeat $Nb_Circles_Surrounding

	Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
	X_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
	Y_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
	Nb_boucles={$Nb_boucles+1}

	# masque images extérieures
	{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},1,4
	fill_color[-1] 0,0,0,0
	circle[-1] 50%,50%,{{w}/2},1,0,0,0,255

	# images extérieures
	+Je_passe_l_hiver_en_Floride[-3]
	if {w}>{h}
		resize[-1] {{w}/{h}*$Dim_Img_Ext},$Dim_Img_Ext
	else
		resize[-1] $Dim_Img_Ext,{{h}/{w}*$Dim_Img_Ext}
	endif
	shift[-1] $Shift_Xe%,$Shift_Ye%,0,0,2
	blend[-1,-2] alpha
	rm[-3]
	if $RotAng==1 rotate[-1] {$Angle+$Decalage_Angle_Images_Contour} endif
	# genre d'autocrop
	crop[-1] {{{w}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{{w}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}},{{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}}
	# déplacer aux bonnes coordonnées
	X_Deplacement={$X_ext-$Rayon_Cercles_Ext_Final}
	Y_Deplacement={$Y_ext-$Rayon_Cercles_Ext_Final}
	crop[-1] {-$X_Deplacement},{-$Y_Deplacement},{{2*$Rayon_Cercle_Exterieur_Final}-$X_Deplacement-1},{{2*$Rayon_Cercle_Exterieur_Final}-$Y_Deplacement-1},0
	# mélange vers image centrale
	blend[-1,-2] alpha,1,1

done

if {$Rf+$Vf+$Bf+$Af}>0
	replace_color[-1] 1,0,0,0,0,0,$Rf,$Vf,$Bf,$Af
endif
c 0,255

# text_outline $Wsrc-$Hsrc,20,20,36,1,255,0,0,255
# text_outline $Dimension_Finale-$Rayon_Cercle_Centre_Final-$Rayon_Cercle_Exterieur_Final-$Rayon_Centres_C_Ext_Final-$Rayon_Tang_Final-$Dim_Img_Ext,20,20,36,1,255,0,0,255

samj_Montage_Annular_Steiner_Chain_Preview :

samj_Montage_Annular_Steiner_Chain 1200,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19

#################################################
##                                             ##
##   FIN samj_Montage_Annular_Steiner_Chain    ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_montage_multi_rows_GUI         ##
##                                             ##
#################################################

#@gui Montage Multi Rows : samj_montage_multi_rows_GUI, samj_montage_multi_rows_GUI
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/nouveaux-montages-dimages-avec-gmic.html")
#@gui :_=note(" - Montage d'images assemblées horizontalement - <b>Au moins 4 calques/Images pour 2 lignes</b>")
#@gui :_=note(" - Montage of horizontally assembled images - <b>At least 4 layers/Images for 2 rows</b>")
#@gui :_=note(" - 1 ligne est ajoutée automatiquement si modulo Images/Lignes différent de 0")
#@gui :_=note(" - 1 row is automatically added if modulo Images/Rows different from 0")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Montage Multi Rows</b></span>")
#@gui : 1 - Nb. Images Montage = int(4,4,200)
#@gui : 2 - Lignes/Rows = int(2,2,20)
#@gui : 3 - Sélection = choice(0,"Calques du Haut/Top Layers","Calques du Bas/Bottom Layers")
#@gui : 4 - Montage Type = choice(1,"Hauteurs Proportionnelles/Proportional heights","Hauteur Constante/Same Height")
#@gui : 5 - Dimension Pixels = int(2400,800,11400)
#@gui : 6 - Contours Pixels = int(2,0,24)
#@gui : 7 - Espacement/Padding Pixels = int(2,0,24)
#@gui : 8 - Rotation Images = bool(0)
#@gui : 9 - Lignes vers Colonnes/Rows to Columns = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/12/11</i>.</small>")

samj_montage_multi_rows_GUI :

DimensionMini=4 # (min param 5 / max param 1
NbTotalCalques=$!
if $NbTotalCalques<4
	repeat {4-$NbTotalCalques}
		+Je_passe_l_hiver_en_Floride[-$NbTotalCalques]
	done
endif
if $3==0 rv endif
if $!>$1 rm[-{$1+1}--$!] endif
NbCalques=$!
Reste={$NbCalques%$2}
NbImgParRow={{$NbCalques-$Reste}/$2}
NbRow={{$NbCalques-$Reste}/$NbImgParRow}

if {$NbImgParRow*{2*{$6+$7}+$DimensionMini}}>$5
	samj_erreur_montage_multi_rows_GUI
else
	# Fond blanc systématiquement. À voir {i3}<1
	NbImg=$!
	Index=0
	repeat $NbImg
		Index={$Index-1}
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		$Wtemp,$Htemp,1,4
		fill_color[-1] 255,255,255,255
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
	done

	Index=0
	Hmax=0
	Wmax=0
	Htot=0
	Wtot=0
	repeat $NbCalques
		Index={$Index-1}
		Htemp={h(#$Index)}
		Htot={$Htot+$Htemp}
		if $Htemp>$Hmax
			Hmax=$Htemp
		endif
		Wtemp={w(#$Index)}
		Wtot={$Wtot+$Wtemp}
		if $Wtemp>$Wmax
			Wmax=$Wtemp
		endif
		Wliste$AbsInd=$Wtemp
		Hliste$AbsInd=$Htemp
	done
	H_moyen={round($Htot/$NbCalques)}
	W_moyen={round($Wtot/$NbCalques)}
	H_max=$Hmax
	W_max=$Wmax
	if $Reste>0
		repeat {$NbImgParRow-$Reste}
			$W_moyen,$W_moyen,1,3
			fill_color[-1] 255,255,255
		done
		NbRow={$NbRow+1}
	endif
	Itr=
	Idb=0
	repeat $NbRow
		repeat $NbImgParRow
			Idb={$Idb-1}
			Itr=$Itr,$Idb
		done
		samj_montage_row[$Itr] $4,$5,$6,$7,$8,0
		Itr=
		Idb={$Idb+$NbImgParRow-1}
	done
	append y
	if $9==1 mirror x permute yx endif
endif

samj_erreur_montage_multi_rows_GUI :
	rm
	1000,1000,1,3
	fill_color 255,255,255
	text[-1] "Erreur!",20,20,20,1,255,0,0
	text[-1] "Solutions possibles :",20,60,20,1,255,0,0
	text[-1] "Diminuer 1 - Images",20,90,20,1,0,0,0
	text[-1] "Diminuer 2 - Lignes/Rows",20,120,20,1,0,0,0
	text[-1] "Diminuer 6 - Contours Pixels et/ou 7 - Espacement/Padding Pixels",20,150,30,1,0,0,0

	text[-1] "Error!",20,220,20,1,255,0,0
	text[-1] "Possible solutions :",20,260,20,1,255,0,0
	text[-1] "Decrease 1 - Images",20,290,20,1,0,0,0
	text[-1] "Decrease 2 - Lignes/Rows",20,320,20,1,0,0,0
	text[-1] "Decrease 6 - Contours Pixels and/or 7 - Espacement/Padding Pixels",20,350,30,1,0,0,0

#################################################
##                                             ##
##      FIN samj_montage_multi_rows_GUI        ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_montage_row_GUI             ##
##                                             ##
#################################################

#@gui Montage Row : samj_montage_row_GUI, samj_montage_row_GUI_preview
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2020/12/nouveaux-montages-dimages-avec-gmic.html")
#@gui :_=note("Montage d'images assemblées horizontalement")
#@gui :_=note("Montage of horizontally assembled images")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Montage Row</b></span>")
#@gui : 1 - Max. Images = int(8,1,200)
#@gui : 2 - Sélection = choice(0,"Calques du Haut/Top Layers","Calques du Bas/Bottom Layers")
#@gui : 3 - Montage Type = choice(1,"Hauteurs Proportionnelles/Proportional heights","Hauteur Constante/Same Height")
#@gui : 4 - Dimension Pixels = int(2400,800,11400)
#@gui : 5 - Contours Pixels = int(2,0,24)
#@gui : 6 - Espacement/Padding Pixels = int(2,0,24)
#@gui : 7 - Rotation Images = bool(0)
#@gui : 8 - Ligne vers Colonne/Row to Column = bool(0)
#@gui :_=note("<span foreground="orangered"><b>Déformation</b></span>")
#@gui : 9 - Déformation = bool(0)
#@gui : 10 - Forme/Shape = choice(1,"Angle","Sinus")
#@gui : 11 - Offset % = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/12/11</i>.</small>")

samj_montage_row_GUI :

Type_Proportions_Finales=$2
	DimensionMini=4 # min param 4 / max param 1
	if $2==0 rv endif
	if $!>$1 rm[-{$1+1}--$!] endif
	if {{$1*{$5+$6+$DimensionMini}}>$4}
		samj_erreur_montage_row_GUI
	else
		samj_montage_row $3,$4,$5,$6,$7,0
		if $9==1
			mirror x permute yx
			expand_x {w/2}
			ripple {{w}/2},{h},{$10+1},0,{{h}/100*$11}
			permute yxzc mirror x
			autocrop
		endif
		if $8==1
			mirror x permute yx
		endif
	endif

samj_montage_row_GUI_preview :
	DimensionMini=4 # min param 4 / max param 1
	if $2==0 rv endif
	if $!>$1 rm[-{$1+1}--$!] endif
	if $!<$1 NbImg=$! else NbImg=$1 endif
	if {{$NbImg*{2*{$5+$6}+$DimensionMini}}>$4}
		samj_erreur_montage_row_GUI
	else
		samj_montage_row $3,$4,$5,$6,$7,0
		if $9==1
			mirror x permute yx
			expand_x {w/2}
			ripple {{w}/2},{h},{$10+1},0,{{h}/100*$11}
			permute yxzc mirror x
			autocrop
		endif
		if $8==1
			mirror x permute yx
		endif
		DimReduite=1000
		resize $DimReduite,{{h}/{w}*$DimReduite},1,3
	endif

samj_erreur_montage_row_GUI :
	rm
	1000,1000,1,3
	fill_color 255,255,255
	text "Erreur!",20,20,36,1,255,0,0
	text "Diminuer 5 - Contours Pixels et/ou 6 - Espacement/Padding Pixels",20,60,20,1,255,0,0
	text "Error!",20,100,36,1,255,0,0
	text "Decrease 5 - Contours Pixels and/or 6 - Espacement/Padding Pixels",20,140,20,1,255,0,0

#################################################
##                                             ##
##          FIN samj_montage_row_GUI           ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Tiles_Deconstruction          ##
##                                             ##
#################################################

#@gui Deconstruction : samj_Tiles_Deconstruction, samj_Tiles_Deconstruction
#@gui :_=link("https://samjcreations.blogspot.com","https://samjcreations.blogspot.com")
#@gui : Tuiles/Tiles = int(63,2,1000)
#@gui : note = note("<span foreground="orangered"><b>Contours Tuiles/Tiles</b></span>")
#@gui : Lignes/Lines = choice(0,"None","XY","X","Y")
#@gui : Couleur/Color = color(0,0,0,64)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/11/13</i>.</small>")

samj_Tiles_Deconstruction :
Hauteur={h}
Largeur={w}
if $1>$Hauteur||$1>$Largeur Tuiles={min($Largeur,$Hauteur)} else Tuiles=$1 endif
rotate 90
mirror x
resize {round($Largeur/$Tuiles)*$Tuiles},{round($Hauteur/$Tuiles)*$Tuiles}
split y,$Tuiles
split x,$Tuiles
append y
append x
split y,$Tuiles
append x
resize $Largeur,$Hauteur
if $2>0 to_rgba endif
if $2==1||$2==2
	IncX={{w}/$Tuiles}
	Xorg=0
	Yorg=0
	Xfin=0
	Yfin={h}
	repeat $1
		line $Xorg,$Yorg,$Xfin,$Yfin,1,$3,$4,$5,$6
		Xorg={$Xorg+$IncX}
		Xfin={$Xfin+$IncX}
	done
endif
if $2==1||$2==3
	IncY={{h}/$Tuiles}
	Xorg=0
	Yorg=0
	Xfin={w}
	Yfin=0
	repeat $1
		line $Xorg,$Yorg,$Xfin,$Yfin,1,$3,$4,$5,$6
		Yorg={$Yorg+$IncY}
		Yfin={$Yfin+$IncY}
	done
endif

#################################################
##                                             ##
##        FIN samj_Tiles_Deconstruction        ##
##                                             ##
#################################################
#################################################
##                                             ##
##                 samj_Flouter                ##
##                                             ##
#################################################

#@gui Floutage Blurring : samj_Flouter, samj_Flouter
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-floutage-blurring.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-floutage-blurring.html")
#@gui : Flou/Blur = float(0,0,20)
#@gui : Netteté/Sharpen = float(0,0,100)
#@gui : Autoindex = int(0,0,255)
#@gui : Grille/Grid = int(10,4,100)
#@gui : Cercle/Circle = bool(0)
#@gui : Taille/Size = int(0,0,100)
#@gui : Norm. = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/21</i>.</small>")

samj_Flouter :
	blur $1
	sharpen $2
	if $3>0 autoindex {$3+1} endif
	{w},{h},1,3
	fill_color[-1] 255,255,255
	imagegrid[-1] $4,$4
	negate[-1]
	to_rgba
	replace_color[-1] 1,0,255,255,255,255,0,0,0,0
	blend alpha
	replace_color 0,0,0,0,0,255,0,0,0,0
	if $5==0 dilate {$6+$4}  else dilate_circ {{$6+$4}*1.5} endif
	if $7==1 n 0,255 endif
	to_rgb

#################################################
##                                             ##
##               FIN samj_Flouter              ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Carres_Noirs              ##
##                                             ##
#################################################
# ajouts couleur + résolution
# pour la version GMIC 2.8.0 remplacer replace_color[-2] 100% par replace_color[-2] 0%
#@gui Carres Noirs : samj_Carres_Noirs , samj_Carres_Noirs (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Limite détails = int(128,1,255)
#@gui : Résolution = int(40,8,64)
#@gui : Épaisseur / Thickness = int(7,1,7)
#@gui : Dilate = int(0,0,8)
#@gui : Couleur Avant Plan = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Flou/Blur = float(2,0,10)
#@gui : Couleur Ombre = color(96,96,96,255)
#@gui : Décalage Ombre= int(2,0,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Isophotes</b></span>")
#@gui : Ajout Isophotes = bool(0)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Ajout Couleur = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Carres_Noirs :

Limite=$1
Resolution_Largeur=$2
Trait_Largeur=$3
Dilatation=$4
R_a=$5
V_a=$6
B_a=$7
A_a=$8
Flou=$9
R_b=$10
V_b=$11
B_b=$12
A_b=$13
VA=$14
R_c=$15
V_c=$16
B_c=$17
A_c=$18
Ajout_Isophotes=$19
Flou_Isophotes=$20
Ajout_Couleur=$21

Largeur={w}
Hauteur={h}

 to_rgba[-1]
 if $Ajout_Isophotes==1
  +Je_passe_l_hiver_en_Floride[-1]
 endif
 luminance[-1]
 to_rgba[-1]
 n[-1] 0,255
 c[-1] 0,$Limite
 n[-1] 0,255
 c[-1] {255-$Limite},255
 n[-1] 0,255
 +Je_passe_l_hiver_en_Floride[-1]
 samj_Lignes_Epaisseur_Variable[-1] 0,$Resolution_Largeur,$Trait_Largeur,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0.5,0.5,1.8,0,0
 samj_Lignes_Epaisseur_Variable[-2] 1,$Resolution_Largeur,$Trait_Largeur,0,0,0,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0.5,0.5,1.8,0,0
 blend[-1,-2] alpha
 if $Dilatation>0
  dilate[-1] $Dilatation
 endif
 resize[-1] $Largeur,$Hauteur
 to_rgba[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 replace_color[-1] 0%,0,0,0,0,255,$R_b,$V_b,$B_b,$A_b # noir vers couleur fond
 blur[-1] $Flou
 shift[-1] $VA,$VA,0,0,0
 crop[-1] 0,0,{{w}-1},{{h}-1}
 replace_color[-2] 0%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a # noir vers couleur avant plan
 rv[-1,-2]
 blend[-1,-2] alpha
 {w},{h},1,4
 fill_color[-1] $R_c,$V_c,$B_c,$A_c
 rv[-1,-2]
 blend[-1,-2] alpha
 if $Ajout_Isophotes==1
  blur[-2] $Flou_Isophotes
  isophotes[-2] 8
  n[-2] 0,255
  if $Ajout_Couleur==0
   to_graya[-2]
  endif
  rv[-1,-2]
  blend[-1,-2] alpha
 endif

#################################################
##                                             ##
##            FIN samj_Carres_Noirs            ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Pixelisation_Contours          ##
##                                             ##
#################################################
# 2016/12/20 gmic 1.8.0 fx_smooth_antialias
#@gui Pixelisation Contours  : samj_Pixelisation_Contours , samj_Pixelisation_Contours(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Pixélisation</b></span>")
#@gui : Flou/Blur = float(0.5,0,16)
#@gui : Forme = choice(0,"Carrée","Hexagonale","Triangulaire A","Triangulaire B","Triangulaire C","Triangulaire D","Triangulaire E","Triangulaire F")
#@gui : Pixélisation = int(20,2,128)
#@gui : Levels = int(8,1,256)
#@gui : Smoothness = float(0,0,5)
#@gui : Décalages = int(0,0,32)
#@gui : Rendu = int(1,1,6)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Amplitude = float(0,0,100)
#@gui : Edge threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/20</i>.</small>")

samj_Pixelisation_Contours  :

Flou=$1
Forme=$2
Pixelisation=$3
TM_Levels=$4
TM_Smoothness=$5
VA=$6
Type_Rendu=$7
V_Amplitude=$8
V_Edge_Threshold=$9
V_Smoothness=$10

Largeur={w}
Hauteur={h}

 blur[-1] $Flou
 if $Forme==0
  pixelize[-1] {$Largeur/$Pixelisation},{$Hauteur/$Pixelisation}
 elif $Forme==1
  imagegrid_hexagonal[-1] {round({2*$Largeur/$Pixelisation})},0
 elif $Forme==2
  imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},0,0
 elif $Forme==3
  imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},1,0
 elif $Forme==4
  imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},2,0
 elif $Forme==5
  imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},3,0
 elif $Forme==6
  imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},4,0
 elif $Forme==7
  imagegrid_triangular[-1] {round({$Largeur/$Pixelisation})},{round({$Largeur/$Pixelisation/{2^0.5}})},5,0
 endif
 topographic_map[-1] $TM_Levels,$TM_Smoothness
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
  if $Type_Rendu==1
   shift[-1] 0,$VA,0,0,0
   shift[-2] $VA,0,0,0,0
   shift[-3] $VA,$VA,0,0,0
  elif $Type_Rendu==2
   shift[-1] 0,$VA,0,0,0
   shift[-2] $VA,$VA,0,0,0
   shift[-3] $VA,0,0,0,0
  elif $Type_Rendu==3
   shift[-1] $VA,0,0,0,0
   shift[-2] 0,$VA,0,0,0
   shift[-3] $VA,$VA,0,0,0
  elif $Type_Rendu==4
   shift[-1] $VA,0,0,0,0
   shift[-2] $VA,$VA,0,0,0
   shift[-3] 0,$VA,0,0,0
  elif $Type_Rendu==5
   shift[-1] $VA,$VA,0,0,0
   shift[-2] $VA,0,0,0,0
   shift[-3] 0,$VA,0,0,0
  elif $Type_Rendu==6
   shift[-1] $VA,$VA,0,0,0
   shift[-2] 0,$VA,0,0,0
   shift[-3] $VA,0,0,0,0
  endif
 crop[-1,-2,-3] 0,0,{$Largeur-1-$VA},{$Hauteur-1-$VA}
 blend[-1,-2,-3,-4] edges
 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness

#################################################
##                                             ##
##       FIN samj_Pixelisation_Contours        ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_Moirage_Spline_XY            ##
##                                             ##
#################################################

# 2016/12/21 nouvelle fonction spline
#@gui Moirage Spline XY  : samj_Moirage_Spline_XY, samj_Moirage_Spline_XY(0)
#@gui :_=note("samj_Moirage_Spline_XY")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Calque A</b></span>")
#@gui : Couleur A = color(0,0,0,255)
#@gui : Résolution A = int(8,2,32)
#@gui : Décalage A = float(0,-100,100)
#@gui : Spline A u0 = float(-50,-400,400)
#@gui : Spline A v0 = float(50,-400,400)
#@gui : Spline A u1 = float(-50,-400,400)
#@gui : Spline A v1 = float(50,-400,400)
#@gui : Dilate A % = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Calque B</b></span>")
#@gui : Couleur B = color(0,0,0,255)
#@gui : Résolution B = int(8,2,32)
#@gui : Décalage B = float(0,-100,100)
#@gui : Spline B u0 = float(-50,-400,400)
#@gui : Spline B v0 = float(50,-400,400)
#@gui : Spline B u1 = float(-50,-400,400)
#@gui : Spline B v1 = float(50,-400,400)
#@gui : Dilate B % = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Calques Visibles</b></span>")
#@gui : Choix = choice(0,"Calques A B","Calque A","Calque B")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Moirage_Spline_XY :

Couleur_Ar=$1
Couleur_Av=$2
Couleur_Ab=$3
Couleur_Aa=$4
Resolution_A=$5
Decalage_A=$6
Spline_A_u0=$7
Spline_A_v0=$8
Spline_A_u1=$9
Spline_A_v1=$10

Dilate_A={round({$11/100*$Resolution_A})}
Couleur_Br=$12
Couleur_Bv=$13
Couleur_Bb=$14
Couleur_Ba=$15
Resolution_B=$16
Decalage_B=$17
Spline_B_u0=$18
Spline_B_v0=$19
Spline_B_u1=$20
Spline_B_v1=$21

Dilate_B={round({$22/100*$Resolution_B})}
Choix_Calques_Visibles=$23
Largeur_Origine={w}
Hauteur_Origine={h}
XA_origine={round({{$Resolution_A/100*$Decalage_A}-{$Largeur_Origine/2}})}
YA_origine=0
XA_fin={round({{$Resolution_A/100*$Decalage_A}+{$Largeur_Origine*1.5}})}
YA_fin=$Hauteur_Origine
Iterations_A={round({{{abs($XA_origine)}+$XA_fin}/$Resolution_A})}

XB_origine=0
YB_origine={round({{$Resolution_B/100*$Decalage_B}-{$Hauteur_Origine/2}})}
XB_fin=$Largeur_Origine
YB_fin={round({{$Resolution_B/100*$Decalage_B}+{$Hauteur_Origine*1.5}})}
Iterations_B={round({{{abs($YB_origine)}+$YB_fin}/$Resolution_B})}
if $Choix_Calques_Visibles==0||$Choix_Calques_Visibles==1
 $Largeur_Origine,$Hauteur_Origine,1,4
 repeat $Iterations_A
  XA_origine={$XA_origine+$Resolution_A}
  XA_fin=$XA_origine
  spline[-1] $XA_origine,$YA_origine,{$Largeur_Origine/100*$Spline_A_u0},{$Largeur_Origine/100*$Spline_A_v0},$XA_fin,$YA_fin,{$Largeur_Origine/100*$Spline_A_u1},{$Largeur_Origine/100*$Spline_A_v1},1,$Couleur_Ar,$Couleur_Av,$Couleur_Ab,$Couleur_Aa
 done
 if $Dilate_A>1 dilate_circ[-1] $Dilate_A endif
endif

if $Choix_Calques_Visibles==0||$Choix_Calques_Visibles==2
 $Largeur_Origine,$Hauteur_Origine,1,4
 repeat $Iterations_B
  YB_origine={$YB_origine+$Resolution_B}
  YB_fin=$YB_origine
  spline[-1] $XB_origine,$YB_origine,{$Hauteur_Origine/100*$Spline_B_u0},{$Hauteur_Origine/100*$Spline_B_v0},$XB_fin,$YB_fin,{$Hauteur_Origine/100*$Spline_B_u1},{$Hauteur_Origine/100*$Spline_B_v1},1,$Couleur_Br,$Couleur_Bv,$Couleur_Bb,$Couleur_Ba
 done
 if $Dilate_B>1 dilate_circ[-1] $Dilate_B endif
endif

if $Choix_Calques_Visibles==0
 blend[-1,-2] alpha,1,1
endif

rv[-1,-2]
#################################################
##                                             ##
##         FIN samj_Moirage_Spline_XY          ##
##                                             ##
#################################################


#################################################
##                                             ##
##             samj_Moirage_Spline             ##
##                                             ##
#################################################
# 2016/12/21 nouvelle fonction spline

#@gui Moirage Spline  : samj_Moirage_Spline, samj_Moirage_Spline(0)
#@gui :_=note("samj_Moirage_Spline")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Calque A</b></span>")
#@gui : Couleur A = color(0,0,0,255)
#@gui : Résolution A = int(8,2,32)
#@gui : Décalage A = float(0,-100,100)
#@gui : Spline A u0 = float(-50,-250,250)
#@gui : Spline A v0 = float(50,-250,250)
#@gui : Spline A u1 = float(-50,-250,250)
#@gui : Spline A v1 = float(50,-250,250)
#@gui : Orientation A = float(0,0,360)
#@gui : Dilate A % = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Calque B</b></span>")
#@gui : Couleur B = color(0,0,0,255)
#@gui : Résolution B = int(8,2,32)
#@gui : Décalage B = float(0,-100,100)
#@gui : Spline B u0 = float(-50,-250,250)
#@gui : Spline B v0 = float(50,-250,250)
#@gui : Spline B u1 = float(-50,-250,250)
#@gui : Spline B v1 = float(50,-250,250)
#@gui : Orientation A = float(0,0,360)
#@gui : Dilate B % = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/04</i>.</small>")

samj_Moirage_Spline :

Couleur_Ar=$1
Couleur_Av=$2
Couleur_Ab=$3
Couleur_Aa=$4
Resolution_A=$5
Decalage_A=$6
Spline_A_u0=$7
Spline_A_v0=$8
Spline_A_u1=$9
Spline_A_v1=$10
Orientation_A=$11
Dilate_A={round({$12/100*$Resolution_A})}
Couleur_Br=$13
Couleur_Bv=$14
Couleur_Bb=$15
Couleur_Ba=$16
Resolution_B=$17
Decalage_B=$18
Spline_B_u0=$19
Spline_B_v0=$20
Spline_B_u1=$21
Spline_B_v1=$22
Orientation_B=$23
Dilate_B={round({$24/100*$Resolution_B})}

Largeur_Origine={w}
Hauteur_Origine={h}
Nouvelle_Dimension={round({{{{$Largeur_Origine^2}+{$Hauteur_Origine^2}}^0.5}+1})}
Nouvelle_Dimension={$Nouvelle_Dimension+{max({abs({$Nouvelle_Dimension/100*$Spline_A_u0})},{abs({$Nouvelle_Dimension/100*$Spline_B_u0})})}+{max({abs({$Nouvelle_Dimension/100*$Spline_A_u1})},{abs({$Nouvelle_Dimension/100*$Spline_B_u1})})}}
XA_origine={round({$Resolution_A/100*$Decalage_A})}
YA_origine=0
XA_fin=$XA_origine
YA_fin=$Nouvelle_Dimension

XB_origine=0
YB_origine={round({$Resolution_B/100*$Decalage_B})}
XB_fin=$Nouvelle_Dimension
YB_fin=$XB_origine

$Nouvelle_Dimension,$Nouvelle_Dimension,1,4

repeat $Nouvelle_Dimension/$Resolution_A
 spline[-1] $XA_origine,$YA_origine,{$Nouvelle_Dimension/100*$Spline_A_u0},{$Nouvelle_Dimension/100*$Spline_A_v0},$XA_fin,$YA_fin,{$Nouvelle_Dimension/100*$Spline_A_u1},{$Nouvelle_Dimension/100*$Spline_A_v1},1,$Couleur_Ar,$Couleur_Av,$Couleur_Ab,$Couleur_Aa
 XA_origine={$XA_origine+$Resolution_A}
 YA_origine=0
 XA_fin=$XA_origine
 YA_fin=$Nouvelle_Dimension
done

if $Orientation_A>0 rotate[-1] {$Orientation_A} endif
crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{{{{w}-$Largeur_Origine}/2}+$Largeur_Origine-1},{{{{h}-$Hauteur_Origine}/2}+$Hauteur_Origine-1}
if $Dilate_A>1 dilate_circ[-1] $Dilate_A endif

$Nouvelle_Dimension,$Nouvelle_Dimension,1,4

repeat $Nouvelle_Dimension/$Resolution_B
 spline[-1] $XB_origine,$YB_origine,{$Nouvelle_Dimension/100*$Spline_B_u0},{$Nouvelle_Dimension/100*$Spline_B_v0},$XB_fin,$YB_fin,{$Nouvelle_Dimension/100*$Spline_B_u1},{$Nouvelle_Dimension/100*$Spline_B_v1},1,$Couleur_Br,$Couleur_Bv,$Couleur_Bb,$Couleur_Ba
 XB_origine=0
 YB_origine={$YB_origine+$Resolution_B}
 XB_fin=$Nouvelle_Dimension
 YB_fin=$YB_origine
done
if $Orientation_B>0 rotate[-1] {$Orientation_B} endif
crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{{{{w}-$Largeur_Origine}/2}+$Largeur_Origine-1},{{{{h}-$Hauteur_Origine}/2}+$Hauteur_Origine-1}
if $Dilate_B>1 dilate_circ[-1] $Dilate_B endif

blend[-1,-2] alpha,1,1
rv[-1,-2]
#################################################
##                                             ##
##           FIN samj_Moirage_Spline           ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Scintillements_Colores         ##
##                                             ##
#################################################

#### samj_Scintillements_Colores 58,50,42,255,16,8,0.5,600,12,0,60,2,0,0,0,0,255
#### samj_Scintillements_Colores 58,50,42,255,16,8,0.4,768,15,0,0,2,0,0,0,0,255

#@gui Scintillements Colores : samj_Scintillements_Colores, samj_Scintillements_Colores(1)
#@gui :_=note("Color Rays / samj_Scintillements_Colores")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite = color(64,64,64,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Scintillement</b></span>")
#@gui : Résolution L = int(8,1,32)
#@gui : Résolution H = int(8,1,32)
#@gui : Dimension Variation = float(1,0.3,3)
#@gui : Variation Couleur = int(768,1,768)
#@gui : Scintillement / Rays = int(12,3,24)
#@gui : Angle Décalage / Shift Angle = float(0,0,120)
#@gui : Variation Aléatoire / Random = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="Rendu"><b>Limite</b></span>")
#@gui : Rendu / Rendering = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui : Déformation = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Scintillements_Colores :

Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution_L=$5
Resolution_H=$6
Dimension_Variation=$7
Variation_Couleur=$8
Scintillement=$9
Angle_Decalage=$10
Variation_Aleatoire=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Hauteur=$Resolution_H
Largeur=$Resolution_L
Rayon_Scintillement_Origine={{$Resolution_H+$Resolution_L}*$Dimension_Variation}
Rayon_Scintillement=0
Angle_Variation={360/$Scintillement}
Angle_Variation_En_Cours=0
Coeff_Variation_Aleatoire=0

$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

repeat $Largeur_Origine/($Resolution_L+$Resolution_L)
 repeat $Hauteur_Origine/($Resolution_H+$Resolution_H)
  couleur_pixel=${at_ancien[0]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  Moyenne_couleur={1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Variation_Couleur}}
  Rayon_Scintillement={$Rayon_Scintillement_Origine*$Moyenne_couleur}
  Angle_Variation_En_Cours=0
  if $Rendu==0
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    repeat $Scintillement
     Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
     if $Variation_Aleatoire==0
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     else
      Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     endif
    done
   endif
  elif $Rendu==1
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    repeat $Scintillement
     Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
     if $Variation_Aleatoire==0
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     else
      Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     endif
    done
   endif
  elif $Rendu==2
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    repeat $Scintillement
     Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
     if $Variation_Aleatoire==0
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     else
      Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     endif
    done
   endif
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    repeat $Scintillement
     Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
     if $Variation_Aleatoire==0
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     else
      Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
      line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
     endif
    done
   endif
  endif
  Hauteur={$Hauteur+$Resolution_H+$Resolution_H}
 done
 Largeur={$Largeur+$Resolution_L+$Resolution_L}
 Hauteur=$Resolution_H
done

rm[0]

if $Flou_Contours>0 blur[-1] $Flou_Contours,0 endif
if $18>0 deform[-1] $18 endif

#################################################
##                                             ##
##        FIN samj_Scintillements_Colores      ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Losanges_Colores            ##
##                                             ##
#################################################

#### samj_Losanges_Colores 30,26,21,255,16,0,0,0,1.5,0,1.8,2,0,0,0,0,255,4
#### samj_Losanges_Colores 30,26,21,255,16,1,0,0,1.5,0,1.4,2,0,0,0,0,255,4

#@gui Losanges Colores  : samj_Losanges_Colores, samj_Losanges_Colores(1)
#@gui :_=note("samj_Losanges_Colores")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite= color(64,64,64,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Resolution</b></span>")
#@gui : Résolution = int(8,1,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Losanges - Rectangles</b></span>")
#@gui : Inclinaison = bool(0)
#@gui : Variation L = int(0,-255,255)
#@gui : Variation H = int(0,-255,255)
#@gui : Grossissement A = float(1.5,0.5,9)
#@gui : Grossissement B = float(0,-10,10)
#@gui : Dimension Variation = float(1,0.3,3)
#@gui :_=separator()
#@gui :_=note("<span foreground="Rendu"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours Losanges = choice(0,"Sans","Couleur Fond","Blanc","Gris moyen","Fonce")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Losanges_Colores :

Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Inclinaison_Quadrilataire=$6
Variation_L=$7
Variation_H=$8
Grossissement_A=$9
Grossissement_B=$10
Dimension_Variation=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17
Contours_Polygones=$18

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Dimension_Origine={$Dimension_Variation*$Resolution}

KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution

X_a=0
Y_a=0
X_b=0
Y_b=0
X_c=0
Y_c=0
X_d=0
Y_d=0

$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

repeat $Largeur_Origine/($Resolution+$Resolution)
 repeat $Hauteur_Origine/($Resolution+$Resolution)
  couleur_pixel=${at_ancien[0]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}

  KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
  KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}

  Dimension_Variation={$Dimension_Origine*{1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}}}}

  if $Inclinaison_Quadrilataire==0
   X_a={$Largeur-{$Dimension_Variation*$KL}}
   Y_a=$Hauteur
   X_b=$Largeur
   Y_b={$Hauteur+{$Dimension_Variation*$KH}}
   X_c={$Largeur+{$Dimension_Variation*$KL}}
   Y_c=$Hauteur
   X_d=$Largeur
   Y_d={$Hauteur-{$Dimension_Variation*$KH}}
  else
   X_a={$Largeur-{$Dimension_Variation*$KL}}
   Y_a={$Hauteur+{$Dimension_Variation*$KH}}
   X_b={$Largeur+{$Dimension_Variation*$KL}}
   Y_b={$Hauteur+{$Dimension_Variation*$KH}}
   X_c={$Largeur+{$Dimension_Variation*$KL}}
   Y_c={$Hauteur-{$Dimension_Variation*$KH}}
   X_d={$Largeur-{$Dimension_Variation*$KL}}
   Y_d={$Hauteur-{$Dimension_Variation*$KH}}
  endif

  if $Rendu==0
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==1
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==2
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  endif

  if $Contours_Polygones==1
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
  elif $Contours_Polygones==2
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,255,255,255,$alpha_pixel
  elif $Contours_Polygones==3
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},$alpha_pixel
  elif $Contours_Polygones==4
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{$rouge_pixel*0.5},{$vert_pixel*0.5},{$bleu_pixel*0.5},$alpha_pixel
  endif

  Hauteur={$Hauteur+$Resolution+$Resolution}
 done
 Largeur={$Largeur+$Resolution+$Resolution}
 Hauteur=$Resolution
done

rm[0]

if $Flou_Contours>0 blur[-1] $Flou_Contours,0 endif

#################################################
##                                             ##
##          FIN samj_Losanges_Colores          ##
##                                             ##
#################################################
#################################################
##                                             ##
##      samj_Pointes_De_Diamants_Colorees      ##
##                                             ##
#################################################

#### samj_Pointes_De_Diamants_Colorees 29,24,20,255,10,0,100,0.5,0.5,15,2,0,0,0,0,255,4
#### samj_Pointes_De_Diamants_Colorees 23,18,14,255,8,180,72,1,1.8,0,2,0,0,0,0,255,4

#@gui Pointes De Diamants Colorees  : samj_Pointes_De_Diamants_Colorees, samj_Pointes_De_Diamants_Colorees(1)
#@gui :_=note("samj_Pointes_De_Diamants_Colorees")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite= color(64,64,64,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Resolution</b></span>")
#@gui : Résolution = int(8,1,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Polygones</b></span>")
#@gui : Variation L = int(0,-255,255)
#@gui : Variation H = int(0,-255,255)
#@gui : Grossissement A = float(1.5,0.5,9)
#@gui : Grossissement B = float(0,-10,10)
#@gui : Angle Variation = float(0,0,180)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours Polygones = choice(0,"Sans","Couleur Fond","Blanc","Gris moyen","Fonce")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Pointes_De_Diamants_Colorees :

Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Variation_L=$6
Variation_H=$7
Grossissement_A=$8
Grossissement_B=$9
Angle_Variation=$10
Rendu=$11
Flou_Contours=$12
Couleur_Fond_r=$13
Couleur_Fond_v=$14
Couleur_Fond_b=$15
Couleur_Fond_a=$16
Contours_Polygones=$17

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Angle_Origine={45+$Angle_Variation}

KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution

X_a=0
Y_a=0
X_b=0
Y_b=0
X_c=0
Y_c=0
X_d=0
Y_d=0

$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

repeat $Largeur_Origine/($Resolution+$Resolution)
 repeat $Hauteur_Origine/($Resolution+$Resolution)
  couleur_pixel=${at_ancien[0]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}

  KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
  KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}

  Angle_Variation={$Angle_Origine+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}*180}}

  X_a={$Largeur-{{$Resolution*$KL}*{cos({pi/180*$Angle_Variation})}}}
  Y_a=$Hauteur
  X_b=$Largeur
  Y_b={$Hauteur+{{$Resolution*$KH}*{sin({pi/180*$Angle_Variation})}}}
  X_c={$Largeur+{{$Resolution*$KL}*{cos({pi/180*$Angle_Variation})}}}
  Y_c=$Hauteur
  X_d=$Largeur
  Y_d={$Hauteur-{{$Resolution*$KH}*{sin({pi/180*$Angle_Variation})}}}

  if $Rendu==0
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==1
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==2
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  endif

  if $Contours_Polygones==1
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a
  elif $Contours_Polygones==2
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,255,255,255,$alpha_pixel
  elif $Contours_Polygones==3
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},{{$rouge_pixel+$vert_pixel+$bleu_pixel}/3},$alpha_pixel
  elif $Contours_Polygones==4
   polygon[-1] 4,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,{$rouge_pixel*0.5},{$vert_pixel*0.5},{$bleu_pixel*0.5},$alpha_pixel
  endif

  Hauteur={$Hauteur+$Resolution+$Resolution}
 done
 Largeur={$Largeur+$Resolution+$Resolution}
 Hauteur=$Resolution
done

rm[0]

if $Flou_Contours>0 blur[-1] $Flou_Contours,0 endif

#################################################
##                                             ##
##    FIN samj_Pointes_De_Diamants_Colorees    ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Bulles_Colorees            ##
##                                             ##
#################################################

#### samj_Bulles_Colorees 64,64,64,255,8,-255,255,2.5,0.4,1,20,2,0,0,0,0,255

#@gui Bulles Colorees  : samj_Bulles_Colorees, samj_Bulles_Colorees(1)
#@gui :_=note("samj_Bulles_Colorees")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite= color(64,64,64,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Resolution</b></span>")
#@gui : Résolution = int(8,1,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Bulles</b></span>")
#@gui : Variation L = int(0,-255,255)
#@gui : Variation H = int(0,-255,255)
#@gui : Grossissement A = float(3,1,9)
#@gui : Grossissement B = float(0,-3,3)
#@gui : Angle = bool(0)
#@gui : Angle Variation = float(0,0,180)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Bulles_Colorees :

Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Resolution=$5
Variation_L=$6
Variation_H=$7
Grossissement_A=$8
Grossissement_B=$9
Angle_Validation=$10
Angle_Variation=$11
Rendu=$12
Flou_Contours=$13
Couleur_Fond_r=$14
Couleur_Fond_v=$15
Couleur_Fond_b=$16
Couleur_Fond_a=$17

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Moyenne_couleur=0
Coeff_bulle=0
Angle_Origine=$Angle_Variation

KL=0
KH=0
Hauteur=$Resolution
Largeur=$Resolution
$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

repeat $Largeur_Origine/($Resolution+$Resolution)
 repeat $Hauteur_Origine/($Resolution+$Resolution)
  couleur_pixel=${at_ancien[0]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  Moyenne_couleur={{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Grossissement_A}

  KL={$Grossissement_B+{{$Moyenne_couleur+$Variation_L}/512}}
  KH={$Grossissement_B+{{$Moyenne_couleur+$Variation_H}/512}}

  if $Angle_Validation==0
   Angle_Variation=$Angle_Origine
  else
   Angle_Variation={$Angle_Origine+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/{255*3}*180}}
  endif

  if $Rendu==0
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==1
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==2
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    ellipse[-1] $Largeur,$Hauteur,{$Resolution*$KL},{$Resolution*$KH},$Angle_Variation,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  endif
  Hauteur={$Hauteur+$Resolution+$Resolution}
 done
 Largeur={$Largeur+$Resolution+$Resolution}
 Hauteur=$Resolution
done

rm[0]

if $Flou_Contours>0 blur[-1] $Flou_Contours,0 endif

#################################################
##                                             ##
##            FIN samj_Bulles_Colorees         ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Ellipses_Colorees           ##
##                                             ##
#################################################

#### samj_Ellipses_Colorees 50,50,50,255,12,8,2,0,0,0,0,255
# 20160131 erreur Couleur_Fond_x

#@gui Ellipses Colorees  : samj_Ellipses_Colorees, samj_Ellipses_Colorees(1)
#@gui :_=note("samj_Ellipses_Colorees")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite= color(64,64,64,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ellipse</b></span>")
#@gui : Rayon L = int(8,1,32)
#@gui : Rayon H = int(8,1,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(0,"A","Inverser","A + Inverser")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Ellipses_Colorees :

Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Couleur_Limite_a=$4
Rayon_L=$5
Rayon_H=$6
Rendu=$7
Flou_Contours=$8
Couleur_Fond_r=$9
Couleur_Fond_v=$10
Couleur_Fond_b=$11
Couleur_Fond_a=$12

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=$Couleur_Limite_a
Hauteur=$Rayon_H
Largeur=$Rayon_L
$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

repeat $Largeur_Origine/($Rayon_L+$Rayon_L)
 repeat $Hauteur_Origine/($Rayon_H+$Rayon_H)
  couleur_pixel=${at_ancien[0]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  if $Rendu==0
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==1
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  elif $Rendu==2
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
   endif
  endif
  Hauteur={$Hauteur+$Rayon_H+$Rayon_H}
 done
 Largeur={$Largeur+$Rayon_L+$Rayon_L}
 Hauteur=$Rayon_H
done

rm[0]

if $Flou_Contours>0 blur[-1] $Flou_Contours,0 endif

#################################################
##                                             ##
##           FIN samj_Ellipses_Colorees        ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  samj_reptile               ##
##                                             ##
#################################################

# 2016/12/20 gmic 1.8.0
# 20190217 fx_blend
#@gui Reptile  : samj_reptile, samj_reptile(1)
#@gui :_=note("samj_reptile")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Texture Peau / Skin Texture</b></span>")
#@gui : Forme = choice(0,"hexagonal","grid","triangular Ha","triangular Hb","triangular Va","triangular Vb")
#@gui : Résolution = int(64,1,256)
#@gui : Spread = int(25,5,100)
#@gui : Color = float(2,0,10)
#@gui : Orientation = float(0,0,1)
#@gui : Light = int(40,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_reptile :

Texture_Forme=$1
Texture_Resolution=$2
Texture_Spread=$3
Texture_Color=$4
Texture_Orientation=$5
Texture_Light=$6
Opacity=$7

Largeur_Origine={w}
Hauteur_Origine={h}
Coeff_Echelle_L=1
Coeff_Echelle_H=1

+Je_passe_l_hiver_en_Floride[-1]
fx_isophotes[-1] 8,2,1,0

if $Largeur_Origine<10*$Texture_Resolution
 Coeff_Echelle_L={{10*$Texture_Resolution}/$Largeur_Origine}
endif
if $Hauteur_Origine<10*$Texture_Resolution
 Coeff_Echelle_H={{10*$Texture_Resolution}/$Hauteur_Origine}
endif

if $Coeff_Echelle_L+$Coeff_Echelle_H>2
 if $Coeff_Echelle_L>$Coeff_Echelle_H
  resize[-1,-2] {round({$Largeur_Origine*$Coeff_Echelle_L})},{round({$Hauteur_Origine*$Coeff_Echelle_L})}
 else
  resize[-1,-2] {round({$Largeur_Origine*$Coeff_Echelle_H})},{round({$Hauteur_Origine*$Coeff_Echelle_H})}
 endif
endif

to_rgb[-1,-2]

if $Texture_Forme==0
 fx_imagegrid_hexagonal[-1] $Texture_Resolution,0.1,1
elif $Texture_Forme==1
 imagegrid[-1] {round({{w}/$Texture_Resolution})},{round({{h}/$Texture_Resolution})}
elif $Texture_Forme==2
 fx_imagegrid_triangular {round({{w}/$Texture_Resolution})},{round({1.8*{w}/$Texture_Resolution})},0,0,0,0,255
 Texture_Spread={$Texture_Spread/2}
elif $Texture_Forme==3
 fx_imagegrid_triangular {round({{h}/{1.8*$Texture_Resolution}})},{round({{h}/$Texture_Resolution})},0,0,0,0,255
 Texture_Spread={$Texture_Spread/2}
elif $Texture_Forme==4
 fx_imagegrid_triangular {round({{w}/$Texture_Resolution})},{round({1.8*{w}/$Texture_Resolution})},1,0,0,0,255
 Texture_Spread={$Texture_Spread/2}
elif $Texture_Forme==5
 fx_imagegrid_triangular {round({{h}/{1.8*$Texture_Resolution}})},{round({{h}/$Texture_Resolution})},1,0,0,0,255
 Texture_Spread={$Texture_Spread/2}
endif

fx_spread {{{w}*$Texture_Spread}/{100*$Texture_Resolution}},{{{h}*$Texture_Spread}/{100*$Texture_Resolution}},0,0,0
fx_boost_fade[-1] $Texture_Color,0
+Je_passe_l_hiver_en_Floride[-1]
fx_local_orientation[-1] $Texture_Orientation,0,100,0,16,0
fx_blend[-1,-2] 14,0,1,1,"0"
fx_lightglow[-1] $Texture_Light,0.5,8,0.8,0,0

blend[-1,-2] grainmerge,1,$Opacity

#################################################
##                                             ##
##               FIN samj_reptile              ##
##                                             ##
#################################################
#################################################
##                                             ##
##            Cercles_Concentriques            ##
##                                             ##
#################################################

# 2015/04/25 origine
# 2015/04/26 menu "Décalage Cercles %" à 500%
# 2016/02/02 {round(u)*255}
# 2016/12/20 symmetrizoscope gmic 1.8.0
# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
#@gui Cercles Concentriques : Cercles_Concentriques_A, Cercles_Concentriques_A(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Image Finale / Resulting Image</b></span>")
#@gui : Dimension En Pixels = int(800,256,1920)
#@gui : Supprimer Calque / Delete Layer = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Cercles / Circles Rings</b></span>")
#@gui : Nb Cercles / Circles (anneaux) = int(6,1,180)
#@gui : Variation Dimensions / Size = choice(0,"Sin A","Sin B","Lineaire")
#@gui : Angle Variation Origine = float(0,0,180)
#@gui : Angle Variation Fin / End = float(90,0,180)
#@gui : Coef. Variation = float(1,-1,1)
#@gui : Rotation Horaire / Rotate Clockwise = bool(1)
#@gui : Décalage Cercles % / Shift = float(50,0,500)
#@gui : Conserver Extérieur / Keep Outside = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Rayons De Couleurs Et Contours / Colored Rays And Contours</b></span>")
#@gui : Activer Rayons De Couleurs / Enable = bool(1)
#@gui :_=note("<span foreground="blue"><small> - Contours - </small></span>")
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = choice(0,"Sans","Rayons et Cercles","Rayons","Cercles")
#@gui : Dilate Contours = int(0,0,16)
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : Sharpen = int(0,0,600)
#@gui :_=note("<span foreground="blue"><small> - Couleurs - </small></span>")
#@gui : Répétition Des Couleurs = int(5,1,180)
#@gui : Angle Décalage Des Couleurs  = float(0,0,360)
#@gui : Couleur / Color A = color(0,0,255,255)
#@gui : Couleur / Color B = color(255,255,0,255)
#@gui : Couleur / Color C = color(255,0,0,255)
#@gui : Couleur / Color D = color(0,255,255,255)
#@gui : Couleur / Color E = color(255,0,255,255)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Mélange Couleurs Contours / Blend = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Symmetrizoscope</b></span>")
#@gui : Activer Symmetrizoscope = bool(0)
#@gui : Itérations = int(5,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Symmetry sides = choice("Backward","Forward","Swap")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

Cercles_Concentriques_A:

 Dimension_Finale=$1
 Supprimer_Calque_Origine=$2

 Nb_Circles={$3+1}
 Type_Variation_Dimensions_Cercles=$4
 Angle_Variation_Origine=$5
 Angle_Variation_Fin=$6
 Coef_Variation=$7
 Sens_Rotation_Horaire=$8
 Decalage_Cercles={$9-50}
 Conserver_Exterieur_Cercles=$10

 Activer_Rayons_De_Couleurs=$11

 R_Contours=$12
 V_Contours=$13
 B_Contours=$14
 A_Contours=$15

 Affichage_Contours=$16
 Dilate_Contours=$17
 Flou_Contours=$18
 Sharpen_Contours=$19

 Repetition_Couleurs=$20
 Angle_Decalage_Couleurs=$21

 R_a=$22
 V_a=$23
 B_a=$24
 A_a=$25

 R_b=$26
 V_b=$27
 B_b=$28
 A_b=$29

 R_c=$30
 V_c=$31
 B_c=$32
 A_c=$33

 R_d=$34
 V_d=$35
 B_d=$36
 A_d=$37

 R_e=$38
 V_e=$39
 B_e=$40
 A_e=$41

 Couleurs_aleatoires=$42
 Melange_Couleurs_Contours=$43

 Filtre_Symmetrizoscope=$44
 Iterations_Symmetrizoscope=$45
 Angle_Symmetrizoscope=$46
 Symmetry_Sides=$47

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Rayon_Cercle_Final={round({{$Dimension_Finale/2}-1})}
 Rayon_Cercle_En_Cours=0
 Rayon_Cercle_Precedent=0
 Rayon_Dernier_Cercle=0 # voir si utile
 Rayon_De_Couleur={round({1+{$Dimension_Finale*{2^0.5}}})}
 Decrement_Rayon=0
 Angle_Rayon_De_Couleur={72/$Repetition_Couleurs}
 Angle_Rayon_De_Couleur_En_Cours=0
 Angle_Rayon_De_Couleur_En_Cours_Fin=0
 Nb_De_Rayon_De_Couleur=0
 # 2 nouvelles images contours
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0

 if $Activer_Rayons_De_Couleurs==0
  # nouvelle image couleurs
  +Je_passe_l_hiver_en_Floride[0]
  if $Largeur_Origine>$Hauteur_Origine
   crop[-1] {{$Largeur_Origine-$Hauteur_Origine}/2},0,{{{$Largeur_Origine-$Hauteur_Origine}/2}+$Hauteur_Origine-1},$Hauteur_Origine
  elif $Largeur_Origine<$Hauteur_Origine
   crop[-1] 0,{{$Hauteur_Origine-$Largeur_Origine}/2},$Largeur_Origine,{{{$Hauteur_Origine-$Largeur_Origine}/2}+$Largeur_Origine-1}
  endif
  resize[-1] $Dimension_Finale,$Dimension_Finale
  to_rgba[-1]
 endif

 if $Activer_Rayons_De_Couleurs==1
  # nouvelle image couleurs
  $Dimension_Finale,$Dimension_Finale,1,4
  fill_color[-1] 0,0,0,255
 endif

 if $Sens_Rotation_Horaire==1
  Angle_Decalage_Couleurs_En_Cours={$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
 else
  Angle_Decalage_Couleurs_En_Cours={{$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}+{$Angle_Rayon_De_Couleur/2}}
 endif

 repeat $Repetition_Couleurs

  if $Couleurs_aleatoires==1
   R_a={round(u)*255}
   V_a={round(u)*255}
   B_a={round(u)*255}
   R_b={round(u)*255}
   V_b={round(u)*255}
   B_b={round(u)*255}
   R_c={round(u)*255}
   V_c={round(u)*255}
   B_c={round(u)*255}
   R_d={round(u)*255}
   V_d={round(u)*255}
   B_d={round(u)*255}
   R_e={round(u)*255}
   V_e={round(u)*255}
   B_e={round(u)*255}
  endif

  Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
  Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  if $Activer_Rayons_De_Couleurs==1
   polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_a,$V_a,$B_a,$A_a
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2
   line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
  Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  if $Activer_Rayons_De_Couleurs==1
   polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_b,$V_b,$B_b,$A_b
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2
   line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
  Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  if $Activer_Rayons_De_Couleurs==1
   polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_c,$V_c,$B_c,$A_c
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2
   line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
  Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  if $Activer_Rayons_De_Couleurs==1
   polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_d,$V_d,$B_d,$A_d
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2
   line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  Nb_De_Rayon_De_Couleur={$Nb_De_Rayon_De_Couleur+1}
  Angle_Rayon_De_Couleur_En_Cours={{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur+{$Angle_Rayon_De_Couleur*$Nb_De_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_En_Cours}
  if $Activer_Rayons_De_Couleurs==1
   polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin})}}},1,$R_e,$V_e,$B_e,$A_e
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2
   line[-2] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

 done

 Rayon_Cercle_En_Cours=$Rayon_Cercle_Final
 Rayon_Cercle_Precedent=$Rayon_Cercle_Final
 Nb_boucles=0

 # Rotation des cercles concentriques
 repeat $Nb_Circles

  if $Type_Variation_Dimensions_Cercles==0 # Sin A
   if $Nb_Circles-$Nb_boucles>1
    Decrement_Rayon={abs({{{$Rayon_Cercle_Precedent*{cos({pi/180*{$Angle_Variation_Fin}})}}-{$Rayon_Cercle_Precedent*{cos({pi/180*{$Angle_Variation_Origine}})}}}/$Nb_Circles})}
   else
    Decrement_Rayon={$Rayon_Cercle_Final-$Rayon_Cercle_En_Cours}
   endif
  elif $Type_Variation_Dimensions_Cercles==1 # Sin B
   if $Nb_Circles-$Nb_boucles>1
    Decrement_Rayon={abs({{{$Rayon_Cercle_Precedent*{-1+{cos({pi/180*{$Angle_Variation_Fin}})}}}-{$Rayon_Cercle_Precedent*{1+{cos({pi/180*{$Angle_Variation_Origine}})}}}}/$Nb_Circles})}
   else
    Decrement_Rayon={$Rayon_Cercle_Final-$Rayon_Cercle_En_Cours}
   endif
  elif $Type_Variation_Dimensions_Cercles==2 # Lineaire
   Decrement_Rayon={abs({{{$Rayon_Cercle_Final*{1+{cos({pi/180*{$Angle_Variation_Fin}})}}}-{$Rayon_Cercle_Final*{1+{cos({pi/180*{$Angle_Variation_Origine}})}}}}/$Nb_Circles})}
  endif

  if $Sens_Rotation_Horaire==1
   Angle_Decalage_Couleurs_En_Cours={{$Decalage_Cercles*$Angle_Rayon_De_Couleur/100}+$Angle_Decalage_Couleurs_En_Cours+{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
  else
   Angle_Decalage_Couleurs_En_Cours={{$Decalage_Cercles*$Angle_Rayon_De_Couleur/100*-1}+$Angle_Decalage_Couleurs_En_Cours-{$Angle_Decalage_Couleurs+{$Angle_Rayon_De_Couleur/2}}}
  endif

  if $Coef_Variation>0 # lin
   Rayon_Cercle_En_Cours={$Rayon_Cercle_En_Cours-{$Decrement_Rayon*$Coef_Variation}}
  else
   Rayon_Cercle_En_Cours={$Rayon_Cercle_En_Cours-{$Decrement_Rayon*{abs($Coef_Variation)}/{$Nb_boucles+1}}}
  endif

  # copie image couleurs , rotation , ajuster aux bonnes dimensions
  +Je_passe_l_hiver_en_Floride[-1]
  rotate[-1] {$Angle_Decalage_Couleurs_En_Cours}
  crop[-1] {{{w}-$Dimension_Finale}/2},{{{h}-$Dimension_Finale}/2},{{{{w}-$Dimension_Finale}/2}+$Dimension_Finale-1},{{{{h}-$Dimension_Finale}/2}+$Dimension_Finale-1}

  # creation masque temporaire rond
  $Dimension_Finale,$Dimension_Finale,1,4
  fill_color[-1] 0,0,0,255
  circle[-1] 50%,50%,$Rayon_Cercle_Precedent,1,255,0,0,255
  circle[-1] 50%,50%,$Rayon_Cercle_En_Cours,1,0,0,0,255
  replace_color[-1] 0%,0,255,0,0,255,0,0,0,0 # rouge vers transparence

  # mélanges
  blend[-1,-2] alpha,1,1

  replace_color[-1] 0%,0,0,0,0,255,0,0,0,0 # noir vers transparence
  blend[-1,-2] alpha,1,1

  # rotation contours
  if $Affichage_Contours>0
   rv[-1,-2]
   $Dimension_Finale,$Dimension_Finale,1,4
   +Je_passe_l_hiver_en_Floride[-2]
   rotate[-1] $Angle_Decalage_Couleurs_En_Cours
   crop[-1] {{{w}-$Dimension_Finale}/2},{{{h}-$Dimension_Finale}/2},{{{{w}-$Dimension_Finale}/2}+$Dimension_Finale-1},{{{{h}-$Dimension_Finale}/2}+$Dimension_Finale-1}
   circle[-1] 50%,50%,$Rayon_Cercle_En_Cours,1,0,0,0,0
   $Dimension_Finale,$Dimension_Finale,1,4
   fill_color[-1] 0,0,0,255
   circle[-1] 50%,50%,$Rayon_Cercle_Precedent,1,0,0,0,0
   blend[-1,-2] alpha,1,1
   replace_color[-1] 0%,0,0,0,0,255,0,0,0,0 # noir vers transparence
   blend[-1,-2] alpha,1,1
   # contours cercles
   if $Affichage_Contours==1||$Affichage_Contours==3
    ellipse[-1] 50%,50%,$Rayon_Cercle_En_Cours,$Rayon_Cercle_En_Cours,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
   endif
   blend[-1,-4] alpha,1,0
   rv[-1,-2]
  endif

  Rayon_Dernier_Cercle=$Rayon_Cercle_Precedent
  Rayon_Cercle_Precedent=$Rayon_Cercle_En_Cours
  Nb_boucles={$Nb_boucles+1}

 done

 rm[-2]

 # contour cercle
 if $Affichage_Contours==1||$Affichage_Contours==3
  ellipse[-2] 50%,50%,$Rayon_Cercle_Final,$Rayon_Cercle_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 if $Dilate_Contours>1 dilate_circ[-2] $Dilate_Contours endif
 if $Flou_Contours>0 blur[-2] $Flou_Contours,0 endif
 if $Sharpen_Contours>0 sharpen[-2] $Sharpen_Contours endif

 if $Filtre_Symmetrizoscope==1
  fx_symmetrizoscope[-1,-2] $Iterations_Symmetrizoscope,$Angle_Symmetrizoscope,0,$Symmetry_Sides
  Conserver_Exterieur_Cercles=0
 endif

 if $Conserver_Exterieur_Cercles==0
  # creation masque temporaire rond
  $Dimension_Finale,$Dimension_Finale,1,4
  fill_color[-1] 255,0,0,255
  circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
  replace_color[-1] 0%,0,255,0,0,255,0,0,0,0 # rouge vers transparence

  # mélanges
  rv[-1,-2]
  blend[-2,-1] add,1,0
 endif

 if $Supprimer_Calque_Origine==1
  rm[0]
  if $Melange_Couleurs_Contours==1
   rv[-1,-2]
   blend[-1,-2] alpha,1,0
  else
   rv[-1,-2]
  endif
 else
  if $Melange_Couleurs_Contours==1
   rv[-1,-2]
   blend[-1,-2] alpha,1,0
   rv[-1,-2]
  else
   rv[-1,-2,-3]
  endif
 endif

#################################################
##                                             ##
##        FIN Cercles_Concentriques_A          ##
##                                             ##
#################################################
#################################################
##                                             ##
##       Annular_Steiner_Chain_Round_Tile      ##
##                                             ##
#################################################

# 2015/04/19 origine
# 2015/04/21 amélioration rendu pour les cercles extérieurs
# 2016/02/02 {round(u)*255}

#@gui Annular Steiner Chain Round Tile : Annular_Steiner_Chain_Round_Tile, Annular_Steiner_Chain_Round_Tile(1)
#@gui :_=note("<span foreground="orangered">Annular Steiner Chain Round Tiles</span>")
#@gui :_=link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Image Finale</small></span>")
#@gui : Dimension En Pixels = int(800,256,1920)
#@gui : Supprimer Calque / Delete Layer = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Image</small></span>")
#@gui : Position X Origine (%) = float(0,0,100)
#@gui : Position Y Origine (%) = float(0,0,100)
#@gui : Dimension (%) = float(100,1,100)
#@gui : Angle Décalage Image Contour = float(0,0,360)
#@gui : Image Contour Dimension = float(100,1,100)
#@gui : Nb Cercles Extérieurs / Circles Surrounding  = int(12,3,180)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Couleurs Formes</small></span>")
#@gui : Activer Couleurs Formes = bool(1)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = choice(0,"Sans","A","B","C","D","E","F","G")
#@gui : Cercle / Circle C = color(255,255,0,127)
#@gui : Cercle / Circle D = color(0,0,255,127)
#@gui : Couleurs Aléatoires / Random Colors = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

Annular_Steiner_Chain_Round_Tile:

 Dimension_Finale=$1
 Supprimer_Calque_Origine=$2
 X={round({{w}*{$3/100}})}
 Y={round({{h}*{$4/100}})}
 Dimension_Image=$5
 Decalage_Angle_Images_Contour=$6
 Image_Contour_Dimension=$7
 Nb_Circles_Surrounding=$8
 Angle_inclinaison=$9

 Activer_Couleurs_Formes=$10

 R_Contours=$11
 V_Contours=$12
 B_Contours=$13
 A_Contours=$14

 Affichage_Contours=$15

 R_c=$16
 V_c=$17
 B_c=$18
 A_c=$19

 R_d=$20
 V_d=$21
 B_d=$22
 A_d=$23

 Couleurs_aleatoires=$24

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Angle_Theta={pi/$Nb_Circles_Surrounding}

 # variables dimensions
 Rayon_Cercle_Exterieur_Final={$Dimension_Finale/2}
 Rayon_Cercle_Centre_Final={{$Rayon_Cercle_Exterieur_Final*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
 Rayon_Cercles_Ext_Final={{$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final}/2}
 Rayon_Centres_C_Ext_Final={$Rayon_Cercle_Centre_Final+$Rayon_Cercles_Ext_Final}
 Rayon_Tang_Final={{{$Rayon_Centres_C_Ext_Final*$Rayon_Centres_C_Ext_Final}-{$Rayon_Cercles_Ext_Final*$Rayon_Cercles_Ext_Final}}^0.5}

 Fin_X={round({{{w}-$X}*$Dimension_Image/{100}})}
 Fin_Y={round({{{h}-$Y}*$Dimension_Image/{100}})}
 if $Fin_X>$Fin_Y
  Rayon_Cercle_Centre_Origine={$Fin_Y/2}
 else
  Rayon_Cercle_Centre_Origine={$Fin_X/2}
 endif

 to_rgb[-1]

 # masque image extérieure
 {$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},{$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100},1,4
 fill_color[-1] 0,0,0,0
 circle[-1] 50%,50%,{{w}/2},1,0,0,0,255

 # image extérieure
 +Je_passe_l_hiver_en_Floride[0]
 crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
 resize2dy[-1] {$Rayon_Cercles_Ext_Final*2*$Image_Contour_Dimension/100}
   # ? ajout de filtres en [-1] pour modifier rendu image extérieure
 blend[-1,-2] alpha

 # masque image centrale
 {$Rayon_Cercle_Centre_Final*2},{$Rayon_Cercle_Centre_Final*2},1,4
 fill_color[-1] 0,0,0,0
 circle[-1] 50%,50%,{{w}/2},1,0,0,0,255

 # image centrale
 +Je_passe_l_hiver_en_Floride[0]
 crop[-1] $X,$Y,{$X+{$Rayon_Cercle_Centre_Origine*2}},{$Y+{$Rayon_Cercle_Centre_Origine*2}}
 resize2dy[-1] {$Rayon_Cercle_Centre_Final*2}
   # ? ajout de filtres en [-1] pour modifier rendu image centrale
 blend[-1,-2] alpha,1,1
 expand_xy[-1] {$Rayon_Cercle_Exterieur_Final-$Rayon_Cercle_Centre_Final},0

 Nb_boucles=0
 X_ext=0
 Y_ext=0
 Angle=0
 Dimension_Img_pivotee=0
 X_Deplacement=0
 Y_Deplacement=0

 repeat $Nb_Circles_Surrounding
  Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
  X_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
  Y_ext={$Rayon_Cercle_Exterieur_Final+{$Rayon_Centres_C_Ext_Final*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
  Nb_boucles={$Nb_boucles+1}

  if $Couleurs_aleatoires==1
   R_c={round(u)*255}
   V_c={round(u)*255}
   B_c={round(u)*255}
   R_d={round(u)*255}
   V_d={round(u)*255}
   B_d={round(u)*255}
  endif

  if $Activer_Couleurs_Formes==1
   if ($Nb_Circles_Surrounding%2)==0
    if ($Nb_boucles%2)==0
     ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_c,$V_c,$B_c,$A_c
    else
     ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_d,$V_d,$B_d,$A_d
    endif
   else
    ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,$R_c,$V_c,$B_c,$A_c
   endif
   if $Affichage_Contours>0
    ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext_Final,$Rayon_Cercles_Ext_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
   endif
  endif

  +Je_passe_l_hiver_en_Floride[-2]
  rotate[-1] {$Angle+$Decalage_Angle_Images_Contour}
   # genre d'autocrop
  crop[-1] {{{w}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2},{{{{w}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}},{{{{h}-{$Rayon_Cercles_Ext_Final*2}}/2}+{$Rayon_Cercles_Ext_Final*2}}
   # déplacer aux bonnes coordonnées
  X_Deplacement={$X_ext-$Rayon_Cercles_Ext_Final}
  Y_Deplacement={$Y_ext-$Rayon_Cercles_Ext_Final}
  crop[-1] {-$X_Deplacement},{-$Y_Deplacement},{{2*$Rayon_Cercle_Exterieur_Final}-$X_Deplacement-1},{{2*$Rayon_Cercle_Exterieur_Final}-$Y_Deplacement-1},0
   # mélange vers image centrale
  blend[-1,-2] alpha,1,1

 done

 if $Activer_Couleurs_Formes==1
  if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==5
   ellipse[-1] 50%,50%,$Rayon_Cercle_Exterieur_Final,$Rayon_Cercle_Exterieur_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==6
   ellipse[-1] 50%,50%,$Rayon_Cercle_Centre_Final,$Rayon_Cercle_Centre_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Affichage_Contours==2||$Affichage_Contours==3 # cercle des centres
   ellipse[-1] 50%,50%,$Rayon_Centres_C_Ext_Final,$Rayon_Centres_C_Ext_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Affichage_Contours==3||$Affichage_Contours==4 # cercle des tang.
   ellipse[-1] 50%,50%,$Rayon_Tang_Final,$Rayon_Tang_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
 endif

 rm[-2]

 if $Supprimer_Calque_Origine==1
  rm[0]
 else
  rv[0,-1]
 endif

 #text_outline[-1] {2*$Rayon_Cercle_Exterieur_Final},10,10,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Cercles_Ext_Final},10,60,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Centres_C_Ext_Final},10,110,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Tang_Final},10,160,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Cercle_Centre_Final},10,210,64,1,1,255,255,255

#################################################
##                                             ##
##   FIN Annular_Steiner_Chain_Round_Tile      ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_Coeurs_Hearts_002            ##
##                                             ##
#################################################
## 2016/12/20 gmic 1.8.0 balance_gamma
## 2015/03/13 samj_Coeurs_Hearts_002 remplace Coeurs_Hearts_001 , menu , preview , utilisation de gimp_blend pour avoir + d'effets
## 2014/04/26 to_rgb
## 20140423 blend
## pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
##  Coeurs_Hearts_001 samj_Coeurs_Hearts_001 16,100,0,0.5,1,3,0,0,1,0,0,0,255,0    Image http://www.fontplay.com/freephotos/4thfoldern/fp022706-13.jpg
####    coeur 16*16
####    (
####    0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0;
####    0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0;
####    0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0;
####    0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;
####    0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;
####    0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0;
####    0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0;
####    0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0;
####    0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0
####    )

####   motif 16*16
####    (
####    1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1;
####    0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1
####    )

#@gui Coeurs Hearts 002  : samj_Coeurs_Hearts_002, samj_Coeurs_Hearts_002(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="red">Des c&#339;urs aux couleurs de l'image.</span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>C&#339;urs / Hearts</small></span>")
#@gui : Résolution = int(16,4,128)
#@gui : Remplissage % / Filling % = float(100,20,100)
#@gui : Angle Rotation = int(0,0,360)
#@gui : Flou / Blur = float(0,0,2)
#@gui : Coeurs / Hearts = bool(1)
#@gui : Interpolation = int(0,0,3)
#@gui : Couleur Fond / Background Color = color(255,255,255,255)
#@gui : Gris / Grey = bool(0)
#@gui : Amplification Couleurs / Colors Boost = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Mélange / Blend</small></span>")
#@gui : Type Avant Plan / Foreground = choice(0,"Type A","Type B")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Coeurs_Hearts_002 :

 Resolution=$1
 Remplissage=$2
 Angle_Rotation_Motif=$3
 flou=$4
 Coeurs_Hearts=$5
 Interpolation=$6
 R_Couleur=$7
 V_Couleur=$8
 B_Couleur=$9
 A_Couleur=$10
 Gris=$11
 Boost=$12
 Type_Avant_Plan=$13
 Mode_blend=$14
 Opacity_blend=$15

 if $Type_Avant_Plan==1
  +Je_passe_l_hiver_en_Floride[-1]
  to_rgb[-2]
  negate[-2]
 endif

 to_rgb[-1]
 negate[-1]

 if $Interpolation==0
  resize[-1] {{w}/$Resolution},{{h}/$Resolution}
  c[-1] 0,255
 elif $Interpolation==1
  resize[-1] {{w}/$Resolution},{{h}/$Resolution},1,3,3
  c[-1] 0,255
 elif $Interpolation==2
  resize[-1] {{w}/$Resolution},{{h}/$Resolution}
  n[-1] 0,255
 elif $Interpolation==3
  resize[-1] {{w}/$Resolution},{{h}/$Resolution},1,3,3
  n[-1] 0,255
 endif

 if $Type_Avant_Plan==1
  resize[-2] {{w}*$Resolution},{{h}*$Resolution}
  rm[-1]
 else
  resize[-1] {{w}*$Resolution},{{h}*$Resolution}
 endif

 if $Gris==1
  to_gray[-1]
 endif

 c[-1] 0,255

 if $Boost==1
  balance_gamma[-1] 128,128,128,1
  n[-1] 0,255
 endif

 negate[-1]
 to_rgba[-1]

 $Resolution,$Resolution,1,4
 fill_color[-1] 0,0,0,0

 if $Coeurs_Hearts==1
  #### Coeur 16*16
  (0,0,0,1,1,1,0,0,0,0,1,1,1,0,0,0;0,1,1,1,1,1,1,0,0,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,0,1,1,1,1,1,1,1,1,1,1,1,1,0,0;0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0;0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0;0,0,0,0,0,1,1,1,1,1,1,0,0,0,0,0;0,0,0,0,0,0,1,1,1,1,0,0,0,0,0,0;0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0;0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,0)
 else
  #### motif 16*16
  (1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0;1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1;0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1;0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1)
 endif

 if $Angle_Rotation_Motif>0
  rotate[-1] $Angle_Rotation_Motif,0,0
  autocrop[-1] 0
 endif

 resize[-1] {$Resolution*$Remplissage/100},{$Resolution*$Remplissage/100}
 blend[-1,-2] alpha
 resize[-1] [-2],[-2],1,1,0,2
 to_rgba[-1]
 #replace_color[-1] 0%,0,0,0,0,255,0,0,0,0
 #replace_color[-1] 0%,0,0,0,0,255,255,255,255,255
 replace_color[-1] 0%,0,0,0,0,255,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
 replace_color[-1] 0%,0,1,1,1,255,0,0,0,0

 gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0 # alpha

 if $flou>0
  blur[-1] $flou,0
 endif
#################################################
##                                             ##
##          FIN samj_Coeurs_Hearts_002         ##
##                                             ##
#################################################


#################################################################################################################################################################################################
#
#                                                                                                                                                                                        ARTISTIC
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_atistic :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Artistic</b>
#################################################
##                                             ##
##             samj_Test_Cubisme_B             ##
##                                             ##
#################################################

#@gui Cubisme B : samj_Test_Cubisme_B, samj_Test_Cubisme_B
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2021/01/samuser-avec-gmic-gimp-filtre-cubisme-b.html")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Decoupage Triangle A</b></span>")
#@gui : 1 - Tuiles = int(11,1,64)
#@gui : 2 - Type Imagegrid = choice(6,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing","All Types")
#@gui : 3 - Noise-Spread = int(0,0,40)
#@gui : 4 - Shift X = int(30,0,300)
#@gui : 5 - Shift Y = int(40,0,300)
#@gui :_=note("<span foreground="orangered"><b>Decoupage Triangle B</b></span>")
#@gui : 6 - Tuiles = int(17,1,64)
#@gui : 7 - Type Imagegrid = choice(6,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing,"All Types")
#@gui : 8 - Noise-Spread = int(0,0,40)
#@gui : 9 - Shift X = int(0,0,300)
#@gui : 10 - Shift Y = int(0,0,300)
#@gui :_=note("<span foreground="orangered"><b>Mélange/Blend</b></span>")
#@gui : 11 - Inverser/Invert A-B = bool(0)
#@gui : 12 - Mode = choice(3,"add","alpha","and","average","blue","burn","darken","difference",
#@gui : "divide","dodge","edges","exclusion","freeze","grainextract","grainmerge","green","hardlight",
#@gui : "hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance",
#@gui : "multiply","negation","or","overlay","pinlight","red","reflect","saturation","seamless","seamless_mixed",
#@gui : "screen","shapeareamax","shapeareamax0","shapeareamin","shapeareamin0","shapeaverage","shapeaverage0",
#@gui : "shapemedian","shapemedian0","shapemin","shapemin0","shapemax","shapemax0","softburn","softdodge",
#@gui : "softlight","stamp","subtract","value","vividlight","xor")
#@gui : 13 - Opacité / Opacity = float(1,0,1)
#@gui :_=note("<span foreground="orangered"><b>Brushify</b></span>")
#@gui : 14 - Brushify = bool(1)
#@gui : 15 - Nb Dimensions/Sizes= int(64,1,128)
#@gui : 16 - Opacité/Opacity = int(25,0,100)
#@gui : 17 - Brosse/Brush Dimension = int(8,8,40)
#@gui : 18 - Inverser/Invert = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Pseudo Gray</b></span>")
#@gui : 19 - Pseudo Gray = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/13</i>.</small>")

samj_Test_Cubisme_B :
repeat $! l[$>]
to_rgba
+samj_Decoupage_Triangle $1,$2,$3,$4,$5
samj_Decoupage_Triangle[-2] $6,$7,$8,$9,$10
mode=${arg\ 1+$12,add,alpha,and,average,blue,burn,darken,difference,\
,divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
,hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
,multiply,negation,or,overlay,pinlight,red,reflect,saturation,seamless,seamless_mixed,\
,screen,shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,shapeaverage,shapeaverage0,\
,shapemedian,shapemedian0,shapemin,shapemin0,shapemax,shapemax0,softburn,softdodge,\
,softlight,stamp,subtract,value,vividlight,xor}
if $11==1 rv[-1,-2] endif
blend[-1,-2] $mode,$13
n 0,255 
if $14==1
	$17,$17,1,3
	fill_color[-1] 0,0,0
	rectangle[-1] 1,1,{{w}-3},{{h}-3},1,127,127,127
	srand 123
	noise[-1] 2,2
	if $18==1 negate[-1] endif
	n[-1] 0,255
	srand 123
	brushify[0] [-1],$15,,4,,{$16%}
	rm[-1]
endif
if $19==1 to_pseudogray 10,1,8 endif
endl done

samj_Decoupage_Triangle :
# $1=Tuiles $2=Type Imagegrid $3=Spread $4,$5=Shift X et Y
skip ${1=2},${2=5},${3=0},${4=0},${5=0}
Haut={h}
Larg={w}
shift $4,$5,0,0,2
resize {round($Larg/$1)*$1},{round($Haut/$1)*$1}
split y,$1
split x,$1
if $2<6
	imagegrid_triangular {w},{h},$2,0,0,0,0
else
	NbImg=$!
	Index=0
	repeat $NbImg
		Index={$Index-1}
		imagegrid_triangular[$Index] {w},{h},{$Index%6},0,0,0,0
	done
endif
if $3>0 spread $3 endif
append x
split x,$1
append y
resize $Larg,$Haut
shift[-1] -$4,-$5,0,0,2

#################################################
##                                             ##
##           FIN samj_Test_Cubisme_B           ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Test_Cubisme_A             ##
##                                             ##
#################################################
# Inspiration Juan_Gris https://fr.wikipedia.org/wiki/Juan_Gris
#@gui Cubisme A : samj_Test_Cubisme_A, samj_Test_Cubisme_A
#@gui :_=link("Inspiration","https://fr.wikipedia.org/wiki/Portrait_de_Pablo_Picasso#/media/Fichier:Juan_Gris_-_Portrait_of_Pablo_Picasso_-_Google_Art_Project.jpg")
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2021/01/samuser-avec-gmic-gimp-filtre-cubisme-a.html")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : 1 - Dilate = bool(1)
#@gui : 2 - DiA = int(120,4,200)
#@gui : 3 - DiB = int(70,4,200)
#@gui :_=note("<span foreground="orangered"><b>Imagegrid Triangular</b></span>")
#@gui : 4 - Imagegrid = bool(1)
#@gui : 5 - X = int(30,1,256)
#@gui : 6 - Y = int(30,1,256)
#@gui : 7 - Type = choice(2,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing")
#@gui :_=note("<span foreground="orangered"><b>Variante</b></span>")
#@gui : 8 - Variante = bool(0)
#@gui : 9 - Noise-Spread = int(6,1,40)
#@gui : 10 - Flou/Blur = float(0,0,10)
#@gui :_=note("<span foreground="orangered"><b>Polygonize</b></span>")
#@gui : 11 - Polygonize = bool(1)
#@gui : 12 - Amplitude = int(300,0,2000)
#@gui : 13 - Douceur/Smoothness = float(8,0,100)
#@gui : 14 - Surface minimale/Minimal area = float(10,0,100)
#@gui : 15 - X-resolution = float(10,1,256)
#@gui : 16 - Y-resolution = float(20,1,256)
#@gui :_=note("<span foreground="orangered"><b>Kuwahara</b></span>")
#@gui : 17 - Kuwahara = bool(1)
#@gui : 18 - Répétition/Repeat = int(1,1,4)
#@gui : 19 - Size = int(5,1,50)
#@gui :_=note("<span foreground="orangered"><b>Drawing-Smooth</b></span>")
#@gui : 20 - Drawing = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Brushify</b></span>")
#@gui : 21 - Brushify = bool(1)
#@gui : 22 - Nb Dimensions/Sizes= int(64,1,128)
#@gui : 23 - Opacité/Opacity = int(25,0,100)
#@gui : 24 - Brosse/Brush Dimension = int(8,8,40)
#@gui : 25 - Inverser/Invert = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Pseudo Gray</b></span>")
#@gui : 26 - Pseudo Gray = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/12</i>.</small>")

samj_Test_Cubisme_A :
repeat $! l[$>]
if $1==1 +dilate  {{{w}+{h}}/$2} dilate[-2]  {{{w}+{h}}/$3} blend edges endif
if $4==1 imagegrid_triangular $5,$6,$7,0,0,0,0 endif
if $8==1 srand 123 spread $9 noise {$9*2.5} to_rgb blur $10 endif
if $11==1 polygonize $12,$13,$14,$15,$16 endif
if $17==1 repeat $18 kuwahara $19 done endif
if $20>0 drawing 200 smooth 300 endif
n 0,255 
if $21==1
	$24,$24,1,3
	fill_color[-1] 0,0,0
	rectangle[-1] 1,1,{{w}-3},{{h}-3},1,127,127,127
	srand 123
	noise[-1] 2,2
	if $25==1 negate[-1] endif
	n[-1] 0,255
	srand 123
	brushify[0] [-1],$22,,4,,{$23%}
	rm[-1]
endif
if $26==1 to_pseudogray 10,1,8 endif
endl done
#################################################
##                                             ##
##           FIN samj_Test_Cubisme_A           ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Hallucinogen_b             ##
##                                             ##
#################################################

#@gui Hallucinogen 2 : samj_Hallucinogen_b, samj_Hallucinogen_b
#@gui :_=note("<span foreground="orangered"><b>Filtre Polygonize</b></span>")
#@gui : Polygonize = bool(1)
#@gui : Amplitude = int(300,0,2000)
#@gui : Douceur/Smoothness = float(10,0,100)
#@gui : Surface minimale/Minimal area = float(10,0,100)
#@gui : X-resolution = float(10,1,256)
#@gui : Y-resolution = float(10,1,256)
#@gui :_=note("<span foreground="orangered"><b>Filtre HallucinoGenerator</b></span>")
#@gui : Autoindex = int(80,1,255)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Puissance/Pow = float(80,0,100)
#@gui : Modulo = float(1.5,0.5,2)
#@gui : Adoucir/Smooth = int(2,0,5)
#@gui : Inverser/Invert = bool(0)
#@gui : Répéter ce Filtre/Repeat = bool(0)
#@gui :_=note("<span foreground="orangered"><b>Brushify</b></span>")
#@gui : Brushify = bool(1)
#@gui : Nb Dimensions/Sizes= int(1,1,16)
#@gui : Opacité/Opacity = int(80,0,100)
#@gui : Brosse/Brush Dimension = int(8,8,40)
#@gui :_=note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Blend= bool(1)
#@gui : Inverser Calques/Reverse Layers= bool(0)
#@gui : Mode = choice(14,"add","alpha","and","average","blue","burn","darken","difference",
#@gui : "divide","dodge","edges","exclusion","freeze","grainextract","grainmerge","green","hardlight",
#@gui : "hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance",
#@gui : "multiply","negation","or","overlay","pinlight","red","reflect","saturation","seamless","seamless_mixed",
#@gui : "screen","shapeareamax","shapeareamax0","shapeareamin","shapeareamin0","shapeaverage","shapeaverage0",
#@gui : "shapemedian","shapemedian0","shapemin","shapemin0","shapemax","shapemax0","softburn","softdodge",
#@gui : "softlight","stamp","subtract","value","vividlight","xor")
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/11/25</i>.</small>")

samj_Hallucinogen_b :
if $18==0
	if $1==1 polygonize $2,$3,$4,$5,$6 endif
	samj_Hallucinogen $7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
else
	if $1==1
		+polygonize $2,$3,$4,$5,$6
		samj_Hallucinogen[-1] $7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
	else
		+samj_Hallucinogen[-1] $7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
	endif
	if $19==1 rv[-1,0] endif
	mode=${arg\ 1+$20,add,alpha,and,average,blue,burn,darken,difference,\
	,divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
	,hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
	,multiply,negation,or,overlay,pinlight,red,reflect,saturation,seamless,seamless_mixed,\
	,screen,shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,shapeaverage,shapeaverage0,\
	,shapemedian,shapemedian0,shapemin,shapemin0,shapemax,shapemax0,softburn,softdodge,\
	,softlight,stamp,subtract,value,vividlight,xor}
	blend $mode,$21
endif

#################################################
##                                             ##
##           FIN samj_Hallucinogen_b           ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Hallucinogen              ##
##                                             ##
#################################################

#@gui Hallucinogen : samj_Hallucinogen, samj_Hallucinogen
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre.html")
#@gui :_=note("<span foreground="orangered"><b>Filtre HallucinoGenerator</b></span>")
#@gui : Autoindex = int(80,1,255)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Puissance/Pow = float(80,0,100)
#@gui : Modulo = float(1.5,0.5,2)
#@gui : Adoucir/Smooth = int(2,0,5)
#@gui : Inverser/Invert = bool(0)
#@gui : Répéter ce Filtre/Repeat = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Brushify</b></span>")
#@gui : Brushify = bool(0)
#@gui : Nb Dimensions/Sizes= int(1,1,16)
#@gui : Opacité/Opacity = int(80,0,100)
#@gui : Brosse/Brush Dimension = int(8,8,40)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/19</i>.</small>")

samj_Hallucinogen :

	Larg={w}
	Haut={h}
	to_rgb
	n 0,255
	samj_HallucinoGenerator $1,$2,$3,$4,$5,$6
	if $7==1 samj_HallucinoGenerator $1,$2,$3,$4,$5,$6 endif
	if $8==1
			$11,$11,1,3
			fill_color[-1] 0,0,0
			rectangle[-1] 1,1,{{w}-3},{{h}-3},1,127,127,127
			srand 123
			noise[-1] 2,2
			if $6==1 negate[-1] endif
			n[-1] 0,255
			srand 123
			brushify[0] [-1],$9,,4,,{$10%}
			rm[-1]
	endif

samj_HallucinoGenerator:
skip ${1=80},${2=2},${3=80},${4=1.5},${5=2},${6=0}
if $1>1 autoindex $1 endif
blur $2
pow {0.4+{$3/10000}}
mod $4
repeat $5 smooth 100,0.7,0.3,0.6 done
if $6==1 negate endif
n 0,255

#################################################
##                                             ##
##            FIN samj_Hallucinogen            ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Posterize_B                ##
##                                             ##
#################################################

#@gui Posterize B : samj_Posterize_B, samj_Posterize_B(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Posterize B</b></span>")
#@gui : Blur  = float(1,0,5)
#@gui : Colors  = int(12,2,32)
#@gui : Inpaint Holes = float(1,0.1,5)
#@gui : Smooth = int(0,0,8)
#@gui : Smooth - Smoothness = float(40,10,800)
#@gui : Smooth - Edges (%) = float(30,0,100)
#@gui : Smooth - Paint = float(1,0,10)
#@gui : Sharpen = int(0,0,5000)
#@gui : Normalize Colors = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours Difference</b></span>")
#@gui : Contours Difference = bool(0)
#@gui : XY-Offset = choice(0,"1 1","1 -1","-1 1","-1 -1","0 1","1 0","0 -1","-1 0")
#@gui : Thickness = int(1,1,8)
#@gui : Dithering = bool(0)
#@gui : Erasure Grid = int(0,0,16)
#@gui : Vivid Light - Type = choice(0,"No","Vivid Light 1","Vivid Light 2","Vivid Light 3")
#@gui : Vivid Light - Colors = int(0,0,200)
#@gui : Black and White = bool(0)
#@gui : Negative Colors = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/24</i>.</small>")

samj_Posterize_B:

	if $15>0&&$10==1 +blur[-1] $1 n[-2] 0,{255-{$16/$15}} else blur[-1] $1 endif
	autoindex[-1] $2
	inpaint_holes[-1] {{w}/100*$3},1
	# smooth plus joli issu de fx_posterize
	repeat $4 smooth[-1] $5,{$6%},1,$7,{2*$7} done
	if $8>0 sharpen[-1] $8 endif
	if $9==1 n[-1] 0,255 endif
	if $10==1
		luminance[-1]
		if $11==0 +shift[-1] 1,1,0,0,0
		elif $11==1 +shift[-1] 1,-1,0,0,0
		elif $11==2 +shift[-1] -1,1,0,0,0
		elif $11==3 +shift[-1] -1,-1,0,0,0
		elif $11==4 +shift[-1] 0,1,0,0,0
		elif $11==5 +shift[-1] 1,0,0,0,0
		elif $11==6 +shift[-1] 0,-1,0,0,0
		elif $11==7 +shift[-1] -1,0,0,0,0
		endif
		blend[-1,-2] difference
		n[-1] 0,255
		negate[-1]
		erode_circ[-1] $12
		round
		if $13==1 ditheredbw[-1] endif
		if $14>0 grid[-1] {18-$14},{18-$14},0,0,255,255 endif
		if $15==1 to_rgb[-1,-2] blend[-1,-2] vividlight
		elif $15==2 ++[-2] to_rgb[-1,-2,-3] repeat 2 blend[-1,-2] vividlight done
		elif $15==3 ++[-2] ++[-3] to_rgb[-1,-2,-3,-4] repeat 3 blend[-1,-2] vividlight done
		endif
		if $17==1 to_gray[-1] round select_color[-1] 0,255 n[-1] 0,255 endif
		if $18==1 negate[-1] endif
	endif

#################################################
##                                             ##
##           FIN samj_Posterize_B              ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_fx_sketchbw_modifie           ##
##                                             ##
#################################################

#@gui Fx Sketchbw Modifie : samj_fx_sketchbw_modifie, samj_fx_sketchbw_modifie_preview(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Sketch</small></span>")
#@gui : Number of orientations = int(3,1,16)
#@gui : Starting angle = float(45,0,180)
#@gui : Angle range = float(180,0,180)
#@gui : Stroke length = float(30,0,1000)
#@gui : Contour threshold = float(1.75,0,10)
#@gui : Opacity = float(0.02,0,0.3)
#@gui : Background intensity = float(0.5,0,2)
#@gui : Density = float(0.75,0,5)
#@gui : Sharpness = float(0.1,0,1)
#@gui : Anisotropy = float(0.7,0,1)
#@gui : Smoothness = float(3,0,10)
#@gui : Cohérence = float(6,0,10)
#@gui : Boost stroke = bool(0)
#@gui : Curved stroke = bool(1)
#@gui : Color model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui : Forme Aléatoire = bool(0)
#@gui : Forme = int(1234,1,111111)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Smooth</small></span>")
#@gui : Smooth = bool(0)
#@gui : Amplitude = int(2,1,5)
#@gui : Sharpness = int(100,0,500)
#@gui : Anisotropy = float(0.2,0,0.5)
#@gui : Sigma = float(1,0,10)
#@gui : dl = float(4,0,10)
#@gui : Equalize = bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i><a href="http://ow.ly/wpsV30fzhdI">David Tschumperlé / <span color="#FF6060">&#x2764;&#x2764;</span></a> modifications : samj</i>.      Latest update: <i>2018/05/15</i>.</small>")

samj_fx_sketchbw_modifie :

 samj_fonction_fx_sketchbw_modifie $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17
 if $18
  repeat $19
   smooth $20,$21,1,$22,$23
  done
  n 0,255
  if $24==1 equalize endif
 endif

samj_fx_sketchbw_modifie_preview :
 gui_split_preview "samj_fx_sketchbw_modifie $*",$-1

samj_fonction_fx_sketchbw_modifie :

 if $16==0 srand $17 endif
 if $15==4 repeat $! l[$>] +sketchbw ${1-14} blend hardlight endl done return fi
 sketchbw ${1-14}
 if $15&1 negate fi
 if $15==2 r 100%,100%,1,4 repeat $! sh[$>] 3 *. -2 +. {2*255} c. 0,255 rm. done
 elif $15==3 r 100%,100%,1,4 repeat $! sh[$>] 3 *. 2 c. 0,255 rm. done
 fi

#################################################
##                                             ##
##       FIN  samj_fx_sketchbw_modifie         ##
##                                             ##
#################################################
#################################################
##                                             ##
##        samj_Isophotes_Vers_Aquarelle        ##
##                                             ##
#################################################

#@gui Isophotes Vers Aquarelle  : samj_Isophotes_Vers_Aquarelle , samj_Isophotes_Vers_Aquarelle (1)
#@gui :_=note("<span foreground="orangered"><b><u>Isophotes</u></b></span>")
#@gui : Nb Décomposition Couleurs = int(16,2,32)
#@gui : Variation Flou = Float(0.5,0.1,2)
#@gui : Isophotes = int(4,3,16)
#@gui : Dilate = int(0,0,8)
#@gui :_=note("<span foreground="orangered"><b><u>Segmentation</u></b></span>")
#@gui : Segmentation = bool(1)
#@gui : Edge threshold = float(10,0,30)
#@gui : Smoothness = float(1,0,5)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value action = choice("None","Cut","Normalize")
#@gui :_=note("<span foreground="orangered"><b><u>Contours</u></b></span>")
#@gui : Flou = Float(0,0,2)
#@gui : Couleurs = Float(0,-2,2)
#@gui :_=note("<span foreground="orangered"><b><u>Fond</u></b></span>")
#@gui : Fond = bool(1)
#@gui : Amplitude Noise = float(10,5,200)
#@gui : Density Hardsketchbw= float(10,5,100)
#@gui : Spread Variations = float(4,3,20)
#@gui : Amplitude Water = float(3,2,10)
#@gui : Couleur / Color = color(251,237,206)
#@gui : Opacité / Opacity = float(1,-1,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2017/01/20</i>.</small>")

samj_Isophotes_Vers_Aquarelle :

 Nb_Decomposition_Couleurs=$1
 Variation_Flou=$2
 Nb_Isophotes=$3
 Dilatation=$4
 Segmentation=$5
 S_E=$6
 S_S=$7
 S_C=$8
 S_V=$9
 Flou=$10
 Couleurs=$11
 Fond=$12
 F_A_N=$13
 F_D_H=$14
 F_S_V=$15
 F_A_W=$16
 F_R=$17
 F_V=$18
 F_B=$19
 F_O=$20

 Nb_Boucles=0

 n[-1] 0,255
 +Je_passe_l_hiver_en_Floride[-1]
 repeat $Nb_Decomposition_Couleurs
  if $Nb_Boucles>0
   blur[-1] {$Nb_Boucles*$Variation_Flou}
   equalize[-1] {$Nb_Boucles+4},0,100
  endif
  isophotes[-1] $Nb_Isophotes
  if $Nb_Boucles>0
   if $Dilatation>0 dilate_circ[-1] {$Dilatation+1} endif
   blend[-1,-2] alpha
  endif
  Nb_Boucles={$Nb_Boucles+1}
  +Je_passe_l_hiver_en_Floride[-2]
 done
 rm[-1,-3]
 if $Segmentation>0 fx_segment_watershed[-1] $S_E,$S_S,$S_C,$S_V endif
 if $Flou>0 blur[-1] $Flou endif
 if $Couleurs>0
  mul[-1] $Couleurs
 elif $Couleurs<0
  pow[-1] {abs($Couleurs)}
 endif
 if $Fond==1
  {w},{h},1,3
  samj_Texture_Aquarelle_1[-1] $F_A_N,$F_D_H,$F_S_V,$F_A_W,$F_R,$F_V,$F_B,$F_O
  rv[-1,-2]
  blend[-1,-2] alpha
 endif

#################################################
##                                             ##
##      FIN samj_Isophotes_Vers_Aquarelle      ##
##                                             ##
#################################################
#################################################
##                                             ##
##                samj_Plasmic                 ##
##                                             ##
#################################################
#### samj_Plasmic 1.2,12,40,0,4,2,0
# 20160203 ajout blur
#@gui Plasmic  : samj_Plasmic, samj_Plasmic(1)
#@gui :_=note("Plasmic filter is based on a composition of Lylejk")
#@gui :_=link("https://www.flickr.com/photos/34520999@N05/24513476052/sizes/o/","https://www.flickr.com/photos/34520999@N05/24513476052/sizes/o/")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blur</b></span>")
#@gui : Blur = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Pow = float(1.1,0.2,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Segment</b></span>")
#@gui : Edge threshold = float(2,0,15)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Cut</b></span>")
#@gui : Cut = int(40,0,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate Contours = int(0,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Plasmic = int(0,0,20)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradation Deform</b></span>")
#@gui : Deform = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradation Spread</b></span>")
#@gui : Spread = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2016/02/03</i>.</small>")

samj_Plasmic :

Flou=$1
Puissance=$2
Edge_threshold=$3
Couper_Cut=$4
Dilate_Contours=$5
Valeur_Plasma=$6
Deformation=$7
Degradation_Spread=$8

Largeur_Origine={w}
Hauteur_Origine={h}

if $Flou>0 blur[-1] $Flou endif
if $Valeur_Plasma>0
 $Largeur_Origine,$Hauteur_Origine,1,3
 plasma[-1] $Valeur_Plasma,$Valeur_Plasma
 n[-1] 0,255
 rv[-1,-2]
else
 +Je_passe_l_hiver_en_Floride[0]
endif
to_rgb[-1,-2]
pow[-1] $Puissance
c[-1] 0,255
fx_segment_watershed[-1] $2,1,0,2,0
fx_gradient_norm[-1] 0,0.5,0,100,0,0
c[-1] $Couper_Cut,255
n[-1] 0,255

if $Deformation>0 deform[-1,-2] $Deformation endif
if $Dilate_Contours>1 dilate_circ[-1,-2] $Dilate_Contours endif
if $Degradation_Spread>1 spread[-1,-2] $Degradation_Spread endif
blend[-2,-1] darken,1,0

#################################################
##                                             ##
##               FIN samj_Plasmic              ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Pointillisme_B            ##
##                                             ##
#################################################

# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
#@gui Pointillisme B  : samj_Pointillisme_B , samj_Pointillisme_B (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Couleurs</b></span>")
#@gui : Variation = float(1,0.2,2)
#@gui : Dilatation = int(0,0,16)
#@gui : Pixels = float(90,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Points</b></span>")
#@gui : Dimension = int(3,0,20)
#@gui : Rond vs Carré = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Arriere plan</b></span>")
#@gui : Fond Transparent = bool(1)
#@gui : Couleur = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Pointillisme_B :

Variation=$1
Dilatation=$2
Pixels=$3
Dimension=$4
Rond=$5
Fond_Transparent=$6
R_a=$7
V_a=$8
B_a=$9
A_a=$10

mul[-1] $Variation
if $Dilatation>0 dilate[-1] {$Dilatation+1} endif
remove_pixels[-1] 90%
to_rgba[-1]
replace_color[-1] 0%,0,0,0,0,255,0,0,0,0
if $Dimension>0
 if $Rond==1
  dilate_circ[-1] {$Dimension+1}
 else
  dilate[-1] {$Dimension+1}
 endif
endif
if $Fond_Transparent==0
 {w},{h},1,4
 fill_color[-1] $R_a,$V_a,$B_a,$A_a
 rv[-1,-2]
 blend[-1,-2] alpha
endif

#################################################
##                                             ##
##            FIN samj_Pointillisme_B          ##
##                                             ##
#################################################
#################################################
##                                             ##
##               samj_Pointillisme             ##
##                                             ##
#################################################

#@gui Pointillisme  : samj_Pointillisme , samj_Pointillisme (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Points</b></span>")
#@gui : Intensite = int(10,1,100)
#@gui : Densité = float(2,0,100)
#@gui : Dimension = int(5,2,20)
#@gui : Rond vs Carré = bool(1)
#@gui : Variation = float(1,0.2,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Arriere plan</b></span>")
#@gui : Fond Transparent = bool(1)
#@gui : Couleur = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/08</i>.</small>")

samj_Pointillisme :

Intensite=$1
Densite=$2
Dimension=$3
Rond=$4
Variation=$5
Fond_Transparent=$6
R_a=$7
V_a=$8
B_a=$9
A_a=$10

to_rgba[-1]
+Je_passe_l_hiver_en_Floride[-1]
mul[-1] $Variation
sharpen[-1] {2000*$Intensite}
noise[-1] {1+$Densite}
warp[-2] [-1],1,0,0
rm[-1]
if $Rond==1
 dilate_circ[-1] $Dimension
else
 dilate[-1] $Dimension
endif
if $Fond_Transparent==0
 {w},{h},1,4
 fill_color[-1] $R_a,$V_a,$B_a,$A_a
 rv[-1,-2]
 blend[-1,-2] alpha
endif

#################################################
##                                             ##
##             FIN samj_Pointillisme           ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Flamboyance_Test            ##
##                                             ##
#################################################
# version 5 modification noise vers noise_hurl
# version 4 bis ajout to_rgb avant negate + menu
# version 3 + spread
# version 2 sans échelle et sans filtres Gimp + sharpen + noise
# origine GMIC 1.7.9  2016/12/05
#@gui Flamboyance Test : samj_Flamboyance_Test, samj_Flamboyance_Test_preview
#@gui : sep = separator(), url = link("GMIC Adaptation of the tutorial written by Lyle Kroll","http://gimpchat.com/viewtopic.php?f=10&t=14999")
#@gui :_=note("<span foreground="blue"><i>Thank you for this beautiful and interesting effect</i></span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Hard Sketch</u></b></span>")
#@gui : Amplitude = float(65,0,4000)
#@gui : Density = float(28,0,100)
#@gui : Smoothness = float(9.25,0,10)
#@gui : Opacity = float(0.3,0,1)
#@gui : Edge = float(0,0,100)
#@gui : Fast approximation = bool(1)
#@gui : Color Variation = float(1.1,0.5,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Smooth Bilateral</u></b></span>")
#@gui : Spatial variance = float(10,0,100)
#@gui : Value variance = float(12,0,100)
#@gui : Iterations = int(2,1,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Blend</u></b></span>")
#@gui : Grain Type = choice(0,"A","B","C","D")
#@gui : Iterations = int(0,0,10)
#@gui : Blend Proportion = float(1,0,1)
#@gui : Interruption Flamboyance = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Smooth</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.65,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Color Variation = float(1,0.5,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Cartoon</u></b></span>")
#@gui : Smoothness = float(3,0,10)
#@gui : Sharpening = float(200,0,400)
#@gui : Edge threshold = float(20,1,30)
#@gui : Edge thickness = float(0.1,0,1)
#@gui : Color strength = float(1.5,0,3)
#@gui : Color quantization = int(8,2,256)
#@gui : Color Variation = float(1,0.5,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Blend GMIC</u></b></span>")
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : Reverse = bool(0)
#@gui : Sharpen = float(20,0,500)
#@gui : Noise = float(0,0,40)
#@gui : Spread X = float(0,0,20)
#@gui : Spread Y = float(0,0,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i>Lyle Kroll</i> and <i>samj</i>.      Latest update: <i>2016/12/06</i>.</small>")

samj_Flamboyance_Test:

repeat $! l[$>]

#partie1
 HS_Amplitude=$1
 HS_Density=$2
 Flou_HS=$3
 HS_Opacity=$4
 HS_Edge=$5
 HS_Fast_Approximation=$6
 Couleur_HS=$7
#partie2
 SB_Spatial_Variance=$8
 SB_Value_Variance=$9
 SB_Iterations=$10
#partie3
 Blend_Grain_Type=$11
 Iterations_Blend_Grain=$12
 Blend_Grain_Proportion=$13
 Interruption_Flamboyance=$14
#partie4
 S_Amplitude=$15
 S_Sharpness=$16
 S_Anisotropy=$17
 S_Gradient_smoothness=$18
 S_Tensor_smoothness=$19
 S_Spatial_precision=$20
 S_Angular_precision=$21
 S_Value_precision=$22
 S_Interpolation=$23
 S_Fast_approximation=$24
 S_Color_Variation=$25
#partie5
 C_Smoothness=$26
 C_Sharpening=$27
 C_Edge_threshold=$28
 C_Edge_thickness=$29
 C_Color_strength=$30
 C_Color_quantization=$31
 C_Color_Variation=$32
#partie6
 Blend_Mode=$33
 Blend_Opacity=$34
 Blend_Reverse=$35
 Sharpen_Origine=$36
 Bruit=$37
 Spread_X=$38
 Spread_Y=$39

 to_rgba[-1]
 spread[-1] $Spread_X,$Spread_Y,0
 if $Bruit>0 +Je_passe_l_hiver_en_Floride[-1] noise_hurl[-1] {$Bruit+1} blend[-1,-2] alpha endif
 sharpen[-1] $Sharpen_Origine
 +Je_passe_l_hiver_en_Floride[-1]
 #partie1
 blur[-1] $Flou_HS
 +hardsketchbw[-1] $HS_Amplitude,$HS_Density,$HS_Opacity,$HS_Edge,$HS_Fast_Approximation
 blend[-1,-2] hardlight
 to_rgb[-1]
 negate[-1]
 n[-1] 0,255
 to_graya[-1]
 mul[-1] $Couleur_HS
 c[-1] 0,255
 to_rgba[-1]
 #partie2
 repeat $SB_Iterations
  bilateral[-2] $SB_Spatial_Variance,$SB_Value_Variance
 done
 to_rgba[-2]
 #partie3
 if $Blend_Grain_Type==0
  +Je_passe_l_hiver_en_Floride[-1,-2]
  blend[-1,-2]  grainextract,$Blend_Grain_Proportion,1
  repeat $Iterations_Blend_Grain
   +Je_passe_l_hiver_en_Floride[-2]
   blend[-1,-2]  grainextract,$Blend_Grain_Proportion,1
  done
 elif $Blend_Grain_Type==1
  +Je_passe_l_hiver_en_Floride[-1,-2]
  blend[-1,-2]  grainextract,$Blend_Grain_Proportion,1
  repeat $Iterations_Blend_Grain
   +Je_passe_l_hiver_en_Floride[-2]
   blend[-1,-3]  grainextract,$Blend_Grain_Proportion,1
  done
 elif $Blend_Grain_Type==2
  +Je_passe_l_hiver_en_Floride[-1,-2]
  blend[-1,-2]  grainmerge,$Blend_Grain_Proportion,1
  repeat $Iterations_Blend_Grain
   +Je_passe_l_hiver_en_Floride[-2]
   blend[-1,-2]  grainmerge,$Blend_Grain_Proportion,1
  done
 elif $Blend_Grain_Type==3
  +Je_passe_l_hiver_en_Floride[-1,-2]
  blend[-1,-2]  grainmerge,$Blend_Grain_Proportion,1
  repeat $Iterations_Blend_Grain
   +Je_passe_l_hiver_en_Floride[-2]
   blend[-1,-3]  grainmerge,$Blend_Grain_Proportion,1
  done
 endif
 if $Interruption_Flamboyance==1
  rm[-2,-3]
 else
  rm[-2]
 #partie4
  smooth[-1] $S_Amplitude,$S_Sharpness,$S_Anisotropy,$S_Gradient_smoothness,$S_Tensor_smoothness,$S_Spatial_precision,$S_Angular_precision,$S_Value_precision,$S_Interpolation,$S_Fast_approximation
  mul[-1] $S_Color_Variation
  c[-1] 0,255
 #partie5
  cartoon[-1] $C_Smoothness,$C_Sharpening,$C_Edge_threshold,$C_Edge_thickness,$C_Color_strength,$C_Color_quantization
  mul[-1] $C_Color_Variation
 #partie6
  if $Blend_Reverse==0 rv[-1,-2] endif
  gimp_blend_1651[-2,-1] $Blend_Mode,2,$Blend_Opacity,0 # Average
 endif

endl done

samj_Flamboyance_Test_preview :
 gui_split_preview "samj_Flamboyance_Test $*",$-1

#################################################
##                                             ##
##           FIN samj_Flamboyance_Test         ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Couleurs_Rayees_2           ##
##                                             ##
#################################################

#@gui Couleurs Rayees 2  : samj_Couleurs_Rayees_2 , samj_Couleurs_Rayees_2 (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Lumin = bool(0)
#@gui : Pixélisation = int(30,8,100)
#@gui : Flou = float(0,0,10)
#@gui : PA = int(100,1,255)
#@gui : DeformA = int(4,-16,16)
#@gui : DeformB = int(4,-16,16)
#@gui : Limite = int(255,1,255)
#@gui : Itérations = int(1,1,4)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/07</i>.</small>")

samj_Couleurs_Rayees_2 :

 +Je_passe_l_hiver_en_Floride[-1]
 samj_Gris_Raye[-1] $1,$2,$3,$4,$5,$6,$7,$8
 blend[-1,-2] luminance

#################################################
##                                             ##
##          FIN samj_Couleurs_Rayees_2         ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Couleurs_Rayees             ##
##                                             ##
#################################################

# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
#@gui Couleurs Rayees  : samj_Couleurs_Rayees , samj_Couleurs_Rayees (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Lumin = bool(0)
#@gui : Pixélisation = int(30,8,100)
#@gui : Flou = float(0,0,10)
#@gui : PA = int(100,1,255)
#@gui : DeformA = int(4,-16,16)
#@gui : DeformB = int(4,-16,16)
#@gui : Couleur = int(0,0,255)
#@gui : Itérations = int(2,1,4)
#@gui : Puissance = float(0.7,0.1,2)
#@gui : Equalize = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Couleurs_Rayees :

Lumin=$1
Pixelisation=$2
Flou=$3
PA=$4
DeformA=$5
DeformB=$6
Couleur=$7
Iterations=$8
Puissance=$9
Egaliser=$10

 to_rgba[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 if $Lumin==1
  luminance[-1]
  n[-1] 0,255
  equalize[-1]
 endif
 to_rgb[-1]
 ditheredbw[-1]
 pixelize[-1] $Pixelisation
 blur[-1] $Flou
 ditheredbw[-1]
 to_rgba[-1]
 replace_color[-1] 0%,0,255,255,255,255,0,0,0,0  # blanc vers transparence
 replace_color[-1] 0%,0,0,0,0,255,$Couleur,$Couleur,$Couleur,255  # noir vers gris
 blend[-1,-2] alpha
 repeat $Iterations
  smooth[-1] $PA,0.2,1,$DeformA,$DeformB
 done
 pow[-1] $Puissance
 n[-1] 0,255
 if $Egaliser==1 equalize[-1] endif

#################################################
##                                             ##
##          FIN samj_Couleurs_Rayees           ##
##                                             ##
#################################################
#################################################
##                                             ##
##               samj_Gris_Raye                ##
##                                             ##
#################################################

#@gui Gris Raye  : samj_Gris_Raye , samj_Gris_Raye (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Lumin = bool(0)
#@gui : Pixélisation = int(30,8,100)
#@gui : Flou = float(0,0,10)
#@gui : PA = int(100,1,255)
#@gui : DeformA = int(4,-16,16)
#@gui : DeformB = int(4,-16,16)
#@gui : Limite = int(255,1,255)
#@gui : Itérations = int(1,1,4)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/29</i>.</small>")

samj_Gris_Raye :

Lumin=$1
Pixelisation=$2
Flou=$3
PA=$4
DeformA=$5
DeformB=$6
Limite=$7
Iterations=$8

 if $Lumin==1
  luminance[-1]
  n[-1] 0,255
  equalize[-1]
 endif
 to_rgb[-1]
 ditheredbw[-1]
 pixelize[-1] $Pixelisation
 blur[-1] $Flou
 ditheredbw[-1]
 repeat $Iterations
  smooth[-1] $PA,0.2,1,$DeformA,$DeformB
 done
 n[-1] 0,255
 c[-1] 0,$Limite
 n[-1] 0,255
 c[-1] {255-$Limite},255
 n[-1] 0,255

#################################################
##                                             ##
##             FIN samj_Gris_Raye              ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Contour_Epais              ##
##                                             ##
#################################################
# 2016/11/20 Validation Isophotes
# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
#@gui Contour epais  : samj_Contour_Epais , samj_Contour_Epais (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Edges</b></span>")
#@gui : Itérations = int(1,1,5)
#@gui : Flou/Blur = float(0,0,5)
#@gui : Edges % = float(5,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Isophotes</b></span>")
#@gui : Validation = bool(1)
#@gui : Isophotes = int(5,4,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Amplitude = float(5,0,100)
#@gui : Edge threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Rendu</b></span>")
#@gui : Épaisseur = int(2,0,10)
#@gui : Type Rendu = int(1,1,6)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Contour_Epais  :

Iterations=$1
Flou=$2
V_Edges=$3
Valider_Isophotes=$4
V_Isophotes=$5
V_Amplitude=$6
V_Edge_Threshold=$7
V_Smoothness=$8
Epaisseur=$9
Type_Rendu=$10

Largeur={w}
Hauteur={h}

 to_rgba[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 repeat $Iterations
  blur[-1] $Flou
  edges[-1] $V_Edges%
  n[-1] 0,255
  if $Valider_Isophotes==0
   to_rgba[-1]
   replace_color[-1] 0%,0,255,255,255,255,0,0,0,0 # blanc vers transparence
  endif
 done
 if $Valider_Isophotes==0
  to_rgba[-1]
  c[-1] 0,{$Epaisseur+1}
  Epaisseur={abs({$Epaisseur-2})}
 else
  isophotes $V_Isophotes
 endif
 n[-1] 0,255
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 shift[-1] 0,1,0,0,0
 shift[-2] 1,0,0,0,0
 shift[-3] 1,1,0,0,0
 crop[-1,-2,-3] 0,0,{$Largeur-1},{$Hauteur-1}
 blend[-1,-2,-3,-4] alpha
 blur[-1] 1
 sharpen[-1] 10
 if $Valider_Isophotes==0
  rv[-1,-2]
  blend[-1,-2] edges
  pixelize[-1] {$Largeur/4},{$Hauteur/4}

 else
  blend[-1,-2] edges
 endif
 repeat $Epaisseur
  +Je_passe_l_hiver_en_Floride[-1]
  +Je_passe_l_hiver_en_Floride[-1]
  +Je_passe_l_hiver_en_Floride[-1]
  if $Type_Rendu==1
   shift[-1] 0,1,0,0,0
   shift[-2] 1,0,0,0,0
   shift[-3] 1,1,0,0,0
  elif $Type_Rendu==2
   shift[-1] 0,1,0,0,0
   shift[-2] 1,1,0,0,0
   shift[-3] 1,0,0,0,0
  elif $Type_Rendu==3
   shift[-1] 1,0,0,0,0
   shift[-2] 0,1,0,0,0
   shift[-3] 1,1,0,0,0
  elif $Type_Rendu==4
   shift[-1] 1,0,0,0,0
   shift[-2] 1,1,0,0,0
   shift[-3] 0,1,0,0,0
  elif $Type_Rendu==5
   shift[-1] 1,1,0,0,0
   shift[-2] 1,0,0,0,0
   shift[-3] 0,1,0,0,0
  elif $Type_Rendu==6
   shift[-1] 1,1,0,0,0
   shift[-2] 0,1,0,0,0
   shift[-3] 1,0,0,0,0
  endif
  crop[-1,-2,-3] 0,0,{$Largeur-1},{$Hauteur-1}
  blend[-1,-2,-3,-4] alpha
 done
 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness

#################################################
##                                             ##
##           FIN samj_Contour_Epais            ##
##                                             ##
#################################################
#################################################
##                                             ##
##               samj_TensorTest               ##
##                                             ##
#################################################

#@gui Tensor Test : samj_TensorTest, samj_TensorTest(1)
#@gui :_=note("Tensor Test")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>diffusiontensors</b></span>")
#@gui : Sharpness = float(0.3,0,1)
#@gui : Anisotropy = float(0.9,0,1)
#@gui : Alpha = float(0.6,0,100)
#@gui : Sigma = float(1.1,0,100)
#@gui : Is_Sqrt = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>ABS</b></span>")
#@gui : Abs = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>resize2dx</b></span>")
#@gui : SizeX = int(20,8,64)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>display tensors</b></span>")
#@gui : Size Factor = int(32,16,128)
#@gui : Ellipse Size = float(20,0,100)
#@gui : Color Mode = choice{2,"Monochrome","Grayscale","Color"}
#@gui : Outline = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Couleur</b></span>")
#@gui : Couleur = float(0,0,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Resize</b></span>")
#@gui : Resize = choice{2,"Non RVBA","Oui RVB","Oui RVBA"}
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/01</i>.</small>")

samj_TensorTest :

DT_Sharpness=$1
DT_Anisotropy=$2
DT_Alpha=$3
DT_Sigma=$4
DT_Is_Sqrt=$5
Absolu=$6
SizeX=$7
Size_Factor=$8
Ellipse_Size=$9
Color_Mode=$10
Outline=$11
Couleur=$12
Type_Resize=$13

Largeur_Origine={w}
Hauteur_Origine={h}

 to_rgb[-1]
 diffusiontensors[-1] $DT_Sharpness,$DT_Anisotropy,$DT_Alpha,$DT_Sigma,$DT_Is_Sqrt
 if $Absolu==1
  abs
 endif
 resize2dx[-1] $SizeX
 display_tensors[-1] $Size_Factor,{$Ellipse_Size/10},$Color_Mode,$Outline
 if $Couleur>0
  pow[-1] $Couleur
 endif
 n[-1] 0,255
 if $Type_Resize==0
  to_rgba[-1]
 elif $Type_Resize==1
  to_rgb[-1]
  resize[-1] $Largeur_Origine,$Hauteur_Origine,5,3,3
 elif $Type_Resize==2
  to_rgba[-1]
  resize[-1] $Largeur_Origine,$Hauteur_Origine,5,4,3
 endif

#################################################
##                                             ##
##             FIN samj_TensorTest             ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Diff_Tensors_Blend          ##
##                                             ##
#################################################

#### 20161030 version origine test avec version 1.7.9pre

#@gui Diff Tensors Blend  : samj_Diff_Tensors_Blend, samj_Diff_Tensors_Blend(1)
#@gui :_=note("samj_Diff_Tensors_Blend")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Diffusion Tensors</b></span>")
#@gui : Résolution (%) = float(10,1,20)
#@gui : Size = float(5,0,16)
#@gui : Outline = int(1,0,16)
#@gui : Sharpness = float(0.15,0,1)
#@gui : Anisotropy = float(1,0,1)
#@gui : Gradient smoothness = float(0,0,10)
#@gui : Tensor smoothness = float(3,0,10)
#@gui : Itérations = int(1,1,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Flou-Blur</b></span>")
#@gui : Flou/Blur = int(0,0,50)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/10/30</i>.</small>")

samj_Diff_Tensors_Blend :

DT_Resolution=$1
DT_Size=$2
DT_Colormode=1
DT_Outline=$3
DT_Sharpness=$4
DT_Anisotropy=$5
DT_Gradientsmoothness=$6
DT_Tensorsmoothness=$7
Iterations=$8
Flou=$9
Mode_blend=$10
Opacity_blend=$11
 +Je_passe_l_hiver_en_Floride[-1]
 to_rgba[-1,-2]
 repeat $Iterations
  fx_diffusiontensors[-1] $DT_Resolution,$DT_Size,$DT_Colormode,$DT_Outline,$DT_Sharpness,$DT_Anisotropy,$DT_Gradientsmoothness,$DT_Tensorsmoothness
 done
 blur[-2] $Flou
 gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0 # Average
#################################################
##                                             ##
##          FIN samj_Diff_Tensors_Blend        ##
##                                             ##
#################################################


#################################################
##                                             ##
##         samj_Color_EdgesO_Engrave           ##
##                                             ##
#################################################

#### samj_Color_EdgesO_Engrave 0,50,9,1,2,50,0,8,40,0,0,1,0,0,1

#@gui Color Edges Engrave  : samj_Color_EdgesO_Engrave, samj_Color_EdgesO_Engrave(0)
#@gui :_=note("samj_Color_EdgesO_Engrave")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Edges offsets</b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(50,0,100)
#@gui : Scale = int(9,0,32)
#@gui : Thickness = int(1,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Engrave</b></span>")
#@gui : Radius = float(2,0,4)
#@gui : Density = float(50,0,200)
#@gui : Edges = float(0,0,10)
#@gui : Cohérence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal area = int(0,-256,256)
#@gui : Flat regions removal = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Variations</b></span>")
#@gui : Areas = float(1,0.8,1.2)
#@gui : Invert Areas = bool(0)
#@gui : Segment = int(0,0,15)
#@gui : Add = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/25</i>.</small>")

samj_Color_EdgesO_Engrave :
+Je_passe_l_hiver_en_Floride[-1]
+Je_passe_l_hiver_en_Floride[-1]
pow[-2]  $12
fx_edge_offsets[-2] $1,$2,$3,$4,0
fx_engrave[-1,-2] $5,$6,$7,$8,$9,$10,$11,0,10,1,0,0,0,1
blend[-1,-2] multiply,1,1
if $13==1 negate[-1] endif
if $14>0 fx_segment_watershed[-2] $14,1,16,0,0 endif
blend[-1,-2] multiply,1,1
if $15==1 +Je_passe_l_hiver_en_Floride[-1] blend[-1,-2] add,1,1 endif

#################################################
##                                             ##
##        FIN samj_Color_EdgesO_Engrave        ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Fond_Brosse               ##
##                                             ##
#################################################

#### samj_Fond_Brosse 3,1

#@gui Fond Brosse  : samj_Fond_Brosse, samj_Fond_Brosse(1)
#@gui :_=note("samj_Fond_Brosse")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Brosse</b></span>")
#@gui : Brosse = int(3,2,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Couleur</b></span>")
#@gui : Couleur = float(1,0.8,1.2)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/27</i>.</small>")

samj_Fond_Brosse :

Brosse=$1
Couleur=$2

repeat $Brosse
 fx_local_orientation[-1] 0,0,100,0,25,0
pow[-1]  $Couleur
done
fx_smooth_anisotropic[-1] 60,0.7,0.3,4,10,2,180,2,1,1,1,2,0
fx_normalize_local[-1] 2,6,5,20,1,11,0

#################################################
##                                             ##
##             FIN samj_Fond_Brosse            ##
##                                             ##
#################################################


#################################################
##                                             ##
##              samj_fond_broderie             ##
##                                             ##
#################################################

#### samj_fond_broderie 8,2,0,1,1
#### http://samjcreations.blogspot.ca/2016/01/filtre-fond-broderie-avec-gmic-gimp.html

#@gui Fond Broderie  : samj_fond_broderie, samj_fond_broderie(1)
#@gui :_=note("samj_fond_broderie")
#@gui :_=note("<span foreground="orangered"><small>topographic_map</small></span>")
#@gui : Levels = int(8,1,32)
#@gui : Smoothness = float(2,0,5)
#@gui :_=note("<span foreground="orangered"><small>gimp_skeleton</small></span>")
#@gui : Curviness = float(0,0,2)
#@gui :_=note("<span foreground="orangered"><small>fx_LCE</small></span>")
#@gui : Activer fx_LCE = bool(1)
#@gui :_=note("<span foreground="orangered"><small>gimp_frame_blur</small></span>")
#@gui : Activer gimp_frame_blur = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/19</i>.</small>")

samj_fond_broderie :

 Levels_topographic_map=$1
 Smoothness_topographic_map=$2
 Curviness_gimp_skeleton=$3
 Activer_fx_LCE=$4
 Activer_gimp_frame_blur=$5

 topographic_map[0] $Levels_topographic_map,$Smoothness_topographic_map
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]

 fx_local_orientation[-1] 0,0,100,0,0,0
 fx_color_abstraction[-1] 2,10,0.5,0
 fx_skeleton[-1] 0,$3,0,0,0

 fx_skeleton[-2] 0,$3,0,0,0

 blend[-2,-1] add,1,0
 blend[-2,-1] and,1,0

 if $Activer_fx_LCE==1
  fx_LCE[-1] 80,0.5,1,1,3,0
 endif

 if $Activer_gimp_frame_blur==1
  fx_frame_blur[-1] 30,30,0,5,0,0,128,128,128,0,5,255,255,255,2,2,1,0,0.5,0.5,0
 endif

#################################################
##                                             ##
##            FIN samj_fond_broderie           ##
##                                             ##
#################################################


#################################################
##                                             ##
##              samj_texture_coloree           ##
##                                             ##
#################################################

# 2015/04/05 Pâques 2015 origine à partir de samj_test_E

#@gui Texture Coloree  : samj_texture_coloree, samj_texture_coloree(1)
#@gui :_=note("samj_texture_coloree")
#@gui :_=note("<span foreground="orangered"><small>diffusiontensors</small></span>")
#@gui : Type = choice{"A","B","C","D","E","F"}
#@gui : Sharpness = float(0.7,0.2,2)
#@gui :_=note("<span foreground="orangered"><small>Color</small></span>")
#@gui : Fond / Background Color = color(200,125,50)
#@gui :_=note("<span foreground="orangered"><small>Blur Linear</small></span>")
#@gui : Amplitude A = float(5,0,10)
#@gui : Amplitude B = float(5,0,100)
#@gui : Angle = float(45,0,360)
#@gui :_=note("<span foreground="orangered"><small>Sharpen</small></span>")
#@gui : Amplitude S = int(200,50,1000)
#@gui :_=note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Itérations = int(4,1,8)
#@gui : Opacité / Opacity = float(0.2,0,0.3)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/04/05</i>.</small>")

samj_texture_coloree :

 Type=$1
 sharpness=$2
 rf=$3
 vf=$4
 bf=$5
 AmplitudeA=$6
 AmplitudeB=$7
 Angle=$8
 AmplitudeS=$9
 Iterations_Blend=$10
 Opacite_Blend=$11

 if $Type==0
  anisotropy=0
  alpha=0
  sigma=0
  is_sqrt=1
 elif $Type==1
  anisotropy=0
  alpha=4
  sigma=0
  is_sqrt=1
 elif $Type==2
  sharpness=0.5
  anisotropy=0.3
  alpha=4
  sigma=2
  is_sqrt=1
 elif $Type==3
  anisotropy=0
  alpha=0
  sigma=0
  is_sqrt=0
 elif $Type==4
  anisotropy=0
  alpha=4
  sigma=0
  is_sqrt=0
 elif $Type==5
  sharpness=0.5
  anisotropy=0.3
  alpha=4
  sigma=2
  is_sqrt=0
 endif

 diffusiontensors[-1] $sharpness,$anisotropy,$alpha,$sigma,$is_sqrt
 n[-1] 0,255
 equalize[-1]
 fx_decompose_channels[-1] 4,0,1,0
 remove[-1,-2]
 to_rgb[-1]
 fx_8bits[-1] 100,10000,256
 {w},{h},1,3
 fill_color[-1] $rf,$vf,$bf
 blend[-1,-2] add
 to_rgb[-1]
 repeat $Iterations_Blend
  +Je_passe_l_hiver_en_Floride[-1]
 done
 blur_linear[-1] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},$Angle,1
 sharpen[-1] $AmplitudeS
 to_rgb[-1]
 repeat $Iterations_Blend
  fx_blend_edges[-1,-2] $Opacite_Blend,5,0
 done
#################################################
##                                             ##
##           FIN samj_texture_coloree          ##
##                                             ##
#################################################
################################################################
##                                                            ##
##                      samj_Impressions                      ##
##                                                            ##
################################################################

# Pour créer des impressions plus ou moins abstraites à partir de samj_Angoisse
# 2015/04/02 origine

#@gui Impressions : samj_Impressions, samj_Impressions(1)
#@gui :_=note("<span foreground="orangered"><small>Spread</small></span>")
#@gui : Spread = float(10,0,50)
#@gui :_=note("<span foreground="orangered"><small>Textured Glass</small></span>")
#@gui : X-amplitude = float(5,0,400)
#@gui : Y-amplitude = float(5,0,400)
#@gui : X-smoothness = float(1,0,5)
#@gui : Y-smoothness = float(1,0,5)
#@gui : Edge Atténuation = float(0,0,1)
#@gui : Edge influence = float(2,0,10)
#@gui : Noise scale = int(0,0,16)
#@gui :_=note("<span foreground="orangered"><small>Abstraction</small></span>")
#@gui : Itérations = int(1,1,3)
#@gui :_=note("<span foreground="orangered"><small>Abstraction Dog</small></span>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui :_=note("<span foreground="orangered"><small>Abstraction Segment Watershed</small></span>")
#@gui : Threshold = float(5,0,10)
#@gui :_=note("<span foreground="orangered"><small>Abstraction Smooth</small></span>")
#@gui : Amplitude = float(100,0,200)
#@gui :_=note("<span foreground="orangered"><small>Abstraction Noise</small></span>")
#@gui : Amplitude = float(2,0,10)
#@gui : Type = choice(4,"Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui :_=note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=note("<span foreground="orangered"><small>Sharpen</small></span>")
#@gui : Amplitude = int(250,0,500)
#@gui :_=note("<span foreground="orangered"><small>Couleurs</small></span>")
#@gui : Couleurs = float(1.2,0.1,5)
#@gui :_=separator()
#@gui :_=note("<small>samj      Dernière mise à jour : <i>2016/01/19</i>.</small>")

samj_Impressions :
 Spread_fond=$1
 X_amplitude=$2
 Y_amplitude=$3
 X_smoothness=$4
 Y_smoothness=$5
 Edge_attenuation=$6
 Edge_influence=$7
 Noise_scale=$8
 iterations=$9
 dog_sigma1=$10
 dog_sigma2={$11/10}
 sw_threshold=$12
 smooth_amplitude=$13
 noise_amplitude=$14
 noise_type=$15
 opacite=$16
 sharpen_amplitude=$17
 Couleurs=$18

 spread[-1] $Spread_fond
 fx_textured_glass[-1] $X_amplitude,$Y_amplitude,$X_smoothness,$Y_smoothness,$Edge_attenuation,$Edge_influence,$Noise_scale
 to_rgb[-1]
 +Je_passe_l_hiver_en_Floride[-1]

 repeat $iterations
  dog[-1] $dog_sigma1%,$dog_sigma2%
  segment_watershed[-1] $sw_threshold,1
  smooth[-1] $smooth_amplitude,0,1,1,3
  n[-1] 0,255
  if $noise_amplitude>0 noise[-1] $noise_amplitude,$noise_type endif
  to_rgb[-1]
  fx_decompose_channels[-1] 4,0,1,0
  remove[-1,-2]
 done

 to_rgb[-1]
 gimp_blend_1651[-1,-2] 28,0,$opacite,0,1
 if $sharpen_amplitude>0 sharpen[-1] $sharpen_amplitude endif
 fx_custom_transform[-1] "i",i*$Couleurs,"i","i","i","i",0

################################################################
##                                                            ##
##                    FIN  samj_Impressions                   ##
##                                                            ##
################################################################
################################################################
##                                                            ##
##                samj_Barbouillage_Paint_Daub                ##
##                                                            ##
################################################################

# Pour créer des barbouillages
# 2015/04/01 origine
# 2015/04/16 ajout Plasma (Aléatoire)
# 2015/04/17 ajout Plasma "Couleurs A" et "Couleurs B"

#@gui Barbouillage Paint Daub : samj_Barbouillage_Paint_Daub, samj_Barbouillage_Paint_Daub(0)
#@gui :_=note("<span foreground="blue">Barbouillage / Paint Daub</span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Gradient Norm</small></span>")
#@gui : Itérations = int(2,1,3)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Smooth</small></span>")
#@gui : Amplitude = int(2,1,5)
#@gui : Sharpness = int(100,0,500)
#@gui : Anisotropy = float(0.2,0,0.5)
#@gui : Sigma = float(1,0,10)
#@gui : dl = float(4,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Equalize</small></span>")
#@gui : Equalize = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Plasma Aléatoire / Random Plasma</small></span>")
#@gui : Plasma = choice(0,"Non / Without","Couleurs A","Couleurs B")
#@gui : Scale Plasma = int(8,1,30)
#@gui :_=separator()
#@gui :_=note("<small>samj      Dernière mise à jour : <i>2015/04/17</i>.</small>")

samj_Barbouillage_Paint_Daub :

 iterations=$1
 amplitude=$2
 sharpness=$3
 anisotropy=$4
 sigma=$5
 dl=$6
 egaliser=$7
 Couleurs_Plasma=$8
 Scale_Plasma=$9
 to_rgb[-1]

 if $Couleurs_Plasma>0
  {w},{h},1,3
  fill_color[-1] 0,0,0
  plasma[-1] 1,1,$Scale_Plasma
  n[-1] 0,255
  if $Couleurs_Plasma==1
   fx_decompose_channels[-1,-2] 2,0,1,0 remove[-2,-3,-4] fx_decompose_channels 2,1,1,0
  elif $Couleurs_Plasma==2
   fx_decompose_channels[-1,-2] 2,0,1,0 remove[-1,-5,-6] fx_decompose_channels[-3,-2,-1] 2,1,1,0
  endif
  n[-1] 0,255
  to_rgb[-1]
 endif

 +Je_passe_l_hiver_en_Floride[-1]

 repeat $iterations
  gradient_norm[-1]
  n[-1] 0,255
  equalize[-1]
 done

 engrave_modifie[-1] 4,0.5,4,0,8,40,0,25,1
 blend[-1,-2] add
 repeat $amplitude
  smooth[-1] $sharpness,$anisotropy,1,$sigma,$dl
 done
 n[-1] 0,255
 if $egaliser==1 equalize[-1] endif

################################################################
##                                                            ##
##              FIN  samj_Barbouillage_Paint_Daub             ##
##                                                            ##
################################################################
################################################################
##                                                            ##
##                        samj_Angoisse                       ##
##                                                            ##
################################################################

# Pour créer des couleurs angoissantes
# 2015/03/27 origine

#@gui Angoisse Anguish : samj_Angoisse, samj_Angoisse(1)
#@gui :_=separator()
#@gui :_=note("<small>Itérations</small>")
#@gui : Itérations = int(1,1,3)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre dog</small>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre segment_watershed</small>")
#@gui : Threshold = float(5,0,10)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre smooth</small>")
#@gui : Amplitude = float(100,0,200)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre noise</small>")
#@gui : Amplitude = float(2,0,10)
#@gui : Type = choice(4,"Gaussian","Uniform","Salt and pepper","Poisson","Rice")
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre blend</small>")
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre sharpen</small>")
#@gui : Amplitude = int(250,0,500)
#@gui :_=separator()
#@gui :_=note("<small>samj      Dernière mise à jour : <i>2016/01/19</i>.</small>")

samj_Angoisse :

 iterations=$1
 dog_sigma1=$2
 dog_sigma2={$3/10}
 sw_threshold=$4
 smooth_amplitude=$5
 noise_amplitude=$6
 noise_type=$7
 opacite=$8
 sharpen_amplitude=$9

 to_rgb[-1]
 +Je_passe_l_hiver_en_Floride[-1]

 repeat $iterations
  dog[-1] $dog_sigma1%,$dog_sigma2%
  segment_watershed[-1] $sw_threshold,1
  smooth[-1] $smooth_amplitude,0,1,1,3
  n[-1] 0,255
  if $noise_amplitude>0 noise[-1] $noise_amplitude,$noise_type endif
  to_rgb[-1]
  fx_decompose_channels[-1] 4,0,1,0
  remove[-1,-2]
 done

 to_rgb[-1]
 gimp_blend_1651[-1,-2] 28,0,$opacite,0,1
 if $sharpen_amplitude>0 sharpen[-1] $sharpen_amplitude endif

################################################################
##                                                            ##
##                      FIN  samj_Angoisse                    ##
##                                                            ##
################################################################
################################################################
##                                                            ##
##                Début ensemble Chalk it up                  ##
##                                                            ##
################################################################

#********** Chalk it up **********
##  forum   :     http://www.flickr.com/groups/gmic/discuss/72157631155481890/
##                http://www.gimpchat.com/viewtopic.php?f=9&t=4982
##  Version 1.00  19 août 2012 Merci à David pour la transposition au format G'MIC pour Gimp et l'aide :o)
##  Version 1.1   20 août 2012 modification pour calques avec canal alpha par ajout de remove_opacity ajout du traitement par canaux pour gimp_morpho & gimp_spread
##  Version 1.2   16 octobre 2012 modifications paramètres gimp_morpho + choix RGB
##  Version 1.3   3 mars 2015 fx_painting ajout 4e paramètre et paramètrage Canaux / Channel(s) gimp_morpho Canaux / Channel(s) gimp_spread
##  Version 1.4   31 mars 2015 canaux gimp_morpho gimp_spread valeur par défaut : Linear RGB [all]

#@gui Chalk It Up [Fr] : samj_chalkitup, samj_chalkitup_preview
#@gui :_=note("Inspiré du didacticiel proposé par Lylejk")
#@gui :_=note("Inspired by the tutorial proposed by Lylejk")
#@gui :_=link("http://justpaste.it/chalk_it_up","http://justpaste.it/chalk_it_up")
#@gui :_=separator()
#@gui :_=note("<small>Paramètres peinturage / Painting parameters</small>")
#@gui : Abstraction = int(5,0,10)
#@gui : Précision Détails / Details scale = float(2.5,0,10)
#@gui : Couleur / Color = float(1.5,0,5)
#@gui : Douceur / Smoothness = float(50,0,200)
#@gui : Accentuation nuances / Sharpen shades = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres filtre Morpho / Morpho parameters</small>")
#@gui : Action = choice(5,"Erosion","Dilation","Opening","Closing","Original - Erosion","Dilation - Original","Original - Opening","Closing - Original")
#@gui : Taille / Size = int(5,0,32)
#@gui : Inversion Couleurs / Invert colors = bool(0)
#@gui : Modeler / Shape = bool(0)
#@gui : Canaux / Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui :_=separator()
#@gui :_=note("<small>Paramètres filtre Spread / Spread parameters</small>")
#@gui : X-variations = float(0.8,-5,5)
#@gui : Y-variations = float(1.9,-5,5)
#@gui : Canaux / Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui : sep = separator(), Type Aperçu = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui :_=separator()
#@gui :_=note("<small>Auteurs / Authors : <i>Lylejk/samj/Ronounours</i>.      Dernière mise à jour : <i>2015/03/31</i>.</small>")

samj_chalkitup :

####### Déclaration des variables

 #gimp_painting
 Abstraction=$1
 Details_scale=$2
 Color=$3
 Smoothness=$4
 Sharpen_shades=$5

 #gimp_morpho
 Action=$6
 Size=$7
 Invert_colors=$8
 Shape=$9
 Channel_morpho=$10

 #gimp_spread
 X_variations=$11
 Y_variations=$12
 Channel_spread=$13

####### Ligne de commandes

 repeat $! l[$>]
  remove_opacity[-1]
  fx_painting[-1] $Abstraction,$Details_scale,$Color,$Smoothness,$Sharpen_shades
  ancien_gimp_morpho[-1] $Action,$Size,$Invert_colors,$Shape,$Channel_morpho,0
  fx_spread[-1] $X_variations,$Y_variations,$Channel_spread,0
 endl done

samj_chalkitup_preview :
 gui_split_preview "samj_chalkitup ${1--2}",$-1
################################################################
##                                                            ##
##            FIN  Début ensemble Chalk it up                 ##
##                                                            ##
################################################################


#################################################
##                                             ##
##             Texture Granuleuse              ##
##                                             ##
#################################################

# 2020/10/20 Correction
# 2015/03/31 changement parametre canaux sur fx_local_orientation
# 2015/03/07 Ancien filtre samj_gimp_texture_zero_zero_un , Granular Texture / Texture Granuleuse remplace samj_gimp_texture_zero_zero_un , Je_passe_l_hiver_en_Floride remplace gimp_do_nothing
# 2014/04/24 blend

#@gui Granular Texture  : samj_Texture_Granuleuse, samj_Texture_Granuleuse_preview(0)
#@gui :_=note("<small>Texture Granuleuse / Granular Texture</small>")
#@gui : sep = separator()
#@gui : Douceur / Smoothness Gradient RGB = float(0,0.5,2)
#@gui : Maximum Seuil Dégradé / Max threshold Gradient RGB = float(20,10,50)
#@gui : sep = separator()
#@gui : Amplitude Bruit / Noise = float(80.0,40,200)
#@gui : sep = separator()
#@gui : Couleurs / Colors = float(0,-20,20)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/31</i>.</small>")
samj_Texture_Granuleuse :

repeat $! l[$>]

 Smoothness_Gradient_RGB=$1
 Max_threshold_Gradient_RGB=$2
 Amplitude_Noise=$3
 Colors=$4
 Automatic_color_balance=$5

 +Je_passe_l_hiver_en_Floride[-1]
 fx_gradient2rgb[-1] $Smoothness_Gradient_RGB,0,$Max_threshold_Gradient_RGB,0,0
 {w},{h},1,3
 fill_color[-1] 255,255,255
 to_rgb[-1]
 fx_noise[-1] $Amplitude_Noise,0,2,0
 blend[-1,-2] negation,1,1
 ancien_Tom_Keil_Colortemp[-1] $Colors,$Automatic_color_balance
 fx_local_orientation[-1] 0,0,100,0,11

 fx_normalize_local[-1] 0,6,5,20,1,2
 blend[0,-1] grainmerge,1,1

endl done

samj_Texture_Granuleuse_preview :
 gui_split_preview "samj_Texture_Granuleuse $*",$-1
#################################################
##                                             ##
##           FIN Texture Granuleuse            ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Edges_And_LIC             ##
##                                             ##
#################################################

#@gui Edges And LIC : samj_Edges_And_LIC, samj_Edges_And_LIC(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Edges_And_LIC</span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background [Step 1]</b></span>")
#@gui : Rendering = choice(0,"A","B","C")
#@gui : Lic = int(200,10,1000)
#@gui : Dilate = int(0,0,2)
#@gui : Sharpen = int(0,0,5000)
#@gui : Blur = float(0,0,5)
#@gui : sep = separator()
#@gui : Edges % = float(15,0,100)
#@gui : Pow = float(8,0.2,8)
#@gui : N min = int(127,0,255)
#@gui : N max = int(255,0,255)
#@gui : Gray = choice(0,"A","B","C","D","E","F","G")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Abstraction [Optional Step 2]</b></span>")
#@gui : Abstraction = bool(0)
#@gui : Smoothness = float(1,0,10)
#@gui : Levels = int(20,2,100)
#@gui : Contrast = float(0.2,0.01,1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend [Optional Step 3]</b></span>")
#@gui : Blend = bool(0)
#@gui : Mode = choice{14,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape area max","Shape area max0","Shape area min","Shape area min0","Shape average","Shape average0","Shape min","Shape min0","Shape max","Shape max0",
#@gui : "Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value","Vivid light","Xor"}
#@gui : Reverse = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2017/01/09</i>.</small>")

samj_Edges_And_LIC :

Rendu=$1
Val_Lic=$2
Val_Dilate_Circ=$3
Val_Sharpen=$4
Val_Blur=$5
Val_Edges=$6
Val_Pow=$7
N_min=$8
N_max=$9
Gray=$10
Valider_Abstraction=$11
Smoothness_Abstraction=$12
Levels_Abstraction=$13
Contrast_Abstraction=$14
Valider_Blend=$15
mode=${arg\ 1+$16,add,alpha,and,average,blue,burn,darken,difference,\
   divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
   hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
   multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
   shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
   shapeaverage,shapeaverage0,shapemin,shapemin0,shapemax,shapemax0,\
   softburn,softdodge,softlight,screen,stamp,subtract,value,\
   vividlight,xor}
Inverser_Blend=$17

to_rgb[-1]
samj_Wavelet_Sharpen_Test_en[-1] 1,0
if $Valider_Blend==1
 +Je_passe_l_hiver_en_Floride[-1]
endif

+Je_passe_l_hiver_en_Floride[-1]
edges[-1] $Val_Edges%
pow[-1] $Val_Pow
n[-1] $N_min,$N_max
rv[-1,-2]

if $Rendu==0
 lic[-1] $Val_Lic,3
 if $Val_Dilate_Circ>0 dilate_circ[-1] {$Val_Dilate_Circ+1} endif
 if $Val_Sharpen>0 sharpen[-1] $Val_Sharpen endif
 if $Val_Blur>0 blur[-1] $Val_Blur endif
endif

if $Rendu==1
 mirror[-1] x
 lic[-1] $Val_Lic,3
 if $Val_Dilate_Circ>0 dilate_circ[-1] {$Val_Dilate_Circ+1} endif
 if $Val_Sharpen>0 sharpen[-1] $Val_Sharpen endif
 if $Val_Blur>0 blur[-1] $Val_Blur endif
 mirror[-1] x
endif

if $Rendu==2
 +Je_passe_l_hiver_en_Floride[-1]
 lic[-1] $Val_Lic,3
 if $Val_Dilate_Circ>0 dilate_circ[-1] {$Val_Dilate_Circ+1} endif
 if $Val_Sharpen>0 sharpen[-1] $Val_Sharpen endif
 if $Val_Blur>0 blur[-1] $Val_Blur endif
 rv[-1,-2]
 mirror[-1] x
 lic[-1] $Val_Lic,3
 if $Val_Dilate_Circ>0 dilate_circ[-1] {$Val_Dilate_Circ+1} endif
 if $Val_Sharpen>0 sharpen[-1] $Val_Sharpen endif
 if $Val_Blur>0 blur[-1] $Val_Blur endif
 mirror[-1] x
 blend[-1,-2] average
endif

if $Gray==0
 fx_decompose_channels[-1] 7,0,1,0
 remove[-1,-2]
elif $Gray==1
 fx_decompose_channels[-1] 2,0,1,0
 remove[-3,-2]
elif $Gray==2
 fx_decompose_channels[-1] 7,0,1,0
 remove[-3,-2]
elif $Gray==3
 fx_decompose_channels[-1] 2,0,1,0
 remove[-3,-1]
elif $Gray==4
 fx_decompose_channels[-1] 7,0,1,0
 remove[-1,-3]
elif $Gray==5
 fx_decompose_channels[-1] 2,0,1,0
 remove[-1,-2]
elif $Gray==6
 to_gray[-1]
endif

n[-1] 0,255
to_rgb[-1]
blend[-1,-2] average
n[-1] 0,255

if $Valider_Abstraction==1
 fx_color_abstraction[-1] $Smoothness_Abstraction,$Levels_Abstraction,$Contrast_Abstraction
endif

if $Valider_Blend==1
 if $Inverser_Blend==1 rv[-1,-2] endif
 blend[-1,-2] $mode
endif

#################################################
##                                             ##
##            FIN samj_Edges_And_LIC           ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Test_Skeletik              ##
##                                             ##
#################################################

# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
# utilisation de l'ancienne version de 'skeleton' => 'Ancien_skeleton'
#@gui Skeletik : samj_Test_Skeletik, samj_Test_Skeletik(0)
#@gui :_=note("samj_Test_Skeletik")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Lines - Cobweb</b></span>")
#@gui : Itérations = int(10,1,50)
#@gui : Skeleton = int(1,1,20)
#@gui : Deform = float(0,0,200)
#@gui : Dilate = int(0,0,16)
#@gui : Spread = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape area max","Shape area max0","Shape area min","Shape area min0","Shape average","Shape average0","Shape min","Shape min0","Shape max","Shape max0",
#@gui : "Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value","Vivid light","Xor"}
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Colors</b></span>")
#@gui : Lines = float(1,0.75,1.25)
#@gui : Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2019/12/14</i>.</small>")

samj_Test_Skeletik:

Iterations=$1
Val_Skeleton=$2
Deformation=$3
Dilate_Contours=$4
Degradation_Spread=$5
mode=${arg\ 1+$6,add,alpha,and,average,blue,burn,darken,difference,\
   divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
   hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
   multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
   shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
   shapeaverage,shapeaverage0,shapemin,shapemin0,shapemax,shapemax0,\
   softburn,softdodge,softlight,screen,stamp,subtract,value,\
   vividlight,xor}
Couleur=$7
R_a=$8
V_a=$9
B_a=$10
A_a=$11

Nb_Boucles=0
 +Je_passe_l_hiver_en_Floride[-1]
 if $Deformation>0 samj_Random_Small_Deformations[-1] $Deformation,5,3 endif
 to_rgb[-1]
 repeat $Iterations
  Ancien_skeleton[-1] {$Val_Skeleton+$Nb_Boucles}
  n[-1] 0,255
  to_rgba[-1]
  replace_color[-1] 0%,0,0,0,0,255,0,0,0,0 # noir vers transparent
  if $Nb_Boucles>0 blend[-1,-2] alpha endif
  Nb_Boucles={$Nb_Boucles+1}
  +Je_passe_l_hiver_en_Floride[-2]
 done
 rm[-1]
 if $Degradation_Spread>1 spread[-1] $Degradation_Spread endif
 if $Dilate_Contours>1 dilate_circ[-1] $Dilate_Contours endif
 to_graya[-1]
 rv[-1,-2]
 blend[-1,-2] $mode
 mul[-1] $Couleur
 {w},{h},1,4
 fill_color[-1] $R_a,$V_a,$B_a,$A_a
 rv[-1,-2]
 blend[-1,-2] alpha
#@gmic Ancien_skeleton : _smoothness[%]>=0
#@gmic : Compute skeleton of binary shapes using distance transform.
#@gmic : Default value: 'smoothness=0'.
#@gmic : $ image.jpg threshold 50% +Ancien_skeleton 0
Ancien_skeleton : check ${1=0}>=0
  e[^-1] "Compute skeleton of binary image$?."
  ->= 50% distance 0 b $1 sharpen 1e10 ->= 100%
  repeat $! +erode[$>] 2 --[$>,-1] done

#################################################
##                                             ##
##           FIN samj_Test_Skeletik            ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Plasmic_V2                ##
##                                             ##
#################################################
# ajout Valeur_Plasma=0 , Valeur_Plasma<0 , Deformation<0
#@gui Plasmic V2  : samj_Plasmic_V2, samj_Plasmic_V2(0)
#@gui :_=note("samj_Plasmic_V2")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Plasmic = int(2,-20,20)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Lines</b></span>")
#@gui : Thickness = int(4,1,32)
#@gui : Accuracy = int(10,1,32)
#@gui : Coeff. Accuracy = float(2,0.1,8)
#@gui : Coeff. Blur = float(0.02,0,1)
#@gui : Isophotes = int(8,2,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradation Deform</b></span>")
#@gui : Deform = float(0,-200,200)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate Contours = int(0,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradation Spread</b></span>")
#@gui : Spread = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Plasmic_V2 :

 Valeur_Plasma=$1
 Epaisseur=$2
 Precision=$3
 Coeff_Precision_Pixelise=$4
 Coeff_Precision_Flou=$5
 Nb_Isophotes=$6
 Deformation=$7
 Dilate_Contours=$8
 Degradation_Spread=$9
 R_a=$10
 V_a=$11
 B_a=$12
 A_a=$13

 Largeur_Origine={w}
 Hauteur_Origine={h}
 Nb_Boucles=0

 to_rgba[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 repeat $Epaisseur
  pixelize[-1] {1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)},{1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)}
  blur[-1]  {{$Precision+$Epaisseur+$Nb_Boucles}*$Coeff_Precision_Flou}
  isophotes[-1] $Nb_Isophotes
  if $Nb_Boucles>0 blend[-1,-2] alpha endif
  Nb_Boucles={$Nb_Boucles+1}
  +Je_passe_l_hiver_en_Floride[-2]
 done
 rm[-1,-3]
 if {abs($Valeur_Plasma)}>0
  $Largeur_Origine,$Hauteur_Origine,1,3
  plasma[-1] {abs($Valeur_Plasma)},{abs($Valeur_Plasma)}
  n[-1] 0,255
 else
  +Je_passe_l_hiver_en_Floride[-1]
 endif
 rv[-1,-2]
 if $Deformation>0 samj_Random_Small_Deformations[-1,-2] $Deformation,5,3 endif
 if $Dilate_Contours>1 dilate_circ[-1,-2] $Dilate_Contours endif
 if $Degradation_Spread>1 spread[-1,-2] $Degradation_Spread endif
 if $Deformation<0 samj_Random_Small_Deformations[-1,-2] {abs($Deformation)/10},5,3 endif
 if $Valeur_Plasma<0
  samj_Texture_Granuleuse[-1,-2] 0.5,20,80,0,0
 endif
 rv[-1,-2]
 blend[-2,-1] alpha
 {w},{h},1,4
 fill_color[-1] $R_a,$V_a,$B_a,$A_a
 rv[-1,-2]
 blend[-1,-2] alpha

#################################################
##                                             ##
##             FIN samj_Plasmic_V2             ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Contour_Drawings_en           ##
##                                             ##
#################################################
# ajouts Smoothness et Autoindex
#@gui Contour Drawings  : samj_Contour_Drawings_en , samj_Contour_Drawings_en (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contour</b></span>")
#@gui : Isophotes = int(5,3,16)
#@gui : Smoothness = float(0,0,5)
#@gui : Dilate = int(2,0,5)
#@gui : Color Autoindex = int(0,0,64)
#@gui : To Gray = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Amplitude = float(5,0,100)
#@gui : Edge threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Background = bool(0)
#@gui : Color = float(1.1,0,1.2)
#@gui : Variation = int(10,2,200)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Chalk</b></span>")
#@gui : Chalk = bool(0)
#@gui : Spread = float(1,0,4)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2016/11/18</i>.</small>")

samj_Contour_Drawings_en  :

V_Isophotes=$1
Flou=$2
V_Dilate=$3
V_Color_Autoindex=$4
V_To_Gray=$5
V_Amplitude=$6
V_Edge_Threshold=$7
V_Smoothness=$8
BG=$9
BG_Color=$10
BG_Variation=$11
Chalk=$12
V_Spread=$13

Largeur={w}
Hauteur={h}

 to_rgba[-1]
 if $BG==1
  +Je_passe_l_hiver_en_Floride[-1]
 endif
 blur[-1] $Flou
 isophotes[-1] $V_Isophotes
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 shift[-1] 1,1,0,0,0
 shift[-2] 0,1,0,0,0
 shift[-3] 1,0,0,0,0
 crop[-1,-2,-3] 0,0,{$Largeur-1},{$Hauteur-1}
 blend[-1,-2,-3,-4] alpha
 dilate[-1] $V_Dilate
 if $V_Color_Autoindex>0
  autoindex[-1] {$V_Color_Autoindex+1},1,1
  to_rgba[-1]
 endif
 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness
 if $V_To_Gray==1
  to_graya[-1]
  n[-1] 64,255
  to_rgba[-1]
 endif
 if $Chalk==1
  spread[-1] $V_Spread
  BG_Color=0
 endif
 if $BG==1
  if $BG_Color<1
   to_gray[-2]
  endif
  blur[-2] {{{w}+{h}}/$BG_Variation}
  pow[-2] $BG_Color
  blend[-1,-2] alpha
 endif

#################################################
##                                             ##
##        FIN samj_Contour_Drawings_en         ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_texture_coloree_en          ##
##                                             ##
#################################################

# 2015/04/13 ajout Richardson Lucy pour la version en anglais

#@gui Variations on a Single Color : samj_texture_coloree_en, samj_texture_coloree_en(1)
#@gui :_=note("Variations On A Single Color")
#@gui :_=note("<span foreground="orangered"><small>Diffusion Tensors</small></span>")
#@gui : Type = choice{"A","B","C","D","E","F"}
#@gui : Sharpness = float(0.7,0.2,1)
#@gui :_=note("<span foreground="orangered"><small>Color</small></span>")
#@gui : Single Color = color(200,125,50)
#@gui :_=note("<span foreground="orangered"><small>Blur Linear</small></span>")
#@gui : Amplitude A = float(5,0,10)
#@gui : Amplitude B = float(5,0,100)
#@gui : Angle = float(45,0,360)
#@gui :_=note("<span foreground="orangered"><small>Sharpen</small></span>")
#@gui : Amplitude S = int(200,50,1000)
#@gui :_=note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Iterations = int(4,1,8)
#@gui : Opacity = float(0.2,0,0.3)
#@gui :_=note("<span foreground="orangered"><small>Richardson Lucy</small></span>")
#@gui : Sigma = float(1,0.5,10)
#@gui : Iterations = int(10,0,100)
#@gui : Blur = choice(1,"Exponential","Gaussian")
#@gui : Cut = bool(true)

#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2015/04/13</i>.</small>")

samj_texture_coloree_en :

 samj_texture_coloree $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11
 if $13>0 # Iterations
  deblur_richardsonlucy[-1] $12,$13,$14
  if $15 c[-1] 0,255 else n[-1] 0,255 endif
 endif

#################################################
##                                             ##
##         FIN samj_texture_coloree_en         ##
##                                             ##
#################################################

#################################################################################################################################################################################################
#
#                                                                                                                                                                                   BLACK & WHITE
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_black_and_white :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Black & White</b>
#################################################
##                                             ##
##             samj_Grid_BW_Color              ##
##                                             ##
#################################################

#@gui Grid BW Color : samj_Grid_BW_Color, samj_Grid_BW_Color
#@gui :_=link("https://samjcreations.blogspot.com/2020/12/samuser-avec-gmic-gimp-filtre-grid-bw.html","https://samjcreations.blogspot.com/2020/12/samuser-avec-gmic-gimp-filtre-grid-bw.html")
#@gui : 1 Flou/Blur = float(3,0,10)
#@gui : 2 - Adoucir/Smooth = int(0,0,5000)
#@gui :_=note("<span foreground="orangered"><b>Grille/Grid</b></span>")
#@gui : 3 - Grille/Grid = choice(1,"Non/No","Rectangle","Triangle","Hexagone Paramètre 4","Rectangle Sans Contour","Triangle Sans Contour","Hexagone Sans Contour Paramètre 4")
#@gui : 4 - X Grille/Grid = int(4,2,64)
#@gui : 5 - Y Grille/Grid = int(4,2,64)
#@gui :_=note("<span foreground="orangered"><b>Fond Noir/Black Background</b></span>")
#@gui : 6 - Noir/Black = int(32,16,160)
#@gui : 7 - Negate = bool(1)
#@gui : 8 - Index = int(2,2,8)
#@gui :_=note("<span foreground="orangered"><b>Couleur/Color</b></span>")
#@gui : 9 - Color = bool(0)
#@gui : 10 - Index = int(32,2,32)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/12/19</i>.</small>")

samj_Grid_BW_Color :
Index=0
repeat $!
	Index={$Index-1}
	samj_Base_Grid_BW_Color[$Index] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
done

samj_Base_Grid_BW_Color :
n[-1] 0,255
if $9==1
	+Je_passe_l_hiver_en_Floride[-1]
	if $3==4 Larg={w} Haut={h} resize[-2] {$Larg/$4},{$Haut/$5} resize[-2] $Larg,$Haut endif
endif
blur[-1] $1
to_rgba[-1]
if $3==4 Larg={w} Haut={h} resize[-1] {$Larg/$4},{$Haut/$5} resize[-1] $Larg,$Haut endif
map[-1] hocuspocus,1
smooth[-1] $2
split[-1] c
rm[-1--11]
c[-1] 0,$6
if $7==1 negate[-1] endif
autoindex[-1] $8
if $3==1
	imagegrid[-1] $4,$5
elif $3==2
	imagegrid_triangular[-1] {$4+2},{$5+2},0,1,0,0,0,255
elif $3==3
	imagegrid_hexagonal[-1] {round({w}/{6+$4})},0.1,1
elif $3==5
	imagegrid_triangular[-1] {$4+2},{$5+2},0,0,0,0,0,255
elif $3==6
	imagegrid_hexagonal[-1] {round({w}/{6+$4})},0,1
endif
n[-1] 0,255
if $9==1
	autoindex[-2] {$10}
	if $3==1
		imagegrid[-2] $4,$5
	elif $3==2
		imagegrid_triangular[-2] {$4+2},{$5+2},0,1,0,0,0,255
	elif $3==3
		imagegrid_hexagonal[-2] {round({w}/{6+$4})},0.1,1
	elif $3==5
		imagegrid_triangular[-2] {$4+2},{$5+2},0,0,0,0,0,255
	elif $3==6
		imagegrid_hexagonal[-2] {round({w}/{6+$4})},0,1
	endif
	rv[-1,-2]
	blend[-1,-2] grainmerge
endif

#################################################
##                                             ##
##           FIN samj_Grid_BW_Color            ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_NB_EdgesO_Engrave            ##
##                                             ##
#################################################

#### samj_NB_EdgesO_Engrave 0,50,9,1,2,50,0,8,40,0,0,1
#### samj_NB_EdgesO_Engrave 0,50,9,1,0.7,150,0,8,40,-16,0,1

#@gui NB Edges Engrave  : samj_NB_EdgesO_Engrave, samj_NB_EdgesO_Engrave(0)
#@gui :_=note("samj_NB_EdgesO_Engrave")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Edges offsets</b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(50,0,100)
#@gui : Scale = int(9,0,32)
#@gui : Thickness = int(1,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Engrave</b></span>")
#@gui : Radius = float(2,0,4)
#@gui : Density = float(50,0,200)
#@gui : Edges = float(0,0,10)
#@gui : Cohérence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal area = int(0,-256,256)
#@gui : Flat regions removal = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Variation</b></span>")
#@gui : Variation = float(1,0.8,1.2)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/24</i>.</small>")

samj_NB_EdgesO_Engrave :
+Je_passe_l_hiver_en_Floride[-1]
pow[-2]  $12
fx_edge_offsets[-2] $1,$2,$3,$4,0
fx_engrave[-1,-2] $5,$6,$7,$8,$9,$10,$11,0,10,1,0,0,0,1
blend[-1,-2] multiply,1,1
#################################################
##                                             ##
##         FIN samj_NB_EdgesO_Engrave          ##
##                                             ##
#################################################


#################################################
##                                             ##
##              samj_scintillements            ##
##                                             ##
#################################################

# 2015/04/14 origine

#@gui Scintillements  : samj_scintillements, samj_scintillements(1)
#@gui :_=note("samj_scintillements")
#@gui : Exemples = choice{"Non","A","B","C","D Image Noire","E Image Noire - Scintillements","F Image Noire - Stars"}
#@gui :_=note("<span foreground="orangered"><small>Dog</small></span>")
#@gui : Sigma 1 = float(5,0,10)
#@gui : Sigma 2 = float(0,0,10)
#@gui : Itérations = int(1,1,8)
#@gui :_=note("<span foreground="orangered"><small>Noise</small></span>")
#@gui : Variation = int(20,0,100)
#@gui : Type = choice{2,"Gaussian","Uniform","Salt and Pepper","Poisson","Rice"}
#@gui :_=note("<span foreground="orangered"><small>Circle</small></span>")
#@gui : Amplitude = int(6,3,20)
#@gui :_=note("<span foreground="orangered"><small>Blur Linear</small></span>")
#@gui : Amplitude A = float(20,0,100)
#@gui : Amplitude B = float(5,0,100)
#@gui : Angle = float(45,0,120)
#@gui :_=note("<span foreground="orangered"><small>Local normalization</small></span>")
#@gui : Amplitude = float(2,0,60)
#@gui : Radius = int(6,1,64)
#@gui : Neighborhood smoothness = float(5,0,40)
#@gui : Average smoothness = float(20,0,40)
#@gui : Constrain values = bool(1)
#@gui : Channel(s) = choice(7,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui :_=note("<span foreground="orangered"><small>Couleurs</small></span>")
#@gui : Inverser Couleur = bool(0)
#@gui : Dégradation = float(0,-50,50)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/19</i>.</small>")

samj_scintillements :

 Exemple=$1
 dog_sigma1=$2
 dog_sigma2={$3/10}
 dog_Iterations=$4
 Variation_noise=$5
 Type_noise=$6
 Amplitude_circle=$7
 AmplitudeA=$8
 AmplitudeB=$9
 Angle=$10
 Amplitude_ln=$11
 Radius_ln=$12
 Neighborhood_smoothness_ln=$13
 Average_smoothness_ln=$14
 Constrain_values_ln=$15
 Channel_ln=$16
 Inverser_couleur=$17
 Degradation_pow={1+{$18/100}}

 to_rgb[-1]

 if $Exemple==1
  Variation_noise=70
  Amplitude_circle=3
  Angle=0
 elif $Exemple==2
  Variation_noise=70
  Amplitude_circle=3
  Angle=40
 elif $Exemple==3
  Variation_noise=70
  Amplitude_circle=3
  Angle=80
 elif $Exemple==4
  fill_color[-1] 0,0,0
  noise[-1] $Variation_noise,$Type_noise
  norm[-1]
 elif $Exemple==5
  Variation_noise=2
  fill_color[-1] 0,0,0
  noise[-1] $Variation_noise,$Type_noise
  norm[-1]
 elif $Exemple==6
  fill_color[-1] 0,0,0
  noise[-1] $Variation_noise,$Type_noise
  norm[-1]
  Amplitude_circle={$Amplitude_circle+25}
 endif

 repeat $dog_Iterations
  dog[-1] $dog_sigma1%,$dog_sigma2%
 done

 #filtre sponge (par David Tschumperlé) adapté
  {w},{h},1
  noise[-1] $Variation_noise,$Type_noise
  r[-1] [-2]
  n[-1] 0,1
  *[-1,-2]
  _circle_1610 $Amplitude_circle
  dilate[-2] [-1]
  rm[-1]
 #fin filtre sponge adapté

 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 blur_linear[-1] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},$Angle,1
 blur_linear[-2] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},{$Angle+120},1
 blur_linear[-3] $AmplitudeA,{$AmplitudeB*$AmplitudeA/100},{$Angle+240},1
 n[-1,-2,-3] 0,255
 fx_blend_average_all[-1,-2,-3] 2
 fx_normalize_local[-1] $Amplitude_ln,$Radius_ln,$Neighborhood_smoothness_ln,$Average_smoothness_ln,$Constrain_values_ln,$Channel_ln
 if $Degradation_pow!=1
  pow[-1] $Degradation_pow
  n[-1] 0,255
 endif
 if $Inverser_couleur==1 negate[-1] endif

#fonction _circle (par David Tschumperlé) de GMIC 1610
_circle_1610 :
 if $1%2==0
  i 2,2
 else
  i 1
 endif
 +[-1] 1
 r[-1] $1,$1,1,1,0,0,0.5,0.5
 distance[-1] 1
 n[-1] 0,1
 sqrt[-1]
 c[-1] 0.85,0.86
 *[-1] -1
 n[-1] 0,1

#################################################
##                                             ##
##            FIN samj_scintillements          ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Engrave_colore                ##
##                                             ##
#################################################

# 2015/03/23 ajout sortie 3 calques pour couleurs , modifications paramètres dilate_circ
# 2015/03/22 ajout couleurs à partir de l'image
# 2015/03/21 origine à partir de engrave_modifie
#@gui Colored Engraving : Engrave_colore, Engrave_colore(1)
#@gui :_=note("<small>Modification du Filtre de Lyle Kroll et David Tschumperlé</small>")
#@gui :_=note("<small>pour obtenir des gravures colorées - samj 20150321</small>")
#@gui : sep = separator()
#@gui : Exemples / Examples = choice(0,"Non / None","A","B","C","D ***","E","F","G")
#@gui :_=note("<small><b>Gravure / Engraving</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Densité A = float(4,0,10)
#@gui : Edges = float(0,0,10)
#@gui : Cohérence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal area = int(0,-256,256)
#@gui : Répétition = int(25,0,50)
#@gui :_=note("<small><b>Anti-aliasing</b></small>")
#@gui : Anti-aliasing = choice(1,"Disabled","A","B","C")
#@gui :_=note("<small><b>Couleurs / Colors</b></small>")
#@gui : Gravure / Engraving = choice(2,"Avant Plan","Image Avec Contours Des Couleurs 8","Image Avec Contours Des Couleurs 16","Image Avec Contours Des Couleurs 32","Image Avec Contours Des Couleurs 64","Image Sans Contours Des Couleurs 8","Image Sans Contours Des Couleurs 16","Image Sans Contours Des Couleurs 32","Image Sans Contours Des Couleurs 64","3 calques - Image Sans Contours Des Couleurs 8","3 calques - Image Sans Contours Des Couleurs 16","3 calques - Image Sans Contours Des Couleurs 32","3 calques - Image Sans Contours Des Couleurs 64")
#@gui : Avant Plan = color(0,0,0)
#@gui : Fond / Background Color = color(255,255,255)
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperlé </i>.      Latest update: <i>2020/10/24</i>.</small>")

Engrave_colore :

 Examples=$1
 Radius=$2
 Densite_A=$3
 Edges=$4
 Coherence=$5
 Threshold=$6
 Minimal_Area=$7
 Repetition=$8
 Anti_Aliasing=$9
 Choix_Couleur=$10
 R_C1=$11
 V_C1=$12
 B_C1=$13
 R_C2=$14
 V_C2=$15
 B_C2=$16

 if $Examples==1
  Radius={0.475+{$Radius/20}}
  Densite_A={3.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==2
  Radius={0.275+{$Radius/20}}
  Densite_A={2.3+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==3
  Radius={0.475+{$Radius/20}}
  Densite_A={3.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={7-{$Coherence/20}}
  Threshold={48+{$Threshold/20}}
  Minimal_Area=-100
  Repetition={20-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==4
  Radius={0.175+{$Radius/20}}
  Densite_A={12-{$Densite_A/2}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={30-{$Repetition/10}}
  Anti_Aliasing=3
 elif $Examples==5
  Radius={1.975+{$Radius/20}}
  Densite_A={1.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={2-{$Coherence/20}}
  Threshold={18+{$Threshold/20}}
  Minimal_Area=-100
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=2
 elif $Examples==6
  Radius={0.975+{$Radius/20}}
  Densite_A={2.3+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={28+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==7
  Radius={0.475+{$Radius/20}}
  Densite_A={3.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={-5+{$Repetition/10}}
  Anti_Aliasing=1
 endif

 f={arg(1+$Anti_Aliasing,1,1.5,2,3)}
 r={$f*$Radius}
 nm=${-gui_layer_name}
 pos=${-gui_layer_pos}
 C1_blanc=0
 Blend_final=0

 to_rgb[-1]

 if $Choix_Couleur==0
  Blend_final=0
 elif $Choix_Couleur==1
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 8,2
  Blend_final=1
 elif $Choix_Couleur==2
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 16,2
  Blend_final=1
 elif $Choix_Couleur==3
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 32,2
  Blend_final=1
 elif $Choix_Couleur==4
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 64,2
  Blend_final=1
 elif $Choix_Couleur==5
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 8,2
  dilate_circ[-2] 2
  blur[-2] 2
  Blend_final=1
 elif $Choix_Couleur==6
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 16,2
  dilate_circ[-2] 4
  blur[-2] 2
  Blend_final=1
 elif $Choix_Couleur==7
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 32,2
  dilate_circ[-2] 8
  blur[-2] 2
  Blend_final=1
 elif $Choix_Couleur==8
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 64,2
  dilate_circ[-2] 16
  blur[-2] 2
  Blend_final=1
 elif $Choix_Couleur==9
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 8,2
  dilate_circ[-2] 2
  blur[-2] 2
  Blend_final=2
 elif $Choix_Couleur==10
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 16,2
  dilate_circ[-2] 4
  blur[-2] 2
  Blend_final=2
 elif $Choix_Couleur==11
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 32,2
  dilate_circ[-2] 8
  blur[-2] 2
  Blend_final=2
 elif $Choix_Couleur==12
  +Je_passe_l_hiver_en_Floride[-1]
  topographic_map[-2] 64,2
  dilate_circ[-2] 16
  blur[-2] 2
  Blend_final=2
 endif

 if $R_C1+$V_C1+$B_C1==765
  C1_blanc=1
  B_C1=254
 endif

 l[-1]

  split_opacity[-1]

  l[-1]
   wh={w},{h}
   norm[-1]
   if $Anti_Aliasing
    r[-1] {100*$f}%,{100*$f}%,1,1,3
   endif

   l[-1]
    repeat $Repetition
     b[-1] $r
     unsharp[-1] $r,{$Densite_A}
     c[-1] 0,255
    done
    smooth[-1] 100,0.1,1,{$f*$Edges},{$f*$Coherence}
    ->=[-1] {100-$Threshold}%
   endl

   if $Minimal_Area<0
    area_fg[-1] 0,0
    gt[-1] {$f*$Minimal_Area*$Minimal_Area}
   elif $Minimal_Area>0
    -==[-1] 0
    area_fg[-1] 0,0
    gt[-1] {$f*$Minimal_Area*$Minimal_Area}
    -==[-1] 0
   endif

   n[-1] 0,255
   to_rgb[-1]
   if $Blend_final==0
    replace_color[-1] 0,0,0,0,0,$R_C1,$V_C1,$B_C1
    replace_color[-1] 0,0,255,255,255,$R_C2,$V_C2,$B_C2
    if $C1_blanc==1
     replace_color[-1] 0,0,255,255,254,255,255,255
    endif
   endif

   if $Anti_Aliasing
    r[-1] $wh,1,3,2
   else
    r[-1] $wh
   endif
  endl

  a[-1] c

 endl

 if $Blend_final==1
  blend[-1,-2] add
  replace_color[-1] 0,0,255,255,255,$R_C2,$V_C2,$B_C2
 elif $Blend_final==2
  $wh,1,3
  to_rgb[-1]
  replace_color[-1] 0,0,0,0,0,$R_C2,$V_C2,$B_C2
  # display [-3,-2,-1]
  nm[-3] mode(add),name($nm" [couleurs]"),pos($pos)
  nm[-2] name($nm" [gravure]"),pos($pos)
 endif

#################################################
##                                             ##
##             FIN Engrave_colore              ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Engrave_modifie               ##
##                                             ##
#################################################

# 2015/03/30 modification des exemples avec petites variations des curseurs suite aux remarques de Lyle Kroll sur Gimpchat :o)
# 2015/03/18 ajout exemples
# 2015/03/17 origine
#@gui Engrave Modifie : engrave_modifie, engrave_modifie(1)
#@gui :_=note("<small>Aussi pour obtenir des contours</small>")
#@gui : Exemples / Examples = choice(0,"Non / None","A","B","C","D ***","E","F","G")
#@gui :_=note("<small><b>Black & White foreground:</b></small>")
#@gui : Radius = float(0.5,0,2)
#@gui : Densité A = float(4,0,10)
#@gui : Edges = float(0,0,10)
#@gui : Cohérence = float(8,0,40)
#@gui : Threshold (%) = float(40,0,100)
#@gui : Minimal area = int(0,-256,256)
#@gui : Répétition = int(25,0,50)
#@gui : sep = separator()
#@gui : Anti-aliasing = choice(1,"Disabled","x1.5","x2","x3")
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i>Lyle Kroll</i> and <i>David Tschumperlé</i>.      Latest update: <i>samj 2015/03/20</i>.</small>")

engrave_modifie :

 Examples=$1
 Radius=$2
 Densite_A=$3
 Edges=$4
 Coherence=$5
 Threshold=$6
 Minimal_Area=$7
 Repetition=$8
 Anti_Aliasing=$9

 if $Examples==1
  Radius={0.475+{$Radius/20}}
  Densite_A={3.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==2
  Radius={0.275+{$Radius/20}}
  Densite_A={2.3+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==3
  Radius={0.475+{$Radius/20}}
  Densite_A={3.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={7-{$Coherence/20}}
  Threshold={48+{$Threshold/20}}
  Minimal_Area=-100
  Repetition={20-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==4
  Radius={0.175+{$Radius/20}}
  Densite_A={12-{$Densite_A/2}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={30-{$Repetition/10}}
  Anti_Aliasing=3
 elif $Examples==5
  Radius={1.975+{$Radius/20}}
  Densite_A={1.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={2-{$Coherence/20}}
  Threshold={18+{$Threshold/20}}
  Minimal_Area=-100
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=2
 elif $Examples==6
  Radius={0.975+{$Radius/20}}
  Densite_A={2.3+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={28+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={55-{$Repetition/10}}
  Anti_Aliasing=1
 elif $Examples==7
  Radius={0.475+{$Radius/20}}
  Densite_A={3.8+{$Densite_A/20}}
  Edges={$Edges/20}
  Coherence={10-{$Coherence/20}}
  Threshold={38+{$Threshold/20}}
  Minimal_Area={$Minimal_Area/20}
  Repetition={-5+{$Repetition/10}}
  Anti_Aliasing=1
 endif

 f={arg(1+$Anti_Aliasing,1,1.5,2,3)}
 r={$f*$Radius}
 nm=${-gui_layer_name}
 pos=${-gui_layer_pos}
 l[0]

  split_opacity

  l[0]
   wh={w},{h}
   norm
   if $Anti_Aliasing
    r {100*$f}%,{100*$f}%,1,1,3
   endif

   l[0]
    repeat $Repetition
     b $r
     unsharp $r,{$Densite_A}
     c 0,255
    done
    smooth 100,0.1,1,{$f*$Edges},{$f*$Coherence}
    ->= {100-$Threshold}%
   endl

   if $Minimal_Area<0
    area_fg 0,0
    gt {$f*$Minimal_Area*$Minimal_Area}
   elif $Minimal_Area>0
    -== 0
    area_fg 0,0
    gt {$f*$Minimal_Area*$Minimal_Area}
    -== 0
   endif

   * 255

   if $Anti_Aliasing
    r $wh,1,1,2
   endif

  endl

  a c

 endl

#################################################
##                                             ##
##            FIN Engrave_modifie              ##
##                                             ##
#################################################
################################################################
##                                                            ##
##                    XY_hardsketchbw_samj                    ##
##                                                            ##
################################################################

# Pour créer des effets sur les parties horizontales et verticales
# version 1.00 2013 01 12
# version 1.01 modification expand
# version 1.02 ajout couleur transparence
# 17 janvier 2014  modifications blend , gimp_unsharp_octave et ajout trait coloré XY_hardsketch Color  /  Hard sketch XY : XY_hardsketchbw_samj 0.2,187.234,50,1,0.1,8.51064,0,0,0,1,180,40,160,255,1,0
# 2014/04/24 blend
# 2015/03/10 menu , Je_passe_l_hiver_en_Floride[-1] , ajout anciennes fonctions "euclidean2polar" et "polar2euclidean" de G'MIC 1.5.8.6

#@gui Hard Sketch XY : XY_hardsketchbw_samj, XY_hardsketchbw_samj(0)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre Hard Sketch BW</small>")
#@gui : XY = float(0.2,0,1)
#@gui : Densité / Amplitude = float(300,0,4000)
#@gui : Density / Density = float(50,0,100)
#@gui : Douceur / Smoothness = float(1,0,10)
#@gui : Opacité / Opacity = float(0.1,0,1)
#@gui : Bordure / Edge = float(20,0,100)
#@gui : Approximation Rapide / Fast approximation = bool(0)
#@gui : Color model = choice("Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui :_=separator()
#@gui :_=note("<small>Calques / Layers</small>")
#@gui : Nb. = choice(0,"1 : XY","2 : XY + Hard Sketch BW Normal")
#@gui :_=separator()
#@gui :_=note("<small>Netteté / Sharpen</small>")
#@gui : Filtre Octave Sharpening = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>XY_hardsketch Color</small>")
#@gui : Couleur / Color = color(180,40,160,255)
#@gui : Remplir / Fill = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj      Dernière mise à jour : <i>2015/03/10</i>.</small>")

XY_hardsketchbw_samj :

XY=$1
Amplitude=$2
Density=$3
Smoothness=$4
Opacity=$5
Edge=$6
Fast_approximation=$7
Negative=$8
Calques=$9
Octave_Sharpening=$10
R_Transparence=$11
V_Transparence=$12
B_Transparence=$13
A_Transparence=$14
Remplir=$15

 Largeur={w}
 Hauteur={h}

 to_rgba[-1]

 +Je_passe_l_hiver_en_Floride[-1]
 if $Calques==1 +Je_passe_l_hiver_en_Floride[-1] endif

 if $Largeur>$Hauteur
  Grande_dimension={$Largeur*1.5}
 else
  Grande_dimension={$Hauteur*1.5}
 endif

 Origine_X={round({{{$Grande_dimension}-$Largeur}/2})}
 Origine_Y={round({{{$Grande_dimension}-$Hauteur}/2})}

 expand_x[-1] $Origine_X,2
 expand_y[-1] $Origine_Y,2

 twirl_ancien_euclidean2polar_ancien_polar2euclidean[-1] $XY,0.5,0.5,1
 fx_hardsketchbw[-1] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
 twirl_ancien_euclidean2polar_ancien_polar2euclidean[-1] -$XY,0.5,0.5,1

 expand_x[-2] $Origine_X,2
 expand_y[-2] $Origine_Y,2

 twirl_ancien_euclidean2polar_ancien_polar2euclidean[-2] -$XY,0.5,0.5,1
 fx_hardsketchbw[-2] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
 twirl_ancien_euclidean2polar_ancien_polar2euclidean[-2] $XY,0.5,0.5,1

 #average
 blend[-1,-2] average,1,0
 crop[-1] $Origine_X,$Origine_Y,{$Largeur+$Origine_X-1},{$Hauteur+$Origine_Y-1}

 if $Octave_Sharpening==1
  fx_unsharp_octave 4,5,3,0,0,0,24,0
 endif

 if $Calques==1
  fx_hardsketchbw[-2] $Amplitude,$Density,$Smoothness,$Opacity,$Edge,$Fast_approximation,$Negative
  rv[-1,-2]
 endif

 if $Remplir==1
  $Largeur,$Hauteur,1,4
  fill_color[-1] $R_Transparence,$V_Transparence,$B_Transparence,$A_Transparence
  if $Calques==1
   rv[-1,-2]
  endif
  blend[-1,-2] screen,1,1
  if $Calques==1
   rv[-1,-2]
  endif
 endif

################################################################
##                                                            ##
##                  FIN  XY_hardsketchbw_samj                 ##
##                                                            ##
################################################################


#################################################################################################################################################################################################
#
#                                                                                                                                                                                          COLORS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_colors :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Colors</b>
#################################################
##                                             ##
##             samj_test_9_colors              ##
##                                             ##
#################################################

#@gui 9 colors : samj_test_9_colors, samj_test_9_colors
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-9-colors.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-9-colors.html")
#@gui :_=link("https://discuss.pixls.us/t/help-with-gmic-map-command/20801","https://discuss.pixls.us/t/help-with-gmic-map-command/20801")
#@gui : Couleur/Color 1 = color(70,17,10)
#@gui : Couleur/Color 2 = color(134,35,20)
#@gui : Couleur/Color 3 = color(154,27,58)
#@gui : Couleur/Color 4 = color(186,61,89)
#@gui : Couleur/Color 5 = color(220,103,129)
#@gui : Couleur/Color 6 = color(239,151,169)
#@gui : Couleur/Color 7 = color(246,194,205)
#@gui : Couleur/Color 8 = color(253,201,212)
#@gui : Couleur/Color 9 = color(255,255,255)
#@gui : Flou/Blur = float(0,0,5)
#@gui : Netteté/Sharpen = float(0,0,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/19</i>.</small>")

samj_test_9_colors :
	if $28>0 blur $28 endif
	if $29>0 sharpen $29 endif
	samj9colorsV2 $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27

samj9colorsV2:
skip ${1=0},${2=0},${3=0},${4=0},${5=128},${6=0},${7=0},${8=255},${9=0},${10=173},${11=245},${12=47},${13=255},${14=255},${15=0},${16=255},${17=218},${18=0},${19=255},${20=165},${21=0},${22=255},${23=0},${24=0},${25=255},${26=255},${27=255}
# black , green , lime , GreenYellow , yellow , PeachPuff , orange , red , white
to_gray # to gray without alpha channel
to_rgba # to rgba with alpha  channel
index=0 # array
repeat 16 # array 0,15
replace_color 1,0,$index,$index,$index,255,$1,$2,$3,255
index={$index+1}
done
repeat 32 # array 16,47
replace_color 1,0,$index,$index,$index,255,$4,$5,$6,255
index={$index+1}
done
repeat 32  # array 48,79
replace_color 1,0,$index,$index,$index,255,$7,$8,$9,255
index={$index+1}
done
repeat 32  # array 80,111
replace_color 1,0,$index,$index,$index,255,$10,$11,$12,255
index={$index+1}
done
repeat 32  # array 112,143
replace_color 1,0,$index,$index,$index,255,$13,$14,$15,255
index={$index+1}
done
repeat 32  # array 144,175
replace_color 1,0,$index,$index,$index,255,$16,$17,$18,255
index={$index+1}
done
repeat 32  # array 176,207
replace_color 1,0,$index,$index,$index,255,$19,$20,$21,255
index={$index+1}
done
repeat 32  # array 208,239
replace_color 1,0,$index,$index,$index,255,$22,$23,$24,255
index={$index+1}
done
repeat 16  # array 240,255
replace_color 1,0,$index,$index,$index,255,$25,$26,$27,255
index={$index+1}
done

#################################################
##                                             ##
##           FIN samj_test_9_colors            ##
##                                             ##
#################################################
#################################################
##                                             ##
##               samj_Dorure                   ##
##                                             ##
#################################################

#@gui Dorure Gilding : samj_Dorure, samj_Dorure
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-dorure.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-dorure.html")
#@gui :_=note("<span foreground="orangered"><b>Relief Light</b></span>")
#@gui :_=note("<small><i>Obtenir une couleur dorée ou cuivrée par Lightness et Darkness.</i></small>")
#@gui :_=note("<small><i>Obtain a golden or copper color by Lightness et Darkness.</i></small>")
#@gui : Ambient Lightness = float(0.4,0.2,0.7)
#@gui : Specular Lightness = float(0.2,0,2)
#@gui : Specular Size = float(0.2,0,1)
#@gui : Darkness = float(0,0,1)
#@gui : Light Smoothness = float(1,0,5)
#@gui : XY-Light = point(20,20,0,1,255,255,128,200,10)
#@gui : Z-Light = float(0,0,20)
#@gui : Z-Scale = float(0.5,0,3)
#@gui :_=note("<span foreground="orangered"><b>Dorure/Gilding</b></span>")
#@gui : Inverser/Invert Relief = bool(0)
#@gui : Adoucir/Smooth = int(60,0,200)
#@gui : Large Image = bool(0)
#@gui : Flou/Blur = float(0,0,5)
#@gui : Netteté/Sharpen = float(100,0,200)
#@gui : Aspect = float(45,0,360)
#@gui : Map 1 = int(18,2,64)
#@gui : Map 2 = int(32,2,255)
#@gui : Map 3 = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/24</i>.</small>")

samj_Dorure:

	if $12==1
		Largeur={w}
		Hauteur={h}
		if {w}>{h}
			resize 800,{{h}/{w}*800}
		else
			resize {{w}/{h}*800},800
		endif
	endif
	if $10==1 negate endif
	samj_Fond_Or $13,$14,$15,$16,$17,$18
	fx_light_relief $1,$2,$3,$4,$5,$6,$7,$8,$9,0,0
	if $11>100 smooth 100,0.7,0.3,0.6 smooth {$11-100},0.7,0.3,0.6 else smooth $11,0.7,0.3,0.6 endif
	if $12==1 resize $Largeur,$Hauteur smooth 100,0.7,0.3,0.6 sharpen 50 endif

samj_Fond_Or:
	skip ${1=0},${2=0},${3=45},${4=64},${5=255},${6=0}
	blur $1
	sharpen $2
	n 0,255
	+fx_linear_gradient 255,208,170,255,220,92,1,255,0,$3,0,100,0
	autoindex[-1] $4
	autoindex[0] $5
	if $6==1 to_gray[0] endif
	resize[-1] 64,1
	to_rgb
	n 0,255
	negate[0]
	map_clut[0] [-1]
	rm[-1]
	blend screen

#################################################
##                                             ##
##               FIN samj_Dorure               ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_64_Couleurs_Max            ##
##                                             ##
#################################################

#@gui 64 Couleurs Max : samj_64_Couleurs_Max, samj_64_Couleurs_Max(0)
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-64.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-64.html")
#@gui : Graine/Seed = int(9,0,65536)
#@gui : Nb. Max. Couleurs/Colors = int(4,2,64)
#@gui : Flou/Blur = float(2,0,100)
#@gui : Netteté/Sharpen = float(50,0,100)
#@gui : Map Sur Gris/On Gray = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Palette de couleurs predefinie/Preset color palette</b></span>")
#@gui : Palette Prédéfinie/Preset Color = choice(0,"Non/No","Palette Origine","N&B-Gris/B&W-Grey","B&N-Gris/W&B-Grey","Choix/Choice 2 Colors A B","Choix/Choice 2 Colors B A")
#@gui : Couleur - Color A = color(240,240,40)
#@gui : Couleur - Color B = color(120,40,240)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/18</i>.</small>")

samj_64_Couleurs_Max:
	to_rgb
	blur $3
	sharpen $4
	if $6==0
		index=0
		srand $1
		{$2*16},{$2*16},1,3
		fx_array_color[-1] $2,1,1
	elif $6==1
		+colormap $2
	elif $6==2
		16,16,1,3
		fill_color[-1] 0,0,0
		16,16,1,3
		fill_color[-1] 255,255,255
		append_tiles[-1,-2] 2,1
	elif $6==3		
		16,16,1,3
		fill_color[-1] 255,255,255
		16,16,1,3
		fill_color[-1] 0,0,0
		append_tiles[-1,-2] 2,1
	elif $6==4
		{$2*16},{$2*16},1,1,4
		fx_linear_gradient[-1] $7,$8,$9,255,$10,$11,$12,255,0,0,0,100,2
	elif $6==5
		{$2*16},{$2*16},1,1,4
		fx_linear_gradient[-1] $7,$8,$9,255,$10,$11,$12,255,1,0,0,100,2
	endif
	resize[-1] 64,1
	if $5==1 to_gray[0] endif
	n[0] 0,255
	to_rgb
	map_clut[0] [-1]
	rm[-1]
	autoindex[0] $2
	n 0,255

#################################################
##                                             ##
##          FIN samj_64_Couleurs_Max           ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Valeur_Moyenne_LCH            ##
##                                             ##
#################################################
# Fonction samj_Valeur_Moyenne_LCH pour récupérer dans un fichier la couleur moyenne d'une image en LCH. À utiliser dans un traitement par lot, par exemple :
#            gmic m update254.gmic i fp070606-24.jpg samj_Valeur_Moyenne_LCH[-1] 400,14,4,"C:\Gimp-2.10.9_Portable-32-64bits-Win_20190317\bin","fp070606-24.jpg.txt" quit
#@gui Valeur Moyenne LCH : samj_Valeur_Moyenne_LCH, samj_Valeur_Moyenne_LCH_Preview(0)
#@gui : sep = separator(), note = link("http://colormine.org/convert/rgb-to-lch","http://colormine.org/convert/rgb-to-lch")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Valeur_Moyenne_LCH</span>")
#@gui : Dimension Echantillon Image = int(400,10,800)
#@gui :_=link("http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html","http://www.brucelindbloom.com/Eqn_RGB_XYZ_Matrix.html")
#@gui : RGB XYZ Matrices = choice(14,"0 Adobe RGB 1998 D65","1 AppleRGB D65","2 Best RGB D50","3 Beta RGB D50","4 Bruce RGB D65","5 CIE RGB E","6 ColorMatch RGB D50","7 Don RGB 4 D50","8 ECI RGB D50","9 Ekta Space PS5 D50 ","10 NTSC RGB C","11 PAL SECAM RGB D65","12 ProPhoto RGB D50","13 SMPTE C RGB D65","14 Observateur 2deg Illuminant D65 sRGB REF","15 Wide Gamut RGB D50")
#@gui : XYZ_Tristimulus = choice(4,"0 2deg CIE 1931 A Incandescent","1 2deg CIE 1931 C","2 2deg CIE 1931 D50","3 2deg CIE 1931 D55","4 2deg CIE 1931 D65 Daylight REF","5 2deg CIE 1931 D75","6 2deg CIE 1931 F2 Fluorescent","7 2deg CIE 1931 F7","8 2deg CIE 1931 F11","9 RIEN NONE","10 10deg CIE 1964 A Incandescent","11 10deg CIE 1964 C","12 10deg CIE 1964 D50","13 10deg CIE 1964 D55","14 10deg CIE 1964 D65 Daylight ","15 10deg CIE 1964 D75 ","16 10deg CIE 1964 F2 Fluorescent ","17 10deg CIE 1964 F7 ","18 10deg CIE 1964 F11")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Fichier Sauvegarde File</span>")
#@gui : Output Folder = _folder()
#@gui : Output Filename = _text("samj_Valeur_Moyenne_LCH.txt")
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2019/03/26</i>.</small>")

samj_Valeur_Moyenne_LCH :

 Echantillon=$1
 Matrices_RGB=$2
 XYZ_Tristimulus=$3
 filename="$4//$5"
 Choix=0
 +resize[-1] $Echantillon,{{h}/{w}*$Echantillon}
 quantize[-1] 1,1,0
 Val_R={i0}
 Val_V={i1}
 Val_B={i2}
 Valeur_L={round(${"samj_RGB_to_LCH_or_Lab[] 1,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 Valeur_C={round(${"samj_RGB_to_LCH_or_Lab[] 2,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 Valeur_H={round(${"samj_RGB_to_LCH_or_Lab[] 3,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 rm[-1]
 200,200,1,4
 fill_color[-1] $Val_R,$Val_V,$Val_B,255
 echo_file $filename,L{$Valeur_L}C{$Valeur_C}H{$Valeur_H}
 text_outline[-1] R{round($Val_R)}V{round($Val_V)}B{round($Val_B)},2,2,23,2,1,255
 text_outline[-1] L{$Valeur_L}C{$Valeur_C}H{$Valeur_H},2,22,23,2,1,255
 rv[-2,-1]

samj_Valeur_Moyenne_LCH_Preview :

 Echantillon=$1
 Matrices_RGB=$2
 XYZ_Tristimulus=$3
 Choix=0
 +resize[-1] $Echantillon,{{h}/{w}*$Echantillon}
 quantize[-1] 1,1,0
 Val_R={i0}
 Val_V={i1}
 Val_B={i2}
 Valeur_L={round(${"samj_RGB_to_LCH_or_Lab[] 1,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 Valeur_C={round(${"samj_RGB_to_LCH_or_Lab[] 2,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 Valeur_H={round(${"samj_RGB_to_LCH_or_Lab[] 3,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 to_rgba[-1,-2]
 blend[-2,-1] alpha,1,1
 text_outline[-1] "Attention Couleur Selon Apercu",2,22,23,2,1,255
# fonction pour obtenir des données de type CSV
# gmic m update i fp070606-24.jpg samj_Valeur_Moyenne_LCH_CSV[-1] 400,14,4,"C:\Gimp-2.10.9_Portable-32-64bits-Win_20190317\bin","fp070606-24.jpg.csv","fp070606-24.jpg" quit
samj_Valeur_Moyenne_LCH_CSV :

 Echantillon=$1
 Matrices_RGB=$2
 XYZ_Tristimulus=$3
 filename="$4//$5"
 Img=$6
 Choix=0
 +resize[-1] $Echantillon,{{h}/{w}*$Echantillon}
 quantize[-1] 1,1,0
 Val_R={i0}
 Val_V={i1}
 Val_B={i2}
 Valeur_L={round(${"samj_RGB_to_LCH_or_Lab[] 1,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 Valeur_C={round(${"samj_RGB_to_LCH_or_Lab[] 2,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 Valeur_H={round(${"samj_RGB_to_LCH_or_Lab[] 3,"$Val_R","$Val_V","$Val_B","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
 echo_file $filename,$Img,{$Valeur_L},{$Valeur_C},{$Valeur_H}
 rm[-1]

#################################################
##                                             ##
##         FIN samj_Valeur_Moyenne_LCH         ##
##         FIN samj_Valeur_Moyenne_LCH_CSV     ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_At06A_2017_VarCouleurs         ##
##                                             ##
#################################################

#@gui At06A 2017 VarCouleurs : samj_At06A_2017_VarCouleurs, samj_At06A_2017_VarCouleurs(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_At06A_2017_VarCouleurs</span>")
#@gui : Puissance = float(1,0,8)
#@gui : Couper A % = float(0,0,100)
#@gui : Couper B % = float(100,0,100)
#@gui : Noir et Blanc = choice(0,"Non","To Gray","Lightness - Lab")
#@gui : Normaliser = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2017/02/27</i>.</small>")

samj_At06A_2017_VarCouleurs :

to_rgba[-1]
pow[-1] $1
n[-1] 0,{{iM}-{im}}
c[-1] {{iM}/100*$2},{iM}
n[-1] 0,{iM}
c[-1] 0,{{iM}/100*$3}
n[-1] 0,255
if $4==1
 to_graya[-1]
elif $4==2
 +Je_passe_l_hiver_en_Floride[-1]
 fx_decompose_channels[-1] 7,0,1,0
 remove[-1,-2]
 blend[-1,-2] alpha
endif
if $5==1 n[-1] 0,255 endif
to_rgba[-1]

#################################################
##                                             ##
##       FIN samj_At06A_2017_VarCouleurs       ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Variations_RVB              ##
##                                             ##
#################################################

#@gui Variations RVB : samj_Variations_RVB, samj_Variations_RVB(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Variations_RVB</b></span>")
#@gui :_=separator()
#@gui :_=note("<small>Geometry</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Tilt Angle = float(0,0,360)
#@gui : Radius Center Circle = float(6,0,100)
#@gui : Angle Offset Rings = float(0,0,360)
#@gui : Variation Dimension = float(0,-100,200)
#@gui :_=separator()
#@gui :_=note("<small>Variations RVB</small>")
#@gui : Reference Color = color(180,90,45)
#@gui : Fill Color = bool(0)
#@gui : Outline Reference Color = bool(1)
#@gui : Type Variation = int(0,0,20)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Variations_RVB :

 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Angle_inclinaison=$3

 Rayon_Cercle_Centre={round({{w}*$4/{100}})}
 Angle_Decalage=$5
 Variation_Increment_Anneaux=$6

 R_val=$7
 G_val=$8
 B_val=$9
 Remplir_Couleur_Base=$10
 Outline_Reference_Color=$11
 Type_Variation=$12

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_Circles_Surrounding=32
 Nb_Anneaux=8

 to_rgba[-1]
 if $Remplir_Couleur_Base==1 fill_color[-1] $R_val,$G_val,$B_val,255 endif

 Angle_Theta={pi/$Nb_Circles_Surrounding}
 if $Rayon_Cercle_Centre<10
  Rayon_Cercle_Centre=10
 endif

 Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
 Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
 Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
 Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
 Nb_boucles=0
 X_ext=0
 Y_ext=0
 Angle=0
 Angle_Decalage_En_Cours=0
 Nb_boucles_anneaux=0
 Rayon_Cercle_Centre_En_Cours=0
 R_en_cours=$R_val
 G_en_cours=$G_val
 B_en_cours=$B_val
 A_en_cours=255
 Variation_RVB=0

 repeat $Nb_Anneaux
  Nb_boucles=0

  Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage*$Nb_boucles_anneaux} # si curseur Angle_Decalage = 50
  if $Nb_boucles_anneaux==0
   Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
  else
   Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
  endif

  Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
  Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
  Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
  Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}

  repeat $Nb_Circles_Surrounding

   Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
   X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
   Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
   if $Type_Variation==0
    R_en_cours={abs({$R_val-$Variation_RVB})}
    G_en_cours={abs({$G_val-$Variation_RVB})}
    B_en_cours={abs({$B_val-$Variation_RVB})}
   elif $Type_Variation==1
    R_en_cours={abs({$R_val-$Variation_RVB})}
   elif $Type_Variation==2
    B_en_cours={abs({$G_val-$Variation_RVB})}
   elif $Type_Variation==3
    B_en_cours={abs({$B_val-$Variation_RVB})}
   elif $Type_Variation==4
    R_en_cours={abs({$R_val-$Variation_RVB})}
    G_en_cours={abs({$G_val-$Variation_RVB})}
   elif $Type_Variation==5
    R_en_cours={abs({$R_val-$Variation_RVB})}
    B_en_cours={abs({$B_val-$Variation_RVB})}
   elif $Type_Variation==6
    G_en_cours={abs({$G_val-$Variation_RVB})}
    B_en_cours={abs({$B_val-$Variation_RVB})}
   elif $Type_Variation==7
    R_en_cours={$R_val-$Variation_RVB}
    G_en_cours={$G_val-$Variation_RVB}
    B_en_cours={$B_val-$Variation_RVB}
   elif $Type_Variation==8
    R_en_cours={$R_val-$Variation_RVB}
   elif $Type_Variation==9
    B_en_cours={$G_val-$Variation_RVB}
   elif $Type_Variation==10
    B_en_cours={$B_val-$Variation_RVB}
   elif $Type_Variation==11
    R_en_cours={$R_val-$Variation_RVB}
    G_en_cours={$G_val-$Variation_RVB}
   elif $Type_Variation==12
    R_en_cours={$R_val-$Variation_RVB}
    B_en_cours={$B_val-$Variation_RVB}
   elif $Type_Variation==13
    G_en_cours={$G_val-$Variation_RVB}
    B_en_cours={$B_val-$Variation_RVB}
   elif $Type_Variation==14
    R_en_cours={$R_val+$Variation_RVB}
    G_en_cours={$G_val+$Variation_RVB}
    B_en_cours={$B_val+$Variation_RVB}
   elif $Type_Variation==15
    R_en_cours={$R_val+$Variation_RVB}
   elif $Type_Variation==16
    B_en_cours={$G_val+$Variation_RVB}
   elif $Type_Variation==17
    B_en_cours={$B_val+$Variation_RVB}
   elif $Type_Variation==18
    R_en_cours={$R_val+$Variation_RVB}
    G_en_cours={$G_val+$Variation_RVB}
   elif $Type_Variation==19
    R_en_cours={$R_val+$Variation_RVB}
    B_en_cours={$B_val+$Variation_RVB}
   elif $Type_Variation==20
    G_en_cours={$G_val+$Variation_RVB}
    B_en_cours={$B_val+$Variation_RVB}
   endif
   if $R_en_cours<0 R_en_cours=0 endif
   if $R_en_cours>255 R_en_cours=255 endif
   if $G_en_cours<0 G_en_cours=0 endif
   if $G_en_cours>255 G_en_cours=255 endif
   if $B_en_cours<0 B_en_cours=0 endif
   if $B_en_cours>255 B_en_cours=255 endif
   circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,$R_en_cours,$G_en_cours,$B_en_cours,$A_en_cours
   if $Nb_boucles==0&&$Nb_boucles_anneaux==0&&$Outline_Reference_Color==1
    circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,0xFFFFFFFF,0,0,0,255
    circle[-1] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/2},1,0xFFFFFFFF,255,255,255,255
   endif
   Nb_boucles={$Nb_boucles+1}
   Variation_RVB={$Variation_RVB+1}
  done

  Nb_boucles_anneaux={$Nb_boucles_anneaux+1}

 done

#################################################
##                                             ##
##          FIN samj_Variations_RVB            ##
##                                             ##
#################################################
################################################################
##                                                            ##
##                    Couleurs_Metalliques                    ##
##                                                            ##
################################################################
# 2014/04/24 blend
# 2015/03/03 ajout Rendu_local_orientation_channels
# 2015/03/31 modification canaux paramètre Rendu_local_orientation_channels suite aux modifications du filtre

#********** Couleurs_Metalliques **********
##
##                                       Version 1.05 samj 29 septembre 2012
##
##
#@gui Couleurs Metalliques : Couleurs_Metalliques, Couleurs_Metalliques_preview
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Transparence / transparency = choice(0,"Conserver / Preserve","Supprimer / Remove")
#@gui : Rendu / Rendering = choice("YCbCr [luminance]","Lab [lightness]","HSV [value]","HSL [lightness]","Linear RGB [all]","RGB [all]","RGB [all]")
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre Noise - Noise parameters</small>")
#@gui : Amplitude = float(22,0,200)
#@gui : Type de bruit / Noise type = choice("Gaussian","Uniform","Salt and pepper","Poisson")
#@gui : Étendue / Value range = choice("Cut","Normalize")
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre Local normalization - Local normalization parameters</small>")
#@gui : Double effet = bool(0)
#@gui : Amplitude = float(0,0,60)
#@gui : Rayon / Radius = int(6,1,64)
#@gui : Lissage voisinage / Neighborhood smoothness = float(5,0,40)
#@gui : Lissage moyenne / Average smoothness = float(20,0,40)
#@gui : Imposer valeurs / Constrain values = bool(1)
#@gui : Canaux / Channel(s) = choice(0,"All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]")
#@gui :_=separator()
#@gui :_=note("<small>Paramètres Filtre Boost-Fade - Boost-Fade parameters : Siif Amplitude Sup. 0</small>")
#@gui : Amplitude = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>PhotoComix Options</small>")
#@gui : Utiliser / Use PC Options = bool(0)
#@gui : Filtre Pencilbw Taille / Size = float(0.3,0,5)
#@gui : Filtre Pencilbw Amplitude = float(60,0,200)
#@gui : Opacité Mélange / Blend Opacity = float(1,0,1)
#@gui : Mélange Permuter Calques / Blend Revert layers = bool(1)
#@gui : sep = separator()
#@gui : sep = separator(), Type Aperçu = choice("Tout","Rendu en bas","Rendu a droite","Rendu en haut","Rendu a gauche")
#@gui :_=separator()
#@gui :_=note("<small>samj      Dernière mise à jour : <i>2015/03/31</i>.</small>")

Couleurs_Metalliques :

####### Déclaration des variables

 Transparence=$1
 Rendu=$2

#gimp_noise
 Amplitude=$3
 Noise_type=$4
 Noise_Channel=7
 Value_range=$5

#gimp_normalize_local
 Double_effet=$6
 Local_normalization_Amplitude=$7
 Radius=$8
 Neighborhood_smoothness=$9
 Average_smoothness=$10
 Constrain_values=$11
 Local_normalization_Channel=$12

#gimp_boost_fade
 boost_fade_Amplitude=$13

 Utiliser_Photocomix_Options=$14
 Pencilbw_Size=$15
 Pencilbw_Amplitude=$16
 Blend_soft_light_Opacity=$17
 Blend_soft_light_Revert_layers=$18

####### Ligne de commandes

  repeat $! l[$>]

 if $Rendu==0
  Rendu_local_orientation_channels=11 # YCbCr [luminance]
 elif $Rendu==1
  Rendu_local_orientation_channels=16 # Lab [lightness]
 elif $Rendu==2
  Rendu_local_orientation_channels=25 # HSV [value]
 elif $Rendu==3
  Rendu_local_orientation_channels=27 # HSL [lightness]
 elif $Rendu==4
  Rendu_local_orientation_channels=7 # Linear RGB [all]
 elif $Rendu==5
  Rendu_local_orientation_channels=2 # RGB [all]
 elif $Rendu==6
  Rendu_local_orientation_channels=2 # RGB [all]
  endif

 if $Transparence==1
  remove_opacity[-1]
 endif

 if $Utiliser_Photocomix_Options==1
   +pencilbw[-1] $Pencilbw_Size,$Pencilbw_Amplitude

   if $Double_effet==1
    fx_normalize_local[-2] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
   endif

   fx_noise[-2] $Amplitude,$Noise_type,$Noise_Channel,$Value_range

   fx_local_orientation[-2] 0,0,100,0,$Rendu_local_orientation_channels

   fx_normalize_local[-2] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel

   if $boost_fade_Amplitude>0
    fx_boost_fade[-2] $boost_fade_Amplitude
   endif

   blend[-2,-1] softlight,$Blend_soft_light_Opacity,$Blend_soft_light_Revert_layers
 else
   if $Double_effet==1
    fx_normalize_local[-1] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel
   endif

   fx_noise[-1] $Amplitude,$Noise_type,$Noise_Channel,$Value_range

   fx_local_orientation[-1] 0,0,100,0,$Rendu_local_orientation_channels

   fx_normalize_local[-1] $Local_normalization_Amplitude,$Radius,$Neighborhood_smoothness,$Average_smoothness,$Constrain_values,$Local_normalization_Channel

   if $boost_fade_Amplitude>0
    fx_boost_fade[-1] $boost_fade_Amplitude
   endif
 endif

  endl done

Couleurs_Metalliques_preview :
 gui_split_preview "Couleurs_Metalliques ${1--2}",$-1

################################################################
##                                                            ##
##                  FIN  Couleurs_Metalliques                 ##
##                                                            ##
################################################################
#################################################
##                                             ##
##            samj_Color_Palettes              ##
##                                             ##
#################################################

#@gui Color Harmonies : samj_Color_Palettes, samj_Color_Palettes(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Color_Palettes</b></span>")
#@gui :_=separator()
#@gui :_=note("<small>Geometry</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Tilt Angle = float(0,0,360)
#@gui : Radius Center Circle = float(6,0,100)
#@gui : Number Of Shades Per Circle  = int(24,16,90)
#@gui : Angle Offset Rings = float(0,0,360)
#@gui : Variation Dimension = float(0,-100,200)
#@gui :_=separator()
#@gui :_=note("<small>Color - Palettes</small>")
#@gui : Reference Color = color(180,90,45)
#@gui : Fill Color = bool(1)
#@gui : RGB XYZ Matrices  = int(3,0,15)
#@gui : XYZ Tristimulus  = int(2,0,18)
#@gui : Outline Reference Color = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Color_Palettes :

 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Angle_inclinaison=$3

 Rayon_Cercle_Centre={round({{w}*$4/{100}})}
 Nb_Circles_Surrounding=$5
 Angle_Decalage=$6
 Variation_Increment_Anneaux=$7

 R_val=$8
 G_val=$9
 B_val=$10
 Remplir_Couleur_Base=$11

 # Conversions
 Matrices_RGB=$12
 XYZ_Tristimulus=$13
 Choix=0

 Outline_Reference_Color=$14

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_Anneaux={2*4} # (bases) + (L+25) + (L+50) + (L+75)

 R_val_comp={255-$R_val}
 G_val_comp={255-$G_val}
 B_val_comp={255-$B_val}

 L_origine=${"samj_RGB_to_LCH_or_Lab[] 1,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
 C_origine=${"samj_RGB_to_LCH_or_Lab[] 2,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
 H_origine=${"samj_RGB_to_LCH_or_Lab[] 3,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
 L_origine25={$L_origine+25}
 if $L_origine25>100 L_origine25={$L_origine25-100} endif
 L_origine50={$L_origine+50}
 if $L_origine50>100 L_origine50={$L_origine50-100} endif
 L_origine75={$L_origine+75}
 if $L_origine75>100 L_origine75={$L_origine75-100} endif

 L_origine_comp=${"samj_RGB_to_LCH_or_Lab[] 1,"{/$R_val_comp}","{/$G_val_comp}","{/$B_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
 C_origine_comp=${"samj_RGB_to_LCH_or_Lab[] 2,"{/$R_val_comp}","{/$G_val_comp}","{/$B_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
 H_origine_comp=${"samj_RGB_to_LCH_or_Lab[] 3,"{/$R_val_comp}","{/$G_val_comp}","{/$B_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""}
 L_origine_comp25={$L_origine_comp+25}
 if $L_origine_comp25>100 L_origine_comp25={$L_origine_comp25-100} endif
 L_origine_comp50={$L_origine_comp+50}
 if $L_origine_comp50>100 L_origine_comp50={$L_origine_comp50-100} endif
 L_origine_comp75={$L_origine_comp+75}
 if $L_origine_comp75>100 L_origine_comp75={$L_origine_comp75-100} endif

 to_rgba[-1]
 if $Remplir_Couleur_Base==1 fill_color[-1] $R_val,$G_val,$B_val,255 endif

 Angle_Theta={pi/$Nb_Circles_Surrounding}
 if $Rayon_Cercle_Centre<10
  Rayon_Cercle_Centre=10
 endif

 Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
 Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
 Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
 Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
 Nb_boucles=0
 X_ext=0
 Y_ext=0
 Angle=0
 Angle_Decalage_En_Cours=0
 Nb_boucles_anneaux=0
 Rayon_Cercle_Centre_En_Cours=0
 R_en_cours=0
 G_en_cours=0
 B_en_cours=0
 A_en_cours=255
 L_val=0
 L_val_comp=0

 repeat $Nb_Anneaux

  Nb_boucles=0

  Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage*$Nb_boucles_anneaux} # si curseur Angle_Decalage = 50
  if $Nb_boucles_anneaux==0
   Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
  else
   Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
  endif

  Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
  Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
  Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
  Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}

  repeat $Nb_Circles_Surrounding

   Erreur_Couleur=0
   Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
   X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
   Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}

   if {$Nb_boucles_anneaux%2}==0
    H_val={$H_origine+$Angle}
    if $Nb_boucles_anneaux==0
     L_val=$L_origine75
    elif $Nb_boucles_anneaux==2
     L_val=$L_origine50
    elif $Nb_boucles_anneaux==4
     L_val=$L_origine25
    elif $Nb_boucles_anneaux==6
     L_val=$L_origine
    endif
    R_en_cours={int(${"samj_LCH_or_Lab_to_RGB[] 1,"{/$L_val}","{/$C_origine}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
    G_en_cours={int(${"samj_LCH_or_Lab_to_RGB[] 2,"{/$L_val}","{/$C_origine}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
    B_en_cours={int(${"samj_LCH_or_Lab_to_RGB[] 3,"{/$L_val}","{/$C_origine}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
   else
    H_val_comp={$H_origine_comp+$Angle}
    if $Nb_boucles_anneaux==1
     L_val_comp=$L_origine_comp75
    elif $Nb_boucles_anneaux==3
     L_val_comp=$L_origine_comp50
    elif $Nb_boucles_anneaux==5
     L_val_comp=$L_origine_comp25
    elif $Nb_boucles_anneaux==7
     L_val_comp=$L_origine_comp
    endif
    R_en_cours={int(${"samj_LCH_or_Lab_to_RGB[] 1,"{/$L_val_comp}","{/$C_origine_comp}","{/$H_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
    G_en_cours={int(${"samj_LCH_or_Lab_to_RGB[] 2,"{/$L_val_comp}","{/$C_origine_comp}","{/$H_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
    B_en_cours={int(${"samj_LCH_or_Lab_to_RGB[] 3,"{/$L_val_comp}","{/$C_origine_comp}","{/$H_val_comp}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""})}
   endif
   if $R_en_cours<0 Erreur_Couleur=1 endif
   if $R_en_cours>255 Erreur_Couleur=1 endif
   if $G_en_cours<0 Erreur_Couleur=1 endif
   if $G_en_cours>255 Erreur_Couleur=1 endif
   if $B_en_cours<0 Erreur_Couleur=1 endif
   if $B_en_cours>255 Erreur_Couleur=1 endif
   if $Erreur_Couleur==0 circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,$R_en_cours,$G_en_cours,$B_en_cours,$A_en_cours endif
   if $Nb_boucles==0&&$Nb_boucles_anneaux==6&&$Outline_Reference_Color==1
    circle[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,1,0xFFFFFFFF,0,0,0,255
    circle[-1] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/2},1,$R_val,$G_val,$B_val,$A_en_cours
    circle[-1] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/2},1,0xFFFFFFFF,255,255,255,255
   endif
   Nb_boucles={$Nb_boucles+1}
  done

  Nb_boucles_anneaux={$Nb_boucles_anneaux+1}

 done

#################################################
##                                             ##
##          FIN samj_Color_Palettes            ##
##                                             ##
#################################################

#################################################################################################################################################################################################
#
#                                                                                                                                                                                        CONTOURS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_contours :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Contours</b>
#################################################
##                                             ##
##           samj_Edges_Offsets_Dots           ##
##                                             ##
#################################################

#@gui Edges Offsets Dots : samj_Edges_Offsets_Dots, samj_Edges_Offsets_Dots
#@gui :_=note("<span foreground="orangered"><b>Edges Offsets</b></span>")
#@gui : 1 - Smoothness = float(1.3,0,10)
#@gui : 2 - Threshold = float(40,0,50)
#@gui : 3 - Scale = int(18,4,32)
#@gui :_=note("<span foreground="orangered"><b>Points/Dots</b></span>")
#@gui : 4 - Rayon/Radius = int(2,1,4)
#@gui : 5 - Densité/Density = int(4,1,5)
#@gui : 6 - Couleurs = float(0,-0.1,0.2)
#@gui :_=note("<span foreground="orangered"><b>Fond/Background</b></span>")
#@gui : 7-8-9-10 Couleur/Color = color(0,0,0,0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/19</i>.</small>")

samj_Edges_Offsets_Dots :
repeat $! l[$>]
+fx_edge_offsets $1,$2,$3,1,0,2,50,50
to_rgba[-1]
replace_color[-1] 1,0,255,255,255,255,0,0,0,0
{w},{h},1,4
fill_color[-1] 0,0,0,0
Diam={$4*2}
Dens={6-$5}
IndX=$4
PosX=0
PosY=$4
IncrX={$Diam+$Dens}
repeat {{h}/$Diam}
	repeat {w}
		PosX=$IndX
		+crop[-2] $PosX,$PosY,$PosX,$PosY,0
		if {iM}==0 AppliForme=0 else AppliForme=1 endif
		rm[-1]
		if $AppliForme==1
			+crop[-3] $PosX,$PosY,$PosX,$PosY,0
			circle[-2] $PosX,$PosY,$4,1,{I(#-1)},255
			rm[-1]
			IndX={$IndX+$IncrX}
		else
			IndX={$IndX+$Dens}
		endif
		if $IndX>{w} break endif
	done
	IndX=$4
	PosY={$PosY+$Diam+$4}
done
mirror x permute yx	
IndX=$4
PosX=0
PosY=$4
repeat {{h}/$Diam}
	repeat {w}
		PosX=$IndX
		+crop[-2] $PosX,$PosY,$PosX,$PosY,0
		if {iM}==0 AppliForme=0 else AppliForme=1 endif
		rm[-1]
		if $AppliForme==1
			+crop[-3] $PosX,$PosY,$PosX,$PosY,0
			circle[-2] $PosX,$PosY,$4,1,{I(#-1)},255
			rm[-1]
			IndX={$IndX+$IncrX}
		else
			IndX={$IndX+$Dens}
		endif
		if $IndX>{w} break endif
	done
	IndX=$4
	PosY={$PosY+$Diam+$4}
done
permute yxzc mirror x
dilate_circ[-1] 3
rm[-2,-3]
if $6!=5 pow {1+$6} c 0,255 endif
if {$7+$8+$9+$10}>0 {w},{h},1,4 fill_color[-1] $7,$8,$9,$10 rv blend alpha endif
endl done

#################################################
##                                             ##
##         FIN samj_Edges_Offsets_Dots         ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Contours_Coins_Vifs           ##
##                                             ##
#################################################
#@gui Contours Coins Vifs : samj_Contours_Coins_Vifs, samj_Contours_Coins_Vifs
#@gui :_=separator()
#@gui : 1 - Autoindex (Détails) = int(20,2,255)
#@gui : 2 - Dilate (Étendue Zones/Size Areas) = int(20,2,100)
#@gui : 3 - Grosseur Traits/Thickness Lines = int(2,1,100)
#@gui : 4 - Rendu/Rendering = choice(0,"Couleurs","Blanc","Noir")
#@gui :_=note("<span foreground="orangered"><b>Couleurs/Colors</b></span>")
#@gui : 5 - Intensité/intensity = float(0.05,-0.1,0.2)
#@gui :_=note("<span foreground="orangered"><b>Flou/Blur</b></span>")
#@gui : 6 - Étendue/Extent = int(0,0,300)
#@gui : 7 - Intensité/Intensity = float(0,-0.05,0.2)
#@gui :_=note("<span foreground="orangered"><b>Fond/Background</b></span>")
#@gui : 8-9-10-11 Color = color(0,0,0,0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/15</i>.</small>")

samj_Contours_Coins_Vifs :
repeat $! l[$>]
autoindex $1 dilate $2
if $3==1
	isophotes 40 isophotes {$1*2}
else
	+erode[-1] 2 dilate[-1] 3 isophotes 40 blend alpha isophotes {$1*2} dilate $3
endif
if $4==0
	if $6>0
		+pow {1+$5} c[-1] 0,255 dilate[-2] {$6} spread[-2] 1 blur[-2] 2 n[-2] 64,192 pow[-2] {1+$7} blend alpha
	else
		pow {1+$5} c 0,255
	endif
elif $4==1||$4==2
	repeat 128 +- blend add done
	if $4==2 replace_color[-1] 1,0,255,255,255,255,0,0,0,255 endif
	if $6>0
		+- dilate[-2] {$6} spread[-2] 1 blur[-2] 2 n[-2] 64,192 pow[-2] {1+$7} blend alpha
	endif
endif
if {$8+$9+$10+$11}>0 {w},{h},1,4 fill_color[-1] $8,$9,$10,$11 rv blend alpha endif
endl done
#################################################
##                                             ##
##         FIN samj_Contours_Coins_Vifs        ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Quelques_Isophotes_C           ##
##                                             ##
#################################################

#@gui Quelques Isophotes C : samj_Quelques_Isophotes_C, samj_Quelques_Isophotes_C
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-quelques.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-quelques.html")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Flou/Blur = float(0,0,20)
#@gui : Normalize Min = int(0,0,255)
#@gui : Normalize Max = int(160,0,255)
#@gui : Cut Min = int(0,0,255)
#@gui : Cut Max = int(80,0,255)
#@gui : Isophotes = int(6,2,64)
#@gui : Épaisseur/thickness  = int(4,1,64)
#@gui : Decalage X = int(1,-20,+20)
#@gui : Decalage Y = int(1,-20,+20)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Wind</b></span>")
#@gui : Wind = bool(0)
#@gui : Amplitude = int(20,1,100)
#@gui : Angle = float(45,0,360)
#@gui : Attenuation = float(0.7,0,1)
#@gui : Threshold = int(20,1,50)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/28</i>.</small>")

samj_Quelques_Isophotes_C :

	blur $1
	n $2,$3
	c $4,$5
	n 0,255
	isophotes $6
	repeat $7
		+-
		shift[-1] $8,0
		blend alpha
		+-
		shift[-1] 0,$9
		blend alpha
		if $8>-1&&$9>-1 shift[-1] -$8,-$9 endif
		if $8<0&&$9<0 shift[-1] {abs($8)},{abs($9)} endif
		if $8<0&&$9>-1 shift[-1] {abs($8)},-$9 endif
		if $8>-1&&$9<0 shift[-1] -$8,{abs($9)} endif
	done
	if $10==1 wind $11,$12,$13,$14 endif

#################################################
##                                             ##
##       FIN samj_Quelques_Isophotes_C         ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_Carte_De_Repoussage          ##
##                                             ##
#################################################

#@gui Carte De Repoussage  : samj_Carte_De_Repoussage , samj_Carte_De_Repoussage(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>15 Matrices Emboss Pivotees</b></span>")
#@gui : Matrices Emboss = int(30,0,59)
#@gui : Gris/Gray = bool(1)
#@gui : Flou/Blur = float(0,0,32)
#@gui : Netteté/Sharpen = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/03/22</i>.</small>")

samj_Carte_De_Repoussage :

 if $3>0 blur $3 endif
 if $1==0
  (0,1,-1;0,1,-1;0,1,-1)
 elif $1==1
  (-1,-1,-1;1,1,1;0,0,0)
 elif $1==2
  (-1,1,0;-1,1,0;-1,1,0)
 elif $1==3
  (0,0,0;1,1,1;-1,-1,-1)
 elif $1==4
  (0,1,0;0,0,0;0,-1,0)
 elif $1==5
  (0,0,0;1,0,-1;0,0,0)
 elif $1==6
  (0,-1,0;0,0,0;0,1,0)
 elif $1==7
  (0,0,0;-1,0,1;0,0,0)
 elif $1==8
  (1,0,0;0,0,0;0,0,-1)
 elif $1==9
  (0,0,-1;0,0,0;1,0,0)
 elif $1==10
  (-1,0,0;0,0,0;0,0,1)
 elif $1==11
  (0,0,1;0,0,0;-1,0,0)
 elif $1==12
  (2,0,0;0,-1,0;0,0,-1)
 elif $1==13
  (0,0,-1;0,-1,0;2,0,0)
 elif $1==14
  (-1,0,0;0,-1,0;0,0,2)
 elif $1==15
  (0,0,2;0,-1,0;-1,0,0)
 elif $1==16
  (1,1,-1;1,3,-1;1,-1,-1)
 elif $1==17
  (-1,-1,-1;1,3,-1;1,1,1)
 elif $1==18
  (-1,-1,1;-1,3,1;-1,1,1)
 elif $1==19
  (1,1,1;-1,3,1;-1,-1,-1)
 elif $1==20
  (-2,-1,0;-1,1,1;0,1,2)
 elif $1==21
  (0,1,2;-1,1,1;-2,-1,0)
 elif $1==22
  (2,1,0;1,1,-1;0,-1,-2)
 elif $1==23
  (0,-1,-2;1,1,-1;2,1,0)
 elif $1==24
  (1,0,0,0,0;0,1,0,0,0;0,0,0,0,0;0,0,0,-1,0;0,0,0,0,-1)
 elif $1==25
  (0,0,0,0,1;0,0,0,1,0;0,0,0,0,0;0,-1,0,0,0;-1,0,0,0,0)
 elif $1==26
  (-1,0,0,0,0;0,-1,0,0,0;0,0,0,0,0;0,0,0,1,0;0,0,0,0,1)
 elif $1==27
  (0,0,0,0,-1;0,0,0,-1,0;0,0,0,0,0;0,1,0,0,0;1,0,0,0,0)
 elif $1==28
  (0,1,0,0,0;0,0,1,0,0;0,0,0,0,0;0,0,-1,0,0;0,0,0,-1,0)
 elif $1==29
  (0,0,0,0,0;0,0,0,0,1;0,-1,0,1,0;-1,0,0,0,0;0,0,0,0,0)
 elif $1==30
  (0,1,0,0,0;0,0,1,0,0;0,0,0,0,0;0,0,-1,0,0;0,0,0,-1,0)
 elif $1==31
  (0,0,0,0,0;0,0,0,0,1;0,-1,0,1,0;-1,0,0,0,0;0,0,0,0,0)
 elif $1==32
  (1,0,0,0,0,0,0;0,1,0,0,0,0,0;0,0,1,0,0,0,0;0,0,0,0,0,0,0;0,0,0,0,-1,0,0;0,0,0,0,0,-1,0;0,0,0,0,0,0,-1)
 elif $1==33
  (0,0,0,0,0,0,1;0,0,0,0,0,1,0;0,0,0,0,1,0,0;0,0,0,0,0,0,0;0,0,-1,0,0,0,0;0,-1,0,0,0,0,0;-1,0,0,0,0,0,0)
 elif $1==34
  (-1,0,0,0,0,0,0;0,-1,0,0,0,0,0;0,0,-1,0,0,0,0;0,0,0,0,0,0,0;0,0,0,0,1,0,0;0,0,0,0,0,1,0;0,0,0,0,0,0,1)
 elif $1==35
  (0,0,0,0,0,0,-1;0,0,0,0,0,-1,0;0,0,0,0,-1,0,0;0,0,0,0,0,0,0;0,0,1,0,0,0,0;0,1,0,0,0,0,0;1,0,0,0,0,0,0)
 elif $1==36
  (-1,0,0;0,1,0;0,0,0)
 elif $1==37
  (0,0,0;0,1,0;-1,0,0)
 elif $1==38
  (0,0,0;0,1,0;0,0,-1)
 elif $1==39
  (0,0,-1;0,1,0;0,0,0)
 elif $1==40
  (-1,-1,-1,-1,0;-1,-1,-1,0,1;-1,-1,0,1,1;-1,0,1,1,1;0,1,1,1,1)
 elif $1==41
  (0,1,1,1,1;-1,0,1,1,1;-1,-1,0,1,1;-1,-1,-1,0,1;-1,-1,-1,-1,0)
 elif $1==42
  (1,1,1,1,0;1,1,1,0,-1;1,1,0,-1,-1;1,0,-1,-1,-1;0,-1,-1,-1,-1)
 elif $1==43
  (0,-1,-1,-1,-1;1,0,-1,-1,-1;1,1,0,-1,-1;1,1,1,0,-1;1,1,1,1,0)
 elif $1==44
  (-1,-1,0;-1,0,1;0,1,1)
 elif $1==45
  (0,1,1;-1,0,1;-1,-1,0)
 elif $1==46
  (1,1,0;1,0,-1;0,-1,-1)
 elif $1==47
  (0,-1,-1;1,0,-1;1,1,0)
 elif $1==48
  (-1,0,0;0,0,0;0,0,1)
 elif $1==49
  (0,0,1;0,0,0;-1,0,0)
 elif $1==50
  (1,0,0;0,0,0;0,0,-1)
 elif $1==51
  (0,0,-1;0,0,0;1,0,0)
 elif $1==52
  (-2,-1,0;-1,0,1;0,1,2)
 elif $1==53
  (0,1,2;-1,0,1;-2,-1,0)
 elif $1==54
  (2,1,0;1,0,-1;0,-1,-2)
 elif $1==55
  (0,-1,-2;1,0,-1;2,1,0)
 elif $1==56
  (1,1,0,0,0;0,1,1,0,0;1,1,0,-1,-1;0,0,-1,-1,0;0,0,0,-1,-1)
 elif $1==57
  (0,0,-1,0,-1;0,0,-1,-1,-1;0,1,0,-1,0;1,1,1,0,0;1,0,1,0,0)
 elif $1==58
  (-1,-1,0,0,0;0,-1,-1,0,0;-1,-1,0,1,1;0,0,1,1,0;0,0,0,1,1)
 elif $1==59
  (0,0,1,0,1;0,0,1,1,1;0,-1,0,1,0;-1,-1,-1,0,0;-1,0,-1,0,0)
 endif
 convolve[-2] [-1]
 k[-2]
 if $4>0 sharpen {$4*100} endif
 n 0,255
 if $2==1 to_gray endif

#################################################
##                                             ##
##        FIN samj_Carte_De_Repoussage         ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Contours_Blancs             ##
##                                             ##
#################################################

#@gui Contours Blancs  : samj_Contours_Blancs , samj_Contours_Blancs_preview(0)
#@gui : sep = separator()
#@gui :_=note("<b><u>Option Quantize</u></b>")
#@gui : Quantize = choice(1,"No","A","B","A + B")
#@gui : Levels = int(16,2,256)
#@gui : Blur = float(2,0,100)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(0,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Blanc Contours</u></b></span>")
#@gui : White Level Contour = int(3,0,12)
#@gui :_=note("<span foreground="orangered"><b><u>Segment Watershed</u></b></span>")
#@gui : Edge threshold = float(2,0,15)
#@gui : Smoothness = float(1,0,5)
#@gui : Channel(s) = choice("All","RGBA [all]","RGB [all]","RGB [red]","RGB [green]","RGB [blue]","RGBA [alpha]","Linear RGB [all]","Linear RGB [red]","Linear RGB [green]","Linear RGB [blue]","YCbCr [luminance]","YCbCr [blue-red chrominances]","YCbCr [blue chrominance]","YCbCr [red chrominance]","YCbCr [green chrominance]","Lab [lightness]","Lab [ab-chrominances]","Lab [a-chrominance]","Lab [b-chrominance]","Lch [ch-chrominances]","Lch [c-chrominance]","Lch [h-chrominance]","HSV [hue]","HSV [saturation]","HSV [value]","HSI [intensity]","HSL [lightness]","CMYK [cyan]","CMYK [magenta]","CMYK [yellow]","CMYK [key]","YIQ [luma]","YIQ [chromas]")
#@gui : Value action = choice("None","Cut","Normalize")
#@gui :_=note("<span foreground="orangered"><b><u>Edges Offsets</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Threshold = float(15,0,50)
#@gui : Scale = int(4,0,32)
#@gui : Thickness = int(1,0,16)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>samj</i>.      Latest update: <i>2019/12/16</i>.</small>")

samj_Contours_Blancs :

i [-1]
if $1==1
 blur[-1,-2] $3
 quantize[-1] $2,1,1
elif $1==2
 blur[-1,-2] $3
 quantize[-2] $2,1,1
elif $1==3
 blur[-1,-2] $3
 quantize[-1,-2] $2,1,1
endif
fx_gradient_norm[-1] $4,$5,$6,$7,$8
isophotes[-1] 8
to_graya[-1]
repeat $9
 i [-1]
 blend[-1,-2] add
done
fx_segment_watershed[-2] $10,$11,$12,$13
fx_edge_offsets[-2] $14,$15,$16,$17,1
to_rgba[-1,-2]
replace_color[-1,-2] 0%,0,0,0,0,255,0,0,0,0
blend[-1,-2] alpha

samj_Contours_Blancs_preview :
  gui_split_preview "samj_Contours_Blancs $*",$-1

#################################################
##                                             ##
##          FIN samj_Contours_Blancs           ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Quelques_Isophotes_B          ##
##                                             ##
#################################################

#@gui Quelques Isophotes B  : samj_Quelques_Isophotes_B , samj_Quelques_Isophotes_B (1)
#@gui : Nb Décomposition Couleurs = int(16,2,32)
#@gui : Variation Couleurs % = Float(100,25,100)
#@gui : Type Variation Couleurs = choice(0,"Min","Max","Min Max")
#@gui : Dilate = int(0,0,8)
#@gui : Isophotes = int(4,2,16)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2017/01/14</i>.</small>")

samj_Quelques_Isophotes_B :

if $3==2
 +Je_passe_l_hiver_en_Floride[-1]
 samj_Fonction_Quelques_Isophotes_B[-1] $1,$2,0,$4,$5
 rv[-1,-2]
 samj_Fonction_Quelques_Isophotes_B[-1] $1,$2,1,$4,$5
 blend[-1,-2] alpha
else
 samj_Fonction_Quelques_Isophotes_B $1,$2,$3,$4,$5
endif

samj_Fonction_Quelques_Isophotes_B :
 Nb_Decomposition_Couleurs=$1
 Variation_Couleurs=$2
 Type_Variation_Couleurs=$3
 Dilatation=$4
 Nb_Isophotes=$5

 Val_min={im}
 Val_max={iM}
 Variation_Par_Boucle={{{iM}-{im}}/{$Nb_Decomposition_Couleurs*$Variation_Couleurs}}
 Nb_Boucles=0

 +Je_passe_l_hiver_en_Floride[-1]
 repeat $Nb_Decomposition_Couleurs
  if $Type_Variation_Couleurs==0
   c {$Val_min+{$Variation_Par_Boucle*$Nb_Boucles}},$Val_max
  elif $Type_Variation_Couleurs==1
   c $Val_min,{$Val_max-{$Variation_Par_Boucle*$Nb_Boucles}}
  endif
  n 0,255
  isophotes[-1] $Nb_Isophotes
  if $Nb_Boucles>0
   if $Dilatation>0 dilate_circ[-1] {$Dilatation+1} endif
   blend[-1,-2] alpha
  endif
  Nb_Boucles={$Nb_Boucles+1}
  +Je_passe_l_hiver_en_Floride[-2]
 done
 rm[-1,-3]

#################################################
##                                             ##
##        FIN samj_Quelques_Isophotes_B        ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Test_Mauvais_Contours          ##
##                                             ##
#################################################
# samj_Test_Mauvais_Contours -18,0,0,2,1.25,0,255,0,80,1,1,24,0
#@gui Test Mauvais Contours : samj_Test_Mauvais_Contours, samj_Test_Mauvais_Contours(0)
#@gui :_=note("samj_Test_Mauvais_Contours")
#@gui : Spread -  Watershed + = float(0,-30,30)
#@gui : Déformation A = int(0,0,20)
#@gui : Déformation B = int(0,0,20)
#@gui : Itérations = int(2,1,10)
#@gui : Pow = float(1,0.1,3)
#@gui : Na = int(0,0,255)
#@gui : Nb = int(255,0,255)
#@gui : Ca = int(0,0,255)
#@gui : Cb = int(255,0,255)
#@gui : Negate = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend</b></span>")
#@gui : Blend = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape area max","Shape area max0","Shape area min","Shape area min0","Shape average","Shape average0","Shape min","Shape min0","Shape max","Shape max0",
#@gui : "Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value","Vivid light","Xor"}
#@gui : Reverse = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2016/12/30</i>.</small>")

samj_Test_Mauvais_Contours:

mode=${arg\ 1+$12,add,alpha,and,average,blue,burn,darken,difference,\
   divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
   hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
   multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
   shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,\
   shapeaverage,shapeaverage0,shapemin,shapemin0,shapemax,shapemax0,\
   softburn,softdodge,softlight,screen,stamp,subtract,value,\
   vividlight,xor}

if $11==1 +Je_passe_l_hiver_en_Floride[-1] endif
+Je_passe_l_hiver_en_Floride[-1]
if $1<0 spread[-1] {abs($1/4)},{abs($1/4)} endif
if $1>0 segment_watershed[-1] {int($1)} endif
if $2>0 samj_Random_Small_Deformations[-1] $2,5,3 endif
if $3>0 samj_Random_Small_Deformations[-2] $3,5,3 endif
blend[-1,-2] edges
gradient_norm[-1]
n[-1] 0,255
repeat $4
 +Je_passe_l_hiver_en_Floride[-1]
 blend[-1,-2] add
 pow[-1] $5
 n[-1] $6,$7
 c[-1] $8,$9
done
n[-1] 0,255
if $10>0 negate[-1] endif
if $11==1
 if $13==1 rv[-1,-2] endif
 blend[-1,-2] $mode
endif

#################################################
##                                             ##
##       FIN samj_Test_Mauvais_Contours        ##
##                                             ##
#################################################
#################################################
##                                             ##
##                samj_Coloriage               ##
##                                             ##
#################################################

#@gui Coloriage : samj_Coloriage, samj_Coloriage_preview
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Filtre Lent</u></b></span>")
#@gui :_=note("<span foreground="orangered"><b><u>Pour obtenir un contour de 1 couleur</u></b></span>")
#@gui : sep = separator(),
#@gui : Dimension Max Echantillon= int(612,256,800)
#@gui : Limites = int(255,1,255)
#@gui : Flou Lissage = float(2,0,10)
#@gui : Isophotes Nb Levels = int(6,4,16)
#@gui : Dilatation = int(2,1,16)
#@gui : Couleur Contour = color(0,0,0,255)
#@gui : Dimensions Origine = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/04</i>.</small>")

samj_Coloriage:

Dimension_Max=$1
Limite=$2
Flou_Lissage=$3
Isophotes_Nb_Levels=$4
Dilatation=$5
R_a=$6
V_a=$7
B_a=$8
A_a=$9
Dimensions_Origine=$10

Largeur_Origine={w}
Hauteur_Origine={h}
OrigineH=0
OrigineV=-1
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0

 if $Hauteur_Origine>$Largeur_Origine
  Largeur_A={round({$Largeur_Origine/$Hauteur_Origine*$Dimension_Max})}
  Hauteur_A=$Dimension_Max
 else
  Largeur_A=$Dimension_Max
  Hauteur_A={round({$Hauteur_Origine/$Largeur_Origine*$Dimension_Max})}
 endif
 resize[-1] $Largeur_A,$Hauteur_A
 n[-1] 0,255
 c[-1] 0,$Limite
 n[-1] 0,255
 c[-1] {255-$Limite},255
 n[-1] 0,255
 blur[-1] $Flou_Lissage
 isophotes[-1] $Isophotes_Nb_Levels
 dilate[-1] $Dilatation
 repeat $Hauteur_A
  OrigineH=0
  OrigineV={$OrigineV+1}
  repeat $Largeur_A
   couleur_pixel={I($OrigineH,$OrigineV)}
   #rouge_pixel={arg(1,$couleur_pixel)}
   #vert_pixel={arg(2,$couleur_pixel)}
   #bleu_pixel={arg(3,$couleur_pixel)}
   alpha_pixel={arg(4,$couleur_pixel)}
   if $alpha_pixel>0
    #point[-1] $OrigineH,$OrigineV,0,1,$rouge_pixel,$vert_pixel,$bleu_pixel,255
    point[-1] $OrigineH,$OrigineV,0,1,$R_a,$V_a,$B_a,$A_a
   endif
   OrigineH={$OrigineH+1}
  done
 done
 if $Dimensions_Origine==1 resize[-1] $Largeur_Origine,$Hauteur_Origine endif

samj_Coloriage_preview :
 samj_Coloriage[-1] 256,$2,$3,$4,$5,$6,$7,$8,$9,0

#################################################
##                                             ##
##              FIN samj_Coloriage             ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_Quelques_Isophotes           ##
##                                             ##
#################################################

#@gui Quelques Isophotes  : samj_Quelques_Isophotes , samj_Quelques_Isophotes (1)
#@gui : Épaisseur = int(10,1,32)
#@gui : Précision = int(10,1,32)
#@gui : Coeff précision = float(1,0.1,8)
#@gui : Coeff Flou = float(0.02,0,1)
#@gui : Isophotes = int(8,2,32)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/23</i>.</small>")

samj_Quelques_Isophotes :

Epaisseur=$1
Precision=$2
Coeff_Precision_Pixelise=$3
Coeff_Precision_Flou=$4
Nb_Isophotes=$5

Nb_Boucles=0

+Je_passe_l_hiver_en_Floride[-1]
repeat $Epaisseur
 pixelize[-1] {1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)},{1+round({$Precision+$Epaisseur-$Nb_Boucles}*$Coeff_Precision_Pixelise)}
 blur[-1]  {{$Precision+$Epaisseur+$Nb_Boucles}*$Coeff_Precision_Flou}
 isophotes[-1] $Nb_Isophotes
 if $Nb_Boucles>0 blend[-1,-2] alpha endif
 Nb_Boucles={$Nb_Boucles+1}
 +Je_passe_l_hiver_en_Floride[-2]
done
rm[-1,-3]

#################################################
##                                             ##
##         FIN samj_Quelques_Isophotes         ##
##                                             ##
#################################################
#################################################
##                                             ##
##     samj_Scintillements_Colores_Contours    ##
##                                             ##
#################################################

#### samj_Scintillements_Colores_Contours 3,10,6,8,8,0.5,400,18,0,70,0,1,0,0,0,255
#### samj_Scintillements_Colores_Contours 2,8,6,6,6,0.4,400,18,15,70,0,1,0,0,0,255
# 20160204 ajout overlay

#@gui Scintillements Colores Contours  : samj_Scintillements_Colores_Contours, samj_Scintillements_Colores_Contours(1)
#@gui :_=note("samj_Scintillements_Colores_Contours")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limites via Isophote</b></span>")
#@gui : Flou = int(0,0,10)
#@gui : Isophotes = int(8,6,16)
#@gui : Dilate = int(0,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Scintillement</b></span>")
#@gui : Résolution L = int(8,1,32)
#@gui : Résolution H = int(8,1,32)
#@gui : Dimension Variation = float(1,0.3,3)
#@gui : Variation Couleur = int(768,1,768)
#@gui : Scintillement = int(12,3,24)
#@gui : Angle Décalage = float(0,0,120)
#@gui : Variation Aléatoire = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Flou</b></span>")
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Overlay</b></span>")
#@gui : Overlay = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond / Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/04</i>.</small>")

samj_Scintillements_Colores_Contours :

Val_Flou=$1
Val_Isophotes=$2
Val_Dilate=$3
Resolution_L=$4
Resolution_H=$5
Dimension_Variation=$6
Variation_Couleur=$7
Scintillement=$8
Angle_Decalage=$9
Variation_Aleatoire=$10
Flou_Contours=$11
Mode_Overlay=$12
Couleur_Fond_r=$13
Couleur_Fond_v=$14
Couleur_Fond_b=$15
Couleur_Fond_a=$16

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0
Hauteur=$Resolution_H
Largeur=$Resolution_L
Rayon_Scintillement_Origine={{$Resolution_H+$Resolution_L}*$Dimension_Variation}
Rayon_Scintillement=0
Angle_Variation={360/$Scintillement}
Angle_Variation_En_Cours=0
Coeff_Variation_Aleatoire=0

blur[-1] $Val_Flou
to_rgba[-1]
isophotes[-1] $Val_Isophotes
dilate_circ[-1] $Val_Dilate

$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

repeat $Largeur_Origine/($Resolution_L+$Resolution_L)
 repeat $Hauteur_Origine/($Resolution_H+$Resolution_H)
  couleur_pixel=${at_ancien[-2]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  alpha_pixel=${arg\ 4,$couleur_pixel}
  Moyenne_couleur={1+{{$rouge_pixel+$vert_pixel+$bleu_pixel}/$Variation_Couleur}}
  Rayon_Scintillement={$Rayon_Scintillement_Origine*$Moyenne_couleur}
  Angle_Variation_En_Cours=0

  if $alpha_pixel>1
   repeat $Scintillement
    Angle_Variation_En_Cours={$Angle_Variation_En_Cours+$Angle_Variation+$Angle_Decalage}
    if $Variation_Aleatoire==0
     line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*{cos({pi/180*$Angle_Variation_En_Cours})}}},{$Hauteur+{$Rayon_Scintillement*{sin({pi/180*$Angle_Variation_En_Cours})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
    else
     Coeff_Variation_Aleatoire={1+{{round(u)*$Variation_Aleatoire}/100}}
     line[-1] $Largeur,$Hauteur,{$Largeur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{cos({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},{$Hauteur+{$Rayon_Scintillement*$Coeff_Variation_Aleatoire*{sin({pi/180*$Angle_Variation_En_Cours*$Coeff_Variation_Aleatoire})}}},1,$rouge_pixel,$vert_pixel,$bleu_pixel,$alpha_pixel
    endif
   done
  endif
  Hauteur={$Hauteur+$Resolution_H+$Resolution_H}
 done
 Largeur={$Largeur+$Resolution_L+$Resolution_L}
 Hauteur=$Resolution_H
done

rm[-2]

if $Flou_Contours>0 blur[-1] $Flou_Contours,0 endif

if $Mode_Overlay==1
 +Je_passe_l_hiver_en_Floride[-1]
 blend[-2,-1] overlay,1,0
endif

#################################################
##                                             ##
##  FIN samj_Scintillements_Colores_Contours   ##
##                                             ##
#################################################


#################################################
##                                             ##
##            samj_Colored_Outlines            ##
##                                             ##
#################################################

#@gui Colored Outlines  : samj_Colored_Outlines, samj_Colored_Outlines(1)
#@gui :_=note("samj_Colored_Outlines")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blur</b></span>")
#@gui : Axes = choice(0,"XY","X","Y")
#@gui : Blur = float(2,0,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Isophote</b></span>")
#@gui : Isophote = float(8,6,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth</b></span>")
#@gui : Smooth = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate = int(0,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/29</i>.</small>")

samj_Colored_Outlines :
Axe_blur=$1
Valeur_blur=$2
Valeur_isophotes=$3
Iterations_smooth=$4
Valeur_dilate=$5
Couleur_Fond_r=$6
Couleur_Fond_v=$7
Couleur_Fond_b=$8
Couleur_Fond_a=$9

Largeur_Origine={w}
Hauteur_Origine={h}

to_rgba[-1]

if $Axe_blur==0
 blur[-1] xy,{$Valeur_blur}
elif $Axe_blur==1
 blur[-1] x,{$Valeur_blur}
elif $Axe_blur==2
 blur[-1] y,{$Valeur_blur}
endif

isophotes[-1] $Valeur_isophotes

if $Iterations_smooth>0 fx_smooth_diffusion[-1] 0.7,0.3,0.6,1.1,15,$Iterations_smooth,2,0,24 endif

dilate_circ[-1] $Valeur_dilate

$Largeur_Origine,$Hauteur_Origine,1,4
fill_color[-1] $Couleur_Fond_r,$Couleur_Fond_v,$Couleur_Fond_b,$Couleur_Fond_a

gimp_blend_1651[-2,-1] 1,0,1,0,1

#################################################
##                                             ##
##           FIN samj_Colored_Outlines         ##
##                                             ##
#################################################


#################################################
##                                             ##
##           samj_Contours_Colores             ##
##                                             ##
#################################################

#### samj_Contours_Colores 1.1,2,40,5,0
#### samj_Contours_Colores 1.06,10.2,40,0,0

#@gui Contours Colores  : samj_Contours_Colores, samj_Contours_Colores(1)
#@gui :_=note("samj_Contours_Colores")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Puissance / Pow = float(1.1,1,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Segment</b></span>")
#@gui : Edge threshold = float(2,0,15)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Cut</b></span>")
#@gui : Couper / Cut = int(40,0,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dilate</b></span>")
#@gui : Dilate Contours = int(0,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradation Spread</b></span>")
#@gui : Spread = float(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/25</i>.</small>")

samj_Contours_Colores :

Puissance=$1
Edge_threshold=$2
Couper_Cut=$3
Dilate_Contours=$4
Degradation_Spread=$5

pow[-1] $Puissance
c[-1] 0,255
fx_segment_watershed[-1] $2,1,0,2,0
+Je_passe_l_hiver_en_Floride[-1]
fx_gradient_norm[-1] 0,0.5,0,100,0,0
c[-1] $Couper_Cut,255
n[-1] 0,255
if $Dilate_Contours>1 dilate_circ[-1,-2] $Dilate_Contours endif
if $Degradation_Spread>1 spread[-1,-2] $Degradation_Spread endif
blend[-2,-1] darken,1,0

#################################################
##                                             ##
##          FIN samj_Contours_Colores          ##
##                                             ##
#################################################


#################################################
##                                             ##
##               samj_Skeletation              ##
##                                             ##
#################################################

#### samj_Skeletation 4,50,100,0,0,1

#@gui Skeletation  : samj_Skeletation, samj_Skeletation(1)
#@gui :_=note("samj_Skeletation")
#@gui :_=note("<span foreground="orangered"><small>Skeleton</small></span>")
#@gui : Skeletation = int(2,2,10)
#@gui : Smoothness A % = int(100,10,100)
#@gui : Smoothness B % = int(100,10,100)
#@gui :_=note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Blend = bool(0)
#@gui : Mode = choice{0,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/20</i>.</small>")

samj_Skeletation :

 Skeletation=$1
 Variation_SmoothnessA={$2/$Skeletation/100}
 Variation_SmoothnessB={$3/$Skeletation/100}
 Valider_Blend=$4
 Mode_blend=$5
 Opacity_blend=$6

 Smoothness=0
 index=0

 +Je_passe_l_hiver_en_Floride[-1]

 repeat $Skeletation
  +Je_passe_l_hiver_en_Floride[0]
  fx_skeleton[-1] 0,$Smoothness,0,0,0
  if $index>0 blend[-2,-1] add,1,0 endif
  Smoothness={$Smoothness+$Variation_SmoothnessA}
  index={$index+1}
 done

 fx_local_orientation[-2] 0,0,100,0,0,0

 Smoothness=0
 index=0

 repeat $Skeletation
  +Je_passe_l_hiver_en_Floride[1]
  fx_skeleton[-1] 0,$Smoothness,0,0,0
  if $index>0 blend[-2,-1] add,1,0 endif
  Smoothness={$Smoothness+$Variation_SmoothnessB}
  index={$index+1}
 done
 blend[-2,-1] add,1,0
 rm[-2]

 if $Valider_Blend==0
  rm[0]
 else
  gimp_blend_1651[0,-1] $Mode_blend,2,$Opacity_blend,0 # add
 endif

#################################################
##                                             ##
##             FIN samj_Skeletation            ##
##                                             ##
#################################################


#################################################
##                                             ##
##             samj_Contours_Arrondis          ##
##                                             ##
#################################################
#@gui Contours Arrondis  : samj_Contours_Arrondis, samj_Contours_Arrondis(1)
#@gui :_=note("samj_Contours_Arrondis")
#@gui :_=note("<span foreground="orangered"><small>Lissage</small></span>")
#@gui : Itérations = int(1,1,25)
#@gui : Quantize  = int(3,2,25)
#@gui : Blur  = int(5,5,50)
#@gui :_=note("<span foreground="orangered"><small>Traits</small></span>")
#@gui : Isophotes  = int(10,2,50)
#@gui : RGBA = bool(0)
#@gui : Dilate Circ  = int(0,0,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/04/06</i>.</small>")

samj_Contours_Arrondis :
 Iterations=$1
 Val_Quantize=$2
 Val_Blur=$3
 Val_Isophotes=$4
 RGBA=$5
 Val_Dilate_Circ=$6

 to_rgb[-1]

 repeat $Iterations
  quantize[-1] $Val_Quantize
  blur[-1] {$Val_Blur/10}
  n[-1] 0,255
 done

 isophotes[-1] $Val_Isophotes

 if $RGBA==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Val_Dilate_Circ>1 dilate_circ[-1] $Val_Dilate_Circ endif

#################################################
##                                             ##
##          FIN samj_Contours_Arrondis         ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                    DEFORMATIONS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_deformations :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Deformations</b>
#################################################
##                                             ##
##                samj_Beigne                  ##
##                                             ##
#################################################

#@gui Beigne Donut : samj_Beigne, samj_Beigne
#@gui :_=link("Documentation","https://samjcreations.blogspot.com/2021/01/samuser-avec-gmic-gimp-filtre-beigne.html")
#@gui :_=note("Bonne Année 2021")
#@gui : 1 - Trou De Beigne/Donut Hole = float(100,0,300)
#@gui : 2 - Effet/Effect = choice(0,"Circulaire/Circular","Carré/Square")
#@gui : 3 - Rotation Angle = choice(0,"0","90","-90","180")
#@gui : 4-5-6-7 Fond/Background = color(0,0,0,0)
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : 8 - Contours = bool(0)
#@gui : 9 - X = int(20,0,300)
#@gui : 10 - Y = int(20,0,300)
#@gui : 11-12-13-14 Couleur/Color = color(255,255,255,255)
#@gui :_=note("<span foreground="orangered"><b>Symétrie/Symmetry</b></span>")
#@gui : 15 - Symétrie/Symmetry = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/01</i>.</small>")

samj_Beigne :
repeat $! l[$>]
Carre=0
Diff=0
to_rgba
if $8==1
	frame_xy $9,$10,$11,$12,$13,$14
endif
if $3==1
	mirror x permute yx
elif $3==2
	permute yxzc mirror x
elif $3==3
	mirror x mirror y
endif
Larg={w}
Haut={h}
if $Larg<$Haut
	Carre=$Haut
	Diff={$Carre-{w}}
	expand_x $Diff,0,0
	crop 0,0,{{w}-$Diff-1},{{h}-1}
endif
if $1>0
	expand_y {$Haut*$1/200},1,0
	Carre={$Haut*{100+$1}/100}
	Diff={$Carre-{w}}
	if $Diff>0
		expand_x $Diff,0,0
		crop 0,0,{{w}-$Diff-1},{{h}-1}
	endif
endif
fill "i(((w-(2*x))^2+(h-(2*y))^2)^0.5)" # Création pour ce filtre
if $15==1
	fx_symmetrizoscope 3,45,0,0
	rotate 45,2,0
	autocrop
endif
if $2==1
	fx_square_circle 0,1,0,0,0,0,0 # Fonction par C. Fong http://squircular.blogspot.com/2015/09/mapping-circle-to-square.html
endif
replace_color 1,0,0,0,0,0,$4,$5,$6,$7
endl done
#################################################
##                                             ##
##              FIN samj_Beigne                ##
##                                             ##
#################################################
#################################################
##                                             ##
##       samj_Random_Small_Deformations        ##
##                                             ##
#################################################

#@gui Random Small Deformations : samj_Random_Small_Deformations, samj_Random_Small_Deformations(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Random_Small_Deformations</span>")
#@gui : Noise Amplitude = float(10,0,200)
#@gui : Dilate = int(5,1,20)
#@gui : Blur = float(3,0,20)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/12/07</i>.</small>")

samj_Random_Small_Deformations :

Val_Bruit=$1
Val_Dilate=$2
Val_Flou=$3

Val_Expand={round({$Val_Bruit+$Val_Dilate+$Val_Flou})*2}

 to_rgba[-1]
 expand_xy[-1] $Val_Expand,0
 100%,100%,1,2
 noise[-1] $Val_Bruit
 dilate[-1] $Val_Dilate
 blur[-1] $Val_Flou
 warp[-2] [-1],1,0,0
 rm[-1]
 autocrop[-1]

#################################################
##                                             ##
##      FIN samj_Random_Small_Deformations     ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_Ecraser_Etirer_V2            ##
##                                             ##
#################################################

#@gui Ecraser Etirer V2  : samj_Ecraser_Etirer_V2 , samj_Ecraser_Etirer_V2_preview(0)
#@gui :_=note("<span foreground="orangered"><b><u>samj_Ecraser_Etirer_V2</u></b></span>")
#@gui : Découpage = int(12,2,32)
#@gui : Effet = choice(0,"A","B","C","D")
#@gui : Taille Origine = bool(0)
#@gui : Pourcentage Step = float(100,1,300)
#@gui : Pourcentage Découpe = float(50,25,75)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>samj</i>.      Latest update: <i>2020/10/24</i>.</small>")

samj_Ecraser_Etirer_V2 :

 Pourcentage_Decoupe=$5
 Largeur_Origine={w}
 Hauteur_Origine={h}

 if $2==0||$2==1
  +Je_passe_l_hiver_en_Floride[-1]
  crop[-1] 100%,$Pourcentage_Decoupe%
  mirror[-2] x
  crop[-2] 100%,{100-$Pourcentage_Decoupe}%
  mirror[-2] x
  if $2==1 mirror[-1,-2] x endif
  samj_Ecraser_Etirer[-1] $1,0,0,1,$4
  samj_Ecraser_Etirer[-2] $1,1,0,1,$4
  if $2==1 mirror[-1,-2] x endif
  append[-1,-2] x
 elif $2==2||$2==3
  permute[-1] yxzc
  +Je_passe_l_hiver_en_Floride[-1]
  crop[-1] 100%,$Pourcentage_Decoupe%
  mirror[-2] x
  crop[-2] 100%,{100-$Pourcentage_Decoupe}%
  mirror[-2] x
  if $2==3 mirror[-1,-2] x endif
  samj_Ecraser_Etirer[-1] $1,0,0,1,$4
  samj_Ecraser_Etirer[-2] $1,1,0,1,$4
  if $2==3 mirror[-1,-2] x endif
  append[-1,-2] x
  permute[-1] yxzc
 endif
 if $3==1 resize $Largeur_Origine,$Hauteur_Origine endif

samj_Ecraser_Etirer_V2_preview :
 gui_split_preview "samj_Ecraser_Etirer_V2 $*",$-1

#################################################
##                                             ##
##         FIN samj_Ecraser_Etirer_V2          ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Ecraser_Etirer             ##
##                                             ##
#################################################

#@gui Ecraser Etirer  : samj_Ecraser_Etirer , samj_Ecraser_Etirer_preview(0)
#@gui :_=note("<span foreground="orangered"><b><u>samj_Ecraser_Etirer</u></b></span>")
#@gui : Découpage = int(12,2,32)
#@gui : Effet = choice(0,"Ecraser le Bas","Ecraser le Haut","Etirer le haut","Etirer le bas")
#@gui : Taille Origine = bool(0)
#@gui : Pivoter Image Origine 90 = bool(0)
#@gui : Pourcentage Step = float(100,1,300)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>samj</i>.      Latest update: <i>2018/04/25</i>.</small>")

samj_Ecraser_Etirer :

 NbSplit=$1
 Effet=$2
 Step={$5/$NbSplit}
 Loop=1
 Largeur_Origine={w}
 Hauteur_Origine={h}
 if $4==1 permute yxzc endif
 split y,$NbSplit
 repeat $NbSplit
  if $Effet==0 # Ecraser le bas
   resize[-$Loop] 100%,{$Step*$Loop}%
  elif $Effet==1 # Ecraser le haut
   resize[-{$NbSplit+1-$Loop}] 100%,{$Step*$Loop}%
  elif $Effet==2 # Etirer le haut
   resize[-$Loop] 100%,{100+{$Step*$Loop}}%
  elif $Effet==3 # Etirer le bas
   resize[-{$NbSplit+1-$Loop}] 100%,{100+{$Step*$Loop}}%
  endif
  Loop={$Loop+1}
 done
 append y
 if $3==1 resize $Largeur_Origine,$Hauteur_Origine endif
 if $4==1 permute yxzc endif

samj_Ecraser_Etirer_preview :
 gui_split_preview "samj_Ecraser_Etirer $*",$-1

#################################################
##                                             ##
##           FIN samj_Ecraser_Etirer           ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Cercle_Polaire             ##
##                                             ##
#################################################

# 2015/05/11 origine

#@gui Cercle Polaire : samj_Cercle_Polaire, samj_Cercle_Polaire(1)
#@gui :_=note("samj_Cercle_Polaire")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Rendu</b></span>")
#@gui : Répétitions = int(1,1,4)
#@gui : Rotation = float(0,0,360)
#@gui : Type Raccord = choice(0,"Sans","A","B","A+B","C")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Array [mirrored]</b></span>")
#@gui : Itérations = int(1,1,4)
#@gui : X-offset (%) = float(0,0,100)
#@gui : Y-offset (%) = float(0,0,100)
#@gui : Array mode = choice(2,"x-axis","y-axis","xy-axes","2xy-axes")
#@gui : Initialization = choice(0,"Original","Mirror X","Mirror Y","Rotate 90 deg.","Rotate 180 deg.","Rotate 270 deg.")
#@gui : Expand size = bool(0)
#@gui : Crop (%) = int(0,0,100)
#@gui :_=note("<span foreground="orangered"><b>Polar To Euclidean</b></span>")
#@gui : X-center (%) = float(50,0,100)
#@gui : Y-center (%) = float(50,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Cercle_Polaire:

 Repetitions=$1
 Angle_Rotation=$2
 Type_Raccord=$3
 Iterations_AM=$4
 X_offset_AM=$5
 Y_offse_AM=$6
 Array_mode_AM=$7
 Initialization_AM=$8
 Expand_size_AM=$9
 Crop_AM=$10
 X_center_PTE=$11
 Y_center_PTE=$12

 Expension=0
 Securite=4000

 to_rgba[-1]
 repeat $Repetitions
  if $Type_Raccord==1||$Type_Raccord==3
   if {w}>{h}
    Expension={round({{{w}-{h}}/2})}
    expand_y[-1] $Expension,1
   elif {w}<{h}
    Expension={round({{{h}-{w}}/2})}
    expand_x[-1] $Expension,1
   endif
  endif
  repeat $Iterations_AM
   #### securité système ####
   if {w}>$Securite||{h}>$Securite
    if {w}>{h}
     resize[-1] $Securite,{$Securite/{w}*{h}}
    else
     resize[-1] {$Securite/{h}*{w}},$Securite
    endif
   endif
   fx_array_mirror[-1] 1,$X_offset_AM,$Y_offse_AM,$Array_mode_AM,$Initialization_AM,$Expand_size_AM,$Crop_AM
  done
  #### securité système ####
  if {w}>$Securite||{h}>$Securite
   if {w}>{h}
    resize[-1] $Securite,{$Securite/{w}*{h}}
   else
    resize[-1] {$Securite/{h}*{w}},$Securite
   endif
  endif
  polar2euclidean[-1] $X_center_PTE%,$Y_center_PTE%,1,1
  if $Type_Raccord==2||$Type_Raccord==3
   if {w}>{h}
    Expension={round({{{w}-{h}}/2})}
    expand_y[-1] $Expension,1
   elif {w}<{h}
    Expension={round({{{h}-{w}}/2})}
    expand_x[-1] $Expension,1
   endif
  endif
  if $Angle_Rotation>0
   if $Type_Raccord==2||$Type_Raccord==3||$Type_Raccord==4
    rotate[-1] $Angle_Rotation,0,1
   endif
   if $Type_Raccord==0||$Type_Raccord==1
    rotate[-1] $Angle_Rotation,0,0
   endif
  endif
  autocrop[-1] 0
  #### securité système ####
  if {w}>$Securite||{h}>$Securite
   if {w}>{h}
    resize[-1] $Securite,{$Securite/{w}*{h}}
   else
    resize[-1] {$Securite/{h}*{w}},$Securite
   endif
  endif
 done

#################################################
##                                             ##
##           FIN samj_Cercle_Polaire           ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                    DEGRADATIONS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_degradations :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Degradations</b>
#################################################
##                                             ##
##       samj_Degradations_Path_Solidify       ##
##                                             ##
#################################################

# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
#@gui Path Et Solidify  : samj_Degradations_Path_Solidify , samj_Degradations_Path_Solidify (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Degradations_Path_Solidify</span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradations Image Origine</b></span>")
#@gui : Pixelise = int(0,0,32)
#@gui : Spread = int(0,0,32)
#@gui : Deform = int(0,0,10)
#@gui : Isophotes = int(0,0,15)
#@gui : Blur = float(0,0,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Path</b></span>")
#@gui : Patch Type = choice(2,"Max Patch","Min Patch","Max et Min Path")
#@gui : Valeur Patch = int(10,1,50)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradations Apres Path</b></span>")
#@gui : Dilate Type = choice(1,"Dilate Circ","Dilate")
#@gui : Valeur Dilate = int(0,0,16)
#@gui : sep = separator()
#@gui : Valeur Erode = int(0,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Solidify</b></span>")
#@gui : Valider Solidify = bool(1)
#@gui : Smoothness % = float(75,0,100)
#@gui : Diffusion Type = choice(0,"Isotropic","Delaunay Oriented","Edge Oriented")
#@gui : Diffusion Iter = int(20,1,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Degradations_Path_Solidify :

Val_Pixelise=$1
Val_Spread=$2
Val_Deform=$3
Val_Isophotes=$4
Val_Blur=$5
Patch_Type=$6
Valeur_Patch=$7
Dilate_Type=$8
Valeur_Dilate=$9
Valeur_Erode=$10
Valider_Solidify=$11
smoothness=$12
diffusion_type=$13
diffusion_iter=$14
to_rgb[-1]
+Je_passe_l_hiver_en_Floride[-1]
if $Val_Pixelise>0 pixelize[-1] {$Val_Pixelise+1},{$Val_Pixelise+1} endif
if $Val_Spread>0 spread[-1] $Val_Spread endif
if $Val_Deform>0 deform[-1] $Val_Deform endif
if $Val_Isophotes>0 isophotes[-1] {$Val_Isophotes+2} replace_color[-1] 0%,0,0,0,0,0,0,0,0,255 endif
if $Val_Blur>0 blur[-1] $Val_Blur endif
to_rgb[-1]
if $Patch_Type==2
 +Je_passe_l_hiver_en_Floride[-1]
 max_patch[-1] $Valeur_Patch
 min_patch[-2] $Valeur_Patch
 blend[-1,-2] add
elif $Patch_Type==1
 min_patch[-1] $Valeur_Patch
elif $Patch_Type==0
 max_patch[-1] $Valeur_Patch
endif
n[-1] 0,255
to_rgba[-1]
if $Valeur_Dilate>0
 if $Dilate_Type==0
  dilate_circ[-1] {$Valeur_Dilate+1}
 elif $Dilate_Type==1
  dilate[-1] {$Valeur_Dilate+1}
 endif
endif
if $Valeur_Erode>0 erode[-1] $Valeur_Erode endif
replace_color[-1] 0%,0,0,0,0,255,0,0,0,0 # noir vers transparent
rv[-1,-2]
blend[-1,-2] alpha
if $Valider_Solidify==1 solidify[-1] $smoothness,$diffusion_type,$diffusion_iter endif

#################################################
##                                             ##
##     FIN samj_Degradations_Path_Solidify     ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Ellipses_Inpaint           ##
##                                             ##
#################################################
# modification de samj_Ellipses_Colorees

#@gui Ellipses Inpaint  : samj_Ellipses_Inpaint, samj_Ellipses_Inpaint(1)
#@gui :_=note("samj_Ellipses_Inpaint")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Couleur Limite= color(0,0,0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ellipse</b></span>")
#@gui : Rayon L = int(8,1,32)
#@gui : Rayon H = int(8,1,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Limite</b></span>")
#@gui : Rendu = choice(2,"A","Inverser","A + Inverser")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Random Dégradation</b></span>")
#@gui : Dégradation = bool(0)
#@gui : Sponge = int(10,1,16)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Ellipses_Inpaint :

Couleur_Limite_r=$1
Couleur_Limite_v=$2
Couleur_Limite_b=$3
Rayon_L=$4
Rayon_H=$5
Rendu=$6
Flou_Effet_Sponge=$7
Valeur_Effet_Sponge=$8

Largeur_Origine={w}
Hauteur_Origine={h}

couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
Hauteur=$Rayon_H
Largeur=$Rayon_L

to_rgba[-1]
$Largeur_Origine,$Hauteur_Origine,1,4
repeat $Largeur_Origine/($Rayon_L+$Rayon_L)
 repeat $Hauteur_Origine/($Rayon_H+$Rayon_H)
  couleur_pixel=${at_ancien[0]\ {$Largeur},{$Hauteur}}
  rouge_pixel=${arg\ 1,$couleur_pixel}
  vert_pixel=${arg\ 2,$couleur_pixel}
  bleu_pixel=${arg\ 3,$couleur_pixel}
  if $Rendu==0
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
   endif
  elif $Rendu==1
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
   endif
  elif $Rendu==2
   if $rouge_pixel-$Couleur_Limite_r>=0&&$vert_pixel-$Couleur_Limite_v>=0&&$bleu_pixel-$Couleur_Limite_b>=0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
   endif
   if $rouge_pixel-$Couleur_Limite_r<0&&$vert_pixel-$Couleur_Limite_v<0&&$bleu_pixel-$Couleur_Limite_b<0
    ellipse[-1] $Largeur,$Hauteur,$Rayon_L,$Rayon_H,0,1,255
   endif
  endif
  Hauteur={$Hauteur+$Rayon_H+$Rayon_H}
 done
 Largeur={$Largeur+$Rayon_L+$Rayon_L}
 Hauteur=$Rayon_H
done
if $Flou_Effet_Sponge==1 sponge[-1] $Valeur_Effet_Sponge endif
inpaint[-2] [-1]
rm[-1]
samj_Wavelet_Sharpen_Test[-1] 1

#################################################
##                                             ##
##            FIN samj_Ellipses_Inpaint        ##
##                                             ##
#################################################
################################################################
##                                                            ##
##                      samj_Zones_Grises                     ##
##                                                            ##
################################################################

# Pour créer des zones détériorées sur l'image
# 2015/04/04 origine

#@gui Deteriorated Areas : samj_Zones_Grises, samj_Zones_Grises(1)
#@gui :_=note("samj_Zones_Grises / Deteriorated Areas")
#@gui :_=note("<span foreground="orangered"><small>Contours</small></span>")
#@gui : Itérations = int(3,1,10)
#@gui : Type = choice(0,"A","B","C")
#@gui : Variations = float(3,1,10)
#@gui :_=note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Itérations = int(4,1,8)
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj      Dernière mise à jour : <i>2015/04/04</i>.</small>")

samj_Zones_Grises :

Iterations_Contours=$1
Choice_Contours=$2
Variations_Contours=$3
Iterations_Blend=$4
Opacite_Blend=$5

to_rgb[-1]
repeat $Iterations_Blend
 +Je_passe_l_hiver_en_Floride[-1]
done

repeat $Iterations_Contours
 if $Choice_Contours==0
  fx_curvature[-1] $Variations_Contours,0,100,0,0,0
 elif $Choice_Contours==1
  dog[-1] {5000/$Variations_Contours},0
 elif $Choice_Contours==2
  fx_edges[-1] 0,{2*$Variations_Contours},0,0
 endif
done

equalize[-1]
fx_decompose_channels[-1] 4,0,1,0
remove[-1,-2]
to_rgb[-1]

repeat $Iterations_Blend
 fx_blend_edges[-1,-2] $Opacite_Blend,5,0
done
################################################################
##                                                            ##
##                    FIN  samj_Zones_Grises                  ##
##                                                            ##
################################################################
#################################################
##                                             ##
##             samj_Random_Plasma              ##
##                                             ##
#################################################

#@gui Random Plasma : samj_Random_Plasma, samj_Random_Plasma(1)
#@gui :_=note("samj_Random_Plasma")
#@gui : Random Colors = int(0,0,4)
#@gui : Blur = int(80,20,120)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/11/05</i>.</small>")

samj_Random_Plasma :

Melange=$1
Flou=$2

 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 blur[-1] {{{w}+{h}}/$Flou}
 +Je_passe_l_hiver_en_Floride[-1]
 plasma[-1] 1,1,10
 blur[-1] {{{w}+{h}}/$Flou}
 #gimp_blend_seamless
 blend_seamless[-2,-1] 1,0,25%
 if $Melange==0
  _gb_bwd_version_1_7_8[-1] 1
 elif $Melange==1
  _gb_bwd_version_1_7_8[-1] 2
 elif $Melange==2
  _gb_bwd_version_1_7_8[-1,-2] 1
 elif $Melange==3
  _gb_bwd_version_1_7_8[-1,-2] 2
 endif
 #fx_blend_edges[-2,-1] 1,5,0
 blend_edges[-2,-1] 5
 blend[-1,-2] alpha

# Fonction _gb_bwd de la version 1.7.8 par David Tschumperlé
_gb_bwd_version_1_7_8 :
  to_color
  if $1==1 repeat $! l[$>] sh 0,2 rgb2srgb. rm. endl done
  elif $1==2 repeat $! l[$>] sh 0,2 lab2rgb. rgb2srgb. rm. endl done
  endif

#################################################
##                                             ##
##            FIN samj_Random_Plasma           ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                         DETAILS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_details :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Details</b>
#################################################
##                                             ##
##           samj_Antialias_Wavelet            ##
##                                             ##
#################################################

#@gui Antialias Wavelet  : samj_Antialias_Wavelet , samj_Antialias_Wavelet (0)
#@gui :_=note("<span foreground="orangered"><small>Pour dessins avec crenelage</small></span>")
#@gui : Flou = int(40,0,255)
#@gui : Trait = int(0,0,255)
#@gui : Cut Bas = int(127,0,255)
#@gui : Cut Haut = int(255,0,255)
#@gui : Dilate Circle W = int(1,1,3)
#@gui : Netteté = int(60,0,128)
#@gui : Dilate Circle R = int(1,1,3)
#@gui : Normaliser = bool(1)
#@gui : Itérations = int(1,1,3)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/17</i>.</small>")

samj_Antialias_Wavelet  :

Flou=$1
Trait=$2
Cut_Bas=$3
Cut_Haut=$4
Dilate_Circle_W=$5
Nettete=$6
Dilate_Circle_R=$7
Normaliser=$8
Iterations_Contours=$9

 repeat $Iterations_Contours
  fx_split_details_wavelets[-1] 2,0,0
  blur[-2] $Flou
  if $Trait>0 add[-2] $Trait endif
  c[-2] $Cut_Bas,$Cut_Haut
  if $Dilate_Circle_W>1 dilate_circ[-1] $Dilate_Circle_W endif
  blend[-1,-2] grainmerge
  sharpen[-1] $Nettete
 done
 if $Dilate_Circle_R>1 dilate_circ[-1] $Dilate_Circle_R endif
 if $Normaliser==1 n[-1] 0,255 endif
 gui_set_layer_mode[-1] normal

#################################################
##                                             ##
##         FIN samj_Antialias_Wavelet          ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Wavelet_Sharpen_Test          ##
##                                             ##
#################################################

#@gui Wavelet Sharpen Test : samj_Wavelet_Sharpen_Test, samj_Wavelet_Sharpen_Test(1)
#@gui :_=note("samj_Wavelet_Sharpen_Test")
#@gui :_=note("gimp_split_details_wavelets 2,0,0")
#@gui : Itérations = int(1,1,4)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/11/06</i>.</small>")

samj_Wavelet_Sharpen_Test :

Repetition=$1

 repeat $Repetition
  fx_split_details_wavelets[-1] 2,0,0
  +Je_passe_l_hiver_en_Floride[-2]
  blend[-1,-3] grainmerge
  blend[-1,-2] grainmerge
 done

 gui_set_layer_mode[-1] normal

#################################################
##                                             ##
##         FIN samj_Wavelet_Sharpen_Test       ##
##                                             ##
#################################################
#################################################
##                                             ##
##        samj_Wavelet_Sharpen_Test_en         ##
##                                             ##
#################################################

#2016/11/07 Ajout Decompose 6
#2016/11/06 origine
#@gui Sharpen [Wavelet] : samj_Wavelet_Sharpen_Test_en, samj_Wavelet_Sharpen_Test_en(1)
#@gui :_=note("Test")
#@gui : Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Iterations = int(0,0,2)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/11/07</i>.</small>")

samj_Wavelet_Sharpen_Test_en :

 repeat $2+1
  if $1==0
   fx_split_details_wavelets[-1] 2,0,0
   +Je_passe_l_hiver_en_Floride[-2]
   blend[-1,-3] grainmerge
   blend[-1,-2] grainmerge
  elif $1==1
   fx_split_details_wavelets[-1] 6,0,0
   +Je_passe_l_hiver_en_Floride[-6]
   blend[-1,-7] grainmerge
   blend[-6,-5] grainmerge
   +Je_passe_l_hiver_en_Floride[-3]
   blend[-1,-6] grainmerge
   blend[-5,-4] grainmerge
   blend[-4,-3] grainmerge
   blend[-3,-2] grainmerge
   blend[-1,-2] grainmerge
  endif
 done
 gui_set_layer_mode[-1] normal

#################################################
##                                             ##
##      FIN samj_Wavelet_Sharpen_Test_en       ##
##                                             ##
#################################################

#################################################################################################################################################################################################
#
#                                                                                                                                                                                          FRAMES
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_frames :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Frames</b>
#################################################
##                                             ##
##       samj_At06B_2017_frame_painting        ##
##                                             ##
#################################################
#@gui At06B 2017 Frame_Painting : samj_At06A_2017_frame_painting, samj_At06A_2017_frame_painting(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Frame</b></span>")
#@gui : Size (%) = float(10,0,100)
#@gui : Contrast = float(0.4,0,1)
#@gui : Smoothness = float(6,0,30)
#@gui : Color = color(127,127,127)
#@gui : Vignette size = float(2,0,50)
#@gui : Vignette contrast = float(400,0,1000)
#@gui : Defects contrast = float(50,0,512)
#@gui : Defects density = float(10,0,100)
#@gui : Defects size = float(1,0,10)
#@gui : Defects smoothness = float(0.5,0,20)
#@gui : Serial number = int(123456,0,1000000)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend GMIC</b></span>")
#@gui : Mode = choice{35,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : Reverse = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Frame Color Variation</b></span>")
#@gui : Pow = float(1,0,8)
#@gui : Cut A % = float(0,0,100)
#@gui : Cut B % = float(100,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>David Tschumperlé + modification samj</i>.      Latest update: <i>2017/02/23</i>.</small>")

samj_At06A_2017_frame_painting:

Blend_Mode=$14
Blend_Opacity=$15
Blend_Reverse=$16

Largeur={w}
Hauteur={h}
to_rgba[-1]
$Largeur,$Hauteur,1,4
frame_painting[-1] $1%,$2,$3%,${4-6},$7%,${8-13}
resize[-1] $Largeur,$Hauteur
pow[-1] $17
n[-1] 0,{{iM}-{im}}
c[-1] {{iM}/100*$18},{iM}
n[-1] 0,{iM}
c[-1] 0,{{iM}/100*$19}
n[-1] 0,255
if $Blend_Reverse==0 rv[-1,-2] endif
gimp_blend_1651[-2,-1] $Blend_Mode,2,$Blend_Opacity,0 # Soft burn

#################################################
##                                             ##
##     FIN samj_At06B_2017_frame_painting      ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                          LAYERS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_layers :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Layers</b>


#################################################################################################################################################################################################
#
#                                                                                                                                                                              LIGHTS AND SHADOWS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_lights_and_shadows :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Lights & Shadows</b>
#################################################
##                                             ##
##             samj_Ombre_Portee_D             ##
##                                             ##
#################################################

#@gui Ombre Portee D  : samj_Ombre_Portee_D , samj_Ombre_Portee_D (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant Plan</b></span>")
#@gui : Résolution = int(16,4,64)
#@gui : Détection A = int(64,0,255)
#@gui : Détection B = int(64,0,255)
#@gui : Flou Lissage = float(2,0,10)
#@gui : Couleur = float(1,0,4)
#@gui : Isophotes AP = int(16,4,64)
#@gui : Dilate AP = int(5,0,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Contours Avant Plan</b></span>")
#@gui : Contour = bool(1)
#@gui : Variation Contour = int(-32,-127,127)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Dilate = int(4,0,16)
#@gui : Couleur Ombre = float(1,0,4)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Décalage Ombre = int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/03</i>.</small>")

samj_Ombre_Portee_D :

Resolution=$1
Detection_A=$2
Detection_B=$3
Flou_Lissage=$4
Couleur=$5
Isophotes_AP=$6
Dilate_AP=$7
Contour=$8
Variation_Contour=$9
Dilatation_ombre=$10
Couleur_Ombre=$11
Flou_Ombre=$12
VA=$13
Type_Rendu=$14
R_a=$15
V_a=$16
B_a=$17
A_a=$18

Largeur_A={round({{w}/$Resolution})}
Hauteur_A={round({{h}/$Resolution})}
OrigineH=0
OrigineV={-$Resolution}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0

 blur $Flou_Lissage
 c[-1] 0,255
 n[-1] 0,255
 c[-1] $Detection_A,{255-$Detection_B}
 n[-1] 0,255
 mul[-1] $Couleur
 isophotes[-1] $Isophotes_AP
 dilate[-1] $Dilate_AP
 resize[-1] $Largeur_A,$Hauteur_A
 resize[-1] {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution}
 repeat $Hauteur_A
  OrigineH=0
  OrigineV={$OrigineV+$Resolution}
  repeat $Largeur_A
   couleur_pixel={I($OrigineH,$OrigineV)}
   rouge_pixel={arg(1,$couleur_pixel)}
   vert_pixel={arg(2,$couleur_pixel)}
   bleu_pixel={arg(3,$couleur_pixel)}
   alpha_pixel={arg(4,$couleur_pixel)}
   if $alpha_pixel>0
    rectangle[-1] $OrigineH,$OrigineV,{$OrigineH+$Resolution-1},{$OrigineV+$Resolution-1},1,$rouge_pixel,$vert_pixel,$bleu_pixel,255
    if $Contour==1
     rectangle[-1] $OrigineH,$OrigineV,{$OrigineH+$Resolution-1},{$OrigineV+$Resolution-1},1,0xFFFFFFFF,{{$rouge_pixel/2}+$Variation_Contour},{{$vert_pixel/2}+$Variation_Contour},{{$bleu_pixel/2}+$Variation_Contour},255
    endif
   endif
   OrigineH={$OrigineH+$Resolution}
  done
 done
 +Je_passe_l_hiver_en_Floride[-1]
 to_graya[-1]
 dilate[-1] $Dilatation_ombre
 mul[-1] $Couleur_Ombre
 blur[-1] $Flou_Ombre
 if $Type_Rendu==1
  shift[-1] 0,0,0,0,0
 elif $Type_Rendu==2
  shift[-1] $VA,0,0,0,0
 elif $Type_Rendu==3
  shift[-1] 0,$VA,0,0,0
 elif $Type_Rendu==4
  shift[-1] $VA,$VA,0,0,0
 elif $Type_Rendu==5
  shift[-1] {-$VA},0,0,0,0
 elif $Type_Rendu==6
  shift[-1] 0,{-$VA},0,0,0
 elif $Type_Rendu==7
  shift[-1] {-$VA},{-$VA},0,0,0
 endif
 crop[-1] 0,0,{{w}-1},{{h}-1}
 rv[-1,-2]
 blend[-1,-2] alpha
 {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution},1,4
 fill_color[-1] $R_a,$V_a,$B_a,$A_a
 rv[-1,-2]
 blend[-1,-2] alpha

#################################################
##                                             ##
##           FIN samj_Ombre_Portee_D           ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Ombre_Portee_C             ##
##                                             ##
#################################################

#@gui Ombre Portee C  : samj_Ombre_Portee_C , samj_Ombre_Portee_C (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Isophotes = int(32,4,64)
#@gui : Dilatation = int(8,1,64)
#@gui :_=note("<span foreground="blue"><small><i><b>samj_Ombre_Portee_B</b></i></small></span>")
#@gui : Résolution = int(16,4,64)
#@gui : Limite détails = int(192,1,255)
#@gui : Supprimer Noir = bool(0)
#@gui : Contour = bool(1)
#@gui : Variation Contour = int(16,-127,127)
#@gui : Clair Foncé = float(1,0,2)
#@gui : Précision Blanc = float(0,0,1)
#@gui : Précision Noir = float(0,0,1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Couleur Ombre = color(96,96,96,255)
#@gui : Dilate = int(2,0,16)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Décalage Ombre= int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/01</i>.</small>")

samj_Ombre_Portee_C :

 isophotes[-1] $1
 dilate_circ[-1] $2
 samj_Ombre_Portee_B[-1] $3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22

#################################################
##                                             ##
##           FIN samj_Ombre_Portee_C           ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Ombre_Portee_B             ##
##                                             ##
#################################################

#@gui Ombre Portee B  : samj_Ombre_Portee_B , samj_Ombre_Portee_B (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : Résolution = int(16,4,64)
#@gui : Limite détails = int(128,1,255)
#@gui : Supprimer Noir = bool(0)
#@gui : Contour = bool(1)
#@gui : Variation Contour = int(16,-127,127)
#@gui : Clair Foncé = float(1,0,2)
#@gui : Précision Blanc = float(0,0,1)
#@gui : Précision Noir = float(0,0,1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Couleur Ombre = color(127,127,127,255)
#@gui : Dilate = int(2,0,16)
#@gui : Flou/Blur = float(2,0,10)
#@gui : Décalage Ombre= int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/01</i>.</small>")

samj_Ombre_Portee_B :

Resolution=$1
Limite=$2
Supprimer_Noir=$3
Contour=$4
Variation_Contour=$5
Clair_Fonce=$6
Precision_Blanc=$7
Precision_Noir=$8
R_a=$9
V_a=$10
B_a=$11
A_a=$12
Dilatation=$13
Flou=$14
VA=$15
Type_Rendu=$16
R_b=$17
V_b=$18
B_b=$19
A_b=$20

Largeur_A={round({{w}/$Resolution})}
Hauteur_A={round({{h}/$Resolution})}
OrigineH=0
OrigineV={-$Resolution}
couleur_pixel=0
rouge_pixel=0
vert_pixel=0
bleu_pixel=0
alpha_pixel=0

 to_rgba[-1]
 resize[-1] $Largeur_A,$Hauteur_A
 resize[-1] {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution}
 luminance[-1]
 to_rgba[-1]
 n[-1] 0,255
 c[-1] 0,$Limite
 n[-1] 0,255
 c[-1] {255-$Limite},255
 n[-1] 0,255
 replace_color[-1] 100,$Precision_Blanc,255,255,255,255,0,0,0,0  # blanc vers transparence
 if $Supprimer_Noir==1
  replace_color[-1] 100,$Precision_Noir,0,0,0,255,0,0,0,0  # noir vers transparence
 endif
 mul[-1] $Clair_Fonce
 {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution},1,4
 rv[-1,-2]
 repeat $Hauteur_A
  OrigineH=0
  OrigineV={$OrigineV+$Resolution}
  repeat $Largeur_A
   couleur_pixel={I($OrigineH,$OrigineV)}
   rouge_pixel={arg(1,$couleur_pixel)}
   vert_pixel={arg(2,$couleur_pixel)}
   bleu_pixel={arg(3,$couleur_pixel)}
   alpha_pixel={arg(4,$couleur_pixel)}
   if $alpha_pixel>0
    rectangle[-2] $OrigineH,$OrigineV,{$OrigineH+$Resolution},{$OrigineV+$Resolution},1,$R_a,$V_a,$B_a,$A_a
    if $Contour==1
     rectangle[-1] $OrigineH,$OrigineV,{$OrigineH+$Resolution-1},{$OrigineV+$Resolution-1},1,0xFFFFFFFF,{{$rouge_pixel/2}+$Variation_Contour},{{$vert_pixel/2}+$Variation_Contour},{{$bleu_pixel/2}+$Variation_Contour},255
    endif
   endif
   OrigineH={$OrigineH+$Resolution}
  done
 done
 dilate[-2] $Dilatation
 blur[-2] $Flou
 if $Type_Rendu==1
  shift[-2] 0,0,0,0,0
 elif $Type_Rendu==2
  shift[-2] $VA,0,0,0,0
 elif $Type_Rendu==3
  shift[-2] 0,$VA,0,0,0
 elif $Type_Rendu==4
  shift[-2] $VA,$VA,0,0,0
 elif $Type_Rendu==5
  shift[-2] {-$VA},0,0,0,0
 elif $Type_Rendu==6
  shift[-2] 0,{-$VA},0,0,0
 elif $Type_Rendu==7
  shift[-2] {-$VA},{-$VA},0,0,0
 endif
 crop[-2] 0,0,{{w}-1},{{h}-1}
 blend[-1,-2] alpha
 {$Largeur_A*$Resolution},{$Hauteur_A*$Resolution},1,4
 fill_color[-1] $R_b,$V_b,$B_b,$A_b
 rv[-1,-2]
 blend[-1,-2] alpha

#################################################
##                                             ##
##           FIN samj_Ombre_Portee_B           ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Ombre_Portee              ##
##                                             ##
#################################################

# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
# 20161128 Ajout Forme A & B - QuA
#@gui Ombre Portee  : samj_Ombre_Portee , samj_Ombre_Portee (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Avant plan</b></span>")
#@gui : QuA = int(0,0,100)
#@gui : FlA = float(0,0,10)
#@gui : InvC = bool(0)
#@gui : Limite détails = int(128,1,255)
#@gui : Dilate = int(0,0,8)
#@gui : Couleur Avant = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ombre</b></span>")
#@gui : Couleur Ombre = color(127,127,127,255)
#@gui : Décalage Ombre= int(2,0,7)
#@gui : Rendu = int(2,1,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Flou</b></span>")
#@gui : Flou/Blur = float(0.1,0,2)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Ombre_Portee :

QuA=$1
FlA=$2
InvC=$3
Limite=$4
Dilatation=$5
R_a=$6
V_a=$7
B_a=$8
A_a=$9
R_b=$10
V_b=$11
B_b=$12
A_b=$13
VA=$14
Type_Rendu=$15
R_c=$16
V_c=$17
B_c=$18
A_c=$19
Flou=$20

Largeur_Origine={w}
Hauteur_Origine={h}

 if $QuA>0 quantize[-1] {$QuA+7},1,1 endif
 blur[-1] $FlA
 if $InvC==1 negate[-1] endif
 to_rgba[-1]
 luminance[-1]
 to_rgba[-1]
 n[-1] 0,255
 c[-1] 0,$Limite
 n[-1] 0,255
 c[-1] {255-$Limite},255
 n[-1] 0,255
 ditheredbw[-1]
 dilate[-1] {$Dilatation+1}
 to_rgba[-1]
 replace_color[-1] 0%,0,255,255,255,255,0,0,0,0  # blanc vers transparence
 +Je_passe_l_hiver_en_Floride[-1]
 replace_color[-1] 0%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a # noir vers couleur avant
 replace_color[-2] 0%,0,0,0,0,255,$R_b,$V_b,$B_b,$A_b # noir vers couleur ombre
 if $Type_Rendu==1
  shift[-2] 0,0,0,0,0
 elif $Type_Rendu==2
  shift[-2] $VA,0,0,0,0
 elif $Type_Rendu==3
  shift[-2] 0,$VA,0,0,0
 elif $Type_Rendu==4
  shift[-2] $VA,$VA,0,0,0
 elif $Type_Rendu==5
  shift[-2] {-$VA},0,0,0,0
 elif $Type_Rendu==6
  shift[-2] 0,{-$VA},0,0,0
 elif $Type_Rendu==7
  shift[-2] {-$VA},{-$VA},0,0,0
 endif
 crop[-2] 0,0,{{w}-1},{{h}-1}
 if $Flou>0 blur[-1] $Flou blur[-2] {$Flou+1} endif
 blend[-1,-2] alpha
 {w},{h},1,4
 fill_color[-1] $R_c,$V_c,$B_c,$A_c
 rv[-1,-2]
 blend[-1,-2] alpha

#################################################
##                                             ##
##            FIN samj_Ombre_Portee            ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                        PATTERNS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_patterns :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Patterns</b>
#################################################
##                                             ##
##               samj_Mosaic_A                 ##
##                                             ##
#################################################

#@gui Mosaic A : samj_Mosaic_A, samj_Mosaic_A
#@gui : 1 - Tuiles Taille/Tiles Size = int(20,10,40)
#@gui : 2 - Joints = int(3,2,5)
#@gui :_=note("<span foreground="orangered"><b>Relief</b></span>")
#@gui : 3 - Relief = bool(1)
#@gui : 4 - Lumière/Light = float(0,0,1)
#@gui : 5 - Lumière/Light Orientation = int(0,0,3)
#@gui : 6 - Fancy Mosaic - Slow = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/05/09</i>.</small>")

samj_Mosaic_A :
repeat $! l[$>]
	if $5==1 mirror x elif $5==2 mirror y elif $5==3 mirror x mirror y endif
	c 0,255
	add 1
	fx_superpixels $1,50,5,1,1,255,255,255,255,0,50,50
	to_rgba
	+-
	replace_color[-1] 0%,0,255,255,255,255,0,0,0,0
	replace_color[-1] 99%,0,127,127,127,255,255,255,255,255
	erode[-1] $2
	replace_color[-1] 0%,0,0,0,0,0,0,0,0,255
	replace_color[-1] 0%,0,255,255,255,255,0,0,0,0
	blend alpha
	replace_color 0%,0,0,0,0,255,0,0,0,0
	if $3==1
		fx_smooth_antialias 5,10,0.8,0,50,50
		samj_Reptorian_fx_emboss_relief_20210508 {$4*36},20,165,500,2,0,1,1,100,0,50,50
		if $6==1
			+samj_Barbouillage_Paint_Daub 2,2,100,0.2,1,4,1,0,8
			rv
			fx_blend[-1,-2] 6,0,100,1,"1/2 - 1/4*cos(pi*a) - 1/4*cos(pi*b)"
		endif
	endif
	if $5==1 mirror x elif $5==2 mirror y elif $5==3 mirror x mirror y endif
	c 0,255
endl done
# 20210509 Sauvegarde sources Reptorian
samj_Reptorian_fx_emboss_relief_20210508 : 
	to_a repeat $! l[$>] split_opacity if $8 +samj_Reptorian_em[0] {$6?$2+180:$2},{$1?$4/100:$3/100},$5 blend[^1] grainmerge,{$9/100} else samj_Reptorian_em[0] {$6?$2+180:$2},{$1?$4/100:$3/100},$5 fi if $7 a c else k[0] fi endl done
samj_Reptorian_em : 
	samj_Reptorian_emboss_image $*
samj_Reptorian_emboss_image :
	-skip ${2=1},${3=0}
	l[0]
	luminance
	fx_gradient2rgb $3,0,100,0,0
	[0]
	repeat 2 l[$>] rgb2hsv s c l[0] + {$1+($>*180)} % 360 endl a c hsv2rgb to_rgb s c rm[1,2] endl done
	l[0] n 128,255 endl l[1] negate n 0,128 endl
	+fill_color[0] 128,128,128,255 rv blend grainmerge - 128 mul $2 + 128 cut 0,255
	endl

#################################################
##                                             ##
##              FIN samj_Mosaic_A              ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Pseudo_Vitrail             ##
##                                             ##
#################################################

#@gui Pseudo Vitrail : samj_Pseudo_Vitrail, samj_Pseudo_Vitrail
#@gui :_=separator()
#@gui : 1 - Autoindex = int(0,0,1024)
#@gui : 2 - Densité/Density = int(40,1,100)
#@gui : 3 - Voronoi = bool(0)
#@gui : 4 - Détails = float(0,0,1)
#@gui : 5 - Grosseur Trait/Line Thickness = int(2,1,5)
#@gui : 6-7-8-9 Trait/Line = color(0,0,0,255)
#@gui : 10 - Itération = bool(0)
#@gui : 11 - Couleurs/Colors = float(0,-0.1,0.2)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2021/01/17</i>.</small>")

samj_Pseudo_Vitrail :
repeat $! l[$>]
repeat {$10+1} samj_Base_Pseudo_Vitrail $1,$2,$3,$4,$5,$6,$7,$8,$9 done
pow {1+$11}
endl done
samj_Base_Pseudo_Vitrail :
if $1>0 autoindex {$1+1} endif
mosaic $2
if $3==1 fx_voronoi 160,1,0,50,3,0,0,0,0,0,0,0,0,0,0,0 endif
blur $4
+isophotes {iM}
if $5>1 dilate[-1] $5 endif
replace_color[-1] 255,0,127,127,127,255,0,0,0,255
replace_color[-1] 1,0,0,0,0,255,$6,$7,$8,$9
blend alpha

#################################################
##                                             ##
##           FIN samj_Pseudo_Vitrail           ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Motifs_Rapides_B            ##
##                                             ##
#################################################

#@gui Quickly Create Colorful Patterns B : samj_Motifs_Rapides_B, samj_Motifs_Rapides_B(0)
#@gui :_=link("https://samjcreations.blogspot.com","https://samjcreations.blogspot.com")
#@gui :_=note("<i>Pour créer rapidement des motifs sur des grosses images 7800*11400 - 13/19</i>")
#@gui :_=note("<i>To quickly create patterns on large images 7800*11400 - 13/19</i>")
#@gui :_=note("<span foreground="orangered"><b>Fond/Background</b></span>")
#@gui : Lignes Verticales/Vertical Lines = bool(1)
#@gui : Couleurs/Colors = int(1234,1,65536)
#@gui : Épaisseur Des Lignes/Line Thickness = int(16,1,128)
#@gui : note = note("<span foreground="orangered"><b>Bandes/Strips</b></span>")
#@gui : Bandes/Strips = bool(0)
#@gui : Nb = int(8,2,16)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/31</i>.</small>")

samj_Motifs_Rapides_B :
Hauteur={h}
Largeur={w}
srand $2
rm[0]
if $1==1 {$Largeur/$3},1,1,3,u([256,256,256]) else {$Hauteur/$3},1,1,3,u([256,256,256]) rotate 90 endif
n 0,255
resize $Largeur,$Hauteur
if $4==1 shift 50%,50%,0,0,2 resize {round($Largeur/$5)*$5},{round($Hauteur/$5)*$5} split y,$5 split x,$5 append y append x split y,$5 append x resize $Largeur,$Hauteur endif

#################################################
##                                             ##
##          FIN samj_Motifs_Rapides_B          ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Lignes_Perpendiculaires        ##
##                                             ##
#################################################

#@gui Perpendicular Lines : samj_Lignes_Perpendiculaires, samj_Lignes_Perpendiculaires
#@gui :_=link("https://samjcreations.blogspot.com","https://samjcreations.blogspot.com")
#@gui : note = note("<span foreground="orangered"><b>Lignes / Lines </b></span>")
#@gui : Couleur/Color = color(255,255,255,255)
#@gui : Fréquence/Frequency = int(10,1,100)
#@gui : Répétitions/Repeat = int(1,1,100)
#@gui : Dilate = int(2,1,64)
#@gui : Graine/Seed A = int(1234,1,65536)
#@gui : Graine/Seed B = int(5678,1,65536)
#@gui : note = note("<span foreground="orangered"><b>Mélange/Blend</b></span>")
#@gui : Mélange Avec Image / Blend= bool(0)
#@gui : Mode = choice(0,"add","alpha","and","average","blue","burn","darken","difference",
#@gui : "divide","dodge","edges","exclusion","freeze","grainextract","grainmerge","green","hardlight",
#@gui : "hardmix","hue","interpolation","lighten","lightness","linearburn","linearlight","luminance",
#@gui : "multiply","negation","or","overlay","pinlight","red","reflect","saturation","seamless","seamless_mixed",
#@gui : "screen","shapeareamax","shapeareamax0","shapeareamin","shapeareamin0","shapeaverage","shapeaverage0",
#@gui : "shapemedian","shapemedian0","shapemin","shapemin0","shapemax","shapemax0","softburn","softdodge",
#@gui : "softlight","stamp","subtract","value","vividlight","xor")
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/30</i>.</small>")

samj_Lignes_Perpendiculaires :
Boucle=0
{w},{h},1,4
repeat $6
	rotate[-1] 90
	srand {$8+$Boucle}
	stripes_y[-1] $5
	rotate[-1] -90
	srand {$9+$Boucle}
	stripes_y[-1] $5
	Boucle=$Boucle+1
done
dilate[-1] $7
n[-1] 0,255
{w},{h},1,4
fill_color[-1] $1,$2,$3,$4
blend[-1,-2] average
if $10==0
	rm[0]
else
	to_rgba[0]
	mode=${arg\ 1+$11,add,alpha,and,average,blue,burn,darken,difference,\
	,divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
	,hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
	,multiply,negation,or,overlay,pinlight,red,reflect,saturation,seamless,seamless_mixed,\
	,screen,shapeareamax,shapeareamax0,shapeareamin,shapeareamin0,shapeaverage,shapeaverage0,\
	,shapemedian,shapemedian0,shapemin,shapemin0,shapemax,shapemax0,softburn,softdodge,\
	,softlight,stamp,subtract,value,vividlight,xor}
	blend $mode,$12
endif

#################################################
##                                             ##
##      FIN samj_Lignes_Perpendiculaires       ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Motifs_7200               ##
##                                             ##
#################################################

#@gui Motifs 7200  : samj_Motifs_7200 , samj_Motifs_7200(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Motif Plasma</b></span>")
#@gui : Détails  = int(2,1,8)
#@gui : Plasma 0 - Bruit Aléatoire 1  = bool(0)
#@gui : Plasma A - Bruit Dimension  = int(20,0,32)
#@gui : Plasma B - Bruit Dimension  = int(20,0,32)
#@gui : Flou Pourcent  = int(30,1,100)
#@gui : Mélange Mode  = int(1,0,1)
#@gui : Mélange Pourcent  = int(75,0,100)
#@gui : Graine - 0 Pour Motif Aléatoire  = int(0,0,1000000)
#@gui : Effet = choice(0,"0 Plasma","1 CA","2 BR","3 CA BR","4 RS CA","5 RS BR","6 RS CA BR","7 PD","8 PD RS","9 PD BR","10 PD RS BR")
#@gui : Couleur Random Shade = color(255,0,221,255)
#@gui : Ajouter Rolling Guidance [lissage] = bool(0)
#@gui : Ajouter Mess With Bits = bool(0)
#@gui : Ajouter CeKoaSa 004 = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/02/17</i>.</small>")

samj_Motifs_7200 :

 Details=$1
 Plasma_Bruit=$2
 PlasmaA=$3
 PlasmaB=$4
 Flou=$5
 Melange_Mode=$6
 Melange_Pourcent=$7
 Graine=$8
 Effet=$9
 R_a=$10
 V_a=$11
 B_a=$12
 A_a=$13
 Ajouter_Rolling_Guidance=$14
 Ajouter_Mess_With_Bits=$15
 Ajouter_CeKoaSa_004=$16

 Boucle=0
 Larg={w}
 Haut={h}

 rm[0]

 repeat $Details
  repeat 2
   $Larg,$Haut,1,3
   Boucle={$Boucle+1}
   if $Graine>0 srand {$Graine*$Boucle} endif
   if $Plasma_Bruit==1
    noise[-1] {$Larg*$Haut*$Boucle},1
    blur[-1] {16+$PlasmaA+$PlasmaB+$Boucle+{{round({$Larg/512})}}}
   else
    plasma[-1] $PlasmaA,$PlasmaB
    blur[-1] {round($Larg/$Flou)}
   endif
   c[-1] 0,255
  done
  blend_seamless $Melange_Mode,0,$Melange_Pourcent
 done

 if $Ajouter_Mess_With_Bits==1 fx_mess_with_bits[-1] 1,15,1,1,0,15,100,0,0,50,50 endif

 if $Effet==1
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
 elif $Effet==2
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==3
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==4
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
 elif $Effet==5
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==6
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==7
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
 elif $Effet==8
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
 elif $Effet==9
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==10
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 endif

 if $Ajouter_Rolling_Guidance==1 rolling_guidance[-1] {u(3,5)},{u(8,12)},{u(0.3,0.6)} endif
 if $Ajouter_CeKoaSa_004==1 samj_CeKoaSa_004 30,0,0,0.8,0,0 endif

##############################################
##   Fonctions Communes aux 'Motifs_7200'   ##
##############################################

samj_Soft_Random_Shades_7200 :

 R_a=$1
 V_a=$2
 B_a=$3
 A_a=$4
 Variation_A=$5
 Variation_B=$6
 Variation_C=$7

 Largeur={w}
 Hauteur={h}
  srand {1+$R_a+$V_a+$B_a+$A_a}
  {$Largeur},{$Hauteur},1,4
  {$Largeur},{$Hauteur},1,4
  rm[-3]
  fill_color[-1,-2] $R_a,$V_a,$B_a,$A_a
  samj_Random_Plasma_7200[-1] $Variation_A,$Variation_B
  blend[-1,-2] luminance
  if $Variation_C==0
   # rien
  else
   {$Largeur},{$Hauteur},1,4
   {$Largeur},{$Hauteur},1,4
   fill_color[-1,-2] $R_a,$V_a,$B_a,$A_a
   samj_Random_Plasma_7200[-1] $Variation_A,$Variation_B
   blend[-1,-2] luminance
   blend[-1,-2] edges,{0.5+$Variation_C},0
  endif
  crop[-1] 0,0,{$Largeur-8},{$Hauteur-1}
  resize[-1] {$Largeur},{$Hauteur}

samj_Random_Plasma_7200 :

Melange=$1
Flou=$2

 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 blur[-1] {{{w}+{h}}/$Flou}
 +Je_passe_l_hiver_en_Floride[-1]
 srand {1+$Melange+$Flou}
 plasma[-1] 1,1,10
 blur[-1] {{{w}+{h}}/$Flou}
 #gimp_blend_seamless
 blend_seamless[-2,-1] 1,0,25%
 if $Melange==0
  samj_7200_gb_bwd_version_1_7_8[-1] 1
 elif $Melange==1
  samj_7200_gb_bwd_version_1_7_8[-1] 2
 elif $Melange==2
  samj_7200_gb_bwd_version_1_7_8[-1,-2] 1
 elif $Melange==3
  samj_7200_gb_bwd_version_1_7_8[-1,-2] 2
 endif
 #fx_blend_edges[-2,-1] 1,5,0
 blend_edges[-2,-1] 5
 blend[-1,-2] alpha

# Fonction _gb_bwd de la version 1.7.8 par David Tschumperlé
samj_7200_gb_bwd_version_1_7_8 :
  to_color
  if $1==1 repeat $! l[$>] sh 0,2 rgb2srgb. rm. endl done
  elif $1==2 repeat $! l[$>] sh 0,2 lab2rgb. rgb2srgb. rm. endl done
  endif

##############################################
## FIN Fonctions Communes aux 'Motifs_7200' ##
##############################################

#################################################
##                                             ##
##            FIN samj_Motifs_7200             ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Motifs_7200_VarianteA          ##
##                                             ##
#################################################

##  samj_Motifs_7200_VarianteA 8,0,6,6,1,1,10,111111,7,225,103,223,255,0,1,1 fx_freaky_details[-1] 2,5,1,11,0,32,0,50,50
#@gui Motifs 7200 Variante A  : samj_Motifs_7200_VarianteA , samj_Motifs_7200_VarianteA(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="blue"><b>Pour obtenir des motifs autour de la couleur choisie</b></span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Motif Plasma</b></span>")
#@gui : Détails  = int(2,1,8)
#@gui : Plasma 0 - Bruit Aléatoire 1  = bool(0)
#@gui : Plasma A - Bruit Dimension  = int(20,0,32)
#@gui : Plasma B - Bruit Dimension  = int(20,0,32)
#@gui : Flou Pourcent  = int(30,1,100)
#@gui : Mélange Mode  = int(1,0,1)
#@gui : Mélange Pourcent  = int(75,0,100)
#@gui : Graine - 0 Pour Motif Aléatoire  = int(0,0,1000000)
#@gui : Effet = choice(0,"0 Plasma","1 CA","2 BR","3 CA BR","4 RS CA","5 RS BR","6 RS CA BR","7 PD","8 PD RS","9 PD BR","10 PD RS BR")
#@gui : Couleur Random Shade = color(255,0,221,255)
#@gui : Ajouter Rolling Guidance [lissage] = bool(0)
#@gui : Ajouter Mess With Bits = bool(0)
#@gui : Ajouter CeKoaSa 004 = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/02/19</i>.</small>")

samj_Motifs_7200_VarianteA :

 Details=$1
 Plasma_Bruit=$2
 PlasmaA=$3
 PlasmaB=$4
 Flou=$5
 Melange_Mode=$6
 Melange_Pourcent=$7
 Graine=$8
 Effet=$9
 R_a=$10
 V_a=$11
 B_a=$12
 A_a=$13
 Ajouter_Rolling_Guidance=$14
 Ajouter_Mess_With_Bits=$15
 Ajouter_CeKoaSa_004=$16

 Boucle=0
 Larg={w}
 Haut={h}

 rm[0]

 repeat $Details
  repeat 2
   $Larg,$Haut,1,4
   fill_color[-1] $R_a,$V_a,$B_a,$A_a
   $Larg,$Haut,1,4
   Boucle={$Boucle+1}
   if $Graine>0 srand {$Graine*$Boucle} endif
   if $Plasma_Bruit==1
    noise[-1] {$Larg*$Haut*$Boucle},1
    blur[-1] {16+$PlasmaA+$PlasmaB+$Boucle+{{round({$Larg/512})}}}
   else
    plasma[-1] $PlasmaA,$PlasmaB
    blur[-1] {round($Larg/$Flou)}
   endif
   c[-1] 0,255
   blend[-1,-2] edges,0.5,0
   $Larg,$Haut,1,4
   fill_color[-1] $R_a,$V_a,$B_a,$A_a
   blend[-1,-2] luminance
   blur[-1] {round($Larg/$Flou)}
  done
  blend_seamless $Melange_Mode,0,$Melange_Pourcent
 done

 if $Ajouter_Mess_With_Bits==1 fx_mess_with_bits[-1] 1,15,1,1,0,15,100,0,0,50,50 endif

 if $Effet==1
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
 elif $Effet==2
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==3
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==4
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
 elif $Effet==5
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==6
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_color_abstraction[-1] 10,10,0.2,0,50,50
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==7
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
 elif $Effet==8
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
 elif $Effet==9
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 elif $Effet==10
  samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8
  +samj_Soft_Random_Shades_7200[-1] $R_a,$V_a,$B_a,$A_a,1,66,0.1
  fx_blend_seamless[-1,-2] 1,0,85,2,0
  fx_brushify[-1] 8,0.25,4,64,25,12,0,2,4,0.2,0.5,30,1,1,1,5,0,0.2,1
 endif

 if $Ajouter_CeKoaSa_004==1 samj_CeKoaSa_004 30,0,0,0.8,0,0 endif
 if $Ajouter_Rolling_Guidance==1 rolling_guidance[-1] {u(3,5)},{u(8,12)},{u(0.3,0.6)} endif

 $Larg,$Haut,1,4
 samj_Soft_Random_Shades[-1] $R_a,$V_a,$B_a,255,1,66,0.1
 blend[-1,-2] seamless
 if $Ajouter_Mess_With_Bits==1 $Larg,$Haut,1,4 samj_Soft_Random_Shades[-1] $R_a,$V_a,$B_a,255,1,66,0.1 fx_blend[-2,-1] 6,0,100,1,"1/2 - 1/4*cos(pi*a) - 1/4*cos(pi*b)" endif
 n[-1] 0,255

#################################################
##                                             ##
##       FIN samj_Motifs_7200_VarianteA        ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Motifs_7200_VarianteB          ##
##                                             ##
#################################################

## samj_Motifs_7200_VarianteB 4,9,0,3,45,180,30,0.75,0.02,0.5,1.5,0.1,1,10,10,1,1,4,1,1,1,1
## samj_Motifs_7200_VarianteB 4,9,0,5,45,77,100,0.75,0.02,0.5,1,0.1,1,6.5,10,0,1,4,1,1,1,1[-1] samj_Barbouillage_Paint_Daub_en[-1] 2,2,100,0.2,1,4,1,0,8

#@gui Motifs 7200 VarianteB  : samj_Motifs_7200_VarianteB , samj_Motifs_7200_VarianteB(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="blue"><b>Pour obtenir des motifs cheveux peignes</b></span>")
#@gui : Détails  = int(4,1,8)
#@gui : Bruit En Plus = int(0,0,64)
#@gui : Déformation En Plus  = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>sketchbw</b></span>")
#@gui : Number of Orientations = int(3,1,16)
#@gui : Starting Angle = float(45,0,180)
#@gui : Angle Range = float(180,0,180)
#@gui : Stroke Length = float(30,0,1000)
#@gui : Contour Threshold = float(0.75,0,10)
#@gui : Opacity = float(0.02,0,0.3)
#@gui : Background Intensity = float(0.5,0,2)
#@gui : Density = float(1.5,0,5)
#@gui : Sharpness = float(0.1,0,1)
#@gui : Anisotropy = float(1,0,1)
#@gui : Smoothness = float(10,0,10)
#@gui : Cohérence = float(10,0,10)
#@gui : Boost Stroke = bool(1)
#@gui : Curved Stroke = bool(1)
#@gui : Color Model = choice(4,"Black on white","White on black","Black on transparent white","White on transparent black","Color on white")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dispersion</b></span>")
#@gui : Dispersion  = int(48,1,100)
#@gui : DispersionDeform  = int(4,1,10)
#@gui : Cut vs Norm = bool(1)
#@gui : Seamless vs Edges = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/02/20</i>.</small>")

samj_Motifs_7200_VarianteB :

 Details=$1
 Bruit=$2
 Deformation=$3
 Dispersion=$19
 Cut_vs_Norm=$20
 Seamless_vs_Edges=$21

 Boucle=0
 Larg={w}
 Haut={h}
 rm[0]
 repeat $Details
 Boucle={$Boucle+1}
 $Larg,$Haut,1,3
 noise[-1] {{$Dispersion*$Boucle*$Bruit}+$Larg*$Haut*{round(u(1,32))}},1
 blur[-1] {round(u({16*{1+{$Larg/512}}},{32*{1+{$Larg/512}}}))}
 if $$Deformation>0 deform[-1] {$Deformation*{$DispersionDeform+$Boucle}} endif
 if $Cut_vs_Norm==1 c 0,255 else n 0,255 endif
 done
 if $Seamless_vs_Edges==1 blend seamless else blend edges endif
 # fx_sketchbw[-1] 3,45,180,30,0.75,0.02,0.5,1.5,0.1,1,10,0,0,1,4,0,50,50
 fx_sketchbw[-1] $4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18

#################################################
##                                             ##
##       FIN samj_Motifs_7200_VarianteB        ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Motifs_7200_VarianteC          ##
##                                             ##
#################################################

## LargO={w} HautO={h} samj_Motifs_7200_VarianteC 4,32,64,99,1,5,255,0,221,0,3,1,0,0,240,40,160,180,0,85,255,180,0 $LargO,$HautO,1,4 fx_maze[-1] 120,10,0,1,1  blend[-1,-2] add

#@gui Motifs 7200 VarianteC  : samj_Motifs_7200_VarianteC , samj_Motifs_7200_VarianteC(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="blue"><b>Pour obtenir des chemins courbes</b></span>")
#@gui : Détails  = int(4,1,8)
#@gui : Bruit = int(32,2,64)
#@gui : Flou A = int(64,2,128)
#@gui : Déformation = int(32,1,100)
#@gui : Seamless vs Edges A = bool(1)
#@gui : Flou B = int(5,2,10)
#@gui : Couleur = color(255,0,221)
#@gui : Seamless vs Edges B = bool(0)
#@gui : Etendue Couleurs = choice(3,"Cut Norm","Cut","Norm","Rien")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Dégradé</b></span>")
#@gui : Ajouter Dégradé = bool(0)
#@gui : Type H / V = choice(0,"H","V")
#@gui : Swap colors = bool(0)
#@gui : Starting color A = color(240,40,160,255)
#@gui : Ending color B = color(240,240,40,255)
#@gui : Colorspace = choice(0,"sRGB","Linear RGB","Lab")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/02/20</i>.</small>")

samj_Motifs_7200_VarianteC :

 Details=$1
 Bruit=$2
 FlouA=$3
 Deformation=$4
 Seamless_vs_EdgesA=$5
 FlouB=$6
 R_a=$7
 V_a=$8
 B_a=$9
 Seamless_vs_EdgesB=$10
 Etendue_Couleurs=$11
 Ajouter_Degrade=$12

 Larg={w}
 Haut={h}
 rm[0]
 repeat $Details
  $Larg,$Haut,1,3
  noise[-1] {$Larg*$Haut*{round(u(1,$Bruit))}},1
  blur[-1] {round(u(10,$FlouA))}
  deform[-1] {round(u(0,$Deformation))}
  if $Etendue_Couleurs==0 c[-1] 0,255 n[-1] 0,255 elif $Etendue_Couleurs==1 c[-1] 0,255 elif $Etendue_Couleurs==2 n[-1] 0,255 endif
 done
 if $Seamless_vs_EdgesA==1 blend seamless else blend edges endif
 blur[-1] {round(u(1,$FlouB))}
 rolling_guidance {u(3,5)},{u(8,12)},{u(0.3,0.6)}
 $Larg,$Haut,1,3
 fill_color[-1] $R_a,$V_a,$B_a
 if $Seamless_vs_EdgesB==1 blend seamless else blend edges endif
 fx_color_abstraction[-1] 10,10,0.2,0,50,50
 if $Ajouter_Degrade==1
  to_rgba[-1]
  $Larg,$Haut,1,4
  samj_Linear_Gradient_CIE_Lab[-1] $13,$14,$15,$16,$17,$18,$19,$20,$21,$22
  fx_blend_average_all $23
 endif

#################################################
##                                             ##
##       FIN samj_Motifs_7200_VarianteC        ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Motif_Plasma               ##
##                                             ##
#################################################

#@gui Motif Plasma  : samj_Motif_Plasma , samj_Motif_Plasma(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Motif Plasma</b></span>")
#@gui : Détails  = int(2,1,8)
#@gui : Plasma A  = int(20,0,32)
#@gui : Plasma B  = int(20,0,32)
#@gui : Flou Pourcent  = int(30,1,100)
#@gui : Mélange Mode  = int(1,0,1)
#@gui : Mélange Pourcent  = int(75,0,100)
#@gui : Graine - 0 Pour Motif Aléatoire  = int(0,0,1000000)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/02/17</i>.</small>")

samj_Motif_Plasma :

 Details=$1
 PlasmaA=$2
 PlasmaB=$3
 Flou=$4
 Melange_Mode=$5
 Melange_Pourcent=$6
 Graine=$7
 Boucle=0
 Larg={w}
 Haut={h}
 rm[0]

 repeat $Details
  repeat 2
   $Larg,$Haut,1,3
   Boucle={$Boucle+1}
   if $Graine>0 srand {$Graine*$Boucle} endif
   ## option pour rendu totalement aléatoire noise[-1] {$Larg*$Haut*$Boucle},1  blur[-1] {16+$PlasmaA+$PlasmaB+$Boucle+{{round({$Larg/512})}}}
   plasma[-1] $PlasmaA,$PlasmaB
   blur[-1] {round($Larg/$Flou)}
   c[-1] 0,255
  done
  blend_seamless $Melange_Mode,0,$Melange_Pourcent
 done

#################################################
##                                             ##
##           FIN samj_Motif_Plasma             ##
##                                             ##
#################################################
#################################################
##                                             ##
##        samj_Lignes_H_ou_V_Colorees          ##
##                                             ##
#################################################

# Pour vérifier l'échelle de Gimp
#@gui Lignes H Ou V Colorees : samj_Lignes_H_ou_V_Colorees, samj_Lignes_H_ou_V_Colorees(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Lignes_H_ou_V_Colorees - Colored Lines</b></span>")
#@gui : Couleur - Color A = color(159,190,195)
#@gui : Couleur - Color B = color(55,67,140)
#@gui : Couleur - Color C = color(54,40,39)
#@gui : Couleur - Color D = color(140,81,88)
#@gui : Couleur - Color E = color(207,175,190)
#@gui : Couleur - Color F = color(220,202,196)
#@gui : Couleur - Color G = color(170,186,192)
#@gui : Couleur - Color H = color(130,149,139)
#@gui : Couleur - Color I = color(112,96,96)
#@gui : Couleur - Color J = color(237,168,138)
#@gui : Couleur - Color K = color(220,199,205)
#@gui : Couleur - Color L = color(234,217,219)
#@gui : Alpha = int(255,1,255)
#@gui : Largeur - Width = int(256,2,1024)
#@gui : Nombre De Lignes - Number Of Lines = int(256,2,1024)
#@gui : Hauteur De Une Ligne - Height Of One Line= int(1,1,20)
#@gui : Rotation 90 Degrés - Vertical Lines = bool(0)
#@gui : Origine - First Color = choice(0,"A","B","C","D","E","F","G","H","I","J","K","L")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Lignes_H_ou_V_Colorees :

 R_a=$1
 V_a=$2
 B_a=$3

 R_b=$4
 V_b=$5
 B_b=$6

 R_c=$7
 V_c=$8
 B_c=$9

 R_d=$10
 V_d=$11
 B_d=$12

 R_e=$13
 V_e=$14
 B_e=$15

 R_f=$16
 V_f=$17
 B_f=$16

 R_g=$19
 V_g=$20
 B_g=$21

 R_h=$22
 V_h=$23
 B_h=$25

 R_i=$25
 V_i=$26
 B_i=$27

 R_j=$28
 V_j=$29
 B_j=$30

 R_k=$31
 V_k=$32
 B_k=$33

 R_l=$34
 V_l=$35
 B_l=$36

 Transparence=$37
 Largeur=$38
 Nombre_De_Lignes=$39
 Hauteur_De_Une_Ligne=$40
 Rotation=$41
 Boucles=$42

 Position_H=0

 $Largeur,{$Nombre_De_Lignes*$Hauteur_De_Une_Ligne},1,4

 repeat $Nombre_De_Lignes
  repeat $Hauteur_De_Une_Ligne
   if $Boucles%12==0
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_a,$V_a,$B_a,$Transparence
   elif $Boucles%12==1
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_b,$V_b,$B_b,$Transparence
   elif $Boucles%12==2
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_c,$V_c,$B_c,$Transparence
   elif $Boucles%12==3
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_d,$V_d,$B_d,$Transparence
   elif $Boucles%12==4
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_e,$V_e,$B_e,$Transparence
   elif $Boucles%12==5
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_f,$V_f,$B_f,$Transparence
   elif $Boucles%12==6
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_g,$V_g,$B_g,$Transparence
   elif $Boucles%12==7
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_h,$V_h,$B_h,$Transparence
   elif $Boucles%12==8
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_i,$V_i,$B_i,$Transparence
   elif $Boucles%12==9
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_j,$V_j,$B_j,$Transparence
   elif $Boucles%12==10
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_k,$V_k,$B_k,$Transparence
   elif $Boucles%12==11
    line[-1] 0,$Position_H,$Largeur,$Position_H,1,$R_l,$V_l,$B_l,$Transparence
   endif
   Position_H={$Position_H+1}
  done
  Boucles={$Boucles+1}
 done
 if $Rotation==1 permute[1] yxzc endif
 rv[-2,-1]

#################################################
##                                             ##
##      FIN samj_Lignes_H_ou_V_Colorees        ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Tissu_Fond_Flou            ##
##                                             ##
#################################################

#@gui Tissu Fond Flou  : samj_Tissu_Fond_Flou , samj_Tissu_Fond_Flou_preview(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Capture Ligne</b></span>")
#@gui : X Origine  = float(0,0,100)
#@gui : Y Origine  = float(0,0,100)
#@gui : X Fin  = float(100,0,100)
#@gui : Y Fin  = float(100,0,100)
#@gui : Déplacement A  = float(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Tissu</b></span>")
#@gui : Tissu = bool(1)
#@gui : Forme = choice(0,"A","B","C","D")
#@gui : Blend 0pacity  = float(1,0,1)
#@gui : Inversion Calques Blend = bool(0)
#@gui : Angle Rotation  = float(0,0,360)
#@gui : Déplacement B  = float(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Flou/Blur</b></span>")
#@gui : Flou/Blur = float(0,0,1)
#@gui : Coeff. Flou = choice(0,"Flou/Blur *1","Flou/Blur *10","Flou/Blur *100","Flou/Blur *1000")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/02</i>.</small>")

samj_Tissu_Fond_Flou :

X_Origine={round({{w}/100*$1})}
Y_Origine={round({{h}/100*$2})}
X_Fin={round({{w}/100*$3})}
Y_Fin={round({{h}/100*$4})}
Deplacement_A=$5
Tissu=$6
Forme=$7
Blend_0pacity=$8
Inversion=$9
Angle_Rotation=$10
Deplacement_B=$11
Flou=$12
Coeff_Flou=$13

Largeur={w}
Hauteur={h}

 at_line[-1] $X_Origine,$Y_Origine,0,$X_Fin,$X_Fin,0
 resize[-1] $Largeur,$Hauteur
 to_rgb[-1]
 if $Tissu==1
  +Je_passe_l_hiver_en_Floride[-1]
  if $Forme==0
   permute[-1] yxzc
  elif $Forme==1
   permute[-1] yxzc
   mirror[-1] y
  elif $Forme==2
   mirror[-2] x
   permute[-1] yxzc
   mirror[-1] y
  elif $Forme==3
   mirror[-2] x
   permute[-1] yxzc
  endif
  resize[-1] $Largeur,$Hauteur
  if $Deplacement_B>0 shift[-1] 0,$Deplacement_B%,0,0,2 endif
  if $Deplacement_A>0 shift[-2] $Deplacement_A%,0,0,0,2 endif
  if $Inversion==1 rv[-2,-1] endif
  blend[-1,-2] average,$Blend_0pacity,0
 else
  if $Deplacement_A>0 shift[-1] $Deplacement_A%,0,0,0,2 endif
 endif
 if $Angle_Rotation>0 rotate[-1] $Angle_Rotation,1,2,50%,50% endif
 if $Flou>0 blur[-1] {$Flou*{10^$Coeff_Flou}} endif

# adaptation de : gimp Gradient [from line]
samj_Tissu_Fond_Flou_preview :
 repeat $! l[$>]
 samj_Tissu_Fond_Flou[-1] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13
 to_rgba
  l[0]
   line $1%,$2%,$3%,$4%,1,0xF0F0F0F0,255,255,255,255
   line $1%,$2%,$3%,$4%,1,0x0F0F0F0F,0,0,0,255
   circle $1%,$2%,4,1,255,0,0,255
   circle $3%,$4%,4,1,0,0,255,255
   circle $1%,$2%,4,1,0xFFFFFFFF,0,0,0,255
   circle $3%,$4%,4,1,0xFFFFFFFF,0,0,0,255
  endl
 endl done

#################################################
##                                             ##
##           FIN samj_Tissu_Fond_Flou          ##
##                                             ##
#################################################
#################################################
##                                             ##
##   Motifs_Aleatoires_Symetriques_Degrades    ##
##                                             ##
#################################################

# 2016/11/15
# 2014/04/24 ajout Inv.  pour utilisation + simple
# origine 2014/04/23
#@gui Motifs Aleatoires Symetriques Degrades : samj_Motifs_Aleatoires_Symetriques_Degrades, samj_Motifs_Aleatoires_Symetriques_Degrades(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu</small>")
#@gui : Type dégradé = choice(0,"Dégradés_XYZ_CIE A","Dégradés_XYZ_CIE B","Dégradés_HSL_TSL","Formes_Couleurs_Variees_Dans_Image")
#@gui : Dimensions motif = int(400,128,2048)
#@gui : Forme = int(4,3,12)
#@gui : Limite / boundary = int(1,0,2)
#@gui : Symétrie = int(1,0,2)
#@gui : Utiliser GIMP feltpen = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/15</i>.</small>")

samj_Motifs_Aleatoires_Symetriques_Degrades :

 Type_Degrade=$1
 Dimensions=$2
 Forme=$3
 Boundary=$4
 Symetrie=$5
 Utiliser_Gimp_Feltpen=$6

 Angle={180/$Forme}
 Inc_Angle=$Angle

 if $Type_Degrade==0
  samj_Degrades_XYZ_CIE[-1] 6,$Dimensions,240,240,40,255,120,40,240,255,0,0,0,100,64,64,0,0,1,0,100,-128,128,-128,128,0,5,0,0
 elif $Type_Degrade==1
  samj_Degrades_XYZ_CIE[-1] 0,$Dimensions,0,0,0,255,0,0,0,255,0,0,0,100,64,64,0,{round(u(0,2))},1,0,100,-128,128,-128,128,0,{round(u(0,2))},0,0
 elif $Type_Degrade==2
  samj_Degrades_HSL_TSL[-1] 4,$Dimensions,240,240,40,255,120,40,240,255,0,0,0,360,100,100,0,1,0,718,75,100,0,100,0,0,0,0
 elif $Type_Degrade==3
  rm[-1]
  $Dimensions,$Dimensions,1,4
  samj_Formes_Couleurs_Variees_Dans_Image 4,0,0,0,0,192,128,64,255,1,1,1,0,3,127,255,1,0,0,0,1
 endif

 fx_euclidean2polar[-1] 0.5,0.5,1,1,0

 repeat $Forme
  symmetrize[-1] 50%,50%,$Angle,$Boundary,0,0
  Angle={$Angle+$Inc_Angle}
 done

 if $Utiliser_Gimp_Feltpen==1
  fx_feltpen[-1] 1000,50,1,0.1,1,2
 endif

 if $Symetrie==1
  symmetrize[-1] 50%,50%,180,1,0,0
 elif $Symetrie==2
  symmetrize[-1] 50%,50%,180,1,0,0
  symmetrize[-1] 50%,50%,90,1,0,0
 endif

#################################################
##                                             ##
## FIN Motifs_Aleatoires_Symetriques_Degrades  ##
##                                             ##
#################################################
#################################################
##                                             ##
##              Degrades_HSL_TSL               ##
##                                             ##
#################################################
# rm[-1] Forme=0 repeat 12 400,400,1,4 samj_Degrades_HSL_TSL {round(u(0,5))},400,240,240,40,255,120,40,240,255,0,0,0,360,100,100,0,1,0,718,75,100,0,100,0,$Forme,0,0 Forme={$Forme+1} done
# 2016/11/15
# 2014/04/24
#@gui Degrades HSL TSL : samj_Degrades_HSL_TSL, samj_Degrades_HSL_TSL(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu</small>")
#@gui : Type dégradé = choice(4,"V Couleur A","H Couleur A","V Couleur B","H Couleur B","V Couleurs A/B","H Couleurs A/B","V Couleurs A/B Inv.","H Couleurs A/B Inv.")
#@gui : Dimensions image = int(800,128,2048)
#@gui : Couleur a = color(240,240,40,255)
#@gui : Couleur b = color(120,40,240,255)
#@gui : Décalage h = float(0,0,360)
#@gui : Décalage s = float(0,0,100)
#@gui : Décalage l = float(0,0,100)
#@gui : Variation h = float(360,1,360)
#@gui : Variation s = float(100,1,100)
#@gui : Variation l = float(100,1,100)
#@gui : Valider variations canal alpha = bool(0)
#@gui : Dégradés aléatoires = bool(0)
#@gui : H min. ded. aléa. = float(0,0,718)
#@gui : H max. ded. aléa. = float(718,0,718)
#@gui : S min. ded. aléa. = float(75,0,100)
#@gui : S max. ded. aléa. = float(100,0,100)
#@gui : L min. ded. aléa. = float(0,0,100)
#@gui : L max. ded. aléa. = float(100,0,100)
#@gui : Inverser dégradé = bool(0)
#@gui : Formes = choice(0,"Non","Sinus V - Param A B","Sinus H - Param A B","Cercles - Param A B","Rayons - Param A B","Lignes V Norm - Param A B","Lignes H Norm - Param A B","Plaid","Carré","Croix","Perspective - Param A","Sphere A","Sphere B")
#@gui : Paramètre forme a = int(0,0,100)
#@gui : Paramètre forme b = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Degrades_HSL_TSL :

 Type_Degrade=$1
 Dimensions=$2
 Ra=$3
 Ga=$4
 Ba=$5
 Aa=$6
 Rb=$7
 Gb=$8
 Bb=$9
 Ab=$10
 Decalage_H=$11
 Decalage_S=$12
 Decalage_L=$13
 Variation_H=$14
 Variation_S=$15
 Variation_L=$16
 Valider_Variations_Canal_A=$17
 Degrades_aleatoires=$18
 H_Min_Ded_Alea=$19
 H_Max_Ded_Alea=$20
 S_Min_Ded_Alea=$21
 S_Max_Ded_Alea=$22
 L_Min_Ded_Alea=$23
 L_Max_Ded_Alea=$24
 Inverser_Degrade=$25
 Variations_Formes=$26
 Parametre_Forme_A=$27
 Parametre_Forme_B=$28

 Nb_Boucles=0
 Inc_H=0
 Inc_S=0
 Inc_L=0
 Inc_A=0
 Diff=0
 Temp=0

 if $Variations_Formes==1
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
 elif $Variations_Formes==2
  if $Type_Degrade==0
   Type_Degrade=1
  elif $Type_Degrade==2
   Type_Degrade=3
  elif $Type_Degrade==4
   Type_Degrade=5
  elif $Type_Degrade==6
   Type_Degrade=7
  endif
 elif $Variations_Formes==3
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
  Valider_Variations_Canal_A=0
 elif $Variations_Formes==4
  if $Type_Degrade==0
   Type_Degrade=1
  elif $Type_Degrade==2
   Type_Degrade=3
  elif $Type_Degrade==4
   Type_Degrade=5
  elif $Type_Degrade==6
   Type_Degrade=7
  endif
  Valider_Variations_Canal_A=0
 elif $Variations_Formes==5
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
 elif $Variations_Formes==6
  if $Type_Degrade==0
   Type_Degrade=1
  elif $Type_Degrade==2
   Type_Degrade=3
  elif $Type_Degrade==4
   Type_Degrade=5
  elif $Type_Degrade==6
   Type_Degrade=7
  endif
 elif $Variations_Formes==7
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
 elif $Variations_Formes==8
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
 elif $Variations_Formes==9
  if $Type_Degrade==0
   Type_Degrade=1
  elif $Type_Degrade==2
   Type_Degrade=3
  elif $Type_Degrade==4
   Type_Degrade=5
  elif $Type_Degrade==6
   Type_Degrade=7
  endif
 elif $Variations_Formes==10
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
 elif $Variations_Formes==11
  if $Type_Degrade==0
   Type_Degrade=1
  elif $Type_Degrade==2
   Type_Degrade=3
  elif $Type_Degrade==4
   Type_Degrade=5
  elif $Type_Degrade==6
   Type_Degrade=7
  endif
 elif $Variations_Formes==12
  if $Type_Degrade==1
   Type_Degrade=0
  elif $Type_Degrade==3
   Type_Degrade=2
  elif $Type_Degrade==5
   Type_Degrade=4
  elif $Type_Degrade==7
   Type_Degrade=6
  endif
 endif

 # Conversions RGB > HSL   http://www.rapidtables.com/convert/color/rgb-to-hsl.htm
 # couleur a

 var_Ra={$Ra/255}
 var_Ga={$Ga/255}
 var_Ba={$Ba/255}

 var_Mina={min($var_Ra,$var_Ga,$var_Ba)}
 var_Maxa={max($var_Ra,$var_Ga,$var_Ba)}
 var_diffa={$var_Maxa-$var_Mina}
 if $var_Maxa==$var_Mina
  Ha=0
 elif $var_Maxa==$var_Ra
  Ha={{{$var_Ga-$var_Ba}/$var_diffa}%6}
 elif $var_Maxa==$var_Ga
  Ha={{$var_Ba-$var_Ra}/$var_diffa+2}
 else
  Ha={{$var_Ra-$var_Ga}/$var_diffa+4}
 endif
 Ha={$Ha*60} # deg
 if $Ha<0
  Ha={$Ha+360} # deg
 endif
 La={{$var_Maxa+$var_Mina}/2}
 if $var_diffa==0
  Sa=0
 else
  Sa={$var_diffa/{1-{abs({2*$La-1})}}}
 endif
 Sa={$Sa*100}
 La={$La*100}

 # couleur b

 var_Rb={$Rb/255}
 var_Gb={$Gb/255}
 var_Bb={$Bb/255}

 var_Minb={min($var_Rb,$var_Gb,$var_Bb)}
 var_Maxb={max($var_Rb,$var_Gb,$var_Bb)}
 var_diffb={$var_Maxb-$var_Minb}
 if $var_Maxb==$var_Minb
  Hb=0
 elif $var_Maxb==$var_Rb
  Hb={{{$var_Gb-$var_Bb}/$var_diffb}%6}
 elif $var_Maxb==$var_Gb
  Hb={{$var_Bb-$var_Rb}/$var_diffb+2}
 else
  Hb={{$var_Rb-$var_Gb}/$var_diffb+4}
 endif
 Hb={$Hb*60} # deg
 if $Hb<0
  Hb={$Hb+360} # deg
 endif
 Lb={{$var_Maxb+$var_Minb}/2}

 if $var_diffb==0
  Sb=0
 else
  Sb={$var_diffb/{1-{abs({2*$Lb-1})}}}
 endif
 Sb={$Sb*100}
 Lb={$Lb*100}

 # FIN Conversions RGB > HSL

 rm[-1]

 if $Type_Degrade==0||$Type_Degrade==1||$Type_Degrade==2||$Type_Degrade==3

  if $Type_Degrade==2||$Type_Degrade==3
   Ha=$Hb
   Sa=$Sb
   La=$Lb
   Aa=$Ab
  endif

  Nb_Boucles=0
  Inc_H={$Variation_H/$Dimensions}

  Sa={$Sa+$Decalage_S}
  if $Sa>100  Sa={$Sa-100} endif
  La={$La+$Decalage_L}
  if $La>100  La={$La-100} endif

  $Dimensions,$Dimensions,1,4

  repeat $Dimensions

   if $Degrades_aleatoires==1
    if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0}
     if $H_Max_Ded_Alea>$H_Min_Ded_Alea Ha={round(u($H_Min_Ded_Alea,$H_Max_Ded_Alea))} else Ha={round(u($H_Max_Ded_Alea,$H_Min_Ded_Alea))} endif
     if $S_Max_Ded_Alea>$S_Min_Ded_Alea Sa={round(u($S_Min_Ded_Alea,$S_Max_Ded_Alea))} else Sa={round(u($S_Max_Ded_Alea,$S_Min_Ded_Alea))} endif
     if $L_Max_Ded_Alea>$L_Min_Ded_Alea La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} else La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} endif
    endif
   endif

   # Conversions  HSL > RGB   http://www.rapidtables.com/convert/color/hsl-to-rgb.htm
   # couleur a
   if $Inverser_Degrade==0
    Ha_c={$Ha+$Decalage_H+{$Nb_Boucles*$Inc_H}}
   else
    Ha_c={$Ha+$Decalage_H-{$Nb_Boucles*$Inc_H}}
   endif
   if $Ha_c>359 Ha_c={$Ha_c-359} endif
   if $Ha_c<0 Ha_c={$Ha_c+359} endif
   Sa_c=$Sa
   La_c=$La

   if $Ha_c>=360 Ha_c=359 endif
   if $Sa_c>100 Sa_c=100 endif
   if $La_c>100 La_c=100 endif
   if $Ha_c<0 Ha_c=0 endif
   if $Sa_c<0 Sa_c=0 endif
   if $La_c<0 La_c=0 endif
   Sa_c={$Sa_c/100}
   La_c={$La_c/100}
   Ca={{1-{abs({2*$La_c-1})}}*$Sa_c}
   hha={$Ha_c/60}
   Xa={$Ca*{1-{abs({$hha%2-1})}}}
   Ra_c=0
   Ga_c=0
   Ba_c=0
   if $hha>=0&&$hha<1
    Ra_c=$Ca
    Ga_c=$Xa
   elif $hha>=1&&$hha<2
    Ra_c=$Xa
    Ga_c=$Ca
   elif $hha>=2&&$hha<3
    Ga_c=$Ca
    Ba_c=$Xa
   elif $hha>=3&&$hha<4
    Ga_c=$Xa
    Ba_c=$Ca
   elif $hha>=4&&$hha<5
    Ra_c=$Xa
    Ba_c=$Ca
   else
    Ra_c=$Ca
    Ba_c=$Xa
   endif
   ma={$La_c-$Ca/2}
   Ra_c={{$Ra_c+$ma}*255}
   Ga_c={{$Ga_c+$ma}*255}
   Ba_c={{$Ba_c+$ma}*255}

   if $Type_Degrade==0||$Type_Degrade==2
    line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Ra_c,$Ga_c,$Ba_c,$Aa
   elif $Type_Degrade==1||$Type_Degrade==3
    line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Ra_c,$Ga_c,$Ba_c,$Aa
   endif

   Nb_Boucles={$Nb_Boucles+1}
  done

 endif

 if $Type_Degrade==4||$Type_Degrade==5||$Type_Degrade==6||$Type_Degrade==7

  Nb_Boucles=0

  if $Type_Degrade==4||$Type_Degrade==5
   if $Inverser_Degrade==0
    Inc_H={{$Ha-$Hb}/$Dimensions}
    Inc_S={{$Sa-$Sb}/$Dimensions}
    Inc_L={{$La-$Lb}/$Dimensions}
    Inc_A={{$Aa-$Ab}/$Dimensions}
   else
    Inc_H={-1*{{$Ha-$Hb}/$Dimensions}}
    Inc_S={-1*{{$Sa-$Sb}/$Dimensions}}
    Inc_L={-1*{{$La-$Lb}/$Dimensions}}
    Inc_A={-1*{{$Aa-$Ab}/$Dimensions}}
   endif
  else
   if $Inverser_Degrade==0
    Inc_H={-1*{{$Ha-$Hb}/$Dimensions}}
    Inc_S={-1*{{$Sa-$Sb}/$Dimensions}}
    Inc_L={-1*{{$La-$Lb}/$Dimensions}}
    Inc_A={-1*{{$Aa-$Ab}/$Dimensions}}
   else
    Inc_H={{$Ha-$Hb}/$Dimensions}
    Inc_S={{$Sa-$Sb}/$Dimensions}
    Inc_L={{$La-$Lb}/$Dimensions}
    Inc_A={{$Aa-$Ab}/$Dimensions}
   endif
  endif

  $Dimensions,$Dimensions,1,4

  repeat $Dimensions

   if $Degrades_aleatoires==1
    if {{{$Nb_Boucles+1}%{round(u(2,{$Dimensions/10}))}}==0}
     if $H_Max_Ded_Alea>$H_Min_Ded_Alea Ha={round(u($H_Min_Ded_Alea,$H_Max_Ded_Alea))} else Ha={round(u($H_Max_Ded_Alea,$H_Min_Ded_Alea))} endif
     if $S_Max_Ded_Alea>$S_Min_Ded_Alea Sa={round(u($S_Min_Ded_Alea,$S_Max_Ded_Alea))} else Sa={round(u($S_Max_Ded_Alea,$S_Min_Ded_Alea))} endif
     if $L_Max_Ded_Alea>$L_Min_Ded_Alea La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} else La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} endif
    endif
   endif

   if $Valider_Variations_Canal_A==1
    Aa={$Aa+$Inc_A}
    if $Aa>255 Aa=255 Inc_A={-1*$Inc_A} endif
    if $Aa<0 Aa=0 Inc_A={-1*$Inc_A} endif
   endif

   # Conversions  HSL > RGB   http://www.rapidtables.com/convert/color/hsl-to-rgb.htm
   # couleur a
   Ha_c={$Ha+$Decalage_H+{$Nb_Boucles*$Inc_H}}
   if $Ha_c>359 Ha_c={$Ha_c-359} endif
   if $Ha_c<0 Ha_c={$Ha_c+359} endif
   Sa_c={$Sa+$Decalage_S+{$Nb_Boucles*$Inc_S}}
   if $Sa_c>100 Sa_c={$Sa_c-100} endif
   if $Sa_c<0 Sa_c={$Sa_c+100} endif
   La_c={$La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
   if $La_c>100 La_c={$La_c-100} endif
   if $La_c<0 La_c={$La_c+100} endif

   if $Ha_c>=360 Ha_c=359 endif
   if $Sa_c>100 Sa_c=100 endif
   if $La_c>100 La_c=100 endif
   if $Ha_c<0 Ha_c=0 endif
   if $Sa_c<0 Sa_c=0 endif
   if $La_c<0 La_c=0 endif
   Sa_c={$Sa_c/100}
   La_c={$La_c/100}
   Ca={{1-{abs({2*$La_c-1})}}*$Sa_c}
   hha={$Ha_c/60}
   Xa={$Ca*{1-{abs({$hha%2-1})}}}
   Ra_c=0
   Ga_c=0
   Ba_c=0
   if $hha>=0&&$hha<1
    Ra_c=$Ca
    Ga_c=$Xa
   elif $hha>=1&&$hha<2
    Ra_c=$Xa
    Ga_c=$Ca
   elif $hha>=2&&$hha<3
    Ga_c=$Ca
    Ba_c=$Xa
   elif $hha>=3&&$hha<4
    Ga_c=$Xa
    Ba_c=$Ca
   elif $hha>=4&&$hha<5
    Ra_c=$Xa
    Ba_c=$Ca
   else
    Ra_c=$Ca
    Ba_c=$Xa
   endif
   ma={$La_c-$Ca/2}
   Ra_c={{$Ra_c+$ma}*255}
   Ga_c={{$Ga_c+$ma}*255}
   Ba_c={{$Ba_c+$ma}*255}

   if $Type_Degrade==4||$Type_Degrade==6
    line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Ra_c,$Ga_c,$Ba_c,$Aa
   elif $Type_Degrade==5||$Type_Degrade==7
    line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Ra_c,$Ga_c,$Ba_c,$Aa
   endif

   Nb_Boucles={$Nb_Boucles+1}
  done

 endif

 if $Variations_Formes==1
  fx_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
 elif $Variations_Formes==2
  fx_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
 elif $Variations_Formes==3
  if $Parametre_Forme_A<50 Parametre_Forme_A={{$Parametre_Forme_A+50}/100} else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} endif
  if $Parametre_Forme_B<50 Parametre_Forme_B={{$Parametre_Forme_B+50}/100} else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} endif
  fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
 elif $Variations_Formes==4
  if $Parametre_Forme_A<50 Parametre_Forme_A={{$Parametre_Forme_A+50}/100} else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} endif
  if $Parametre_Forme_B<50 Parametre_Forme_B={{$Parametre_Forme_B+50}/100} else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} endif
  fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
 elif $Variations_Formes==5
  fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
 elif $Variations_Formes==6
  fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
 elif $Variations_Formes==7
  fx_plaid_texture[-1] 50,2,0,90,0,300
 elif $Variations_Formes==8
  fx_symmetrizoscope[-1] 5,0,1,0
 elif $Variations_Formes==9
  fx_symmetrizoscope[-1] 5,0,1,0
 elif $Variations_Formes==10
  fx_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
 elif $Variations_Formes==11
  fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
 elif $Variations_Formes==12
  fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
 endif

#################################################
##                                             ##
##             FIN Degrades_HSL_TSL            ##
##                                             ##
#################################################
#################################################
##                                             ##
##      Formes_Couleurs_Variees_Dans_Image     ##
##                                             ##
#################################################

# 2019/12/14 correction if{...}
# 2016/11/15
# 2014/04/28 preview
# 2014/04/24 blend

#@gui Formes Couleurs Variees Dans Image : samj_Formes_Couleurs_Variees_Dans_Image, samj_Formes_Couleurs_Variees_Dans_Image(1)
#@gui : Formes = choice(0,"Sinus V - Param A B","Sinus H - Param A B","Cercles - Param A B","Rayons - Param A B","Lignes V","Lignes H","Tiled V - Param A B C D","Tiled H - Param A B C D","Lignes V Norm - Param A B","Lignes H Norm - Param A B","Plaid","Carré","Croix","Perspective - Param A","Sphere A","Sphere B")
#@gui : Paramètre forme a = int(0,0,100)
#@gui : Paramètre forme b = int(0,0,100)
#@gui : Paramètre forme c = int(0,0,100)
#@gui : Paramètre forme d = int(0,0,100)
#@gui : Canal r = int(192,0,255)
#@gui : Canal v = int(128,0,255)
#@gui : Canal b = int(64,0,255)
#@gui : Canal alpha = int(255,0,255)
#@gui : Valider variations canal r = bool(1)
#@gui : Valider variations canal v = bool(1)
#@gui : Valider variations canal b = bool(1)
#@gui : Valider variations canal alpha = bool(0)
#@gui : Type variations =  choice(0,"A","B","C","D","E","F")
#@gui : Décalage = int(127,0,255)
#@gui : Etendue = int(255,1,255)
#@gui : Couleurs aléatoires / random colors = bool(0)
#@gui : Flou / blur = float(0,0,5)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / noise = float(0,0,200)
#@gui : Canal alpha = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Formes_Couleurs_Variees_Dans_Image :

 Variations_Formes=$1
 Parametre_Forme_A=$2
 Parametre_Forme_B=$3
 Parametre_Forme_C=$4
 Parametre_Forme_D=$5
 Canal_R=$6
 Canal_V=$7
 Canal_B=$8
 Canal_A=$9
 Valider_Variations_Canal_R=$10
 Valider_Variations_Canal_V=$11
 Valider_Variations_Canal_B=$12
 Valider_Variations_Canal_A=$13
 Type_Variations=$14
 Decalage=$15
 Etendue=$16
 Couleurs_aleatoires=$17
 Flou=$18
 Deformation=$19
 Bruit=$20
 Canal_Alpha=$21

 Largeur_Origine={w}
 Hauteur_Origine={h}
 Total_Boucles=0
 Nb_Boucle=0
 Val_R=$Canal_R
 Val_V=$Canal_V
 Val_B=$Canal_B
 Val_A=$Canal_A
 R_imp=0
 V_imp=0
 B_imp=0
 A_imp=0

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 fill_color[-1] 0,0,0,255

 if $Variations_Formes==0||$Variations_Formes==2||$Variations_Formes==4||$Variations_Formes==6||$Variations_Formes==8||$Variations_Formes==10||$Variations_Formes==11||$Variations_Formes==13||$Variations_Formes==14
  Total_Boucles=$Largeur_Origine
 elif $Variations_Formes==1||$Variations_Formes==3||$Variations_Formes==5||$Variations_Formes==7||$Variations_Formes==9||$Variations_Formes==12||$Variations_Formes==15
  Total_Boucles=$Hauteur_Origine
 endif

 repeat $Total_Boucles

  if $Couleurs_aleatoires==1

   if $Decalage==0
    if $Nb_Boucle%round(u(1,255))==0
     Canal_R={round(u(0,255))}
     Canal_V={round(u(0,255))}
     Canal_B={round(u(0,255))}
     Val_R=$Canal_R
     Val_V=$Canal_V
     Val_B=$Canal_B
    endif
   else
    if $Nb_Boucle%$Decalage==0
     Canal_R={round(u(0,255))}
     Canal_V={round(u(0,255))}
     Canal_B={round(u(0,255))}
     Val_R=$Canal_R
     Val_V=$Canal_V
     Val_B=$Canal_B
    endif
   endif
  endif

  if $Valider_Variations_Canal_R==1
   if $Type_Variations==0
    Val_R={$Val_R+1}
    if $Val_R>{$Canal_R+$Decalage} Val_R=$Canal_R endif
    R_imp={{$Val_R+$Decalage}%$Etendue}
   elif $Type_Variations==1
    Val_R={$Val_R-1}
    if $Val_R<{$Canal_R-$Decalage} Val_R=$Canal_R endif
    R_imp={{$Val_R-$Decalage}%$Etendue}
   elif $Type_Variations==2
    Val_R={$Val_R+1}
    if $Val_R>255 Val_R=$Canal_R endif
    R_imp={{$Val_R+$Decalage}%$Etendue}
   elif $Type_Variations==3
    Val_R={$Val_R-1}
    if $Val_R<0 Val_R=$Canal_R endif
    R_imp={{$Val_R-$Decalage}%$Etendue}
   elif $Type_Variations==4
    Val_R={$Val_R+{round(u(0,3))}}
    if $Val_R>255 Val_R=$Canal_R endif
    R_imp={{$Val_R+$Decalage}%$Etendue}
   elif $Type_Variations==5
    Val_R={$Val_R-{round(u(0,3))}}
    if $Val_R<0 Val_R=$Canal_R endif
    R_imp={{$Val_R-$Decalage}%$Etendue}
   endif
  else
   R_imp=$Canal_R
  endif

  if $Valider_Variations_Canal_V==1
   if $Type_Variations==0
    Val_V={$Val_V+1}
    if $Val_V>{$Canal_V+$Decalage} Val_V=$Canal_V endif
    V_imp={{$Val_V+$Decalage}%$Etendue}
   elif $Type_Variations==1
    Val_V={$Val_V-1}
    if $Val_V<{$Canal_V-$Decalage} Val_V=$Canal_V endif
    V_imp={{$Val_V-$Decalage}%$Etendue}
   elif $Type_Variations==2
    Val_V={$Val_V+1}
    if $Val_V>255 Val_V=$Canal_V endif
    V_imp={{$Val_V+$Decalage}%$Etendue}
   elif $Type_Variations==3
    Val_V={$Val_V-1}
    if $Val_V<0 Val_V=$Canal_V endif
    V_imp={{$Val_V-$Decalage}%$Etendue}
   elif $Type_Variations==4
    Val_V={$Val_V+{round(u(0,3))}}
    if $Val_V>255 Val_V=$Canal_V endif
    V_imp={{$Val_V+$Decalage}%$Etendue}
   elif $Type_Variations==5
    Val_V={$Val_V-{round(u(0,3))}}
    if $Val_V<0 Val_V=$Canal_V endif
    V_imp={{$Val_V-$Decalage}%$Etendue}
   endif
  else
   V_imp=$Canal_V
  endif

  if $Valider_Variations_Canal_B==1
   if $Type_Variations==0
    Val_B={$Val_B+1}
    if $Val_B>{$Canal_B+$Decalage} Val_B=$Canal_B endif
    B_imp={{$Val_B+$Decalage}%$Etendue}
   elif $Type_Variations==1
    Val_B={$Val_B-1}
    if $Val_B<{$Canal_B-$Decalage} Val_V=$Canal_B endif
    B_imp={{$Val_B-$Decalage}%$Etendue}
   elif $Type_Variations==2
    Val_B={$Val_B+1}
    if $Val_B>255 Val_B=$Canal_B endif
    B_imp={{$Val_B+$Decalage}%$Etendue}
   elif $Type_Variations==3
    Val_B={$Val_B-1}
    if $Val_B<0 Val_V=$Canal_B endif
    B_imp={{$Val_B-$Decalage}%$Etendue}
   elif $Type_Variations==4
    Val_B={$Val_B+{round(u(0,3))}}
    if $Val_B>255 Val_B=$Canal_B endif
    B_imp={{$Val_B+$Decalage}%$Etendue}
   elif $Type_Variations==5
    Val_B={$Val_B-{round(u(0,3))}}
    if $Val_B<0 Val_V=$Canal_B endif
    B_imp={{$Val_B-$Decalage}%$Etendue}
   endif
  else
   B_imp=$Canal_B
  endif

  if $Valider_Variations_Canal_A==1
   if $Type_Variations==0
    Val_A={$Val_A+1}
    if $Val_A>{$Canal_A+$Decalage} Val_A=$Canal_A endif
    A_imp={{$Val_A+$Decalage}%$Etendue}
   elif $Type_Variations==1
    Val_A={$Val_A-1}
    if $Val_A<{$Canal_A-$Decalage} Val_A=$Canal_A endif
    A_imp={{$Val_A-$Decalage}%$Etendue}
   elif $Type_Variations==2
    Val_A={$Val_A+1}
    if $Val_A>255 Val_A=$Canal_A endif
    A_imp={{$Val_A+$Decalage}%$Etendue}
   elif $Type_Variations==3
    Val_A={$Val_A-1}
    if $Val_A<0 Val_A=$Canal_A endif
    A_imp={{$Val_A-$Decalage}%$Etendue}
   elif $Type_Variations==4
    Val_A={$Val_A+{round(u(0,3))}}
    if $Val_A>255 Val_A=$Canal_A endif
    A_imp={{$Val_A+$Decalage}%$Etendue}
   elif $Type_Variations==5
    Val_A={$Val_A-{round(u(0,3))}}
    if $Val_A<0 Val_A=$Canal_A endif
    A_imp={{$Val_A-$Decalage}%$Etendue}
   endif
  else
   A_imp=$Canal_A
  endif

  if $Variations_Formes==0||$Variations_Formes==2||$Variations_Formes==4||$Variations_Formes==6||$Variations_Formes==8||$Variations_Formes==10||$Variations_Formes==11||$Variations_Formes==13||$Variations_Formes==14
   line[-1] $Nb_Boucle,0,$Nb_Boucle,{$Hauteur_Origine-1},1,$R_imp,$V_imp,$B_imp,$A_imp
  elif $Variations_Formes==1||$Variations_Formes==3||$Variations_Formes==5||$Variations_Formes==7||$Variations_Formes==9||$Variations_Formes==12||$Variations_Formes==15
   line[-1] 0,$Nb_Boucle,{$Largeur_Origine-1},$Nb_Boucle,1,$R_imp,$V_imp,$B_imp,$A_imp
  endif

  Nb_Boucle={$Nb_Boucle+1}

 done

 if $Variations_Formes==0
  fx_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
 elif $Variations_Formes==1
  fx_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
 elif $Variations_Formes==2
  if $Parametre_Forme_A<50 Parametre_Forme_A={{$Parametre_Forme_A+50}/100} else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} endif
  if $Parametre_Forme_B<50 Parametre_Forme_B={{$Parametre_Forme_B+50}/100} else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} endif
  fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
 elif $Variations_Formes==3
  if $Parametre_Forme_A<50 Parametre_Forme_A={{$Parametre_Forme_A+50}/100} else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} endif
  if $Parametre_Forme_B<50 Parametre_Forme_B={{$Parametre_Forme_B+50}/100} else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} endif
  fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
 elif $Variations_Formes==6
  fx_normalize_tiles[-1] {$Parametre_Forme_A+4},1,{$Parametre_Forme_B/100*255},{{$Parametre_Forme_C-100}/100*-255},{{$Parametre_Forme_D+3}%22}
 elif $Variations_Formes==7
  fx_normalize_tiles[-1] 1,{$Parametre_Forme_A+4},{$Parametre_Forme_B/100*255},{{$Parametre_Forme_C-100}/100*-255},{{$Parametre_Forme_D+3}%22}
 elif $Variations_Formes==8
  fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
 elif $Variations_Formes==9
  fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
 elif $Variations_Formes==10
  fx_plaid_texture[-1] 50,2,0,90,0,300
 elif $Variations_Formes==11
  fx_symmetrizoscope[-1] 5,0,1,0
 elif $Variations_Formes==12
  fx_symmetrizoscope[-1] 5,0,1,0
 elif $Variations_Formes==13
  fx_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
 elif $Variations_Formes==14
  fill_color[-2] 0,0,0,0
  fx_map_sphere[-1] {min($Largeur_Origine,$Hauteur_Origine)},{min($Largeur_Origine,$Hauteur_Origine)},90,0.5,0,0,20,0,0,0,0.5
  autocrop[-1]
 elif $Variations_Formes==15
  fill_color[-2] 0,0,0,0
  fx_map_sphere[-1] {min($Largeur_Origine,$Hauteur_Origine)},{min($Largeur_Origine,$Hauteur_Origine)},90,0.5,0,0,20,0,0,0,0.5
 endif

 if $Flou>0 blur[-1] $Flou,0 endif
 if $Deformation>0 deform[-1] $Deformation endif
 if $Bruit>0 apply_channels[-1] "fx_noise "$Bruit",0,22,1",1 endif

 blend[-2,-1] alpha,1,0

#################################################
##                                             ##
##    FIN Formes_Couleurs_Variees_Dans_Image   ##
##                                             ##
#################################################
#################################################
##                                             ##
##                samj_Steps_V2                ##
##                                             ##
#################################################

#@gui Steps V2 : samj_Steps_V2, samj_Steps_V2(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Pixelise X = int(10,1,256)
#@gui : Pixelise X = int(10,1,256)
#@gui : Area = int(4,1,16)
#@gui : Area IHC = bool(1)
#@gui : Isophotes = int(10,1,127)
#@gui : Dilate Circle = int(2,1,5)
#@gui : Smoothness = float(60,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Background = bool(0)
#@gui : Color = float(1.1,1,1.2)
#@gui : Variation = int(10,5,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Steps_V2 :

Pixelise_X=$1
Pixelise_Y=$2
Area_Valeur=$3
Area_is_high_connectivity=$4
Isophotes_Valeur=$5
Dilate_Circle_Valeur=$6
Smoothness=$7
BG=$8
BG_Color=$9
BG_Variation=$10

 +Je_passe_l_hiver_en_Floride[-1]
 to_rgba[-1]
 if $BG==1
  +Je_passe_l_hiver_en_Floride[-1]
 endif
 pixelize[-1,-2] $Pixelise_X,$Pixelise_Y
 area[-1] $Area_Valeur,$Area_is_high_connectivity
 c[-1] 0,255
 n[-1] 0,255
 isophotes[-1] $Isophotes_Valeur
 dilate_circ[-1] $Dilate_Circle_Valeur
 to_graya[-1]
 fx_blend_edges[-1,-2] 1,$Smoothness,0
 if $BG==1
  blur[-2] {{{w}+{h}}/$BG_Variation}
  pow[-2] $BG_Color
  pixelize[-2] $Pixelise_X,$Pixelise_Y
  blend[-1,-2] alpha
 endif

#################################################
##                                             ##
##              FIN samj_Steps_V2              ##
##                                             ##
#################################################
#################################################
##                                             ##
##        samj_Variation_Stained_Glass         ##
##                                             ##
#################################################

#@gui Variation Stained Glass  : samj_Variation_Stained_Glass, samj_Variation_Stained_Glass(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Colored Outlines</b></span>")
#@gui : Axes = choice(0,"XY","X","Y")
#@gui : Blur = float(2,0,10)
#@gui : Isophote = float(8,6,16)
#@gui : Smooth = int(0,0,100)
#@gui : Dilate = int(3,1,16)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Stained Glass</b></span>")
#@gui : Edges = float(40,0,100)
#@gui : Shading = int(100,0,200)
#@gui : Is Precise = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Background</b></span>")
#@gui : Color = float(1.1,1,1.2)
#@gui : Variation = int(20,10,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/13</i>.</small>")

samj_Variation_Stained_Glass :
 to_rgba[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 stained_glass[-1] $6,{$7/1000},$8
 to_rgba[-1]
 n[-1,-2] 0,255
 samj_Colored_Outlines[-2] $1,$2,$3,$4,$5,0,0,0,0
 blend[-1,-2] alpha
 blur[-2] {{{w}+{h}}/$10}
 pow[-2] $9
 blend[-1,-2] alpha
#################################################
##                                             ##
##       FIN samj_Variation_Stained_Glass      ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Rays_Of_Colors                ##
##                                             ##
#################################################

#### samj 20161105 mise à jour ancien filtre et ajout couleur fond
#### samj 20131211
#@gui Rays Of Colors : samj_Rays_Of_Colors, samj_Rays_Of_Colors(0)
#@gui : Color Intensity = int(300,1,1600)
#@gui : Color Density = int(12,2,40)
#@gui : Radius = float(40,0,400)
#@gui : Border smoothness = float(16,0,200)
#@gui : Border width = float(38,0,100)
#@gui : Merge Layers  = bool(1)
#@gui : Background Color = color(0,0,0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2020/10/24</i>.</small>")

samj_Rays_Of_Colors :

Color_Intensity=$1
Color_Density=($2/512*{w})
Radius=$3
Border_smoothness=$4
Border_width=$5
Merge_Layers=$6
R_a=$7
V_a=$8
B_a=$9

 to_rgb[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 fill_color[-1] $R_a,$V_a,$B_a
 repeat $Color_Intensity
  R_Couleur={round(u)*255}
  V_Couleur={round(u)*255}
  B_Couleur={round(u)*255}
  X_point={round((u)*{w})}
  Y_point={round((u)*{h})}
  polygon[-1] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
 done
 fx_textured_glass[-1] 40,40,1,1,0,2,0
 fx_map_sphere[-1] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
 #####
 fill_color[-2] $R_a,$V_a,$B_a
 repeat $Color_Intensity
  R_Couleur={round(u)*255}
  V_Couleur={round(u)*255}
  B_Couleur={round(u)*255}
  X_point={round((u)*{w})}
  Y_point={round((u)*{h})}
  polygon[-2] 4,$X_point,$Y_point,$X_point,{$Y_point+$Color_Density},{$X_point+$Color_Density},{$Y_point+$Color_Density},{$X_point+$Color_Density},$Y_point,1,$R_Couleur,$V_Couleur,$B_Couleur,255
 done
 fx_textured_glass[-2] 40,40,1,1,0,2,0
 fx_map_sphere[-2] {w},{h},$Radius,0.5,0,$Border_smoothness,$Border_width,0,0,100,3
 if $Merge_Layers==1
  blend[-2,-1] add
 endif

#################################################
##                                             ##
##              FIN Rays_Of_Colors             ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_EPPE_Transform             ##
##                                             ##
#################################################

#@gui EPPE Transform : samj_EPPE_Transform, samj_EPPE_Transform(1)
#@gui :_=note("samj_EPPE_Transform")
#@gui : X Centre = float(50,0,100)
#@gui : Y Centre = float(50,0,100)
#@gui : Rendu = choice(0,"Imagegrid","Imagegrid Hexagonal","Imagegrid Triangular","BoxFitting")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Imagegrid</b></span>")
#@gui : X-size = int(10,2,100)
#@gui : Y-size = int(10,2,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Imagegrid Hexagonal</b></span>")
#@gui : Résolution = int(32,1,128)
#@gui : Outline = float(0.1,0,0.5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Imagegrid Triangular</b></span>")
#@gui : Pattern width = int(10,8,128)
#@gui : Pattern height = int(18,8,128)
#@gui : Pattern type = choice(0,"Horizontal","Vertical","Crossed","Cube","Decreasing","Increasing")
#@gui : Outline color = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>BoxFitting</b></span>")
#@gui : Minimal size = int(3,1,32)
#@gui : Maximal size = int(0,0,32)
#@gui : Initial density = float(0.1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_EPPE_Transform :

X_Centre=$1
Y_Centre=$2
Rendu=$3

 euclidean2polar[-1] $X_Centre%,$Y_Centre%,1,1

 if $Rendu==0
  imagegrid[-1] $4,$5
 elif $Rendu==1
  imagegrid_hexagonal[-1] $6,$7
 elif $Rendu==2
  imagegrid_triangular[-1] $8,$9,$10,{1-($14/255)},$11,$12,$13
 elif $Rendu==3
  boxfitting[-1] $15,$16,$17,3
 endif

 polar2euclidean[-1] $X_Centre%,$Y_Centre%,1,1

#################################################
##                                             ##
##           FIN samj_EPPE_Transform           ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Contours_Gros_Pixels          ##
##                                             ##
#################################################

# ajouts dilate_circ, edges
# samj_Contours_Gros_Pixels 1,8,4,20,20,16,1.1,0,1,15,1,0,0,1

#@gui Contours Gros Pixels : samj_Contours_Gros_Pixels, samj_Contours_Gros_Pixels(1)
#@gui :_=note("Contours GrosPixels")
#@gui : Flou/Blur = float(1,0,5)
#@gui : Isophotes Nb Levels = int(8,1,256)
#@gui : Dilatation = int(0,0,10)
#@gui : Gros Pixels X = int(20,5,90)
#@gui : Gros Pixels Y = int(20,5,90)
#@gui : Quantize Levels = int(16,1,256)
#@gui : Couleur = float(1.1,0.8,4)
#@gui : Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Edges</b></span>")
#@gui : VALIDATION EDGES = bool(0)
#@gui : Threshold = float(15,0.5,50)
#@gui : Colorization = bool(0)
#@gui : Alpha Colorization = bool(0)
#@gui : Colorization Mode = choice{0,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Colorization Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Contours_Gros_Pixels :

Flou=$1
Isophotes_Nb_Levels=$2
Dilatation=$3
Gros_Pixels_X=$4
Gros_Pixels_Y=$5
Quantize_Levels=$6
Couleur=$7
Transparence=$8
Valider_Edges=$9
Threshold_Edges=$10
Colorisation=$11
Alpha_Colorisation=$12
Mode_blend=$13
Opacity_blend=$14

 to_rgb[-1]
 blur[-1] $Flou
 isophotes[-1] $Isophotes_Nb_Levels
 if $Dilatation>0
  dilate_circ[-1] $Dilatation
 endif
 if $Valider_Edges==1
  if $Colorisation==1
   +Je_passe_l_hiver_en_Floride[-1]
   pow[-2] $Couleur
   dilate_circ[-2] $Dilatation
  endif
 endif
 # Partie code filtre Tetris
 wh={w},{h},1,{s} r $Gros_Pixels_X%,$Gros_Pixels_Y%,10%,100%,2 n[-1] 0,255 quantize[-1] $Quantize_Levels,1,0 r $wh

 pow[-1] $Couleur
 if $Transparence==1
  to_rgba[-1]
 else
  to_rgb[-1]
 endif
 if $Valider_Edges==1
  edges[-1] $Threshold_Edges%
  n[-1] 0,255
  to_rgb[-1]
  if $Colorisation==1
   n[-2] 0,255
   if $Alpha_Colorisation==0
    to_rgb[-2]
   endif
   gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0 # add
  endif
 endif

#################################################
##                                             ##
##        FIN samj_Contours_Gros_Pixels        ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  samj_Marbre                ##
##                                             ##
#################################################

#### 20161030 version origine test avec version 1.7.9pre
#### 20161031 Ajout Blend Image

#@gui Marbre Marble : samj_Marbre, samj_Marbre(1)
#@gui :_=note("samj_Marbre")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Plasma</b></span>")
#@gui : Alpha = float(1,0,5)
#@gui : Beta = float(1,0,100)
#@gui : Scale = int(8,2,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Flou-Blur</b></span>")
#@gui : Flou/Blur = float(5,2,20)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Gris-Gray</b></span>")
#@gui : Gris/Gray = float(0.2,0.1,0.6)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Bruit-Noise</b></span>")
#@gui : Spread = int(0,0,10)
#@gui : Atténuation = float(0,0,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Couleur-Color</b></span>")
#@gui : Colorisation = bool(0)
#@gui : Couleur / Color = color(140,120,220)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Blend Image</b></span>")
#@gui : Blend Image = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Marbre :

Plasma_alpha=$1
Plasma_beta=$2
Plasma_scale=$3
Flou=$4
Gris=$5
Bruit_Spread=$6
Attenuation=$7
Colorisation=$8
R_a=$9
V_a=$10
B_a=$11
Blend_Image=$12
Mode_blend=$13
Opacity_blend=$14

 if $Blend_Image==1
  +Je_passe_l_hiver_en_Floride[-1]
 endif
 plasma[-1] $Plasma_alpha,$Plasma_beta,$Plasma_scale
 blur[-1] $Flou
 structuretensors[-1]
 abs[-1]
 spread[-1] $Bruit_Spread
 pow[-1] $Gris
 to_gray[-1]
 blur[-1] $Attenuation
 n[-1] 0,255
 to_rgb[-1]
 if $Colorisation==1
  {w},{h},1,3
  fill_color[-1] $R_a,$V_a,$B_a
  blend_median[-1,-2]
 endif
 if $Blend_Image==1
  to_rgb[-2]
  gimp_blend_1651[-2,-1] $Mode_blend,2,$Opacity_blend,0 # Average
 endif
#################################################
##                                             ##
##                FIN samj_Marbre              ##
##                                             ##
#################################################
#################################################
##                                             ##
##           Points_Aleatoires_001             ##
##                                             ##
#################################################

## 2015/03/15  menu, itérations , pas de preview
## version 3 2014/01/30 ajout Continuité et déplacement Fou , Tour , Reine. Correction avec variable Choix
## version 2 2014/01/30 ajout déplacement Cavalier
## version 1 2014/01/30 origine

#@gui Points Aleatoires 001  : samj_Points_Aleatoires_001, gui_no_preview
#@gui : sep = separator()
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Points</small></span>")
#@gui : Itérations = int(10,1,200)
#@gui : Couleur Point = color(255,255,0,255)
#@gui : Mode = choice(3,"XY Aléatoire","X Aléatoire","Y Aléatoire","Cavalier","Fou","Tour","Reine")
#@gui : Couleurs Aléatoires = bool(0)
#@gui : Continuité entre itérations = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Points_Aleatoires_001 :
Iterations=$1
R_Point=$2
V_Point=$3
B_Point=$4
A_Point=$5
Mode=$6
Couleurs_Aleatoires=$7
Continuite=$8
Choix=0
Cavalier=0
Largeur_Origine={w}
Hauteur_Origine={h}
Position_X={round(u(0,{$Largeur_Origine-1}))}
Position_Y={round(u(0,{$Hauteur_Origine-1}))}
{w},{h},1,4
fill_color[-1] 0,0,0,0
rm[-2]
repeat $Iterations
if $Couleurs_Aleatoires==1
R_Point={round(u(0,255))}
V_Point={round(u(0,255))}
B_Point={round(u(0,255))}
A_Point=255
endif
if $Continuite==0
Position_X={round(u(0,{$Largeur_Origine-1}))}
Position_Y={round(u(0,{$Hauteur_Origine-1}))}
endif
repeat $Largeur_Origine+$Hauteur_Origine
Choix={round(u(0,1))}
if $Mode==0
Inc_X={{round(u(0,2))}-1}
Inc_Y={{round(u(0,2))}-1}
elif $Mode==1
Inc_X={{round(u(0,2))}-1}
Inc_Y={{round(u(0,{$|}))%3}-1}
elif $Mode==2
Inc_X={{round(u(0,{$|}))%3}-1}
Inc_Y={{round(u(0,2))}-1}
elif $Mode==3
if $Choix==0
Cavalier={round(u(0,7))}
else
Cavalier={round(u(0,4095)%8)}
endif
if $Cavalier==0
Inc_X=-1
Inc_Y=2
elif $Cavalier==1
Inc_X=1
Inc_Y=2
elif $Cavalier==2
Inc_X=2
Inc_Y=1
elif $Cavalier==3
Inc_X=2
Inc_Y=-1
elif $Cavalier==4
Inc_X=1
Inc_Y=-2
elif $Cavalier==5
Inc_X=-1
Inc_Y=-2
elif $Cavalier==6
Inc_X=-2
Inc_Y=-1
elif $Cavalier==7
Inc_X=-2
Inc_Y=1
endif
elif $Mode==4
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
if $Choix==0
Inc_Y=$Inc_X
else
Inc_Y={0-$Inc_X}
endif
elif $Mode==5
if {$Choix==0}
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=0
else
Inc_X=0
Inc_Y={{round(u(0,8))}-{round(u(0,8))}}
endif
elif $Mode==6
Choix={round(u(0,3))}
if $Choix==0
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=$Inc_X
elif $Choix==1
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y=0
elif $Choix==2
Inc_X=0
Inc_Y={{round(u(0,8))}-{round(u(0,8))}}
elif $Choix==3
Inc_X={{round(u(0,8))}-{round(u(0,8))}}
Inc_Y={0-$Inc_X}
endif
endif
Position_X={$Position_X+$Inc_X}
if {$Position_X<0}
Position_X={$Largeur_Origine-1}
endif
if $Position_X>{$Largeur_Origine-1}
Position_X=0
endif
Position_Y={$Position_Y+$Inc_Y}
if $Position_Y<0
Position_Y={$Hauteur_Origine-1}
endif
if $Position_Y>{$Hauteur_Origine-1}
Position_Y=0
endif
point[-1] $Position_X,$Position_Y,0,1,$R_Point,$V_Point,$B_Point,$A_Point
done
done

#################################################
##                                             ##
##          FIN Points_Aleatoires_001          ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Denim_samj                    ##
##                                             ##
#################################################
# version 1.00 2013 01 17
# 17 janvier 2014  modification blend
# 2014/04/24 blend
# 2015/03/15 simplification , menu
# 2015/03/31 canaux de gimp_noise :

#@gui Denim Texture : Denim_samj, Denim_samj(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Texture</small></span>")
#@gui : Dimension motif base = int(5,2,30)
#@gui : Dilatation Motif / Pattern = int(2,0,5)
#@gui : Retourner Motif / Flip Pattern = bool(0)
#@gui : Déformation 1 = int(40,0,200)
#@gui : Déformation 2 = int(40,0,200)
#@gui : Denim [bruit/noise] = int(25,0,100)
#@gui : Usure [bruit/noise] = int(50,0,100)
#@gui : Netteté / Sharpness = float(0,0,500)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Couleur</small></span>")
#@gui : Couleur Denim  = color(43,108,126,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Version : <i>2020/10/24</i>.</small>")

Denim_samj :

Dimension_Motif=$1 # 5
Dilatation=$2
Retourner_motif=$3
Deformation_1=$4
Deformation_2=$5
Amplitude_Bruit=$6 # 30
Amplitude_Bruit_2=$7
Nettete=$8

# couleur 2B6C7E 43,108,126
R_Couleur_Denim=$9
V_Couleur_Denim=$10
B_Couleur_Denim=$11
A_Couleur_Denim=$12

 Largeur={w}
 Hauteur={h}
 $Largeur,$Hauteur,1,4
 fill_color[-1] $R_Couleur_Denim,$V_Couleur_Denim,$B_Couleur_Denim,$A_Couleur_Denim
 to_rgba[-1]
 fx_noise[-1] $Amplitude_Bruit,0,11,0 # laisser la transparence "YCbCr [luminance]"
 $Dimension_Motif,$Dimension_Motif,1,4
 if $Retourner_motif==0
  line[-1] 0,$Dimension_Motif,$Dimension_Motif,0,1,0,0,0,255
 else
  line[-1] 0,0,$Dimension_Motif,$Dimension_Motif,1,0,0,0,255
 endif
 resize[-1] [-2],[-2],1,100%,0,2
 dilate_circ[-1] $Dilatation
 #alpha
 blend[-1,-2] alpha,1,1
 water[-1] {$Deformation_1/1000},{$Deformation_2/100}
 fx_noise[-1] $Amplitude_Bruit_2,0,26,0 # bruit transparence "HSI [intensity]"
 sharpen[-1] $Nettete
 rv[-2,-1] # inverser les calques
 rm[-1]

#################################################
##                                             ##
##             FIN  Denim_samj                 ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  Courtepointe               ##
##                                             ##
#################################################
## catégorie "Patterns" pour réaliser des motifs de courtepointe ou tapis
#
# 2015/03/07 pas de preview , ajout courbes interactives , fonction samj_gimp_texture_zero_zero_un remplacée par samj_Texture_Granuleuse
# 2014/04/28 preview
# 2014/01/06 origine
#@gui Random Pattern Courtepointe  : samj_Courtepointe, gui_no_preview
#@gui :_=note("Motif au rendu aléatoire / Random Pattern")
#@gui : sep = separator()
#@gui : Cossin 1 / Parameter 1 = int(20,1,100)
#@gui : Cossin 2 / Parameter 2 = bool(0)
#@gui : Répetition / Repeat = int(1,1,5)
#@gui : Croix / Cross = bool(0)
#@gui : Texture = bool(1)
#@gui : Courbes des couleurs /  Color Curves = choice("RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")
samj_Courtepointe :

 Cossin=$1
 Cossin_Deux=$2
 Repetition=$3
 Croix=$4
 Texture=$5
 Courbes_Interactives_Couleurs=$6

 rorschach[-1] {$Cossin}%,1

 if $Cossin_Deux==1
  n[-1] 64,192
 endif

 n[-1] 0,255

 repeat $Repetition
  fx_array_mirror[-1] 1,0,0,2,0,0
 done

 if $Croix==1
  fx_symmetrizoscope[-1] 5,0,1,0
 endif

 if {$Texture==1}
  samj_Texture_Granuleuse[-1] 0.5,20,80,0,0
 endif

 if $Courbes_Interactives_Couleurs==0
  x_color_curves[-1] rgb
 elif $Courbes_Interactives_Couleurs==1
  x_color_curves[-1] cmy
 elif $Courbes_Interactives_Couleurs==2
  x_color_curves[-1] cmyk
 elif $Courbes_Interactives_Couleurs==3
  x_color_curves[-1] hsi
 elif $Courbes_Interactives_Couleurs==4
  x_color_curves[-1] hsl
 elif $Courbes_Interactives_Couleurs==5
  x_color_curves[-1] hsv
 elif $Courbes_Interactives_Couleurs==6
  x_color_curves[-1] lab
 elif $Courbes_Interactives_Couleurs==7
  x_color_curves[-1] lch
 elif $Courbes_Interactives_Couleurs==8
  x_color_curves[-1] ycbcr
 endif

#################################################
##                                             ##
##               FIN Courtepointe              ##
##                                             ##
#################################################
#################################################
##                                             ##
##              Degrades_XYZ_CIE               ##
##                                             ##
#################################################

# 2015/03/09 menu, Motifs Degrades CIE remplace Degrades_XYZ_CIE
# 2014/04/28 limites Lab -128 127

#@gui Motifs Degrades CIE : samj_Degrades_XYZ_CIE, samj_Degrades_XYZ_CIE(0)
#@gui :_=separator()
#@gui :_=note("<small>Dégradé Rendu CIE Lab</small>")
#@gui : Type dégradé = choice(6,"V Couleur A","H Couleur A","V Couleur B","H Couleur B","V Couleurs A/B Inv.","H Couleurs A/B Inv.","V Couleurs A/B","H Couleurs A/B")
#@gui : Dimensions image = int(800,128,2048)
#@gui : Couleur a = color(240,240,40,255)
#@gui : Couleur b = color(120,40,240,255)
#@gui : Décalage l = float(0,0,100)
#@gui : Décalage a = float(0,-128,127)
#@gui : Décalage b = float(0,-128,127)
#@gui : Variation l = float(100,0,100)
#@gui : Variation a = float(64,0,255)
#@gui : Variation b = float(64,0,255)
#@gui : Valider variations canal alpha = bool(0)
#@gui : Trou noir = choice(0,"Non","Mode A","Mode B")
#@gui : Dégradés aléatoires = bool(1)
#@gui : L min. ded. aléa. = float(0,0,100)
#@gui : L max. ded. aléa. = float(100,0,100)
#@gui : A min. ded. aléa. = float(-128,-128,127)
#@gui : A max. ded. aléa. = float(128,-128,127)
#@gui : B min. ded. aléa. = float(-128,-128,127)
#@gui : B max. ded. aléa. = float(128,-128,127)
#@gui : Inverser dégradé = bool(0)
#@gui : Formes = choice(11,"Non","Sinus V - Param A B","Sinus H - Param A B","Cercles - Param A B","Rayons - Param A B","Lignes V Norm - Param A B","Lignes H Norm - Param A B","Plaid","Carré","Croix","Perspective - Param A","Sphere A","Sphere B")
#@gui : Paramètre forme a = int(0,0,100)
#@gui : Paramètre forme b = int(0,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>Samj</i>. - Dernière mise à jour : <i>2010/10/24</i>.</small>")
samj_Degrades_XYZ_CIE :
 Type_Degrade=$1
 Dimensions=$2
 Ra=$3
 Ga=$4
 Ba=$5
 Aa=$6
 Rb=$7
 Gb=$8
 Bb=$9
 Ab=$10
 Decalage_L=$11
 Decalage_a=$12
 Decalage_b=$13
 Variation_L=$14
 Variation_a=$15
 Variation_b=$16
 Valider_Variations_Canal_A=$17
 Trou_Noir=$18
 Degrades_aleatoires=$19
 L_Min_Ded_Alea=$20
 L_Max_Ded_Alea=$21
 a_Min_Ded_Alea=$22
 a_Max_Ded_Alea=$23
 b_Min_Ded_Alea=$24
 b_Max_Ded_Alea=$25
 Inverser_Degrade=$26
 Variations_Formes=$27
 Parametre_Forme_A=$28
 Parametre_Forme_B=$29
 Nb_Boucles=0
 Inc_L=0
 Inc_a=0
 Inc_b=0
 Inc_Alpha=0
 # Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
 # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 nt_Ra={$Ra/255}
 nt_Ga={$Ga/255}
 nt_Ba={$Ba/255}
 if $nt_Ra>0.04045
 nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
 nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
 nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
 nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
 nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
 nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}
 #Observateur. = 2? Illuminant = D65 sRGB
 Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
 Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
 Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
 Xca=$Xa
 Yca=$Ya
 Zca=$Za
 ref_Xa=95.047
 ref_Ya=100.000
 ref_Za=108.883
 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
 nt_Xa={($nt_Xa)^{1/3}}
 else
 nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
 nt_Ya={($nt_Ya)^{1/3}}
 else
 nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
 nt_Za={($nt_Za)^{1/3}}
 else
 nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_La={{116*$nt_Ya}-16}
 CIE_aa={500*{$nt_Xa-$nt_Ya}}
 CIE_ba={200*{$nt_Ya-$nt_Za}}
 nt_Ra={$Rb/255}
 nt_Ga={$Gb/255}
 nt_Ba={$Bb/255}
 if $nt_Ra>0.04045
 nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
 nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
 nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
 nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
 nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
 nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}
 #Observateur. = 2? Illuminant = D65 sRGB
 Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
 Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
 Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
 Xca=$Xb
 Yca=$Yb
 Zca=$Zb
 ref_Xa=95.047
 ref_Ya=100.000
 ref_Za=108.883
 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
 nt_Xa={($nt_Xa)^{1/3}}
 else
 nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
 nt_Ya={($nt_Ya)^{1/3}}
 else
 nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
 nt_Za={($nt_Za)^{1/3}}
 else
 nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_Lb={{116*$nt_Ya}-16}
 CIE_ab={500*{$nt_Xa-$nt_Ya}}
 CIE_bb={200*{$nt_Ya-$nt_Za}}
 if $Variations_Formes==1
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 elif $Variations_Formes==2
 if $Type_Degrade==0
 Type_Degrade=1
 elif $Type_Degrade==2
 Type_Degrade=3
 elif $Type_Degrade==4
 Type_Degrade=5
 elif $Type_Degrade==6
 Type_Degrade=7
 endif
 elif $Variations_Formes==3
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 Valider_Variations_Canal_A=0
 elif $Variations_Formes==4
 if $Type_Degrade==0
 Type_Degrade=1
 elif $Type_Degrade==2
 Type_Degrade=3
 elif $Type_Degrade==4
 Type_Degrade=5
 elif $Type_Degrade==6
 Type_Degrade=7
 endif
 Valider_Variations_Canal_A=0
 elif $Variations_Formes==5
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 elif $Variations_Formes==6
 if $Type_Degrade==0
 Type_Degrade=1
 elif $Type_Degrade==2
 Type_Degrade=3
 elif $Type_Degrade==4
 Type_Degrade=5
 elif $Type_Degrade==6
 Type_Degrade=7
 endif
 elif $Variations_Formes==7
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 elif $Variations_Formes==8
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 elif $Variations_Formes==9
 if $Type_Degrade==0
 Type_Degrade=1
 elif $Type_Degrade==2
 Type_Degrade=3
 elif $Type_Degrade==4
 Type_Degrade=5
 elif $Type_Degrade==6
 Type_Degrade=7
 endif
 elif $Variations_Formes==10
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 elif $Variations_Formes==11
 if $Type_Degrade==0
 Type_Degrade=1
 elif $Type_Degrade==2
 Type_Degrade=3
 elif $Type_Degrade==4
 Type_Degrade=5
 elif $Type_Degrade==6
 Type_Degrade=7
 endif
 elif $Variations_Formes==12
 if $Type_Degrade==1
 Type_Degrade=0
 elif $Type_Degrade==3
 Type_Degrade=2
 elif $Type_Degrade==5
 Type_Degrade=4
 elif $Type_Degrade==7
 Type_Degrade=6
 endif
 endif
 rm[-1]
 ######
 if $Type_Degrade==0||$Type_Degrade==1||$Type_Degrade==2||$Type_Degrade==3
 if $Type_Degrade==2||$Type_Degrade==3
 CIE_La=$CIE_Lb
 CIE_aa=$CIE_ab
 CIE_ba=$CIE_bb
 Aa=$Ab
 endif
 Nb_Boucles=0
 Inc_L={$Variation_L/$Dimensions}
 Inc_a={$Variation_a/$Dimensions}
 Inc_b={$Variation_b/$Dimensions}
 $Dimensions,$Dimensions,1,4
 repeat $Dimensions
 if $Degrades_aleatoires==1
 if {{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0
 if $L_Max_Ded_Alea>$L_Min_Ded_Alea CIE_La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} else CIE_La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} endif
 if $a_Max_Ded_Alea>$a_Min_Ded_Alea CIE_aa={round(u($a_Min_Ded_Alea,$a_Max_Ded_Alea))} else CIE_aa={round(u($a_Max_Ded_Alea,$a_Min_Ded_Alea))} endif
 if $b_Max_Ded_Alea>$b_Min_Ded_Alea CIE_ba={round(u($b_Min_Ded_Alea,$b_Max_Ded_Alea))} else CIE_ba={round(u($b_Max_Ded_Alea,$b_Min_Ded_Alea))} endif
 endif
 endif
 if $Inverser_Degrade==0
 CIE_Lca={$CIE_La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
 CIE_aca={$CIE_aa+$Decalage_a+{$Nb_Boucles*$Inc_a}}
 CIE_bca={$CIE_ba+$Decalage_b+{$Nb_Boucles*$Inc_b}}
 else
 CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
 CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
 CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
 endif
 if $Trou_Noir==0
 if $CIE_Lca>100 CIE_Lca=100 endif
 if $CIE_Lca<0 CIE_Lca=0 endif
 if $CIE_aca>127 CIE_aca=127 endif
 if $CIE_aca<-128 CIE_aca=-128 endif
 if $CIE_bca>127 CIE_bca=127 endif
 if $CIE_bca<-128 CIE_bca=-128 endif
 elif $Trou_Noir==1
 if $CIE_Lca>100 Inc_L={-1*$Inc_L} CIE_Lca=100  endif
 if $CIE_Lca<0 Inc_L={-1*$Inc_L} CIE_Lca=0 endif
 if $CIE_aca>127 Inc_a={-1*$Inc_a} CIE_aca=0 endif
 if $CIE_aca<-128 Inc_a={-1*$Inc_a} CIE_aca=0 endif
 if $CIE_bca>127 Inc_b={-1*$Inc_b} CIE_bca=0 endif
 if $CIE_bca<-128 Inc_b={-1*$Inc_b} CIE_bca=0 endif
 elif $Trou_Noir==2
 if $CIE_Lca>100 CIE_Lca={$CIE_Lca-100} endif
 if $CIE_Lca<0 CIE_Lca={$CIE_Lca+100} endif
 if $CIE_aca>127 CIE_aca={$CIE_aca-255} endif
 if $CIE_aca<-128 CIE_aca={$CIE_aca+255} endif
 if $CIE_bca>127 CIE_bca={$CIE_bca-255} endif
 if $CIE_bca<-128 CIE_bca={$CIE_bca+255} endif
 endif
 # Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
 nt_Yca={{$CIE_Lca+16}/116}
 nt_Xca={$CIE_aca/500+$nt_Yca}
 nt_Zca={$nt_Yca-$CIE_bca/200}
 if {($nt_Yca)^3}>0.008856
 nt_Yca={($nt_Yca)^3}
 else
 nt_Yca={{$nt_Yca-16/116}/7.787}
 endif
 if {($nt_Xca)^3}>0.008856
 nt_Xca={($nt_Xca)^3}
 else
 nt_Xca={{$nt_Xca-16/116}/7.787}
 endif
 if {($nt_Zca)^3}>0.008856
 nt_Zca={($nt_Zca)^3}
 else
 nt_Zca={{$nt_Zca-16/116}/7.787}
 endif
 ref_Xca=95.047
 ref_Yca=100.000
 ref_Zca=108.883
 Xca={$ref_Xca*$nt_Xca}
 Yca={$ref_Yca*$nt_Yca}
 Zca={$ref_Zca*$nt_Zca}
 # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
 # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 vcXa=$Xca
 vcYa=$Yca
 vcZa=$Zca
 nt_X={$vcXa/100}
 nt_Y={$vcYa/100}
 nt_Z={$vcZa/100}
 nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
 nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
 nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
 if $nt_R>0.0031308
 nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
 else
 nt_R={12.92*$nt_R}
 endif
 if {$nt_G>0.0031308}
 nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
 else
 nt_G={12.92*$nt_G}
 endif
 if $nt_B>0.0031308
 nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
 else
 nt_B={12.92*$nt_B}
 endif
 Rconv={$nt_R*255}
 Gconv={$nt_G*255}
 Bconv={$nt_B*255}
 if $Rconv>255 Rconv=255 endif
 if $Rconv<0 Rconv=0 endif
 if $Gconv>255 Gconv=255 endif
 if $Gconv<0 Gconv=0 endif
 if $Bconv>255 Bconv=255 endif
 if $Bconv<0 Bconv=0 endif
 if $Type_Degrade==0||$Type_Degrade==2
 line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Rconv,$Gconv,$Bconv,$Aa
 elif $Type_Degrade==1||$Type_Degrade==3
 line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
 endif
 Nb_Boucles={$Nb_Boucles+1}
 done
 endif
 ######
 if $Type_Degrade==4||$Type_Degrade==5||$Type_Degrade==6||$Type_Degrade==7
 Nb_Boucles=0
 Inc_L={{$CIE_La-$CIE_Lb}/$Dimensions}
 Inc_a={{$CIE_aa-$CIE_ab}/$Dimensions}
 Inc_b={{$CIE_ba-$CIE_bb}/$Dimensions}
 Inc_Alpha={{$Ab-$Aa}/$Dimensions}
 $Dimensions,$Dimensions,1,4
 repeat $Dimensions
 if $Degrades_aleatoires==1
 if {{$Nb_Boucles+1}%{round(u(2,{$Dimensions/{2+$Type_Degrade}}))}}==0
 if $L_Max_Ded_Alea>$L_Min_Ded_Alea CIE_La={round(u($L_Min_Ded_Alea,$L_Max_Ded_Alea))} else CIE_La={round(u($L_Max_Ded_Alea,$L_Min_Ded_Alea))} endif
 if $a_Max_Ded_Alea>$a_Min_Ded_Alea CIE_aa={round(u($a_Min_Ded_Alea,$a_Max_Ded_Alea))} else CIE_aa={round(u($a_Max_Ded_Alea,$a_Min_Ded_Alea))} endif
 if $b_Max_Ded_Alea>$b_Min_Ded_Alea CIE_ba={round(u($b_Min_Ded_Alea,$b_Max_Ded_Alea))} else CIE_ba={round(u($b_Max_Ded_Alea,$b_Min_Ded_Alea))} endif
 endif
 endif
 if $Inverser_Degrade==0
 CIE_Lca={$CIE_La+$Decalage_L+{$Nb_Boucles*$Inc_L}}
 CIE_aca={$CIE_aa+$Decalage_a+{$Nb_Boucles*$Inc_a}}
 CIE_bca={$CIE_ba+$Decalage_b+{$Nb_Boucles*$Inc_b}}
 endif
 if $Inverser_Degrade==1||$Type_Degrade==6||$Type_Degrade==7
 CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
 CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
 CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
 endif
 if $Valider_Variations_Canal_A==1
 Aa={$Aa+$Inc_Alpha}
 if {$Aa>255} Aa=255 endif
 if {$Aa<0} Aa=0 endif
 endif
 if $Trou_Noir==0
 if $CIE_Lca>100 CIE_Lca=100 endif
 if $CIE_Lca<0 CIE_Lca=0 endif
 if $CIE_aca>127 CIE_aca=127 endif
 if $CIE_aca<-128 CIE_aca=-128 endif
 if $CIE_bca>127 CIE_bca=127 endif
 if $CIE_bca<-128 CIE_bca=-128 endif
 elif $Trou_Noir==1
 if $CIE_Lca>100 Inc_L={-1*$Inc_L} CIE_Lca=$CIE_Lb  endif
 if $CIE_Lca<0 Inc_L={-1*$Inc_L} CIE_Lca=$CIE_La endif
 if $CIE_aca>127 Inc_a={-1*$Inc_a} CIE_aca=0 endif
 if $CIE_aca<-128 Inc_a={-1*$Inc_a} CIE_aca=0 endif
 if $CIE_bca>127 Inc_b={-1*$Inc_b} CIE_bca=0 endif
 if $CIE_bca<-128 Inc_b={-1*$Inc_b} CIE_bca=0 endif
 elif $Trou_Noir==2
 if $CIE_Lca>100 CIE_Lca={$CIE_Lca-100} endif
 if $CIE_Lca<0 CIE_Lca={$CIE_Lca+100} endif
 if $CIE_aca>127 CIE_aca={$CIE_aca-255} endif
 if $CIE_aca<-128 CIE_aca={$CIE_aca+255} endif
 if $CIE_bca>127 CIE_bca={$CIE_bca-255} endif
 if $CIE_bca<-128 CIE_bca={$CIE_bca+255} endif
 endif
 # Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
 nt_Yca={{$CIE_Lca+16}/116}
 nt_Xca={$CIE_aca/500+$nt_Yca}
 nt_Zca={$nt_Yca-$CIE_bca/200}
 if {($nt_Yca)^3}>0.008856
 nt_Yca={($nt_Yca)^3}
 else
 nt_Yca={{$nt_Yca-16/116}/7.787}
 endif
 if {($nt_Xca)^3}>0.008856
 nt_Xca={($nt_Xca)^3}
 else
 nt_Xca={{$nt_Xca-16/116}/7.787}
 endif
 if {($nt_Zca)^3}>0.008856
 nt_Zca={($nt_Zca)^3}
 else
 nt_Zca={{$nt_Zca-16/116}/7.787}
 endif
 ref_Xca=95.047
 ref_Yca=100.000
 ref_Zca=108.883
 Xca={$ref_Xca*$nt_Xca}
 Yca={$ref_Yca*$nt_Yca}
 Zca={$ref_Zca*$nt_Zca}
 # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
 # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 vcXa=$Xca
 vcYa=$Yca
 vcZa=$Zca
 nt_X={$vcXa/100}
 nt_Y={$vcYa/100}
 nt_Z={$vcZa/100}
 nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
 nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
 nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
 if $nt_R>0.0031308
 nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
 else
 nt_R={12.92*$nt_R}
 endif
 if $nt_G>0.0031308
 nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
 else
 nt_G={12.92*$nt_G}
 endif
 if $nt_B>0.0031308
 nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
 else
 nt_B={12.92*$nt_B}
 endif
 Rconv={$nt_R*255}
 Gconv={$nt_G*255}
 Bconv={$nt_B*255}
 if $Rconv>255 Rconv=255 endif
 if $Rconv<0 Rconv=0 endif
 if $Gconv>255 Gconv=255 endif
 if $Gconv<0 Gconv=0 endif
 if $Bconv>255 Bconv=255 endif
 if $Bconv<0 Bconv=0 endif
 if $Type_Degrade==4||$Type_Degrade==6
 line[-1] $Nb_Boucles,0,$Nb_Boucles,{$Dimensions-1},1,$Rconv,$Gconv,$Bconv,$Aa
 elif $Type_Degrade==5||$Type_Degrade==7
 line[-1] 0,$Nb_Boucles,{$Dimensions-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
 endif
 Nb_Boucles={$Nb_Boucles+1}
 done
 endif
 #####
 if $Variations_Formes==1
 fx_custom_deformation[-1] "(w+h)/"{20+$Parametre_Forme_A}" * cos(y*"{10+$Parametre_Forme_B}"/h)","1",1,1,1
 elif $Variations_Formes==2
 fx_custom_deformation[-1] "1","(w+h)/"{20+$Parametre_Forme_A}" * sin(x*"{10+$Parametre_Forme_B}"/w)",1,1,1
 elif $Variations_Formes==3
 if $Parametre_Forme_A<50 Parametre_Forme_A={{$Parametre_Forme_A+50}/100} else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} endif
 if $Parametre_Forme_B<50 Parametre_Forme_B={{$Parametre_Forme_B+50}/100} else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} endif
 fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
 elif $Variations_Formes==4
 if $Parametre_Forme_A<50 Parametre_Forme_A={{$Parametre_Forme_A+50}/100} else Parametre_Forme_A={{$Parametre_Forme_A-50}/100} endif
 if $Parametre_Forme_B<50 Parametre_Forme_B={{$Parametre_Forme_B+50}/100} else Parametre_Forme_B={{$Parametre_Forme_B-50}/100} endif
 fx_euclidean2polar[-1] $Parametre_Forme_A,$Parametre_Forme_B,1,1,1
 elif $Variations_Formes==5
 fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
 elif $Variations_Formes==6
 fx_normalize_local[-1] {$Parametre_Forme_A+6},6,5,20,1,{{$Parametre_Forme_B+3}%23}
 elif $Variations_Formes==7
 fx_plaid_texture[-1] 50,2,0,90,0,300
 elif $Variations_Formes==8
 fx_symmetrizoscope[-1] 5,0,1,0
 elif $Variations_Formes==9
 fx_symmetrizoscope[-1] 5,0,1,0
 elif $Variations_Formes==10
 fx_warp_perspective[-1] 1.73,0,1,50,50,$Parametre_Forme_A,0,2
 elif $Variations_Formes==11
 fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
 elif $Variations_Formes==12
 fx_map_sphere[-1] {min($Dimensions,$Dimensions)},{min($Dimensions,$Dimensions)},90,0.5,0,0,20,0,0,0,0.5
 endif

#################################################
##                                             ##
##             FIN Degrades_XYZ_CIE            ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_Motifs_Rapides             ##
##                                             ##
#################################################
# pour créer rapdement images de test conversion heif/avif dim sup. 7200*7200 pixels

#@gui Quickly create colorful patterns : samj_Motifs_Rapides, samj_Motifs_Rapides(0)
#@gui :_=link("https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-quickly.html","https://samjcreations.blogspot.com/2020/10/samuser-avec-gmic-gimp-filtre-quickly.html")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Array</b></span>")
#@gui : Color = int(2345,0,65536)
#@gui :_=note("<small><i>Set dimension to 20 or very close for very large images.</i></small>")
#@gui : Dimension = float(19,0,20)
#@gui :_=note("<span foreground="orangered"><b>Deform</b></span>")
#@gui : Seed = int(1234,1,65536)
#@gui : Amplitude = int(30,0,1000)
#@gui :_=note("<span foreground="orangered"><b>Tiles</b></span>")
#@gui : Tiles = bool(0)
#@gui : Nb X Y Tiles = int(10,2,32)
#@gui :_=note("<span foreground="orangered"><b>Spread</b></span>")
#@gui : Seed = int(1234,1,65536)
#@gui : DxDy = int(0,0,100)
#@gui :_=note("<span foreground="orangered"><b>Blur</b></span>")
#@gui : Add Blur = bool(0)
#@gui : Blur = float(1,0,100)
#@gui :_=note("<span foreground="orangered"><b>Dominant Color</b></span>")
#@gui : Add A Dominant Color = bool(0)
#@gui : Color = color(255,170,0,128)
#@gui :_=note("<span foreground="orangered"><b>Geometry</b></span>")
#@gui : Symmetrize = bool(0)
#@gui : Mirror X Y = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/10/14</i>.</small>")

samj_Motifs_Rapides:
	srand $1 fx_array_color {round({{w}/100*{20.01-$2}})+1},{round({{h}/100*{20.01-$2}})+1},1
	if $4>0 srand $3 deform {{{w}+{h}}/1000*$4} endif
	if $5>0 Larg={w} Haut={h} resize {round({w}/$6)*$6},{round({h}/$6)*$6} split y,$6 split x,$6 append y append x split y,$6 append x resize $Larg,$Haut endif
	if $8>0 srand $7 spread $8 endif
	if $9==1 blur $10 endif
	if $11==1 {w},{h},1,4 fill_color[-1] $12,$13,$14,$15 blend average endif
	if $16==1 symmetrize 50%,50%,180 symmetrize 50%,50%,90 endif
	if $17==1 resize {{w}/2},{{h}/2} +mirror x +mirror y append_tiles 2,2 endif

#################################################
##                                             ##
##          FIN samj_Motifs_Rapides            ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Soft_Random_Shades            ##
##                                             ##
#################################################

#@gui Soft Random Shades : samj_Soft_Random_Shades, samj_Soft_Random_Shades(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Soft_Random_Shades</span>")
#@gui : Background Color = color(140,120,220,255)
#@gui : Variation A = int(0,0,4)
#@gui : Variation B = int(20,20,120)
#@gui : Variation C = float(0,0,0.25)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/12/06</i>.</small>")

samj_Soft_Random_Shades :

R_a=$1
V_a=$2
B_a=$3
A_a=$4
Variation_A=$5
Variation_B=$6
Variation_C=$7

Largeur={w}
Hauteur={h}

 {$Largeur},{$Hauteur},1,4
 {$Largeur},{$Hauteur},1,4
 rm[-3]
 fill_color[-1,-2] $R_a,$V_a,$B_a,$A_a
 samj_Random_Plasma[-1] $Variation_A,$Variation_B
 blend[-1,-2] luminance
 if $Variation_C==0
  # rien
 else
  {$Largeur},{$Hauteur},1,4
  {$Largeur},{$Hauteur},1,4
  fill_color[-1,-2] $R_a,$V_a,$B_a,$A_a
  samj_Random_Plasma[-1] $Variation_A,$Variation_B
  blend[-1,-2] luminance
  blend[-1,-2] edges,{0.5+$Variation_C},0
 endif
 crop[-1] 0,0,{$Largeur-8},{$Hauteur-1}
 resize[-1] {$Largeur},{$Hauteur}

#################################################
##                                             ##
##         FIN samj_Soft_Random_Shades         ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                       RENDERING
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_rendering :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Rendering</b>
#################################################
##                                             ##
##            samj_Lignes_Colonnes             ##
##                                             ##
#################################################

#@gui Rows Columns : samj_Lignes_Colonnes, samj_Lignes_Colonnes
#@gui : Colonnes/Columns = int(16,2,128)
#@gui : Lignes/Rows = int(16,2,128)
#@gui : Afficher/Display = choice(0,"Lignes Colonnes/Rows Columns","Colonnes/Columns","Lignes/Rows")
#@gui : Couleur/Color = color(0,0,0,64)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/11/20</i>.</small>")

samj_Lignes_Colonnes :

to_rgba
if $3==0||$3==1
	IncX={{w}/$1}
	Xorg=0
	Yorg=0
	Xfin=0
	Yfin={h}
	repeat $1
		line $Xorg,$Yorg,$Xfin,$Yfin,1,$4,$5,$6,$7
		Xorg={$Xorg+$IncX}
		Xfin={$Xfin+$IncX}
	done
endif
if $3==0||$3==2
	IncY={{h}/$2}
	Xorg=0
	Yorg=0
	Xfin={w}
	Yfin=0
	repeat $2
		line $Xorg,$Yorg,$Xfin,$Yfin,1,$4,$5,$6,$7
		Yorg={$Yorg+$IncY}
		Yfin={$Yfin+$IncY}
	done
endif

#################################################
##                                             ##
##         FIN samj_Lignes_Colonnes            ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Engrenages_Laser_LED           ##
##                                             ##
#################################################
# modif 20200106 pour creux=dent sur cercle Primitif
#@gui Engrenages Gears Laser : samj_Engrenages_Laser_LED, samj_Engrenages_Laser_LED_Preview
#@gui :_=separator()
#@gui :_=note("<small><i>Engrenages Gears Laser Cutting Engraving</i></small>")
#@gui :_=link("https://samjcreations.blogspot.com/2020/01/samuser-avec-gmic-gimp-engrenages.html","https://samjcreations.blogspot.com/2020/01/samuser-avec-gmic-gimp-engrenages.html")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Paramètres / Settings</span>")
#@gui :_=link("https://fr.wikipedia.org/wiki/Engrenage","https://fr.wikipedia.org/wiki/Engrenage")
#@gui : Module m [pixels] = int(80,10,200)
#@gui :_=note("<small><span foreground="red">Diminuer Angle De Pression alpha pour inscrire Z1 ou Z2 dans cercle de tête [ 14.5 par exemple ] </span></small>")
#@gui : Angle De Pression alpha / Pressure Angle [20 Degrés]  = float(20,10,20)
#@gui : Diam. trou central [pixels]  = int(12,12,600)
#@gui : Nb de dents roue Z1 / Nb of teeth gear Z1  [13...17]  = int(14,7,151)
#@gui : Nb de dents roue Z2 / Nb of teeth gear Z2 [13...39]  = int(17,7,151)
#@gui : Forme = choice(1,"Dent plus petite - Calcul sur Cercle De Base","Dent=Creux sur Cercle Primitif")
#@gui : Contours +  = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Trous pour assemblage / Mechanical assembly</span>")
#@gui : Nb. trous assemblage / Holes  = int(2,0,12)
#@gui : Diam. trous assemblage / Holes [pixels]  = int(19,12,600)
#@gui : Distance du centre / Center spacing [pixels]  = int(250,12,3000)
#@gui : Décalage Angulaire / Angular offset [Degrés]  = float(0,0,360)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Mortaise clavette trou central / Keyway cutting</span>")
#@gui :_=link("https://fr.wikipedia.org/wiki/Clavette_&#040;mécanique&#041;","https://fr.wikipedia.org/wiki/Clavette_&#040;mécanique&#041;")
#@gui : Largeur / Width [pixels]  = int(0,0,150)
#@gui : Hauteur / Height [pixels]  = int(0,0,100)
#@gui : Décalage Angulaire / Angular offset [Degrés]  = float(0,0,360)
#@gui :_=separator()
#@gui :_=note("<span foreground="magenta">Ce script est lent car les engrenages sont dessinés point par point.</span>")
#@gui :_=note("<span foreground="magenta">Le script donne 3 calques de dimensions identiques max. 7200 pixels : </span>")
#@gui :_=note("<span foreground="magenta"> - 1 calque au fond transparent avec des  données techniques.</span>")
#@gui :_=note("<span foreground="magenta"> - 1 calque blanc avec un dessin noir pour la roue Z2.</span>")
#@gui :_=note("<span foreground="magenta"> - 1 calque blanc avec un dessin noir pour la roue Z1.</span>")
#@gui :_=note("<span foreground="magenta">This script is slow because the gears are plotted point by point.</span>")
#@gui :_=note("<span foreground="magenta">The script gives 3 layers of the same dimensions max.7200 pixels : </span>")
#@gui :_=note("<span foreground="magenta"> - 1 layer with transparent background with technical data.</span>")
#@gui :_=note("<span foreground="magenta"> - 1 white layer with a black outline for the Z2 wheel.</span>")
#@gui :_=note("<span foreground="magenta"> - 1 white layer with a black outline for the Z1 wheel.</span>")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/01/06</i>.</small>")

samj_Engrenages_Laser_LED :

Module_m={$1+1} # compensation boucle vérification dimensions
Angle_De_Pression_alpha={round($2*10000)/10000}
Diam_Trou_Arbre=$3
Nb_Dents_Roue_Z1=$4
Nb_Dents_Roue_Z2=$5
Egalite_Primitif=$6
Contours_Plus=$7
Trous_Assemb_Nb=$8
Trous_Assemb_Diam=$9
Trous_Assemb_Distance_Centre=$10
Trous_Assemb_Decalage_Angle={{pi}/180*$11}
Rainure_Largeur=$12
Rainure_Hauteur=$13
Rainure_Decalage_Angle={{pi}/180*$14} # $14 utilisé dans infos.

Echelle=1
Dimension_Max_Image=7200 # pixels
Reserve_Contour_Image=10  # pixels

# correction automatique Module m
Module_m_Origine={$Module_m-1}
Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}

if $Nb_Dents_Roue_Z1>$Nb_Dents_Roue_Z2
 do
  Module_m={$Module_m-1}
  Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
  Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
 while $Dia_Tete_Z1>$Dimension_Max_Image-2*$Reserve_Contour_Image
else
 do
  Module_m={$Module_m-1}
  Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
  Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}
 while $Dia_Tete_Z2>$Dimension_Max_Image-2*$Reserve_Contour_Image
endif

Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
Dia_Pied_Z1={$Dia_Primitif_Z1-{2.5*$Echelle*$Module_m}}
Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}
Dia_Pied_Z2={$Dia_Primitif_Z2-{2.5*$Echelle*$Module_m}}

# correction automatique Angle De Pression alpha
Angle_De_Pression_alpha_Origine=$Angle_De_Pression_alpha
Angle_De_Pression_alpha={$Angle_De_Pression_alpha+0.1}
if $Nb_Dents_Roue_Z1>$Nb_Dents_Roue_Z2
 do
  Angle_De_Pression_alpha={$Angle_De_Pression_alpha-0.1}
  Diametre_Cercle_De_Base_Z1={$Dia_Primitif_Z1*cos({{pi}/180*$Angle_De_Pression_alpha})}
  Rayon_Developpante_Z1={$Diametre_Cercle_De_Base_Z1/2}
 while $Dia_Pied_Z1/2>$Rayon_Developpante_Z1
else
 do
  Angle_De_Pression_alpha={$Angle_De_Pression_alpha-0.1}
  Diametre_Cercle_De_Base_Z2={$Dia_Primitif_Z2*cos({{pi}/180*$Angle_De_Pression_alpha})}
  Rayon_Developpante_Z2={$Diametre_Cercle_De_Base_Z2/2}
 while $Dia_Pied_Z2/2>$Rayon_Developpante_Z2
endif
Angle_De_Pression_alpha={round($Angle_De_Pression_alpha*10000)/10000}

Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
Diametre_Cercle_De_Base_Z1={$Dia_Primitif_Z1*cos({{pi}/180*$Angle_De_Pression_alpha})}  # Base des calculs / Compris entre le cercle de pied et le cercle primitif
Dia_Pied_Z1={$Dia_Primitif_Z1-{2.5*$Echelle*$Module_m}}
Rayon_Developpante_Z1={$Diametre_Cercle_De_Base_Z1/2}
Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}
Dia_Pied_Z2={$Dia_Primitif_Z2-{2.5*$Echelle*$Module_m}}
Diametre_Cercle_De_Base_Z2={$Dia_Primitif_Z2*cos({{pi}/180*$Angle_De_Pression_alpha})}  # Base des calculs / Compris entre le cercle de pied et le cercle primitif
Rayon_Developpante_Z2={$Diametre_Cercle_De_Base_Z2/2}

##  Diametre_Cercle_Hauteur_Active_Z1=???  >>  À ajouter si norme  à ce sujet : modifier les raccords faits avec $Angle_Porte_Au_Cercle_Pied et ajouter arrondis au rendu

# Dimensions Image
if $Nb_Dents_Roue_Z1>$Nb_Dents_Roue_Z2
 Largeur={round({$Dia_Tete_Z1+{2*{$Reserve_Contour_Image}}})}
else
 Largeur={round({$Dia_Tete_Z2+{2*{$Reserve_Contour_Image}}})}
endif
Hauteur=$Largeur

Entraxe_Engrenages_theorique={{$Echelle*$Module_m*{$Nb_Dents_Roue_Z1+$Nb_Dents_Roue_Z2}}/2}

# Vocabulaire engrenage http://www.zpag.net/Dessin_Technique/1980/EngrnagesCames/Definition_Formule_engre_droit.htm
Creux_b={$Echelle*$Module_m*1.25}
Saillie_a={$Echelle*$Module_m}
Vide_Fond_De_Dent_c={$Creux_b-$Saillie_a}
Hauteur_de_dent_ht={$Creux_b+$Saillie_a}
Pas_Primitif_p={$Echelle*$Module_m*{pi}}
Epaisseur_Circulaire_t={$Pas_Primitif_p/2}
Hauteur_Active_hk={2*$Saillie_a}

##### Tracer Z1

X_Origine={$Largeur/2}
Y_Origine={$Hauteur/2}

Increment_Developpante={{pi}*0.0002}
Precision_Tracage_Cercles=500

rm[0]
$Largeur,$Hauteur,1,4
fill_color[-1] 255,255,255,255

Rayon_Developpante={$Diametre_Cercle_De_Base_Z1/2}

Dimension_Developpante=0
Condition_Arret={$Dia_Tete_Z1/2}

Angle_Rotation=0
Increment_Rotation={2*{pi}/$Nb_Dents_Roue_Z1} # angle creux + dent
Angle_Dent={{pi}/$Nb_Dents_Roue_Z1} # angle dent
Base_Dent={2*{{$Diametre_Cercle_De_Base_Z1/2}*sin({{pi}/{$Nb_Dents_Roue_Z1*4}})}}
Angle_Porte_Au_Cercle_Pied={2*asin($Base_Dent/$Dia_Pied_Z1)}
Angle_Decalage_Rainure_Pied={{$Angle_Porte_Au_Cercle_Pied-{$Increment_Rotation/4}}/2}
X_Developpante_Tracage=0
Y_Developpante_Tracage=0
Angle_Decalage_Developpante_B={{{pi}/{$Nb_Dents_Roue_Z1*2}}-{{pi}/2}+{{{pi}/$Nb_Dents_Roue_Z1}/2}}

if $Egalite_Primitif==1
 # determiner croisement avec cercle primitif et l'angle correspondant
 Intersection_Developpante_Cercle_primitif=0
 X_Developpante_Memo=0
 Y_Developpante_Memo=0
 X_Intersection=0
 Y_Intersection=0
 Angle_Developpante_Rad=0
 Nb_boucles=0
 do
  # développante
  X_Developpante={$Rayon_Developpante*{cos($Angle_Developpante_Rad)+{$Angle_Developpante_Rad*sin($Angle_Developpante_Rad)}}}
  Y_Developpante={$Rayon_Developpante*{sin($Angle_Developpante_Rad)-{$Angle_Developpante_Rad*cos($Angle_Developpante_Rad)}}}
  Dimension_Developpante={({{($X_Developpante)^2}+{($Y_Developpante)^2}})^0.5}
  # rotation angulaire de la développante
  X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation)}-{$Y_Developpante*sin($Angle_Rotation)}}}
  Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation)}+{$Y_Developpante*cos($Angle_Rotation)}}}
  if $Intersection_Developpante_Cercle_primitif==0
   if $Dimension_Developpante>{$Dia_Primitif_Z1/2} # dépassement
    Angle_Intersection={atan2({$Y_Developpante_Memo-$Y_Origine},{$X_Developpante_Memo-$X_Origine})}
    Angle_Alpha_Base_Primitif={$Angle_Rotation-$Angle_Intersection}
    Intersection_Developpante_Cercle_primitif=1
   endif
   X_Developpante_Memo=$X_Developpante_Tracage
   Y_Developpante_Memo=$Y_Developpante_Tracage
  endif
  Angle_Developpante_Rad={$Angle_Developpante_Rad+$Increment_Developpante}
  Nb_boucles={$Nb_boucles+1}
 while $Dimension_Developpante<$Condition_Arret

 Angle_Rotation=0
 Dimension_Developpante=0
 X_Developpante_Tracage=0
 Y_Developpante_Tracage=0
endif

 repeat $Nb_Dents_Roue_Z1

  Angle_Developpante_Rad=0
  Nb_boucles=0

  do
   # développante
   X_Developpante={$Rayon_Developpante*{cos($Angle_Developpante_Rad)+{$Angle_Developpante_Rad*sin($Angle_Developpante_Rad)}}}
   Y_Developpante={$Rayon_Developpante*{sin($Angle_Developpante_Rad)-{$Angle_Developpante_Rad*cos($Angle_Developpante_Rad)}}}

   Dimension_Developpante={({{($X_Developpante)^2}+{($Y_Developpante)^2}})^0.5}

   # rotation angulaire de la développante
   X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation)}-{$Y_Developpante*sin($Angle_Rotation)}}}
   Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation)}+{$Y_Developpante*cos($Angle_Rotation)}}}

   if $Nb_boucles==0
    X_Debut_Developpante_Tracage_A=$X_Developpante_Tracage
    Y_Debut_Developpante_Tracage_A=$Y_Developpante_Tracage
   endif
   X_Fin_Developpante_Tracage_A=$X_Developpante_Tracage
   Y_Fin_Developpante_Tracage_A=$Y_Developpante_Tracage

   # tracer developpante gauche
   point[-1] $X_Developpante_Tracage,$Y_Developpante_Tracage,0,1,0,0,0,255

   # développante
   X_Developpante={$Rayon_Developpante*{sin($Angle_Developpante_Rad)-{$Angle_Developpante_Rad*cos($Angle_Developpante_Rad)}}}
   Y_Developpante={$Rayon_Developpante*{cos($Angle_Developpante_Rad)+{$Angle_Developpante_Rad*sin($Angle_Developpante_Rad)}}}
   # rotation angulaire de la développante

   if $Egalite_Primitif==1
    X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}-{$Y_Developpante*sin($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}}}
    Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}+{$Y_Developpante*cos($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}}}
   else
    X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation+$Angle_Decalage_Developpante_B)}-{$Y_Developpante*sin($Angle_Rotation+$Angle_Decalage_Developpante_B)}}}
    Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation+$Angle_Decalage_Developpante_B)}+{$Y_Developpante*cos($Angle_Rotation+$Angle_Decalage_Developpante_B)}}}
   endif

   if $Nb_boucles==0
    X_Debut_Developpante_Tracage_B=$X_Developpante_Tracage
    Y_Debut_Developpante_Tracage_B=$Y_Developpante_Tracage
   endif
   X_Fin_Developpante_Tracage_B=$X_Developpante_Tracage
   Y_Fin_Developpante_Tracage_B=$Y_Developpante_Tracage

   # tracer developpante droite
   point[-1] $X_Developpante_Tracage,$Y_Developpante_Tracage,0,1,0,0,0,255

   Angle_Developpante_Rad={$Angle_Developpante_Rad+$Increment_Developpante}

   Nb_boucles={$Nb_boucles+1}

  while $Dimension_Developpante<$Condition_Arret

  Angle_Fin_Developpante_Tracage_A={atan2({$Y_Fin_Developpante_Tracage_A-$Y_Origine},{$X_Fin_Developpante_Tracage_A-$X_Origine})}
  Angle_Fin_Developpante_Tracage_B={atan2({$Y_Fin_Developpante_Tracage_B-$Y_Origine},{$X_Fin_Developpante_Tracage_B-$X_Origine})}
  Angle_Tracage=$Angle_Fin_Developpante_Tracage_A
  Increment_Angle_Tracage={{$Angle_Fin_Developpante_Tracage_B-$Angle_Fin_Developpante_Tracage_A}/$Precision_Tracage_Cercles}

  # tracer sommets dents
  repeat $Precision_Tracage_Cercles
   point[-1] {$X_Origine+{{$Dia_Tete_Z1/2}*{cos($Angle_Tracage)}}},{$Y_Origine+{{$Dia_Tete_Z1/2}*{sin($Angle_Tracage)}}},0,1,0,0,0,255
   Angle_Tracage={$Angle_Tracage+$Increment_Angle_Tracage}
  done

  # tracer rainure cercle de base - cercle de pied
  Angle_Debut_Developpante_Tracage_A={atan2({$Y_Debut_Developpante_Tracage_A-$Y_Origine},{$X_Debut_Developpante_Tracage_A-$X_Origine})}
  Angle_Debut_Developpante_Tracage_B={atan2({$Y_Debut_Developpante_Tracage_B-$Y_Origine},{$X_Debut_Developpante_Tracage_B-$X_Origine})}
  Angle_Debut_Rainure_Pied={$Angle_Debut_Developpante_Tracage_A-$Angle_Decalage_Rainure_Pied}
  Angle_Fin_Rainure_Pied={$Angle_Debut_Developpante_Tracage_B+$Angle_Decalage_Rainure_Pied}
  X_Debut_Rainure_Pied={$X_Origine+{{$Dia_Pied_Z1/2}*{cos($Angle_Debut_Rainure_Pied)}}}
  Y_Debut_Rainure_Pied={$Y_Origine+{{$Dia_Pied_Z1/2}*{sin($Angle_Debut_Rainure_Pied)}}}
  X_Fin_Rainure_Pied={$X_Origine+{{$Dia_Pied_Z1/2}*{cos($Angle_Fin_Rainure_Pied)}}}
  Y_Fin_Rainure_Pied={$Y_Origine+{{$Dia_Pied_Z1/2}*{sin($Angle_Fin_Rainure_Pied)}}}
  line[-1] {$X_Origine+{{$Diametre_Cercle_De_Base_Z1/2}*{cos($Angle_Debut_Developpante_Tracage_A)}}},{$Y_Origine+{{$Diametre_Cercle_De_Base_Z1/2}*{sin($Angle_Debut_Developpante_Tracage_A)}}},$X_Debut_Rainure_Pied,$Y_Debut_Rainure_Pied,1,0,0,0,255
  line[-1] {$X_Origine+{{$Diametre_Cercle_De_Base_Z1/2}*{cos($Angle_Debut_Developpante_Tracage_B)}}},{$Y_Origine+{{$Diametre_Cercle_De_Base_Z1/2}*{sin($Angle_Debut_Developpante_Tracage_B)}}},$X_Fin_Rainure_Pied,$Y_Fin_Rainure_Pied,1,0,0,0,255

  Angle_Debut_Rainure_Pied_Suivant={$Angle_Fin_Rainure_Pied+{$Increment_Rotation/2}-{$Angle_Decalage_Rainure_Pied*2}}

  if $Egalite_Primitif==1
   X_Debut_Rainure_Pied_Suivant={$X_Origine+{{$Dia_Pied_Z1/2}*{cos($Angle_Debut_Rainure_Pied_Suivant+{2*$Angle_Alpha_Base_Primitif})}}}
   Y_Debut_Rainure_Pied_Suivant={$Y_Origine+{{$Dia_Pied_Z1/2}*{sin($Angle_Debut_Rainure_Pied_Suivant+{2*$Angle_Alpha_Base_Primitif})}}}
   line[-1] $X_Debut_Rainure_Pied_Suivant,$Y_Debut_Rainure_Pied_Suivant,$X_Fin_Rainure_Pied,$Y_Fin_Rainure_Pied,1,0,0,0,255
  else
   X_Debut_Rainure_Pied_Suivant={$X_Origine+{{$Dia_Pied_Z1/2}*{cos($Angle_Debut_Rainure_Pied_Suivant)}}}
   Y_Debut_Rainure_Pied_Suivant={$Y_Origine+{{$Dia_Pied_Z1/2}*{sin($Angle_Debut_Rainure_Pied_Suivant)}}}
   line[-1] $X_Debut_Rainure_Pied_Suivant,$Y_Debut_Rainure_Pied_Suivant,$X_Fin_Rainure_Pied,$Y_Fin_Rainure_Pied,1,0,0,0,255
  endif

  Angle_Rotation={$Angle_Rotation+$Increment_Rotation}

 done

##### Tracer Z2

X_Origine={$Largeur/2}
Y_Origine={$Hauteur/2}

Increment_Developpante={{pi}*0.0002}
Precision_Tracage_Cercles=500

$Largeur,$Hauteur,1,4
fill_color[-1] 255,255,255,255

Rayon_Developpante={$Diametre_Cercle_De_Base_Z2/2}

Dimension_Developpante=0
Condition_Arret={$Dia_Tete_Z2/2}

Angle_Rotation=0
Increment_Rotation={2*{pi}/$Nb_Dents_Roue_Z2} # angle creux + dent
Angle_Dent={{pi}/$Nb_Dents_Roue_Z2} # angle dent
Base_Dent={2*{{$Diametre_Cercle_De_Base_Z2/2}*sin({{pi}/{$Nb_Dents_Roue_Z2*4}})}}
Angle_Porte_Au_Cercle_Pied={2*asin($Base_Dent/$Dia_Pied_Z2)}
Angle_Decalage_Rainure_Pied={{$Angle_Porte_Au_Cercle_Pied-{$Increment_Rotation/4}}/2}
X_Developpante_Tracage=0
Y_Developpante_Tracage=0
Angle_Decalage_Developpante_B={{{pi}/{$Nb_Dents_Roue_Z2*2}}-{{pi}/2}+{{{pi}/$Nb_Dents_Roue_Z2}/2}}

if $Egalite_Primitif==1
 # determiner croisement avec cercle primitif et l'angle correspondant
 Intersection_Developpante_Cercle_primitif=0
 X_Developpante_Memo=0
 Y_Developpante_Memo=0
 X_Intersection=0
 Y_Intersection=0
 Angle_Developpante_Rad=0
 Nb_boucles=0
 do
  # développante
  X_Developpante={$Rayon_Developpante*{cos($Angle_Developpante_Rad)+{$Angle_Developpante_Rad*sin($Angle_Developpante_Rad)}}}
  Y_Developpante={$Rayon_Developpante*{sin($Angle_Developpante_Rad)-{$Angle_Developpante_Rad*cos($Angle_Developpante_Rad)}}}
  Dimension_Developpante={({{($X_Developpante)^2}+{($Y_Developpante)^2}})^0.5}
  # rotation angulaire de la développante
  X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation)}-{$Y_Developpante*sin($Angle_Rotation)}}}
  Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation)}+{$Y_Developpante*cos($Angle_Rotation)}}}
  if $Intersection_Developpante_Cercle_primitif==0
   if $Dimension_Developpante>{$Dia_Primitif_Z2/2} # dépassement
    Angle_Intersection={atan2({$Y_Developpante_Memo-$Y_Origine},{$X_Developpante_Memo-$X_Origine})}
    Angle_Alpha_Base_Primitif={$Angle_Rotation-$Angle_Intersection}
    Intersection_Developpante_Cercle_primitif=1
   endif
   X_Developpante_Memo=$X_Developpante_Tracage
   Y_Developpante_Memo=$Y_Developpante_Tracage
  endif
  Angle_Developpante_Rad={$Angle_Developpante_Rad+$Increment_Developpante}
  Nb_boucles={$Nb_boucles+1}
 while $Dimension_Developpante<$Condition_Arret

 Angle_Rotation=0
 Dimension_Developpante=0
 X_Developpante_Tracage=0
 Y_Developpante_Tracage=0
endif

 repeat $Nb_Dents_Roue_Z2

  Angle_Developpante_Rad=0
  Nb_boucles=0

  do
   # développante
   X_Developpante={$Rayon_Developpante*{cos($Angle_Developpante_Rad)+{$Angle_Developpante_Rad*sin($Angle_Developpante_Rad)}}}
   Y_Developpante={$Rayon_Developpante*{sin($Angle_Developpante_Rad)-{$Angle_Developpante_Rad*cos($Angle_Developpante_Rad)}}}

   Dimension_Developpante={({{($X_Developpante)^2}+{($Y_Developpante)^2}})^0.5}

   # rotation angulaire de la développante
   X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation)}-{$Y_Developpante*sin($Angle_Rotation)}}}
   Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation)}+{$Y_Developpante*cos($Angle_Rotation)}}}

   if $Nb_boucles==0
    X_Debut_Developpante_Tracage_A=$X_Developpante_Tracage
    Y_Debut_Developpante_Tracage_A=$Y_Developpante_Tracage
   endif
   X_Fin_Developpante_Tracage_A=$X_Developpante_Tracage
   Y_Fin_Developpante_Tracage_A=$Y_Developpante_Tracage

   # tracer developpante gauche
   point[-1] $X_Developpante_Tracage,$Y_Developpante_Tracage,0,1,0,0,0,255

   # développante
   X_Developpante={$Rayon_Developpante*{sin($Angle_Developpante_Rad)-{$Angle_Developpante_Rad*cos($Angle_Developpante_Rad)}}}
   Y_Developpante={$Rayon_Developpante*{cos($Angle_Developpante_Rad)+{$Angle_Developpante_Rad*sin($Angle_Developpante_Rad)}}}
   # rotation angulaire de la développante

   if $Egalite_Primitif==1
    X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}-{$Y_Developpante*sin($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}}}
    Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}+{$Y_Developpante*cos($Angle_Rotation-{2*$Angle_Alpha_Base_Primitif}+$Angle_Decalage_Developpante_B)}}}
   else
    X_Developpante_Tracage={$X_Origine+{{$X_Developpante*cos($Angle_Rotation+$Angle_Decalage_Developpante_B)}-{$Y_Developpante*sin($Angle_Rotation+$Angle_Decalage_Developpante_B)}}}
    Y_Developpante_Tracage={$Y_Origine+{{$X_Developpante*sin($Angle_Rotation+$Angle_Decalage_Developpante_B)}+{$Y_Developpante*cos($Angle_Rotation+$Angle_Decalage_Developpante_B)}}}
   endif

   if $Nb_boucles==0
    X_Debut_Developpante_Tracage_B=$X_Developpante_Tracage
    Y_Debut_Developpante_Tracage_B=$Y_Developpante_Tracage
   endif
   X_Fin_Developpante_Tracage_B=$X_Developpante_Tracage
   Y_Fin_Developpante_Tracage_B=$Y_Developpante_Tracage

   # tracer developpante droite
   point[-1] $X_Developpante_Tracage,$Y_Developpante_Tracage,0,1,0,0,0,255

   Angle_Developpante_Rad={$Angle_Developpante_Rad+$Increment_Developpante}

   Nb_boucles={$Nb_boucles+1}

  while $Dimension_Developpante<$Condition_Arret

  Angle_Fin_Developpante_Tracage_A={atan2({$Y_Fin_Developpante_Tracage_A-$Y_Origine},{$X_Fin_Developpante_Tracage_A-$X_Origine})}
  Angle_Fin_Developpante_Tracage_B={atan2({$Y_Fin_Developpante_Tracage_B-$Y_Origine},{$X_Fin_Developpante_Tracage_B-$X_Origine})}
  Angle_Tracage=$Angle_Fin_Developpante_Tracage_A
  Increment_Angle_Tracage={{$Angle_Fin_Developpante_Tracage_B-$Angle_Fin_Developpante_Tracage_A}/$Precision_Tracage_Cercles}

  # tracer sommets dents
  repeat $Precision_Tracage_Cercles
   point[-1] {$X_Origine+{{$Dia_Tete_Z2/2}*{cos($Angle_Tracage)}}},{$Y_Origine+{{$Dia_Tete_Z2/2}*{sin($Angle_Tracage)}}},0,1,0,0,0,255
   Angle_Tracage={$Angle_Tracage+$Increment_Angle_Tracage}
  done

  # tracer rainure cercle de base - cercle de pied
  Angle_Debut_Developpante_Tracage_A={atan2({$Y_Debut_Developpante_Tracage_A-$Y_Origine},{$X_Debut_Developpante_Tracage_A-$X_Origine})}
  Angle_Debut_Developpante_Tracage_B={atan2({$Y_Debut_Developpante_Tracage_B-$Y_Origine},{$X_Debut_Developpante_Tracage_B-$X_Origine})}
  Angle_Debut_Rainure_Pied={$Angle_Debut_Developpante_Tracage_A-$Angle_Decalage_Rainure_Pied}
  Angle_Fin_Rainure_Pied={$Angle_Debut_Developpante_Tracage_B+$Angle_Decalage_Rainure_Pied}
  X_Debut_Rainure_Pied={$X_Origine+{{$Dia_Pied_Z2/2}*{cos($Angle_Debut_Rainure_Pied)}}}
  Y_Debut_Rainure_Pied={$Y_Origine+{{$Dia_Pied_Z2/2}*{sin($Angle_Debut_Rainure_Pied)}}}
  X_Fin_Rainure_Pied={$X_Origine+{{$Dia_Pied_Z2/2}*{cos($Angle_Fin_Rainure_Pied)}}}
  Y_Fin_Rainure_Pied={$Y_Origine+{{$Dia_Pied_Z2/2}*{sin($Angle_Fin_Rainure_Pied)}}}
  line[-1] {$X_Origine+{{$Diametre_Cercle_De_Base_Z2/2}*{cos($Angle_Debut_Developpante_Tracage_A)}}},{$Y_Origine+{{$Diametre_Cercle_De_Base_Z2/2}*{sin($Angle_Debut_Developpante_Tracage_A)}}},$X_Debut_Rainure_Pied,$Y_Debut_Rainure_Pied,1,0,0,0,255
  line[-1] {$X_Origine+{{$Diametre_Cercle_De_Base_Z2/2}*{cos($Angle_Debut_Developpante_Tracage_B)}}},{$Y_Origine+{{$Diametre_Cercle_De_Base_Z2/2}*{sin($Angle_Debut_Developpante_Tracage_B)}}},$X_Fin_Rainure_Pied,$Y_Fin_Rainure_Pied,1,0,0,0,255

  Angle_Debut_Rainure_Pied_Suivant={$Angle_Fin_Rainure_Pied+{$Increment_Rotation/2}-{$Angle_Decalage_Rainure_Pied*2}}

  if $Egalite_Primitif==1
   X_Debut_Rainure_Pied_Suivant={$X_Origine+{{$Dia_Pied_Z2/2}*{cos($Angle_Debut_Rainure_Pied_Suivant+{2*$Angle_Alpha_Base_Primitif})}}}
   Y_Debut_Rainure_Pied_Suivant={$Y_Origine+{{$Dia_Pied_Z2/2}*{sin($Angle_Debut_Rainure_Pied_Suivant+{2*$Angle_Alpha_Base_Primitif})}}}
   line[-1] $X_Debut_Rainure_Pied_Suivant,$Y_Debut_Rainure_Pied_Suivant,$X_Fin_Rainure_Pied,$Y_Fin_Rainure_Pied,1,0,0,0,255
  else
   X_Debut_Rainure_Pied_Suivant={$X_Origine+{{$Dia_Pied_Z2/2}*{cos($Angle_Debut_Rainure_Pied_Suivant)}}}
   Y_Debut_Rainure_Pied_Suivant={$Y_Origine+{{$Dia_Pied_Z2/2}*{sin($Angle_Debut_Rainure_Pied_Suivant)}}}
   line[-1] $X_Debut_Rainure_Pied_Suivant,$Y_Debut_Rainure_Pied_Suivant,$X_Fin_Rainure_Pied,$Y_Fin_Rainure_Pied,1,0,0,0,255
  endif

  Angle_Rotation={$Angle_Rotation+$Increment_Rotation}

 done

# autres tracés

 # calque paramètres
 $Largeur,$Hauteur,1,4
 fill_color[-1] 0,0,0,0

 Angle_Rot=0
 Inc_Angle={2*{pi}/$Trous_Assemb_Nb}
 repeat $Trous_Assemb_Nb
  X_Centre={$X_Origine+{$Trous_Assemb_Distance_Centre*cos({$Trous_Assemb_Decalage_Angle+$Angle_Rot})}}
  Y_Centre={$Y_Origine+{$Trous_Assemb_Distance_Centre*sin({$Trous_Assemb_Decalage_Angle+$Angle_Rot})}}
  circle[-2,-3] $X_Centre,$Y_Centre,{$Trous_Assemb_Diam/2},1,0xFFFFFFFF,0,0,0,255
  circle[-1] $X_Centre,$Y_Centre,{$Trous_Assemb_Diam/2},1,0xFFFFFFFF,255,0,255,255
  Angle_Rot={$Angle_Rot+$Inc_Angle}
 done
 circle[-1] $X_Origine,$Y_Origine,$Trous_Assemb_Distance_Centre,1,0xFFFFFFFF,255,0,255,255
 Trous_Assemb_Erreur=0
 if {$Trous_Assemb_Distance_Centre+{$Trous_Assemb_Diam/2}}>{$Dia_Pied_Z1/2} Trous_Assemb_Erreur={$Trous_Assemb_Erreur+1} endif
 if {$Trous_Assemb_Distance_Centre-{$Trous_Assemb_Diam/2}}<{$Diam_Trou_Arbre/2} Trous_Assemb_Erreur={$Trous_Assemb_Erreur+10} endif
 if $Trous_Assemb_Nb>3
  # samj_Annular_Steiner_Chains
  Rayon_Cercle_Exterieur={$Trous_Assemb_Distance_Centre+$Trous_Assemb_Diam}
  Angle_Theta={pi/$Trous_Assemb_Nb}
  Rayon_Cercle_Centre={{$Rayon_Cercle_Exterieur*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
  Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
  Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
  Rayon_Tang={({{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}})^0.5}
  if $Trous_Assemb_Distance_Centre<$Rayon_Tang Trous_Assemb_Erreur={$Trous_Assemb_Erreur+100} endif
 endif

 circle[-1,-2,-3] $X_Origine,$Y_Origine,{$Diam_Trou_Arbre/2},1,0xFFFFFFFF,0,0,0,255
 polygon[-1,-2,-3] 4,2,2,{$Largeur-2},2,{$Largeur-2},{$Hauteur-2},2,{$Hauteur-2},1,0xFFFFFFFF,0,0,0,255

 Erreur_Rainure=0
 if $Rainure_Hauteur>{{$Diam_Trou_Arbre/2}-1}
  Erreur_Rainure={$Erreur_Rainure+1}
 endif
 if $Rainure_Largeur>{{$Diam_Trou_Arbre/2}-1}
  Erreur_Rainure={$Erreur_Rainure+10}
 endif
 if $Rainure_Largeur>0&&$Rainure_Hauteur>0&&$Rainure_Hauteur<{{$Diam_Trou_Arbre/2}-1}&&$Rainure_Largeur<{{$Diam_Trou_Arbre/2}-1}
  Angle_Rainure={acos({{{{({$Diam_Trou_Arbre/2})^2}*2}-{({$Rainure_Largeur})^2}}/{2*{({$Diam_Trou_Arbre/2})^2}}})}
  X_Sommet_A={$X_Origine+{{$Diam_Trou_Arbre/2}*cos({$Rainure_Decalage_Angle+$Angle_Rainure})}}
  Y_Sommet_A={$Y_Origine+{{$Diam_Trou_Arbre/2}*sin({$Rainure_Decalage_Angle+$Angle_Rainure})}}
  X_Sommet_B={$X_Origine+{{$Diam_Trou_Arbre/2}*cos($Rainure_Decalage_Angle)}}
  Y_Sommet_B={$Y_Origine+{{$Diam_Trou_Arbre/2}*sin($Rainure_Decalage_Angle)}}
  # effacer arc
  Angle_Tracage=0
  Increment_Angle_Tracage={$Angle_Rainure/$Precision_Tracage_Cercles}
  repeat $Precision_Tracage_Cercles
   point[-2,-3] {$X_Origine+{{$Diam_Trou_Arbre/2}*{cos($Rainure_Decalage_Angle+$Angle_Rainure+$Angle_Tracage)}}},{$Y_Origine+{{$Diam_Trou_Arbre/2}*{sin($Rainure_Decalage_Angle+$Angle_Rainure+$Angle_Tracage)}}},0,1,255,255,255,255
   Angle_Tracage={$Angle_Tracage-$Increment_Angle_Tracage}
  done
  line[-1] $X_Sommet_A,$Y_Sommet_A,$X_Sommet_B,$Y_Sommet_B,1,0,255,255,255
  Rayon_CD={({{({$Diam_Trou_Arbre/2})^2}+{({$Rainure_Hauteur})^2}-{2*{$Diam_Trou_Arbre/2}*$Rainure_Hauteur*cos({{{{pi}-$Angle_Rainure}/2}+{{pi}/2}})}})^0.5}
  circle[-1] $X_Origine,$Y_Origine,$Rayon_CD,1,0xFFFFFFFF,0,255,255,255
  Angle_CD={acos({{{{({$Rayon_CD})^2}*2}-{({$Rainure_Largeur})^2}}/{2*{({$Rayon_CD})^2}}})}
  Angle_BC_DA={{$Angle_Rainure-$Angle_CD}/2}
  X_Sommet_C={$X_Origine+{$Rayon_CD*cos({$Rainure_Decalage_Angle+$Angle_BC_DA})}}
  Y_Sommet_C={$Y_Origine+{$Rayon_CD*sin({$Rainure_Decalage_Angle+$Angle_BC_DA})}}
  X_Sommet_D={$X_Origine+{$Rayon_CD*cos($Rainure_Decalage_Angle+$Angle_BC_DA+$Angle_CD)}}
  Y_Sommet_D={$Y_Origine+{$Rayon_CD*sin($Rainure_Decalage_Angle+$Angle_BC_DA+$Angle_CD)}}
  line[-2,-3] $X_Sommet_C,$Y_Sommet_C,$X_Sommet_D,$Y_Sommet_D,1,0,0,0,255
  line[-2,-3] $X_Sommet_C,$Y_Sommet_C,$X_Sommet_B,$Y_Sommet_B,1,0,0,0,255
  line[-2,-3] $X_Sommet_A,$Y_Sommet_A,$X_Sommet_D,$Y_Sommet_D,1,0,0,0,255
  line[-1] $X_Sommet_C,$Y_Sommet_C,$X_Sommet_D,$Y_Sommet_D,1,0,255,255,255
  line[-1] $X_Sommet_C,$Y_Sommet_C,$X_Sommet_B,$Y_Sommet_B,1,0,255,255,255
  line[-1] $X_Sommet_A,$Y_Sommet_A,$X_Sommet_D,$Y_Sommet_D,1,0,255,255,255
 endif

L_O=10
H_O=0
I_T=32
H_P=30
R_P=0
V_P=0
B_P=0
H_O={$H_O+$I_T}
text[-1] "*****     Engrenages Gears Laser : samj_Engrenages_Laser_LED     *****",$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
H_O={$H_O+$I_T}
if $Module_m-$Module_m_Origine==0
 text[-1] "Module m : "$Module_m"   Demande/Settings : "$Module_m_Origine,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
else
 text[-1] "Module m : "$Module_m"   Demande/Settings : "$Module_m_Origine,$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
if $Angle_De_Pression_alpha-$Angle_De_Pression_alpha_Origine==0
 text[-1] "Angle de Pression/Pressure Angle : "$Angle_De_Pression_alpha"   Demande/Settings : "$Angle_De_Pression_alpha_Origine,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
else
 text[-1] "Angle de Pression/Pressure Angle : "$Angle_De_Pression_alpha"   Demande/Settings : "$Angle_De_Pression_alpha_Origine,$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
text[-1] "Diam. trou central [pixels] : "$Diam_Trou_Arbre,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Nb de dents roue Z1 / Nb of teeth gear Z1 : "$Nb_Dents_Roue_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Nb de dents roue Z2 / Nb of teeth gear Z2 : "$Nb_Dents_Roue_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
if $Trous_Assemb_Erreur>0
 H_O={$H_O+$I_T}
 text[-1] "Erreur : "$Trous_Assemb_Erreur" . Modifier section : Trous pour assemblage / Mechanical assembly.",$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
text[-1] "Nb. trous assemblage : "$Trous_Assemb_Nb,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Diam. trous assemblage [pixels] : "$Trous_Assemb_Diam,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Distance du centre [pixels] : "$Trous_Assemb_Distance_Centre,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Decalage angulaire trous [degres] : "$Trous_Assemb_Decalage_Angle,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
if $Erreur_Rainure>0
 H_O={$H_O+$I_T}
 text[-1] "Erreur : "$Erreur_Rainure" . Modifier section : Mortaise clavette trou central / Keyway cutting.",$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
text[-1] "Mortaise/Keyway Largeur / Width [pixels] : "$Rainure_Largeur,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Mortaise/Keyway Hauteur / Height [pixels] : "$Rainure_Hauteur,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Mortaise/Keyway Decalage Angulaire [degres] : "$14,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Creux b [pixels] : "$Creux_b,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Saillie a [pixels] : "$Saillie_a,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Vide Fond De Dent c [pixels] : "$Vide_Fond_De_Dent_c,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Hauteur de dent ht [pixels] : "$Hauteur_de_dent_ht,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Pas Primitif p [pixels] : "$Pas_Primitif_p,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Epaisseur Circulaire t [pixels] : "$Epaisseur_Circulaire_t,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Hauteur Active hk [pixels] : "$Hauteur_Active_hk,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Primitif Z1 Rouge/Red [pixels] : "$Dia_Primitif_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Cercle De Base Z1 Jaune/Yellow [pixels] : "$Diametre_Cercle_De_Base_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Tete Z1 Bleu/Blue [pixels] : "$Dia_Tete_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Pied Z1 Vert/Green [pixels] : "$Dia_Pied_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Primitif Z2 Rouge/Red [pixels] : "$Dia_Primitif_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Cercle De Base Z2 Jaune/Yellow [pixels] : "$Diametre_Cercle_De_Base_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Tete Z2 Bleu/Blue [pixels] : "$Dia_Tete_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Pied Z2 Vert/Green [pixels] : "$Dia_Pied_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255

# autres tracés FIN

 #Tete
 circle[-1] $X_Origine,$Y_Origine,{$Dia_Tete_Z1/2},1,0xFFFFFFFF,0,0,255,255
 #Primitif
 circle[-1] $X_Origine,$Y_Origine,{$Dia_Primitif_Z1/2},1,0xFFFFFFFF,255,0,0,255
 #Pied
 circle[-1] $X_Origine,$Y_Origine,{$Dia_Pied_Z1/2},1,0xFFFFFFFF,0,255,0,255
 #Cercle De Base
 circle[-1] $X_Origine,$Y_Origine,{$Diametre_Cercle_De_Base_Z1/2},1,0xFFFFFFFF,255,255,0,255

 #Tete
 circle[-1] $X_Origine,$Y_Origine,{$Dia_Tete_Z2/2},1,0xFFFFFFFF,0,0,255,255
 #Primitif
 circle[-1] $X_Origine,$Y_Origine,{$Dia_Primitif_Z2/2},1,0xFFFFFFFF,255,0,0,255
 #Pied
 circle[-1] $X_Origine,$Y_Origine,{$Dia_Pied_Z2/2},1,0xFFFFFFFF,0,255,0,255
 #Cercle De Base
 circle[-1] $X_Origine,$Y_Origine,{$Diametre_Cercle_De_Base_Z2/2},1,0xFFFFFFFF,255,255,0,255

 if $Contours_Plus==1 erode_circ[-2,-3] 2 endif

 #centre
 line[-1] {$X_Origine-5},$Y_Origine,{$X_Origine+5},$Y_Origine,1,170,85,255,255
 line[-1] $X_Origine,{$Y_Origine-5},$X_Origine,{$Y_Origine+5},1,170,85,255,255

reverse[-1,-2,-3]

################################################

samj_Engrenages_Laser_LED_Preview :

rm[0]
1080,1080,1,4
fill_color[-1] 255,255,255,255

Module_m={$1+1} # compensation boucle vérification dimensions
Angle_De_Pression_alpha={round($2*10000)/10000}
Diam_Trou_Arbre=$3
Nb_Dents_Roue_Z1=$4
Nb_Dents_Roue_Z2=$5
Egalite_Primitif=$6
Contours_Plus=$7
Trous_Assemb_Nb=$8
Trous_Assemb_Diam=$9
Trous_Assemb_Distance_Centre=$10
Trous_Assemb_Decalage_Angle={{pi}/180*$11}
Rainure_Largeur=$12
Rainure_Hauteur=$13
Rainure_Decalage_Angle={{pi}/180*$14}

Echelle=1
Dimension_Max_Image=7200 # pixels
Reserve_Contour_Image=10  # pixels

# correction automatique Module m
Module_m_Origine={$Module_m-1}
Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}

if $Nb_Dents_Roue_Z1>$Nb_Dents_Roue_Z2
 do
  Module_m={$Module_m-1}
  Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
  Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
 while $Dia_Tete_Z1>$Dimension_Max_Image-2*$Reserve_Contour_Image
else
 do
  Module_m={$Module_m-1}
  Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
  Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}
 while $Dia_Tete_Z2>$Dimension_Max_Image-2*$Reserve_Contour_Image
endif

Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
Dia_Pied_Z1={$Dia_Primitif_Z1-{2.5*$Echelle*$Module_m}}
Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}
Dia_Pied_Z2={$Dia_Primitif_Z2-{2.5*$Echelle*$Module_m}}

# correction automatique Angle De Pression alpha
Angle_De_Pression_alpha_Origine=$Angle_De_Pression_alpha
Angle_De_Pression_alpha={$Angle_De_Pression_alpha+0.1}
if $Nb_Dents_Roue_Z1>$Nb_Dents_Roue_Z2
 do
  Angle_De_Pression_alpha={$Angle_De_Pression_alpha-0.1}
  Diametre_Cercle_De_Base_Z1={$Dia_Primitif_Z1*cos({{pi}/180*$Angle_De_Pression_alpha})}
  Rayon_Developpante_Z1={$Diametre_Cercle_De_Base_Z1/2}
 while $Dia_Pied_Z1/2>$Rayon_Developpante_Z1
else
 do
  Angle_De_Pression_alpha={$Angle_De_Pression_alpha-0.1}
  Diametre_Cercle_De_Base_Z2={$Dia_Primitif_Z2*cos({{pi}/180*$Angle_De_Pression_alpha})}
  Rayon_Developpante_Z2={$Diametre_Cercle_De_Base_Z2/2}
 while $Dia_Pied_Z2/2>$Rayon_Developpante_Z2
endif
Angle_De_Pression_alpha={round($Angle_De_Pression_alpha*10000)/10000}

Dia_Primitif_Z1={$Echelle*$Module_m*$Nb_Dents_Roue_Z1}
Dia_Tete_Z1={$Dia_Primitif_Z1+{2*$Echelle*$Module_m}}
Diametre_Cercle_De_Base_Z1={$Dia_Primitif_Z1*cos({{pi}/180*$Angle_De_Pression_alpha})}  # Base des calculs / Compris entre le cercle de pied et le cercle primitif
Dia_Pied_Z1={$Dia_Primitif_Z1-{2.5*$Echelle*$Module_m}}
Dia_Primitif_Z2={$Echelle*$Module_m*$Nb_Dents_Roue_Z2}
Dia_Tete_Z2={$Dia_Primitif_Z2+{2*$Echelle*$Module_m}}
Dia_Pied_Z2={$Dia_Primitif_Z2-{2.5*$Echelle*$Module_m}}
Diametre_Cercle_De_Base_Z2={$Dia_Primitif_Z2*cos({{pi}/180*$Angle_De_Pression_alpha})}  # Base des calculs / Compris entre le cercle de pied et le cercle primitif

# Vocabulaire engrenage http://www.zpag.net/Dessin_Technique/1980/EngrnagesCames/Definition_Formule_engre_droit.htm
Creux_b={$Echelle*$Module_m*1.25}
Saillie_a={$Echelle*$Module_m}
Vide_Fond_De_Dent_c={$Creux_b-$Saillie_a}
Hauteur_de_dent_ht={$Creux_b+$Saillie_a}
Pas_Primitif_p={$Echelle*$Module_m*{pi}}
Epaisseur_Circulaire_t={$Pas_Primitif_p/2}
Hauteur_Active_hk={2*$Saillie_a}

Trous_Assemb_Erreur=0
if {{$Trous_Assemb_Distance_Centre+{$Trous_Assemb_Diam/2}}>{$Dia_Pied_Z1/2}} Trous_Assemb_Erreur={$Trous_Assemb_Erreur+1} endif
if {$Trous_Assemb_Distance_Centre-{$Trous_Assemb_Diam/2}}<{$Diam_Trou_Arbre/2} Trous_Assemb_Erreur={$Trous_Assemb_Erreur+10} endif
if $Trous_Assemb_Nb>3
 # samj_Annular_Steiner_Chains
 Rayon_Cercle_Exterieur={$Trous_Assemb_Distance_Centre+$Trous_Assemb_Diam}
 Angle_Theta={pi/$Trous_Assemb_Nb}
 Rayon_Cercle_Centre={{$Rayon_Cercle_Exterieur*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
 Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
 Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
 Rayon_Tang={({{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}})^0.5}
 if $Trous_Assemb_Distance_Centre<$Rayon_Tang Trous_Assemb_Erreur={$Trous_Assemb_Erreur+100} endif
endif

Erreur_Rainure=0
if $Rainure_Hauteur>{{$Diam_Trou_Arbre/2}-1}
 Erreur_Rainure={$Erreur_Rainure+1}
endif
if $Rainure_Largeur>{{$Diam_Trou_Arbre/2}-1}
 Erreur_Rainure={$Erreur_Rainure+10}
endif

L_O=10
H_O=0
I_T=32
H_P=30
R_P=0
V_P=0
B_P=0
H_O={$H_O+$I_T}
text[-1] "*****     Engrenages Gears Laser : samj_Engrenages_Laser_LED     *****",$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
H_O={$H_O+$I_T}
if $Module_m-$Module_m_Origine==0
 text[-1] "Module m : "$Module_m"   Demande/Settings : "$Module_m_Origine,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
else
 text[-1] "Module m : "$Module_m"   Demande/Settings : "$Module_m_Origine,$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
if $Angle_De_Pression_alpha-$Angle_De_Pression_alpha_Origine==0
 text[-1] "Angle de Pression/Pressure Angle : "$Angle_De_Pression_alpha"   Demande/Settings : "$Angle_De_Pression_alpha_Origine,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
else
 text[-1] "Angle de Pression/Pressure Angle : "$Angle_De_Pression_alpha"   Demande/Settings : "$Angle_De_Pression_alpha_Origine,$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
text[-1] "Diam. trou central [pixels] : "$Diam_Trou_Arbre,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Nb de dents roue Z1 / Nb of teeth gear Z1 : "$Nb_Dents_Roue_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Nb de dents roue Z2 / Nb of teeth gear Z2 : "$Nb_Dents_Roue_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
if $Trous_Assemb_Erreur>0
 H_O={$H_O+$I_T}
 text[-1] "Erreur : "$Trous_Assemb_Erreur" . Modifier section : Trous pour assemblage / Mechanical assembly.",$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
text[-1] "Nb. trous assemblage : "$Trous_Assemb_Nb,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Diam. trous assemblage [pixels] : "$Trous_Assemb_Diam,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Distance du centre [pixels] : "$Trous_Assemb_Distance_Centre,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Decalage angulaire trous [degres] : "$Trous_Assemb_Decalage_Angle,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
if $Erreur_Rainure>0
 H_O={$H_O+$I_T}
 text[-1] "Erreur : "$Erreur_Rainure" . Modifier section : Mortaise clavette trou central / Keyway cutting.",$L_O,$H_O,{$H_P+2},1,255,0,0,255
endif
H_O={$H_O+$I_T}
text[-1] "Mortaise/Keyway Largeur / Width [pixels] : "$Rainure_Largeur,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Mortaise/Keyway Hauteur / Height [pixels] : "$Rainure_Hauteur,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Mortaise/Keyway Decalage Angulaire [degres] : "$14,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Creux b [pixels] : "$Creux_b,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Saillie a [pixels] : "$Saillie_a,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Vide Fond De Dent c [pixels] : "$Vide_Fond_De_Dent_c,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Hauteur de dent ht [pixels] : "$Hauteur_de_dent_ht,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Pas Primitif p [pixels] : "$Pas_Primitif_p,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Epaisseur Circulaire t [pixels] : "$Epaisseur_Circulaire_t,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Hauteur Active hk [pixels] : "$Hauteur_Active_hk,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Primitif Z1 [pixels] : "$Dia_Primitif_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Cercle De Base Z1 [pixels] : "$Diametre_Cercle_De_Base_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Tete Z1 [pixels] : "$Dia_Tete_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Pied Z1 [pixels] : "$Dia_Pied_Z1,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Primitif Z2 [pixels] : "$Dia_Primitif_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Cercle De Base Z2 [pixels] : "$Diametre_Cercle_De_Base_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Tete Z2 [pixels] : "$Dia_Tete_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255
H_O={$H_O+$I_T}
text[-1] "Dia. Pied Z2 [pixels] : "$Dia_Pied_Z2,$L_O,$H_O,$H_P,1,$R_P,$V_P,$B_P,255

#################################################
##                                             ##
##       FIN samj_Engrenages_Laser_LED         ##
##                                             ##
#################################################
#################################################
##                                             ##
##         samj_Contour_Line_Laser_LED         ##
##                                             ##
#################################################

#@gui Contour Line Laser : samj_Contour_Line_Laser_LED, samj_Contour_Line_Laser_LED
#@gui :_=link("https://samjcreations.blogspot.com/2019/12/samuser-avec-gmic-gimp-decoupes-laser.html","https://samjcreations.blogspot.com/2019/12/samuser-avec-gmic-gimp-decoupes-laser.html")
#@gui :_=note("<small><i>Epaissir Adoucir Les Lignes Du Contour</i></small>")
#@gui :_=note("<small><i>Thick / Soft Contour Line</i></small>")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Type = choice(0,"Non / No","Gros/Thick Contour","Doux/Soft Contour","Gros+Doux/Thick+Soft Contour")
#@gui : Dilatation = int(1,1,48)
#@gui : Ajuster Dimension Image = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/28</i>.</small>")

samj_Contour_Line_Laser_LED :

to_rgba[-1]
if $3==1
 Largeur={w}
 Hauteur={h}
 expand_x[-1] {$2+$2},0
 expand_y[-1] {$2+$2},0
 replace_color[-1] 1%,0,0,0,0,0,255,255,255,255
endif
if $1>0
 if $1==1
  erode_circ[-1] {$2+1}
 elif $1==2
  erode_circ[-1] {$2+1}
  dilate_circ[-1] {$2+1}
 elif $1==3
  erode_circ[-1] {$2+$2+1}
  dilate_circ[-1] {$2+1}
 endif
 replace_color[-1] 70%,0,0,0,0,255,0,0,0,255
endif
if $3==1
 autocrop[-1]
 expand_x[-1] {$Largeur/100},0
 expand_y[-1] {$Hauteur/100},0
 replace_color[-1] 1%,0,0,0,0,0,255,255,255,255
endif

#################################################
##                                             ##
##      FIN samj_Contour_Line_Laser_LED        ##
##                                             ##
#################################################
#################################################
##                                             ##
##             Etoiles_Laser_LED               ##
##                                             ##
#################################################

#@gui Etoiles Stars Laser : samj_Etoiles_Laser_LED, samj_Etoiles_Laser_LED
#@gui :_=note("<small><i>Étoiles/Stars Laser Cutting Engraving</i></small>")
#@gui :_=note("<small><i>Formes Arrondies / Rounded Shapes</i></small>")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Dimension X Y = int(1400,800,3200)
#@gui : Nb Branches / Rays  = int(5,5,72)
#@gui : Type = choice(2,"Pompei A 12 Branches/Rays","Pompei B 12 Branches/Rays"","C","Annular SteinerChains","Traits/Strokes","Gear","Spirographe 4")
#@gui : Affichage / Display Contours = choice(0,"Non / No","Contours Image","Contours Étoile/Star","Contours Image + Étoile/Star")
#@gui : Dilate = int(0,0,48)
#@gui : Cercle Central Noir/Black = float(0,0,48)
#@gui : Cercle Central Blanc/White = float(0,0,48)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/27</i>.</small>")

samj_Etoiles_Laser_LED :
 rm[0]
 $1,$1,1,4
 fill_color[-1] 255,255,255,255
 if $3==0
  samj_Etoile_De_Pompei_Triangles_Sierpinski[-1] 50,50,30,96,0,0,0,255,1,1,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,$5,0,0,0,0.5,0.5,1.8,0,0,0,0
 elif $3==1
  samj_Etoile_De_Pompei_Triangles_Sierpinski[-1] 50,50,30,96,0,0,0,255,1,2,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,$5,0,0,0,0.5,0.5,1.8,0,0,0,0
 elif $3==2
  samj_en_Formes_Geometriques_Simples[-1] 50,50,255,255,255,255,0,0,0,255,255,255,255,255,3,48,48,$2,0,$5,1
 elif $3==3
  samj_Annular_Steiner_Chains[-1] 50,50,46,$2,0,0,0,0,255,0,0,0,0,0,0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,$5,0,0,0,0.5,0.5,1.8,0,0,0,1
 elif $3==4
  Traits_Strokes_samj[-1] 50,50,46,0,100,0,$2,0,360,0,0,0,255,0,$5,0,20,0,0,0,1,1
 elif $3==5
  shape_gear[-1] {$1*0.96},$2,100,0,0
  n[-1]  0,255
  blend[-1,-2] alpha,1,0
  to_rgb[-1]
  negate[-1]
  to_rgba[-1]
 elif $3==6
  Spirographe_samj[-1] 50,50,208,52,150,0,0,0,255,0,0,1,0,1,0,0,0,0,0,0,255,$5,0,0,0,255,0,0,0,1,1
 endif
 if $6>0
  circle[-1] {$1/2},{$1/2},{$1*$6/100},1,0,0,0,255
 endif
 if $7>0
  circle[-1] {$1/2},{$1/2},{$1*$7/100},1,255,255,255,255
 endif
 to_rgba[-1]
 if $4==1
  polygon[-1] 4,1%,1%,99%,1%,99%,99%,1%,99%,1,0xFFFFFFFF,0,0,0,1
 elif $4==2
  gradient_norm[-1]
  negate[-1]
 elif $4==3
  gradient_norm[-1]
  negate[-1]
  polygon[-1] 4,1%,1%,99%,1%,99%,99%,1%,99%,1,0xFFFFFFFF,0,0,0,1
 endif
 replace_color[-1] 70%,0,0,0,0,255,0,0,0,255

#################################################
##                                             ##
##           FIN Etoiles_Laser_LED             ##
##                                             ##
#################################################
#################################################
##                                             ##
##             Flocon_Laser_LED                ##
##                                             ##
#################################################

#@gui Flocon Snowflake Laser : samj_Flocon_Laser_LED, samj_Flocon_Laser_LED
#@gui :_=note("<small><i>Flocon/Snowflake Laser Cutting Engraving</i></small>")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Dimension X Y = int(1400,800,3200)
#@gui : Nb Branches / Rays  = int(6,3,15)
#@gui : Type Flocon / Snowflake = choice(5,"A","B","C","A2","B2","C2")
#@gui : Affichage / Display Contours = choice(0,"Non / No","Contours Image","Contours Flocon/Snowflake","Contours Image + Flocon/Snowflake")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/26</i>.</small>")

samj_Flocon_Laser_LED :
 rm[0]
 $1,$1,1,4
 fill_color[-1] 255,255,255,255
 samj_Flocon_De_Neige[-1] 50,50,$2,45,40,0,1,0,0,0,1,2,1,0,0,0,0.7,$3,0,0,0,44,0,0,0,0.5,0.5,1.8,0,0,0,0
 if $4==1
  polygon[-1] 4,1%,1%,99%,1%,99%,99%,1%,99%,1,0xFFFFFFFF,0,0,0,1
 elif $4==2
  gradient_norm[-1]
  negate[-1]
  replace_color[-1] 70%,0,0,0,0,255,0,0,0,255
 elif $4==3
  gradient_norm[-1]
  negate[-1]
  polygon[-1] 4,1%,1%,99%,1%,99%,99%,1%,99%,1,0xFFFFFFFF,0,0,0,1
  replace_color[-1] 70%,0,0,0,0,255,0,0,0,255
 endif

#################################################
##                                             ##
##            FIN Flocon_Laser_LED             ##
##                                             ##
#################################################
#################################################
##                                             ##
##          samj_Palette_De_Degrades           ##
##                                             ##
#################################################

# couleurs https://www.design-seeds.com
#@gui Palette De Degrades : samj_Palette_De_Degrades, samj_Palette_De_Degrades_preview(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Palette_De_Degrades - Gradient Palette</b></span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="blue">Obtenir des degrades avec 12 couleurs plus noir et blanc en option - Lent</span>")
#@gui :_=note("<span foreground="blue">Get gradients from 12 colors with optional black and white - Slow</span>")
#@gui : sep = separator()
#@gui : Couleur - Color A = color(159,190,195)
#@gui : Couleur - Color B = color(55,67,140)
#@gui : Couleur - Color C = color(54,40,39)
#@gui : Couleur - Color D = color(140,81,88)
#@gui : Couleur - Color E = color(207,175,190)
#@gui : Couleur - Color F = color(220,202,196)
#@gui : Couleur - Color G = color(170,186,192)
#@gui : Couleur - Color H = color(130,149,139)
#@gui : Couleur - Color I = color(112,96,96)
#@gui : Couleur - Color J = color(237,168,138)
#@gui : Couleur - Color K = color(220,199,205)
#@gui : Couleur - Color L = color(234,217,219)
#@gui : Ajouter du Noir - Add Black = bool(0)
#@gui : Ajouter du Blanc - Add White = bool(0)
#@gui : Étendue Degradé - Width = int(256,2,1024)
#@gui : Hauteur d'un Degradé - Height Of One Gradient= int(2,2,20)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")
samj_Palette_De_Degrades :

 R_a=$1
 V_a=$2
 B_a=$3

 R_b=$4
 V_b=$5
 B_b=$6

 R_c=$7
 V_c=$8
 B_c=$9

 R_d=$10
 V_d=$11
 B_d=$12

 R_e=$13
 V_e=$14
 B_e=$15

 R_f=$16
 V_f=$17
 B_f=$16

 R_g=$19
 V_g=$20
 B_g=$21

 R_h=$22
 V_h=$23
 B_h=$25

 R_i=$25
 V_i=$26
 B_i=$27

 R_j=$28
 V_j=$29
 B_j=$30

 R_k=$31
 V_k=$32
 B_k=$33

 R_l=$34
 V_l=$35
 B_l=$36

 Ajouter_Noir=$37
 Ajouter_Blanc=$38
 Etendue_Degrade=$39
 Hauteur_De_Un_Degrade=$40
 Hauteur_Degrade={66*$Hauteur_De_Un_Degrade}
 Hauteur_Origine_Degrade=-1

 if {$Ajouter_Noir+$Ajouter_Blanc}==1
  Hauteur_Degrade={78*$Hauteur_De_Un_Degrade}
 endif
 if {$Ajouter_Noir+$Ajouter_Blanc}==2
  Hauteur_Degrade={91*$Hauteur_De_Un_Degrade}
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_b,$V_b,$B_b,255

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_c,$V_c,$B_c,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_d,$V_d,$B_d,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_e,$V_e,$B_e,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_f,$V_f,$B_f,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_g,$V_g,$B_g,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_a,$V_a,$B_a,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_c,$V_c,$B_c,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_d,$V_d,$B_d,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_e,$V_e,$B_e,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_f,$V_f,$B_f,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_g,$V_g,$B_g,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_b,$V_b,$B_b,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_d,$V_d,$B_d,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_e,$V_e,$B_e,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_f,$V_f,$B_f,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_g,$V_g,$B_g,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_c,$V_c,$B_c,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_e,$V_e,$B_e,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_f,$V_f,$B_f,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_g,$V_g,$B_g,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_d,$V_d,$B_d,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_f,$V_f,$B_f,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_g,$V_g,$B_g,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_e,$V_e,$B_e,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_g,$V_g,$B_g,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_f,$V_f,$B_f,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_h,$V_h,$B_h,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_g,$V_g,$B_g,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_i,$V_i,$B_i,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_h,$V_h,$B_h,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,$R_j,$V_j,$B_j,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_i,$V_i,$B_i,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,$R_k,$V_k,$B_k,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_j,$V_j,$B_j,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 $Etendue_Degrade,$Hauteur_Degrade,1,4
 samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_k,$V_k,$B_k,255,$R_l,$V_l,$B_l,255
 Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_k,$V_k,$B_k,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_k,$V_k,$B_k,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 if $Ajouter_Noir==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_l,$V_l,$B_l,255,0,0,0,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif
 if $Ajouter_Blanc==1
  $Etendue_Degrade,$Hauteur_Degrade,1,4
  samj_Linear_Gradient_CIE_Lab[-1] 0,0,$R_l,$V_l,$B_l,255,255,255,255,255
  Hauteur_Origine_Degrade={$Hauteur_Origine_Degrade+$Hauteur_De_Un_Degrade} rectangle[-1] 0,0,$Etendue_Degrade,$Hauteur_Origine_Degrade,1,0,0,0,0 blend[-1,-2] alpha,1,1
 endif

 rv[-2,-1]

samj_Palette_De_Degrades_preview :

 samj_Palette_De_Degrades[-1] $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,2

#################################################
##                                             ##
##        FIN samj_Palette_De_Degrades         ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  Orbites                    ##
##                                             ##
#################################################

# exemple : samj_Orbites 100,0,0,0,255,50,50,15,39,49,15,240,128,64,255,0,5,0,0,0,0,0,0
# 2018/02/04 GMIC 2.2.0 pre
#@gui Orbites : samj_Orbites, samj_Orbites(1)
#@gui :_=link("https://youtu.be/_JgHQU1Fntg","https://youtu.be/_JgHQU1Fntg")
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="red">New Image</span></b></small>")
#@gui : Image Dimensions = float(100,30,400)
#@gui : Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="blue">Rendering</span></b></small>")
#@gui : X Position (%) = float(50,0,100)
#@gui : Y Position (%) = float(50,0,100)
#@gui : Circle A Radius = float(20,10,1000)
#@gui : Number of Points Circle A = int(79,10,1080)
#@gui : Circle B Radius = float(45,1,1000)
#@gui : Multiplier Number of Points Circle B = float(2,0.1,20)
#@gui : Color Straight Lines = color(240,128,64,255)
#@gui : Tilt Angle A = float(0,-360,360)
#@gui : Tilt Angle B = float(0,-360,360)
#@gui : Random Colors = bool(0)
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="blue">Changes Rendering Image Filter</span></b></small>")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Draw Circles = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2018/02/04</i>.</small>")

samj_Orbites :

 Dimension={round({{max({w},{h})}*$1/100})}
 R_fond=$2
 V_fond=$3
 B_fond=$4
 A_fond=$5
 X={round({$Dimension*{$6/100}})}
 Y={round({$Dimension*{$7/100}})}
 Rayon_Cercle_A={round({$Dimension*$8/100})}
 Nb_Points_A=$9
 Rayon_Cercle_B={round({$Dimension*$10/100})}
 Multiplicateur=$11
 R_a=$12
 V_a=$13
 B_a=$14
 A_a=$15
 Angle_Inclinaison_A=$16
 Angle_Inclinaison_B=$17
 Couleurs_aleatoires=$18
 Flou=$19
 Dilatation=$20
 Deformation=$21
 Bruit=$22
 Tracer_Les_Cercles=$23

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Variation_Angle_A={360/$Nb_Points_A}
 Variation_Angle_B={360/{$Nb_Points_A*$Multiplicateur}}
 Sortie_Boucle_Lignes=0
 Nb_Boucle_Lignes=0
 Nb_Boucle_Points=0

 Boucles_Rendu={round({{$Nb_Points_A*$Multiplicateur}+$Nb_Points_A}+1)}

 rm[-1]
 $Dimension,$Dimension,1,4
 fill_color[-1] 0,0,0,0
 Angle_A=0
 X_Imp_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}
 Y_Imp_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}

 Angle_B=0
 X_Imp_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}
 Y_Imp_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}

 repeat $Boucles_Rendu

  if $Couleurs_aleatoires==1
    R_a={round(u)*255}
    V_a={round(u)*255}
    B_a={round(u)*255}
  endif

  line[-1] $X_Imp_A,$Y_Imp_A,$X_Imp_B,$Y_Imp_B,1,$R_a,$V_a,$B_a,$A_a

  Angle_A={$Variation_Angle_A+$Angle_A}
  X_Imp_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}
  Y_Imp_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle_A+$Angle_Inclinaison_A}})}}}

  Angle_B={$Variation_Angle_B+$Angle_B}
  X_Imp_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}
  Y_Imp_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle_B+$Angle_Inclinaison_B}})}}}

 done

 if $Tracer_Les_Cercles==1
  ellipse[-1] $X,$Y,$Rayon_Cercle_A,$Rayon_Cercle_A,0,1,0xFFFFFFFF,$R_a,$V_a,$B_a,$A_a
  ellipse[-1] $X,$Y,$Rayon_Cercle_B,$Rayon_Cercle_B,0,1,0xFFFFFFFF,$R_a,$V_a,$B_a,$A_a
 endif
 if $Dilatation>1 dilate_circ[-1] $Dilatation endif
 if $Flou>0 blur[-1] $Flou,0 endif
 if $Deformation>0 deform[-1] $Deformation endif
 if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif

 $Dimension,$Dimension,1,4
 fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond

 gimp_blend_1651[-2,-1] 1,0,1,0,1

#################################################
##                                             ##
##                FIN Orbites                  ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Test_Visu_3D              ##
##                                             ##
#################################################

#@gui Test Visu 3D : samj_Test_Visu_3D, samj_Test_Visu_3D(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Test_Visu_3D</span>")
#@gui : Type 3D = choice(1,"Fichier 3D .off","elevation3d","imageplane3d","imagecube3d","gmic3d")
#@gui : Fichier 3D .off = text("C:\\\\GimpEval-2.9.5-Win\\\\images_test\\\\GMIC\\\\cube.off")
#@gui : Elevation3d = float(0.5,0,1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">rotate3d</span>")
#@gui : U  = bool(1)
#@gui : V  = bool(1)
#@gui : W  = bool(0)
#@gui : Angle = float(0,0,360)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">gaussians3d</span>")
#@gui : Size = int(0,0,32)
#@gui : Opacity = float(1,0,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Rendu</span>")
#@gui : Type = choice(0,"fx render3d","snapshot3d")
#@gui : Autocrop  = bool(0)
#@gui : Dimensions Origine  = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">fx render3d</span>")
#@gui : Width = int(1024,8,4096)
#@gui : Height = int(1024,8,4096)
#@gui : Object Size = float(0.5,0,3)
#@gui : X angle = float(0,0,360)
#@gui : Y angle = float(0,0,360)
#@gui : Z angle = float(0,0,360)
#@gui : FOV = float(45,1,90)
#@gui : X light = float(0,-100,100)
#@gui : Y light = float(0,-100,100)
#@gui : Z light = float(-100,-100,0)
#@gui : Specular lightness = float(0.5,0,1)
#@gui : Specular shininess = float(0.7,0,3)
#@gui : Rendering = choice(2,"Dots","Wireframe","Flat","Flat shaded","Gouraud","Phong")
#@gui : Antialiasing = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">snapshot3d</span>")
#@gui : Dimension = int(400,256,4096)
#@gui : Zoom = float(1,1,2)
#@gui : Fond = color(225,255,255,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2017/01/15</i>.</small>")

samj_Test_Visu_3D :

Choix=$1
Fichier=$2
Val_Elevation=$3

R_U=$4
R_V=$5
R_W=$6
R_angle=$7

G_Size=$8
G_Opacity=$9

Type_Rendu=$10
Valider_Autocrop=$11
Dimensions_Origine=$12

Width=$13
Height=$14
Object_size=$15
X_angle=$16
Y_angle=$17
Z_angle=$18
FOV=$19
X_light=$20
Y_light=$21
Z_light=$22
Specular_lightness=$23
Specular_shininess=$24
Rendering_mode=$25
Antialiasing=$26

S_Dimension=$27
S_Zoom=$28
S_R=$29
S_V=$30
S_B=$31
S_A=$32

Largeur_Origine={w}
Hauteur_Origine={h}

if $Choix==0
 rm[0]
 input $Fichier
elif $Choix==1
 elevation3d[-1] $Val_Elevation
elif $Choix==2
 imageplane3d[-1]
elif $Choix==3
 imagecube3d[-1]
elif $Choix==4
 rm[-1]
 gmic3d
endif
rotate3d[-1] $R_U,$R_V,$R_W,$R_angle
if $G_Size>0 gaussians3d[-1] $G_Size,$G_Opacity endif
#normalize3d[-1]
if $Type_Rendu==0
 fx_render3d[-1] $Width,$Height,$Object_size,$X_angle,$Y_angle,$Z_angle,$FOV,$X_light,$Y_light,$Z_light,$Specular_lightness,$Specular_shininess,$Rendering_mode,$Antialiasing
elif $Type_Rendu==1
 snapshot3d[-1] $S_Dimension,$S_Zoom,$S_R,$S_V,$S_B,$S_A
endif
if $Valider_Autocrop==1 autocrop[-1] endif
if $Dimensions_Origine==1 resize[-1] $Largeur_Origine,$Hauteur_Origine endif

#################################################
##                                             ##
##            FIN samj_Test_Visu_3D            ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Chains_Solidify             ##
##                                             ##
#################################################
# variation de Adjacent_Annular_Steiner_Chains
#@gui Chains Solidify : samj_Chains_Solidify, samj_Chains_Solidify(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">samj_Chains_Solidify</span>")
#@gui :_=separator()
#@gui :_=note("<small>Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Tilt = float(0,0,360)
#@gui :_=separator()
#@gui :_=note("<small>Circles</small>")
#@gui : Radius Center Circle = float(6,-100,100)
#@gui : Nb Circles Surrounding = int(56,7,360)
#@gui :_=separator()
#@gui :_=note("<small>Rings</small>")
#@gui : Nb Rings  = int(20,1,100)
#@gui : Offset Angle % = float(50,-100,100)
#@gui : Change Increment % = float(0,-100,200)
#@gui :_=separator()
#@gui :_=note("<small>Coulors</small>")
#@gui : Color A = color(255,0,221,255)
#@gui : Color B = color(72,0,255,255)
#@gui : Color C = color(0,145,255,255)
#@gui : Color D = color(0,255,144,255)
#@gui : Color E = color(72,255,0,255)
#@gui : Color F = color(255,217,0,255)
#@gui : Color G = color(255,0,0,255)
#@gui : Choice Of Colors = choice(5,"Couleurs / Colors AB","Couleurs / Colors ABC","Couleurs / Colors ABCD","Couleurs / Colors ABCDE","Couleurs / Colors ABCDEF","Couleurs / Colors ABCDEFG","Ordre ABCDEFG")
#@gui : Center Color = color(255,127,0,255)
#@gui : Background = color(0,0,0,255)
#@gui : Variation  = float(100,0,1000)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Chains_Solidify :

 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Angle_inclinaison=$3
 if $4>0
  Rayon_Cercle_Centre={round({{w}*$4/{100}})}
 else
  Rayon_Cercle_Centre={round({-{h}*$4/{100}})}
 endif
 Nb_Circles_Surrounding=$5
 Nb_Anneaux=$6
 Angle_Decalage=$7
 Variation_Increment_Anneaux=$8
 R_a=$9
 V_a=$10
 B_a=$11
 A_a=$12
 R_b=$13
 V_b=$14
 B_b=$15
 A_b=$16
 R_c=$17
 V_c=$18
 B_c=$19
 A_c=$20
 R_d=$21
 V_d=$22
 B_d=$23
 A_d=$24
 R_e=$25
 V_e=$26
 B_e=$27
 A_e=$28
 R_f=$29
 V_f=$30
 B_f=$31
 A_f=$32
 R_g=$33
 V_g=$34
 B_g=$35
 A_g=$36
 Rendu=$37
 R_centre=$38
 V_centre=$39
 B_centre=$40
 A_centre=$41
 R_Fond=$42
 V_Fond=$43
 B_Fond=$44
 A_Fond=$45
 Effet=$46

 Largeur_Origine={w}
 Hauteur_Origine={h}

 rm[0]
 $Largeur_Origine,$Hauteur_Origine,1,4
 fill_color[-1] 0,0,0,0
 +Je_passe_l_hiver_en_Floride[-1]
 Angle_Theta={pi/$Nb_Circles_Surrounding}
 if $Rayon_Cercle_Centre<1
  Rayon_Cercle_Centre=1
 endif
 Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
 Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
 Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
 Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
 Nb_boucles=0
 X_ext=0
 Y_ext=0
 Angle=0
 Angle_Decalage_En_Cours=0
 Nb_boucles_anneaux=0
 Rayon_Cercle_Centre_En_Cours=0
 Ra_en_cours=0
 Va_en_cours=0
 Ba_en_cours=0
 Aa_en_cours=0
 Suite_Couleurs=0
 point[-1] $X,$Y,0,1,$R_centre,$V_centre,$B_centre,$A_centre
 repeat $Nb_Anneaux
  Nb_boucles=0
  Suite_Couleurs=0
  Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage/100*$Nb_boucles_anneaux} # si curseur Angle_Decalage = 50
  if $Nb_boucles_anneaux==0
   Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
  else
   Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
  endif
  Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
  Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
  Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
  Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
  repeat $Nb_Circles_Surrounding
   if $Rendu==6 # suite
    if ($Nb_boucles%7)==0&&$Suite_Couleurs==0
     Ra_en_cours=$R_a
     Va_en_cours=$V_a
     Ba_en_cours=$B_a
     Aa_en_cours=$A_a
     Suite_Couleurs=1
    endif
    if ($Nb_boucles%7)==1&&$Suite_Couleurs==1
     Ra_en_cours=$R_b
     Va_en_cours=$V_b
     Ba_en_cours=$B_b
     Aa_en_cours=$A_b
     Suite_Couleurs=2
    endif
    if ($Nb_boucles%7)==2&&$Suite_Couleurs==2
     Ra_en_cours=$R_c
     Va_en_cours=$V_c
     Ba_en_cours=$B_c
     Aa_en_cours=$A_c
     Suite_Couleurs=3
    endif
    if ($Nb_boucles%7)==3&&$Suite_Couleurs==3
     Ra_en_cours=$R_d
     Va_en_cours=$V_d
     Ba_en_cours=$B_d
     Aa_en_cours=$A_d
     Suite_Couleurs=4
    endif
    if ($Nb_boucles%7)==4&&$Suite_Couleurs==4
     Ra_en_cours=$R_e
     Va_en_cours=$V_e
     Ba_en_cours=$B_e
     Aa_en_cours=$A_e
     Suite_Couleurs=5
    endif
    if ($Nb_boucles%7)==5&&$Suite_Couleurs==5
     Ra_en_cours=$R_f
     Va_en_cours=$V_f
     Ba_en_cours=$B_f
     Aa_en_cours=$A_f
     Suite_Couleurs=6
    endif
    if ($Nb_boucles%7)==6&&$Suite_Couleurs==6
     Ra_en_cours=$R_g
     Va_en_cours=$V_g
     Ba_en_cours=$B_g
     Aa_en_cours=$A_g
     Suite_Couleurs=0
    endif
   endif
   if $Rendu<6
    if {$Nb_boucles%2}==0
     Ra_en_cours=$R_a
     Va_en_cours=$V_a
     Ba_en_cours=$B_a
     Aa_en_cours=$A_a
    endif
    if {$Nb_boucles%2}==1
     Ra_en_cours=$R_b
     Va_en_cours=$V_b
     Ba_en_cours=$B_b
     Aa_en_cours=$A_b
    endif
    if {$Nb_boucles%3}==2&&$Rendu>0
     Ra_en_cours=$R_c
     Va_en_cours=$V_c
     Ba_en_cours=$B_c
     Aa_en_cours=$A_c
    endif
    if {$Nb_boucles%4}==3&&$Rendu>1
     Ra_en_cours=$R_d
     Va_en_cours=$V_d
     Ba_en_cours=$B_d
     Aa_en_cours=$A_d
    endif
    if {$Nb_boucles%5}==4&&$Rendu>2
     Ra_en_cours=$R_e
     Va_en_cours=$V_e
     Ba_en_cours=$B_e
     Aa_en_cours=$A_e
    endif
    if {$Nb_boucles%6}==5&&$Rendu>3
     Ra_en_cours=$R_f
     Va_en_cours=$V_f
     Ba_en_cours=$B_f
     Aa_en_cours=$A_f
    endif
    if {$Nb_boucles%7}==6&&$Rendu>4
     Ra_en_cours=$R_g
     Va_en_cours=$V_g
     Ba_en_cours=$B_g
     Aa_en_cours=$A_g
    endif
   endif
   Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
   X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
   Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
   Nb_boucles={$Nb_boucles+1}
   ellipse[-2] $X_ext,$Y_ext,{$Rayon_Cercles_Ext/100*$Effet},{$Rayon_Cercles_Ext/100*$Effet},0,1,0xFFFFFFFF,$R_Fond,$V_Fond,$B_Fond,$A_Fond
   point[-1] $X_ext,$Y_ext,0,1,$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Aa_en_cours
  done
  Nb_boucles_anneaux={$Nb_boucles_anneaux+1}
 done
 ellipse[-2] $X,$Y,{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},0,1,0xFFFFFFFF,$R_Fond,$V_Fond,$B_Fond,$A_Fond
 blend[-1,-2] alpha
 solidify[-1]

#################################################
##                                             ##
##           FIN samj_Chains_Solidify          ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Splines_Test              ##
##                                             ##
#################################################
# modif 2 ajout Version_Spline ...
# modif 1 erreur après codage de spline ... à voir
#@gui Splines Test  : samj_Splines_Test , samj_Splines_Test_preview (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Splines_Test</b></span>")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(50,0,100)
#@gui : Angle Origine = Float(30,0,360)
#@gui : Variation Angle = Float(30,-360,360)
#@gui : Variation Dimension = int(90,1,400)
#@gui : Répétition Spline = int(30,1,360)
#@gui : Répétition Dim = int(1,1,8)
#@gui : Increment Angle = Float(10,-360,360)
#@gui : uA0 = Float(2,-100,100)
#@gui : vA0 = Float(2,-100,100)
#@gui : uA1 = Float(2,-100,100)
#@gui : vA1 = Float(2,-100,100)
#@gui : uB0 = Float(2,-100,100)
#@gui : vB0 = Float(2,-100,100)
#@gui : uB1 = Float(2,-100,100)
#@gui : vB1 = Float(2,-100,100)
#@gui : Couleur Spline A = color(255,255,0,255)
#@gui : Couleur Spline B = color(0,255,255,255)
#@gui : Dilatation = int(1,1,8)
#@gui : Blend = bool(0)
#@gui : Version de Spline = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/09</i>.</small>")

samj_Splines_Test :

XO={round({{w}/100*$1})}
YO={round({{h}/100*$2})}
Angle_Origine=$3
Variation_Angle=$4
Var_Dim=$5
Repetition_Spline=$6
Repetition_Dim=$7
Inc_Angle=$8
uA0={round({{{w}+{h}}/200*$9})}
vA0={round({{{w}+{h}}/200*$10})}
uA1={round({{{w}+{h}}/200*$11})}
vA1={round({{{w}+{h}}/200*$12})}
uB0={round({{{w}+{h}}/200*$13})}
vB0={round({{{w}+{h}}/200*$14})}
uB1={round({{{w}+{h}}/200*$15})}
vB1={round({{{w}+{h}}/200*$16})}
R_a=$17
V_a=$18
B_a=$19
A_a=$20
R_b=$21
V_b=$22
B_b=$23
A_b=$24
Dilatation=$25
Validation_Blend=$26
Version_Spline=$27

deg_to_rad={pi/180}
X_Debut=$XO
Y_Debut=$YO
XF=0
YF=0
XA=0
YA=0
XB=0
YB=0

 to_rgba[-1]
 {w},{h},1,4
 repeat $Repetition_Spline
  XO=$X_Debut
  YO=$Y_Debut
  Angle_Origine={$Angle_Origine+$Inc_Angle}
  repeat $Repetition_Dim
   XF={$XO+{cos({$Angle_Origine+$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
   YF={$YO+{sin({$Angle_Origine+$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
   XA={round({$XO+{{$XF-$XO}/100*$uA0}})}
   YA={round({$YO+{{$YF-$YO}/100*$vA0}})}
   XB={round({$XF-{{$XF-$XO}/100*$uA1}})}
   YB={round({$YF-{{$YF-$YO}/100*$vA1}})}
   if $Version_Spline==0
    spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1,$R_a,$V_a,$B_a,$A_a
   else
    spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1024,1,$R_a,$V_a,$B_a,$A_a
   endif
   #line[-1] $XO,$YO,$XF,$YF,1,$R_a,$V_a,$B_a,$A_a
   XO=$XF
   YO=$YF
   XF={$XO+{cos({$Angle_Origine-$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
   YF={$YO+{sin({$Angle_Origine-$Variation_Angle}*$deg_to_rad)*$Var_Dim}}
   XA={round({$XO+{{$XF-$XO}/100*$uB0}})}
   YA={round({$YO+{{$YF-$YO}/100*$vB0}})}
   XB={round({$XF-{{$XF-$XO}/100*$uB1}})}
   YB={round({$YF-{{$YF-$YO}/100*$vB1}})}
   #line[-1] $XO,$YO,$XF,$YF,1,$R_b,$V_b,$B_b,$A_b
   if $Version_Spline==0
    spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1,$R_b,$V_b,$B_b,$A_b
   else
    spline[-1] $XO,$YO,$XA,$YA,$XF,$YF,$XB,$YB,1024,1,$R_b,$V_b,$B_b,$A_b
   endif
   XO=$XF
   YO=$YF
  done
 done
 dilate[-1] $Dilatation
 if $Validation_Blend==1 blend[-1,-2] alpha else rv[-1,-2] endif

samj_Splines_Test_preview :

 samj_Splines_Test[-1] $1,$2,$3,$4,{$5/2},$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27
 if $26==0 rm[-1] endif

#################################################
##                                             ##
##            FIN samj_Splines_Test            ##
##                                             ##
#################################################
#################################################
##                                             ##
##       Adjacent_Annular_Steiner_Chains       ##
##                                             ##
#################################################

# 20150502 origine
# 2016/02/02 {round(u)*255}

#@gui Adjacent Annular Steiner Chains : samj_Adjacent_Annular_Steiner_Chains, samj_Adjacent_Annular_Steiner_Chains(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>Cercles</small>")
#@gui : Rayon Cercle Centre / Radius Center Circle A = float(6,-100,100)
#@gui : Nb Cercles Extérieurs / Circles Surrounding  = int(56,7,360)
#@gui :_=separator()
#@gui :_=note("<small>Anneaux</small>")
#@gui : Nb Anneaux  = int(20,1,100)
#@gui : Angle Décalage / Offset Angle % = float(50,-100,100)
#@gui : Variation Increment Anneaux % = float(0,-100,200)
#@gui :_=separator()
#@gui :_=note("<small>Couleurs Cercles</small>")
#@gui : Couleur / Color A = color(255,0,221,127)
#@gui : Couleur / Color B = color(72,0,255,127)
#@gui : Couleur / Color C = color(0,145,255,127)
#@gui : Couleur / Color D = color(0,255,144,127)
#@gui : Couleur / Color E = color(72,255,0,127)
#@gui : Couleur / Color F = color(255,217,0,127)
#@gui : Couleur / Color G = color(255,0,0,127)
#@gui : Choix Des Couleurs / Choice Of Colors = choice(5,"Couleurs / Colors AB","Couleurs / Colors ABC","Couleurs / Colors ABCD","Couleurs / Colors ABCDE","Couleurs / Colors ABCDEF","Couleurs / Colors ABCDEFG","Ordre ABCDEFG")
#@gui : Variations Des Couleurs = float(0,-2,2)
#@gui : Couleurs aléatoires / Random Colors = choice(0,"Non / No","A","B","C")
#@gui :_=separator()
#@gui :_=note("<small>Contours</small>")
#@gui : Affichage / Display Contours = choice(2,"Non / No","A","B","C","D","E")
#@gui : Contours = color(0,0,0,255)
#@gui : Dilate Contours = int(0,0,16)
#@gui : Flou / Blur Contours = float(0,0,5)
#@gui : Sharpen = int(0,0,600)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Adjacent_Annular_Steiner_Chains :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Angle_inclinaison=$3
 Canal_Alpha=$4

 if $5>0
  Rayon_Cercle_Centre={round({{w}*$5/{100}})}
 else
  Rayon_Cercle_Centre={round({-{h}*$5/{100}})}
 endif
 Nb_Circles_Surrounding=$6

 Nb_Anneaux=$7
 Angle_Decalage=$8
 Variation_Increment_Anneaux=$9

 R_a=$10
 V_a=$11
 B_a=$12
 A_a=$13

 R_b=$14
 V_b=$15
 B_b=$16
 A_b=$17

 R_c=$18
 V_c=$19
 B_c=$20
 A_c=$21

 R_d=$22
 V_d=$23
 B_d=$24
 A_d=$25

 R_e=$26
 V_e=$27
 B_e=$28
 A_e=$29

 R_f=$30
 V_f=$31
 B_f=$32
 A_f=$33

 R_g=$34
 V_g=$35
 B_g=$36
 A_g=$37

 #Choix_Des_Couleurs
 Rendu=$38
 Variations_Des_Couleurs=$39
 Couleurs_aleatoires=$40

 Affichage_Contours=$41

 R_Contours=$42
 V_Contours=$43
 B_Contours=$44
 A_Contours=$45

 Dilate_Contours=$46
 Flou_Contours=$47
 Sharpen_Contours=$48

 Largeur_Origine={w}
 Hauteur_Origine={h}

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 # 1 nouvelle image contours
 $Largeur_Origine,$Hauteur_Origine,1,4
 fill_color[-1] 0,0,0,0

 # 1 nouvelle image couleurs
 $Largeur_Origine,$Hauteur_Origine,1,4
 fill_color[-1] 0,0,0,0

 Angle_Theta={pi/$Nb_Circles_Surrounding}
 if $Rayon_Cercle_Centre<1
  Rayon_Cercle_Centre=1
 endif

 Rayon_Cercle_Exterieur={$Rayon_Cercle_Centre*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}}
 Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
 Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
 Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
 Nb_boucles=0
 X_ext=0
 Y_ext=0
 Angle=0
 Angle_Decalage_En_Cours=0
 Nb_boucles_anneaux=0
 Rayon_Cercle_Centre_En_Cours=0
 Ra_en_cours=0
 Va_en_cours=0
 Ba_en_cours=0
 Aa_en_cours=0
 Suite_Couleurs=0

 if $Couleurs_aleatoires==1
  R_CE={round(u)*255}
  V_CE={round(u)*255}
  B_CE={round(u)*255}
  R_PC={round(u)*255}
  V_PC={round(u)*255}
  B_PC={round(u)*255}
 endif

 if $Couleurs_aleatoires==1
  R_a={round(u)*255}
  V_a={round(u)*255}
  B_a={round(u)*255}
  R_b={round(u)*255}
  V_b={round(u)*255}
  B_b={round(u)*255}
  R_c={round(u)*255}
  V_c={round(u)*255}
  B_c={round(u)*255}
  R_d={round(u)*255}
  V_d={round(u)*255}
  B_d={round(u)*255}
  R_e={round(u)*255}
  V_e={round(u)*255}
  B_e={round(u)*255}
  R_f={round(u)*255}
  V_f={round(u)*255}
  B_f={round(u)*255}
  R_g={round(u)*255}
  V_g={round(u)*255}
  B_g={round(u)*255}
 endif

 repeat $Nb_Anneaux

  Nb_boucles=0
  Suite_Couleurs=0

  if $Couleurs_aleatoires==2
   R_a={round(u)*255}
   V_a={round(u)*255}
   B_a={round(u)*255}
   R_b={round(u)*255}
   V_b={round(u)*255}
   B_b={round(u)*255}
   R_c={round(u)*255}
   V_c={round(u)*255}
   B_c={round(u)*255}
   R_d={round(u)*255}
   V_d={round(u)*255}
   B_d={round(u)*255}
   R_e={round(u)*255}
   V_e={round(u)*255}
   B_e={round(u)*255}
   R_f={round(u)*255}
   V_f={round(u)*255}
   B_f={round(u)*255}
   R_g={round(u)*255}
   V_g={round(u)*255}
   B_g={round(u)*255}
  endif

  Angle_Decalage_En_Cours={360/$Nb_Circles_Surrounding*$Angle_Decalage/100*$Nb_boucles_anneaux} # si curseur Angle_Decalage = 50
  if $Nb_boucles_anneaux==0
   Rayon_Cercle_Centre_En_Cours={$Rayon_Cercle_Centre}
  else
   Rayon_Cercle_Centre_En_Cours={$Rayon_Tang+{$Rayon_Cercles_Ext*{0.865+$Variation_Increment_Anneaux/100}}}
  endif

  Rayon_Cercle_Exterieur=$Rayon_Cercle_Centre_En_Cours*{{1+{sin($Angle_Theta)}}}/{1-{sin($Angle_Theta)}}
  Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre_En_Cours}/2}
  Rayon_Centres_C_Ext={$Rayon_Cercle_Centre_En_Cours+$Rayon_Cercles_Ext}
  Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}

  repeat $Nb_Circles_Surrounding

   if $Couleurs_aleatoires==3
    R_a={round(u)*255}
    V_a={round(u)*255}
    B_a={round(u)*255}
    R_b={round(u)*255}
    V_b={round(u)*255}
    B_b={round(u)*255}
    R_c={round(u)*255}
    V_c={round(u)*255}
    B_c={round(u)*255}
    R_d={round(u)*255}
    V_d={round(u)*255}
    B_d={round(u)*255}
    R_e={round(u)*255}
    V_e={round(u)*255}
    B_e={round(u)*255}
    R_f={round(u)*255}
    V_f={round(u)*255}
    B_f={round(u)*255}
    R_g={round(u)*255}
    V_g={round(u)*255}
    B_g={round(u)*255}
   endif
   if $Rendu==6 # suite

    if ($Nb_boucles%7)==0&&$Suite_Couleurs==0
     Ra_en_cours=$R_a
     Va_en_cours=$V_a
     Ba_en_cours=$B_a
     Aa_en_cours=$A_a
     Suite_Couleurs=1
    endif

    if ($Nb_boucles%7)==1&&$Suite_Couleurs==1
     Ra_en_cours=$R_b
     Va_en_cours=$V_b
     Ba_en_cours=$B_b
     Aa_en_cours=$A_b
     Suite_Couleurs=2
    endif

    if ($Nb_boucles%7)==2&&$Suite_Couleurs==2
     Ra_en_cours=$R_c
     Va_en_cours=$V_c
     Ba_en_cours=$B_c
     Aa_en_cours=$A_c
     Suite_Couleurs=3
    endif

    if ($Nb_boucles%7)==3&&$Suite_Couleurs==3
     Ra_en_cours=$R_d
     Va_en_cours=$V_d
     Ba_en_cours=$B_d
     Aa_en_cours=$A_d
     Suite_Couleurs=4
    endif

    if ($Nb_boucles%7)==4&&$Suite_Couleurs==4
     Ra_en_cours=$R_e
     Va_en_cours=$V_e
     Ba_en_cours=$B_e
     Aa_en_cours=$A_e
     Suite_Couleurs=5
    endif

    if ($Nb_boucles%7)==5&&$Suite_Couleurs==5
     Ra_en_cours=$R_f
     Va_en_cours=$V_f
     Ba_en_cours=$B_f
     Aa_en_cours=$A_f
     Suite_Couleurs=6
    endif

    if ($Nb_boucles%7)==6&&$Suite_Couleurs==6
     Ra_en_cours=$R_g
     Va_en_cours=$V_g
     Ba_en_cours=$B_g
     Aa_en_cours=$A_g
     Suite_Couleurs=0
    endif

   endif

   if $Rendu<6

    if ($Nb_boucles%2)==0
     Ra_en_cours=$R_a
     Va_en_cours=$V_a
     Ba_en_cours=$B_a
     Aa_en_cours=$A_a
    endif

    if ($Nb_boucles%2)==1
     Ra_en_cours=$R_b
     Va_en_cours=$V_b
     Ba_en_cours=$B_b
     Aa_en_cours=$A_b
    endif

    if ($Nb_boucles%3)==2&&$Rendu>0
     Ra_en_cours=$R_c
     Va_en_cours=$V_c
     Ba_en_cours=$B_c
     Aa_en_cours=$A_c
    endif

    if ($Nb_boucles%4)==3&&$Rendu>1
     Ra_en_cours=$R_d
     Va_en_cours=$V_d
     Ba_en_cours=$B_d
     Aa_en_cours=$A_d
    endif

    if ($Nb_boucles%5)==4&&$Rendu>2
     Ra_en_cours=$R_e
     Va_en_cours=$V_e
     Ba_en_cours=$B_e
     Aa_en_cours=$A_e
    endif

    if ($Nb_boucles%6)==5&&$Rendu>3
     Ra_en_cours=$R_f
     Va_en_cours=$V_f
     Ba_en_cours=$B_f
     Aa_en_cours=$A_f
    endif

    if ($Nb_boucles%7)==6&&$Rendu>4
     Ra_en_cours=$R_g
     Va_en_cours=$V_g
     Ba_en_cours=$B_g
     Aa_en_cours=$A_g
    endif

   endif

   Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
   X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}
   Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Decalage_En_Cours}})}}}

   Nb_boucles={$Nb_boucles+1}

   ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Aa_en_cours

   if $Affichage_Contours==1||$Affichage_Contours==2
    ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
   endif

   if {$Affichage_Contours==4||$Affichage_Contours==5}&&($Nb_boucles%2)==1
    ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
   endif

  done

  Nb_boucles_anneaux={$Nb_boucles_anneaux+1}

 done

 if $Affichage_Contours==1||$Affichage_Contours==3||$Affichage_Contours==5
  ellipse[-2] $X,$Y,{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},{$Rayon_Centres_C_Ext+$Rayon_Cercles_Ext},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 if $Dilate_Contours>1 dilate_circ[-2] $Dilate_Contours endif
 if $Flou_Contours>0 blur[-2] $Flou_Contours,0 endif
 if $Sharpen_Contours>0 sharpen[-2] $Sharpen_Contours endif

 if $Variations_Des_Couleurs<0 *[-1] {abs($Variations_Des_Couleurs)} c[-1] 0,255 endif

 blend[-2,-1] alpha,1,1

 if $Variations_Des_Couleurs>0 *[-1] $Variations_Des_Couleurs c[-1] 0,255 endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##     FIN Adjacent_Annular_Steiner_Chains     ##
##                                             ##
#################################################
#################################################
##                                             ##
##          Triangles_Shades_Adjacents         ##
##                                             ##
#################################################

# 2015/04/28 origine - À voir : modifier et améliorer les dégradés rgb / Angle_Artefacts (Artefacts diminuent avec dimensions > )
# 2016/02/02 {round(u)*255}

#@gui Triangles Shades Adjacents : Triangles_Shades_Adjacents, Triangles_Shades_Adjacents(1)
#@gui :_=note("<span foreground="orangered"><b>Image Finale / Resulting Image</b></span>")
#@gui : Supprimer Calque Origine / Delete Layer Source = bool(0)
#@gui : Position Centre X / X Center = float(50,0,100)
#@gui : Position Centre Y / Y Center  = float(50,0,100)
#@gui : Nb Triangles  = int(60,3,360)
#@gui : Artefacts / Artifacts = int(-1,-1,10)
#@gui :_=note("<span foreground="orangered"><b>Couleurs / Colors</b></span>")
#@gui : Décalage Des Couleurs / Offset (Angle) = float(0,-360,360)
#@gui : - - -  Centre / Center - - - = color(255,255,255)
#@gui : Couleur / Color A = color(255,0,221)
#@gui : Couleur / Color B = color(72,0,255)
#@gui : Couleur / Color C = color(0,145,255)
#@gui : Couleur / Color D = color(0,255,144)
#@gui : Couleur / Color E = color(72,255,0)
#@gui : Couleur / Color F = color(255,217,0)
#@gui : Couleur / Color G = color(255,0,0)
#@gui : Choix Des Couleurs / Choice Of Colors = choice(5,"Couleurs / Colors AB","Couleurs / Colors ABC","Couleurs / Colors ABCD","Couleurs / Colors ABCDE","Couleurs / Colors ABCDEF","Couleurs / Colors ABCDEFG")
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b>Color Balance</b></span>")
#@gui : Activer / Enable Color Balance = bool(0)
#@gui : Neutral color = color(128,128,128)
#@gui : Stretch colors = bool(1)
#@gui :_=note("<span foreground="orangered"><b>Mélange / Blend</b></span>")
#@gui : Activer Mélange / Enable Blend = bool(0)
#@gui : Mode = choice{3,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui : Revert layers = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

Triangles_Shades_Adjacents:

 Supprimer_Calque_Origine=$1
 Position_Centre_X=$2
 Position_Centre_Y=$3
 Nombre_De_Triangles=$4
 Artefacts=$5

 Angle_Decalage_Couleurs=$6

 R_Centre=$7
 V_Centre=$8
 B_Centre=$9

 R_a=$10
 V_a=$11
 B_a=$12

 R_b=$13
 V_b=$14
 B_b=$15

 R_c=$16
 V_c=$17
 B_c=$18

 R_d=$19
 V_d=$20
 B_d=$21

 R_e=$22
 V_e=$23
 B_e=$24

 R_f=$25
 V_f=$26
 B_f=$27

 R_g=$28
 V_g=$29
 B_g=$30

 #Choix_Des_Couleurs
 Rendu=$31
 Couleurs_aleatoires=$32

 Activer_Color_Balance=$33
 R_Neutral_color=$34
 V_Neutral_color=$35
 B_Neutral_color=$36
 Stretch_colors=$37

 Activer_Melange=$38
 Mode=$39
 Opacity=$40
 Revert_layers=$41

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Ra_en_cours=0
 Va_en_cours=0
 Ba_en_cours=0
 Rb_en_cours=0
 Vb_en_cours=0
 Bb_en_cours=0
 Rc_en_cours=0
 Vc_en_cours=0
 Bc_en_cours=0
 Rayon_De_Couleur={round({{{{$Largeur_Origine^2}+{$Hauteur_Origine^2}}^0.5}+1})}
 Angle_Rayon_De_Couleur={360/$Nombre_De_Triangles}
 Angle_Artefacts=0
 Angle_Rayon_De_Couleur_Ref=0
 Angle_Rayon_De_Couleur_En_Cours=0
 Angle_Rayon_De_Couleur_En_Cours_Fin=0

 if $Nombre_De_Triangles==3 Rayon_De_Couleur={$Rayon_De_Couleur*3} endif

 if {$Nombre_De_Triangles-{$Rendu+2}}<0 Rendu={$Nombre_De_Triangles-2} endif

 if $Artefacts==-1 Angle_Artefacts={0.5-{0.1/$Nombre_De_Triangles}} else Angle_Artefacts=$Artefacts endif

 to_rgba[0]

 # 1 nouvelle images couleurs
 $Largeur_Origine,$Hauteur_Origine,1,3
 fill_color[-1] 0,0,0,255

 repeat $Nombre_De_Triangles

  if $Couleurs_aleatoires==1
   R_a={round(u)*255}
   V_a={round(u)*255}
   B_a={round(u)*255}
   R_b={round(u)*255}
   V_b={round(u)*255}
   B_b={round(u)*255}
   R_c={round(u)*255}
   V_c={round(u)*255}
   B_c={round(u)*255}
   R_d={round(u)*255}
   V_d={round(u)*255}
   B_d={round(u)*255}
   R_e={round(u)*255}
   V_e={round(u)*255}
   B_e={round(u)*255}
   R_f={round(u)*255}
   V_f={round(u)*255}
   B_f={round(u)*255}
   R_g={round(u)*255}
   V_g={round(u)*255}
   B_g={round(u)*255}
  endif

  if ($Nb_boucles%{$Rendu+2})==0
   Ra_en_cours=$R_Centre
   Va_en_cours=$V_Centre
   Ba_en_cours=$B_Centre
   Rb_en_cours=$R_a
   Vb_en_cours=$V_a
   Bb_en_cours=$B_a
   Rc_en_cours=$R_b
   Vc_en_cours=$V_b
   Bc_en_cours=$B_b

  endif
  if ($Nb_boucles%{$Rendu+2})==1
   Ra_en_cours=$R_Centre
   Va_en_cours=$V_Centre
   Ba_en_cours=$B_Centre
   Rb_en_cours=$R_b
   Vb_en_cours=$V_b
   Bb_en_cours=$B_b
   if {$Rendu==0}
    Rc_en_cours=$R_a
    Vc_en_cours=$V_a
    Bc_en_cours=$B_a
   else
    Rc_en_cours=$R_c
    Vc_en_cours=$V_c
    Bc_en_cours=$B_c
   endif
  endif
  if ($Nb_boucles%{$Rendu+2})==2&&$Rendu>0
   Ra_en_cours=$R_Centre
   Va_en_cours=$V_Centre
   Ba_en_cours=$B_Centre
   Rb_en_cours=$R_c
   Vb_en_cours=$V_c
   Bb_en_cours=$B_c
   if {$Rendu==1}
    Rc_en_cours=$R_a
    Vc_en_cours=$V_a
    Bc_en_cours=$B_a
   else
    Rc_en_cours=$R_d
    Vc_en_cours=$V_d
    Bc_en_cours=$B_d
   endif
  endif
  if ($Nb_boucles%{$Rendu+2})==3&&$Rendu>1
   Ra_en_cours=$R_Centre
   Va_en_cours=$V_Centre
   Ba_en_cours=$B_Centre
   Rb_en_cours=$R_d
   Vb_en_cours=$V_d
   Bb_en_cours=$B_d
   if {$Rendu==2}
    Rc_en_cours=$R_a
    Vc_en_cours=$V_a
    Bc_en_cours=$B_a
   else
    Rc_en_cours=$R_e
    Vc_en_cours=$V_e
    Bc_en_cours=$B_e
   endif
  endif
  if ($Nb_boucles%{$Rendu+2})==4&&$Rendu>2
   Ra_en_cours=$R_Centre
   Va_en_cours=$V_Centre
   Ba_en_cours=$B_Centre
   Rb_en_cours=$R_e
   Vb_en_cours=$V_e
   Bb_en_cours=$B_e
   if {$Rendu==3}
    Rc_en_cours=$R_a
    Vc_en_cours=$V_a
    Bc_en_cours=$B_a
   else
    Rc_en_cours=$R_f
    Vc_en_cours=$V_f
    Bc_en_cours=$B_f
   endif
  endif
  if ($Nb_boucles%{$Rendu+2})==5&&$Rendu>3
   Ra_en_cours=$R_Centre
   Va_en_cours=$V_Centre
   Ba_en_cours=$B_Centre
   Rb_en_cours=$R_f
   Vb_en_cours=$V_f
   Bb_en_cours=$B_f
   if {$Rendu==4}
    Rb_en_cours=$R_a
    Vb_en_cours=$V_a
    Bb_en_cours=$B_a
   else
    Rc_en_cours=$R_g
    Vc_en_cours=$V_g
    Bc_en_cours=$B_g
   endif
  endif

  if ($Nb_boucles%{$Rendu+2})==6&&$Rendu>4
   R_en_cours=$R_g
   V_en_cours=$V_g
   B_en_cours=$B_g

  endif

  Angle_Rayon_De_Couleur_Ref={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs+$Angle_Artefacts}
  if $Nb_boucles==0

  else

  endif

  Angle_Rayon_De_Couleur_En_Cours={$Angle_Rayon_De_Couleur_Ref-$Angle_Artefacts}
  Angle_Rayon_De_Couleur_En_Cours_Fin={$Angle_Rayon_De_Couleur_Ref+$Angle_Rayon_De_Couleur+$Angle_Artefacts}

  triangle_shade[-1] {$Position_Centre_X*$Largeur_Origine/100},{$Position_Centre_Y*$Hauteur_Origine/100},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*{$Angle_Rayon_De_Couleur_En_Cours}})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*{$Angle_Rayon_De_Couleur_En_Cours}})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*{$Angle_Rayon_De_Couleur_En_Cours_Fin}})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*{$Angle_Rayon_De_Couleur_En_Cours_Fin}})}}},$Ra_en_cours,$Va_en_cours,$Ba_en_cours,$Rb_en_cours,$Vb_en_cours,$Bb_en_cours,$Rc_en_cours,$Vc_en_cours,$Bc_en_cours

  Nb_boucles={$Nb_boucles+1}

 done

 if $Activer_Color_Balance==1
  fx_balance_gamma[-1] $R_Neutral_color,$V_Neutral_color,$B_Neutral_color,$Stretch_colors=$34
 endif

 if $Supprimer_Calque_Origine==1
  rm[0]
 else
  if $Activer_Melange==1
   if $Revert_layers==1
    rv[-1,-2]
   endif
   gimp_blend_1651[-2,-1] $Mode,0,$Opacity,0
  else
   rv[-1,-2]
  endif
 endif

#################################################
##                                             ##
##        FIN Triangles_Shades_Adjacents       ##
##                                             ##
#################################################
#################################################
##                                             ##
##                 Twisted_Rays                ##
##                                             ##
#################################################

# 2015/04/27 origine
# 2016/02/02 {round(u)*255}

#@gui Twisted Rays : Twisted_Rays, Twisted_Rays(1)
#@gui :_=note("<span foreground="orangered"><b>Image Finale</b></span>")
#@gui : Dimension En Pixels = int(800,256,1920)
#@gui : Supprimer Calque / Delete Layer = bool(1)
#@gui : Twirl = float(0.2,-5,5)
#@gui : Mélanges Rayons / Blend Rays = choice(2,"Add","And","Average","Darken","Difference","Edges","Grainextract","Grainmerge","Multiply","Negation","Or","Screen","Softburn","Softdodge","Subtract","Xor","- NON / NO -")
#@gui : Rendu = choice(5,"Rayons Couleurs AB","Rayons Couleurs ABC","Rayons Couleurs ABCD","Rayons Couleurs ABCDE","Rayons Couleurs ABCDEF","Rayons Couleurs ABCDEFG")
#@gui :_=note("<span foreground="orangered"><b>Rayons De Couleurs</b></span>")
#@gui : Nombre de Rayons / Number Of Rays = int(21,3,360)
#@gui : Angle Décalage Des Couleurs A / Offset  = float(0,-360,360)
#@gui : Angle Décalage Des Couleurs B / Offset  = float(0,-360,360)
#@gui : Couleur / Color A = color(0,0,255,255)
#@gui : Couleur / Color B = color(0,255,255,255)
#@gui : Couleur / Color C = color(0,255,0,255)
#@gui : Couleur / Color D = color(255,255,0,255)
#@gui : Couleur / Color E = color(255,0,0,255)
#@gui : Couleur / Color F = color(255,0,255,255)
#@gui : Couleur / Color G = color(255,255,255,255)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b>Contours</b></span>")
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(0)
#@gui : Dilate Contours = int(2,1,16)
#@gui : Flou / Blur Contours = float(2,0,5)
#@gui : Sharpen = int(0,200,400)
#@gui :_=note("<span foreground="orangered"><b>Symmetrizoscope</b></span>")
#@gui : Activer Symmetrizoscope = bool(0)
#@gui : Itérations = int(5,1,32)
#@gui : Angle = float(0,0,360)
#@gui : Symmetry sides = choice("Backward","Forward","Swap")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

Twisted_Rays:

 Dimension_Finale=$1
 Supprimer_Calque_Origine=$2
 Amplitude_Twirl=$3
 Melanges_Rayons=$4
 Rendu=$5

 Nb_De_Rayon_De_Couleur=$6
 Angle_Decalage_Couleurs_A=$7
 Angle_Decalage_Couleurs_B=$8

 R_a=$9
 V_a=$10
 B_a=$11
 A_a=$12

 R_b=$13
 V_b=$14
 B_b=$15
 A_b=$16

 R_c=$17
 V_c=$18
 B_c=$19
 A_c=$20

 R_d=$21
 V_d=$22
 B_d=$23
 A_d=$24

 R_e=$25
 V_e=$26
 B_e=$27
 A_e=$28

 R_f=$29
 V_f=$30
 B_f=$31
 A_f=$32

 R_g=$33
 V_g=$34
 B_g=$35
 A_g=$36

 Couleurs_aleatoires=$37

 R_Contours=$38
 V_Contours=$39
 B_Contours=$40
 A_Contours=$41

 Affichage_Contours=$42
 Dilate_Contours=$43
 Flou_Contours=$44
 Sharpen_Contours=$45

 Filtre_Symmetrizoscope=$46
 Iterations_Symmetrizoscope=$47
 Angle_Symmetrizoscope=$48
 Symmetry_Sides=$49

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Rayon_Cercle_Final={round({{$Dimension_Finale/2}-1})}
 Rayon_De_Couleur={round({1+{$Dimension_Finale*{2^0.5}}})}
 Angle_Rayon_De_Couleur={360/$Nb_De_Rayon_De_Couleur}
 Angle_Rayon_De_Couleur_En_Cours_A=0
 Angle_Rayon_De_Couleur_En_Cours_Fin_A=0
 Angle_Rayon_De_Couleur_En_Cours_B=0
 Angle_Rayon_De_Couleur_En_Cours_Fin_B=0
 R_en_cours=0
 V_en_cours=0
 B_en_cours=0
 A_en_cours=0

 if $Supprimer_Calque_Origine==1
  rm[0]
 endif

 # 2 nouvelles images contours
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0

 # 2 nouvelles images Rayons
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0
 repeat $Nb_De_Rayon_De_Couleur

  if $Couleurs_aleatoires==1
   R_a={round(u)*255}
   V_a={round(u)*255}
   B_a={round(u)*255}
   R_b={round(u)*255}
   V_b={round(u)*255}
   B_b={round(u)*255}
   R_c={round(u)*255}
   V_c={round(u)*255}
   B_c={round(u)*255}
   R_d={round(u)*255}
   V_d={round(u)*255}
   B_d={round(u)*255}
   R_e={round(u)*255}
   V_e={round(u)*255}
   B_e={round(u)*255}
   R_f={round(u)*255}
   V_f={round(u)*255}
   B_f={round(u)*255}
   R_g={round(u)*255}
   V_g={round(u)*255}
   B_g={round(u)*255}
  endif

  if ($Nb_boucles%{$Rendu+2})==0
   R_en_cours=$R_a
   V_en_cours=$V_a
   B_en_cours=$B_a
   A_en_cours=$A_a
  endif
  if ($Nb_boucles%{$Rendu+2})==1
   R_en_cours=$R_b
   V_en_cours=$V_b
   B_en_cours=$B_b
   A_en_cours=$A_b
  endif
  if ($Nb_boucles%{$Rendu+2})==2&&$Rendu>0
   R_en_cours=$R_c
   V_en_cours=$V_c
   B_en_cours=$B_c
   A_en_cours=$A_c
  endif
  if ($Nb_boucles%{$Rendu+2})==3&&$Rendu>1
   R_en_cours=$R_d
   V_en_cours=$V_d
   B_en_cours=$B_d
   A_en_cours=$A_d
  endif
  if ($Nb_boucles%{$Rendu+2})==4&&$Rendu>2
   R_en_cours=$R_e
   V_en_cours=$V_e
   B_en_cours=$B_e
   A_en_cours=$A_e
  endif
  if ($Nb_boucles%{$Rendu+2})==5&&$Rendu>3
   R_en_cours=$R_f
   V_en_cours=$V_f
   B_en_cours=$B_f
   A_en_cours=$A_f
  endif
  if ($Nb_boucles%{$Rendu+2})==6&&$Rendu>4
   R_en_cours=$R_g
   V_en_cours=$V_g
   B_en_cours=$B_g
   A_en_cours=$A_g
  endif

  Angle_Rayon_De_Couleur_En_Cours_A={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_A}
  Angle_Rayon_De_Couleur_En_Cours_Fin_A={{{$Nb_boucles+1}*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_A}
  Angle_Rayon_De_Couleur_En_Cours_B={{$Nb_boucles*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_B}
  Angle_Rayon_De_Couleur_En_Cours_Fin_B={{{$Nb_boucles+1}*$Angle_Rayon_De_Couleur}+$Angle_Decalage_Couleurs_B}
  polygon[-1] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_A})}}},1,$R_en_cours,$V_en_cours,$B_en_cours,$A_en_cours
  polygon[-2] 3,50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_Fin_B})}}},1,$R_en_cours,$V_en_cours,$B_en_cours,$A_en_cours

  if $Affichage_Contours==1
   line[-3] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_A})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
   line[-4] 50%,50%,{{{w}/2}+{$Rayon_De_Couleur*{cos({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},{{{h}/2}+{$Rayon_De_Couleur*{sin({pi/180*$Angle_Rayon_De_Couleur_En_Cours_B})}}},1,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  Nb_boucles={$Nb_boucles+1}

 done

 dilate_circ[-3,-4] 2

 twirl[-1,-3] $Amplitude_Twirl,50%,50%,0
 twirl[-2,-4] -$Amplitude_Twirl,50%,50%,0

 blend[-3,-4] alpha,1,0

 # contour cercle
 if $Affichage_Contours==1
  ellipse[-3] 50%,50%,$Rayon_Cercle_Final,$Rayon_Cercle_Final,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-3] 50%,50%,{$Rayon_Cercle_Final-1},{$Rayon_Cercle_Final-1},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-3] 50%,50%,{$Rayon_Cercle_Final-2},{$Rayon_Cercle_Final-2},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif
 if $Dilate_Contours>1 dilate_circ[-3] $Dilate_Contours endif
 if $Flou_Contours>0 blur[-3] $Flou_Contours,0 endif
 if $Sharpen_Contours>0 sharpen[-3] $Sharpen_Contours endif

 if $Filtre_Symmetrizoscope==1
  fx_symmetrizoscope[-1,-2,-3] $Iterations_Symmetrizoscope,$Angle_Symmetrizoscope,0,$Symmetry_Sides
 endif

 # creation masque temporaire rond
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 255,255,255,255
 circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,0
 # mélanges
 blend[-4,-1] alpha,1,0
 replace_color[-3] 100%,0,255,255,255,255,0,0,0,0 # blanc vers transparence

 # creation masque temporaire rond
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0
 circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
 # mélanges
 rv[-1,-3]
 blend[-3,-1] add,1,0

 # creation masque temporaire rond
 $Dimension_Finale,$Dimension_Finale,1,4
 fill_color[-1] 0,0,0,0
 circle[-1] 50%,50%,$Rayon_Cercle_Final,1,0,0,0,255
 # mélanges
 rv[-1,-2]
 blend[-2,-1] add,1,0

 if $Melanges_Rayons==0
  blend[-1,-2] add,1,0
 elif $Melanges_Rayons==1
  blend[-1,-2] and,1,0
 elif $Melanges_Rayons==2
  blend[-1,-2] average,1,0
 elif $Melanges_Rayons==3
  blend[-1,-2] darken,1,0
 elif $Melanges_Rayons==4
  blend[-1,-2] difference,1,0
 elif $Melanges_Rayons==5
  blend[-1,-2] edges,1,0
 elif $Melanges_Rayons==6
  blend[-1,-2] grainextract,1,0
 elif $Melanges_Rayons==7
  blend[-1,-2] grainmerge,1,0
 elif $Melanges_Rayons==8
  blend[-1,-2] multiply,1,0
 elif $Melanges_Rayons==9
  blend[-1,-2] negation,1,0
 elif $Melanges_Rayons==10
  blend[-1,-2] or,1,0
 elif $Melanges_Rayons==11
  blend[-1,-2] screen,1,0
 elif $Melanges_Rayons==12
  blend[-1,-2] softburn,1,0
 elif $Melanges_Rayons==13
  blend[-1,-2] softdodge,1,0
 elif $Melanges_Rayons==14
  blend[-1,-2] subtract,1,0
 elif $Melanges_Rayons==15
  blend[-1,-2] xor,1,0
 elif $Melanges_Rayons==16
  # Pas de mélange
 endif

 c[-1,-2] 0,255

 if $Supprimer_Calque_Origine==1
  if $Melanges_Rayons==16
   # Pas de mélange couleurs
   rv[-3,-2,-1]
  else
   # Mélange couleurs
   rv[-1,-2]
   blend[-1,-2] alpha,1,0
  endif
 else
  if $Melanges_Rayons==16
   # Pas de mélange couleurs
   rv[-3,-2,-1,0]
  else
   # Mélange couleurs
   rv[-1,-2]
   blend[-1,-2] alpha,1,0
   rv[0,-1]
  endif
 endif

#################################################
##                                             ##
##               FIN Twisted_Rays              ##
##                                             ##
#################################################
################################################################
##                                                            ##
##             Tracer des traits autour d'un point            ##
##                                                            ##
################################################################

# Idées générales
# Des segments partent d'un point. Ils sont définis par : les coordonnées du point origine, la longueur, les variations de longueur, le nombre, l'angle de départ, l'angle de fin, la couleur, les variations de couleur, une symétrie par rapport au point d'origine, % longueur symétrie.
# Version origine le 24 décembre 2012 , Joyeux Noël !
# Version 1.01 20121224
# version 1.02  abandon du "preview" avec : Traits_Strokes_samj(1)
# version 1.03 ajout Épaisseur / Thickness  = int(0,0,32)
# version 1.04 ajout éloignement
# 17 janvier 2014  modification blend
# 2014/04/24 blend
# 2014/07/03 modification gimp_blend
# 2015/03/15 menu , simplification , modification gimp_blend , dimensions fonction de W et H
# 2016/02/02 {round(u)*

#@gui Traits Strokes : Traits_Strokes_samj, Traits_Strokes_samj(1)
#@gui :_=separator()
#@gui :_=note("<small>Origine</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Traits / Strokes</small>")
#@gui : Longueur / Length (>0 %W) (<0 $H) = float(35,-400,400)
#@gui : Mode variations = choice(0,"Non / No","Plus / More","Moins / Less","Plus / More [milieu-middle]","Moins / Less [milieu-middle]")
#@gui : Variations % (Longueur/Length) = float(100,0,1000)
#@gui : Éloignement du centre / Distance from Center (>0 %W) (<0 $H) = float(0,-400,400)
#@gui : Nombre de traits / Number of strokes = int(30,1,2160)
#@gui : Angle (Départ / Start) = float(0,0,360)
#@gui : Angle (Fin / End) = float(360,0,360)
#@gui : Couleur/ Color= color(240,60,120,255)
#@gui : Variation de couleur / Color variation = choice("Pas de variation / No change","Couleurs aleatoires / Random Colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Épaisseur / Thickness  = int(0,0,32)
#@gui :_=separator()
#@gui :_=note("<small>Symétrie / Symmetry</small>")
#@gui : Symétrie / Symmetry = bool(0)
#@gui : Longueur / Length (%) = float(20,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Déformation = float(0,0,25)
#@gui :_=separator()
#@gui :_=note("<small>Mélange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

Traits_Strokes_samj:

####### Déclaration des variables
 Position_X={round({{w}*{$1/100}})}
 Position_Y={round({{h}*{$2/100}})}

  #Traits

 if $3>0
  Longueur={{w}*$3/{100}}
 else
  Longueur={-{h}*$3/{100}}
 endif
 Variations_Formes=$4
 Variations_Longueur=$5
 if $6>0
  Eloignement_du_centre={{w}*$6/{100}}
 else
  Eloignement_du_centre={-{h}*$6/{100}}
 endif
 Nombre_de_traits=$7
 Angle_Depart=$8
 Angle_Fin=$9
 R_Couleur=$10
 V_Couleur=$11
 B_Couleur=$12
 A_Couleur=$13
 Variation_de_couleur=$14
 Epaisseur=$15

  #Symétrie

 Symetrie=$16
 Pourcent_Longueur_Sym=$17

  #Divers

 Flou_traits=$18
 Spread_traits=$19
 Deform_traits=$20

 blend=$21
 opacite=$22

 Revert_layers=0

####### Ligne de commandes

 to_rgba

 {w},{h},1,4  ## créer une image transparente aux mêmes dimensions que l'image d'origine

 Angle=$Angle_Depart

 if $Angle_Depart>$Angle_Fin
  Angle_Fin={$Angle_Fin+360}
 endif

 increment_theta={{$Angle_Fin-$Angle_Depart}/$Nombre_de_traits}

 if $Variations_Formes==1
  Variation={{$Longueur/100*$Variations_Longueur}/$Nombre_de_traits}
 endif

 if $Variations_Formes==2
  Variation={{-$Longueur/1000*$Variations_Longueur}/$Nombre_de_traits}
 endif

 if $Variations_Formes==3
  Variation={{$Longueur/100*$Variations_Longueur}/{$Nombre_de_traits/2}}
 endif

 if $Variations_Formes==4
  Variation={{-$Longueur/1000*$Variations_Longueur}/{$Nombre_de_traits/2}}
 endif

 Longueur_calculee=$Longueur
 Nb_Boucle=1

 R_Couleur_origine=$R_Couleur
 V_Couleur_origine=$V_Couleur
 B_Couleur_origine=$B_Couleur
 A_Couleur_origine=$A_Couleur

 repeat $Nombre_de_traits

  if $Variation_de_couleur==1
    R_Couleur={round(u)*255}
    V_Couleur={round(u)*255}
    B_Couleur={round(u)*255}
    A_Couleur={{round(u)*200}+55}
  endif

  ## couleurs nuancées
  if $Variation_de_couleur>1

   Valeur_variation_couleur=16

   if $Variation_de_couleur==3
    Valeur_variation_couleur=32
   endif

   if $Variation_de_couleur==4
    Valeur_variation_couleur=64
   endif

   R_Couleur={round({$R_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
    if $R_Couleur>255
      R_Couleur=$R_Couleur_origine
    endif
    if $R_Couleur<0
      R_Couleur=$R_Couleur_origine
    endif

   V_Couleur={round({$V_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
    if $V_Couleur>255
      V_Couleur=$V_Couleur_origine
    endif
    if $V_Couleur<0
      V_Couleur=$V_Couleur_origine
    endif

   B_Couleur={round({$B_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
    if $B_Couleur>255
      B_Couleur=$B_Couleur_origine
    endif
    if $B_Couleur<0
      B_Couleur=$B_Couleur_origine
    endif

  endif

  Debut_X={$Position_X+{round(cos(pi/180*$Angle)*$Eloignement_du_centre)}}
  Debut_Y={$Position_Y+{round(sin(pi/180*$Angle)*$Eloignement_du_centre)}}

  Extremite_X={$Position_X+{round(cos(pi/180*$Angle)*{$Longueur_calculee+$Eloignement_du_centre})}}
  Extremite_Y={$Position_Y+{round(sin(pi/180*$Angle)*{$Longueur_calculee+$Eloignement_du_centre})}}

  line[-1] $Debut_X,$Debut_Y,$Extremite_X,$Extremite_Y,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur

  if $Symetrie==1

    Debut_X={$Position_X+{round(cos(pi/180*{$Angle+180})*$Eloignement_du_centre)}}
    Debut_Y={$Position_Y+{round(sin(pi/180*{$Angle+180})*$Eloignement_du_centre)}}

    Extremite_X={$Position_X+{round(cos(pi/180*{$Angle+180})*{{$Longueur_calculee/100*$Pourcent_Longueur_Sym}+$Eloignement_du_centre})}}
    Extremite_Y={$Position_Y+{round(sin(pi/180*{$Angle+180})*{{$Longueur_calculee/100*$Pourcent_Longueur_Sym}+$Eloignement_du_centre})}}

    line[-1] $Debut_X,$Debut_Y,$Extremite_X,$Extremite_Y,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur

  endif

  Angle={$Angle+$increment_theta}

   if $Variations_Formes==1||$Variations_Formes==2
    Longueur_calculee={$Longueur_calculee+$Variation}
   endif

   if $Variations_Formes==3||$Variations_Formes==4
    if $Nb_Boucle<{$Nombre_de_traits/2}
     Longueur_calculee={$Longueur_calculee+$Variation}
    else
     Longueur_calculee={$Longueur_calculee-$Variation}
    endif
   endif

  Nb_Boucle={$Nb_Boucle+1}

 done

 if $Epaisseur>0
  dilate_circ[-1] $Epaisseur
 endif

 blur[-1] $Flou_traits

 spread[-1] $Spread_traits

 deform[-1] $Deform_traits

 gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1 # alpha

################################################################
##                                                            ##
##         FIN    Tracer des traits autour d'un point         ##
##                                                            ##
################################################################
#################################################
##                                             ##
##           Egg_Oeuf_Hugelschaffer            ##
##                                             ##
#################################################

# 2014/04/24 blend
# modification 2014/03/28 interpolation rotate[-1]
# origine 2014/03/25
# 2015/03/14 menu
# 2016/02/02 {round(u)*255}

#@gui Egg Oeuf Hugelschaffer : samj_Egg_Oeuf_Hugelschaffer, samj_Egg_Oeuf_Hugelschaffer(1)
#@gui :_=link("http://www.mathcurve.com/courbes2d/oeuf/oeuf.shtml","http://www.mathcurve.com/courbes2d/oeuf/oeuf.shtml")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Dimension = float(50,0,100)
#@gui : Valeur A Forme = float(6,0,10)
#@gui : Valeur B Forme = float(48,0,100)
#@gui : Valeur D Forme = float(0,0,24)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Egg Oeuf","Egg Oeuf CA CB")
#@gui : Couleur = color(255,255,0,127)
#@gui : Couleur aléatoire / Random color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation Décalage Ombre X = float(0,-20,20)
#@gui : Compensation Décalage Ombre Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_Egg_Oeuf_Hugelschaffer :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Dimension={round({{min({w},{h})}*$3/5000})}
 Valeur_A=$4
 Valeur_B=$5
 Valeur_D=$6
 Angle_Rotation=$7

 R_Contours=$8
 V_Contours=$9
 B_Contours=$10
 A_Contours=$11

 Affichage_Contours=$12

 R_a=$13
 V_a=$14
 B_a=$15
 A_a=$16

 Couleurs_aleatoires=$17
 Inversions=$18
 Flou=$19
 Dilatation=$20
 Deformation=$21
 Bruit=$22
 Ombre=$23
 X_Ombre=$24
 Y_Ombre=$25
 Smoothness_Ombre=$26
 Curvature_Ombre=$27
 Compensation_Decalage_Ombre_X=$28
 Compensation_Decalage_Ombre_Y=$29
 Canal_Alpha=$30

 Resolution=720

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Angle=0

 X_Oeuf_A_Imprimer=0
 Y_Oeuf_A_Imprimer=0
 X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{{{{$Valeur_A*$Valeur_A}-{$Valeur_D*$Valeur_D*{sin({pi/180*$Angle})}*{sin({pi/180*$Angle})}}^0.5}+{$Valeur_D*{cos({pi/180*$Angle})}}}*{cos({pi/180*$Angle})}}}}
 Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{$Valeur_B*{sin({pi/180*$Angle})}}}}

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 if $Couleurs_aleatoires==1
  R_a={round(u)*255}
  V_a={round(u)*255}
  B_a={round(u)*255}
 endif

 if $Affichage_Contours==2
  ellipse[-2] $X,$Y,{$Dimension*$Valeur_A},{$Dimension*$Valeur_A},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-2] $X,$Y,{$Dimension*$Valeur_B},{$Dimension*$Valeur_B},0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 repeat $Resolution
  Nb_boucles={$Nb_boucles+1}
  Angle={$Nb_boucles*{360/$Resolution}}

  X_Oeuf_A_Imprimer={$X+{$Dimension*{{{{$Valeur_A*$Valeur_A}-{$Valeur_D*$Valeur_D*{sin({pi/180*$Angle})}*{sin({pi/180*$Angle})}}^0.5}+{$Valeur_D*{cos({pi/180*$Angle})}}}*{cos({pi/180*$Angle})}}}}
  Y_Oeuf_A_Imprimer={$Y+{$Dimension*{$Valeur_B*{sin({pi/180*$Angle})}}}}

  polygon[-1] 3,$X,$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a

  if $Affichage_Contours>0
   line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
  Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
 done

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 if $Angle_Rotation>0 rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##          FIN Egg_Oeuf_Hugelschaffer         ##
##                                             ##
#################################################
#################################################
##                                             ##
##             Egg_Oeuf_Granville              ##
##                                             ##
#################################################

# 2014/04/24 blend
# modification 2014/03/28 interpolation rotate[-1]
# origine 2014/03/26
# voir si Decalage_X utile
# 2015/03/14 menu
# 2016/02/02 {round(u)*255}

#@gui Egg Oeuf Granville : samj_Egg_Oeuf_Granville, samj_Egg_Oeuf_Granville(1)
#@gui :_=link("http://en.wikipedia.org/wiki/William_Anthony_Granville","http://en.wikipedia.org/wiki/William_Anthony_Granville")
#@gui :_=link("http://www.mathcurve.com/courbes2d/oeuf/oeufgranville.shtml","http://www.mathcurve.com/courbes2d/oeuf/oeufgranville.shtml")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Décalage X = float(0,-100,100)
#@gui : Valeur A Forme = float(20,0,100)
#@gui : Valeur B Forme = float(30,1,100)
#@gui : Valeur R Forme = float(10,0.1,99)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Egg Oeuf","Egg Oeuf CA CB CR")
#@gui : Couleur = color(255,255,0,127)
#@gui : Couleur aléatoire / Random color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation Décalage Ombre X = float(0,-50,50)
#@gui : Compensation Décalage Ombre Y = float(0,-50,50)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_Egg_Oeuf_Granville :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Decalage_X={round({{min({w},{h})}*$3/100})}
 Valeur_A={round({{min({w},{h})}*$4/40})}
 Valeur_B={round({{min({w},{h})}*$5/40})}
 Valeur_R={round({{min({w},{h})}*$6/40})}
 Angle_Rotation=$7

 R_Contours=$8
 V_Contours=$9
 B_Contours=$10
 A_Contours=$11

 Affichage_Contours=$12

 R_a=$13
 V_a=$14
 B_a=$15
 A_a=$16

 Couleurs_aleatoires=$17
 Inversions=$18
 Flou=$19
 Dilatation=$20
 Deformation=$21
 Bruit=$22
 Ombre=$23
 X_Ombre=$24
 Y_Ombre=$25
 Smoothness_Ombre=$26
 Curvature_Ombre=$27
 Compensation_Decalage_Ombre_X=$28
 Compensation_Decalage_Ombre_Y=$29
 Canal_Alpha=$30

 Resolution=720

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Angle=0

 X_Oeuf_A_Imprimer=0
 Y_Oeuf_A_Imprimer=0
 # X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{     }}}
 # Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{     }}}
 X_Oeuf_A_Imprimer_Precedent={{$X-{$Valeur_B+{$Valeur_R/2}}}+{$Decalage_X+{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}
 Y_Oeuf_A_Imprimer_Precedent={$Y+{{{$Valeur_A*$Valeur_R*{sin({pi/180*$Angle})}}/{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}}

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 if $Couleurs_aleatoires==1
  R_a={round(u)*255}
  V_a={round(u)*255}
  B_a={round(u)*255}
 endif

 if $Affichage_Contours==2
  ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_B,$Valeur_B,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-2] {$X+$Decalage_X},$Y,$Valeur_R,$Valeur_R,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 repeat $Resolution
  Nb_boucles={$Nb_boucles+1}
  Angle={$Nb_boucles*{360/$Resolution}}

  X_Oeuf_A_Imprimer={{$X-{$Valeur_B+{$Valeur_R/2}}}+{$Decalage_X+{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}
  Y_Oeuf_A_Imprimer={$Y+{{{$Valeur_A*$Valeur_R*{sin({pi/180*$Angle})}}/{$Valeur_B+{$Valeur_R*{cos({pi/180*$Angle})}}}}}}

  polygon[-1] 3,{$X+$Decalage_X},$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a

  if $Affichage_Contours>0
   line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
  Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
 done

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 if $Angle_Rotation>0 rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##            FIN Egg_Oeuf_Granville           ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Egg_Oeuf_Rosillo              ##
##                                             ##
#################################################

# 2014/04/24 blend
# 2015/03/14 menu
# 2016/02/02 {round(u)*255}

#@gui Egg Oeuf Rosillo : samj_Egg_Oeuf_Rosillo, samj_Egg_Oeuf_Rosillo(1)
#@gui :_=link("http://www.mathcurve.com/courbes2d/rosillo/rosillo.shtml","http://www.mathcurve.com/courbes2d/rosillo/rosillo.shtml")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Valeur A Dimension = float(40,0,100)
#@gui : Valeur B Forme 200%A = float(200,0,400)
#@gui : Valeur C Forme 300%A = float(300,0,400)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Egg Oeuf","Egg Oeuf CA CB CC")
#@gui : Couleur = color(255,255,0,127)
#@gui : Couleur aléatoire / Random color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation Décalage Ombre X = float(0,-50,50)
#@gui : Compensation Décalage Ombre Y = float(0,-50,50)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_Egg_Oeuf_Rosillo :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Valeur_A={round({{{w}+{h}}*$3/200})}
 Valeur_B={$Valeur_A*$4/100}
 Valeur_C={$Valeur_A*$5/100}
 Angle_Rotation=$6

 R_Contours=$7
 V_Contours=$8
 B_Contours=$9
 A_Contours=$10

 Affichage_Contours=$11

 R_a=$12
 V_a=$13
 B_a=$14
 A_a=$15

 Couleurs_aleatoires=$16
 Inversions=$17
 Flou=$18
 Dilatation=$19
 Deformation=$20
 Bruit=$21
 Ombre=$22
 X_Ombre=$23
 Y_Ombre=$24
 Smoothness_Ombre=$25
 Curvature_Ombre=$26
 Compensation_Decalage_Ombre_X=$27
 Compensation_Decalage_Ombre_Y=$28
 Canal_Alpha=$29

 Resolution=720

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Angle=0

 X_Oeuf_A_Imprimer=0
 Y_Oeuf_A_Imprimer=0
 # X_Oeuf_A_Imprimer_Precedent={$X+{$Dimension*{     }}}
 # Y_Oeuf_A_Imprimer_Precedent={$Y+{$Dimension*{     }}}
 X_Oeuf_A_Imprimer_Precedent={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
 Y_Oeuf_A_Imprimer_Precedent={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 if $Couleurs_aleatoires==1
  R_a={round(u)*255}
  V_a={round(u)*255}
  B_a={round(u)*255}
 endif

 if $Affichage_Contours==2
  ellipse[-2] $X,$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-2] $X,$Y,$Valeur_B,$Valeur_B,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-2] $X,$Y,$Valeur_C,$Valeur_C,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 repeat $Resolution
  Nb_boucles={$Nb_boucles+1}
  Angle={$Nb_boucles*{360/$Resolution}}

  X_Oeuf_A_Imprimer={$X+{$Valeur_A*{cos({pi/180*$Angle})}}}
  Y_Oeuf_A_Imprimer={$Y+{{$Valeur_B-{$Valeur_A*{cos({pi/180*$Angle})}}}/{$Valeur_C-{$Valeur_A*{cos({pi/180*$Angle})}}}*{$Valeur_A*{sin({pi/180*$Angle})}}}}

  polygon[-1] 3,$X,$Y,$X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a

  if $Affichage_Contours>0
   line[-2] $X_Oeuf_A_Imprimer_Precedent,$Y_Oeuf_A_Imprimer_Precedent,$X_Oeuf_A_Imprimer,$Y_Oeuf_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  X_Oeuf_A_Imprimer_Precedent=$X_Oeuf_A_Imprimer
  Y_Oeuf_A_Imprimer_Precedent=$Y_Oeuf_A_Imprimer
 done

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 if $Angle_Rotation>0 rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##              FIN Egg_Oeuf_Rosillo           ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Poisson_D_Avril               ##
##                                             ##
#################################################

# 2014/04/24 blend
# 2015/03/14 menu
# 2016/02/02 {round(u)*255}

#@gui Poisson D'Avril : samj_Poisson_D_Avril, samj_Poisson_D_Avril(1)
#@gui :_=link("http://www.mathcurve.com/courbes2d/poisson/poisson.shtml","http://www.mathcurve.com/courbes2d/poisson/poisson.shtml")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Valeur A Dimension = float(40,1,100)
#@gui : Valeur K = float(2,0,4)
#@gui : Angle Inclinaison = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(1,"Sans","Poisson","Poisson CA")
#@gui : Couleur A = color(250,60,10,255)
#@gui : Couleur B = color(255,255,255,255)
#@gui : Couleur aléatoire / Random color = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre = bool(0)
#@gui : X-Ombre = float(0.5,-5,5)
#@gui : Y-Ombre = float(0.5,-5,5)
#@gui : Douceur / Smoothness Ombre = float(1.8,0,5)
#@gui : Courbure / Curvature Ombre = float(0,0,1)
#@gui : Compensation Décalage Ombre X = float(0,-50,50)
#@gui : Compensation Décalage Ombre Y = float(0,-50,50)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_Poisson_D_Avril :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Valeur_A={round({{{w}+{h}}*$3/500})}
 Valeur_K=$4
 Angle_Rotation=$5

 R_Contours=$6
 V_Contours=$7
 B_Contours=$8
 A_Contours=$9

 Affichage_Contours=$10

 R_a=$11
 V_a=$12
 B_a=$13
 A_a=$14

 R_b=$15
 V_b=$16
 B_b=$17
 A_b=$18

 Couleurs_aleatoires=$19
 Inversions=$20
 Flou=$21
 Dilatation=$22
 Deformation=$23
 Bruit=$24
 Ombre=$25
 X_Ombre=$26
 Y_Ombre=$27
 Smoothness_Ombre=$28
 Curvature_Ombre=$29
 Compensation_Decalage_Ombre_X=$30
 Compensation_Decalage_Ombre_Y=$31
 Canal_Alpha=$32

 Resolution=720

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Angle=0

 X_Poisson_A_Imprimer=0
 Y_Poisson_A_Imprimer=0

 X_Poisson_A_Imprimer_Precedent={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
 Y_Poisson_A_Imprimer_Precedent={$Y+{$Valeur_A*{sin({pi/180*$Angle})}}}

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 if $Affichage_Contours==2
  ellipse[-2] $X,$Y,$Valeur_A,$Valeur_A,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 if $Couleurs_aleatoires==1
  R_a={round(u)*255}
  V_a={round(u)*255}
  B_a={round(u)*255}
 endif

 repeat $Resolution
  Nb_boucles={$Nb_boucles+1}
  Angle={$Nb_boucles*{360/$Resolution}}

  X_Poisson_A_Imprimer={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
  Y_Poisson_A_Imprimer={$Y+{$Valeur_A*{sin({pi/180*$Angle})}}}

  polygon[-1] 3,{$X-{2*$Valeur_A}},$Y,$X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,$R_a,$V_a,$B_a,$A_a

  if $Affichage_Contours>0
   line[-2] $X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  X_Poisson_A_Imprimer_Precedent=$X_Poisson_A_Imprimer
  Y_Poisson_A_Imprimer_Precedent=$Y_Poisson_A_Imprimer
 done

 Nb_boucles=0
 Angle=0

 X_Poisson_A_Imprimer_Precedent={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
 Y_Poisson_A_Imprimer_Precedent={$Y-{$Valeur_A*{sin({pi/180*$Angle})}}}

 if $Couleurs_aleatoires==1
  R_b={round(u)*255}
  V_b={round(u)*255}
  B_b={round(u)*255}
 endif

 repeat $Resolution
  Nb_boucles={$Nb_boucles+1}
  Angle={$Nb_boucles*{360/$Resolution}}

  X_Poisson_A_Imprimer={{$X-$Valeur_A}+{$Valeur_A*{{cos({pi/180*$Angle})}+{$Valeur_K*{cos({pi/180*{$Angle/2}})}}}}}
  Y_Poisson_A_Imprimer={$Y-{$Valeur_A*{sin({pi/180*$Angle})}}}

  polygon[-1] 3,{$X-{2*$Valeur_A}},$Y,$X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,$R_b,$V_b,$B_b,$A_b

  if $Affichage_Contours>0
   line[-2] $X_Poisson_A_Imprimer_Precedent,$Y_Poisson_A_Imprimer_Precedent,$X_Poisson_A_Imprimer,$Y_Poisson_A_Imprimer,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  X_Poisson_A_Imprimer_Precedent=$X_Poisson_A_Imprimer
  Y_Poisson_A_Imprimer_Precedent=$Y_Poisson_A_Imprimer
 done

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 if $Angle_Rotation>0 rotate[-1] $Angle_Rotation,1,0,{{w}/2},{{h}/2} endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##              FIN Poisson_D_Avril            ##
##                                             ##
#################################################
################################################################
##                                                            ##
##                         Spirographe                        ##
##                                                            ##
################################################################

# version origine du 25 décembre 2012, Joyeux Noël !
# version 1.03  abandon du "preview" avec : Spirographe_samj(1)
# version 1.04  ajout dilate_circ
# à voir Harmonograph Pintograph
# 17 janvier 2014  modification blend , ajout
# 2014/04/24 blend
# 2014/07/03 modification gimp_blend
# 2015/03/14 menu , gimp_blend , filtres utilisés en fonction pour version stable simplifiée , Nombre_de_tours float à la place de int
# 2015/03/15 Rayon_1 , Rayon_2 ,Position_Stylo =  fonction de W  et H
# 2016/02/02 {round(u)*255}

#@gui Spirographe : Spirographe_samj, Spirographe_samj(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Spirograph")
#@gui :_=separator()
#@gui :_=note("<small>Centre / Center</small>")
#@gui : Centre / Center X (%) = float(50,0,100)
#@gui : Centre / Center Y (%) = float(50,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Spirographe</small>")
#@gui : Rayon/Radius R (>0 W) (<0 H) = float(200,-500,500)
#@gui : Rayon/Radius r (>0 W) (<0 H) = float(50,-500,500)
#@gui : Stylo / Pen (Position) (>0 W) (<0 H) = float(150,-500,500)
#@gui : Stylo / Pen (Couleur/Color) = color(192,128,64,255)
#@gui : Stylo / Pen (Variation de couleur/Color variation) = choice("Pas de variation / No change","Couleurs aleatoires / Random Colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Stylo / Pen (Dilate Pixels)  = int(0,0,32)
#@gui : Nombre de tours / Number of turns = float(3,0.01,20)
#@gui : Multiplier  = choice(0,"Tours / Turns * 1","Tours / Turns * 10 LENT / SLOW","Tours / Turns * 100 TRES LENT / VERY SLOW")
#@gui : Incrément angulaire / Angular increment (Degrés) = float(1,1,360)
#@gui : Diviser / Divide = choice(0,"Increment angulaire-Angular increment / 1","Increment angulaire-Angular increment /10 LENT / SLOW","Increment angulaire-Angular increment /100 TRES LENT / VERY SLOW")
#@gui : Type de rendu / Rendering type = choice("Formule/Formula 1","Formule/Formula 2","Formule/Formula 3","Formule/Formula 4","Formule/Formula 5","Formule/Formula 6","Formule/Formula 7","Formule/Formula 8")
#@gui : Points (Rayon/Radius) = int(0,0,32)
#@gui : Points (Couleur/Color) = color(255,0,0,255)
#@gui : Lignes (Épaisseur/Thickness) = int(0,0,32)
#@gui : Lignes (Couleur/Color) = color(255,255,0,255)
#@gui :_=separator()
#@gui :_=note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Déformation = float(0,0,25)
#@gui :_=separator()
#@gui :_=note("<small>Mélange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

Spirographe_samj :

 centre_origine_X={$1/100*w}
 centre_origine_Y={$2/100*h}
   ## Spirographe
 if $3>0
  Rayon_1={{w}*$3/{1000}}
 else
  Rayon_1={-{h}*$3/{1000}}
 endif
 if $4>0
  Rayon_2={{w}*$4/{1000}}
 else
  Rayon_2={-{h}*$4/{1000}}
 endif
 if $5>0
  Position_Stylo={{w}*$5/{1000}}
 else
  Position_Stylo={-{h}*$5/{1000}}
 endif
 R_Couleur_Stylo=$6
 V_Couleur_Stylo=$7
 B_Couleur_Stylo=$8
 A_Couleur_Stylo=$9
 Variation_de_couleur=$10
 Dilate_Stylo=$11
 Nombre_de_tours=$12
 Multiplier_tours=$13
 Increment_angulaire=$14
 Diviser_Increment_angulaire=$15
 Type_de_rendu=$16
 Points_Rayon=$17
 R_Couleur_Points=$18
 V_Couleur_Points=$19
 B_Couleur_Points=$20
 A_Couleur_Points=$21
 Lignes_epaisseur=$22
 R_Couleur_Lignes=$23
 V_Couleur_Lignes=$24
 B_Couleur_Lignes=$25
 A_Couleur_Lignes=$26

   ## divers
 Flou_Spirographe=$27
 Spread_Spirographe=$28
 Deform_Spirographe=$29

 blend=$30
 opacite=$31
 Revert_layers=0

####### Ligne de commandes

 to_rgba
 {w},{h},1,4  ## créer une image transparente aux mêmes dimensions que l'image d'origine
 Nb_Boucle=1
 theta=0
 Ancien_point_X=0
 Nouveau_point_X=0
 Ancien_point_Y=0
 Nouveau_point_Y=0
 if $Rayon_2==0
  Rayon_2=1
 endif
 if $Multiplier_tours==1
  Nombre_de_tours={$Nombre_de_tours*10}
 endif
 if $Multiplier_tours==2
  Nombre_de_tours={$Nombre_de_tours*100}
 endif
 if $Diviser_Increment_angulaire==1
  Increment_angulaire={$Increment_angulaire/10}
 endif
 if $Diviser_Increment_angulaire==2
  Increment_angulaire={$Increment_angulaire/100}
 endif
 Nombre_de_tours={$Nombre_de_tours/$Increment_angulaire*360}
 R_Couleur_origine=$R_Couleur_Stylo
 V_Couleur_origine=$V_Couleur_Stylo
 B_Couleur_origine=$B_Couleur_Stylo
 A_Couleur_origine=$A_Couleur_Stylo
 if $Dilate_Stylo>0 # 2 étapes "lignes+dilate" puis "traits-points"
  repeat $Nombre_de_tours # tracer la ligne
   if $Variation_de_couleur==1
     R_Couleur_Stylo={round(u)*255}
     V_Couleur_Stylo={round(u)*255}
     B_Couleur_Stylo={round(u)*255}
     ##A_Couleur_Stylo={{round({(u(200))})}+55}
   endif
   ## couleurs nuancées
   if $Variation_de_couleur>1
    Valeur_variation_couleur=16
    if $Variation_de_couleur==3
     Valeur_variation_couleur=32
    endif
    if $Variation_de_couleur==4
     Valeur_variation_couleur=64
    endif
    R_Couleur_Stylo={round({$R_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
     if $R_Couleur_Stylo>255
       R_Couleur_Stylo=$R_Couleur_origine
     endif
     if $R_Couleur_Stylo<0
       R_Couleur_Stylo=$R_Couleur_origine
     endif
    V_Couleur_Stylo={round({$V_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
     if $V_Couleur_Stylo>255
       V_Couleur_Stylo=$V_Couleur_origine
     endif
     if $V_Couleur_Stylo<0
       V_Couleur_Stylo=$V_Couleur_origine
     endif
    B_Couleur_Stylo={round({$B_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
     if $B_Couleur_Stylo>255
       B_Couleur_Stylo=$B_Couleur_origine
     endif
     if $B_Couleur_Stylo<0
       B_Couleur_Stylo=$B_Couleur_origine
     endif
   endif
    ## Mode
    if $Type_de_rendu==0
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==1
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif

    if $Type_de_rendu==2
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==3
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==4
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==5
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==6
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==7
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    ## Tracer
    if $Nb_Boucle>1
     line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
    endif
   Ancien_point_X=$Nouveau_point_X
   Ancien_point_Y=$Nouveau_point_Y
   theta={$theta+$Increment_angulaire}
   Nb_Boucle={$Nb_Boucle+1}
  done
  dilate_circ[-1] $Dilate_Stylo
  Nb_Boucle=1
  theta=0
  Ancien_point_X=0
  Nouveau_point_X=0
  Ancien_point_Y=0
  Nouveau_point_Y=0
  if $Lignes_epaisseur>0||$Points_Rayon>0
   repeat $Nombre_de_tours # tracer les points et traits
    ## Mode
    if $Type_de_rendu==0
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==1
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==2
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==3
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==4
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==5
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==6
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==7
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    ## Tracer
    if $Nb_Boucle>1
     if $Lignes_epaisseur>0
      if $Points_Rayon>0
       circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
      endif
      trait_epais_samj $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,$Lignes_epaisseur,1,$R_Couleur_Lignes,$V_Couleur_Lignes,$B_Couleur_Lignes,$A_Couleur_Lignes
      if $Points_Rayon>0
       circle[-1] $Nouveau_point_X,$Nouveau_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
      endif
     endif
     if $Points_Rayon>0
      if $Variation_de_couleur==1
        R_Couleur_Points={round(u)*255}
        V_Couleur_Points={round(u)*255}
        B_Couleur_Points={round(u)*255}
      ##A_Couleur_Points={{round({(u(200))})}+55}
      endif
      circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
     endif
    endif
    Ancien_point_X=$Nouveau_point_X
    Ancien_point_Y=$Nouveau_point_Y
    theta={$theta+$Increment_angulaire}
    Nb_Boucle={$Nb_Boucle+1}
   done
  endif
 else
  repeat $Nombre_de_tours
   if $Variation_de_couleur==1
     R_Couleur_Stylo={round(u)*255}
     V_Couleur_Stylo={round(u)*255}
     B_Couleur_Stylo={round(u)*255}
     ##A_Couleur_Stylo={{round({(u(200))})}+55}
   endif
   ## couleurs nuancées
   if $Variation_de_couleur>1
    Valeur_variation_couleur=16
    if $Variation_de_couleur==3
     Valeur_variation_couleur=32
    endif
    if $Variation_de_couleur==4
     Valeur_variation_couleur=64
    endif
    R_Couleur_Stylo={round({$R_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
     if $R_Couleur_Stylo>255
       R_Couleur_Stylo=$R_Couleur_origine
     endif
     if $R_Couleur_Stylo<0
       R_Couleur_Stylo=$R_Couleur_origine
     endif
    V_Couleur_Stylo={round({$V_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
     if $V_Couleur_Stylo>255
       V_Couleur_Stylo=$V_Couleur_origine
     endif
     if $V_Couleur_Stylo<0
       V_Couleur_Stylo=$V_Couleur_origine
     endif
    B_Couleur_Stylo={round({$B_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
     if $B_Couleur_Stylo>255
       B_Couleur_Stylo=$B_Couleur_origine
     endif
     if $B_Couleur_Stylo<0
       B_Couleur_Stylo=$B_Couleur_origine
     endif
   endif
    ## Mode
    if $Type_de_rendu==0
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==1
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==2
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif

    if $Type_de_rendu==3
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1+$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1+$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==4
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==5
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1-$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==6
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{{$Rayon_2+$Position_Stylo}*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    if $Type_de_rendu==7
     Nouveau_point_X={$centre_origine_X+{{{$Rayon_1-$Rayon_2}*{cos(pi/180*$theta)}}-{$Position_Stylo*{cos({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
     Nouveau_point_Y={$centre_origine_Y+{{{$Rayon_1-$Rayon_2}*{sin(pi/180*$theta)}}-{$Position_Stylo*{sin({{$Rayon_1+$Rayon_2}/$Rayon_2}*{pi/180*$theta})}}}}
    endif
    ## Tracer
    if $Nb_Boucle>1
     if $Lignes_epaisseur>0
      if $Points_Rayon>0
       circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
      endif
      trait_epais_samj $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,$Lignes_epaisseur,1,$R_Couleur_Lignes,$V_Couleur_Lignes,$B_Couleur_Lignes,$A_Couleur_Lignes
      if $Points_Rayon>0
       circle[-1] $Nouveau_point_X,$Nouveau_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
      endif
     endif
     if $Lignes_epaisseur<1
      line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
     endif
     if $Points_Rayon>0
      if $Variation_de_couleur==1
        R_Couleur_Points={round(u)*255}
        V_Couleur_Points={round(u)*255}
        B_Couleur_Points={round(u)*255}
        ##A_Couleur_Points={{round({(u(200))})}+55}
      endif
      circle[-1] $Ancien_point_X,$Ancien_point_Y,$Points_Rayon,1,$R_Couleur_Points,$V_Couleur_Points,$B_Couleur_Points,$A_Couleur_Points
     endif
    endif
   Ancien_point_X=$Nouveau_point_X
   Ancien_point_Y=$Nouveau_point_Y
   theta={$theta+$Increment_angulaire}
   Nb_Boucle={$Nb_Boucle+1}
  done

 endif
 if $Flou_Spirographe>0 blur[-1] $Flou_Spirographe,0 endif
 if $Spread_Spirographe>1 spread[-1] $Spread_Spirographe endif
 if $Deform_Spirographe>0 deform[-1] $Deform_Spirographe endif
 gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1 # alpha

################################################################
##                                                            ##
##                     FIN  Spirographe                       ##
##                                                            ##
################################################################
################################################################
##                                                            ##
##                        Harmonograph                        ##
##                                                            ##
################################################################

# gmic -m samj.gmic 800,800,1,4 fill_color[-1] 0,0,0,255 Harmonograph_samj 50,50,255,128,64,255,0,0,1000,0,400,75,150,125,50,4,6,4,10,15,360,0,0,0,0,0,0.0515873,0,0,0,27,1,0 o Harmonograph.png
# version 1.02 du 3 janvier 2013
# 17 janvier 2014  modification blend
# 2014/04/24 blend
# 2014/07/03 modification gimp_blend
# 2015/03/14 menu , gimp_blend , filtres utilisés en fonction pour version stable simplifiée
# 2015/03/15 Amplitude1 Amplitude2 Amplitude3 Amplitude4 en fonction de W et H
# 2016/02/02 {round(u)*255}

#@gui Harmonograph : Harmonograph_samj, Harmonograph_samj(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Harmonograph")
#@gui :_=separator()
#@gui :_=note("<small>Centre / Center</small>")
#@gui : Centre / Center X (%) = float(50,0,100)
#@gui : Centre / Center Y (%) = float(50,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Harmonograph</small>")
#@gui : Stylo / Pen (Couleur/Color) = color(192,128,64,255)
#@gui : Stylo / Pen (Variation de couleur/Color variation) = choice("Pas de variation / No change","Couleurs aleatoires / Random Colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Stylo / Pen (Dilate Pixels)  = int(0,0,32)
#@gui : Itérations = int(1000,2,30000)
#@gui : Multiplier  = choice(0,"Iterations * 1","Iterations * 5 LENT / SLOW","Iterations * 10 TRES LENT / VERY SLOW")
#@gui : Increment Temps / Time increment [*10000]= float(400,10,500)
#@gui :_=separator()
#@gui :_=note("<small>Amplitude</small>")
#@gui : Amplitude 1 (>0 W) (<0 H) = float(150,-1000,1000)
#@gui : Amplitude 2 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 3 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 4 (>0 W) (<0 H) = float(100,-1000,1000)
#@gui :_=separator()
#@gui :_=note("<small>Fréquence / Frequency</small>")
#@gui : Fréquence 1 = float(4,0,16)
#@gui : Fréquence 2 = float(6,0,16)
#@gui : Fréquence 3 = float(2,0,16)
#@gui : Fréquence 4 = float(2,0,16)
#@gui :_=separator()
#@gui :_=note("<small>Phase</small>")
#@gui : Phase 1 = float(15,0,360)
#@gui : Phase 2 = float(270,0,360)
#@gui : Phase 3 = float(75,0,360)
#@gui : Phase 4 = float(60,0,360)
#@gui :_=separator()
#@gui :_=note("<small>Amortissement / Damping</small>")
#@gui : Amortissement 1 = float(0.04,0,1)
#@gui : Amortissement 2 = float(0.04,0,1)
#@gui : Amortissement 3 = float(0.05,0,1)
#@gui : Amortissement 4 = float(0.06,0,1)
#@gui :_=separator()
#@gui :_=note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Déformation = float(0,0,25)
#@gui :_=separator()
#@gui :_=note("<small>Mélange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

Harmonograph_samj :

 centre_origine_X={$1/100*w}
 centre_origine_Y={$2/100*h}

 R_Couleur_Stylo=$3
 V_Couleur_Stylo=$4
 B_Couleur_Stylo=$5
 A_Couleur_Stylo=$6
 Variation_de_couleur=$7
 Dilate_Stylo=$8
 Iterations=$9
 Multiplier_Iterations=$10
 Increment_temps=$11

 if $12>0
  Amplitude1={{w}*$12/{1000}}
 else
  Amplitude1={-{h}*$12/{1000}}
 endif
 if $13>0
  Amplitude2={{w}*$13/{1000}}
 else
  Amplitude2={-{h}*$13/{1000}}
 endif
 if $14>0
  Amplitude3={{w}*$14/{1000}}
 else
  Amplitude3={-{h}*$14/{1000}}
 endif
 if $15>0
  Amplitude4={{w}*$15/{1000}}
 else
  Amplitude4={-{h}*$15/{1000}}
 endif
 Frequence1=$16
 Frequence2=$17
 Frequence3=$18
 Frequence4=$19
 Phase1=$20
 Phase2=$21
 Phase3=$22
 Phase4=$23
 Amort1=$24
 Amort2=$25
 Amort3=$26
 Amort4=$27

   ## divers
 Flou_Harmonograph=$28
 Spread_Harmonograph=$29
 Deform_Harmonograph=$30

 blend=$31
 opacite=$32
 Revert_layers=0
####### Ligne de commandes

 to_rgba
 {w},{h},1,4  ## créer une image transparente aux mêmes dimensions que l'image d'origine
 Nb_Boucle=1
 temps=0
 Ancien_point_X=0
 Nouveau_point_X=0
 Ancien_point_Y=0
 Nouveau_point_Y=0
 R_Couleur_origine=$R_Couleur_Stylo
 V_Couleur_origine=$V_Couleur_Stylo
 B_Couleur_origine=$B_Couleur_Stylo
 A_Couleur_origine=$A_Couleur_Stylo
 Increment_temps={$Increment_temps/10000}
 Phase1={$Phase1/180*{pi}}
 Phase2={$Phase2/180*{pi}}
 Phase3={$Phase3/180*{pi}}
 Phase4={$Phase4/180*{pi}}
 if $Multiplier_Iterations>0
  Iterations={$Iterations*$Multiplier_Iterations*5}
 endif
 repeat $Iterations
  if $Variation_de_couleur==1
    R_Couleur_Stylo={round(u)*255}
    V_Couleur_Stylo={round(u)*255}
    B_Couleur_Stylo={round(u)*255}
    ##A_Couleur_Stylo={{round({(u(200))})}+55}
  endif
  ## couleurs nuancées
  if $Variation_de_couleur>1
   Valeur_variation_couleur=16
   if $Variation_de_couleur==3
    Valeur_variation_couleur=32
   endif
   if $Variation_de_couleur==4
    Valeur_variation_couleur=64
   endif
   R_Couleur_Stylo={round({$R_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $R_Couleur_Stylo>255
     R_Couleur_Stylo=$R_Couleur_origine
   endif
   if $R_Couleur_Stylo<0
     R_Couleur_Stylo=$R_Couleur_origine
   endif
   V_Couleur_Stylo={round({$V_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $V_Couleur_Stylo>255
     V_Couleur_Stylo=$V_Couleur_origine
   endif
   if $V_Couleur_Stylo<0
     V_Couleur_Stylo=$V_Couleur_origine
   endif
   B_Couleur_Stylo={round({$B_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $B_Couleur_Stylo>255
     B_Couleur_Stylo=$B_Couleur_origine
   endif
   if $B_Couleur_Stylo<0
     B_Couleur_Stylo=$B_Couleur_origine
   endif
  endif
  Nouveau_point_X={$centre_origine_X+{{$Amplitude1*{sin({{$Frequence1*$temps}+$Phase1})}*{exp({-$Amort1*$temps})}}+{$Amplitude2*{sin({{$Frequence2*$temps}+$Phase2})}*{exp({-$Amort2*$temps})}}}}
  Nouveau_point_Y={$centre_origine_Y+{{$Amplitude3*{sin({{$Frequence3*$temps}+$Phase3})}*{exp({-$Amort3*$temps})}}+{$Amplitude4*{sin({{$Frequence4*$temps}+$Phase4})}*{exp({-$Amort4*$temps})}}}}
  if $Nb_Boucle>1
   line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
  endif
  Ancien_point_X=$Nouveau_point_X
  Ancien_point_Y=$Nouveau_point_Y
  temps={$temps+$Increment_temps}
  Nb_Boucle={$Nb_Boucle+1}
 done

 if $Dilate_Stylo>0 dilate_circ[-1] $Dilate_Stylo endif
 if $Flou_Harmonograph>0 blur[-1] $Flou_Harmonograph,0 endif
 if $Spread_Harmonograph>1 spread[-1] $Spread_Harmonograph endif
 if $Deform_Harmonograph>0 deform[-1] $Deform_Harmonograph endif
 gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1 # alpha
 ## vérification ##
 #text_outline[0] $Amplitude1,10,10,64,1,1,255,255,255

################################################################
##                                                            ##
##                    FIN  Harmonograph                       ##
##                                                            ##
################################################################

################################################################
##                                                            ##
##                      Pintograph_samj                       ##
##                                                            ##
################################################################

# variante de Harmonograph sans amortissement
# -Pintograph_samj 50,50,255,128,64,255,0,0,5000,0,40,200,50,100,300,4,4.05,4.16,3.95636,90,120,75,30,0,0,0,27,1,0
# -Pintograph_samj 50,50,255,128,64,255,0,0,10000,2,10,200,200,200,100,4,4,4.1,4.1,0,75,75,75,0,0,0,27,1,0
# -Pintograph_samj 50,50,255,128,64,255,0,0,10000,2,10,200,200,200,100,4,4,4,4.1,0,75,75,75,0,0,0,27,1,0
# version 1.00 du 3 janvier 2013
# 17 janvier 2014  modification blend
# 2014/04/24 blend
# 2014/07/03 modification gimp_blend
# 2015/03/14 menu , gimp_blend , filtres utilisés en fonction pour version stable simplifiée
# 2015/03/15 Amplitude1 Amplitude2 Amplitude3 Amplitude4 en fonction de W et H
# 2016/02/02 {round(u)*255}

#@gui Pintograph : Pintograph_samj, Pintograph_samj(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Pintograph")
#@gui :_=separator()
#@gui :_=note("<small>Centre / Center</small>")
#@gui : Centre / Center X (%) = float(50,0,100)
#@gui : Centre / Center Y (%) = float(50,0,100)
#@gui :_=separator()
#@gui :_=note("<small>Pintograph</small>")
#@gui : Stylo / Pen (Couleur/Color) = color(192,128,64,255)
#@gui : Stylo / Pen (Variation de couleur/Color variation) = choice("Pas de variation / No change","Couleurs aleatoires / Random Colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui : Stylo / Pen (Dilate Pixels)  = int(0,0,32)
#@gui : Itérations = int(1000,2,30000)
#@gui : Multiplier  = choice(0,"Itérations * 1","Itérations * 5 LENT / SLOW","Itérations * 10 TRES LENT / VERY SLOW")
#@gui : Increment Temps / Time increment [*10000]= float(400,10,500)
#@gui :_=separator()
#@gui :_=note("<small>Amplitude</small>")
#@gui : Amplitude 1 (>0 W) (<0 H) = float(150,-1000,1000)
#@gui : Amplitude 2 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 3 (>0 W) (<0 H) = float(200,-1000,1000)
#@gui : Amplitude 4 (>0 W) (<0 H) = float(100,-1000,1000)
#@gui :_=separator()
#@gui :_=note("<small>Fréquence / Frequency</small>")
#@gui : Fréquence 1 = float(4.00,0,16)
#@gui : Fréquence 2 = float(4.05,0,16)
#@gui : Fréquence 3 = float(4.16,0,16)
#@gui : Fréquence 4 = float(4.32,0,16)
#@gui :_=separator()
#@gui :_=note("<small>Phase</small>")
#@gui : Phase 1 = float(75,0,360)
#@gui : Phase 2 = float(150,0,360)
#@gui : Phase 3 = float(75,0,360)
#@gui : Phase 4 = float(60,0,360)
#@gui :_=separator()
#@gui :_=note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Déformation = float(0,0,25)
#@gui :_=separator()
#@gui :_=note("<small>Mélange / Blend</small>")
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

Pintograph_samj :

 centre_origine_X={$1/100*w}
 centre_origine_Y={$2/100*h}

 R_Couleur_Stylo=$3
 V_Couleur_Stylo=$4
 B_Couleur_Stylo=$5
 A_Couleur_Stylo=$6
 Variation_de_couleur=$7
 Dilate_Stylo=$8
 Iterations=$9
 Multiplier_Iterations=$10
 Increment_temps=$11

 if $12>0
  Amplitude1={{w}*$12/{1000}}
 else
  Amplitude1={-{h}*$12/{1000}}
 endif
 if $13>0
  Amplitude2={{w}*$13/{1000}}
 else
  Amplitude2={-{h}*$13/{1000}}
 endif
 if $14>0
  Amplitude3={{w}*$14/{1000}}
 else
  Amplitude3={-{h}*$14/{1000}}
 endif
 if $15>0
  Amplitude4={{w}*$15/{1000}}
 else
  Amplitude4={-{h}*$15/{1000}}
 endif
 Frequence1=$16
 Frequence2=$17
 Frequence3=$18
 Frequence4=$19
 Phase1=$20
 Phase2=$21
 Phase3=$22
 Phase4=$23

   ## divers
 Flou_Pintograph=$24
 Spread_Pintograph=$25
 Deform_Pintograph=$26

 blend=$27
 opacite=$28
 Revert_layers=0
####### Ligne de commandes

 to_rgba
 {w},{h},1,4  ## créer une image transparente aux mêmes dimensions que l'image d'origine
 Nb_Boucle=1
 temps=0
 Ancien_point_X=0
 Nouveau_point_X=0
 Ancien_point_Y=0
 Nouveau_point_Y=0
 R_Couleur_origine=$R_Couleur_Stylo
 V_Couleur_origine=$V_Couleur_Stylo
 B_Couleur_origine=$B_Couleur_Stylo
 A_Couleur_origine=$A_Couleur_Stylo
 Increment_temps={$Increment_temps/10000}
 Phase1={$Phase1/180*{pi}}
 Phase2={$Phase2/180*{pi}}
 Phase3={$Phase3/180*{pi}}
 Phase4={$Phase4/180*{pi}}
 if $Multiplier_Iterations>0
  Iterations={$Iterations*$Multiplier_Iterations*5}
 endif
 repeat $Iterations
  if $Variation_de_couleur==1
    R_Couleur_Stylo={round(u)*255}
    V_Couleur_Stylo={round(u)*255}
    B_Couleur_Stylo={round(u)*255}
    ##A_Couleur_Stylo={{round({(u(200))})}+55}
  endif
  ## couleurs nuancées
  if $Variation_de_couleur>1
   Valeur_variation_couleur=16
   if $Variation_de_couleur==3
    Valeur_variation_couleur=32
   endif
   if $Variation_de_couleur==4
    Valeur_variation_couleur=64
   endif
   R_Couleur_Stylo={round({$R_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
    if $R_Couleur_Stylo>255
      R_Couleur_Stylo=$R_Couleur_origine
    endif
    if $R_Couleur_Stylo<0
      R_Couleur_Stylo=$R_Couleur_origine
    endif
   V_Couleur_Stylo={round({$V_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
    if $V_Couleur_Stylo>255
      V_Couleur_Stylo=$V_Couleur_origine
    endif
    if $V_Couleur_Stylo<0
      V_Couleur_Stylo=$V_Couleur_origine
    endif
   B_Couleur_Stylo={round({$B_Couleur_origine+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
    if $B_Couleur_Stylo>255
      B_Couleur_Stylo=$B_Couleur_origine
    endif
    if $B_Couleur_Stylo<0
      B_Couleur_Stylo=$B_Couleur_origine
    endif
  endif
  Nouveau_point_X={$centre_origine_X+{{$Amplitude1*{sin({{$Frequence1*$temps}+$Phase1})}}+{$Amplitude2*{sin({{$Frequence2*$temps}+$Phase2})}}}}
  Nouveau_point_Y={$centre_origine_Y+{{$Amplitude3*{sin({{$Frequence3*$temps}+$Phase3})}}+{$Amplitude4*{sin({{$Frequence4*$temps}+$Phase4})}}}}
  if $Nb_Boucle>1
   line[-1] $Ancien_point_X,$Ancien_point_Y,$Nouveau_point_X,$Nouveau_point_Y,1,$R_Couleur_Stylo,$V_Couleur_Stylo,$B_Couleur_Stylo,$A_Couleur_Stylo
  endif
  Ancien_point_X=$Nouveau_point_X
  Ancien_point_Y=$Nouveau_point_Y
  temps={$temps+$Increment_temps}
  Nb_Boucle={$Nb_Boucle+1}
 done

 if $Dilate_Stylo>0 dilate_circ[-1] $Dilate_Stylo endif
 if $Flou_Pintograph>0 blur[-1] $Flou_Pintograph,0 endif
 if $Spread_Pintograph>1 spread[-1] $Spread_Pintograph endif
 if $Deform_Pintograph>0 deform[-1] $Deform_Pintograph endif
 gimp_blend_1651[-1,-2] $blend,1,$opacite,$Revert_layers,1 # alpha

################################################################
##                                                            ##
##                     FIN  Pintograph_samj                   ##
##                                                            ##
################################################################
#################################################
##                                             ##
##                Des_Lignes_002               ##
##                                             ##
#################################################

# à faire : ajouter réorganiser les effets

## origine 2014/01/07
## 2014/01/19 ajout effets 10 et 11
## 2014/04/24 blend
## 2014/07/03 modification gimp_blend
## 2015/03/09 menu , Je_passe_l_hiver_en_Floride , simplification blend , ajout effet 12, ajout dilate , Straight Lines remplacce Des_Lignes_002, symétrie
# 2016/02/02 {round(u)*255}

#@gui Straight Lines  : samj_Des_Lignes_002, samj_Des_Lignes_002(1)
#@gui :_=separator()
#@gui :_=note("<small>Des Lignes / Straight Lines</small>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Paramètres des lignes</small></span>")
#@gui : Nombre Lignes / Number Of Lines = int(100,1,4096)
#@gui : Couleurs Aléatoires / Random Colors = bool(0)
#@gui : Gris / Gray = bool(0)
#@gui : Couleur / Color = color(192,128,64,255)
#@gui : Symétrie / Symmetry = int(0,0,3)
#@gui : Effet / Effect = choice(0,"1","2","3","4","5","6","7","8","9","10","11","12")
#@gui : Etendue / Extent = float(1,1,10)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Effet 12 / Effect 12</small></span>")
#@gui : Origine X (% w) = float(50,-400,400)
#@gui : Origine Y (% h) = float(50,-400,400)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Distorsions</small></span>")
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Mélange / Blend</small></span>")
#@gui : Mélange / Blend = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")
samj_Des_Lignes_002 :

 Nombre_Lignes=$1
 Random_Colors=$2
 Gris=$3
 R_Couleur=$4
 V_Couleur=$5
 B_Couleur=$6
 A_Couleur=$7
 Symetrie=$8
 Effet=$9
 Etendue=$10
 point_X={{w}/100*$11}
 point_Y={{h}/100*$12}
 Flou=$13
 Dilatation=$14
 Deformation=$15
 Bruit=$16
 Melange=$17

 Inc_L={{w}/{{$Nombre_Lignes+1}*$Etendue}}
 Inc_H={{h}/{{$Nombre_Lignes+1}*$Etendue}}

 Origine_L=0
 Origine_H=0

 if $Melange==1
  {w},{h},1,4
 else
  to_rgba[-1]
  fill_color[-1] 0,0,0,0
 endif

 repeat $Nombre_Lignes

  Origine_L={$Origine_L+$Inc_L}
  Origine_H={$Origine_H+$Inc_H}

  if $Random_Colors==1
   R_Couleur={round(u)*255}
   V_Couleur={round(u)*255}
   B_Couleur={round(u)*255}
  endif

  if $Gris==1
   R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
   V_Couleur=$R_Couleur
   B_Couleur=$R_Couleur
  endif

  if $Effet==0
   line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==1
   line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==3
   line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==5
   line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==9
   line[-1] $Origine_L,0,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==11
   line[-1] $point_X,$point_Y,{w},$Origine_H,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
   line[-1] $point_X,$point_Y,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
   line[-1] $point_X,$point_Y,0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
   line[-1] $point_X,$point_Y,$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  endif

  if $Random_Colors==1
   R_Couleur={round(u)*255}
   V_Couleur={round(u)*255}
   B_Couleur={round(u)*255}
  endif

  if $Gris==1
   R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
   V_Couleur=$R_Couleur
   B_Couleur=$R_Couleur
  endif

  if $Effet==0
   line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==2
   line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==3
   line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==6
   line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==10
   line[-1] {w},$Origine_H,{{w}-$Origine_L},{h},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  endif

  if $Random_Colors==1
   R_Couleur={round(u)*255}
   V_Couleur={round(u)*255}
   B_Couleur={round(u)*255}
  endif

  if $Gris==1
   R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
   V_Couleur=$R_Couleur
   B_Couleur=$R_Couleur
  endif

  if $Effet==0
   line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==1
   line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==4
   line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==7
   line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==10
   line[-1] {{w}-$Origine_L},{h},0,{{h}-$Origine_H},1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  endif

  if $Random_Colors==1
   R_Couleur={round(u)*255}
   V_Couleur={round(u)*255}
   B_Couleur={round(u)*255}
  endif

  if $Gris==1
   R_Couleur={{$R_Couleur+$V_Couleur+$B_Couleur}/3}
   V_Couleur=$R_Couleur
   B_Couleur=$R_Couleur
  endif

  if $Effet==0
   line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==2
   line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==4
   line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==8
   line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  elif $Effet==9
   line[-1] 0,{{h}-$Origine_H},$Origine_L,0,1,$R_Couleur,$V_Couleur,$B_Couleur,$A_Couleur
  endif

 done

 if $Symetrie==1
  mirror[-1] x
 elif $Symetrie==2
  mirror[-1] y
 elif $Symetrie==3
  mirror[-1] x
  mirror[-1] y
 endif

 if $Dilatation>1 dilate_circ[-1] $Dilatation endif
 if $Flou>0 blur[-1] $Flou,0 endif
 if $Deformation>0 deform[-1] $Deformation endif
 if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif

 if $Melange==1
  blend[-1,-2] alpha,1,0
 endif

 # text_outline[-1] $Effet,10,10,64,1,1,255,255,255
#################################################
##                                             ##
##             FIN Des_Lignes_002              ##
##                                             ##
#################################################


#################################################
##                                             ##
##         Formes_Geometriques_Simples         ##
##                                             ##
#################################################

# 2015/03/09 menu , changement de nom : Simple Geometric Shapes remplace Formes_Geometriques_Simples , ajout blend
# 2014/03/10 origine
# samj_Formes_Geometriques_Simples[-1] $X_Position,$Y_Position,$R_Externe,$V_Externe,$B_Externe,$A_Externe,$R_Interne,$V_Interne,$B_Interne,$A_Interne,$R_Contour,$V_Contour,$B_Contour,$A_Contour,$Forme,$Dimension_Un,$Dimension_Deux,$Nb_Cotes,$Angle_Inclinaison,$Dilatation

#@gui Simple Geometric Shapes  : samj_Formes_Geometriques_Simples, samj_Formes_Geometriques_Simples(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="black">Formes Géometriques Simples / Simple Geometric Shapes</span>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Effet</small></span>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Couleur Externe / External Color = color(127,127,127,127)
#@gui : Couleur Interne / Interior Color = color(255,255,0,255)
#@gui : Couleur / Color Contour = color(0,0,255,255)
#@gui : Forme / Shape = choice(5,"Polygone Inscrit Dimension 1","Polygone Inscrit Dimension 2","Cercle / Ellipse","Étoile Star Dimension 1","Étoile Star Dimension 2","Polygone Étoile Star Dimension 1","Polygone Étoile Star Dimension 2")
#@gui : Dimension 1  (% Width) = float(40,0,400)
#@gui : Dimension 2  (% Height) = float(40,0,400)
#@gui : Nb Côtés / Number Of Sides = int(4,3,26)
#@gui : Angle Inclinaison / Tilt = float(0,0,120)
#@gui : Dilate = int(0,0,48)
#@gui : Blend = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/09</i>.</small>")
samj_Formes_Geometriques_Simples :

 X_Position={round({{w}*{$1/100}})}
 Y_Position={round({{h}*{$2/100}})}
 R_Externe=$3
 V_Externe=$4
 B_Externe=$5
 A_Externe=$6
 R_Interne=$7
 V_Interne=$8
 B_Interne=$9
 A_Interne=$10
 R_Contour=$11
 V_Contour=$12
 B_Contour=$13
 A_Contour=$14
 Forme=$15
 Dimension_Un={round({{w}*{$16/100}})}
 Dimension_Deux={round({{h}*{$17/100}})}
 Nb_Cotes=$18
 Angle_Inclinaison=$19
 Dilatation=$20
 Melange=$21

 Largeur_Origine={w}
 Hauteur_Origine={h}
 Valeur_Angle=0
 Nb_Boucles=0
 Rayon_Cercle_Circonscrit=0

 if $Forme==0
  Rayon_Cercle_Circonscrit=$Dimension_Un
 elif $Forme==1 #"Polygone Inscrit Dimension 2"
  Rayon_Cercle_Circonscrit=$Dimension_Deux
 elif $Forme==3
  Rayon_Cercle_Circonscrit=$Dimension_Un
  if $Nb_Cotes<5 Nb_Cotes=5 endif
 elif $Forme==4
  Rayon_Cercle_Circonscrit=$Dimension_Deux
  if $Nb_Cotes<5 Nb_Cotes=5 endif
 elif $Forme==5
  Rayon_Cercle_Circonscrit=$Dimension_Un
  if $Nb_Cotes<5 Nb_Cotes=5 endif
 elif $Forme==6
  Rayon_Cercle_Circonscrit=$Dimension_Deux
  if $Nb_Cotes<5 Nb_Cotes=5 endif
 endif

 if $Melange==0
  rm[-1]
 else
  to_rgba[-1]
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 fill_color[-1] $R_Externe,$V_Externe,$B_Externe,$A_Externe
 if $Forme==2 # ellipse
  ellipse[-1] $X_Position,$Y_Position,$Dimension_Un,$Dimension_Deux,$Angle_Inclinaison,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  ellipse[-1] $X_Position,$Y_Position,$Dimension_Un,$Dimension_Deux,$Angle_Inclinaison,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour

 else # Coordonnées Polygones Étoiles

  repeat $Nb_Cotes

   Nb_Boucles={$Nb_Boucles+1}

   if $Nb_Boucles==1
    X_a={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_a={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==2
    X_b={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_b={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==3
    X_c={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_c={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==4
    X_d={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_d={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==5
    X_e={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_e={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==6
    X_f={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_f={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==7
    X_g={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_g={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==8
    X_h={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_h={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==9
    X_i={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_i={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==10
    X_j={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_j={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==11
    X_k={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_k={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==12
    X_l={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_l={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==13
    X_m={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_m={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==14
    X_n={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_n={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==15
    X_o={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_o={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==16
    X_p={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_p={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==17
    X_q={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_q={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==18
    X_r={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_r={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==19
    X_s={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_s={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==20
    X_t={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_t={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==21
    X_u={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_u={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==22
    X_v={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_v={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==23
    X_w={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_w={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==24
    X_x={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_x={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==25
    X_y={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_y={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   elif $Nb_Boucles==26
    X_z={$X_Position+{round({$Rayon_Cercle_Circonscrit*{cos({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
    Y_z={$Y_Position+{round({$Rayon_Cercle_Circonscrit*{sin({pi/180*{$Valeur_Angle+$Angle_Inclinaison+{360/$Nb_Cotes}}})}})}}
   endif

   Valeur_Angle={$Valeur_Angle+{360/$Nb_Cotes}}

  done

 endif

 if $Forme==0||$Forme==1 # Polygones Inscrits

  if $Nb_Cotes==3
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==4
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==5
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==6
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==7
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==8
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==9
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==10
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==11
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==12
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==13
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==14
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==15
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==16
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==17
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==18
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==19
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==20
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==21
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==22
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==23
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==24
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==25
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==26
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  endif

 endif

 if $Forme==3||$Forme==4
 # Etoiles Impaires
  if $Nb_Cotes==5
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==7
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==9
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==11
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==13
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==15
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==17
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==19
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==21
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==23
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==25
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
 # Étoiles Paires
  elif $Nb_Cotes==6
   polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==8
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==10
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==12
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==14
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==16
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==18
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==20
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==22
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==24
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  elif $Nb_Cotes==26
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,0xFFFFFFFF,$R_Contour,$V_Contour,$B_Contour,$A_Contour
  endif
 endif
 if $Forme==5||$Forme==6 # Polygones + Etoiles
 # Polygones + Étoiles Impaires
  if $Nb_Cotes==5
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,$X_b,$Y_b,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==7
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_c,$Y_c,$X_f,$Y_f,$X_b,$Y_b,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==9
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_e,$Y_e,$X_i,$Y_i,$X_d,$Y_d,$X_h,$Y_h,$X_c,$Y_c,$X_g,$Y_g,$X_b,$Y_b,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==11
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_e,$Y_e,$X_j,$Y_j,$X_d,$Y_d,$X_i,$Y_i,$X_c,$Y_c,$X_h,$Y_h,$X_b,$Y_b,$X_g,$Y_g,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==13
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_g,$Y_g,$X_m,$Y_m,$X_f,$Y_f,$X_l,$Y_l,$X_e,$Y_e,$X_k,$Y_k,$X_d,$Y_d,$X_j,$Y_j,$X_c,$Y_c,$X_i,$Y_i,$X_b,$Y_b,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==15
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_g,$Y_g,$X_n,$Y_n,$X_f,$Y_f,$X_m,$Y_m,$X_e,$Y_e,$X_l,$Y_l,$X_d,$Y_d,$X_k,$Y_k,$X_c,$Y_c,$X_j,$Y_j,$X_b,$Y_b,$X_i,$Y_i,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==17
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_i,$Y_i,$X_q,$Y_q,$X_h,$Y_h,$X_p,$Y_p,$X_g,$Y_g,$X_o,$Y_o,$X_f,$Y_f,$X_n,$Y_n,$X_e,$Y_e,$X_m,$Y_m,$X_d,$Y_d,$X_l,$Y_l,$X_c,$Y_c,$X_k,$Y_k,$X_b,$Y_b,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==19
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_i,$Y_i,$X_r,$Y_r,$X_h,$Y_h,$X_q,$Y_q,$X_g,$Y_g,$X_p,$Y_p,$X_f,$Y_f,$X_o,$Y_o,$X_e,$Y_e,$X_n,$Y_n,$X_d,$Y_d,$X_m,$Y_m,$X_c,$Y_c,$X_l,$Y_l,$X_b,$Y_b,$X_k,$Y_k,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==21
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_k,$Y_k,$X_u,$Y_u,$X_j,$Y_j,$X_t,$Y_t,$X_i,$Y_i,$X_s,$Y_s,$X_h,$Y_h,$X_r,$Y_r,$X_g,$Y_g,$X_q,$Y_q,$X_f,$Y_f,$X_p,$Y_p,$X_e,$Y_e,$X_o,$Y_o,$X_d,$Y_d,$X_n,$Y_n,$X_c,$Y_c,$X_m,$Y_m,$X_b,$Y_b,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==23
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_k,$Y_k,$X_v,$Y_v,$X_j,$Y_j,$X_u,$Y_u,$X_i,$Y_i,$X_t,$Y_t,$X_h,$Y_h,$X_s,$Y_s,$X_g,$Y_g,$X_r,$Y_r,$X_f,$Y_f,$X_q,$Y_q,$X_e,$Y_e,$X_p,$Y_p,$X_d,$Y_d,$X_o,$Y_o,$X_c,$Y_c,$X_n,$Y_n,$X_b,$Y_b,$X_m,$Y_m,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==25
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_m,$Y_m,$X_y,$Y_y,$X_l,$Y_l,$X_x,$Y_x,$X_k,$Y_k,$X_w,$Y_w,$X_j,$Y_j,$X_v,$Y_v,$X_i,$Y_i,$X_u,$Y_u,$X_h,$Y_h,$X_t,$Y_t,$X_g,$Y_g,$X_s,$Y_s,$X_f,$Y_f,$X_r,$Y_r,$X_e,$Y_e,$X_q,$Y_q,$X_d,$Y_d,$X_p,$Y_p,$X_c,$Y_c,$X_o,$Y_o,$X_b,$Y_b,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
 # Polygones + Étoiles Paires
  elif $Nb_Cotes==6
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] {$Nb_Cotes/2},$X_a,$Y_a,$X_c,$Y_c,$X_e,$Y_e,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
   polygon[-1] {$Nb_Cotes/2},$X_b,$Y_b,$X_d,$Y_d,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==8
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_d,$Y_d,$X_g,$Y_g,$X_b,$Y_b,$X_e,$Y_e,$X_h,$Y_h,$X_c,$Y_c,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==10
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_e,$Y_e,$X_b,$Y_b,$X_i,$Y_i,$X_f,$Y_f,$X_c,$Y_c,$X_j,$Y_j,$X_g,$Y_g,$X_d,$Y_d,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==12
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_f,$Y_f,$X_k,$Y_k,$X_d,$Y_d,$X_i,$Y_i,$X_b,$Y_b,$X_g,$Y_g,$X_l,$Y_l,$X_e,$Y_e,$X_j,$Y_j,$X_c,$Y_c,$X_h,$Y_h,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==14
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_e,$Y_e,$X_n,$Y_n,$X_i,$Y_i,$X_d,$Y_d,$X_m,$Y_m,$X_h,$Y_h,$X_c,$Y_c,$X_l,$Y_l,$X_g,$Y_g,$X_b,$Y_b,$X_k,$Y_k,$X_f,$Y_f,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==16
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_f,$Y_f,$X_m,$Y_m,$X_d,$Y_d,$X_k,$Y_k,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_g,$Y_g,$X_n,$Y_n,$X_e,$Y_e,$X_l,$Y_l,$X_c,$Y_c,$X_j,$Y_j,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==18
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_h,$Y_h,$X_o,$Y_o,$X_d,$Y_d,$X_k,$Y_k,$X_r,$Y_r,$X_g,$Y_g,$X_n,$Y_n,$X_c,$Y_c,$X_j,$Y_j,$X_q,$Y_q,$X_f,$Y_f,$X_m,$Y_m,$X_b,$Y_b,$X_i,$Y_i,$X_p,$Y_p,$X_e,$Y_e,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==20
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_h,$Y_h,$X_q,$Y_q,$X_f,$Y_f,$X_o,$Y_o,$X_d,$Y_d,$X_m,$Y_m,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_i,$Y_i,$X_r,$Y_r,$X_g,$Y_g,$X_p,$Y_p,$X_e,$Y_e,$X_n,$Y_n,$X_c,$Y_c,$X_l,$Y_l,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==22
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_j,$Y_j,$X_s,$Y_s,$X_f,$Y_f,$X_o,$Y_o,$X_b,$Y_b,$X_k,$Y_k,$X_t,$Y_t,$X_g,$Y_g,$X_p,$Y_p,$X_c,$Y_c,$X_l,$Y_l,$X_u,$Y_u,$X_h,$Y_h,$X_q,$Y_q,$X_d,$Y_d,$X_m,$Y_m,$X_v,$Y_v,$X_i,$Y_i,$X_r,$Y_r,$X_e,$Y_e,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==24
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_j,$Y_j,$X_u,$Y_u,$X_h,$Y_h,$X_s,$Y_s,$X_f,$Y_f,$X_q,$Y_q,$X_d,$Y_d,$X_o,$Y_o,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_k,$Y_k,$X_v,$Y_v,$X_i,$Y_i,$X_t,$Y_t,$X_g,$Y_g,$X_r,$Y_r,$X_e,$Y_e,$X_p,$Y_p,$X_c,$Y_c,$X_n,$Y_n,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  elif $Nb_Cotes==26
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_b,$Y_b,$X_c,$Y_c,$X_d,$Y_d,$X_e,$Y_e,$X_f,$Y_f,$X_g,$Y_g,$X_h,$Y_h,$X_i,$Y_i,$X_j,$Y_j,$X_k,$Y_k,$X_l,$Y_l,$X_m,$Y_m,$X_n,$Y_n,$X_o,$Y_o,$X_p,$Y_p,$X_q,$Y_q,$X_r,$Y_r,$X_s,$Y_s,$X_t,$Y_t,$X_u,$Y_u,$X_v,$Y_v,$X_w,$Y_w,$X_x,$Y_x,$X_y,$Y_y,$X_z,$Y_z,1,$R_Contour,$V_Contour,$B_Contour,$A_Contour
   polygon[-1] $Nb_Cotes,$X_a,$Y_a,$X_l,$Y_l,$X_w,$Y_w,$X_h,$Y_h,$X_s,$Y_s,$X_d,$Y_d,$X_o,$Y_o,$X_z,$Y_z,$X_k,$Y_k,$X_v,$Y_v,$X_g,$Y_g,$X_r,$Y_r,$X_c,$Y_c,$X_n,$Y_n,$X_y,$Y_y,$X_j,$Y_j,$X_u,$Y_u,$X_f,$Y_f,$X_q,$Y_q,$X_b,$Y_b,$X_m,$Y_m,$X_x,$Y_x,$X_i,$Y_i,$X_t,$Y_t,$X_e,$Y_e,$X_p,$Y_p,1,$R_Interne,$V_Interne,$B_Interne,$A_Interne
  endif

 endif
 if $Dilatation>1
  dilate_circ[-1] $Dilatation
 endif
 #text_outline[-1] $X_Position,10,10,32,1,1,255,255,255
 #text_outline[-1] $Y_Position,10,35,32,1,1,255,255,255
 #text_outline[-1] $Dimension_Un,10,60,32,1,1,255,255,255
 #text_outline[-1] $Dimension_Deux,10,85,32,1,1,255,255,255
 #text_outline[-1] $Nb_Cotes,10,110,32,1,1,255,255,255
 #text_outline[-1] $Angle_Inclinaison,10,135,32,1,1,255,255,255

 if $Melange==1
  blend[-1,-2] alpha,1,0
 endif



samj_en_Formes_Geometriques_Simples :

 samj_Formes_Geometriques_Simples $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14,$15,$16,$17,$18,$19,$20,$21


#################################################
##                                             ##
##       FIN Formes_Geometriques_Simples       ##
##                                             ##
#################################################


#################################################
##                                             ##
##              Flocon_De_Neige                ##
##                                             ##
#################################################

# 2015/03/08 menu ,  Rayon_cercle_exterieur_flocon en fonction de largeur ou hauteur , ajout contour uniquement
# 2014/04/24 blend
# 2016/02/02 {round(u)*255}

#@gui Snowflake 2 : samj_Flocon_De_Neige, samj_Flocon_De_Neige(1)
#@gui :_=note("<small>Ah! comme la neige a neigé! <i>Soir d'hiver / &#278;mile Nelligan</i></small>")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Nb Branches / Rays  = int(6,3,12)
#@gui : Rayon Cercle Extérieur / Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Rayon Cercle Milieu / Radius Middle Circle = float(40,1,100)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Récursions Contours = int(3,0,5)
#@gui : Contours = color(192,192,192)
#@gui : Opacité / Opacity Contours = float(1,0,1)
#@gui : Affichage / Display Contours = choice(0,"Non / No","Contours + Flocon/Snowflake","Contours")
#@gui : Recursions Flocon / Snowflake = int(3,0,5)
#@gui : Flocon / Snowflake = color(255,255,255)
#@gui : Opacité Flocon / Opacity Snowflake = float(0.7,0,1)
#@gui : Type Flocon / Snowflake = choice(0,"A","B","C","A2","B2","C2")
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_Flocon_De_Neige :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Nb_Branches=$3
 if $4>0
  Rayon_cercle_exterieur_flocon={round({{w}*$4/{100}})}
 else
  Rayon_cercle_exterieur_flocon={round({-{h}*$4/{100}})}
 endif
 Rayon_Cercle_Milieu={round($Rayon_cercle_exterieur_flocon*2)}
 Rayon_Cercle_Milieu={round($Rayon_cercle_exterieur_flocon*$5/100)}
 Angle_inclinaison=$6

 Recursions_Contours=$7
 R_Contours=$8
 V_Contours=$9
 B_Contours=$10
 Opacity_Contours=$11
 Affichage_Contours=$12

 Recursions_Flocon=$13
 R_F=$14
 V_F=$15
 B_F=$16
 Opacity_Flocon=$17

 Type_Flocon=$18
 Couleurs_aleatoires=$19
 Inversions=$20
 Flou=$21
 Dilatation=$22
 Deformation=$23
 Bruit=$24
 Ombre=$25
 X_Ombre=$26
 Y_Ombre=$27
 Smoothness_Ombre=$28
 Curvature_Ombre=$29
 Compensation_Decalage_Ombre_X=$30
 Compensation_Decalage_Ombre_Y=$31
 Canal_Alpha=$32
 Largeur_Origine={w}
 Hauteur_Origine={h}

 Angle_Theta={360/$Nb_Branches}
 Nb_boucles=0
 X_ext=0
 Y_ext=0
 X_exta=0
 Y_exta=0
 X_extb=0
 Y_extb=0
 X_mil=0
 Y_mil=0
 Angle=0

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 repeat $Nb_Branches
  Angle={$Nb_boucles*$Angle_Theta}
  X_ext={$X+{$Rayon_cercle_exterieur_flocon*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
  Y_ext={$Y+{$Rayon_cercle_exterieur_flocon*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
  X_exta={$X+{$Rayon_cercle_exterieur_flocon/3*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
  Y_exta={$Y+{$Rayon_cercle_exterieur_flocon/3*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
  X_extb={$X+{$Rayon_cercle_exterieur_flocon/3*2*{cos({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
  Y_extb={$Y+{$Rayon_cercle_exterieur_flocon/3*2*{sin({pi/180*{$Angle+$Angle_inclinaison+$Angle_Theta}})}}}
  X_mil={$X+{$Rayon_Cercle_Milieu*{cos({pi/180*{$Angle+$Angle_inclinaison+{$Angle_Theta/2}}})}}}
  Y_mil={$Y+{$Rayon_Cercle_Milieu*{sin({pi/180*{$Angle+$Angle_inclinaison+{$Angle_Theta/2}}})}}}
  Nb_boucles={$Nb_boucles+1}

  if $Couleurs_aleatoires==1
   R_F={round(u)*255}
   V_F={round(u)*255}
   B_F={round(u)*255}
  endif

  if $Type_Flocon==0
   if $Affichage_Contours<2
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
   endif
   if $Affichage_Contours>0
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
   endif
  elif $Type_Flocon==1
   if $Affichage_Contours<2
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
   endif
   if $Affichage_Contours>0
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
   endif
  elif $Type_Flocon==2
   if $Affichage_Contours<2
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
   endif
   if $Affichage_Contours>0
    samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_mil,$Y_mil,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
   endif
  elif $Type_Flocon==3
   if $Affichage_Contours<2
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
   endif
   if $Affichage_Contours>0
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_extb,$Y_extb,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
   endif
  elif $Type_Flocon==4
   if $Affichage_Contours<2
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Flocon,$R_F,$V_F,$B_F
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Flocon,$R_F,$V_F,$B_F
   endif
   if $Affichage_Contours>0
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X,$Y,$X_exta,$Y_exta,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_exta,$Y_exta,$X_extb,$Y_extb,$X_exta,$Y_exta,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
    samj_snowflake_contours_absolu[-2] $Recursions_Flocon,$X_extb,$Y_extb,$X_ext,$Y_ext,$X_extb,$Y_extb,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
   endif
  elif $Type_Flocon==5
   if $Affichage_Contours<2
    samj_snowflake_absolu[-1] $Recursions_Flocon,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Flocon,$R_F,$V_F,$B_F
   endif
   if $Affichage_Contours>0
    samj_snowflake_contours_absolu[-2] $Recursions_Contours,$X,$Y,$X_ext,$Y_ext,$X,$Y,$Opacity_Contours,$R_Contours,$V_Contours,$B_Contours
   endif
  endif

 done

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0
#################################################
##                                             ##
##            FIN Flocon_De_Neige              ##
##                                             ##
#################################################


#################################################
##                                             ##
##        Cercles_Tangents_Dans_Cercle         ##
##                                             ##
#################################################

# 2015/03/08 menu , Cercles_Tangents_Dans_Cercle devient Pappus Chain
# 2014/04/24 blend
# 2016/02/02 {round(u)*255}
# 2016/12/20 gmic 1.8.0 fx_noise
#@gui Pappus Chain : samj_Cercles_Tangents_Dans_Cercle, samj_Cercles_Tangents_Dans_Cercle(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Pappus_chain","http://en.wikipedia.org/wiki/Pappus_chain")
#@gui :_=link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle Extérieur / Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Rayon Premier Cercle B  = float(40,0,99)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(1)
#@gui : Cercle Extérieur / Outer Circle A = color(127,127,127,127)
#@gui : Premier Cercle / First Circle B = color(255,0,0,127)
#@gui : Cercle / Circle C = color(0,255,0,127)
#@gui : Cercle / Circle D = color(0,0,255,127)
#@gui : Cercle / Circle E = color(255,0,255,127)
#@gui : Cercle / Circle F = color(255,255,0,127)
#@gui : Cercle / Circle G = color(0,255,255,127)
#@gui : Cercle / Circle H = color(192,128,64,127)
#@gui : Cercle / Circle I = color(64,192,128,127)
#@gui : Cercle / Circle J = color(128,64,192,127)
#@gui : Cercle / Circle K = color(192,64,128,127)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/20</i>.</small>")

samj_Cercles_Tangents_Dans_Cercle :

 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 if $3>0
  Rayon_Cercle_Exterieur={round({{w}*$3/{100}})}
 else
  Rayon_Cercle_Exterieur={round({-{h}*$3/{100}})}
 endif
 Rayon_Premier_Cercle={round({$Rayon_Cercle_Exterieur*$4/100})}
 Angle_inclinaison=$5

 R_Contours=$6
 V_Contours=$7
 B_Contours=$8
 A_Contours=$9

 Affichage_Contours=$10
 R_CE=$11
 V_CE=$12
 B_CE=$13
 A_CE=$14

 R_PC=$15
 V_PC=$16
 B_PC=$17
 A_PC=$18

 R_c=$19
 V_c=$20
 B_c=$21
 A_c=$22

 R_d=$23
 V_d=$24
 B_d=$25
 A_d=$26

 R_e=$27
 V_e=$28
 B_e=$29
 A_e=$30

 R_f=$31
 V_f=$32
 B_f=$33
 A_f=$34

 R_g=$35
 V_g=$36
 B_g=$37
 A_g=$38

 R_h=$39
 V_h=$40
 B_h=$41
 A_h=$42

 R_i=$43
 V_i=$44
 B_i=$45
 A_i=$46

 R_j=$47
 V_j=$48
 B_j=$49
 A_j=$50

 R_k=$51
 V_k=$52
 B_k=$53
 A_k=$54

 Couleurs_aleatoires=$55
 Inversions=$56
 Flou=$57
 Dilatation=$58
 Deformation=$59
 Bruit=$60
 Ombre=$61
 X_Ombre=$62
 Y_Ombre=$63
 Smoothness_Ombre=$64
 Curvature_Ombre=$65
 Compensation_Decalage_Ombre_X=$66
 Compensation_Decalage_Ombre_Y=$67
 Canal_Alpha=$68
 Largeur_Origine={w}
 Hauteur_Origine={h}

 X_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{cos({pi/180*$Angle_inclinaison})}}
 Y_Cb={{$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}*{sin({pi/180*$Angle_inclinaison})}}
 X_Cc={$Rayon_Premier_Cercle*{cos({pi/180*{$Angle_inclinaison+180}})}}
 Y_Cc={$Rayon_Premier_Cercle*{sin({pi/180*{$Angle_inclinaison+180}})}}
 R_Cc={$Rayon_Cercle_Exterieur-$Rayon_Premier_Cercle}

 #####

 # Rayon Cercle rang 1 Pappus
 R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
 n_Pappus=1
 b_Pappus={$R_Cc}
 a_Pappus={$Rayon_Premier_Cercle}
 R_Cercle_d={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}

 Va={$R_Cc+$R_Cercle_d}
 Vb={$Rayon_Premier_Cercle+$R_Cercle_d}

 # Centres des 2 Cercles rang 1 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cb-$X_Cc}
 d_y={$Y_Cb-$Y_Cc}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cc+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cc+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 X_Cercle_da={$c_x2+$o_rx}
 Y_Cercle_da={$c_y2+$o_ry}
 X_Cercle_db={$c_x2-$o_rx}
 Y_Cercle_db={$c_y2-$o_ry}

 #####

 # Rayon Cercle rang 4 Pappus
 R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
 n_Pappus=4
 b_Pappus={$R_Cc}
 a_Pappus={$Rayon_Premier_Cercle}
 R_Cercle_e={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}

 Vb={$R_Cc+$R_Cercle_e}
 Va={$R_Cercle_d+$R_Cercle_e}

 # Centres des 2 Cercles rang 4 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cc-$X_Cercle_da}
 d_y={$Y_Cc-$Y_Cercle_da}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cercle_da+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cercle_da+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 ## comp.  X_Cercle_ea={$c_x2+$o_rx}
 ## comp.  Y_Cercle_ea={$c_y2+$o_ry}
 X_Cercle_eb={$c_x2-$o_rx}
 Y_Cercle_eb={$c_y2-$o_ry}

 # Centres des 2 Cercles rang 4 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cc-$X_Cercle_db}
 d_y={$Y_Cc-$Y_Cercle_db}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cercle_db+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cercle_db+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 X_Cercle_ea={$c_x2+$o_rx}
 Y_Cercle_ea={$c_y2+$o_ry}
 ## comp.  X_Cercle_eb={$c_x2-$o_rx}
 ## comp.  Y_Cercle_eb={$c_y2-$o_ry}

 #####

 # Rayon Cercle rang 9 Pappus
 R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
 n_Pappus=9
 b_Pappus={$R_Cc}
 a_Pappus={$Rayon_Premier_Cercle}
 R_Cercle_f={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}

 Vb={$R_Cc+$R_Cercle_f}
 Va={$R_Cercle_e+$R_Cercle_f}

 # Centres des 2 Cercles rang 9 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cc-$X_Cercle_ea}
 d_y={$Y_Cc-$Y_Cercle_ea}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cercle_ea+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cercle_ea+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 X_Cercle_fa={$c_x2+$o_rx}
 Y_Cercle_fa={$c_y2+$o_ry}
 ## comp.  X_Cercle_fb={$c_x2-$o_rx}
 ## comp.  Y_Cercle_fb={$c_y2-$o_ry}

 # Centres des 2 Cercles rang 9 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cc-$X_Cercle_eb}
 d_y={$Y_Cc-$Y_Cercle_eb}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cercle_eb+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cercle_eb+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 ## comp.  X_Cercle_fa={$c_x2+$o_rx}
 ## comp.  Y_Cercle_fa={$c_y2+$o_ry}
 X_Cercle_fb={$c_x2-$o_rx}
 Y_Cercle_fb={$c_y2-$o_ry}

 #####

 # Rayon Cercle rang 16 Pappus
 R_Pappus={$R_Cc/$Rayon_Cercle_Exterieur}
 n_Pappus=16
 b_Pappus={$R_Cc}
 a_Pappus={$Rayon_Premier_Cercle}
 R_Cercle_g={{$a_Pappus*$b_Pappus*{$a_Pappus+$b_Pappus}}/{{$n_Pappus*$a_Pappus*$a_Pappus}+{$b_Pappus*{$a_Pappus+$b_Pappus}}}}

 Vb={$R_Cc+$R_Cercle_g}
 Va={$R_Cercle_f+$R_Cercle_g}

 # Centres des 2 Cercles rang 16 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cc-$X_Cercle_fa}
 d_y={$Y_Cc-$Y_Cercle_fa}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cercle_fa+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cercle_fa+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 X_Cercle_ga={$c_x2+$o_rx}
 Y_Cercle_ga={$c_y2+$o_ry}
 ## comp.  X_Cercle_gb={$c_x2-$o_rx}
 ## comp.  Y_Cercle_gb={$c_y2-$o_ry}

 # Centres des 2 Cercles rang 16 Pappus , adaptation des codes http://paulbourke.net/geometry/circlesphere/
 # d_x and d_y are the vertical and horizontal distances between the circle centers. dx  dy
 d_x={$X_Cc-$X_Cercle_fb}
 d_y={$Y_Cc-$Y_Cercle_fb}
 # Determine the straight-line distance between the centers. d
 d_between_centers={{{$d_y*$d_y}+{$d_x*$d_x}}^0.5}
 # Determine the distance from point 0 to point 2. a
 d_p0_p2={{{$Va*$Va}-{$Vb*$Vb}+{$d_between_centers*$d_between_centers}}/{2*$d_between_centers}}
 # Determine the coordinates of point 2. x2 y2
 c_x2={$X_Cercle_fb+{$d_x*$d_p0_p2/$d_between_centers}}
 c_y2={$Y_Cercle_fb+{$d_y*$d_p0_p2/$d_between_centers}}
 # Determine the distance from point 2 to either of the intersection points. h
 d_h={{{$Va*$Va}-{$d_p0_p2*$d_p0_p2}}^0.5}
 # Now determine the offsets of the intersection points from point 2. rx  ry
 o_rx={-$d_y*$d_h/$d_between_centers}
 o_ry={$d_x*$d_h/$d_between_centers}
 # Determine the absolute intersection points.
 ## comp.  X_Cercle_ga={$c_x2+$o_rx}
 ## comp.  Y_Cercle_ga={$c_y2+$o_ry}
 X_Cercle_gb={$c_x2-$o_rx}
 Y_Cercle_gb={$c_y2-$o_ry}

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Couleurs_aleatoires==1
  R_CE={round(u)*255}
  V_CE={round(u)*255}
  B_CE={round(u)*255}
  R_PC={round(u)*255}
  V_PC={round(u)*255}
  B_PC={round(u)*255}
  R_c={round(u)*255}
  V_c={round(u)*255}
  B_c={round(u)*255}
  R_d={round(u)*255}
  V_d={round(u)*255}
  B_d={round(u)*255}
  R_e={round(u)*255}
  V_e={round(u)*255}
  B_e={round(u)*255}
  R_f={round(u)*255}
  V_f={round(u)*255}
  B_f={round(u)*255}
  R_g={round(u)*255}
  V_g={round(u)*255}
  B_g={round(u)*255}
  R_h={round(u)*255}
  V_h={round(u)*255}
  B_h={round(u)*255}
  R_i={round(u)*255}
  V_i={round(u)*255}
  B_i={round(u)*255}
  R_j={round(u)*255}
  V_j={round(u)*255}
  B_j={round(u)*255}
  R_k={round(u)*255}
  V_k={round(u)*255}
  B_k={round(u)*255}
 endif
 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

  ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-1] {$X+$X_Cb},{$Y+$Y_Cb},$Rayon_Premier_Cercle,$Rayon_Premier_Cercle,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours

  ellipse[-1] {$X+$X_Cc},{$Y+$Y_Cc},$R_Cc,$R_Cc,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours

  ellipse[-1] {$X+$X_Cercle_da},{$Y+$Y_Cercle_da},$R_Cercle_d,$R_Cercle_d,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-1] {$X+$X_Cercle_db},{$Y+$Y_Cercle_db},$R_Cercle_d,$R_Cercle_d,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours

  ellipse[-1] {$X+$X_Cercle_ea},{$Y+$Y_Cercle_ea},$R_Cercle_e,$R_Cercle_e,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-1] {$X+$X_Cercle_eb},{$Y+$Y_Cercle_eb},$R_Cercle_e,$R_Cercle_e,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours

  ellipse[-1] {$X+$X_Cercle_fa},{$Y+$Y_Cercle_fa},$R_Cercle_f,$R_Cercle_f,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-1] {$X+$X_Cercle_fb},{$Y+$Y_Cercle_fb},$R_Cercle_f,$R_Cercle_f,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours

  ellipse[-1] {$X+$X_Cercle_ga},{$Y+$Y_Cercle_ga},$R_Cercle_g,$R_Cercle_g,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  ellipse[-1] {$X+$X_Cercle_gb},{$Y+$Y_Cercle_gb},$R_Cercle_g,$R_Cercle_g,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours

 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

  ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
  ellipse[-1] {$X+$X_Cb},{$Y+$Y_Cb},$Rayon_Premier_Cercle,$Rayon_Premier_Cercle,0,1,$R_PC,$V_PC,$B_PC,$A_PC

  ellipse[-1] {$X+$X_Cc},{$Y+$Y_Cc},$R_Cc,$R_Cc,0,1,$R_c,$V_c,$B_c,$A_c

  ellipse[-1] {$X+$X_Cercle_da},{$Y+$Y_Cercle_da},$R_Cercle_d,$R_Cercle_d,0,1,$R_d,$V_d,$B_d,$A_d
  ellipse[-1] {$X+$X_Cercle_db},{$Y+$Y_Cercle_db},$R_Cercle_d,$R_Cercle_d,0,1,$R_e,$V_e,$B_e,$A_e

  ellipse[-1] {$X+$X_Cercle_ea},{$Y+$Y_Cercle_ea},$R_Cercle_e,$R_Cercle_e,0,1,$R_f,$V_f,$B_f,$A_f
  ellipse[-1] {$X+$X_Cercle_eb},{$Y+$Y_Cercle_eb},$R_Cercle_e,$R_Cercle_e,0,1,$R_g,$V_g,$B_g,$A_g

  ellipse[-1] {$X+$X_Cercle_fa},{$Y+$Y_Cercle_fa},$R_Cercle_f,$R_Cercle_f,0,1,$R_h,$V_h,$B_h,$A_h
  ellipse[-1] {$X+$X_Cercle_fb},{$Y+$Y_Cercle_fb},$R_Cercle_f,$R_Cercle_f,0,1,$R_i,$V_i,$B_i,$A_i

  ellipse[-1] {$X+$X_Cercle_ga},{$Y+$Y_Cercle_ga},$R_Cercle_g,$R_Cercle_g,0,1,$R_j,$V_j,$B_j,$A_j
  ellipse[-1] {$X+$X_Cercle_gb},{$Y+$Y_Cercle_gb},$R_Cercle_g,$R_Cercle_g,0,1,$R_k,$V_k,$B_k,$A_k

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##      FIN Cercles_Tangents_Dans_Cercle       ##
##                                             ##
#################################################


#################################################
##                                             ##
##           Annular_Steiner_Chains            ##
##                                             ##
#################################################

# 2015/03/08 menu , Rayon_Cercle_Exterieur en fonction de w ou h
# 2014/04/24 blend
# 2014/03/24 ajout des options contours
# origine 2014/03/23
# 2016/02/02 {round(u)*255}
# 2016/12/20 gmic 1.8.0 fx_noise
#@gui Annular Steiner Chains : samj_Annular_Steiner_Chains, samj_Annular_Steiner_Chains(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Steiner_chain","http://en.wikipedia.org/wiki/Steiner_chain")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle Extérieur / Radius Outer Circle A (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Nb Cercles Extérieurs / Circles Surrounding  = int(6,3,360)
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = choice(1,"Sans","CE CI CA","CE CI CA CC","CE CI CA CC CT","CE CI CA CT","CE CA","CI CA","CA")
#@gui : Cercle Extérieur / Exterior Circle A = color(255,255,0,127)
#@gui : Cercle Centre  / Centre Circle B = color(64,192,128,127)
#@gui : Cercle / Circle C = color(0,255,0,127)
#@gui : Cercle / Circle D = color(0,0,255,127)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Annular_Steiner_Chains :
 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 if $3>0
  Rayon_Cercle_Exterieur={round({{w}*$3/{100}})}
 else
  Rayon_Cercle_Exterieur={round({-{h}*$3/{100}})}
 endif
 Nb_Circles_Surrounding=$4
 Angle_inclinaison=$5

 R_Contours=$6
 V_Contours=$7
 B_Contours=$8
 A_Contours=$9

 Affichage_Contours=$10
 R_CE=$11
 V_CE=$12
 B_CE=$13
 A_CE=$14

 R_PC=$15
 V_PC=$16
 B_PC=$17
 A_PC=$18

 R_c=$19
 V_c=$20
 B_c=$21
 A_c=$22

 R_d=$23
 V_d=$24
 B_d=$25
 A_d=$26

 Couleurs_aleatoires=$27
 Inversions=$28
 Flou=$29
 Dilatation=$30
 Deformation=$31
 Bruit=$32
 Ombre=$33
 X_Ombre=$34
 Y_Ombre=$35
 Smoothness_Ombre=$36
 Curvature_Ombre=$37
 Compensation_Decalage_Ombre_X=$38
 Compensation_Decalage_Ombre_Y=$39
 Canal_Alpha=$40

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Angle_Theta={pi/$Nb_Circles_Surrounding}
 Rayon_Cercle_Centre={{$Rayon_Cercle_Exterieur*{1-{sin($Angle_Theta)}}}/{{1+{sin($Angle_Theta)}}}}
 Rayon_Cercles_Ext={{$Rayon_Cercle_Exterieur-$Rayon_Cercle_Centre}/2}
 Rayon_Centres_C_Ext={$Rayon_Cercle_Centre+$Rayon_Cercles_Ext}
 Rayon_Tang={{{$Rayon_Centres_C_Ext*$Rayon_Centres_C_Ext}-{$Rayon_Cercles_Ext*$Rayon_Cercles_Ext}}^0.5}
 Nb_boucles=0
 X_ext=0
 Y_ext=0
 Angle=0

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Couleurs_aleatoires==1
  R_CE={round(u)*255}
  V_CE={round(u)*255}
  B_CE={round(u)*255}
  R_PC={round(u)*255}
  V_PC={round(u)*255}
  B_PC={round(u)*255}
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

  if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==5
   ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==6
   ellipse[-1] $X,$Y,$Rayon_Cercle_Centre,$Rayon_Cercle_Centre,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Affichage_Contours==2||$Affichage_Contours==3 # cercle des centres
   ellipse[-1] $X,$Y,$Rayon_Centres_C_Ext,$Rayon_Centres_C_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Affichage_Contours==3||$Affichage_Contours==4 # cercle des tang.
   ellipse[-1] $X,$Y,$Rayon_Tang,$Rayon_Tang,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

  ellipse[-1] $X,$Y,$Rayon_Cercle_Exterieur,$Rayon_Cercle_Exterieur,0,1,$R_CE,$V_CE,$B_CE,$A_CE
  ellipse[-1] $X,$Y,$Rayon_Cercle_Centre,$Rayon_Cercle_Centre,0,1,$R_PC,$V_PC,$B_PC,$A_PC

 repeat $Nb_Circles_Surrounding
  Angle={$Nb_boucles*{360/$Nb_Circles_Surrounding}}
  X_ext={$X+{$Rayon_Centres_C_Ext*{cos({pi/180*{$Angle+$Angle_inclinaison}})}}}
  Y_ext={$Y+{$Rayon_Centres_C_Ext*{sin({pi/180*{$Angle+$Angle_inclinaison}})}}}
  Nb_boucles={$Nb_boucles+1}
  if $Couleurs_aleatoires==1
   R_c={round(u)*255}
   V_c={round(u)*255}
   B_c={round(u)*255}
   R_d={round(u)*255}
   V_d={round(u)*255}
   B_d={round(u)*255}
  endif
  if ($Nb_Circles_Surrounding%2)==0
   if ($Nb_boucles%2)==0
    ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_c,$V_c,$B_c,$A_c
   else
    ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_d,$V_d,$B_d,$A_d
   endif
  else
   ellipse[-1] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,$R_c,$V_c,$B_c,$A_c
  endif
  if $Affichage_Contours>0
   ellipse[-2] $X_ext,$Y_ext,$Rayon_Cercles_Ext,$Rayon_Cercles_Ext,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
 done

 if $Affichage_Contours>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0

 #text_outline[-1] {2*$Rayon_Cercle_Exterieur},10,10,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Cercles_Ext},10,60,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Centres_C_Ext},10,110,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Tang},10,160,64,1,1,255,255,255
 #text_outline[-1] {2*$Rayon_Cercle_Centre},10,210,64,1,1,255,255,255

#################################################
##                                             ##
##         FIN Annular_Steiner_Chains          ##
##                                             ##
#################################################


#################################################
##                                             ##
##              Hawaiian_Earring               ##
##                                             ##
#################################################

# 2015/03/06 modification menu
# 2014/04/24 blend
# 2016/02/02 {round(u)*255}
# 2016/12/20 gmic 1.8.0 fx_noise
#@gui Hawaiian Earring : samj_Hawaiian_Earring, samj_Hawaiian_Earring(1)
#@gui :_=link("http://en.wikipedia.org/wiki/Hawaiian_earring","http://en.wikipedia.org/wiki/Hawaiian_earring")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Cercle A / Circle A Radius (%) = float(40,1,200)
#@gui : Nb Cercles / Circles = int(6,2,25)
#@gui : Type n = choice(0,"Inc 1","Lin 0.1","Lin 0.2","Lin 0.3","Rand")
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(1)
#@gui : Cercle A / Circle A = color(255,255,0,127)
#@gui : Cercles B / Circles B = color(0,0,255,127)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Miroir /  Mirror = choice(0,"Sans - Wihout"," X "," Y "," X Y ")
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Hawaiian_Earring :

 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Rayon_Cercle_Exterieur={round({{{w}+{h}}*$3/200})}
 Nb_Circles=$4
 Type_n=$5
 Angle_inclinaison=$6

 R_Contours=$7
 V_Contours=$8
 B_Contours=$9
 A_Contours=$10

 Affichage_Contours=$11

 R_a=$12
 V_a=$13
 B_a=$14
 A_a=$15

 R_b=$16
 V_b=$17
 B_b=$18
 A_b=$19

 Couleurs_aleatoires=$20
 Inversions=$21
 Flou=$22
 Dilatation=$23
 Deformation=$24
 Bruit=$25
 Ombre=$26
 X_Ombre=$27
 Y_Ombre=$28
 Smoothness_Ombre=$29
 Curvature_Ombre=$30
 Compensation_Decalage_Ombre_X=$31
 Compensation_Decalage_Ombre_Y=$32
 Canal_Alpha=$33

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 X_Cercle_A_Imprimer=$X
 Y_Cercle_A_Imprimer=$Y
 Rayon_Centre_Cercle_A_Imprimer=0
 Rayon_Cercle_A_Imprimer=$Rayon_Cercle_Exterieur

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours==1
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 repeat $Nb_Circles
  Nb_boucles={$Nb_boucles+1}
  if $Couleurs_aleatoires==1
   R_a={round(u)*255}
   V_a={round(u)*255}
   B_a={round(u)*255}
   R_b={round(u)*255}
   V_b={round(u)*255}
   B_b={round(u)*255}
  endif

  if ($Nb_boucles%2)==0
   ellipse[-1] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,$R_a,$V_a,$B_a,$A_a
  else
   ellipse[-1] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,$R_b,$V_b,$B_b,$A_b
  endif

  if $Affichage_Contours==1
   ellipse[-2] $X_Cercle_A_Imprimer,$Y_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,$Rayon_Cercle_A_Imprimer,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  if $Type_n==0
   Rayon_Cercle_A_Imprimer={$Rayon_Cercle_Exterieur/{$Nb_boucles+1}}
  elif $Type_n==1
   Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.1}}
  elif $Type_n==2
   Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.2}}
  elif $Type_n==3
   Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*0.3}}
  elif $Type_n==4
   Rayon_Cercle_A_Imprimer={$Rayon_Cercle_A_Imprimer-{$Rayon_Cercle_A_Imprimer*{u(0.1,0.3)}}}
  endif

  Rayon_Centre_Cercle_A_Imprimer={$Rayon_Cercle_Exterieur-$Rayon_Cercle_A_Imprimer}
  X_Cercle_A_Imprimer={$X-{$Rayon_Centre_Cercle_A_Imprimer*{cos(pi/180*$Angle_inclinaison)}}}
  Y_Cercle_A_Imprimer={$Y-{$Rayon_Centre_Cercle_A_Imprimer*{sin(pi/180*$Angle_inclinaison)}}}

 done

 if $Affichage_Contours==1
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0

#################################################
##                                             ##
##            FIN Hawaiian_Earring             ##
##                                             ##
#################################################


#################################################
##                                             ##
##            Rectangles_Adjacents             ##
##                                             ##
#################################################

# 2015/03/06 modification menu
# 2014/04/24 blend
# Script inspiré et adapté de Hawaiian_Earring
# 2016/02/02 {round(u)*255}

#@gui Adjacent Rectangles : samj_Rectangles_Adjacents, samj_Rectangles_Adjacents(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X Haut Gauche / Top Left = float(10,-100,100)
#@gui : Position Y Haut Gauche / Top Left = float(10,-100,100)
#@gui : Position X Bas Droite / Down Right = float(80,0,100)
#@gui : Position Y Bas Droite / Down Right = float(80,0,100)
#@gui : Type / Location Contact = choice(0,"Haut - Top","Bas - Down","Gauche - Left","Droite - Right")
#@gui : Position Contact = float(50,0,100)
#@gui : Nb Rectangles = int(6,2,25)
#@gui : Type n = choice(0,"Inc 1","Lin 0.1","Lin 0.2","Lin 0.3","Rand","M1","M2")
#@gui : Angle Inclinaison / Tilt = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage / Display Contours = bool(1)
#@gui : Rectangle A = color(255,255,0,127)
#@gui : Rectangle B = color(0,0,255,127)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Miroir /  Mirror = choice(0,"Sans - Wihout"," X "," Y "," X Y ")
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Rectangles_Adjacents :
 X_Haut_Gauche=$1
 Y_Haut_Gauche=$2
 X_Bas_Droite=$3
 Y_Bas_Droite=$4
 Type_Contact=$5
 Position_Contact=$6
 Nb_Rectangles=$7
 Type_n=$8
 Angle_inclinaison=$9

 R_Contours=$10
 V_Contours=$11
 B_Contours=$12
 A_Contours=$13

 Affichage_Contours=$14

 R_a=$15
 V_a=$16
 B_a=$17
 A_a=$18

 R_b=$19
 V_b=$20
 B_b=$21
 A_b=$22

 Couleurs_aleatoires=$23
 Inversions=$24
 Flou=$25
 Dilatation=$26
 Deformation=$27
 Bruit=$28
 Ombre=$29
 X_Ombre=$30
 Y_Ombre=$31
 Smoothness_Ombre=$32
 Curvature_Ombre=$33
 Compensation_Decalage_Ombre_X=$34
 Compensation_Decalage_Ombre_Y=$35
 Canal_Alpha=$36

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0

 Dimension_Image_Rotation={round({{{{$Largeur_Origine*$Largeur_Origine}+{$Hauteur_Origine*$Hauteur_Origine}}^0.5}+2})}
 Decalage_X={round({{$Dimension_Image_Rotation-$Largeur_Origine}/2})}
 Decalage_Y={round({{$Dimension_Image_Rotation-$Hauteur_Origine}/2})}
 X_H_G_origine={$Decalage_X+{round({$Largeur_Origine*{$X_Haut_Gauche/100}})}}
 Y_H_G_origine={$Decalage_Y+{round({$Hauteur_Origine*{$Y_Haut_Gauche/100}})}}
 Largeur_Rectangle_origine={round({$Largeur_Origine*{$X_Bas_Droite/100}})}
 Hauteur_Rectangle_origine={round({$Hauteur_Origine*{$Y_Bas_Droite/100}})}
 Largeur_A_Imprimer=$Largeur_Rectangle_origine
 Hauteur_A_Imprimer=$Hauteur_Rectangle_origine

 if $Type_Contact==0 #h
  X_Contact={$X_H_G_origine+{round({$Largeur_Rectangle_origine*{$Position_Contact/100}})}}
  Y_Contact=$Y_H_G_origine
 elif $Type_Contact==1 #b
  X_Contact={$X_H_G_origine+{round({$Largeur_Rectangle_origine*{$Position_Contact/100}})}}
  Y_Contact={$Y_H_G_origine+$Hauteur_Rectangle_origine}
 elif $Type_Contact==2 #g
  X_Contact=$X_H_G_origine
  Y_Contact={$Y_H_G_origine+{round({$Hauteur_Rectangle_origine*{$Position_Contact/100}})}}
 elif $Type_Contact==3 #d
  X_Contact={$X_H_G_origine+$Largeur_Rectangle_origine}
  Y_Contact={$Y_H_G_origine+{round({$Hauteur_Rectangle_origine*{$Position_Contact/100}})}}
 endif

 X_H_G_A_Imprimer=$X_H_G_origine
 Y_H_G_A_Imprimer=$Y_H_G_origine

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours==1
  $Dimension_Image_Rotation,$Dimension_Image_Rotation,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Dimension_Image_Rotation,$Dimension_Image_Rotation,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},{$Dimension_Image_Rotation-1},0,{$Dimension_Image_Rotation-1},1,0xFFFFFFFF,0,0,0,1 endif

 repeat $Nb_Rectangles
  Nb_boucles={$Nb_boucles+1}
  if $Couleurs_aleatoires==1
   R_a={round(u)*255}
   V_a={round(u)*255}
   B_a={round(u)*255}
   R_b={round(u)*255}
   V_b={round(u)*255}
   B_b={round(u)*255}
  endif

  if ($Nb_boucles%2)==0
   polygon[-1] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,$R_a,$V_a,$B_a,$A_a
  else
   polygon[-1] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,$R_b,$V_b,$B_b,$A_b
  endif

  if $Affichage_Contours==1
   polygon[-2] 4,$X_H_G_A_Imprimer,$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},$Y_H_G_A_Imprimer,{$X_H_G_A_Imprimer+$Largeur_A_Imprimer},{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},$X_H_G_A_Imprimer,{$Y_H_G_A_Imprimer+$Hauteur_A_Imprimer},1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  if $Type_n==0
   Largeur_A_Imprimer={$Largeur_Rectangle_origine/{$Nb_boucles+1}}
   Hauteur_A_Imprimer={$Hauteur_Rectangle_origine/{$Nb_boucles+1}}
  elif $Type_n==1
   Largeur_A_Imprimer={$Largeur_A_Imprimer*0.9}
   Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.9}
  elif $Type_n==2
   Largeur_A_Imprimer={$Largeur_A_Imprimer*0.8}
   Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.8}
  elif $Type_n==3
   Largeur_A_Imprimer={$Largeur_A_Imprimer*0.7}
   Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.7}
  elif $Type_n==4
   Largeur_A_Imprimer={$Largeur_A_Imprimer*{u(0.7,0.9)}}
   Hauteur_A_Imprimer={$Hauteur_A_Imprimer*{u(0.7,0.9)}}
  elif $Type_n==5
   Largeur_A_Imprimer={$Largeur_Rectangle_origine/{$Nb_boucles+1}}
   Hauteur_A_Imprimer={$Hauteur_A_Imprimer*0.9}
  elif $Type_n==6
   Largeur_A_Imprimer={$Largeur_A_Imprimer*0.9}
   Hauteur_A_Imprimer={$Hauteur_Rectangle_origine/{$Nb_boucles+1}}
  endif

  if $Type_Contact==0 #h
   X_H_G_A_Imprimer={$X_Contact-{$Largeur_A_Imprimer/2}}
   Y_H_G_A_Imprimer=$Y_Contact
  elif $Type_Contact==1 #b
   X_H_G_A_Imprimer={$X_Contact-{$Largeur_A_Imprimer/2}}
   Y_H_G_A_Imprimer={$Y_Contact-$Hauteur_A_Imprimer}
  elif $Type_Contact==2 #g
   X_H_G_A_Imprimer=$X_Contact
   Y_H_G_A_Imprimer={$Y_Contact-{$Hauteur_A_Imprimer/2}}
  elif $Type_Contact==3 #d
   X_H_G_A_Imprimer={$X_Contact-$Largeur_A_Imprimer}
   Y_H_G_A_Imprimer={$Y_Contact-{$Hauteur_A_Imprimer/2}}
  endif

 done

 if $Affichage_Contours==1
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 if $Angle_inclinaison>0 rotate[-1] $Angle_inclinaison,1,0,{{w}/2},{{h}/2} endif

 crop[-1] {{{w}-$Largeur_Origine}/2},{{{h}-$Hauteur_Origine}/2},{$Largeur_Origine+{{{w}-$Largeur_Origine-1}/2}-1},{$Hauteur_Origine+{{{h}-$Hauteur_Origine-1}/2}-1}

 blend[-1,-2] alpha,1,0
#################################################
##                                             ##
##          FIN Rectangles_Adjacents           ##
##                                             ##
#################################################


#################################################
##                                             ##
##          Linear_Gradient_CIE_Lab            ##
##                                             ##
#################################################

# 2014/04/28 limites Lab -128 127
# 2015/03/02 Swap colors = bool(0)  fonctionne avec G'MIC version 1.6.1.0 beta

#@gui Gradient CIE Lab [Linear] : samj_Linear_Gradient_CIE_Lab, samj_Linear_Gradient_CIE_Lab(1)
#@gui :_=link("http://samjcreations.blogspot.ca","http://samjcreations.blogspot.ca")
#@gui :_=separator()
#@gui :_=note("<small>Dégradé / Gradient CIE Lab</small>")
#@gui : Type H / V = choice(0,"H","V")
#@gui : Swap colors = bool(0)
#@gui : Starting color A = color(240,40,160,255)
#@gui : Ending color B = color(240,240,40,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2020/10/24</i>.</small>")

samj_Linear_Gradient_CIE_Lab :

 Type_Degrade=$1
 Swap_colors=$2
 Ra=$3
 Ga=$4
 Ba=$5
 Aa=$6
 Rb=$7
 Gb=$8
 Bb=$9
 Ab=$10

 if $Swap_colors==1
  Ra=$7
  Ga=$8
  Ba=$9
  Aa=$10
  Rb=$3
  Gb=$4
  Bb=$5
  Ab=$6
 endif

 # Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
 # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 # couleur a Linear RGB

 nt_Ra={$Ra/255}
 nt_Ga={$Ga/255}
 nt_Ba={$Ba/255}

 if $nt_Ra>0.04045
  nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
  nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
  nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
  nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
  nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
  nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}
 #Observateur. = 2°, Illuminant = D65 sRGB
 Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
 Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
 Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}

  # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php

 Xca=$Xa
 Yca=$Ya
 Zca=$Za

 ref_Xa=95.047
 ref_Ya=100.000
 ref_Za=108.883
 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
  nt_Xa={($nt_Xa)^{1/3}}
 else
  nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
  nt_Ya={($nt_Ya)^{1/3}}
 else
  nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
  nt_Za={($nt_Za)^{1/3}}
 else
  nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_La={{116*$nt_Ya}-16}
 CIE_aa={500*{$nt_Xa-$nt_Ya}}
 CIE_ba={200*{$nt_Ya-$nt_Za}}

 # couleur b Linear RGB

 nt_Ra={$Rb/255}
 nt_Ga={$Gb/255}
 nt_Ba={$Bb/255}

 if $nt_Ra>0.04045
  nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
  nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
  nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
  nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
  nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
  nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}
 #Observateur. = 2°, Illuminant = D65 sRGB
 Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
 Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
 Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}

  # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php

 Xca=$Xb
 Yca=$Yb
 Zca=$Zb

 ref_Xa=95.047
 ref_Ya=100.000
 ref_Za=108.883
 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
  nt_Xa={($nt_Xa)^{1/3}}
 else
  nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
  nt_Ya={($nt_Ya)^{1/3}}
 else
  nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
  nt_Za={($nt_Za)^{1/3}}
 else
  nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_Lb={{116*$nt_Ya}-16}
 CIE_ab={500*{$nt_Xa-$nt_Ya}}
 CIE_bb={200*{$nt_Ya-$nt_Za}}

 ######

 {w},{h},1,4
 rm[-2]
 Nb_Boucles=0
 Decalage_L=0
 Decalage_a=0
 Decalage_b=0

 if $Type_Degrade==0
  Dimensions={w}
  Inc_L={{$CIE_La-$CIE_Lb}/{w}}
  Inc_a={{$CIE_aa-$CIE_ab}/{w}}
  Inc_b={{$CIE_ba-$CIE_bb}/{w}}
  Inc_Alpha={{$Ab-$Aa}/{w}}
 elif $Type_Degrade==1
  Dimensions={h}
  Inc_L={{$CIE_La-$CIE_Lb}/{h}}
  Inc_a={{$CIE_aa-$CIE_ab}/{h}}
  Inc_b={{$CIE_ba-$CIE_bb}/{h}}
  Inc_Alpha={{$Ab-$Aa}/{h}}
 endif

 repeat $Dimensions

  Aa={$Aa+$Inc_Alpha}
  if $Aa>255 Aa=255 endif
  if $Aa<0 Aa=0 endif
  CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
  CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
  CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
  if $CIE_Lca>100 CIE_Lca=100 endif
  if $CIE_Lca<0 CIE_Lca=0 endif
  if $CIE_aca>127 CIE_aca=127 endif
  if $CIE_aca<-128 CIE_aca=-128 endif
  if $CIE_bca>127 CIE_bca=127 endif
  if $CIE_bca<-128 CIE_bca=-128 endif

  # Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php

  nt_Yca={{$CIE_Lca+16}/116}
  nt_Xca={$CIE_aca/500+$nt_Yca}
  nt_Zca={$nt_Yca-$CIE_bca/200}
  if {($nt_Yca)^3}>0.008856
   nt_Yca={($nt_Yca)^3}
  else
   nt_Yca={{$nt_Yca-16/116}/7.787}
  endif
  if {($nt_Xca)^3}>0.008856
   nt_Xca={($nt_Xca)^3}
  else
   nt_Xca={{$nt_Xca-16/116}/7.787}
  endif
  if {($nt_Zca)^3}>0.008856
   nt_Zca={($nt_Zca)^3}
  else
   nt_Zca={{$nt_Zca-16/116}/7.787}
  endif
  ref_Xca=95.047
  ref_Yca=100.000
  ref_Zca=108.883
  Xca={$ref_Xca*$nt_Xca}
  Yca={$ref_Yca*$nt_Yca}
  Zca={$ref_Zca*$nt_Zca}

  # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
  # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html

  vcXa=$Xca
  vcYa=$Yca
  vcZa=$Zca
  nt_X={$vcXa/100} # X compris entre 0 et  95.047      ( Observateur = 2°, Illuminant = D65 )
  nt_Y={$vcYa/100} # Y compris entre 0 et 100.000
  nt_Z={$vcZa/100} # Z compris entre 0 et 108.883
  nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
  nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
  nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
  if $nt_R>0.0031308
   nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
  else
   nt_R={12.92*$nt_R}
  endif
  if $nt_G>0.0031308
   nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
  else
   nt_G={12.92*$nt_G}
  endif
  if $nt_B>0.0031308
   nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
  else
   nt_B={12.92*$nt_B}
  endif

  Rconv={$nt_R*255}
  Gconv={$nt_G*255}
  Bconv={$nt_B*255}
  if $Rconv>255 Rconv=255 endif
  if $Rconv<0 Rconv=0 endif
  if $Gconv>255 Gconv=255 endif
  if $Gconv<0 Gconv=0 endif
  if $Bconv>255 Bconv=255 endif
  if $Bconv<0 Bconv=0 endif

  if $Type_Degrade==0
   line[-1] $Nb_Boucles,0,$Nb_Boucles,{{h}-1},1,$Rconv,$Gconv,$Bconv,$Aa
  elif $Type_Degrade==1
   line[-1] 0,$Nb_Boucles,{{w}-1},$Nb_Boucles,1,$Rconv,$Gconv,$Bconv,$Aa
  endif

  Nb_Boucles={$Nb_Boucles+1}
 done

#################################################
##                                             ##
##        FIN Linear_Gradient_CIE_Lab          ##
##                                             ##
#################################################


#################################################
##                                             ##
##       Shape_Linear_Gradient_CIE_Lab         ##
##                                             ##
#################################################

# 2014/04/29 limites Lab -128 127
# 2014/04/28 modification test if {{$Type_Degrade==4}||{$Type_Degrade==5}}  ajout Xf & Yf
#@gui Gradient CIE Lab [Shape] : samj_Shape_Linear_Gradient_CIE_Lab, samj_Shape_Linear_Gradient_CIE_Lab(1)
#@gui :_=link("http://samjcreations.blogspot.ca","http://samjcreations.blogspot.ca")
#@gui :_=note("Dégradé / Gradient CIE Lab")
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="red">Starting Point / Diameter :</span></b></small>")
#@gui : X0 = float(10,0,100)
#@gui : Y0 = float(10,0,100)
#@gui :_=note("<small><b><span foreground="blue">Ending Point / Center :</span></b></small>")
#@gui : X1 = float(90,0,100)
#@gui : Y1 = float(90,0,100)
#@gui :_=note("<small><b><span foreground="black">Parameters :</span></b></small>")
#@gui : Shape = choice(2,"Linear H","Linear V","Square","Square Overflow","Circle X0","Circle X0+YO")
#@gui : Swap colors = bool(0)
#@gui : Starting color A = color(240,40,160,255)
#@gui : Ending color B = color(240,240,40,255)
#@gui : Background = choice(0,"Image","Transparent","Color")
#@gui : Background color = color(0,0,0,255)
#@gui : Examples = choice(0,"None","10 10 90 90 Linear H","10 10 90 90 Linear V","10 10 90 90 Square","10 10 90 90 Square Overflow","40 40 50 50 Circle X0","40 40 50 50 Circle X0+YO","71 71 100 100 Circle X0+YO")
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2020/10/24</i>.</small>")

samj_Shape_Linear_Gradient_CIE_Lab :

 Xo={round({{w}/100*$1})}
 Yo={round({{h}/100*$2})}
 Xf={round({{w}/100*$3})}
 Yf={round({{h}/100*$4})}
 Type_Degrade=$5
 Swap_colors=$6
 Ra=$7
 Ga=$8
 Ba=$9
 Aa=$10
 Rb=$11
 Gb=$12
 Bb=$13
 Ab=$14
 Background=$15
 Rback=$16
 Gback=$17
 Bback=$18
 Aback=$19
 Examples=$20

 if $Swap_colors==1
  Ra=$11
  Ga=$12
  Ba=$13
  Aa=$14
  Rb=$7
  Gb=$8
  Bb=$9
  Ab=$10
 endif

 if $Xo>$Xf
  Xo=$3
  Xf=$1
 elif $Xo==$Xf
  Xo={$Xf-1}
 endif

 if $Yo>$Yf
  Yo=$4
  Yf=$2
 elif $Yo==$Yf
  Yo={$Yf-1}
 endif

 if $Type_Degrade==4||$Type_Degrade==5
  Xo={round({{w}/100*$1})}
  Yo={round({{h}/100*$2})}
  Xf={round({{w}/100*$3})}
  Yf={round({{h}/100*$4})}
 endif

 if $Examples==1
  Xo={round({{w}*0.1})}
  Yo={round({{h}*0.1})}
  Xf={round({{w}*0.9})}
  Yf={round({{h}*0.9})}
  Type_Degrade=0
 elif $Examples==2
  Xo={round({{w}*0.1})}
  Yo={round({{h}*0.1})}
  Xf={round({{w}*0.9})}
  Yf={round({{h}*0.9})}
  Type_Degrade=1
 elif $Examples==3
  Xo={round({{w}*0.1})}
  Yo={round({{h}*0.1})}
  Xf={round({{w}*0.9})}
  Yf={round({{h}*0.9})}
  Type_Degrade=2
 elif $Examples==4
  Xo={round({{w}*0.1})}
  Yo={round({{h}*0.1})}
  Xf={round({{w}*0.9})}
  Yf={round({{h}*0.9})}
  Type_Degrade=3
 elif $Examples==5
  Xo={round({{w}*0.4})}
  Yo={round({{h}*0.4})}
  Xf={round({{w}*0.5})}
  Yf={round({{h}*0.5})}
  Type_Degrade=4
 elif $Examples==6
  Xo={round({{w}*0.4})}
  Yo={round({{h}*0.4})}
  Xf={round({{w}*0.5})}
  Yf={round({{h}*0.5})}
  Type_Degrade=5
 elif $Examples==7
  Xo={round({{w}*0.71})}
  Yo={round({{h}*0.71})}
  Xf={w}
  Yf={h}
  Type_Degrade=5
 endif

 # Conversions RGB > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php
 # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 # couleur a Linear RGB

 nt_Ra={$Ra/255}
 nt_Ga={$Ga/255}
 nt_Ba={$Ba/255}

 if $nt_Ra>0.04045
  nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
  nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
  nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
  nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
  nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
  nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}
 #Observateur. = 2°, Illuminant = D65 sRGB
 Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
 Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
 Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}

  # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php

 Xca=$Xa
 Yca=$Ya
 Zca=$Za

 ref_Xa=95.047
 ref_Ya=100.000
 ref_Za=108.883
 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
  nt_Xa={($nt_Xa)^{1/3}}
 else
  nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
  nt_Ya={($nt_Ya)^{1/3}}
 else
  nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
  nt_Za={($nt_Za)^{1/3}}
 else
  nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_La={{116*$nt_Ya}-16}
 CIE_aa={500*{$nt_Xa-$nt_Ya}}
 CIE_ba={200*{$nt_Ya-$nt_Za}}

 # couleur b Linear RGB

 nt_Ra={$Rb/255}
 nt_Ga={$Gb/255}
 nt_Ba={$Bb/255}

 if $nt_Ra>0.04045
  nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
  nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
  nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
  nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
  nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
  nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}
 #Observateur. = 2°, Illuminant = D65 sRGB
 Xb={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
 Yb={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
 Zb={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}

  # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php

 Xca=$Xb
 Yca=$Yb
 Zca=$Zb

 ref_Xa=95.047
 ref_Ya=100.000
 ref_Za=108.883
 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
  nt_Xa={($nt_Xa)^{1/3}}
 else
  nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
  nt_Ya={($nt_Ya)^{1/3}}
 else
  nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
  nt_Za={($nt_Za)^{1/3}}
 else
  nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_Lb={{116*$nt_Ya}-16}
 CIE_ab={500*{$nt_Xa-$nt_Ya}}
 CIE_bb={200*{$nt_Ya-$nt_Za}}

 ######

 if $Background==1
  {w},{h},1,4
  rm[-2]
 elif $Background==2
  {w},{h},1,4
  fill_color[-1] $Rback,$Gback,$Bback,$Aback
  rm[-2]
 endif

 Nb_Boucles=0

 if $Type_Degrade==0
  Dimensions={$Xf-$Xo}
 elif $Type_Degrade==1
  Dimensions={$Yf-$Yo}
 elif $Type_Degrade==2
  if {$Xf-$Xo}>{$Yf-$Yo}
   Dimensions={round({{$Yf-$Yo+1}/2})}
  else
   Dimensions={round({{$Xf-$Xo+1}/2})}
  endif
 elif $Type_Degrade==3
  if {$Xf-$Xo}>{$Yf-$Yo}
   Dimensions={round({{$Xf-$Xo+1}/2})}
  else
   Dimensions={round({{$Yf-$Yo+1}/2})}
  endif
 elif $Type_Degrade==4
  Dimensions=$Xo
 elif $Type_Degrade==5
  Dimensions={$Xo+$Yo}
 endif

 Inc_L={{$CIE_La-$CIE_Lb}/$Dimensions}
 Inc_a={{$CIE_aa-$CIE_ab}/$Dimensions}
 Inc_b={{$CIE_ba-$CIE_bb}/$Dimensions}
 Inc_Alpha={{$Ab-$Aa}/$Dimensions}
 Decalage_L=0
 Decalage_a=0
 Decalage_b=0

 repeat $Dimensions

  Aa={$Aa+$Inc_Alpha}
  if $Aa>255 Aa=255 endif
  if $Aa<0 Aa=0 endif
  CIE_Lca={$CIE_La+$Decalage_L-{$Nb_Boucles*$Inc_L}}
  CIE_aca={$CIE_aa+$Decalage_a-{$Nb_Boucles*$Inc_a}}
  CIE_bca={$CIE_ba+$Decalage_b-{$Nb_Boucles*$Inc_b}}
  if $CIE_Lca>100 CIE_Lca=100 endif
  if $CIE_Lca<0 CIE_Lca=0 endif
  if $CIE_aca>127 CIE_aca=127 endif
  if $CIE_aca<-128 CIE_aca=-128 endif
  if $CIE_bca>127 CIE_bca=127 endif
  if $CIE_bca<-128 CIE_bca=-128 endif

  # Conversions Lab > XYZ   http://www.newtone.fr/formules_conversion_colorimetrie.php

  nt_Yca={{$CIE_Lca+16}/116}
  nt_Xca={$CIE_aca/500+$nt_Yca}
  nt_Zca={$nt_Yca-$CIE_bca/200}
  if {($nt_Yca)^3}>0.008856
   nt_Yca={($nt_Yca)^3}
  else
   nt_Yca={{$nt_Yca-16/116}/7.787}
  endif
  if {($nt_Xca)^3}>0.008856
   nt_Xca={($nt_Xca)^3}
  else
   nt_Xca={{$nt_Xca-16/116}/7.787}
  endif
  if {($nt_Zca)^3}>0.008856
   nt_Zca={($nt_Zca)^3}
  else
   nt_Zca={{$nt_Zca-16/116}/7.787}
  endif
  ref_Xca=95.047
  ref_Yca=100.000
  ref_Zca=108.883
  Xca={$ref_Xca*$nt_Xca}
  Yca={$ref_Yca*$nt_Yca}
  Zca={$ref_Zca*$nt_Zca}

  # Conversions XYZ > Lab   http://www.newtone.fr/formules_conversion_colorimetrie.php
  # Matrices    http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html

  vcXa=$Xca
  vcYa=$Yca
  vcZa=$Zca
  nt_X={$vcXa/100} # X compris entre 0 et  95.047      ( Observateur = 2°, Illuminant = D65 )
  nt_Y={$vcYa/100} # Y compris entre 0 et 100.000
  nt_Z={$vcZa/100} # Z compris entre 0 et 108.883
  nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
  nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
  nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
  if $nt_R>0.0031308
   nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
  else
   nt_R={12.92*$nt_R}
  endif
  if $nt_G>0.0031308
   nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
  else
   nt_G={12.92*$nt_G}
  endif
  if $nt_B>0.0031308
   nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
  else
   nt_B={12.92*$nt_B}
  endif

  Rconv={$nt_R*255}
  Gconv={$nt_G*255}
  Bconv={$nt_B*255}
  if $Rconv>255 Rconv=255 endif
  if $Rconv<0 Rconv=0 endif
  if $Gconv>255 Gconv=255 endif
  if $Gconv<0 Gconv=0 endif
  if $Bconv>255 Bconv=255 endif
  if $Bconv<0 Bconv=0 endif

  if $Type_Degrade==0
   line[-1] {$Xo+$Nb_Boucles},$Yo,{$Xo+$Nb_Boucles},$Yf,1,$Rconv,$Gconv,$Bconv,$Aa
  elif $Type_Degrade==1
   line[-1] $Xo,{$Yo+$Nb_Boucles},$Xf,{$Yo+$Nb_Boucles},1,$Rconv,$Gconv,$Bconv,$Aa
  elif $Type_Degrade==2
   polygon[-1] 4,{$Xo+$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yf-$Nb_Boucles},{$Xo+$Nb_Boucles},{$Yf-$Nb_Boucles},1,0xFFFFFFFF,$Rconv,$Gconv,$Bconv,$Aa
  elif $Type_Degrade==3
   polygon[-1] 4,{$Xo+$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yo+$Nb_Boucles},{$Xf-$Nb_Boucles},{$Yf-$Nb_Boucles},{$Xo+$Nb_Boucles},{$Yf-$Nb_Boucles},1,0xFFFFFFFF,$Rconv,$Gconv,$Bconv,$Aa
  elif $Type_Degrade==4
   ellipse[-1] $Xf,$Yf,{$Dimensions-$Nb_Boucles},{$Dimensions-$Nb_Boucles},0,1,$Rconv,$Gconv,$Bconv,$Aa
  elif $Type_Degrade==5
   ellipse[-1] $Xf,$Yf,{$Dimensions-$Nb_Boucles},{$Dimensions-$Nb_Boucles},0,1,$Rconv,$Gconv,$Bconv,$Aa
  endif

  Nb_Boucles={$Nb_Boucles+1}
 done


#################################################
##                                             ##
##     FIN Shape_Linear_Gradient_CIE_Lab       ##
##                                             ##
#################################################

#################################################
##                                             ##
##                Chryzodes_en                 ##
##                                             ##
#################################################

# 2014/04/27 origine
# 2015/03/03 fx_blend[-2,-1] 1,0,1,0,1  remplace blend[-2,-1] alpha,1,1
# 2016/02/02 {round(u)*255}
# 2016/12/20 gmic 1.8.0
#@gui Chryzodes : samj_Chryzodes, samj_Chryzodes(1)
#@gui :_=link("http://www.chryzode.org/fr/ligne.htm","http://www.chryzode.org/fr/ligne.htm")
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="red">New Image</span></b></small>")
#@gui : Image Dimensions = float(100,30,400)
#@gui : Background Color = color(0,0,0,255)
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="blue">Rendering</span></b></small>")
#@gui : Examples = choice(0,"None","431/7/VC=0","353/3/VC=0","619/4/VC=0","691/12/VC=0","613/20/VC=0","358/13/VC=1","118/20/VC=1","699/6/VC=0")
#@gui : X Position (%) = float(50,0,100)
#@gui : Y Position (%) = float(50,0,100)
#@gui : External Circle Radius = float(45,10,200)
#@gui : Number of Points - Module = int(79,10,1080)
#@gui : Multiplier = int(3,3,33)
#@gui : First Point = int(1,1,1080)
#@gui : Color Straight Lines = color(240,128,64,255)
#@gui : Tilt Angle = float(0,-360,360)
#@gui : Type Straight Lines = choice(0,"Lines Inside The Circle","Over The Entire Image")
#@gui : Random Colors = choice(0,"None","Variations","Lines")
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="blue">Variations Rendering Image Filter</span></b></small>")
#@gui : Variations A = int(0,0,1080)
#@gui : Variations B = int(0,0,3)
#@gui : Variation C = bool(0)
#@gui :_=separator()
#@gui :_=note("<small><b><span foreground="blue">Changes Rendering Image Filter</span></b></small>")
#@gui : Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Deform = float(0,0,5)
#@gui : Noise = float(0,0,100)
#@gui : Draw The Circle = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2020/10/24</i>.</small>")

samj_Chryzodes :

 Dimension={round({{max({w},{h})}*$1/100})}
 R_fond=$2
 V_fond=$3
 B_fond=$4
 A_fond=$5

 Demo=$6
 X={round({$Dimension*{$7/100}})}
 Y={round({$Dimension*{$8/100}})}
 Rayon_Cercle={round({$Dimension*$9/100})}
 Nb_Points=$10
 Multiplicateur=$11
 Premier_Point=$12
 R_l=$13
 V_l=$14
 B_l=$15
 A_l=$16
 Angle_Inclinaison=$17
 Type_De_Lignes=$18
 Couleurs_aleatoires=$19
 Variations_A=$20
 Variations_B=$21
 Variations_C=$22
 Flou=$23
 Dilatation=$24
 Deformation=$25
 Bruit=$26
 Tracer_Cercle=$27

 if $Demo==1
  Nb_Points=431
  Multiplicateur=7
  Variations_A=0
  Variations_B=0
  Variations_C=0
 elif $Demo==2
  Nb_Points=353
  Multiplicateur=3
  Variations_A=0
  Variations_B=0
  Variations_C=0
 elif $Demo==3
  Nb_Points=619
  Multiplicateur=4
  Variations_A=0
  Variations_B=0
  Variations_C=0
 elif $Demo==4
  Nb_Points=691
  Multiplicateur=12
  Variations_A=0
  Variations_B=0
  Variations_C=0
 elif $Demo==5
  Nb_Points=613
  Multiplicateur=20
  Variations_A=0
  Variations_B=0
  Variations_C=0
 elif $Demo==6
  Nb_Points=358
  Multiplicateur=13
  Variations_A=0
  Variations_B=0
  Variations_C=1
 elif $Demo==7
  Nb_Points=118
  Multiplicateur=20
  Variations_A=0
  Variations_B=0
  Variations_C=1
 elif $Demo==8
  Nb_Points=699
  Multiplicateur=6
  Variations_A=0
  Variations_B=0
  Variations_C=0
  Demo=8
 endif

 Largeur_Origine={w}
 Hauteur_Origine={h}

 Angle_Base={360/$Nb_Points}
 Point_Origine=0
 Sortie_Boucle_Lignes=0
 Nb_Boucle_Lignes=0
 Nb_Boucle_Points=0

 Point_A=0
 Angle_A=0
 X_Imp_A=0
 Y_Imp_A=0

 Point_B=0
 Angle_B=0
 X_Imp_B=0
 Y_Imp_B=0

 a_Ligne=0
 b_Ligne=0
 X_Ex_a=0
 Y_Ex_a=0
 X_Ex_b=0
 Y_Ex_b=0

 if $Variations_A==0
  Boucles_Rendu=1
  Variations_A=1
 else
  Boucles_Rendu=2
 endif

 rm[-1]
 $Dimension,$Dimension,1,4
 fill_color[-1] 0,0,0,0

 Point_A=$Premier_Point
 Angle_A={$Angle_Base*$Point_A}
 X_Imp_A={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
 Y_Imp_A={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
 Point_Origine=$Point_A
 test=0

 repeat $Boucles_Rendu+$Variations_B

  if $Couleurs_aleatoires==1
    R_l={round(u)*255}
    V_l={round(u)*255}
    B_l={round(u)*255}
  endif

  do

   if $Couleurs_aleatoires==2
     R_l={round(u)*255}
     V_l={round(u)*255}
     B_l={round(u)*255}
   endif

   if $Variations_C==0
    Point_B={{$Point_A*$Multiplicateur}%$Nb_Points}
   else
    Point_B={{$Point_A*$Multiplicateur*2}%$Nb_Points}
   endif
   Angle_B={$Angle_Base*$Point_B}
   X_Imp_B={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_B+$Angle_Inclinaison}})}}}
   Y_Imp_B={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_B+$Angle_Inclinaison}})}}}

   if $Type_De_Lignes==1    # Lignes Avec Parametres sur toute l'image
    if {round({$X_Imp_A*1000000000000})}=={round({$X_Imp_B*1000000000000})}
     X_Ex_a=$X_Imp_A
     Y_Ex_a=0
     X_Ex_b=$X_Imp_B
     Y_Ex_b={$Dimension-1}
     line[-1] $X_Ex_a,$Y_Ex_a,$X_Ex_b,$Y_Ex_b,1,$R_l,$V_l,$B_l,$A_l
    else
     a_Ligne={{$Y_Imp_B-$Y_Imp_A}/{$X_Imp_B-$X_Imp_A}}
     b_Ligne={$Y_Imp_B-{$a_Ligne*$X_Imp_B}}
     X_Ex_a=0
     Y_Ex_a=$b_Ligne
     X_Ex_b={$Dimension-1}
     Y_Ex_b={{$a_Ligne*$X_Ex_b}+$b_Ligne}
     line[-1] $X_Ex_a,$Y_Ex_a,$X_Ex_b,$Y_Ex_b,1,$R_l,$V_l,$B_l,$A_l
    endif
   else
    line[-1] $X_Imp_A,$Y_Imp_A,$X_Imp_B,$Y_Imp_B,1,$R_l,$V_l,$B_l,$A_l
   endif

   # sorties
   if $Point_B==$Point_Origine Sortie_Boucle_Lignes=1 endif
   if $Nb_Boucle_Lignes>$Nb_Points*$Multiplicateur Sortie_Boucle_Lignes=1 endif
   if $Variations_C==1
    if $Nb_Boucle_Lignes>$Nb_Points Sortie_Boucle_Lignes=1 endif
   endif

   Point_A=$Point_B
   X_Imp_A=$X_Imp_B
   Y_Imp_A=$Y_Imp_B
   Nb_Boucle_Lignes={$Nb_Boucle_Lignes+1}

  while $Sortie_Boucle_Lignes==0

  Nb_Boucle_Points={$Nb_Boucle_Points+1}
  Point_A={$Premier_Point+{1/$Nb_Points*$Nb_Boucle_Points/$Variations_A}}
  Angle_A={$Angle_Base*$Point_A}
  X_Imp_A={$X+{$Rayon_Cercle*{cos({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
  Y_Imp_A={$Y+{$Rayon_Cercle*{sin({pi/180*{$Angle_A+$Angle_Inclinaison}})}}}
  Point_Origine=$Point_A
  Sortie_Boucle_Lignes=0
  Nb_Boucle_Lignes=0

 done

 if $Tracer_Cercle==1
  ellipse[-1] $X,$Y,$Rayon_Cercle,$Rayon_Cercle,0,1,0xFFFFFFFF,$R_l,$V_l,$B_l,$A_l
 endif
 if $Dilatation>1 dilate_circ[-1] $Dilatation endif
 if $Flou>0 blur[-1] $Flou,0 endif
 if $Deformation>0 deform[-1] $Deformation endif
 if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif

 $Dimension,$Dimension,1,4
 fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond

 gimp_blend_1651[-2,-1] 1,0,1,0,1

#################################################
##                                             ##
##              FIN Chryzodes_en               ##
##                                             ##
#################################################


#################################################
##                                             ##
##             Cercles_Qui_Tournent            ##
##                                             ##
#################################################

# pour la version GMIC 2.8.0 remplacer replace_color[-1] 100% par replace_color[-1] 0%
# 2015/03/05 liens vers blog supprimés, gimp_blend remplace blend, modification de l'ordre des paramètres, changement de nom : Rotating Circles remplace Cercles_Qui_Tournent.
# 2014/04/19 ajout de valeurs négatives pour Vbx Vcx Vby Vcy + modification bruit
# 2014/04/18 origine + ajout 3 exemples C D E
# 2016/02/02 {round(u)*255}

#@gui Rotating Circles : samj_Cercles_Qui_Tournent, samj_Cercles_Qui_Tournent(1)
#@gui :_=note("Cercles Qui Tournent / Rotating Circles")
#@gui :_=link("http://rouxjeanbernard.ch/AM/html/amch57.html","http://rouxjeanbernard.ch/AM/html/amch57.html")
#@gui :_=separator()
#@gui :_=note("<small>Nouvelle New Image</small>")
#@gui : Dimension Image = int(800,2,32768)
#@gui : Fond / Background = color(255,255,255,255)
#@gui :_=separator()
#@gui :_=note("<small>Exemples Examples</small>")
#@gui : Examples = choice(0,"Non No","A","B","C","D","E","F")
#@gui :_=separator()
#@gui :_=note("<small>Param. X</small>")
#@gui : Cax = float(1,0.5,2)
#@gui : Cbx = float(0.5,0.05,5)
#@gui : Ccx = float(0.33,0.05,5)
#@gui : Vbx = int(7,-50,50)
#@gui : Vcx = int(17,-50,50)
#@gui :_=separator()
#@gui :_=note("<small>Param. Y</small>")
#@gui : Cay = float(1,0.5,2)
#@gui : Cby = float(0.5,0.05,5)
#@gui : Ccy = float(0.33,0.05,5)
#@gui : Vby = int(7,-50,50)
#@gui : Vcy = int(17,-50,50)
#@gui :_=separator()
#@gui :_=note("<small>Rendu Rendering</small>")
#@gui : Égalite / Equality : Param. X & Param. Y  = bool(1)
#@gui : Théta = int(10,1,5000)
#@gui : Ligne / Line = color(0,0,0,255)
#@gui : Angle Inclinaison = float(0,-360,360)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,200)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/12/14</i>.</small>")

samj_Cercles_Qui_Tournent :
 Dimension=$1
 R_fond=$2
 V_fond=$3
 B_fond=$4
 A_fond=$5

 Exemples=$6

 Cax=$7
 Cbx=$8
 Ccx=$9
 Vbx=$10
 Vcx=$11

 Cay=$12
 Cby=$13
 Ccy=$14
 Vby=$15
 Vcy=$16

 Egalite_Param_X_Y=$17
 Theta=$18
 R_a=$19
 V_a=$20
 B_a=$21
 A_a=$22
 Angle_Rotation=$23
 Couleurs_aleatoires=$24
 Flou=$25
 Dilatation=$26
 Deformation=$27
 Bruit=$28
 Ombre=$29
 X_Ombre=$30
 Y_Ombre=$31
 Smoothness_Ombre=$32
 Curvature_Ombre=$33
 if $Exemples==1
  Egalite_Param_X_Y=1
  Cax=1
  Cbx=0.5
  Ccx=0.25
  Vbx=7
  Vcx=21
  Theta=1000
 elif $Exemples==2
  Egalite_Param_X_Y=1
  Cax=1
  Cbx=5
  Ccx=2
  Vbx=3
  Vcx=10
  Theta=4693
 elif $Exemples==3
  Egalite_Param_X_Y=0
  Cax=1
  Cbx=0.5
  Ccx=0.33
  Vbx=7
  Vcx=17
  Cay=1
  Cby=0.5
  Ccy=0.33
  Vby=11
  Vcy=17
  Theta=4886
 elif $Exemples==4
  Egalite_Param_X_Y=0
  Cax=1
  Cbx=0.5
  Ccx=0.33
  Vbx=7
  Vcx=17
  Cay=1
  Cby=0.5
  Ccy=0.33
  Vby=7
  Vcy=3
  Theta=4520
 elif $Exemples==5
  Egalite_Param_X_Y=0
  Cax=1
  Cbx=0.5
  Ccx=0.25
  Vbx=1
  Vcx=6
  Cay=0.8
  Cby=0.2
  Ccy=1
  Vby=9
  Vcy=12
  Theta=493
 elif $Exemples==6
  Egalite_Param_X_Y=1
  Cax=1
  Cbx=0.5
  Ccx=0.33
  Vbx=-5
  Vcx=17
  Theta=10
 endif

 if $Egalite_Param_X_Y==1
  Cay=$Cax
  Cby=$Cbx
  Ccy=$Ccx
  Vby=$Vbx
  Vcy=$Vcx
 endif

 rm[-1]
 $Dimension,$Dimension,1,4
 fill_color[-1] 0,0,0,0

 # tracer la courbe en couleur noire sans Antialiasing , sans Decoration ,   X(t) :  cos(t)+(0.5*cos(7*t))+((cos((3.14/2)-(17*t)))/3)  ,  Y(t) :  (sin(t)+(0.5*sin(7*t))+((sin((3.14/2)-(17*t)))/3)
 fx_equation_parametric[-1] "(cos(t)*"$Cax")+("$Cbx"*cos("$Vbx"*t))+((cos(("{pi/2}")-("$Vcx"*t)))*"$Ccx")","(sin(t)*"$Cay")+("$Cby"*sin("$Vby"*t))+((sin(("{pi/2}")-("$Vcy"*t)))*"$Ccy")",0,$Theta,$Dimension,1,1,0,0,0,0,0,0,1,0,0
 to_rgba[-1]
 replace_color[-1] 0%,0,255,255,255,255,0,0,0,0 # transparence
 replace_color[-1] 0%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a # couleur de la courbe
 if $Couleurs_aleatoires==0
  replace_color[-1] 0%,0,0,0,0,255,$R_a,$V_a,$B_a,$A_a # couleur de la courbe
 else
  $Dimension,$Dimension,1,4
  fill_color[-1] 0,0,0,0
  fx_corner_gradient[-1] {round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255,{round(u)*255},{round(u)*255},{round(u)*255},255
  blend[-1,-2] add,1,0
  to_rgba[-1]
 endif

 if $Dilatation>1 dilate_circ[-1] $Dilatation endif
 if $Flou>0 blur[-1] $Flou,0 endif
 if $Deformation>0 deform[-1] $Deformation endif
 if $Ombre>0
  drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
 endif

 if $Angle_Rotation>0 rotate[-1] $Angle_Rotation,1,0,{$Dimension/2},{$Dimension/2} endif

 $Dimension,$Dimension,1,4
 fill_color[-1] $R_fond,$V_fond,$B_fond,$A_fond

 if $Bruit>0 apply_channels[-1] "fx_noise "$Bruit",0,22,1",1 endif

 #blend[-2,-1] alpha,1,1
 gimp_blend_1651[-2,-1] 1,0,1,0,1

#################################################
##                                             ##
##           FIN Cercles_Qui_Tournent          ##
##                                             ##
#################################################


#################################################
##                                             ##
##       samj_Lignes_Epaisseur_Variable        ##
##                                             ##
#################################################

# 2015/03/05 changement de nom, modification et traduction menu
# 2014/04/12 origine Test_2_Map_Sprites
# 2016/02/02 {round(u)*255}

#@gui Lines of Varying Thickness : samj_Lignes_Epaisseur_Variable, samj_Lignes_Epaisseur_Variable(1)
#@gui :_=note("Lignes Épaisseur Variable / Lines Of Varying Thickness")
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Orientation Lignes / Lines = choice(0,"Vertical lines","Horizontal lines")
#@gui : Résolution Largeur / Width = int(32,16,64)
#@gui : Épaisseur Ligne / Line Thickness = int(3,1,7)
#@gui : Fond / Background = color(0,0,0,255)
#@gui : Ligne / Line = color(255,255,255,255)
#@gui : Inverser Fond-Ligne / Invert Background-Line = bool(0)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Resize = choice(1,"Non / No","Dim. Origines")
#@gui : Flou / Blur = int(0,0,200)
#@gui : Deblur = int(0,0,48)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation / Deform = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Lignes_Epaisseur_Variable :
 Motif_Sprite=$1
 Resolution_Largeur=$2
 Trait_Largeur=$3

 R_fond=$4
 V_fond=$5
 B_fond=$6
 A_fond=$7

 R_a=$8
 V_a=$9
 B_a=$10
 A_a=$11

 Inverser_Fond_Trait=$12
 Couleurs_aleatoires=$13
 Resize_Image=$14
 Antialiasing=$15
 R_Deblur=$16
 Dilatation=$17
 Deformation=$18
 Bruit=$19
 Ombre=$20
 X_Ombre=$21
 Y_Ombre=$22
 Smoothness_Ombre=$23
 Curvature_Ombre=$24
 Canal_Alpha=$25
 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_boucles=0
 Nb_boucles_motif=0
 Origine_Trait=0
 if $Inverser_Fond_Trait==0
  R_F=$R_fond
  V_F=$V_fond
  B_F=$B_fond
  A_F=$A_fond
  R_M=$R_a
  V_M=$V_a
  B_M=$B_a
  A_M=$A_a
 else
  R_F=$R_a
  V_F=$V_a
  B_F=$B_a
  A_F=$A_a
  R_M=$R_fond
  V_M=$V_fond
  B_M=$B_fond
  A_M=$A_fond
 endif

 Largeur_Sprite={{7*2}+{7*$Trait_Largeur}}
 Hauteur_Sprite=$Largeur_Sprite

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 resize[-1] $Resolution_Largeur,{round({$Hauteur_Origine/$Largeur_Origine*$Resolution_Largeur})}

 repeat 7

  Nb_boucles={$Nb_boucles+1}

  if $Nb_boucles==1
   if $Couleurs_aleatoires==1
    R_F={round(u)*255}
    V_F={round(u)*255}
    B_F={round(u)*255}
   endif
   $Largeur_Sprite,$Hauteur_Sprite,1,4
   fill_color[-1] $R_F,$V_F,$B_F,$A_F
  endif

  if $Couleurs_aleatoires==1
   R_F={round(u)*255}
   V_F={round(u)*255}
   B_F={round(u)*255}
   R_M={round(u)*255}
   V_M={round(u)*255}
   B_M={round(u)*255}
  endif

  $Largeur_Sprite,$Hauteur_Sprite,1,4
  fill_color[-1] $R_F,$V_F,$B_F,$A_F
  Nb_boucles_motif=0

  if $Motif_Sprite==0||$Motif_Sprite==1
   Origine_Trait={round({{$Largeur_Sprite-{$Trait_Largeur*$Nb_boucles}}/2})}
   repeat $Trait_Largeur*$Nb_boucles
    line[-1] {$Origine_Trait+$Nb_boucles_motif},0,{$Origine_Trait+$Nb_boucles_motif},{$Hauteur_Sprite-1},1,$R_M,$V_M,$B_M,$A_M
    Nb_boucles_motif={$Nb_boucles_motif+1}
   done
  endif

 done

 if $Motif_Sprite==1
  rotate[-1,-2,-3,-4,-5,-6,-7,-8] 90,0,0
 endif

 map_sprites[-1,-2,-3,-4,-5,-6,-7,-8,-9] 8,0

 if $Resize_Image==1
  resize[-1] $Largeur_Origine,$Hauteur_Origine
 endif

 if $Antialiasing>0 apply_channels[-1] "smooth "$Antialiasing",0.7,0.3,0.6,5,5,0",1 endif
 if $R_Deblur>0 apply_channels[-1] "deblur "$R_Deblur",10,20,0.1,1",1 endif
 if $Dilatation>1 dilate_circ[-1] $Dilatation endif
 if $Deformation>0 deform[-1] $Deformation endif
 if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
 if $Ombre>0
  drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
 endif
#################################################
##                                             ##
##     FIN samj_Lignes_Epaisseur_Variable      ##
##                                             ##
#################################################


################################################################
##                                                            ##
##          Ensemble Polygones /  Figures géométriques        ##
##                                                            ##
################################################################

# Idée générale
# Les polygones sont construits autour de 2 cercles concentriques.
# janvier 2014 ajout calque transparent + dilate + blend
# Dessiner un polygone version G'MIC le 29 août 2012
# 2014/04/24 blend
# 2014/07/03 modification gimp_blend
# 2015/03/08 nouvelle façon d'appeler gimp_blend, preview , dimension en % largeur ou hauteur , simplifier blend
# 2016/02/02 {round(u)*255}

#@gui Dessiner Un Polygone / Draw a Polygon : samj_dessiner_un_polygone, samj_dessiner_un_polygone(1)
#@gui :_=separator()
#@gui :_=note("<small>Polygone / Polygone</small>")
#@gui : Nombre de côtés / Number of sides = int(5,3,90)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle inclinaison = float(0,0,120)
#@gui : Rayon cercle circonscrit / Circumcircle radius (>0 W%) (<0 H%) = float(40,-400,400)
#@gui : Rayon cercle intérieur / Inner circle radius (%) = float(50,0,100)
#@gui : Remplir polygone extérieur / Fill = bool(1)
#@gui : Couleur polygone extérieur = color(255,255,0)
#@gui : Contour polygone extérieur = bool(0)
#@gui : Couleur contour polygone extérieur = color(0,0,0)
#@gui : Remplir polygone intérieur / Fill = bool(1)
#@gui : Couleur polygone intérieur = color(0,0,255)
#@gui : Contour polygone intérieur = bool(0)
#@gui : Couleur contour polygone intérieur = color(0,255,0)
#@gui : Variation de couleur / Color variation = choice("Pas de variation / No change","Couleurs aleatoires / Random Colors","Faiblement nuancee / Poorly nuanced","Moyennement nuancee / Moderately nuanced","Fortement nuancee / Highly nuanced")
#@gui :_=separator()
#@gui :_=note("<small>cercles / circles</small>")
#@gui : Remplir cercle intérieur / Fill = bool(0)
#@gui : Couleur cercle intérieur = color(127,127,127)
#@gui : Contour cercle intérieur = bool(0)
#@gui : Couleur contour cercle intérieur = color(0,0,0)
#@gui : Remplir cercle extérieur / Fill = bool(0)
#@gui : Couleur cercle extérieur = color(255,255,255)
#@gui : Contour cercle extérieur = bool(0)
#@gui : Couleur contour cercle extérieur = color(0,0,0)
#@gui : Dilatation (épaisseur) = int(1,1,48)
#@gui :_=separator()
#@gui :_=note("<small>Transparence / Transparency</small>")
#@gui : Transparence des couleurs / Color transparency = int(255,0,255)
#@gui :_=separator()
#@gui :_=note("<small>Divers / Foo</small>")
#@gui : Flou / Blur = float(0,0,10)
#@gui : Spread = float(0,0,10)
#@gui : Déformation = float(0,0,25)
#@gui :_=separator()
#@gui :_=note("<small>Mélange / Blend</small>")
#@gui : Mode = choice(1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_dessiner_un_polygone:
 Nombre_de_cotes=$1
 X_centre_cercle_circonscrit={$2/100*w}
 Y_centre_cercle_circonscrit={$3/100*h}
 Angle_inclinaison=$4

 if $5>0
  Rayon_cercle_circonscrit={round({{w}*$5/{100}})}
 else
  Rayon_cercle_circonscrit={round({-{h}*$5/{100}})}
 endif

 Rayon_cercle_interieur={round({$Rayon_cercle_circonscrit/100*$6})}

 Remplir_polygone_exterieur=$7

 ## ATTENTION variables $8,$9,$10 utilisées + loin dans le script
 R_Couleur_polygone_exterieur=$8
 V_Couleur_polygone_exterieur=$9
 B_Couleur_polygone_exterieur=$10

 Contour_polygone_exterieur=$11
 R_Couleur_contour_polygone_exterieur=$12
 V_Couleur_contour_polygone_exterieur=$13
 B_Couleur_contour_polygone_exterieur=$14

 Remplir_polygone_interieur=$15

 ## ATTENTION variables $16,$17,$18 utilisées + loin dans le script
 R_Couleur_polygone_interieur=$16
 V_Couleur_polygone_interieur=$17
 B_Couleur_polygone_interieur=$18

 Contour_polygone_interieur=$19
 R_Couleur_contour_polygone_interieur=$20
 V_Couleur_contour_polygone_interieur=$21
 B_Couleur_contour_polygone_interieur=$22

 Variation_de_couleur=$23

 Remplir_cercle_interieur=$24

 R_CI_plein=$25
 V_CI_plein=$26
 B_CI_plein=$27

 Contour_cercle_interieur=$28

 R_CI_contour=$29
 V_CI_contour=$30
 B_CI_contour=$31

 Remplir_cercle_exterieur=$32

 R_CE_plein=$33
 V_CE_plein=$34
 B_CE_plein=$35

 Contour_cercle_exterieur=$36

 R_CE_contour=$37
 V_CE_contour=$38
 B_CE_contour=$39

 Valeur_dilate_circ=$40

 Transparence_des_couleurs=$41
 Flou_polygone=$42
 Spread_polygone=$43
 Deform_polygone=$44
 blend=$45

 {w},{h},1,4
 fill_color[-1] 0,0,0,0

 ## Cercle circonscrit ##
 if $Remplir_cercle_exterieur==1
  ## tracer le cercle circonscrit plein
  ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_circonscrit,$Rayon_cercle_circonscrit,0,1,$R_CE_plein,$V_CE_plein,$B_CE_plein,$Transparence_des_couleurs
 endif

 ## Cercle circonscrit ##
 if $Contour_cercle_exterieur==1
  ## tracer le cercle circonscrit contour
  ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_circonscrit,$Rayon_cercle_circonscrit,0,1,0xFFFFFF,$R_CE_contour,$V_CE_contour,$B_CE_contour,$Transparence_des_couleurs
 endif

 ## Polygones ##
 Increment_angle={360/$Nombre_de_cotes}

 Nb_boucle=$Nombre_de_cotes

 do

  ## remplir couleur unie
  if $Variation_de_couleur==0

   ## point extérieur ##
   X_point_exterieur={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
   Y_point_exterieur={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}

   ## point intérieur ##
   X_point_interieur={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}
   Y_point_interieur={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{360/$Nombre_de_cotes}}})}})}}

   ## incrémenter les variables de positionnement des points
   if $Nb_boucle==$Nombre_de_cotes
    Points_polygone_exterieur=$X_point_exterieur,$Y_point_exterieur
    Points_polygone_interieur=$X_point_interieur,$Y_point_interieur
   else
    Points_polygone_exterieur=$Points_polygone_exterieur,$X_point_exterieur,$Y_point_exterieur
    Points_polygone_interieur=$Points_polygone_interieur,$X_point_interieur,$Y_point_interieur
   endif

   ## tracer le polygone à la fin
   if $Nb_boucle==1

    ## Tracer les polygones + cercle intérieur
    if $Remplir_polygone_exterieur==1
     ## plein
     polygon[-1] $Nombre_de_cotes,$Points_polygone_exterieur,1,$R_Couleur_polygone_exterieur,$V_Couleur_polygone_exterieur,$B_Couleur_polygone_exterieur,$Transparence_des_couleurs
    endif

    if $Contour_polygone_exterieur==1
     ## contour
     polygon[-1] $Nombre_de_cotes,$Points_polygone_exterieur,1,0xFFFFFF,$R_Couleur_contour_polygone_exterieur,$V_Couleur_contour_polygone_exterieur,$B_Couleur_contour_polygone_exterieur,$Transparence_des_couleurs
    endif

    ## Cercle intérieur ##
    if $Remplir_cercle_interieur==1
     ## tracer le cercle intérieur plein
     ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
    endif

    ## Cercle intérieur ##
    if $Contour_cercle_interieur==1
     ## tracer le cercle intérieur contour
     ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
    endif

    if $Remplir_polygone_interieur==1
     ## plein
     polygon[-1] $Nombre_de_cotes,$Points_polygone_interieur,1,$R_Couleur_polygone_interieur,$V_Couleur_polygone_interieur,$B_Couleur_polygone_interieur,$Transparence_des_couleurs
    endif

    if $Contour_polygone_interieur==1
     ## contour
     polygon[-1] $Nombre_de_cotes,$Points_polygone_interieur,1,0xFFFFFF,$R_Couleur_contour_polygone_interieur,$V_Couleur_contour_polygone_interieur,$B_Couleur_contour_polygone_interieur,$Transparence_des_couleurs
    endif

   endif

  endif

  ## Décomposition en triangles
  ## remplir couleurs aléatoires
  if $Variation_de_couleur==1

   ## triangle 2 points extérieurs ##
   X_point_exterieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   Y_point_exterieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   X_point_exterieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   Y_point_exterieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   ## vérification points
   ##ellipse[-1] $X_point_exterieur_1,$Y_point_exterieur_1,5,5,0,1,127,127,127,255
   ##ellipse[-1] $X_point_exterieur_2,$Y_point_exterieur_2,5,5,0,1,127,127,127,255

   if $Remplir_polygone_exterieur==1
    ## plein
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
   endif

   if $Contour_polygone_exterieur==1
    ## contour
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,0xFFFFFF,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
   endif

   ## triangle 2 points intérieurs ##
   X_point_interieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   Y_point_interieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   X_point_interieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   Y_point_interieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   ## vérification points
   ##ellipse[-1] $X_point_interieur_1,$Y_point_interieur_1,5,5,0,1,127,127,127,255
   ##ellipse[-1] $X_point_interieur_2,$Y_point_interieur_2,5,5,0,1,127,127,127,255

   if $Remplir_polygone_interieur==1
    ## plein
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
   endif

   if $Contour_polygone_interieur==1
    ## contour
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,0xFFFFFF,{round(u)*255},{round(u)*255},{round(u)*255},$Transparence_des_couleurs
   endif

   ## tracer le cercle intérieur à la fin
   if $Nb_boucle==1

    if $Remplir_cercle_interieur==1
     ## tracer le cercle intérieur plein
     ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
    endif

    ## Cercle intérieur ##
    if $Contour_cercle_interieur==1
     ## tracer le cercle intérieur contour
     ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
    endif

   endif

  endif

  ## Décomposition en triangles
  ## couleurs nuancées
  if $Variation_de_couleur>1

   Valeur_variation_couleur=16

   if $Variation_de_couleur==3
    Valeur_variation_couleur=32
   endif

   if $Variation_de_couleur==4
    Valeur_variation_couleur=64
   endif

   R_Couleur_polygone_exterieur={round({$8+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $R_Couleur_polygone_exterieur>255
     R_Couleur_polygone_exterieur=$8
   endif
   if $R_Couleur_polygone_exterieur<0
     R_Couleur_polygone_exterieur=$8
   endif

   V_Couleur_polygone_exterieur={round({$9+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $V_Couleur_polygone_exterieur>255
     V_Couleur_polygone_exterieur=$9
   endif
   if $V_Couleur_polygone_exterieur<0
     V_Couleur_polygone_exterieur=$9
   endif

   B_Couleur_polygone_exterieur={round({$10+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $B_Couleur_polygone_exterieur>255
     B_Couleur_polygone_exterieur=$10
   endif
   if $B_Couleur_polygone_exterieur<0
     B_Couleur_polygone_exterieur=$10
   endif

   R_Couleur_polygone_interieur={round({$16+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $R_Couleur_polygone_interieur>255
     R_Couleur_polygone_interieur=$16
   endif
   if $R_Couleur_polygone_interieur<0
     R_Couleur_polygone_interieur=$16
   endif

   V_Couleur_polygone_interieur={round({$17+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $V_Couleur_polygone_interieur>255
     V_Couleur_polygone_interieur=$17
   endif
   if $V_Couleur_polygone_interieur<0
     V_Couleur_polygone_interieur=$17
   endif

   B_Couleur_polygone_interieur={round({$18+{u(-$Valeur_variation_couleur,$Valeur_variation_couleur)}})}
   if $B_Couleur_polygone_interieur>255
     B_Couleur_polygone_interieur=$18
   endif
   if $B_Couleur_polygone_interieur<0
     B_Couleur_polygone_interieur=$18
   endif

   ## triangle 2 points extérieurs ##
   X_point_exterieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   Y_point_exterieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   X_point_exterieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   Y_point_exterieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_circonscrit*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   ## vérification points
   ##ellipse[-1] $X_point_exterieur_1,$Y_point_exterieur_1,5,5,0,1,127,127,127,255
   ##ellipse[-1] $X_point_exterieur_2,$Y_point_exterieur_2,5,5,0,1,127,127,127,255

   if $Remplir_polygone_exterieur==1
    ## plein
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,$R_Couleur_polygone_exterieur,$V_Couleur_polygone_exterieur,$B_Couleur_polygone_exterieur,$Transparence_des_couleurs
   endif

   if $Contour_polygone_exterieur==1
    ## contour
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_exterieur_1,$Y_point_exterieur_1,$X_point_exterieur_2,$Y_point_exterieur_2,1,0xFFFFFF,$R_Couleur_contour_polygone_exterieur,$V_Couleur_contour_polygone_exterieur,$B_Couleur_contour_polygone_exterieur,$Transparence_des_couleurs
   endif

   ## triangle 2 points intérieurs ##
   X_point_interieur_1={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   Y_point_interieur_1={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison+{180/$Nombre_de_cotes}}})}})}}
   X_point_interieur_2={$X_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   Y_point_interieur_2={$Y_centre_cercle_circonscrit+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Increment_angle+$Angle_inclinaison-{180/$Nombre_de_cotes}}})}})}}
   ## vérification points
   ##ellipse[-1] $X_point_interieur_1,$Y_point_interieur_1,5,5,0,1,127,127,127,255
   ##ellipse[-1] $X_point_interieur_2,$Y_point_interieur_2,5,5,0,1,127,127,127,255

   if $Remplir_polygone_interieur==1
    ## plein
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,$R_Couleur_polygone_interieur,$V_Couleur_polygone_interieur,$B_Couleur_polygone_interieur,$Transparence_des_couleurs
   endif

   if $Contour_polygone_interieur==1
    ## contour
    polygon[-1] 3,$X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$X_point_interieur_1,$Y_point_interieur_1,$X_point_interieur_2,$Y_point_interieur_2,1,0xFFFFFF,$R_Couleur_contour_polygone_interieur,$V_Couleur_contour_polygone_interieur,$B_Couleur_contour_polygone_interieur,$Transparence_des_couleurs
   endif

   ## tracer le cercle intérieur à la fin
   if $Nb_boucle==1

    if $Remplir_cercle_interieur==1
     ## tracer le cercle intérieur plein
     ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,$R_CI_plein,$V_CI_plein,$B_CI_plein,$Transparence_des_couleurs
    endif

    ## Cercle intérieur ##
    if $Contour_cercle_interieur==1
     ## tracer le cercle intérieur contour
     ellipse[-1] $X_centre_cercle_circonscrit,$Y_centre_cercle_circonscrit,$Rayon_cercle_interieur,$Rayon_cercle_interieur,0,1,0xFFFFFF,$R_CI_contour,$V_CI_contour,$B_CI_contour,$Transparence_des_couleurs
    endif

   endif

  endif

  Increment_angle={$Increment_angle+{360/$Nombre_de_cotes}}

  Nb_boucle={$Nb_boucle-1}

 while $Nb_boucle>0

 if $Valeur_dilate_circ>1
  dilate_circ[-1] $Valeur_dilate_circ
 endif

 blur[-1] $Flou_polygone

 spread[-1] $Spread_polygone

 deform[-1] $Deform_polygone

 gimp_blend_1651[-2,-1] $blend,1,1,1 # alpha
################################################################
##                                                            ##
##       FIN  Ensemble Polygones /  Figures géométriques      ##
##                                                            ##
################################################################


#################################################
##                                             ##
##    Etoile_De_Pompei_Triangles_Sierpinski    ##
##                                             ##
#################################################

# 2015/03/08 correction
# 2015/03/07 menu , dimension = largeur ou hauteur
# 2014/04/24 blend
# modification 2014/03/20 samj_sierpinski_absolu[-1]
# origine 2014/03/18
# adaptation de etoile_de_pompei_samj
# 2016/02/02 {round(u)*255}

#@gui Etoile De Pompei Triangles Sierpinski : samj_Etoile_De_Pompei_Triangles_Sierpinski, samj_Etoile_De_Pompei_Triangles_Sierpinski(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Angle inclinaison = float(30,0,60)
#@gui : Dimension (>0 W%) (<0 H%) = float(100,-400,400)
#@gui : Cadre = color(0,0,0,255)
#@gui : Afficher Cadre = choice(0,"Pas Affichage","Affichage Contours Centre","Affichage Contours")
#@gui : Récursions Sierpinski = int(5,1,7)
#@gui : Centre A = color(255,0,0,127)
#@gui : Centre B = color(255,0,255,127)
#@gui : Triangle = color(0,0,255,127)
#@gui : Demi Losange A = color(0,255,255,127)
#@gui : Demi Losange B = color(255,255,0,127)
#@gui : Cercle = color(0,63,255,64)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/02/02</i>.</small>")

samj_Etoile_De_Pompei_Triangles_Sierpinski :

####### Déclaration des variables

 X={round({{w}*{$1/100}})}
 Y={round({{h}*{$2/100}})}
 Angle_inclinaison=$3

 if $4>0
  Dimension={round({{w}*$4/{400*{2^0.5}}})}
 else
  Dimension={round({-{h}*$4/{400*{2^0.5}}})}
 endif

 R_Cadre=$5
 V_Cadre=$6
 B_Cadre=$7
 A_Cadre=$8

 Afficher_Cadre=$9

 Recursions_Sierpinski=$10

 R_Centre=$11
 V_Centre=$12
 B_Centre=$13
 A_Centre=$14

 R_Centreb=$15
 V_Centreb=$16
 B_Centreb=$17
 A_Centreb=$18

 R_Triangle=$19
 V_Triangle=$20
 B_Triangle=$21
 A_Triangle=$22

 R_Demi_Losange=$23
 V_Demi_Losange=$24
 B_Demi_Losange=$25
 A_Demi_Losange=$26

 R_Demi_Losange_Deux=$27
 V_Demi_Losange_Deux=$28
 B_Demi_Losange_Deux=$29
 A_Demi_Losange_Deux=$30

 R_Cercle=$31
 V_Cercle=$32
 B_Cercle=$33
 A_Cercle=$34
 Couleurs_aleatoires=$35
 Inversions=$36
 Flou=$37
 Dilatation=$38
 Deformation=$39
 Bruit=$40
 Ombre=$41
 X_Ombre=$42
 Y_Ombre=$43
 Smoothness_Ombre=$44
 Curvature_Ombre=$45
 Compensation_Decalage_Ombre_X=$46
 Compensation_Decalage_Ombre_Y=$47
 Canal_Alpha=$48
 Largeur_Origine={w}
 Hauteur_Origine={h}

 Rayon_Cercle_1=$Dimension ## cercle hexagone
 Rayon_Cercle_2={{{2*$Dimension*$Dimension}-{2*$Dimension*$Dimension*{cos(pi/180*150)}}}^0.5} ## cercle carrés
 Rayon_Cercle_3={$Dimension+{$Dimension*{3^0.5}}} ## cercle triangles

 #angles degrés
 dephasage_point1_carre={0+$Angle_inclinaison}  ## déphasage point 7
 dephasage_point2_carre={60+$Angle_inclinaison} ## déphasage point 6
 dephasage_point3_carre={45+$Angle_inclinaison}
 dephasage_point4_carre={15+$Angle_inclinaison}
 dephasage_point5_triangle={30+$Angle_inclinaison}

 Nb_Boucle=0
 H_X_a=0
 H_Y_a=0
 H_X_b=0
 H_Y_b=0
 H_X_c=0
 H_Y_c=0
 H_X_d=0
 H_Y_d=0
 H_X_e=0
 H_Y_e=0
 H_X_f=0
 H_Y_f=0
 xca=0
 yca=0
 Angle_C=0
 xcb=0
 ycb=0
 xcc=0
 ycc=0
 xcd=0
 ycd=0
 xce=0
 yce=0

####### Ligne de commandes

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 #Couleurs aléatoires
 if $Couleurs_aleatoires==1
  R_Centre={round(u)*255}
  V_Centre={round(u)*255}
  B_Centre={round(u)*255}
  R_Centreb={round(u)*255}
  V_Centreb={round(u)*255}
  B_Centreb={round(u)*255}
  R_Triangle={round(u)*255}
  V_Triangle={round(u)*255}
  B_Triangle={round(u)*255}
  R_Demi_Losange={round(u)*255}
  V_Demi_Losange={round(u)*255}
  B_Demi_Losange={round(u)*255}
  R_Demi_Losange_Deux={round(u)*255}
  V_Demi_Losange_Deux={round(u)*255}
  B_Demi_Losange_Deux={round(u)*255}
  R_Cercle={round(u)*255}
  V_Cercle={round(u)*255}
  B_Cercle={round(u)*255}
 endif

 if $Afficher_Cadre>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
  #point[-1] 20,20,0,1,255,0,0,255
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 if $Afficher_Cadre==2
  ellipse[-2] $X,$Y,$Rayon_Cercle_3,$Rayon_Cercle_3,0,1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
  ellipse[-1] $X,$Y,$Rayon_Cercle_3,$Rayon_Cercle_3,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
 endif

 #point[-1] 30,30,0,1,255,255,0,255

 repeat 6

  Nb_Boucle={$Nb_Boucle+1}

  #Couleurs aléatoires
  if $Couleurs_aleatoires==1
    R_Centreb={round(u)*255}
    V_Centreb={round(u)*255}
    B_Centreb={round(u)*255}
    R_Triangle={round(u)*255}
    V_Triangle={round(u)*255}
    B_Triangle={round(u)*255}
    R_Demi_Losange_Deux={round(u)*255}
    V_Demi_Losange_Deux={round(u)*255}
    B_Demi_Losange_Deux={round(u)*255}
  endif

  point1_X={round({$Rayon_Cercle_1*{cos(pi/180*$dephasage_point1_carre)}})}
  point1_Y={round({$Rayon_Cercle_1*{sin(pi/180*$dephasage_point1_carre)}})}
  point2_X={round({$Rayon_Cercle_1*{cos(pi/180*{$dephasage_point2_carre})}})}
  point2_Y={round({$Rayon_Cercle_1*{sin(pi/180*{$dephasage_point2_carre})}})}
  point3_X={round({$Rayon_Cercle_2*{cos(pi/180*{$dephasage_point3_carre})}})}
  point3_Y={round({$Rayon_Cercle_2*{sin(pi/180*{$dephasage_point3_carre})}})}
  point4_X={round({$Rayon_Cercle_2*{cos(pi/180*{$dephasage_point4_carre})}})}
  point4_Y={round({$Rayon_Cercle_2*{sin(pi/180*{$dephasage_point4_carre})}})}

  if $Nb_Boucle==1
   H_X_a={$X+$point1_X}
   H_Y_a={$Y+$point1_Y}
  elif $Nb_Boucle==2
   H_X_b={$X+$point1_X}
   H_Y_b={$Y+$point1_Y}
  elif $Nb_Boucle==3
   H_X_c={$X+$point1_X}
   H_Y_c={$Y+$point1_Y}
  elif $Nb_Boucle==4
   H_X_d={$X+$point1_X}
   H_Y_d={$Y+$point1_Y}
  elif $Nb_Boucle==5
   H_X_e={$X+$point1_X}
   H_Y_e={$Y+$point1_Y}
  elif $Nb_Boucle==6
   H_X_f={$X+$point1_X}
   H_Y_f={$Y+$point1_Y}
  endif

  point5_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point5_triangle})}})}
  point5_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point5_triangle})}})}

  samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point5_X},{$Y+$point5_Y},$R_Triangle,$V_Triangle,$B_Triangle,$A_Triangle

  point6_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point2_carre})}})}
  point6_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point2_carre})}})}

  samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point6_X},{$Y+$point6_Y},$R_Demi_Losange_Deux,$V_Demi_Losange_Deux,$B_Demi_Losange_Deux,$A_Demi_Losange_Deux

  point7_X={round({$Rayon_Cercle_3*{cos(pi/180*{$dephasage_point1_carre})}})}
  point7_Y={round({$Rayon_Cercle_3*{sin(pi/180*{$dephasage_point1_carre})}})}

  samj_sierpinski_absolu[-1] $Recursions_Sierpinski,{$X+$point1_X},{$Y+$point1_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point7_X},{$Y+$point7_Y},$R_Demi_Losange,$V_Demi_Losange,$B_Demi_Losange,$A_Demi_Losange

  if $Afficher_Cadre>0
   polygon[-2] 3,{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point5_X},{$Y+$point5_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
   polygon[-2] 3,{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point6_X},{$Y+$point6_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
   polygon[-2] 3,{$X+$point1_X},{$Y+$point1_Y},{$X+$point4_X},{$Y+$point4_Y},{$X+$point7_X},{$Y+$point7_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
  endif
  if $Afficher_Cadre==2
   polygon[-2] 4,{$X+$point1_X},{$Y+$point1_Y},{$X+$point2_X},{$Y+$point2_Y},{$X+$point3_X},{$Y+$point3_Y},{$X+$point4_X},{$Y+$point4_Y},1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre
  endif

  dephasage_point1_carre={$dephasage_point1_carre+60}
  dephasage_point2_carre={$dephasage_point2_carre+60}
  dephasage_point3_carre={$dephasage_point3_carre+60}
  dephasage_point4_carre={$dephasage_point4_carre+60}
  dephasage_point5_triangle={$dephasage_point5_triangle+60}
 done

 samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_a,$H_Y_a,$H_X_b,$H_Y_b,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
 samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_b,$H_Y_b,$H_X_c,$H_Y_c,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
 samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_c,$H_Y_c,$H_X_d,$H_Y_d,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
 samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_d,$H_Y_d,$H_X_e,$H_Y_e,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
 samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_e,$H_Y_e,$H_X_f,$H_Y_f,$X,$Y,$R_Centre,$V_Centre,$B_Centre,$A_Centre
 samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$H_X_f,$H_Y_f,$H_X_a,$H_Y_a,$X,$Y,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb

 if $Afficher_Cadre==0
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif

 elif $Afficher_Cadre==1
  polygon[-2] 6,$H_X_a,$H_Y_a,$H_X_b,$H_Y_b,$H_X_c,$H_Y_c,$H_X_d,$H_Y_d,$H_X_e,$H_Y_e,$H_X_f,$H_Y_f,1,0xFFFFFFFF,$R_Cadre,$V_Cadre,$B_Cadre,$A_Cadre

 endif

 if $Afficher_Cadre>0
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1

 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0
#################################################
##                                             ##
##  FIN Etoile_De_Pompei_Triangles_Sierpinski  ##
##                                             ##
#################################################


#################################################
##                                             ##
##      Superposition_Triangles_Sierpinski     ##
##                                             ##
#################################################

# 2015/03/08 menu , Rayon_Premier_Cecle en fonction de largeur ou hauteur
# 2014/04/24 blend
# 2016/02/02 {round(u)*255}

#@gui Superposition Triangles Sierpinski : samj_Superposition_Triangles_Sierpinski, samj_Superposition_Triangles_Sierpinski(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Nombre De Zones = int(6,3,24)
#@gui : Nombre De Superpositions = int(6,1,50)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Dimension Premier Cercle (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Coeff. Superpositions = float(1,0,4)
#@gui : Hauteur Triangle = float(20,0,100)
#@gui : Angle inclinaison = float(30,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage = choice(1,"Sans Contours Triangles Ext.","Sans Contours Triangles Int.","Sans Contours Triangles Ext. et Lat.","Sans Contours Triangles Int. et Lat.","Triangles Ext.","Triangles Int.","Triangles Ext. et Lat.","Triangles Int. et Lat.")
#@gui : Recursions Sierpinski = int(4,0,7)
#@gui : Triangle A = color(0,0,255,127)
#@gui : Triangle B = color(255,255,0,127)
#@gui : Triangle Lat. A = color(128,64,192,127)
#@gui : Triangle Lat. B = color(64,128,192,127)
#@gui : Cercle = color(0,255,255,127)
#@gui : Afficher Cercle = bool(0)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")
samj_Superposition_Triangles_Sierpinski :

####### Déclaration des variables

 Nombre_de_zones=$1
 Nombre_de_superpositions=$2
 X={round({{w}*{$3/100}})}
 Y={round({{h}*{$4/100}})}
 if $5>0
  Rayon_Premier_Cecle={round({{w}*$5/{200*{2^0.5}}})}
 else
  Rayon_Premier_Cecle={round({-{h}*$5/{200*{2^0.5}}})}
 endif
 Coeff_Superpositions=$6
 Hauteur_Triangle={round({{{w}+{h}}*$7/2400})}
 Angle_inclinaison=$8

 R_Contours=$9
 V_Contours=$10
 B_Contours=$11
 A_Contours=$12

 Affichage=$13

 Recursions_Sierpinski=$14

 R_Tr=$15
 V_Tr=$16
 B_Tr=$17
 A_Tr=$18

 R_Trb=$19
 V_Trb=$20
 B_Trb=$21
 A_Trb=$22

 R_Lat=$23
 V_Lat=$24
 B_Lat=$25
 A_Lat=$26

 R_Latb=$27
 V_Latb=$28
 B_Latb=$29
 A_Latb=$30

 R_Cercle=$31
 V_Cercle=$32
 B_Cercle=$33
 A_Cercle=$34

 Afficher_Cercle=$35
 Couleurs_aleatoires=$36
 Inversions=$37
 Flou=$38
 Dilatation=$39
 Deformation=$40
 Bruit=$41
 Ombre=$42
 X_Ombre=$43
 Y_Ombre=$44
 Smoothness_Ombre=$45
 Curvature_Ombre=$46
 Compensation_Decalage_Ombre_X=$47
 Compensation_Decalage_Ombre_Y=$48
 Canal_Alpha=$49
 Largeur_Origine={w}
 Hauteur_Origine={h}
 Angle=$Angle_inclinaison
 Increment_angle={360/$Nombre_de_zones}
 Rayon_Cercle_A=$Rayon_Premier_Cecle
 H_Tr=$Hauteur_Triangle
 Rayon_Cercle_B=0
 Rayon_Cercle_C=0
 Rayon_Contour=0

####### Ligne de commandes

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif
 if $Affichage>3
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 Nb_boucles_superpositions=0

 repeat $Nombre_de_superpositions

  Nb_boucles_superpositions={$Nb_boucles_superpositions+1}
  Nb_boucles_zones=0
  Angle=$Angle_inclinaison

  repeat $Nombre_de_zones

   Nb_boucles_zones={$Nb_boucles_zones+1}

   if $Couleurs_aleatoires==1
    R_Tr={round(u)*255}
    V_Tr={round(u)*255}
    B_Tr={round(u)*255}
    R_Trb={round(u)*255}
    V_Trb={round(u)*255}
    B_Trb={round(u)*255}
    R_Lat={round(u)*255}
    V_Lat={round(u)*255}
    B_Lat={round(u)*255}
    R_Latb={round(u)*255}
    V_Latb={round(u)*255}
    B_Latb={round(u)*255}
    R_Cercle={round(u)*255}
    V_Cercle={round(u)*255}
    B_Cercle={round(u)*255}
   endif

   Rayon_Cercle_B={{{$Rayon_Cercle_A*$Rayon_Cercle_A}+{{$Rayon_Cercle_A*{tan({pi/180*{180/$Nombre_de_zones}})}}*{$Rayon_Cercle_A*{tan({pi/180*{180/$Nombre_de_zones}})}}}}^0.5}

   X_A={$X+{{$Rayon_Cercle_A+$H_Tr}*{cos({pi/180*$Angle})}}}
   Y_A={$Y+{{$Rayon_Cercle_A+$H_Tr}*{sin({pi/180*$Angle})}}}
   X_B={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
   Y_B={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
   X_C={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
   Y_C={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}

   Rayon_Cercle_C={{{{$Rayon_Cercle_A+$H_Tr}*{$Rayon_Cercle_A+$H_Tr}}+{{{$Rayon_Cercle_A+$H_Tr}*{tan({pi/180*{180/$Nombre_de_zones}})}}*{{$Rayon_Cercle_A+$H_Tr}*{tan({pi/180*{180/$Nombre_de_zones}})}}}}^0.5}

   X_D={$X+{$Rayon_Cercle_A*{cos({pi/180*$Angle})}}}
   Y_D={$Y+{$Rayon_Cercle_A*{sin({pi/180*$Angle})}}}
   X_E={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
   Y_E={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{180/$Nombre_de_zones}}})}}}
   X_F={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
   Y_F={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle-{180/$Nombre_de_zones}}})}}}
   if ($Affichage%2)==0
    # Triangles Ext.
    Rayon_Contour={$Rayon_Cercle_A+$H_Tr}
    if $Recursions_Sierpinski==0
     if ($Nb_boucles_superpositions%2)==0
      polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,$R_Tr,$V_Tr,$B_Tr,$A_Tr
     else
      polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,$R_Trb,$V_Trb,$B_Trb,$A_Trb
     endif
    else
     if ($Nb_boucles_superpositions%2)==0
      samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,$R_Tr,$V_Tr,$B_Tr,$A_Tr
     else
      samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,$R_Trb,$V_Trb,$B_Trb,$A_Trb
     endif
    endif
    if $Affichage==2||$Affichage==6
     if ($Nb_boucles_superpositions%2)==0
       polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_E,$Y_E,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
       polygon[-1] 3,$X_A,$Y_A,$X_C,$Y_C,$X_F,$Y_F,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
     else
       polygon[-1] 3,$X_A,$Y_A,$X_B,$Y_B,$X_E,$Y_E,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
       polygon[-1] 3,$X_A,$Y_A,$X_C,$Y_C,$X_F,$Y_F,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
     endif
    endif
    if $Affichage>3
     polygon[-2] 3,$X_A,$Y_A,$X_B,$Y_B,$X_C,$Y_C,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   else
    # Triangles Int.
    Rayon_Contour=$Rayon_Cercle_C
    if $Recursions_Sierpinski==0
     if ($Nb_boucles_superpositions%2)==0
      polygon[-1] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,$R_Tr,$V_Tr,$B_Tr,$A_Tr
     else
      polygon[-1] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,$R_Trb,$V_Trb,$B_Trb,$A_Trb
     endif
    else
     if ($Nb_boucles_superpositions%2)==0
      samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,$R_Tr,$V_Tr,$B_Tr,$A_Tr
     else
      samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,$R_Trb,$V_Trb,$B_Trb,$A_Trb
     endif
    endif
    if $Affichage==3||$Affichage==7
     if ($Nb_boucles_superpositions%2)==0
       polygon[-1] 3,$X_D,$Y_D,$X_B,$Y_B,$X_E,$Y_E,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
       polygon[-1] 3,$X_D,$Y_D,$X_C,$Y_C,$X_F,$Y_F,1,$R_Lat,$V_Lat,$B_Lat,$A_Lat
     else
       polygon[-1] 3,$X_D,$Y_D,$X_B,$Y_B,$X_E,$Y_E,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
       polygon[-1] 3,$X_D,$Y_D,$X_C,$Y_C,$X_F,$Y_F,1,$R_Latb,$V_Latb,$B_Latb,$A_Latb
     endif
    endif
    if $Affichage>3
     polygon[-2] 3,$X_D,$Y_D,$X_E,$Y_E,$X_F,$Y_F,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   endif

   Angle={$Angle_inclinaison+{$Increment_angle*$Nb_boucles_zones}}
  done

  Rayon_Cercle_A={$Rayon_Cercle_A+$H_Tr}
  H_Tr={$Hauteur_Triangle*$Nb_boucles_superpositions*$Coeff_Superpositions}

 done
 if $Afficher_Cercle==1
  $Largeur_Origine,$Hauteur_Origine,1,4
  polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1
  ellipse[-1] $X,$Y,$Rayon_Contour,$Rayon_Contour,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
  blend[-2,-1] alpha,1,1
  if $Affichage>3
   ellipse[-2] $X,$Y,$Rayon_Contour,$Rayon_Contour,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
 endif
 if $Affichage>3
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0
#################################################
##                                             ##
##    FIN Superposition_Triangles_Sierpinski   ##
##                                             ##
#################################################


#################################################
##                                             ##
##    Etoiles_Remplies_Triangles_Sierpinski    ##
##                                             ##
#################################################

# 2015/03/08 menu , Rayon_cercle_exterieur en fonction de largeur ou hauteur
# modification 2014/03/20 samj_sierpinski_absolu[-1] + couleurs aléatoires dans boucle
# origine 2014/03/19
# 2016/02/02 {round(u)*255}

#@gui Etoiles Remplies Triangles Sierpinski : samj_Etoiles_Remplies_Triangles_Sierpinski, samj_Etoiles_Remplies_Triangles_Sierpinski(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Nombre De Sommets = int(6,2,18)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon cercle extérieur / Outer circle radius (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Rayon cercle intérieur / Inner circle radius (%) = float(40,0,100)
#@gui : Angle inclinaison = float(30,0,60)
#@gui : Excentricité / Eccentricity (%) = float(0,0,100)
#@gui : Angle excentricité / Eccentricity angle = float(0,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage = choice(1,"Pas De Contours A","Pas De Contours B","Pas De Contours C","Pas De Contours D","Contours A","Contours B","Contours C","Contours D")
#@gui : Recursions Sierpinski = int(4,0,7)
#@gui : Centre A = color(255,0,0,127)
#@gui : Centre B = color(255,192,64,127)
#@gui : Sommets A = color(0,0,255,127)
#@gui : Sommets B = color(0,255,255,127)
#@gui : Cercle = color(255,255,0,127)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Etoiles_Remplies_Triangles_Sierpinski :

####### Déclaration des variables

 Nombre_de_sommets=$1
 X={round({{w}*{$2/100}})}
 Y={round({{h}*{$3/100}})}
 if $4>0
  Rayon_cercle_exterieur={round({{w}*$4/{100}})}
 else
  Rayon_cercle_exterieur={round({-{h}*$4/{100}})}
 endif
 Rayon_cercle_interieur={round({$Rayon_cercle_exterieur*$5/100})}
 Angle_inclinaison=$6
 Pourcentage_excentricite=$7
 Angle_excentricite=$8

 R_Contours=$9
 V_Contours=$10
 B_Contours=$11
 A_Contours=$12

 Affichage=$13

 Recursions_Sierpinski=$14

 R_Centre=$15
 V_Centre=$16
 B_Centre=$17
 A_Centre=$18

 R_Centreb=$19
 V_Centreb=$20
 B_Centreb=$21
 A_Centreb=$22

 R_Sommet=$23
 V_Sommet=$24
 B_Sommet=$25
 A_Sommet=$26

 R_Sommetb=$27
 V_Sommetb=$28
 B_Sommetb=$29
 A_Sommetb=$30

 R_Cercle=$31
 V_Cercle=$32
 B_Cercle=$33
 A_Cercle=$34

 Couleurs_aleatoires=$35
 Inversions=$36
 Flou=$37
 Dilatation=$38
 Deformation=$39
 Bruit=$40
 Ombre=$41
 X_Ombre=$42
 Y_Ombre=$43
 Smoothness_Ombre=$44
 Curvature_Ombre=$45
 Compensation_Decalage_Ombre_X=$46
 Compensation_Decalage_Ombre_Y=$47
 Canal_Alpha=$48
 Largeur_Origine={w}
 Hauteur_Origine={h}

 Nb_Boucle=0
 Angle=0
 Increment_angle={360/$Nombre_de_sommets}
 Longueur_excentricite={$Pourcentage_excentricite/100*{$Rayon_cercle_exterieur-$Rayon_cercle_interieur}}
 Decalage_X_excentricite={round({$Longueur_excentricite*{cos(pi/180*$Angle_excentricite)}})}
 Decalage_Y_excentricite={round({$Longueur_excentricite*{sin(pi/180*$Angle_excentricite)}})}
 X_centre_cercle_interieur={$X+$Decalage_X_excentricite}
 Y_centre_cercle_interieur={$Y+$Decalage_Y_excentricite}

####### Ligne de commandes

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 #Couleurs aléatoires
 if $Couleurs_aleatoires==1
  R_Centre={round(u)*255}
  V_Centre={round(u)*255}
  B_Centre={round(u)*255}
  R_Centreb={round(u)*255}
  V_Centreb={round(u)*255}
  B_Centreb={round(u)*255}
  R_Sommet={round(u)*255}
  V_Sommet={round(u)*255}
  B_Sommet={round(u)*255}
  R_Sommetb={round(u)*255}
  V_Sommetb={round(u)*255}
  B_Sommetb={round(u)*255}
  R_Sommetb_Deux={round(u)*255}
  V_Sommetb_Deux={round(u)*255}
  B_Sommetb_Deux={round(u)*255}
  R_Cercle={round(u)*255}
  V_Cercle={round(u)*255}
  B_Cercle={round(u)*255}
 endif

 if $Affichage>3
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 if $Affichage==2||$Affichage==3||$Affichage==6||$Affichage==7
  ellipse[-1] $X,$Y,$Rayon_cercle_exterieur,$Rayon_cercle_exterieur,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
 endif

 repeat $Nombre_de_sommets

  #Couleurs aléatoires
  if $Couleurs_aleatoires==1
   R_Centre={round(u)*255}
   V_Centre={round(u)*255}
   B_Centre={round(u)*255}
   R_Centreb={round(u)*255}
   V_Centreb={round(u)*255}
   B_Centreb={round(u)*255}
   R_Sommet={round(u)*255}
   V_Sommet={round(u)*255}
   B_Sommet={round(u)*255}
   R_Sommetb={round(u)*255}
   V_Sommetb={round(u)*255}
   B_Sommetb={round(u)*255}
   R_Sommetb_Deux={round(u)*255}
   V_Sommetb_Deux={round(u)*255}
   B_Sommetb_Deux={round(u)*255}
   R_Cercle={round(u)*255}
   V_Cercle={round(u)*255}
   B_Cercle={round(u)*255}
  endif

  Nb_Boucle={$Nb_Boucle+1}

  ## Étoiles point extérieur ##
  X_point_exterieur={$X+{round({$Rayon_cercle_exterieur*{cos({pi/180*{$Angle+$Angle_inclinaison}})}})}}
  Y_point_exterieur={$Y+{round({$Rayon_cercle_exterieur*{sin({pi/180*{$Angle+$Angle_inclinaison}})}})}}

  ## Étoiles points intérieurs ##
  X_point_interieur_a={$X_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Angle+$Angle_inclinaison+{180/$Nombre_de_sommets}}})}})}}
  Y_point_interieur_a={$Y_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Angle+$Angle_inclinaison+{180/$Nombre_de_sommets}}})}})}}
  X_point_interieur_b={$X_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{cos({pi/180*{$Angle+$Angle_inclinaison-{180/$Nombre_de_sommets}}})}})}}
  Y_point_interieur_b={$Y_centre_cercle_interieur+{round({$Rayon_cercle_interieur*{sin({pi/180*{$Angle+$Angle_inclinaison-{180/$Nombre_de_sommets}}})}})}}

  if ($Nombre_de_sommets%2)==0
   if ($Nb_Boucle%2)==0
    if $Recursions_Sierpinski==0
     polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
    endif
    if ($Affichage%2)==1
     if $Recursions_Sierpinski==0
      polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centre,$V_Centre,$B_Centre,$A_Centre
     else
      samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centre,$V_Centre,$B_Centre,$A_Centre
     endif
    endif
   else
    if $Recursions_Sierpinski==0
     polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommetb,$V_Sommetb,$B_Sommetb,$A_Sommetb
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommetb,$V_Sommetb,$B_Sommetb,$A_Sommetb
    endif
    if ($Affichage%2)==1
     if $Recursions_Sierpinski==0
      polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
     else
      samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centreb,$V_Centreb,$B_Centreb,$A_Centreb
     endif
    endif
   endif
  else
   if $Recursions_Sierpinski==0
    polygon[-1] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
   else
    samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Sommet,$V_Sommet,$B_Sommet,$A_Sommet
   endif
   if ($Affichage%2)==1
    if $Recursions_Sierpinski==0
     polygon[-1] 3,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,$R_Centre,$V_Centre,$B_Centre,$A_Centre
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X,$Y,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,$R_Centre,$V_Centre,$B_Centre,$A_Centre
    endif
   endif
  endif

  ## tracer les pointes contour
  if $Affichage>3
   polygon[-2] 3,$X_point_exterieur,$Y_point_exterieur,$X_point_interieur_a,$Y_point_interieur_a,$X_point_interieur_b,$Y_point_interieur_b,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif

  Angle={$Increment_angle*$Nb_Boucle}

 done

 if $Affichage>5
  ellipse[-2] $X,$Y,$Rayon_cercle_exterieur,$Rayon_cercle_exterieur,0,1,0xFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
 endif

 if $Affichage>3
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0
#################################################
##                                             ##
##  FIN Etoiles_Remplies_Triangles_Sierpinski  ##
##                                             ##
#################################################


#################################################
##                                             ##
##         Rosace_Triangles_Sierpinski         ##
##                                             ##
#################################################

# 2015/03/08 menu , Rayon_Premier_Cecle en fonction de largeur ou hauteur
# 2014/04/24 blend
# 2016/02/02 {round(u)*255}

#@gui Rosace Triangles Sierpinski : samj_Rosace_Triangles_Sierpinski, samj_Rosace_Triangles_Sierpinski(1)
#@gui :_=separator()
#@gui :_=note("<small>Rendu - Rendering</small>")
#@gui : Nombre De Zones = int(6,3,24)
#@gui : Nombre De Couches = int(6,1,50)
#@gui : Position X (%) = float(50,0,100)
#@gui : Position Y (%) = float(50,0,100)
#@gui : Rayon Premier Cercle (>0 W%) (<0 H%) = float(50,-400,400)
#@gui : Décalage Angle = float(-15,-30,30)
#@gui : Dimension Triangle = float(25,0,100)
#@gui : Recouvrement Triangle = float(5,0,100)
#@gui : Angle inclinaison = float(30,0,360)
#@gui : Contours = color(0,0,0,255)
#@gui : Affichage Contours = choice(0,"Sans","Triangle A et B","Triangle A","Triangle B","Triangle A et B et Cercle","Triangle A et Cercle","Triangle B et Cercle")
#@gui : Type Triangles A = choice(0,"JDH","JDE","JDB","JAH","JAE","JAB","Sans")
#@gui : Type Triangles B = choice(0,"HBI","HBF","HBC","Sans")
#@gui : Type Decalage = choice(0,"Couches","Cercles","Couches et Cercles")
#@gui : Recursions Sierpinski = int(3,0,7)
#@gui : Triangle A = color(0,0,255,127)
#@gui : Triangle Ab = color(255,255,0,127)
#@gui : Triangle B = color(128,64,192,127)
#@gui : Triangle Ba = color(64,128,192,127)
#@gui : Cercle = color(0,255,255,127)
#@gui : Afficher Cercle = bool(0)
#@gui : Couleurs aléatoires / Random Colors = bool(0)
#@gui : Inversions = int(0,0,3)
#@gui : Flou / Blur = float(0,0,5)
#@gui : Dilate = int(0,0,48)
#@gui : Déformation = float(0,0,5)
#@gui : Bruit / Noise = float(0,0,100)
#@gui : Ombre / Shadow = bool(0)
#@gui : X-Ombre X-Shadow = float(0.5,-5,5)
#@gui : Y-Ombre Y-Shadow = float(0.5,-5,5)
#@gui : Douceur Ombre / Smoothness Shadow = float(1.8,0,5)
#@gui : Courbure Ombre / Curvature Shadow = float(0,0,1)
#@gui : Décalage Ombre X / Shadow Offset X = float(0,-20,20)
#@gui : Décalage Ombre Y / Shadow Offset Y = float(0,-20,20)
#@gui : Canal Alpha = bool(0)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/10/24</i>.</small>")

samj_Rosace_Triangles_Sierpinski :

####### Déclaration des variables

 Nombre_de_zones=$1
 Nombre_de_couches=$2
 X={round({{w}*{$3/100}})}
 Y={round({{h}*{$4/100}})}
 if $5>0
  Rayon_Premier_Cecle={round({{w}*$5/{400*{2^0.5}}})}
 else
  Rayon_Premier_Cecle={round({-{h}*$5/{400*{2^0.5}}})}
 endif
 Decalage_Angle=$6
 Hauteur_Triangle={round({{{w}+{h}}*$7/2400})}
 Recouvrement_Triangle={round({{{w}+{h}}*$8/4800})}
 Angle_inclinaison=$9

 R_Contours=$10
 V_Contours=$11
 B_Contours=$12
 A_Contours=$13

 Affichage_Contours=$14
 Type_Triangles_A=$15
 Type_Triangles_B=$16
 Type_Decalage=$17

 Recursions_Sierpinski=$18

 R_Tr=$19
 V_Tr=$20
 B_Tr=$21
 A_Tr=$22

 R_Trb=$23
 V_Trb=$24
 B_Trb=$25
 A_Trb=$26

 R_Tr_B=$27
 V_Tr_B=$28
 B_Tr_B=$29
 A_Tr_B=$30

 R_Tr_Bb=$31
 V_Tr_Bb=$32
 B_Tr_Bb=$33
 A_Tr_Bb=$34

 R_Cercle=$35
 V_Cercle=$36
 B_Cercle=$37
 A_Cercle=$38

 Afficher_Cercle=$39
 Couleurs_aleatoires=$40
 Inversions=$41
 Flou=$42
 Dilatation=$43
 Deformation=$44
 Bruit=$45
 Ombre=$46
 X_Ombre=$47
 Y_Ombre=$48
 Smoothness_Ombre=$49
 Curvature_Ombre=$50
 Compensation_Decalage_Ombre_X=$51
 Compensation_Decalage_Ombre_Y=$52
 Canal_Alpha=$53
 Largeur_Origine={w}
 Hauteur_Origine={h}

 Angle=$Angle_inclinaison
 Increment_angle={360/$Nombre_de_zones}
 Rayon_Cercle_Origine=$Rayon_Premier_Cecle
 Rayon_Cercle_A=0
 Rayon_Cercle_B=0
 Rayon_Cercle_C=0
 Rayon_Cercle_D=0
 H_Tr_A=0
 H_Tr_B=0
 H_Tr_C=0
 H_Tr_D=0
 Nb_Cercles=0
####### Ligne de commandes

 if $Canal_Alpha==0
  to_rgb[-1]
 else
  to_rgba[-1]
 endif

 if $Affichage_Contours>0
  $Largeur_Origine,$Hauteur_Origine,1,4
  if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif
 endif

 $Largeur_Origine,$Hauteur_Origine,1,4
 if $Ombre>0 polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1 endif

 Nb_boucles_couches=0

 repeat $Nombre_de_couches

  Nb_boucles_couches={$Nb_boucles_couches+1}

  H_Tr_A={$Hauteur_Triangle*$Nb_Cercles}
  Nb_Cercles={$Nb_Cercles+1}
  H_Tr_B={$Hauteur_Triangle*$Nb_Cercles}
  Nb_Cercles={$Nb_Cercles+1}
  H_Tr_C={$Hauteur_Triangle*$Nb_Cercles}
  Nb_Cercles={$Nb_Cercles+1}
  H_Tr_D={$Hauteur_Triangle*$Nb_Cercles}

  Rayon_Cercle_A={$Rayon_Cercle_Origine+$H_Tr_A}
  Rayon_Cercle_B={$Rayon_Cercle_Origine+$H_Tr_B}
  Rayon_Cercle_C={$Rayon_Cercle_Origine+$H_Tr_C}
  Rayon_Cercle_D={$Rayon_Cercle_Origine+$H_Tr_D}

  Angle=$Angle_inclinaison

  #ellipse[-1] $X,$Y,$Rayon_Cercle_A,$Rayon_Cercle_A,0,1,0xFFFFFFFF,255,0,0,255
  #ellipse[-1] $X,$Y,$Rayon_Cercle_B,$Rayon_Cercle_B,0,1,0xFFFFFFFF,0,255,0,255
  #ellipse[-1] $X,$Y,$Rayon_Cercle_C,$Rayon_Cercle_C,0,1,0xFFFFFFFF,0,0,255,255
  #ellipse[-1] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,0xFFFFFFFF,255,255,0,255

  Nb_boucles_zones=0

  repeat $Nombre_de_zones

   Nb_boucles_zones={$Nb_boucles_zones+1}

   if $Couleurs_aleatoires==1
    R_Tr={round(u)*255}
    V_Tr={round(u)*255}
    B_Tr={round(u)*255}
    R_Trb={round(u)*255}
    V_Trb={round(u)*255}
    B_Trb={round(u)*255}
    R_Tr_B={round(u)*255}
    V_Tr_B={round(u)*255}
    B_Tr_B={round(u)*255}
    R_Tr_Bb={round(u)*255}
    V_Tr_Bb={round(u)*255}
    B_Tr_Bb={round(u)*255}
    R_Cercle={round(u)*255}
    V_Cercle={round(u)*255}
    B_Cercle={round(u)*255}
   endif
   if $Type_Decalage==0

    X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
    Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
    X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
    Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}

    X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
    Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
    X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
    Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}

    X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
    Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}}})}}}
    X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}
    Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}-{180/$Nombre_de_zones}}})}}}

    X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}
    Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle*$Nb_boucles_couches}+{180/$Nombre_de_zones}}})}}}

   elif $Type_Decalage==1

    X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
    Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
    X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}}})}}}
    Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}}})}}}
    X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
    Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}

    X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
    Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
    X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}}})}}}
    Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}}})}}}
    X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
    Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}

    X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
    Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
    X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}}})}}}
    Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}}})}}}
    X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
    Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}

    X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
    Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}

   elif $Type_Decalage==2

    X_A={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
    Y_A={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}+{180/$Nombre_de_zones}}})}}}
    X_B={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}}})}}}
    Y_B={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}}})}}}
    X_C={$X+{$Rayon_Cercle_A*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}
    Y_C={$Y+{$Rayon_Cercle_A*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-3}}-{180/$Nombre_de_zones}}})}}}

    X_D={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
    Y_D={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}+{180/$Nombre_de_zones}}})}}}
    X_E={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}}})}}}
    Y_E={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}}})}}}
    X_F={$X+{$Rayon_Cercle_B*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}
    Y_F={$Y+{$Rayon_Cercle_B*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-2}}-{180/$Nombre_de_zones}}})}}}

    X_G={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
    Y_G={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}+{180/$Nombre_de_zones}}})}}}
    X_H={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}}})}}}
    Y_H={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}}})}}}
    X_I={$X+{$Rayon_Cercle_C*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}
    Y_I={$Y+{$Rayon_Cercle_C*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*{$Nb_Cercles-1}}-{180/$Nombre_de_zones}}})}}}

    X_J={$X+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{cos({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}
    Y_J={$Y+{{$Recouvrement_Triangle+$Rayon_Cercle_D}*{sin({pi/180*{$Angle+{$Decalage_Angle/3*$Nb_boucles_couches*$Nb_Cercles}+{180/$Nombre_de_zones}}})}}}

   endif
   if $Type_Triangles_A==0 # "JDH"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,$R_Tr,$V_Tr,$B_Tr,$A_Tr
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,$R_Trb,$V_Trb,$B_Trb,$A_Trb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==4||$Affichage_Contours==5
     polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_H,$Y_H,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_A==1 # "JDE"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,$R_Tr,$V_Tr,$B_Tr,$A_Tr
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,$R_Trb,$V_Trb,$B_Trb,$A_Trb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==4||$Affichage_Contours==5
     polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_E,$Y_E,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_A==2 # "JDB"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,$R_Tr,$V_Tr,$B_Tr,$A_Tr
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,$R_Trb,$V_Trb,$B_Trb,$A_Trb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==4||$Affichage_Contours==5
     polygon[-2] 3,$X_J,$Y_J,$X_D,$Y_D,$X_B,$Y_B,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_A==3 # "JAH"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,$R_Tr,$V_Tr,$B_Tr,$A_Tr
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,$R_Trb,$V_Trb,$B_Trb,$A_Trb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==4||$Affichage_Contours==5
     polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_H,$Y_H,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_A==4 # "JAE"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,$R_Tr,$V_Tr,$B_Tr,$A_Tr
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,$R_Trb,$V_Trb,$B_Trb,$A_Trb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==4||$Affichage_Contours==5
     polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_E,$Y_E,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_A==5 # "JAB"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,$R_Tr,$V_Tr,$B_Tr,$A_Tr
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,$R_Trb,$V_Trb,$B_Trb,$A_Trb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==2||$Affichage_Contours==4||$Affichage_Contours==5
     polygon[-2] 3,$X_J,$Y_J,$X_A,$Y_A,$X_B,$Y_B,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   endif

   if $Type_Triangles_B==0 # "HBI"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==6
     polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_I,$Y_I,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_B==1 # "HBF"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==6
     polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_F,$Y_F,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   elif $Type_Triangles_B==2 # "HBC"
    if ($Nb_boucles_couches%2)==0
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,$R_Tr_B,$V_Tr_B,$B_Tr_B,$A_Tr_B
    else
     samj_sierpinski_absolu[-1] $Recursions_Sierpinski,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,$R_Tr_Bb,$V_Tr_Bb,$B_Tr_Bb,$A_Tr_Bb
    endif
    if $Affichage_Contours==1||$Affichage_Contours==3||$Affichage_Contours==4||$Affichage_Contours==6
     polygon[-2] 3,$X_H,$Y_H,$X_B,$Y_B,$X_C,$Y_C,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
    endif
   endif

   Angle={$Angle_inclinaison+{$Increment_angle*$Nb_boucles_zones}}

  done

  Nb_Cercles={$Nb_Cercles-3}
  H_Tr=$H_Tr_C
  Rayon_Cercle_Origine=$Rayon_Cercle_D

 done

 if $Afficher_Cercle==1
  $Largeur_Origine,$Hauteur_Origine,1,4
  polygon[-1] 4,0,0,{$Largeur_Origine-1},0,{$Largeur_Origine-1},{$Hauteur_Origine-1},0,{$Hauteur_Origine-1},1,0xFFFFFFFF,0,0,0,1
  ellipse[-1] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,$R_Cercle,$V_Cercle,$B_Cercle,$A_Cercle
  blend[-2,-1] alpha,1,1
 endif

 if $Affichage_Contours>0
  if $Affichage_Contours>3
   ellipse[-2,-3] $X,$Y,$Rayon_Cercle_D,$Rayon_Cercle_D,0,1,0xFFFFFFFF,$R_Contours,$V_Contours,$B_Contours,$A_Contours
  endif
  if $Dilatation>1 dilate_circ[-2] $Dilatation endif
  if $Flou>0 blur[-1,-2] $Flou,0 endif
  if $Deformation>0 deform[-1,-2] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-2] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-2] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
  blend[-2,-1] alpha,1,1
 else
  if $Dilatation>1 dilate_circ[-1] $Dilatation endif
  if $Flou>0 blur[-1] $Flou,0 endif
  if $Deformation>0 deform[-1] $Deformation endif
  if $Bruit>0 fx_noise[-1] {$Bruit+50},0,22,1 endif
  if $Ombre>0
   drop_shadow[-1] $X_Ombre,$Y_Ombre,$Smoothness_Ombre,$Curvature_Ombre
   shift[-1] {$Compensation_Decalage_Ombre_X}%,{$Compensation_Decalage_Ombre_Y}%,0,0,0
  endif
 endif

 if $Inversions==1
  mirror[-1] x
 elif $Inversions==2
  mirror[-1] y
 elif $Inversions==3
  mirror[-1] x
  mirror[-1] y
 endif

 blend[-1,-2] alpha,1,0
#################################################
##                                             ##
##       FIN Rosace_Triangles_Sierpinski       ##
##                                             ##
#################################################
#################################################
##                                             ##
##               samj_Noel_2016                ##
##                                             ##
#################################################
# 2016/12/20 gmic 1.8.0 fx_smooth_antialias
#@gui Christmas Balls  : samj_Noel_2016 , samj_Noel_2016(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Noel_2016</b></span>")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(50,0,100)
#@gui : Ellipse / Circle A = Float(100,1,500)
#@gui : Ellipse B = Float(150,1,500)
#@gui : Depth Max = int(7,1,13)
#@gui : Line = bool(0)
#@gui : Color = color(240,45,15,255)
#@gui : Color Variation = int(-15,-255,255)
#@gui : Spacing = Float(2.5,0,8)
#@gui : Rendering = choice(2,"Ellipse A","Ellipse B","Ball A","Ball B")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Ball [light]</b></span>")
#@gui : Specular light = float(0.8,0,8)
#@gui : Specular size = float(1,0,8)
#@gui : Shadow = float(1.5,0,4)
#@gui : Angle = float(0,-180,180)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Rotation</b></span>")
#@gui : Rotate = Float(0,-180,180)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [antialias] = bool(0)
#@gui : Amplitude = float(0.25,0,100)
#@gui : Edge threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Noel_2016 :

x={round({{w}/100*$1})}
y={round({{h}/100*$2})}
rayonA={{w}/1000*$3}
rayonB={{w}/1000*$4}
depth_max=$5
fil=$6
R_DT=$7
V_DT=$8
B_DT=$9
A_DT=$10
Variation_Couleur=$11
K_espacement=$12
Type_Rendu=$13
Ball_Specular_light=$14
Ball_Specular_size=$15
Ball_Shadow=$16
Ball_Angle=$17
Rotation=$18
Validation_Smooth_Antialias=$19
V_Amplitude=$20
V_Edge_Threshold=$21
V_Smoothness=$22

depth=0
L_Origine={w}
H_Origine={h}

 to_rgba[-1]
 $L_Origine,$H_Origine,1,4
 samj_guirlande[-1] $x,$y,$rayonA,$rayonB,$depth,$depth_max,$fil,$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$K_espacement,$L_Origine,$H_Origine,$Type_Rendu,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow,$Ball_Angle
 if $Rotation!=0 rotate[-1] $Rotation endif
 if $Validation_Smooth_Antialias==1 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness endif
 blend[-1,-2] alpha

samj_guirlande :
# samj_guirlande x , y , rayonA , rayonB , depth , depth_max , fil , R_a , V_a , B_a , A_a , Variation_Couleur , K_espacement , L_Origine , H_Origine , Type_Rendu , Ball_Specular_light , Ball_Specular_size , Ball_Shadow , Ball_Angle
x=$1
y=$2
rayonA=$3
rayonB=$4
depth=$5
depth_max=$6
fil=$7
R_DT=$8
V_DT=$9
B_DT=$10
A_DT=$11
Variation_Couleur=$12
K_espacement=$13
L_Origine=$14
H_Origine=$15
Type_Rendu=$16
Ball_Specular_light=$17
Ball_Specular_size=$18
Ball_Shadow=$19
Ball_Angle=$20

if $depth<$depth_max&&$rayonA>1&&$rayonB>1
 if $Type_Rendu==0
  ellipse[-1] $x,$y,$rayonA,$rayonB,1,1,$R_DT,$V_DT,$B_DT,$A_DT
 elif $Type_Rendu==1
  $L_Origine,$H_Origine,1,4
  ellipse[-1] $x,$y,$rayonA,$rayonB,1,1,$R_DT,$V_DT,$B_DT,$A_DT
  rv[-1,-2]
  blend[-1,-2] alpha
 elif $Type_Rendu==2
  $L_Origine,$H_Origine,1,4
  ball {$rayonA*2},$R_DT,$V_DT,$B_DT,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow
  rotate[-1] $Ball_Angle
  autocrop[-1] 0
  blend[-1,-2] alpha
  shift[-1] {-1*{{$L_Origine/2}-$x}},{$y-{$H_Origine/2}},0,0,0
  blend[-1,-2] alpha
 elif $Type_Rendu==3
  $L_Origine,$H_Origine,1,4
  $L_Origine,$H_Origine,1,4
  ball {$rayonA*2},$R_DT,$V_DT,$B_DT,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow
  rotate[-1] $Ball_Angle
  autocrop[-1] 0
  blend[-1,-2] alpha
  shift[-1] {-1*{{$L_Origine/2}-$x}},{$y-{$H_Origine/2}},0,0,0
  blend[-1,-2] alpha
  rv[-1,-2]
  blend[-1,-2] alpha
 endif
 R_DT={$R_DT+$Variation_Couleur}
 V_DT={$V_DT+$Variation_Couleur}
 B_DT={$B_DT+$Variation_Couleur}
 if $R_DT>255
  R_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
 endif
 if $V_DT>255
  V_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
 endif
 if $B_DT>255
  B_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
 endif
 if $R_DT<0
  R_DT={$R_DT+$Variation_Couleur+{$Variation_Couleur*{$depth_max-$depth}}}
 endif
 if $V_DT<0
  V_DT={$V_DT+$Variation_Couleur+{$Variation_Couleur*{$depth_max-$depth}}}
 endif
 if $B_DT<0
  B_BT={$B_DT+$Variation_Couleur+{$Variation_Couleur*{$depth_max-$depth}}}
 endif
 samj_guirlande[-1] {$x+{$rayonA*$K_espacement}},$y,{$rayonA/2},{$rayonB/2},{$depth+1},$depth_max,$fil,$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$K_espacement,$L_Origine,$H_Origine,$Type_Rendu,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow,$Ball_Angle
 samj_guirlande[-1] {$x-{$rayonA*$K_espacement}},$y,{$rayonA/2},{$rayonB/2},{$depth+1},$depth_max,$fil,$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$K_espacement,$L_Origine,$H_Origine,$Type_Rendu,$Ball_Specular_light,$Ball_Specular_size,$Ball_Shadow,$Ball_Angle
 if $fil==1
  $L_Origine,$H_Origine,1,4
  line[-1] {$x+{$rayonA*$K_espacement}},$y,{$x-{$rayonA*2.5}},$y,1,$R_DT,$V_DT,$B_DT,$A_DT
  rv[-1,-2]
  blend[-1,-2] alpha
 endif
endif

#################################################
##                                             ##
##             FIN samj_Noel_2016              ##
##                                             ##
#################################################
#################################################
##                                             ##
##            samj_Arbre_Pythagore             ##
##                                             ##
#################################################
# 2016/12/20 gmic 1.8.0 gui_split_preview fx_smooth_antialias
#@gui Pythagoras Tree  : samj_Arbre_Pythagore , samj_Arbre_Pythagore_preview
#@gui : sep = separator(), url = link("Source code from rosettacode.org","https://rosettacode.org/wiki/Pythagoras_tree")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(95,0,100)
#@gui : Depth = int(11,1,14)
#@gui : Dimension [Diff] = Float(12,4,100)
#@gui : Color = color(255,0,0,255)
#@gui : Color Variation [Random -1] = int(20,-1,255)
#@gui : Rendering = choice("A","B","C")
#@gui : Dilatation = int(1,1,8)
#@gui : Rotate Tree = Float(0,-180,180)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [Antialias] = bool(0)
#@gui : Amplitude = float(0.25,0,100)
#@gui : Edge Threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Arbre_Pythagore :
repeat $! l[$>]

x1={round({{w}/100*$1})}
y1={round({{h}/100*$2})}
depth_max=$3
diff={round({{w}/$4})}
R_a=$5
V_a=$6
B_a=$7
A_a=$8
Variation_Couleur=$9
Rendu=$10
Dilatation=$11
Rotation=$12
Validation_Smooth_Antialias=$13
V_Amplitude=$14
V_Edge_Threshold=$15
V_Smoothness=$16

 to_rgba[-1]
 {w},{h},1,4
 #  samj_pythagoras_tree  x1 , y1 , x2 , y2 , depth , R_a , V_a , B_a , A_a , Variation_Couleur , depth_max , Rendu
 samj_pythagoras_tree[-1] {$x1-$diff},$y1,{$x1+$diff},$y1,0,$R_a,$V_a,$B_a,$A_a,$Variation_Couleur,$depth_max,$Rendu
 if $Rotation!=0 rotate[-1] $Rotation endif
 dilate[-1] $Dilatation
 if $Validation_Smooth_Antialias==1 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness endif
 blend[-1,-2] alpha

endl done

samj_Arbre_Pythagore_preview :
 gui_split_preview "samj_Arbre_Pythagore $*",$-1

samj_pythagoras_tree :
x1=$1
y1=$2
x2=$3
y2=$4
depth=$5
R_DT=$6
V_DT=$7
B_DT=$8
A_DT=$9
Variation_Couleur=$10
depth_max=$11
Rendu=$12
if $depth<$depth_max
 dx={$x2-$x1}
 dy={$y1-$y2}
 x3={$x2-$dy}
 y3={$y2-$dx}
 x4={$x1-$dy}
 y4={$y1-$dx}
 x5={$x4+{{$dx-$dy}/2}}
 y5={$y4-{{$dx+$dy}/2}}
 if $Variation_Couleur<0
  R_DT={round(u(0,255))}
  V_DT={round(u(0,255))}
  B_DT={round(u(0,255))}
 elif $Variation_Couleur>0
  R_DT={$Variation_Couleur+$R_DT}
  V_DT={$Variation_Couleur+$V_DT}
  B_DT={$Variation_Couleur+$B_DT}
  if $R_DT>255
   R_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
  endif
  if $V_DT>255
   V_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
  endif
  if $B_DT>255
   B_DT={255-{$Variation_Couleur*{$depth_max-$depth}}}
  endif
 endif
 if $Rendu==0
  line[-1] $x1,$y1,$x2,$y2,1,$R_DT,$V_DT,$B_DT,$A_DT
  line[-1] $x2,$y2,$x3,$y3,1,$R_DT,$V_DT,$B_DT,$A_DT
  line[-1] $x3,$y3,$x4,$y4,1,$R_DT,$V_DT,$B_DT,$A_DT
  line[-1] $x4,$y4,$x1,$y1,1,$R_DT,$V_DT,$B_DT,$A_DT
 elif $Rendu==1
  if ($depth%2)==0
   line[-1] $x1,$y1,$x2,$y2,1,$R_DT,$V_DT,$B_DT,$A_DT
   line[-1] $x2,$y2,$x3,$y3,1,$R_DT,$V_DT,$B_DT,$A_DT
   line[-1] $x3,$y3,$x4,$y4,1,$R_DT,$V_DT,$B_DT,$A_DT
   line[-1] $x4,$y4,$x1,$y1,1,$R_DT,$V_DT,$B_DT,$A_DT
  else
   line[-1] $x1,$y1,$x2,$y2,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
   line[-1] $x2,$y2,$x3,$y3,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
   line[-1] $x3,$y3,$x4,$y4,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
   line[-1] $x4,$y4,$x1,$y1,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
  endif
 elif $Rendu==2
  if ($depth%2)==0
   line[-1] $x1,$y1,$x2,$y2,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
   line[-1] $x2,$y2,$x3,$y3,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
   line[-1] $x3,$y3,$x4,$y4,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
   line[-1] $x4,$y4,$x1,$y1,1,{255-$R_DT},{255-$V_DT},{255-$B_DT},$A_DT
  else
   line[-1] $x1,$y1,$x2,$y2,1,$R_DT,$V_DT,$B_DT,$A_DT
   line[-1] $x2,$y2,$x3,$y3,1,$R_DT,$V_DT,$B_DT,$A_DT
   line[-1] $x3,$y3,$x4,$y4,1,$R_DT,$V_DT,$B_DT,$A_DT
   line[-1] $x4,$y4,$x1,$y1,1,$R_DT,$V_DT,$B_DT,$A_DT
  endif
 endif
 samj_pythagoras_tree[-1] $x4,$y4,$x5,$y5,{$depth+1},$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$depth_max,$Rendu
 samj_pythagoras_tree[-1] $x5,$y5,$x3,$y3,{$depth+1},$R_DT,$V_DT,$B_DT,$A_DT,$Variation_Couleur,$depth_max,$Rendu
endif

#################################################
##                                             ##
##          FIN samj_Arbre_Pythagore           ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Fractal_Tree              ##
##                                             ##
#################################################
# 2016/12/20 gmic 1.8.0 gui_split_preview
#@gui Fractal Tree  : samj_Fractal_Tree , samj_Fractal_Tree_preview
#@gui : sep = separator(), url = link("Source code from rosettacode.org","https://www.rosettacode.org/wiki/Fractal_tree")
#@gui : X Origine = Float(50,0,100)
#@gui : Y Origine = Float(100,0,100)
#@gui : Angle Origine = Float(-90,-360,360)
#@gui : Depth = int(11,1,13)
#@gui : Variation Dimension = Float(10,1,500)
#@gui : Variation Angle = Float(20,-360,360)
#@gui : Color = color(255,0,0,255)
#@gui : Color Variation [random -1] = int(20,-1,255)
#@gui : Rendering = choice("Lines","Circles A","Circles B")
#@gui : Circle Dimension = int(4,1,50)
#@gui : Dilatation = int(1,1,8)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [antialias] = bool(0)
#@gui : Amplitude = float(0.25,0,100)
#@gui : Edge threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Fractal_Tree :
repeat $! l[$>]

x1={round({{w}/100*$1})}
y1={round({{h}/100*$2})}
angle=$3
depth=$4
Variation_Dimension={{w}/1000*$5}
Variation_angle=$6
R_a=$7
V_a=$8
B_a=$9
A_a=$10
Variation_Couleur=$11
Motif=$12
Dimension_Motif=$13
Dilatation=$14
Validation_Smooth_Antialias=$15
V_Amplitude=$16
V_Edge_Threshold=$17
V_Smoothness=$18

 to_rgba[-1]
 {w},{h},1,4
 samj_drawTree[-1] $x1,$y1,$angle,$depth,$Variation_Dimension,$Variation_angle,$R_a,$V_a,$B_a,$A_a,$Variation_Couleur,$Motif,$Dimension_Motif
 dilate[-1] $Dilatation
 if $Validation_Smooth_Antialias==1 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness endif
 blend[-1,-2] alpha

endl done

samj_Fractal_Tree_preview :
 gui_split_preview "samj_Fractal_Tree $*",$-1

samj_drawTree :
if $4!=0
 R_DT=$7
 V_DT=$8
 B_DT=$9
 A_DT=$10
 if $11<0
  R_DT={round(u(0,255))}
  V_DT={round(u(0,255))}
  B_DT={round(u(0,255))}
 elif $11>0
  R_DT={$11+$R_DT}
  V_DT={$11+$V_DT}
  B_DT={$11+$B_DT}
  if $R_DT>255
   R_DT={255-{$11*$4}}
  endif
  if $V_DT>255
   V_DT={255-{$11*$4}}
  endif
  if $B_DT>255
   B_DT={255-{$11*$4}}
  endif
 endif
 x2={$1+{cos({$3*{pi/180}})*$4*$5}}
 y2={$2+{sin({$3*{pi/180}})*$4*$5}}
 if $12==0
  line[-1] $1,$2,$x2,$y2,1,$7,$8,$9,$10
 elif $12==1
  line[-1] $1,$2,$x2,$y2,1,$7,$8,$9,$10
  circle[-1] $x2,$y2,$13,1,$R_DT,$V_DT,$B_DT,$A_DT
 elif $12==2
  line[-1] $1,$2,$x2,$y2,1,$7,$8,$9,$10
  circle[-1] $x2,$y2,$13,1,0xFFFFFFFF,$R_DT,$V_DT,$B_DT,$A_DT
 endif
 samj_drawTree[-1] $x2,$y2,{$3-$6},{$4-1},$5,$6,$R_DT,$V_DT,$B_DT,$A_DT,$11,$12,$13
 if $11<0
  R_DT={round(u(0,255))}
  V_DT={round(u(0,255))}
  B_DT={round(u(0,255))}
 endif
 samj_drawTree[-1] $x2,$y2,{$3+$6},{$4-1},$5,$6,$R_DT,$V_DT,$B_DT,$A_DT,$11,$12,$13
endif

#################################################
##                                             ##
##            FIN samj_Fractal_Tree            ##
##                                             ##
#################################################


#################################################################################################################################################################################################
#
#                                                                                                                                                                                          REPAIR
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_repair :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Repair</b>
#################################################
##                                             ##
##               samj_CorLine_B                ##
##                                             ##
#################################################

# 2015/05/11 origine

#@gui CorLine B : samj_CorLine_B, samj_CorLine_B_preview
#@gui :_=note("<i>samj_CorLine_B</i> pour vieilles photos décolorées scannées \r\n<i>samj_CorLine_B</i> for old faded scanned photos")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Couleurs</b></span>")
#@gui : Balance = int(0,-64,64)
#@gui : Gamma = float(1,0.8,2.2)
#@gui : Chroma = int(10,0,50)
#@gui : Cyan = int(0,-127,128)
#@gui : Magenta = int(0,-127,128)
#@gui : Jaune = int(0,-127,128)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Netteté</b></span>")
#@gui : Netteté A = float(0.5,0,1.5)
#@gui : Netteté B = float(0,0,1.5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Réparation</b></span>")
#@gui : Type = choice(0,"Anisotropic","Diffusion")
#@gui : Amplitude = int(50,0,100)
#@gui : Répétition(s) = int(1,1,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Preview</b></span>")
#@gui : Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/05/11</i>.</small>")

samj_CorLine_B:

 Balance_Couleurs=$1
 Valeur_Gamma=$2
 Chroma_Couleurs=$3
 Cyan=$4
 Magenta=$5
 Jaune=$6
 Nettete_A=$7
 Nettete_B=$8
 Type_Reparation=$9
 Amplitude_Reparation=$10
 Repetition_Reparation=$11

 +Je_passe_l_hiver_en_Floride[0]
 to_rgb[-1]
 fx_balance_gamma[-1] {127+$Balance_Couleurs},{127+$Balance_Couleurs},{127+$Balance_Couleurs},1
 fx_boost_chroma[-1] {$Chroma_Couleurs/100},1
 fx_unsharp_octave[-1] 1,5,$Nettete_A,0,2,0,24
 apply_gamma[-1] $Valeur_Gamma

 if $Type_Reparation==0
  repeat $Repetition_Reparation
   fx_smooth_anisotropic[-1] $Amplitude_Reparation,0.7,0.3,0.6,1.1,0.8,30,2,0,1,1,2
  done
 elif $Type_Reparation==1
  repeat $Repetition_Reparation
   fx_smooth_diffusion[-1] 0.7,0.3,0.6,{0.5+{$Amplitude_Reparation/100}},15,8,0,0,24
  done
 endif

 if $Nettete_B>0 fx_unsharp_octave[-1] 1,5,$Nettete_B,0,2,0,24 endif

 if $Cyan!=0
  Cyan={127+$Cyan}
  apply_channels[-1] "apply_curve 1,0,0,128,"$Cyan",255,255",cmy_c,0
 endif

 if $Magenta!=0
  Magenta={127+$Magenta}
  apply_channels[-1] "apply_curve 1,0,0,128,"$Magenta",255,255",cmy_m,0
 endif

 if $Jaune!=0
  Jaune={127+$Jaune}
  apply_channels[-1] "apply_curve 1,0,0,128,"$Jaune",255,255",cmy_y,0
 endif

 rv[-1,-2]

samj_CorLine_B_preview :
  gui_split_preview "samj_CorLine_B $*",$-1

#################################################
##                                             ##
##             FIN samj_CorLine_B              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                samj_CorLine                 ##
##                                             ##
#################################################

# 2015/05/10 origine

#@gui CorLine : samj_CorLine, samj_CorLine_preview
#@gui :_=note("<i>samj_CorLine</i> pour vieilles photos décolorées scannées \r\n<i>samj_CorLine</i> for old faded scanned photos")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Couleurs</b></span>")
#@gui : Balance = int(0,-64,64)
#@gui : Chroma = int(10,0,50)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Netteté</b></span>")
#@gui : Netteté A = float(0.5,0,1.5)
#@gui : Netteté B = float(0,0,1.5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Réparation</b></span>")
#@gui : Type = choice(0,"Anisotropic","Diffusion")
#@gui : Amplitude = int(50,0,100)
#@gui : Répétition(s) = int(1,1,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Preview</b></span>")
#@gui : Type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate horizontal","Duplicate vertical")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/05/10</i>.</small>")

samj_CorLine:

 Balance_Couleurs=$1
 Chroma_Couleurs=$2
 Nettete_A=$3
 Nettete_B=$4
 Type_Reparation=$5
 Amplitude_Reparation=$6
 Repetition_Reparation=$7

 +Je_passe_l_hiver_en_Floride[0]
 to_rgb[-1]
 fx_balance_gamma[-1] {127+$Balance_Couleurs},{127+$Balance_Couleurs},{127+$Balance_Couleurs},1
 fx_boost_chroma[-1] {$Chroma_Couleurs/100},1
 fx_unsharp_octave[-1] 1,5,$Nettete_A,0,2,0,24

 if $Type_Reparation==0
  repeat $Repetition_Reparation
   fx_smooth_anisotropic[-1] $Amplitude_Reparation,0.7,0.3,0.6,1.1,0.8,30,2,0,1,1,2
  done
 elif $Type_Reparation==1
  repeat $Repetition_Reparation
   fx_smooth_diffusion[-1] 0.7,0.3,0.6,{0.5+{$Amplitude_Reparation/100}},15,8,0,0,24
  done
 endif

 if $Nettete_B>0 fx_unsharp_octave[-1] 1,5,$Nettete_B,0,2,0,24 endif

 rv[-1,-2]

samj_CorLine_preview :
  gui_split_preview "samj_CorLine $*",$-1

#################################################
##                                             ##
##              FIN samj_CorLine               ##
##                                             ##
#################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                                       SEQUENCES
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_sequences :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Sequences</b>

#################################################################################################################################################################################################
#
#                                                                                                                                                                                         VARIOUS
#
#################################################################################################################################################################################################

##      POUR NE PAS AVOIR DE PROBLÈME AVEC LE SOUS-DOSSIER SUIVANT
samj_rien_various :
 Je_passe_l_hiver_en_Floride[-1]

#@gui _
#@gui <b>Various</b>


#################################################################################################################################################################################################
#
#                                                                                                                                                                             FONCTIONS ET DIVERS
#
#################################################################################################################################################################################################
####    Quelques lettres
####    #@gui :_=note("10 0 &#100; 1 &#101; 2 &#102; 3 &#103; 4 &#104; 5 &#105; 6 &#106; 7 &#107; 8 &#108; 9 &#109;   ")
####    #@gui :_=note("11 0 &#110; 1 &#111; 2 &#112; 3 &#113; 4 &#114; 5 &#115; 6 &#116; 7 &#117; 8 &#118; 9 &#119;   ")
####    #@gui :_=note("12 0 &#120; 1 &#121; 2 &#122; 3 &#123; 4 &#124; 5 &#125; 6 &#126; 7 &#127; 8 &#128; 9 &#129;   ")
####    #@gui :_=note("13 0 &#130; 1 &#131; 2 &#132; 3 &#133; 4 &#134; 5 &#135; 6 &#136; 7 &#137; 8 &#138; 9 &#139;   ")
####    #@gui :_=note("14 0 &#140; 1 &#141; 2 &#142; 3 &#143; 4 &#144; 5 &#145; 6 &#146; 7 &#147; 8 &#148; 9 &#149;   ")
####    #@gui :_=note("15 0 &#150; 1 &#151; 2 &#152; 3 &#153; 4 &#154; 5 &#155; 6 &#156; 7 &#157; 8 &#158; 9 &#159;   ")
####    #@gui :_=note("16 0 &#160; 1 &#161; 2 &#162; 3 &#163; 4 &#164; 5 &#165; 6 &#166; 7 &#167; 8 &#168; 9 &#169;   ")
####    #@gui :_=note("17 0 &#170; 1 &#171; 2 &#172; 3 &#173; 4 &#174; 5 &#175; 6 &#176; 7 &#177; 8 &#178; 9 &#179;   ")
####    #@gui :_=note("18 0 &#180; 1 &#181; 2 &#182; 3 &#183; 4 &#184; 5 &#185; 6 &#186; 7 &#187; 8 &#188; 9 &#189;   ")
####    #@gui :_=note("19 0 &#190; 1 &#191; 2 &#192; 3 &#193; 4 &#194; 5 &#195; 6 &#196; 7 &#197; 8 &#198; 9 &#199;   ")
####    #@gui :_=note("20 0 &#200; 1 &#201; 2 &#202; 3 &#203; 4 &#204; 5 &#205; 6 &#206; 7 &#207; 8 &#208; 9 &#209;   ")
####    #@gui :_=note("21 0 &#210; 1 &#211; 2 &#212; 3 &#213; 4 &#214; 5 &#215; 6 &#216; 7 &#217; 8 &#218; 9 &#219;   ")
####    #@gui :_=note("22 0 &#220; 1 &#221; 2 &#222; 3 &#223; 4 &#224; 5 &#225; 6 &#226; 7 &#227; 8 &#228; 9 &#229;   ")
####    #@gui :_=note("23 0 &#230; 1 &#231; 2 &#232; 3 é 4 &#234; 5 &#235; 6 &#236; 7 &#237; 8 &#238; 9 &#239;   ")
####    #@gui :_=note("24 0 &#240; 1 &#241; 2 &#242; 3 &#243; 4 &#244; 5 &#245; 6 &#246; 7 &#247; 8 &#248; 9 &#249;   ")
####    #@gui :_=note("25 0 &#250; 1 &#251; 2 &#252; 3 &#253; 4 &#254; 5 &#255; 6 &#256; 7 &#257; 8 &#258; 9 &#259;   ")
####    #@gui :_=note("26 0 &#260; 1 &#261; 2 &#262; 3 &#263; 4 &#264; 5 &#265; 6 &#266; 7 &#267; 8 &#268; 9 &#269;   ")
####    #@gui :_=note("27 0 &#270; 1 &#271; 2 &#272; 3 &#273; 4 &#274; 5 &#275; 6 &#276; 7 &#277; 8 &#278; 9 &#279;   ")
####    #@gui :_=note("28 0 &#280; 1 &#281; 2 &#282; 3 &#283; 4 &#284; 5 &#285; 6 &#286; 7 &#287; 8 &#288; 9 &#289;   ")
####    #@gui :_=note("29 0 &#290; 1 &#291; 2 &#292; 3 &#293; 4 &#294; 5 &#295; 6 &#296; 7 &#297; 8 &#298; 9 &#299;   ")
####    #@gui :_=note("30 0 &#300; 1 &#301; 2 &#302; 3 &#303; 4 &#304; 5 &#305; 6 &#306; 7 &#307; 8 &#308; 9 &#309;   ")
####    #@gui :_=note("31 0 &#310; 1 &#311; 2 &#312; 3 &#313; 4 &#314; 5 &#315; 6 &#316; 7 &#317; 8 &#318; 9 &#319;   ")
####    #@gui :_=note("32 0 &#320; 1 &#321; 2 &#322; 3 &#323; 4 &#324; 5 &#325; 6 &#326; 7 &#327; 8 &#328; 9 &#329;   ")
####    #@gui :_=note("33 0 &#330; 1 &#331; 2 &#332; 3 &#333; 4 &#334; 5 &#335; 6 &#336; 7 &#337; 8 &#338; 9 &#339;   ")
####    #@gui :_=note("34 0 &#340; 1 &#341; 2 &#342; 3 &#343; 4 &#344; 5 &#345; 6 &#346; 7 &#347; 8 &#348; 9 &#349;   ")
####    #@gui :_=note("35 0 &#350; 1 &#351; 2 &#352; 3 &#353; 4 &#354; 5 &#355; 6 &#356; 7 &#357; 8 &#358; 9 &#359;   ")
####    #@gui :_=note("36 0 &#360; 1 &#361; 2 &#362; 3 &#363; 4 &#364; 5 &#365; 6 &#366; 7 &#367; 8 &#368; 9 &#369;   ")
####    #@gui :_=note("37 0 &#370; 1 &#371; 2 &#372; 3 &#373; 4 &#374; 5 &#375; 6 &#376; 7 &#377; 8 &#378; 9 &#379;   ")
####    #@gui :_=note("38 0 &#380; 1 &#381; 2 &#382; 3 &#383; 4 &#384; 5 &#385; 6 &#386; 7 &#387; 8 &#388; 9 &#389;   ")
####    #@gui :_=note("39 0 &#390; 1 &#391; 2 &#392; 3 &#393; 4 &#394; 5 &#395; 6 &#396; 7 &#397; 8 &#398; 9 &#399;   ")

####     #@gui :_=note("0 \303\200  À    )
####     #@gui :_=note("1 \303\201  Á    )
####     #@gui :_=note("2 \303\202  Â    )
####     #@gui :_=note("3 \303\203      )
####     #@gui :_=note("4 \303\204  Ä    )
####     #@gui :_=note("5 \303\205      )
####     #@gui :_=note("6 \303\206  AE collés )
####     #@gui :_=note("7 \303\207  Ç    )
####     #@gui :_=note("0 \303\210  È    )
####     #@gui :_=note("1 É  É    )
####     #@gui :_=note("2 \303\212  Ê    )
####     #@gui :_=note("3 \303\213  Ë    )
####     #@gui :_=note("4 \303\214  Ì    )
####     #@gui :_=note("5 \303\215  Í    )
####     #@gui :_=note("6 \303\216  Î    )
####     #@gui :_=note("7 \303\217  Ï    )
####     #@gui :_=note("0 \303\220      )
####     #@gui :_=note("1 \303\221      )
####     #@gui :_=note("2 \303\222  Ò    )
####     #@gui :_=note("3 \303\223  Ó    )
####     #@gui :_=note("4 \303\224  Ô    )
####     #@gui :_=note("5 \303\225      )
####     #@gui :_=note("6 \303\226  Ö    )
####     #@gui :_=note("7 \303\227      )
####     #@gui :_=note("0 \303\230  phi  )
####     #@gui :_=note("1 \303\231  Ù    )
####     #@gui :_=note("2 \303\232  Ú    )
####     #@gui :_=note("3 \303\233  Û    )
####     #@gui :_=note("4 \303\234  Ü    )
####     #@gui :_=note("5 \303\235  Ý    )
####     #@gui :_=note("6 \303\236       )
####     #@gui :_=note("7 \303\237  bêta )
####     #@gui :_=note("0 à   à   )
####     #@gui :_=note("1 \303\241   á   )
####     #@gui :_=note("2 \303\242   â   )
####     #@gui :_=note("3 \303\243      )
####     #@gui :_=note("4 \303\244   ä   )
####     #@gui :_=note("5 \303\245      )
####     #@gui :_=note("6 \303\246   ae collés )
####     #@gui :_=note("7 ç   ç   )
####     #@gui :_=note("0 è   è   )
####     #@gui :_=note("1 é   é   )
####     #@gui :_=note("2 \303\252   ê   )
####     #@gui :_=note("3 \303\253   ë   )
####     #@gui :_=note("4 \303\254   ì   )
####     #@gui :_=note("5 \303\255   í   )
####     #@gui :_=note("6 \303\256   î   )
####     #@gui :_=note("7 \303\257   ï   )
####     #@gui :_=note("0 \303\260      )
####     #@gui :_=note("1 \303\261      )
####     #@gui :_=note("2 \303\262   ò   )
####     #@gui :_=note("3 \303\263   ó   )
####     #@gui :_=note("4 ô   ô   )
####     #@gui :_=note("5 \303\265   ö   )
####     #@gui :_=note("6 \303\266      )
####     #@gui :_=note("7 \303\267      )
####     #@gui :_=note("0 \303\270   ù   )
####     #@gui :_=note("1 \303\271   ú   )
####     #@gui :_=note("2 \303\272   û   )
####     #@gui :_=note("3 \303\273      )
####     #@gui :_=note("4 \303\274   ý   )
####     #@gui :_=note("5 \303\275      )
####     #@gui :_=note("6 \303\276      )
####     #@gui :_=note("7 \303\277   ÿ   )

#################################################
##                                             ##
##             samj_resize_screen              ##
##                                             ##
#################################################

#@cli samj_resize_screen : expand={ 0 | 1 }
#@cli : Mettre l'image selon les dimensions de l'écran. / Put the image to the dimensions of the screen.
#@cli : $ image.jpg samj_resize_screen
samj_resize_screen :
	skip ${1=1}
	Screen_W={*,u}
	Screen_H={*,v}
	Image_W={w}
	Image_H={h}
	Scr_Rap={$Screen_W/$Screen_H}
	Img_Rap={$Image_W/$Image_H}
	if {$Scr_Rap}>{$Img_Rap}
		resize {$Image_W/$Image_H*$Screen_H},$Screen_H
		if $1==1 to_a expand_x {{$Screen_W-{w}}/2},0 fi
	else
		resize $Screen_W,{$Image_H/$Image_W*$Screen_W}
		if $1==1 to_a expand_y {{$Screen_H-{h}}/2},0 fi
	fi
#################################################
##                                             ##
##           FIN samj_resize_screen            ##
##                                             ##
#################################################

#################################################
##                                             ##
##          samj_full_screen_display           ##
##                                             ##
#################################################

#@cli samj_full_screen_display : _monitor={ 0 | 1 },_width>0,_height>0,_time_ms>=0
#@cli : Affiche une image en plein écran, soit selon les caractéristiques de l'écran ou selon les dimensions de $2 et $3. Possibilité d'activer une temporisation en ms ($4).
#@cli : L'appui sur une des touches du clavier 'Q', 'Échappement', 'Barre d'espacement' et 'Entrée' permet d'arrêter l'affichage.
#@cli : Displays a full screen image, depending on the characteristics of the screen or dimensions ($2,$3). Ability to activate a ms delay ($4).
#@cli : The keyboard keys 'Q', 'Escape', 'Space bar' and 'Enter' allows you to stop the display.
#@cli : Valeurs par défaut / Default values: 'monitor=1', 'width=800', 'height=600', 'time_ms=5000'.
#@cli : $ image.jpg +samj_full_screen_display 0,400,300,4000 blur 20 +samj_full_screen_display
samj_full_screen_display :
	skip ${1=1},${2=800},${3=600},${4=5000}
	if $1==1
		Screen_W={*,u}
		Screen_H={*,v}
	else
		if ["'$2'"]=='' Screen_W=800 else Screen_W=$2 fi
		if ["'$3'"]=='' Screen_H=600 else Screen_H=$3 fi
	fi
	Image_W={w}
	Image_H={h}
	Scr_Rap={$Screen_W/$Screen_H}
	Img_Rap={$Image_W/$Image_H}
	if {$Scr_Rap}>{$Img_Rap}
		resize {$Image_W/$Image_H*$Screen_H},$Screen_H
		expand_x {{$Screen_W-{w}}/2},0
	else
		resize $Screen_W,{$Image_H/$Image_W*$Screen_W}
		expand_y {{$Screen_H-{h}}/2},0
	fi
	if $1==1 window $Screen_W,$Screen_H,0,1 else window $Screen_W,$Screen_H,0,0,5%,5%,$Screen_W*$Screen_H fi
	if $4>0
		Pre=50 # ms 
		Bc={$4/$Pre}
		repeat $Bc
			if {{*,ESC}||{*,Q}||{*,SPACE}||{*,ENTER}} break fi # Merci à Garagecoder pour l'idée
			wait $Pre
		done
	fi
	rm

#################################################
##                                             ##
##        FIN samj_full_screen_display         ##
##                                             ##
#################################################

#################################################
##                                             ##
##         samj_test_paint_gmic_gimp           ##
##                                             ##
#################################################

#@cli samj_test_paint_gmic_gimp : _Iterations>0,_Seed>0,0.01<=_DiffusionTensors<=0.1,0<=_Blur<=10,_ImageSequence={0=No | 1=Yes},_Brush={0=Ellipse | 1=Circle},0.1<=_BrushSize>0<=4
#@cli : Paint an Image by Randomly Exploring a Space of Brush Strokes by David Tschumperlé.
#@cli : Default values: 'Iterations=200', 'Seed=0', 'DiffusionTensors=0.01', 'Blur=10', 'ImageSequence=0', 'Brush=0' and 'BrushSize=1'.
#@cli : $ image.jpg samj_test_paint_gmic_gimp 300

samj_test_paint_gmic_gimp : check $1>=1 skip "${1=200},${2=0},${3=0.01},${4=10},${5=0},${6=0},${7=1}"

# Version 2021/09/01
# Auteur David Tschumperlé
# A Greedy Algorithm to Paint an Image by Randomly Exploring a Space of Brush Strokes
# https://discuss.pixls.us/t/a-greedy-algorithm-to-paint-an-image-by-randomly-exploring-a-space-of-brush-strokes/26589
# 
# $1=Itérations = int(200,1,1400)
# $2=Graine/Seed = int(0,0,65536)      # trop lent, manque de diversité : à améliorer
# $3=DiffusionTensors = float(0.01,0.01,0.1)
# $4=Flou/Blur % = float(10,0,10)
# $5=Images Sequence = bool(0)      # Windows :  C:\Users\[user]\AppData\Local\Temp\frame_000000.png || Linux :  /tmp/\\frame_000000.png
# $6= Brosse/Brush = choice(0,"Ellipse","Cercle/Circle")
# $7= Taille Brosse/Brush Size = float(1,0.1,4)
# samj_test_paint_gmic_gimp 400,0,0.05,1,0,0,1

+diffusiontensors $3,0.95,0.5,1
+gradient_norm..
+b[0] $4%
f=0
if $2>0 Iterations={$1*2} else Iterations=$1 endif
repeat $Iterations,t
	beta={1-exp(-$t/100)}

	100%,100%,1,4
	if $2>0 srand {$2+$f} endif
	
	{u(16,512)},1,1,1,"*
	const da = 15;
	const dl = 1;

	const echelle = $7;
	const beta = $beta;
	const bs = lerp(60,1,beta);
	const anisotropy = lerp(0.5,1,beta);
	const opac = lerp(0.5,1,beta);
	const alea = $2+$f;
	if($2>0, srand(alea) );
	X0 = round(u([w#0,h#0]-1));
	RGBA = [ lerp(I(#0,X0),u([255,255,255]),0),255 ];
	lmax = lerp(1,10,beta^2);

	for (a = 0, a<360, a+=da,
	X = X0;
	U = [cos(0.017453292*$a), sin(0.017453292*$a)];
	for (l = 0, l<lmax, l+=dl,
	C = I(#1,X,1);
	T = [ C[0],C[1],C[1],C[2] ];
	eig = eig(T);
	l1 = eig[0];
	l2 = eig[1];
	u = eig[2];
	v = eig[3];

	RGBA[3] = opac*lerp(10,255,min(1,i(#2,X0)/10));
	nbs = bs;
	nbs*=lerp(3,1,min(1,i(#2,X0)/20));

	if($6==0, ellipse(#-1,X[0],X[1],echelle*nbs,echelle*nbs*lerp(1,(1 - l1 + l2),anisotropy),atan2(v,u),1,RGBA), ellipse(#-1,X[0],X[1],echelle*nbs,echelle*nbs,0,1,RGBA));
	U = T*U;
	X+=dl*U;
	U/=max(1e-9,norm(U));
	);
	);" rm.

	opac={lerp(0,0.5,$beta)}

	blend[3,-1] alpha,{u(0.05,$opac)}
	w. -1,-1,0
	if $5==1 on. ${-path_tmp}\\frame.png,$f endif
	f+=1
done	
rm[0,-3,-2]

#################################################
##                                             ##
##       FIN samj_test_paint_gmic_gimp         ##
##                                             ##
#################################################

#################################################
##                                             ##
##              samj_test_cercle               ##
##                                             ##
#################################################
# version 20201228
samj_test_cercle :
skip ${1=1},${2=400},${3=250},${4=0} # type : arc-cercle-spirale a-spirale b/largeur/éloignement cercle spirales/angle départ rendu deg./
if $1==0
	# Arc
	skip ${1=300}
	if {{w}/{h}}>{2*pi}
		crop 0,0,{{{h}*2*pi}-1},{{h}-1}
	endif
	resize[-1] $2,{{h}/{w}*$2}
	Larg={w}
	Haut={h}
	RayonInt=$Haut
	RayonExt={$RayonInt+$Haut}
	AngDep=0 # rad
	CirconfInt={2*pi*$RayonInt}
	AngArrivee={$Larg/$RayonInt} # rad
elif $1==2
	# Spirale a
	to_rgba
	samj_inclinaison_h 1,{h}
elif $1==3
	# Spirale b
	to_rgba
	samj_inclinaison_h 2,{h}
endif

if $1==1||$1==2||$1==3
	# Cercle et spirales
	resize[-1] $2,{{h}/{w}*$2}
	EloigC=$3
	Larg={w}
	Haut={h}
	if $EloigC>{round({{$Larg/2}/{2*pi}})}
		RayonInt={round({{$Larg/2}/{2*pi}})+$EloigC}
	else
		RayonInt={round({{$Larg/2}/{2*pi}})}
	endif
	DiamInt={$RayonInt*2}
	AngDep=0 # rad
	CirconfInt={2*pi*$RayonInt}
	AngArrivee={$AngDep+{2*pi}} # rad
	RayonExt={$RayonInt+$Haut}
endif

AngDepDeg={pi/180*$4}
CirconfExt={2*pi*$RayonExt}
DimLigneDebut={$RayonInt*$AngArrivee}
DimLigneFin={$RayonExt*$AngArrivee}
Inc={{$DimLigneFin-$DimLigneDebut}/$Haut}

#### Étirer l'image
to_rgba
split[-1] y,$Haut
LaTrai=0
repeat $Haut
	LaTrai={$LaTrai-1}
	AbsLaTrai={abs($LaTrai)}
	resize[$LaTrai] {$CirconfInt+{{abs($LaTrai)-1}*$Inc}},{h}
	LargSplit$AbsLaTrai={$CirconfInt+{{abs($LaTrai)-1}*$Inc}}
done
append y

#### Nouvelle image rendu
DimNewImg={{$RayonExt+3}*2}
$DimNewImg,$DimNewImg,1,4
fill_color[-1] 0,0,0,0
Xc={$DimNewImg/2}
Yc={$DimNewImg/2}
LaTrai=0
IncY=0
repeat $Haut
	LaTrai={$LaTrai-1}
	AbsLaTrai={abs($LaTrai)}
	LargLigne=${LargSplit$AbsLaTrai} # AbsLaTrai max = ligne du haut la + large
	IncX=0
	IncA={$AngArrivee/$LargLigne}
	repeat $LargLigne
		Rn={$RayonInt+$IncY}
		An={$AngDepDeg+{$IncX*$IncA}}
		Xp={$Xc+{$Rn*cos($An)}}
		Yp={$Yc+{$Rn*sin($An)}}
		Xf={$Xc+{$RayonExt*cos($An)}}
		Yf={$Yc+{$RayonExt*sin($An)}}
		PosX=$IncX
		PosY={{$Haut-1}-$IncY}
		+crop[-2] $PosX,$PosY,$PosX,$PosY,0
		line[-2] $Xp,$Yp,$Xf,$Yf,1,{I(#-1)}
		rm[-1]
		IncX={$IncX+1}
	done
	IncY={$IncY+1}
done

#### Nouvelle image infos
$DimNewImg,$DimNewImg,1,4
fill_color[-1] 0,0,0,0
circle[-1] $Xc,$Yc,$RayonInt,1,0xFFFFFFFF,255,0,0,255
circle[-1] $Xc,$Yc,$RayonExt,1,0xFFFFFFFF,0,255,0,255
Xa={$Xc+{$RayonInt*cos($AngDepDeg)}}
Ya={$Yc+{$RayonInt*sin($AngDepDeg)}}
Xb={$Xc+{$RayonInt*cos($An)}}
Yb={$Yc+{$RayonInt*sin($An)}}
polygon[-1] 3,$Xc,$Yc,$Xa,$Ya,$Xb,$Yb,1,255,255,0,255
text[-1] $1-$2-$3-$4-$AngDepDeg,20,20,30,1,255,0,0,255
text[-1] {$An/pi*180}-$An,20,40,30,1,255,0,0,255
text[-1] $Haut-$RayonInt-$RayonExt,20,60,30,1,255,0,0,255
rv[-1,-2,-3]

#################################################
##                                             ##
##            FIN samj_test_cercle             ##
##                                             ##
#################################################
#################################################
##                                             ##
##             samj_montage_row                ##
##                                             ##
#################################################

# 20201212 ajout gestion erreur avec $7
# 20201209 fond blanc
# 20201202 simplification à 2 "Type_Proportions_Finales" , ajout Pivoter_En_Colonne et modification expand + simplification
# 20201201 ajout de variables crées dynamiquement ( NewW$AbsInd et NewH$AbsInd ) pour éviter un resize inutile dans $Type_Proportions_Finales==3
# 20201130 origine

##### exemples
## gmic repeat 10 sample done samj_montage_row 0,3800,4,10,0,0 o 1montage.jpg
## gmic repeat 10 sample done samj_montage_row 0,3800,4,10,1,1 o 2montage.jpg
## gmic repeat 10 sample done samj_montage_row 1,3800,4,10,0,0 o 3montage.jpg
## gmic repeat 10 sample done samj_montage_row 1,3800,4,10,1,1 o 4montage.jpg

#### variables
## $1 = Type_Proportions_Finales -> 0=Conserver proportions grandeurs en pixels images à assembler | 1=Images sur toute la hauteur.
## $2 = LargeurRow -> Largeur de l'image
## $3 = Contour Largeur -> de 0 (sans) à ...
## $4 = Padding Largeur -> de 0 (sans) à ...
## $5 = Rotation 90° images à assembler -> 1=oui
## $6 = Rotation 90° de l'ensemble pour créer une colonne -> 1=oui
## $7 = Dimension minimale pour une image (option)

samj_montage_row :
skip ${7=2}
Type_Proportions_Finales=$1
LargeurRow=$2
Contour=$3
Padding=$4
Rotation=$5
Pivoter_En_Colonne=$6

# Vérification paramètres
NbImg=$!
DimensionMini=$7
if {{$NbImg*{{2*{$3+$4}}+$DimensionMini}}>$2}
	echo "ERREUR-ERROR - Diminuer $3,$4 et/ou augmenter $2 / Decrease $3,$4 et/ou increase $2"
	rm
else
	# Fond blanc systématiquement. À voir {i3}<1
	Index=0
	repeat $NbImg
		Index={$Index-1}
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		$Wtemp,$Htemp,1,4
		fill_color[-1] 255,255,255,255
		rv[-1,{$Index-1}]
		blend[-1,{$Index-1}] alpha
	done
	to_rgb
	if $Rotation==1 permute yxzc mirror x endif
	NbImg=$!

	if $Type_Proportions_Finales==0
		Index=0
		Hmax=0
		Wmax=0
		Htot=0
		Wtot=0
		# trouver la somme Wtot et Htot
		repeat $NbImg
			Index={$Index-1}
			Htemp={h(#$Index)}
			Htot={$Htot+$Htemp}
			if $Htemp>$Hmax
				Hmax=$Htemp
			endif
			Wtemp={w(#$Index)}
			Wtot={$Wtot+$Wtemp}
			if $Wtemp>$Wmax
				Wmax=$Wtemp
			endif
		done

		ContourTot={$NbImg*$Contour*2}
		PaddingTot={$NbImg*$Padding*2}
		LargeurImages={$LargeurRow-$ContourTot-$PaddingTot}
		Echelle={$LargeurImages/$Wtot}
		Index=0
		# resize aux dimensions finales des images
		repeat $NbImg
			Index={$Index-1}
			Htemp={h(#$Index)}
			Wtemp={w(#$Index)}
			resize[$Index] {$Wtemp*$Echelle},{$Htemp*$Echelle}
			if $Contour>0 frame_xy[$Index] $Contour,$Contour,0 endif
			if $Padding>0 frame_xy[$Index] $Padding,$Padding,255 endif
		done

	else
		Index=0
		Hmax=0
		Wmax=0
		# trouver les valeurs max W et H
		repeat $NbImg
			Index={$Index-1}
			Htemp={h(#$Index)}
			if $Htemp>$Hmax
				Hmax=$Htemp
			endif
			Wtemp={w(#$Index)}
			if $Wtemp>$Wmax
				Wmax=$Wtemp
			endif
		done

		Index=0
		Htot=0
		Wtot=0
		# nouvelles dimensions NewW et NewH pour obtenir de grandes images pour éviter un resize
		repeat $NbImg
			Index={$Index-1}
			AbsInd={abs($Index)}
			Htemp={h(#$Index)}
			Wtemp={w(#$Index)}
			NewW$AbsInd={$Wtemp/$Htemp*$Hmax}
			NewH$AbsInd=$Hmax
		done

		Index=0
		Hmax=0
		Wmax=0
		Htot=0
		Wtot=0
		# trouver la somme Wtot et Htot
		repeat $NbImg
			Index={$Index-1}
			AbsInd={abs($Index)}
			Htemp=${NewH$AbsInd}
			Htot={$Htot+$Htemp}
			if $Htemp>$Hmax
				Hmax=$Htemp
			endif
			Wtemp=${NewW$AbsInd}
			Wtot={$Wtot+$Wtemp}
			if $Wtemp>$Wmax
				Wmax=$Wtemp
			endif
		done

		ContourTot={$NbImg*$Contour*2}
		PaddingTot={$NbImg*$Padding*2}
		LargeurImages={$LargeurRow-$ContourTot-$PaddingTot}
		Echelle={$LargeurImages/$Wtot}
		Index=0
		# resize aux dimensions finales des images
		repeat $NbImg
			Index={$Index-1}
			AbsInd={abs($Index)}
			Htemp=${NewH$AbsInd}
			Wtemp=${NewW$AbsInd}
			resize[$Index] {$Wtemp*$Echelle},{$Htemp*$Echelle}
			if $Contour>0 frame_xy[$Index] $Contour,$Contour,0 endif
			if $Padding>0 frame_xy[$Index] $Padding,$Padding,255 endif
		done

	endif

	Index=0
	Hmaxmontage=0
	# Wmaxmontage=0
	repeat $NbImg
		Index={$Index-1}
		Htemp={h(#$Index)}
		if $Htemp>$Hmaxmontage
			Hmaxmontage=$Htemp
		endif
		Wtemp={w(#$Index)}
		# Wmaxmontage={$Wmaxmontage+$Wtemp}
	done

	Index=0
	repeat $NbImg
		Index={$Index-1}
		Htemp={h(#$Index)}
		Wtemp={w(#$Index)}
		expand_y[$Index] {{$Hmaxmontage-$Htemp}/2},0
		rectangle[$Index] 0,0,$Wtemp,{{$Hmaxmontage-$Htemp}/2},1,255,255,255
		mirror[$Index] y
		rectangle[$Index] 0,0,$Wtemp,{{$Hmaxmontage-$Htemp}/2},1,255,255,255
		mirror[$Index] y
	done

	append x

	Erreur={{w}-$LargeurRow}
	if $Erreur>0
		crop 0,0,{$LargeurRow-1},{{h}-1}
	elif $Erreur<0
		expand_x {-$Erreur-1},0
		rectangle 0,0,{-$Erreur-1},{h},1,255,255,255
		mirror x
		rectangle 0,0,{-$Erreur-1},{h},1,255,255,255
		mirror x
		crop 0,0,{$LargeurRow-1},{{h}-1}
	endif

	to_rgb

	if $Pivoter_En_Colonne==1 mirror x permute yx endif
endif

#################################################
##                                             ##
##            FIN samj_montage_row             ##
##                                             ##
#################################################
#################################################
##                                             ##
##        samj_paulmatth_montage_row           ##
##                                             ##
#################################################

# https://discuss.pixls.us/t/gmic-montage-padding/21480/9

##### examples
## gmic repeat 10 sample done samj_paulmatth_montage_row 10,10,0,20,20,255,1,1800,0 o row1.jpg
## gmic repeat 10 sample done samj_paulmatth_montage_row 10,10,0,20,20,255,1,1800,90 o row2.jpg
## gmic repeat 5 sample done samj_paulmatth_montage_row 10,10,0,20,20,255,1,600,0 o row3.jpg

#### variables
# $1 = X contour
# $2 = Y contour
# $3 = color contour 0...255
# $4 = X padding
# $5 = Y padding
# $6 = color padding 0...255
# $7 = resize Y (1) or N (0)
# $8 = width pixels
# $9 = orientation

samj_paulmatth_montage_row:
frame $1,$2,$3
if $9>0 rotate $9,2 endif
frame $4,$5,$6
montage H
to_rgb
if $7==1 resize $8,{{h}/{w}*$8},1,3 endif
#################################################
##                                             ##
##       FIN samj_paulmatth_montage_row        ##
##                                             ##
#################################################
#################################################
##                                             ##
##       Fonction samj_RGB_to_LCH_or_Lab       ##
##                                             ##
#################################################
# version 20161224
# renvoie une chaîne de caractères ou une valeur L,C,H selon le type de demande , la valeur RGB entrée , Matrices_RGB , XYZ_Tristimulus , Choix (0=LCH 1=Lab)
# exemple :
# R_val=100 G_val=150 B_val=200 Matrices_RGB=14 XYZ_Tristimulus=4 Choix=0 text_outline ${"samj_RGB_to_LCH_or_Lab[] 0,"{/$R_val}","{/$G_val}","{/$B_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""},2,2,23,2,1,255
# Conversions  http://www.brucelindbloom.com/  http://www.easyrgb.com/  http://www.newtone.fr/
samj_RGB_to_LCH_or_Lab:
 Type_de_demande=$1 # 0=chaîne de caractères , 1=L , 2=C , 3=H
 Ra=$2
 Ga=$3
 Ba=$4
 Matrices_RGB=$5  # defaut = 14
 XYZ_Tristimulus=$6  # defaut = 4
 Choix=$7 # 0=LCH   ,  1=Lab
 # http://www.easyrgb.com/index.php?X=MATH
 # Conversions RGB > XYZ

 nt_Ra={$Ra/255}
 nt_Ga={$Ga/255}
 nt_Ba={$Ba/255}

 if $nt_Ra>0.04045
  nt_Ra={({{$nt_Ra+0.055}/1.055})^2.4}
 else
  nt_Ra={$nt_Ra/12.92}
 endif
 if $nt_Ga>0.04045
  nt_Ga={({{$nt_Ga+0.055}/1.055})^2.4}
 else
  nt_Ga={$nt_Ga/12.92}
 endif
 if $nt_Ba>0.04045
  nt_Ba={({{$nt_Ba+0.055}/1.055})^2.4}
 else
  nt_Ba={$nt_Ba/12.92}
 endif
 nt_Ra={$nt_Ra*100}
 nt_Ga={$nt_Ga*100}
 nt_Ba={$nt_Ba*100}

 # http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 Xa={$nt_Ra*1.0000000+$nt_Ga*0.0000000+$nt_Ba*0.0000000}
 Ya={$nt_Ra*0.0000000+$nt_Ga*1.0000000+$nt_Ba*0.0000000}
 Za={$nt_Ra*0.0000000+$nt_Ga*0.0000000+$nt_Ba*1.0000000}

 if $Matrices_RGB==0
  #Adobe RGB (1998) D65
  Xa={$nt_Ra*0.5767309+$nt_Ga*0.1855540+$nt_Ba*0.1881852}
  Ya={$nt_Ra*0.2973769+$nt_Ga*0.6273491+$nt_Ba*0.0752741}
  Za={$nt_Ra*0.0270343+$nt_Ga*0.0706872+$nt_Ba*0.9911085}
 elif $Matrices_RGB==1
  #AppleRGB D65
  Xa={$nt_Ra*0.4497288+$nt_Ga*0.3162486+$nt_Ba*0.1844926}
  Ya={$nt_Ra*0.2446525+$nt_Ga*0.6720283+$nt_Ba*0.0833192}
  Za={$nt_Ra*0.0251848+$nt_Ga*0.1411824+$nt_Ba*0.9224628}
 elif $Matrices_RGB==2
  #Best RGB D50
  Xa={$nt_Ra*0.6326696+$nt_Ga*0.2045558+$nt_Ba*0.1269946}
  Ya={$nt_Ra*0.2284569+$nt_Ga*0.7373523+$nt_Ba*0.0341908}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0095142+$nt_Ba*0.8156958}
 elif $Matrices_RGB==3
  #Beta RGB D50
  Xa={$nt_Ra*0.6712537+$nt_Ga*0.1745834+$nt_Ba*0.1183829}
  Ya={$nt_Ra*0.3032726+$nt_Ga*0.6637861+$nt_Ba*0.0329413}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0407010+$nt_Ba*0.7845090}
 elif $Matrices_RGB==4
  #Bruce RGB D65
  Xa={$nt_Ra*0.4674162+$nt_Ga*0.2944512+$nt_Ba*0.1886026}
  Ya={$nt_Ra*0.2410115+$nt_Ga*0.6835475+$nt_Ba*0.0754410}
  Za={$nt_Ra*0.0219101+$nt_Ga*0.0736128+$nt_Ba*0.9933071}
 elif $Matrices_RGB==5
  #CIE RGB E
  Xa={$nt_Ra*0.4887180+$nt_Ga*0.3106803+$nt_Ba*0.2006017}
  Ya={$nt_Ra*0.1762044+$nt_Ga*0.8129847+$nt_Ba*0.0108109}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0102048+$nt_Ba*0.9897952}
 elif $Matrices_RGB==6
  #ColorMatch RGB D50
  Xa={$nt_Ra*0.5093439+$nt_Ga*0.3209071+$nt_Ba*0.1339691}
  Ya={$nt_Ra*0.2748840+$nt_Ga*0.6581315+$nt_Ba*0.0669845}
  Za={$nt_Ra*0.0242545+$nt_Ga*0.1087821+$nt_Ba*0.6921735}
 elif $Matrices_RGB==7
  #Don RGB 4 D50
  Xa={$nt_Ra*0.6457711+$nt_Ga*0.1933511+$nt_Ba*0.1250978}
  Ya={$nt_Ra*0.2783496+$nt_Ga*0.6879702+$nt_Ba*0.0336802}
  Za={$nt_Ra*0.0037113+$nt_Ga*0.0179861+$nt_Ba*0.8035125}
 elif $Matrices_RGB==8
  #ECI RGB D50
  Xa={$nt_Ra*0.6502043+$nt_Ga*0.1780774+$nt_Ba*0.1359384}
  Ya={$nt_Ra*0.3202499+$nt_Ga*0.6020711+$nt_Ba*0.0776791}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0678390+$nt_Ba*0.7573710}
 elif $Matrices_RGB==9
  #Ekta Space PS5 D50
  Xa={$nt_Ra*0.5938914+$nt_Ga*0.2729801+$nt_Ba*0.0973485}
  Ya={$nt_Ra*0.2606286+$nt_Ga*0.7349465+$nt_Ba*0.0044249}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0419969+$nt_Ba*0.7832131}
 elif $Matrices_RGB==10
  #NTSC RGB C
  Xa={$nt_Ra*0.6068909+$nt_Ga*0.1735011+$nt_Ba*0.2003480}
  Ya={$nt_Ra*0.2989164+$nt_Ga*0.5865990+$nt_Ba*0.1144845}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0660957+$nt_Ba*1.1162243}
 elif $Matrices_RGB==11
  #PAL/SECAM RGB D65
  Xa={$nt_Ra*0.4306190+$nt_Ga*0.3415419+$nt_Ba*0.1783091}
  Ya={$nt_Ra*0.2220379+$nt_Ga*0.7066384+$nt_Ba*0.0713236}
  Za={$nt_Ra*0.0201853+$nt_Ga*0.1295504+$nt_Ba*0.9390944}
 elif $Matrices_RGB==12
  #ProPhoto RGB D50
  Xa={$nt_Ra*0.7976749+$nt_Ga*0.1351917+$nt_Ba*0.0313534}
  Ya={$nt_Ra*0.2880402+$nt_Ga*0.7118741+$nt_Ba*0.0000857}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0000000+$nt_Ba*0.8252100}
 elif $Matrices_RGB==13
  #SMPTE-C RGB D65
  Xa={$nt_Ra*0.3935891+$nt_Ga*0.3652497+$nt_Ba*0.1916313}
  Ya={$nt_Ra*0.2124132+$nt_Ga*0.7010437+$nt_Ba*0.0865432}
  Za={$nt_Ra*0.0187423+$nt_Ga*0.1119313+$nt_Ba*0.9581563}
 elif $Matrices_RGB==14
  #Observateur. = 2°, Illuminant = D65 sRGB   REF
  Xa={$nt_Ra*0.4124564+$nt_Ga*0.3575761+$nt_Ba*0.1804375}
  Ya={$nt_Ra*0.2126729+$nt_Ga*0.7151522+$nt_Ba*0.0721750}
  Za={$nt_Ra*0.0193339+$nt_Ga*0.1191920+$nt_Ba*0.9503041}
 elif $Matrices_RGB==15
  #Wide Gamut RGB D50
  Xa={$nt_Ra*0.7161046+$nt_Ga*0.1009296+$nt_Ba*0.1471858}
  Ya={$nt_Ra*0.2581874+$nt_Ga*0.7249378+$nt_Ba*0.0168748}
  Za={$nt_Ra*0.0000000+$nt_Ga*0.0517813+$nt_Ba*0.7734287}
 endif

  # Conversions XYZ > Lab

 Xca=$Xa
 Yca=$Ya
 Zca=$Za

 # http://www.easyrgb.com/index.php?X=MATH&H=15#text15
 ref_Xa=100.000
 ref_Ya=100.000
 ref_Za=100.000
 if $XYZ_Tristimulus==0 # de 0 à 8   2° (CIE 1931)
  #A (Incandescent)
  ref_Xa=109.850
  ref_Ya=100.000
  ref_Za=35.585
 elif $XYZ_Tristimulus==1
  #C
  ref_Xa=98.074
  ref_Ya=100.000
  ref_Za=118.232
 elif $XYZ_Tristimulus==2
  #D50
  ref_Xa=96.422
  ref_Ya=100.000
  ref_Za=82.521
 elif $XYZ_Tristimulus==3
  #D55
  ref_Xa=95.682
  ref_Ya=100.000
  ref_Za=92.149
 elif $XYZ_Tristimulus==4
  #D65 (Daylight) REF
  ref_Xa=95.047
  ref_Ya=100.000
  ref_Za=108.883
 elif $XYZ_Tristimulus==5
  #D75
  ref_Xa=94.972
  ref_Ya=100.000
  ref_Za=122.638
 elif $XYZ_Tristimulus==6
  # F2 (Fluorescent)
  ref_Xa=99.187
  ref_Ya=100.000
  ref_Za=67.395
 elif $XYZ_Tristimulus==7
  # F7
  ref_Xa=95.044
  ref_Ya=100.000
  ref_Za=108.755
 elif $XYZ_Tristimulus==8
  # F11
  ref_Xa=100.966
  ref_Ya=100.000
  ref_Za=64.370
 elif $XYZ_Tristimulus==10 # de 10 à 18   10° (CIE 1964)
  #A (Incandescent)
  ref_Xa=111.144
  ref_Ya=100.000
  ref_Za=35.200
 elif $XYZ_Tristimulus==11
  #C
  ref_Xa=97.285
  ref_Ya=100.000
  ref_Za=116.145
 elif $XYZ_Tristimulus==12
  #D50
  ref_Xa=96.720
  ref_Ya=100.000
  ref_Za=81.427
 elif $XYZ_Tristimulus==13
  #D55
  ref_Xa=95.799
  ref_Ya=100.000
  ref_Za=90.926
 elif $XYZ_Tristimulus==14
  #D65 (Daylight)
  ref_Xa=94.811
  ref_Ya=100.000
  ref_Za=107.304
 elif $XYZ_Tristimulus==15
  #D75
  ref_Xa=94.416
  ref_Ya=100.000
  ref_Za=120.641
 elif $XYZ_Tristimulus==16
  # F2 (Fluorescent)
  ref_Xa=103.280
  ref_Ya=100.000
  ref_Za=69.026
 elif $XYZ_Tristimulus==17
  # F7
  ref_Xa=95.792
  ref_Ya=100.000
  ref_Za=107.687
 elif $XYZ_Tristimulus==18
  # F11
  ref_Xa=103.866
  ref_Ya=100.000
  ref_Za=65.627
 endif

 nt_Xa={$Xca/$ref_Xa}
 nt_Ya={$Yca/$ref_Ya}
 nt_Za={$Zca/$ref_Za}
 if $nt_Xa>0.008856
  nt_Xa={($nt_Xa)^{1/3}}
 else
  nt_Xa={{7.787*$nt_Xa}+{16/116}}
 endif
 if $nt_Ya>0.008856
  nt_Ya={($nt_Ya)^{1/3}}
 else
  nt_Ya={{7.787*$nt_Ya}+{16/116}}
 endif
 if $nt_Za>0.008856
  nt_Za={($nt_Za)^{1/3}}
 else
  nt_Za={{7.787*$nt_Za}+{16/116}}
 endif
 CIE_La={{116*$nt_Ya}-16}
 CIE_aa={500*{$nt_Xa-$nt_Ya}}
 CIE_ba={200*{$nt_Ya-$nt_Za}}
 if $Choix==1 # 1=Lab
  if $Type_de_demande==0 u {$CIE_La}","{$CIE_aa}","{$CIE_ba}
  elif $Type_de_demande==1 u {$CIE_La}
  elif $Type_de_demande==2 u {$CIE_aa}
  elif $Type_de_demande==3 u {$CIE_ba}
  endif
 elif $Choix==0 # 0=LCH
  # Conversions Lab > LCH

  var_H={atan2($CIE_ba,$CIE_aa)}  #Quadrant by signs
  if $var_H>0
   var_H={{$var_H/pi}*180}
  else
   var_H={360-{{abs($var_H)/pi}*180}}
  endif
  CIE_L=$CIE_La
  CIE_C={({{$CIE_aa*$CIE_aa}+{$CIE_ba*$CIE_ba}})^0.5}
  CIE_H=$var_H

  if $Type_de_demande==0 u {$CIE_L}","{$CIE_C}","{$CIE_H}
  elif $Type_de_demande==1 u {$CIE_L}
  elif $Type_de_demande==2 u {$CIE_C}
  elif $Type_de_demande==3 u {$CIE_H}
  endif
 endif

#################################################
##                                             ##
##     FIN Fonction samj_RGB_to_LCH_or_Lab     ##
##                                             ##
#################################################
#################################################
##                                             ##
##       Fonction samj_LCH_or_Lab_to_RGB       ##
##                                             ##
#################################################
# version 20161224 + maj 2020/10/24
# renvoie une chaîne de caractères ou une valeur R,G,B selon le type de demande , la valeur LCH ou Lab entrée , Matrices_RGB , XYZ_Tristimulus , Choix (0=LCH 1=Lab)
# exemple
# L_val=60.507 C_val=31.056 H_val=264,851 Matrices_RGB=14 XYZ_Tristimulus=4 Choix=0 text_outline ${"samj_LCH_or_Lab_to_RGB[] 0,"{/$L_val}","{/$C_val}","{/$H_val}","{/$Matrices_RGB}","{/$XYZ_Tristimulus}","{/$Choix}""},2,2,23,2,1,255
# Conversions  http://www.brucelindbloom.com/  http://www.easyrgb.com/  http://www.newtone.fr/
samj_LCH_or_Lab_to_RGB:
 Type_de_demande=$1 # 0=chaîne de caractères , 1=R , 2=G , 3=B
 Matrices_RGB=$5  # defaut = 14
 XYZ_Tristimulus=$6  # defaut = 4
 Choix=$7 # 0=LCH   ,  1=Lab

 if $Choix==1 # 1=Lab
  CIE_Lca=$2
  CIE_aca=$3
  CIE_bca=$4
 elif $Choix==0 # 0=LCH
  # http://www.easyrgb.com/index.php?X=MATH
  # Conversions LCH > Lab
  # CIE-H° from 0 to 360°
  CIE_Lca=$2
  CIE_aca={{cos({pi/180*$4})}*$3}
  CIE_bca={{sin({pi/180*$4})}*$3}
 endif

 # Conversions Lab > XYZ

 nt_Yca={{$CIE_Lca+16}/116}
 nt_Xca={$CIE_aca/500+$nt_Yca}
 nt_Zca={$nt_Yca-$CIE_bca/200}
 if {($nt_Yca)^3}>0.008856
  nt_Yca={($nt_Yca)^3}
 else
  nt_Yca={{$nt_Yca-16/116}/7.787}
 endif
 if {($nt_Xca)^3}>0.008856
  nt_Xca={($nt_Xca)^3}
 else
  nt_Xca={{$nt_Xca-16/116}/7.787}
 endif
 if {($nt_Zca)^3}>0.008856
  nt_Zca={($nt_Zca)^3}
 else
  nt_Zca={{$nt_Zca-16/116}/7.787}
 endif

 # http://www.easyrgb.com/index.php?X=MATH&H=15#text15
 ref_Xca=100.000
 ref_Yca=100.000
 ref_Zca=100.000
 if $XYZ_Tristimulus==0 # de 0 à 8   2° (CIE 1931)
  #A (Incandescent)
  ref_Xca=109.850
  ref_Yca=100.000
  ref_Zca=35.585
 elif $XYZ_Tristimulus==1
  #C
  ref_Xca=98.074
  ref_Yca=100.000
  ref_Zca=118.232
 elif $XYZ_Tristimulus==2
  #D50
  ref_Xca=96.422
  ref_Yca=100.000
  ref_Zca=82.521
 elif $XYZ_Tristimulus==3
  #D55
  ref_Xca=95.682
  ref_Yca=100.000
  ref_Zca=92.149
 elif $XYZ_Tristimulus==4
  #D65 (Daylight) REF
  ref_Xca=95.047
  ref_Yca=100.000
  ref_Zca=108.883
 elif $XYZ_Tristimulus==5
  #D75
  ref_Xca=94.972
  ref_Yca=100.000
  ref_Zca=122.638
 elif $XYZ_Tristimulus==6
  # F2 (Fluorescent)
  ref_Xca=99.187
  ref_Yca=100.000
  ref_Zca=67.395
 elif $XYZ_Tristimulus==7
  # F7
  ref_Xca=95.044
  ref_Yca=100.000
  ref_Zca=108.755
 elif $XYZ_Tristimulus==8
  # F11
  ref_Xca=100.966
  ref_Yca=100.000
  ref_Zca=64.370
 elif $XYZ_Tristimulus==10 # de 10 à 18   10° (CIE 1964)
  #A (Incandescent)
  ref_Xca=111.144
  ref_Yca=100.000
  ref_Zca=35.200
 elif $XYZ_Tristimulus==11
  #C
  ref_Xca=97.285
  ref_Yca=100.000
  ref_Zca=116.145
 elif $XYZ_Tristimulus==12
  #D50
  ref_Xca=96.720
  ref_Yca=100.000
  ref_Zca=81.427
 elif $XYZ_Tristimulus==13
  #D55
  ref_Xca=95.799
  ref_Yca=100.000
  ref_Zca=90.926
 elif $XYZ_Tristimulus==14
  #D65 (Daylight)
  ref_Xca=94.811
  ref_Yca=100.000
  ref_Zca=107.304
 elif $XYZ_Tristimulus==15
  #D75
  ref_Xca=94.416
  ref_Yca=100.000
  ref_Zca=120.641
 elif $XYZ_Tristimulus==16
  # F2 (Fluorescent)
  ref_Xca=103.280
  ref_Yca=100.000
  ref_Zca=69.026
 elif $XYZ_Tristimulus==17
  # F7
  ref_Xca=95.792
  ref_Yca=100.000
  ref_Zca=107.687
 elif $XYZ_Tristimulus==18
  # F11
  ref_Xca=103.866
  ref_Yca=100.000
  ref_Zca=65.627
 endif

 Xca={$ref_Xca*$nt_Xca}
 Yca={$ref_Yca*$nt_Yca}
 Zca={$ref_Zca*$nt_Zca}

 # Conversions XYZ > Lab

 vcXa=$Xca
 vcYa=$Yca
 vcZa=$Zca
 nt_X={$vcXa/100} # X compris entre 0 et  95.047      ( Observateur = 2°, Illuminant = D65 )
 nt_Y={$vcYa/100} # Y compris entre 0 et 100.000
 nt_Z={$vcZa/100} # Z compris entre 0 et 108.883

 # http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
 nt_R={$nt_X*1.0000000+$nt_Y*0.0000000+$nt_Z*0.0000000}
 nt_G={$nt_X*0.0000000+$nt_Y*1.0000000+$nt_Z*0.0000000}
 nt_B={$nt_X*0.0000000+$nt_Y*0.0000000+$nt_Z*1.0000000}
 if $Matrices_RGB==0
  #Adobe RGB (1998) D65
  nt_R={$nt_X*2.0413690+$nt_Y*-0.5649464+$nt_Z*-0.3446944}
  nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
  nt_B={$nt_X*0.0134474+$nt_Y*-0.1183897+$nt_Z*1.0154096}
 elif $Matrices_RGB==1
  #AppleRGB D65
  nt_R={$nt_X*2.9515373+$nt_Y*-1.2894116+$nt_Z*-0.4738445}
  nt_G={$nt_X*-1.0851093+$nt_Y*1.9908566+$nt_Z*0.0372026}
  nt_B={$nt_X*0.0854934+$nt_Y*-0.2694964+$nt_Z*1.0912975}
 elif $Matrices_RGB==2
  #Best RGB D50
  nt_R={$nt_X*1.7552599+$nt_Y*-0.4836786+$nt_Z*-0.2530000}
  nt_G={$nt_X*-0.5441336+$nt_Y*1.5068789+$nt_Z*0.0215528}
  nt_B={$nt_X*0.0063467+$nt_Y*-0.0175761+$nt_Z*1.2256959}
 elif $Matrices_RGB==3
  #Beta RGB D50
  nt_R={$nt_X*1.6832270+$nt_Y*-0.4282363+$nt_Z*-0.2360185}
  nt_G={$nt_X*-0.7710229+$nt_Y*1.7065571+$nt_Z*0.0446900}
  nt_B={$nt_X*0.0400013+$nt_Y*-0.0885376+$nt_Z*1.2723640}
 elif $Matrices_RGB==4
  #Bruce RGB D65
  nt_R={$nt_X*2.7454669+$nt_Y*-1.1358136+$nt_Z*-0.4350269}
  nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
  nt_B={$nt_X*0.0112723+$nt_Y*-0.1139754+$nt_Z*1.0132541}
 elif $Matrices_RGB==5
  #CIE RGB E
  nt_R={$nt_X*2.3706743+$nt_Y*-0.9000405+$nt_Z*-0.4706338}
  nt_G={$nt_X*-0.5138850+$nt_Y*1.4253036+$nt_Z*0.0885814}
  nt_B={$nt_X*0.0052982+$nt_Y*-0.0146949+$nt_Z*1.0093968}
 elif $Matrices_RGB==6
  #ColorMatch RGB D50
  nt_R={$nt_X*2.6422874+$nt_Y*-1.2234270+$nt_Z*-0.3930143}
  nt_G={$nt_X*-1.1119763+$nt_Y*2.0590183+$nt_Z*0.0159614}
  nt_B={$nt_X*0.0821699+$nt_Y*-0.2807254+$nt_Z*1.4559877}
 elif $Matrices_RGB==7
  #Don RGB 4 D50
  nt_R={$nt_X*1.7603902+$nt_Y*-0.4881198+$nt_Z*-0.2536126}
  nt_G={$nt_X*-0.7126288+$nt_Y*1.6527432+$nt_Z*0.0416715}
  nt_B={$nt_X*0.0078207+$nt_Y*-0.0347411+$nt_Z*1.2447743}
 elif $Matrices_RGB==8
  #ECI RGB D50
  nt_R={$nt_X*1.7827618+$nt_Y*-0.4969847+$nt_Z*-0.2690101}
  nt_G={$nt_X*-0.9593623+$nt_Y*1.9477962+$nt_Z*-0.0275807}
  nt_B={$nt_X*0.0859317+$nt_Y*-0.1744674+$nt_Z*1.3228273}
 elif $Matrices_RGB==9
  #Ekta Space PS5
  nt_R={$nt_X*2.0043819+$nt_Y*-0.7304844+$nt_Z*-0.2450052}
  nt_G={$nt_X*-0.7110285+$nt_Y*1.6202126+$nt_Z*0.0792227}
  nt_B={$nt_X*0.0381263+$nt_Y*-0.0868780+$nt_Z*1.2725438}
 elif $Matrices_RGB==10
  #NTSC RGB C
  nt_R={$nt_X*1.9099961+$nt_Y*-0.5324542+$nt_Z*-0.2882091}
  nt_G={$nt_X*-0.9846663+$nt_Y*1.9991710+$nt_Z*-0.0283082}
  nt_B={$nt_X*0.0583056+$nt_Y*-0.1183781+$nt_Z*0.8975535}
 elif $Matrices_RGB==11
  #PAL/SECAM RGB D65
  nt_R={$nt_X*3.0628971+$nt_Y*-1.3931791+$nt_Z*-0.4757517}
  nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
  nt_B={$nt_X*0.0678775+$nt_Y*-0.2288548+$nt_Z*1.0693490}
 elif $Matrices_RGB==12
  #ProPhoto RGB D50
  nt_R={$nt_X*1.3459433+$nt_Y*-0.2556075+$nt_Z*-0.0511118}
  nt_G={$nt_X*-0.5445989+$nt_Y*1.5081673+$nt_Z*0.0205351}
  nt_B={$nt_X*0.0000000+$nt_Y*0.0000000+$nt_Z*1.2118128}
 elif $Matrices_RGB==13
  #SMPTE-C RGB D65
  nt_R={$nt_X*3.5053960+$nt_Y*-1.7394894+$nt_Z*-0.5439640}
  nt_G={$nt_X*-1.0690722+$nt_Y*1.9778245+$nt_Z*0.0351722}
  nt_B={$nt_X*0.0563200+$nt_Y*-0.1970226+$nt_Z*1.0502026}
 elif $Matrices_RGB==14
  # sRGB D65  REF
  nt_R={$nt_X*3.2404542+$nt_Y*-1.5371385+$nt_Z*-0.4985314}
  nt_G={$nt_X*-0.9692660+$nt_Y*1.8760108+$nt_Z*0.0415560}
  nt_B={$nt_X*0.0556434+$nt_Y*-0.2040259+$nt_Z*1.0572252}
 elif $Matrices_RGB==15
  #Wide Gamut RGB D50
  nt_R={$nt_X*1.4628067+$nt_Y*-0.1840623+$nt_Z*-0.2743606}
  nt_G={$nt_X*-0.5217933+$nt_Y*1.4472381+$nt_Z*0.0677227}
  nt_B={$nt_X*0.0349342+$nt_Y*-0.0968930+$nt_Z*1.2884099}
 endif

 if $nt_R>0.0031308
  nt_R={1.055*{($nt_R)^{1/2.4}}-0.055}
 else
  nt_R={12.92*$nt_R}
 endif
 if $nt_G>0.0031308
  nt_G={1.055*{($nt_G)^{1/2.4}}-0.055}
 else
  nt_G={12.92*$nt_G}
 endif
 if $nt_B>0.0031308
  nt_B={1.055*{($nt_B)^{1/2.4}}-0.055}
 else
  nt_B={12.92*$nt_B}
 endif

 Rconv={$nt_R*255}
 Gconv={$nt_G*255}
 Bconv={$nt_B*255}
 if $Type_de_demande==0 u {$Rconv}","{$Gconv}","{$Bconv}
 elif $Type_de_demande==1 u {$Rconv}
 elif $Type_de_demande==2 u {$Gconv}
 elif $Type_de_demande==3 u {$Bconv}
 endif

#################################################
##                                             ##
##     FIN Fonction samj_LCH_or_Lab_to_RGB     ##
##                                             ##
#################################################
#################################################
##                                             ##
##          ancien_Tom_Keil_Colortemp          ##
##                                             ##
#################################################

ancien_Tom_Keil_Colortemp :

 repeat $! l[$>] if $2==1 +luminance[-1] to_rgb[-2]
 s[-2] c  avb={-2,127.5-ia} avg={-3,127.5-ia} avr={-4,127.5-ia}
 +[-4] $avr +[-3] $avg +[-2] $avb a[-4,-3,-2] c rv compose_luminance endif
 fx_mix_lab 1,0,0,1,{if({$1>=0},{$1/4},{$1*0.75})},0,1,$1,0,0,2,0 endl done

#################################################
##                                             ##
##        FIN ancien_Tom_Keil_Colortemp        ##
##                                             ##
#################################################
#################################################
##                                             ##
##            ancien_gimp_morpho               ##
##                                             ##
#################################################
ancien_gimp_morpho :
  apply_channels "__ancien_gimp_morpho ${^0}",$5,$6

__ancien_gimp_morpho :
  if $4==1 suf="_oct" elif $4==0 suf="" else suf="_circ" endif
  if $1==0 erode$suf $2
  elif $1==1 dilate$suf $2
  elif $1==2 erode$suf $2 dilate$suf $2
  elif $1==3 dilate$suf $2 erode$suf $2
  elif $1==4 repeat $! +erode$suf $2 --[-2,-1] mv[-1] 0 done
  elif $1==5 repeat $! +dilate$suf $2 rv[-2,-1] --[-2,-1] mv[-1] 0 done
  elif $1==6 repeat $! +erode$suf $2 dilate$suf[-1] $2 --[-2,-1] mv[-1] 0 done
  else repeat $! +dilate$suf $2 erode$suf[-1] $2 rv[-2,-1] --[-2,-1] mv[-1] 0 done
  endif
  if $3 repeat $! l[$>] split_opacity negative[0] a c endl done endif
#################################################
##                                             ##
##          FIN ancien_gimp_morpho             ##
##                                             ##
#################################################
################################################################
##                                                            ##
##                  Ancienne fonction "at"                    ##
##                                                            ##
################################################################

# at_ancien x,y,z Return a specified vector-valued point (x,y,z) from the latest of the selected images.
at_ancien : skip ${1=0},${2=0},${3=0}
  +z. ${1-3},${1-3} u {^} rm.

################################################################
##                                                            ##
##                FIN Ancienne fonction "at"                  ##
##                                                            ##
################################################################
################################################################
##                                                            ##
##                Fonction gimp_blend_1651                    ##
##                                                            ##
################################################################

# ancienne fonction gimp_blend pour ne pas avoir à refaire les scripts > gmic 1651

gimp_blend_1651 :
  mode=${arg\ 1+$1,add,alpha,and,average,blue,burn,darken,difference,\
       divide,dodge,edges,exclusion,freeze,grainextract,grainmerge,green,hardlight,\
       hardmix,hue,interpolation,lighten,lightness,linearburn,linearlight,luminance,\
       multiply,negation,or,overlay,pinlight,red,reflect,saturation,\
       shapeaverage,shapeaverage0,softburn,softdodge,softlight,screen,stamp,subtract,value,\
       vividlight,xor}
  if $2==0 repeat int($!/2) l[$>,{$>+1}] rv blend $mode,$3,$4 endl done # Two-by-two.
  elif $2==1" && "$!>1 blend[^0] [0],$mode,$3,1 rm[0]  # Top layer is top for all blends.
  elif $2==2" && "$!>1 blend[^-1] [-1],$mode,$3,0 rm[-1] # Bottom layer is bottom for all blends.
  endif

################################################################
##                                                            ##
##              FIN Fonction gimp_blend_1651                  ##
##                                                            ##
################################################################
################################################################
##                                                            ##
##               Fonction trait_epais_samj                    ##
##                                                            ##
################################################################

##   Dernière mise à jour : 2012/12/26
##  Pour tracer un trait avec une certaine épaisseur avec 2 modes pour terminer les extrémités
##  appel par :
##     trait_epais_samj Origine_X,Origine_Y,Terminaison_X,Terminaison_Y,Epaisseur,Mode_extremite,R_trait,V_trait,B_trait,A_trait
##     gmic 800,800,1,4 -m samj.gmic trait_epais_samj 750,50,50,750,40,1,255,128,64,255

trait_epais_samj :

 ## Variables
# Origine_X=$1
# Origine_Y=$2
# Terminaison_X=$3
# Terminaison_Y=$4
# Demi_epaisseur={$5/2}
# Mode_extremite=$6  # 1 tracer un cercle pour créer des extrémitées arrondies
# R_trait=$7
# V_trait=$8
# B_trait=$9
# A_trait=$10

# if {$Terminaison_X-$Origine_X}==0

#  X1={$Origine_X-$Demi_epaisseur}
#  Y1=$Origine_Y

#  X2={$Terminaison_X-$Demi_epaisseur}
#  Y2=$Terminaison_Y

#  X3={$Terminaison_X+$Demi_epaisseur}
#  Y3=$Terminaison_Y

#  X4={$Origine_X+$Demi_epaisseur}
#  Y4=$Origine_Y

# else
#  if {$Terminaison_Y-$Origine_Y}==0

#   X1=$Origine_X
#   Y1={$Origine_Y+$Demi_epaisseur}

#   X2=$Terminaison_X
#   Y2={$Terminaison_Y+$Demi_epaisseur}

#   X3=$Terminaison_X
#   Y3={$Terminaison_Y-$Demi_epaisseur}

#   X4=$Origine_X
#   Y4={$Origine_Y-$Demi_epaisseur}

#  else

   # triangle de base
#   angle_triangle={{{pi}/2}-{atan({{$Terminaison_Y-$Origine_Y}/{$Terminaison_X-$Origine_X}})}}
#   X_triangle={$Demi_epaisseur*{cos($angle_triangle)}}
#   Y_triangle={$Demi_epaisseur*{sin($angle_triangle)}}

   # déterminer 4 points pour tracer un rectangle
#   X1={$Origine_X-$X_triangle}
#   Y1={$Origine_Y+$Y_triangle}

#   X2={$Terminaison_X-$X_triangle}
#   Y2={$Terminaison_Y+$Y_triangle}

#   X3={$Terminaison_X+$X_triangle}
#   Y3={$Terminaison_Y-$Y_triangle}

#   X4={$Origine_X+$X_triangle}
#   Y4={$Origine_Y-$Y_triangle}

#  endif
# endif

# polygon[-1] 4,$X1,$Y1,$X2,$Y2,$X3,$Y3,$X4,$Y4,1,$R_trait,$V_trait,$B_trait,$A_trait

# if $Mode_extremite==1
#  circle[-1] $Origine_X,$Origine_Y,$Demi_epaisseur,1,$R_trait,$V_trait,$B_trait,$A_trait
#  circle[-1] $Terminaison_X,$Terminaison_Y,$Demi_epaisseur,1,$R_trait,$V_trait,$B_trait,$A_trait
# endif

# # line[-1] $Origine_X,$Origine_Y,$Terminaison_X,$Terminaison_Y,1,255,255,255,255  # vérification

## version variables $1,$2,$3,etc.
## Pour tracer une ligne avec une certaine épaisseur et 2 modes pour terminer les extrémités
##
## stroke Origine_X,Origine_Y,Terminaison_X,Terminaison_Y,Epaisseur,Mode_extremite(1 pour extremitée arrondie),Rouge,Vert,Bleu,Alpha
## gmic 800,800,1,4 stroke 750,50,50,750,40,1,255,128,64,255

# stroke :
  if {$3-$1}==0 X1={$1-{$5/2}} Y1=$2 X2={$3-{$5/2}} Y2=$4 X3={$3+{$5/2}} Y3=$4 X4={$1+{$5/2}} Y4=$2
  else
     if {$4-$2}==0 X1=$1 Y1={$2+{$5/2}} X2=$3 Y2={$4+{$5/2}} X3=$3 Y3={$4-{$5/2}} X4=$1 Y4={$2-{$5/2}}
     else angle_triangle={{{pi}/2}-{atan({{$4-$2}/{$3-$1}})}} X_triangle={{$5/2}*{cos($angle_triangle)}} Y_triangle={{$5/2}*{sin($angle_triangle)}}
    X1={$1-$X_triangle} Y1={$2+$Y_triangle} X2={$3-$X_triangle} Y2={$4+$Y_triangle} X3={$3+$X_triangle} Y3={$4-$Y_triangle} X4={$1+$X_triangle} Y4={$2-$Y_triangle}
     endif
  endif
  polygon[-1] 4,$X1,$Y1,$X2,$Y2,$X3,$Y3,$X4,$Y4,1,$7,$8,$9,$10
  if $6==1 circle[-1] $1,$2,{$5/2},1,$7,$8,$9,$10 circle[-1] $3,$4,{$5/2},1,$7,$8,$9,$10 endif

################################################################
##                                                            ##
##             FIN  Fonction trait_epais_samj                 ##
##                                                            ##
################################################################
#################################################
##                                             ##
##      Fonction  samj_sierpinski_absolu       ##
##                                             ##
#################################################
## Adapatatin de "sierpinski" de David Tschumperlé
## valeurs par défaut :  samj_sierpinski_absolu 7,0,0,10,100,150,20,255,255,0,255  ( samj_sierpinski_absolu Récursions,Xa,Ya,Xb,Yb,Xc,Yc,R,V,B,A )
## Draw Sierpinski triangle on selected images avec coordonnées absolues et couleur RVBA.

samj_sierpinski_absolu : check ${1=7}>=0 skip ${2=0},${3=0},${4=10},${5=100},${6=150},${7=20},${8=255},${9=255},${10=0},${11=255}
  e[^-1] "Draw Sierpinski triangle of degree $1 on image$?."
  _samj_sierpinski_absolu ${2-11},$1
_samj_sierpinski_absolu :
  if $11<=0 polygon 3,$1,$2,$3,$4,$5,$6,1,$7,$8,$9,$10 return endif
  _samj_sierpinski_absolu $1,$2,{($1+$3)/2},{($2+$4)/2},{($1+$5)/2},{($2+$6)/2},$7,$8,$9,$10,{$11-1}
  _samj_sierpinski_absolu {($1+$3)/2},{($2+$4)/2},$3,$4,{($3+$5)/2},{($4+$6)/2},$7,$8,$9,$10,{$11-1}
  _samj_sierpinski_absolu {($1+$5)/2},{($2+$6)/2},$5,$6,{($3+$5)/2},{($4+$6)/2},$7,$8,$9,$10,{$11-1}
#################################################
##                                             ##
##      Fonction  samj_sierpinski_absolu       ##
##                                             ##
#################################################


#################################################
##                                             ##
##       Fonction  samj_snowflake_absolu       ##
##                                             ##
#################################################
## Adapatatin de "snowflake" de David Tschumperlé pour obtenir des triangles avec les valeurs absolues des coordonnées
## 200,200,1,4 fill_color[-1] 255,0,0,255 samj_snowflake_absolu[-1] 3,20,20,40,100,100,40,1,192,128,64

samj_snowflake_absolu :
  to_rgba
  polygon 3,$2,$3,$4,$5,$6,$7,${8--1},255
  _samj_snowflake_absolu $1,$2,$3,$6,$7,${8--1}
  _samj_snowflake_absolu $1,$6,$7,$4,$5,${8--1}
  _samj_snowflake_absolu $1,$4,$5,$2,$3,${8--1}

_samj_snowflake_absolu :
  x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
  x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
  c={cos(-pi/3)} s={sin(-pi/3)}
  x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
  polygon 3,$x0,$y0,$x1,$y1,$x2,$y2,${6--1},255
  if $1
    _samj_snowflake_absolu {$1-1},$2,$3,$x0,$y0,${6--1}
    _samj_snowflake_absolu {$1-1},$x0,$y0,$x2,$y2,${6--1}
    _samj_snowflake_absolu {$1-1},$x2,$y2,$x1,$y1,${6--1}
    _samj_snowflake_absolu {$1-1},$x1,$y1,$4,$5,${6--1}
  endif

#################################################
##                                             ##
##     FIN Fonction  samj_snowflake_absolu     ##
##                                             ##
#################################################


#################################################
##                                             ##
##  Fonction  samj_snowflake_contours_absolu   ##
##                                             ##
#################################################
## Adapatatin de "snowflake" de David Tschumperlé pour obtenir le contour des triangles avec les valeurs absolues des coordonnées
## 200,200,1,4 fill_color[-1] 255,0,0,255 samj_snowflake_contours_absolu[-1] 3,20,20,40,100,100,40,1,192,128,64

samj_snowflake_contours_absolu :
  to_rgba
  polygon 3,$2,$3,$4,$5,$6,$7,$8,0xFFFFFFFF,$9,$10,$11,255
  _samj_snowflake_contours_absolu $1,$2,$3,$6,$7,${8--1}
  _samj_snowflake_contours_absolu $1,$6,$7,$4,$5,${8--1}
  _samj_snowflake_contours_absolu $1,$4,$5,$2,$3,${8--1}

_samj_snowflake_contours_absolu :
  x0={$2+($4-$2)/3} y0={$3+($5-$3)/3}
  x1={$2+2*($4-$2)/3} y1={$3+2*($5-$3)/3}
  c={cos(-pi/3)} s={sin(-pi/3)}
  x2={$x0+($x1-$x0)*$c-($y1-$y0)*$s} y2={$y0+($x1-$x0)*$s+($y1-$y0)*$c}
  polygon 3,$x0,$y0,$x1,$y1,$x2,$y2,$6,0xFFFFFFFF,${7--1},255
  if $1
    _samj_snowflake_contours_absolu {$1-1},$2,$3,$x0,$y0,${6--1}
    _samj_snowflake_contours_absolu {$1-1},$x0,$y0,$x2,$y2,${6--1}
    _samj_snowflake_contours_absolu {$1-1},$x2,$y2,$x1,$y1,${6--1}
    _samj_snowflake_contours_absolu {$1-1},$x1,$y1,$4,$5,${6--1}
  endif

#################################################
##                                             ##
## FIN Fonction samj_snowflake_contours_absolu ##
##                                             ##
#################################################


###################################################################################################################
##                                                                                                               ##
##    Appel anciennes fonctions "euclidean2polar" et "polar2euclidean" de G'MIC 1.5.8.6 par David Tschumperlé    ##
##                                                                                                               ##
###################################################################################################################

## FONCTION twirl_ancien_euclidean2polar_ancien_polar2euclidean
 twirl_ancien_euclidean2polar_ancien_polar2euclidean : skip ${1=1},${2=50%},${3=50%},${4=1}
   e[^-1] "Apply twirl deformation on image$?, with amplitude $1 and center point at ($2%,$3%)."
   euclidean2polar_ancien $2,$3,1,$4 repeat $!
  [$>],[$>],1,1,$1*x channels[-1] -1,0 warp[$>] [-1],1,1,2 rm[-1]
   done polar2euclidean_ancien $2,$3,1,1

## FONCTION euclidean2polar_ancien
 euclidean2polar_ancien : skip ${1=0.5},${2=0.5},${3=1},${4=1}
   e[^-1] "Apply euclidean to polar transform on image$?."
   repeat $! l[$>]
  ({w},{h}) ($1,$2) *[-2,-1] ({"sqrt(max("{@0}","{-2,w}"-"{@0}")^2 + max("{@1}","{-2,h}"-"{@1}")^2)"})
  a[-2,-1] x
  [-2],[-2],1,1,{@2}"*(x/w)^$3*cos(y*2*pi/h)" +[-1] {-2,@0}
  [-1],[-1],1,1,{-2,@2}"*(x/w)^$3*sin(y*2*pi/h)" +[-1] {-3,@1}
  rm[-3] a[-2,-1] c warp[-2] [-1],0,1,$4 rm[-1]
   endl done

## FONCTION polar2euclidean_ancien
 polar2euclidean_ancien : skip ${1=0.5},${2=0.5},${3=1},${4=1}
   e[^-1] "Apply polar to euclidean transform on image$?."
   repeat $! l[$>]
  ({w},{h}) ($1,$2) *[-2,-1] ({"sqrt(max("{@0}","{-2,w}"-"{@0}")^2 + max("{@1}","{-2,h}"-"{@1}")^2)"})
  a[-2,-1] x
  [-2],[-2],1,1,"w*(sqrt((x-"{@0}")^2 + (y-"{@1}")^2)/"{@2}")^(1/$3)"
  [-1],[-1],1,1,"(atan2(y-"{-2,@1}",x-"{-2,@0}")*h/(2*pi)+h)%h"
  rm[-3] a[-2,-1] c warp[-2] [-1],0,1,$4 rm[-1]
   endl done

###################################################################################################################
##                                                                                                               ##
##  FIN Appel anciennes fonctions "euclidean2polar" et "polar2euclidean" de G'MIC 1.5.8.6 par David Tschumperlé  ##
##                                                                                                               ##
###################################################################################################################


#################################################################################################################################################################################################
#
#                                                                                                                                                                                          DIVERS
#
#################################################################################################################################################################################################
#################################################
##                                             ##
##         Je_passe_l_hiver_en_Floride         ##
##                                             ##
#################################################
#@gui Do Nothing : Je_passe_l_hiver_en_Floride, Je_passe_l_hiver_en_Floride
#@gui :_=note("<small><b>Note</b> : This filters does nothing on the image. Use it to manipulate layers in conjunction with the input/output options of the G'MIC plug-in.</small>")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>David Tschumperlé</i>.      Latest update: <i>2010/12/29</i>.</small>")
Je_passe_l_hiver_en_Floride :
#################################################
##                                             ##
##       FIN Je_passe_l_hiver_en_Floride       ##
##                                             ##
#################################################

#################################################
##                                             ##
##                samj_diaporama               ##
##                                             ##
#################################################
# Merci à Garagecoder pour son aide :o)
#@gui Diaporama - Slideshow : samj_diaporama,gui_no_preview
#@gui :_=note("Ce filtre démarre un diaporama automatique en mode plein écran.\n<b><span foreground="red"> Paramétrage à faire :\n - Calques en entrée = Tous.\n - Mode de sortie = Nouvelle image.</span></b>")
#@gui :_=note(" - Delai / Time Secondes = Temps d'affichage de chaque calque.\n - Diaporama Infini / Infinite slideshow = Boucle infinie d'affichage des images.")
#@gui :_=note("<small>Utilisation du clavier :\n - Barre d'espacement ou Entrée = Image suivante.\n - Échap ou Q = Sortie du diaporama.\n - Page Haut = Image précédente.</small>")
#@gui :_=separator()
#@gui :_=note("This filter starts an automatic slideshow in full screen mode.\n<b><span foreground="red"> Important settings to do :\n - Input layers = All.\n - Output mode = New image.</span></b>")
#@gui :_=note(" - Delai / Time Secondes = Display time of each layer.\n - Diaporama Infini / Infinite slideshow = Infinite image display loop.")
#@gui :_=note("<small>Using the keyboard :\n - Space bar or Enter = Next image.\n - Esc or Q = Exit.\n - Page UP = Previous image.</small>")
#@gui :_=separator()
#@gui : Delai / Time Secondes = int(1,1,300)
#@gui : Diaporama Infini / Infinite slideshow = bool(0)
samj_diaporama :
	if $2==0
		samj_diapo $1
	else
		do
			if {{*,ESC}||{*,Q}} break fi
			samj_diapo $1
		while 1
	fi
	rm[-$!--1]

samj_diapo :
	Delai={$1*1000}
	Bc=$!
	do
		if {{*,ESC}||{*,Q}} break fi
		if {*,PAGEUP}
			Bc={$Bc+2}
			if $Bc>$! Bc=$! fi
		fi
		if {*,PAGEDOWN} Bc={$Bc-2} fi
		+samj_full_screen_display[{$Bc-$!-1}] 1,,,$Delai
		Bc={$Bc-1}
	while $Bc>=1

#################################################
##                                             ##
##              FIN samj_diaporama             ##
##                                             ##
#################################################

#################################################
##                                             ##
##               samj_Tests_Fill               ##
##                                             ##
#################################################

# http://opensource.graphics/image-processing-made-easier-with-a-powerful-math-expression-evaluator/
# https://gmic.eu/tutorial/_fill.shtml

#@gui Tests Fill : samj_Tests_Fill, samj_Tests_Fill
#@gui :_=note("<i>Adaptation des exemples de David Tschumperlé, Garry Osgood</i>")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Type Fill</b></span>")
#@gui : 1 - Fill = choice(0,"Logo","Julia 1","Julia 2","Courbe","Vector Painting","Gradients","Colorisation","Lignes","Motifs","Couleur","Negatif","Artistic")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">----- Logo -----</span>")
#@gui : 2 - Rayon = int(30,0,100)
#@gui :_=note("<span foreground="orangered">----- Julia 1 -----</span>")
#@gui : 3 - Zoom = float(2,0.5,4)
#@gui : 4 - A = float(-0.8,-1.6,1.6)
#@gui : 5 - B = float(0.4,-0.8,0.8)
#@gui :_=note("<span foreground="orangered">----- Courbe -----</span>")
#@gui : 6 - Display Parametric = bool(1)
#@gui :_=note("<span foreground="orangered">----- Vector Painting -----</span>")
#@gui : 7 - A = int(1,1,50)
#@gui :_=note("<span foreground="orangered">----- Gradients -----</span>")
#@gui : 8 - Choix = choice(0,"H","V","H V","Sur Image","2 Couleurs")
#@gui :_=note("<span foreground="orangered">----- Lignes -----</span>")
#@gui : 9 - Choix = choice(0,"Diagonale","Diagonale Négatif","45 Degrés","Verticales Grises 4 Pix.","Médiane")
#@gui :_=note("<span foreground="orangered">----- Motifs -----</span>")
#@gui : 10 - Choix = choice(0,"A","B")
#@gui :_=note("<span foreground="orangered">----- Couleur -----</span>")
#@gui : 11,12,13 - Couleur = color(120,40,240)
#@gui :_=note("<span foreground="orangered">----- Artistic -----</span>")
#@gui : 14 - Choix = choice(0,"Série Dégradés V","Série Dégradés H","Série 2 - Dégradés V","Série 2 - Dégradés H","Hallucinogen","Zones Couleurs","XorXY","XorXY Blend","Distraction","Carrés","Rayons","Rayé","Tamis")
#@gui : 15 - Variation Artistic = float(50,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Derni\303\250re mise \303\240 jour : <i>2020/11/29</i>.</small>")

samj_Tests_Fill :

if $1==0 # Logo
	fill "X=x-w/2; Y=y-h/2; R=sqrt(X^2+Y^2); a=atan2(Y,X); if(R<=(w/100*$2),255*abs(cos(c+200*(x/w-0.5)*(y/h-0.5))),850*(a%(0.1*(c+1))))"
elif $1==1 # Julia 1
	fill "zr = $3 + $3*-2*x/w; zi = $3 + $3*-2*y/h; for (iter = 0, zr^2+zi^2<=4 && iter<256, ++iter, t = zr^2 - zi^2 + $4; (zi *= 2*zr) += $5; zr = t); zi;"
elif $1==2 # Julia 2
	fill "z = 2.4*[ x/w, y/h ] - 1.2; for (iter = 0,  cabs(z)<=2 && iter<256, ++iter, z = z**z + [ 0.4,0.2 ]); iter;"
elif $1==3 # Courbe
	fill "t=x/40;if(c==0,sin(t),cos(t))*(exp(cos(t))-2*cos(4*t)-sin(t/12)^5)"
	if $6==1 display_parametric 512,512 endif
elif $1==4 # Vector Painting	
	fill "dmax = -1; nmax = 0; for (n = 0, ++n<=8, p = arg(n,-$7,0,$7,-$7,$7,-$7,0,$7); q = arg(n,-$7,-$7,-$7,0,0,$7,$7,$7); d = (j(p,q,0,0,0,1)-i)^2; if(d>dmax,dmax = d; nmax = n,nmax) )"
elif $1==5 # Gradients
	if $8==0
		fill "1/w*x"
	elif $8==1
		fill "1/h*y"
	elif $8==2
		fill 'y/h+x/w'
	elif $8==3
		fill '(i*(x+y))'
	elif $8==4
		fill "!c?x:c==1?y:(x+y)/2"
	endif
elif $1==6 # Colorisation
	fill "[(G+B)/2,(R+B)/2,(R+G)/2]"
elif $1==7 # Lignes
	if $9==0
		fill "x==y*w/h"
	elif $9==1
		fill "x!=y*w/h"
	elif $9==2
		fill "x==h-y"
	elif $9==3
		fill "0,0,0,0,0.5,0.5,0.5,0.5,1,1,1,1"
	elif $9==4
		fill "x!=w/2"
	endif
elif $1==8 # Motifs
	if $10==0 #  résultat décevant
		Dimension=16
		1,2,1,3
		fill "255,255,0,255,255,0,0,255"
		resize[-1] $Dimension,$Dimension
		{$Dimension*16},{$Dimension*16},1,4
		fill [-2]
		rm[0]
		rv[-1,-2]
	elif $10==1
		{w},{h},1,3
		rm[0]
		fill "x=x-w/2;y=y-h/2;r=sqrt(x*x+y*y);a=atan2(y,x);5*sin(r/10)*[cos(a),sin(a)]"
	endif
elif $1==11 # Artistic
	if $14==0
		fill "x%(10+$15)"
	elif $14==1
		fill "y%(10+$15)"
	elif $14==2
		fill "x&(1+5*$15)"
	elif $14==3
		fill "y&(1+5*$15)"
	elif $14==4
		fill "i%(10+$15)"
	elif $14==5
		fill "xor(i,(10+$15))"
	elif $14==6
		fill "xor((x+($15*10)),(y+($15*10)))"
	elif $14==7
		fill "xor(i,xor((x+($15*10)),(y+($15*10))))"
	elif $14==8
		+blur {$15/4}
		repeat 2
			fill[-1] "dmax=-1; nmax=0; for (n=0, ++n<=8, p=arg(n,-4,0,4,-4,4,-4,0,4); q=arg(n,-4,-4,-4,0,0,4,4,4); d=(j(p,q,0,0,0,1)-i)^2; if(d>dmax,dmax=d; nmax=n,nmax))"
		done
		fill[-1] "[(R+G+B)/3,(R+G+B)/3,(R+G+B)/3]"
		fill[-1] "-i"
		n[-1] 0,255
		blend grainmerge
		fill "[(G+B)/2,(R+B)/2,(R+G)/2]"
	elif $14==9
		{w},{h},1,1
		rm[0]
		Orientation=(round($15)%4)
		if $Orientation==0
			+fill "x%(16+$15)"
			fill[-2] "y%(16+$15)"
		elif $Orientation==1
			+fill "-x%(15+$15)"
			fill[-2] "y%(15+$15)"
		elif $Orientation==2
			+fill "x%(14+$15)"
			fill[-2] "-y%(14+$15)"
		elif $Orientation==3
			+fill "-x%(13+$15)"
			fill[-2] "-y%(13+$15)"
		endif
		n 0,255
		to_rgb
		blend average
	elif $14==10
		{w},{h},1,4
		if (round($15)%2)==0
			fill[-1] "x=x-w/2;y=y-h/2;r=sqrt(x*x+y*y);r*sin((1+$15*2)*(x-y)/(x+y));"
		else
			fill[-1] "x=x-w/2;y=y-h/2;r=sqrt(x*x+y*y);r*sin((1+$15*2)*(x+y)/(x-y));"
		endif
		n[-1] 128,255
		blend alpha
	elif $14==11
		if (round($15)%2)==0
			fill "if(i>(255/100*$15),((x+y)%40),((x-y)%40))"
		else
			fill "if(i<(255/100*$15),((x+y)%40),((x-y)%40))"
		endif
	elif $14==12
		if (round($15)%2)==0
			fill "(i>(255/100*$15))&&((x+y)%20)&&((x-y)%20)"
		else
			fill "(i<(255/100*($15-1)))&&((x+y)%20)&&((x-y)%20)"
		endif
	endif
endif
n 0,255
if $1==9 # Couleur
	fill "[$11,$12,$13]"
elif $1==10 # Négatif
	min={stats()[0]}
	max={stats()[1]}
	fill "-i"
	n $min,$max
endif

#################################################
##                                             ##
##             FIN samj_Tests_Fill             ##
##                                             ##
#################################################
#################################################
##                                             ##
##                samj_Relief_A                ##
##                                             ##
#################################################

#@gui Relief A : samj_Relief_A, samj_Relief_A(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Vanvliet</span>")
#@gui : Variation = float (3,0,6)
#@gui : Order = int (1,0,3)
#@gui : Axis = choice (0,"X","Y","-X","-Y")
#@gui : Boundary = choice (1,"Dirichlet","Neumann")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Iain Fergusson - Simplelocal Contrast</b></span>")
#@gui : Edge Sensitivity = float (16,0,25)
#@gui : Itérations = int (1,1,5)
#@gui : Paint effect = float (50,0,50)
#@gui : Channels = Choice (1,"Colour","Luminance Only")
#@gui : Pre gamma = float (1.0,0.1,5)
#@gui : Post gamma = float (1.2,0.1,5)
#@gui :_=note("<small>Luminance Mask</small>" )
#@gui : Blacks = float (1,0,1)
#@gui : Dark grey = float (1,0,1)
#@gui : Mid grey = float (1,0,1)
#@gui : Light grey = float (1,0,1)
#@gui : Whites = float (1,0,1)
#@gui : Parallel Processing = Choice (1,"Auto","None")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Wavelet Sharpen</b></span>")
#@gui : Sharpen = choice(0,"Sharpen A","Sharpen B","Sharpen A B")
#@gui : Sharpen A Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Sharpen A Itérations = int(0,0,2)
#@gui : Sharpen B Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Sharpen B Itérations = int(0,0,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered">Relief</span>")
#@gui : Cut A % = float(0,0,100)
#@gui : Cut B % = float(100,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2020/10/24</i>.</small>")

samj_Relief_A :

V_variation=$1
V_order=$2
V_axis=$3
V_boundary=$4

SC_Edge_Sensitivity=$5
SC_Iterations=$6
SC_Paint_effect=$7
SC_Channels=$8
SC_Pre_gamma=$9
SC_Post_gamma=$10
SC_Blacks=$11
SC_Dark_grey=$12
SC_Mid_grey=$13
SC_Light_grey=$14
SC_Whites=$15
SC_Parallel_Processing=$16
Wavelet_Sharpen_Selection=$17
Wavelet_Sharpen_Type_A=$18
Wavelet_Sharpen_Iterations_A=$19
Wavelet_Sharpen_Type_B=$20
Wavelet_Sharpen_Iterations_B=$21
Cut_A=$22
Cut_B=$23

+Je_passe_l_hiver_en_Floride[-1]
if $V_axis==0
 vanvliet[-1] $V_variation,$V_order,x,$V_boundary
elif $V_axis==1
 vanvliet[-1] $V_variation,$V_order,y,$V_boundary
elif $V_axis==2
 mirror[-1] x
 vanvliet[-1] $V_variation,$V_order,x,$V_boundary
 mirror[-1] x
elif $V_axis==3
 mirror[-1] y
 vanvliet[-1] $V_variation,$V_order,y,$V_boundary
 mirror[-1] y
endif
n[-1] 0,{{iM}-{im}}
c[-1] {{iM}/100*$Cut_A},{iM}
n[-1] 0,{iM}
c[-1] 0,{{iM}/100*$Cut_B}
n[-1] 0,255
to_gray[-1]
if $Wavelet_Sharpen_Selection==1||$Wavelet_Sharpen_Selection==2
 samj_Wavelet_Sharpen_Test_en[-1] $Wavelet_Sharpen_Type_B,$Wavelet_Sharpen_Iterations_B
endif
simplelocalcontrast_p[-2] $SC_Edge_Sensitivity,$SC_Iterations,$SC_Paint_effect,$SC_Channels,$SC_Pre_gamma,$SC_Post_gamma,$SC_Blacks,$SC_Dark_grey,$SC_Mid_grey,$SC_Light_grey,$SC_Whites,$SC_Parallel_Processing
if $Wavelet_Sharpen_Selection==0||$Wavelet_Sharpen_Selection==2
 samj_Wavelet_Sharpen_Test_en[-2] $Wavelet_Sharpen_Type_A,$Wavelet_Sharpen_Iterations_A
endif
blend[-1,-2] grainextract

#################################################
##                                             ##
##              FIN samj_Relief_A              ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_Test_Solidify             ##
##                                             ##
#################################################

#@gui Test Solidify  : samj_Test_Solidify , samj_Test_Solidify (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_Quelques_Isophotes</b></span>")
#@gui : Épaisseur = int(10,1,32)
#@gui : Précision = int(10,1,32)
#@gui : Coeff précision = float(1,0.1,8)
#@gui : Coeff Flou = float(0.02,0,1)
#@gui : Isophotes = int(8,2,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Solidify</b></span>")
#@gui : Valider Solidify = bool(1)
#@gui : Smoothness % = float(75,0,100)
#@gui : Diffusion Type = choice(0,"Isotropic","Delaunay Oriented","Edge Oriented")
#@gui : Diffusion Iter = int(20,1,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2017/01/05</i>.</small>")

samj_Test_Solidify :

Epaisseur=$1
Precision=$2
Coeff_Precision_Pixelise=$3
Coeff_Precision_Flou=$4
Nb_Isophotes=$5
Valider_Solidify=$6
smoothness=$7
diffusion_type=$8
diffusion_iter=$9

samj_Quelques_Isophotes[-1] $Epaisseur,$Precision,$Coeff_Precision_Pixelise,$Coeff_Precision_Flou,$Nb_Isophotes
if $Valider_Solidify==1 solidify[-1] $smoothness,$diffusion_type,$diffusion_iter endif

#################################################
##                                             ##
##            FIN samj_Test_Solidify           ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_CeKoaSa_009               ##
##                                             ##
#################################################
# 2017/01/05 ajout script origine + courbes
#@gui  CeKoaSa 009: samj_CeKoaSa_009, samj_CeKoaSa_009(0)
#@gui : sep = separator(), url = link("Essai adaptation du didacticiel de Sebastien Guyader et du code de Iain Fergusson","https://discuss.pixls.us/t/highlight-bloom-and-photoillustration-look/2509/29")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth</b></span>")
#@gui : Itérations= int(1,1,10)
#@gui : Amplitude = float(5,0,1000)
#@gui : Sharpness = float(0.5,0,2)
#@gui : Anisotropy = float(0.63,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(2.35,0,10)
#@gui : Spatial precision = float(0.8,0.1,2)
#@gui : Angular precision = float(30,1,180)
#@gui : Value precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Iain Fergusson - Simplelocal Contrast</b></span>")
#@gui : Edge Sensitivity = float (25,0,25)
#@gui : Itérations = int (1,1,5)
#@gui : Paint effect = float (50,0,50)
#@gui : Channels = Choice (1,"Colour","Luminance Only")
#@gui : Pre gamma = float (1.0,0.1,5)
#@gui : Post gamma = float (1.2,0.1,5)
#@gui :_=note("<small>Luminance Mask</small>" )
#@gui : Blacks = float (1,0,1)
#@gui : Dark grey = float (1,0,1)
#@gui : Mid grey = float (1,0,1)
#@gui : Light grey = float (1,0,1)
#@gui : Whites = float (1,0,1)
#@gui : Parallel Processing = Choice (1,"Auto","None")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Wavelet Sharpen</b></span>")
#@gui : Wavelet Sharpen vs Graphic Novel = Choice (0,"Wavelet Sharpen","Photocomix Graphic Novel")
#@gui : Type = choice(0,"Decompose 2","Decompose 6")
#@gui : Itérations = int(0,0,2)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Script Origine de Iain Fergusson</b></span>")
#@gui : Script Origine = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Courbes</b></span>")
#@gui : Utiliser Courbes = choice(0,"Non"," Utiliser Curves Interactive")
#@gui : Colorspace = choice{7,"RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr"}
#@gui : Output preset as a HaldCLUT layer = value(0)
#@gui : Apply transformation from = _choice("New curves [interactive]","Curves defined previously")
#@gui : Colorspace = value(0)
#@gui : Keypoints = value(0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2017/01/05</i>.</small>")

samj_CeKoaSa_009:

SM_Iterations=$1
SM_Amplitude=$2
SM_Sharpness=$3
SM_Anisotropy=$4
SM_Gradient_smoothness=$5
SM_Tensor_smoothness=$6
SM_Spatial_precision=$7
SM_Angular_precision=$8
SM_Value_precision=$9
SM_Interpolation=$10
SM_Fast_approximation=$11

SC_Edge_Sensitivity=$12
SC_Iterations=$13
SC_Paint_effect=$14
SC_Channels=$15
SC_Pre_gamma=$16
SC_Post_gamma=$17
SC_Blacks=$18
SC_Dark_grey=$19
SC_Mid_grey=$20
SC_Light_grey=$21
SC_Whites=$22
SC_Parallel_Processing=$23

Wavelet_Sharpen=$24
Wavelet_Sharpen_Type=$25
Wavelet_Sharpen_Iterations=$26

Script_Origine=$27
Utiliser_courbes=$28

if $Script_Origine==1
 +fx_smooth_anisotropic[0] 10,0.16,0.63,0.6,2.35,0.8,30,2,0,1,1,0,1
 sub[0] [1]
 simplelocalcontrast_p[1] 25,1,50,1,1,1.2,1,1,1,1,1,1
 fx_graphic_novelfxl[1] 1,2,6,5,20,0,1,100,0,1,0,0.78,1.92,0,0,2,1,1,1,1.26,0.37,1.05
 add
 c 0,255
else
 +Je_passe_l_hiver_en_Floride[-1]
 repeat $SM_Iterations
  smooth[-1] $SM_Amplitude,$SM_Sharpness,$SM_Anisotropy,$SM_Gradient_smoothness,$SM_Tensor_smoothness,$SM_Spatial_precision,$SM_Angular_precision,$SM_Value_precision,$SM_Interpolation,$SM_Fast_approximation
 done
 sub[-2] [-1]
 simplelocalcontrast_p[-1] $SC_Edge_Sensitivity,$SC_Iterations,$SC_Paint_effect,$SC_Channels,$SC_Pre_gamma,$SC_Post_gamma,$SC_Blacks,$SC_Dark_grey,$SC_Mid_grey,$SC_Light_grey,$SC_Whites,$SC_Parallel_Processing
 if $Wavelet_Sharpen==0
  samj_Wavelet_Sharpen_Test_en[-1] $Wavelet_Sharpen_Type,$Wavelet_Sharpen_Iterations
 elif $Wavelet_Sharpen==0
  fx_graphic_novelfxl[-1] 1,2,6,5,20,0,1,100,0,1,0,0.78,1.92,0,0,2,1,1,1,1.26,0.37,1.05
 endif
 rm[-2]
 c[-1] 0,255
endif

if $Utiliser_courbes==1
 fx_curves_interactive[-1] $29,$30,$31,$32,$33
endif

#################################################
##                                             ##
##            FIN samj_CeKoaSa_009             ##
##                                             ##
#################################################
#################################################
##                                             ##
##               samj_CeKoaSa_008              ##
##                                             ##
#################################################

#@gui  CeKoaSa 008 : samj_CeKoaSa_008, samj_CeKoaSa_008_preview(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b><u>Filtre Lent</u></b></span>")
#@gui : Détection A = int(64,0,127)
#@gui : Détection B = int(64,0,127)
#@gui : Flou Lissage = float(4,0,10)
#@gui : Couleur = float(1,0,4)
#@gui : Rendu = int(2,1,7)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Topographic Map</b></span>")
#@gui : Levels = int(16,4,256)
#@gui : Smoothness = float(1,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Stained Glass</b></span>")
#@gui : Edges = float(20,0,100)
#@gui : Shading = float(0.1,0,0.5)
#@gui : Thin separators = bool(0)
#@gui : Intensité = int(1,1,8)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Isophotes</b></span>")
#@gui : Isophotes Nb Levels = int(64,1,128)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Smooth [antialias]</b></span>")
#@gui : Smooth [antialias] = bool(1)
#@gui : Amplitude = float(2,0,100)
#@gui : Edge threshold (%) = float(10,0,100)
#@gui : Smoothness = float(0.8,0,5)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Fond</b></span>")
#@gui : Couleur Fond = color(255,255,255,255)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/12/04</i>.</small>")

samj_CeKoaSa_008:

Detection_A=$1
Detection_B=$2
Flou_Lissage=$3
Couleur=$4
Type_Rendu=$5
Niveaux_TM=$6
Adoucissement_TM=$7
Edges_SG=$8
Shading_SG=$9
Is_Precise_SG=$10
Intensite_SG=$11
Isophotes_Nb_Levels=$12
Validation_Smooth_Antialias=$13
V_Amplitude=$14
V_Edge_Threshold=$15
V_Smoothness=$16
R_a=$17
V_a=$18
B_a=$19
A_a=$20

 blur[-1] $Flou_Lissage
 n[-1] 0,255
 c[-1] {127-$Detection_A},{127+$Detection_B}
 n[-1] 0,255
 mul[-1] $Couleur
 topographic_map[-1] $Niveaux_TM,$Adoucissement_TM
 +Je_passe_l_hiver_en_Floride[-1]
 stained_glass[-1] $Edges_SG,$Shading_SG,$Is_Precise_SG
 repeat $Intensite_SG
 +Je_passe_l_hiver_en_Floride[-1]
  blend[-1,-2] overlay
 done
 if $Type_Rendu==1
  to_graya[-1]
  blend[-1,-2] overlay
 elif $Type_Rendu==2
  to_graya[-1]
  blend[-1,-2] alpha
 elif $Type_Rendu==3
  to_graya[-1]
  blend[-1,-2] edges
 elif $Type_Rendu==4
  blend[-1,-2] overlay
 elif $Type_Rendu==5
  blend[-1,-2] alpha
 elif $Type_Rendu==6
  blend[-1,-2] edges
 elif $Type_Rendu==7
  blend[-1,-2] average
 endif
 isophotes[-1] $Isophotes_Nb_Levels
 if $Validation_Smooth_Antialias==1 fx_smooth_antialias[-1] $V_Amplitude,$V_Edge_Threshold,$V_Smoothness endif
 {w},{h},1,4
 fill_color[-1] $R_a,$V_a,$B_a,$A_a
 rv[-1,-2]
 blend[-1,-2] alpha

samj_CeKoaSa_008_preview :
  gui_split_preview "samj_CeKoaSa_008 $*",$-1

#################################################
##                                             ##
##             FIN samj_CeKoaSa_008            ##
##                                             ##
#################################################
#################################################
##                                             ##
##                 Texture 003                 ##
##                                             ##
#################################################

#2016/11/16
#2013/12/27
#@gui Texture 003  : samj_Texture_Aquarelle_1, samj_Texture_Aquarelle_1(1)
#@gui :_=note("<small>Texture</small>")
#@gui : Amplitude Noise = float(10,5,200)
#@gui : Density Hardsketchbw= float(10,5,100)
#@gui : Spread Variations = float(4,3,20)
#@gui : Amplitude Water = float(3,2,10)
#@gui : sep = separator()
#@gui :_=note("<small>Couleur / Color</small>")
#@gui : Couleur / Color = color(251,237,206)
#@gui : Opacité / Opacity = float(1,-1,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/11/16</i>.</small>")
samj_Texture_Aquarelle_1 :

Amplitude_Noise=$1
Density_Hardsketchbw=$2
Spread_Variations=$3
Amplitude_Water=$4
R3=$5
V3=$6
B3=$7
Opacite=$8

 {w},{h},1,3
 rm[-2]
 fill_color[-1] 255,255,255
 to_rgb[-1]
 fx_noise[-1] $Amplitude_Noise,0,2,0
 fx_hardsketchbw[-1] 300,$Density_Hardsketchbw,1,0.1,20,0,0
 {w},{h},1,3
 fill_color[-1] 255,255,255
 to_rgb[-1]
 fx_noise[-1] $Amplitude_Noise,0,2,0
 fx_hardsketchbw[-1] 300,$Density_Hardsketchbw,1,0.1,20,0,0
 fx_spread[-1] $Spread_Variations,$Spread_Variations,0,0
 blend[-1,-2] average,1,0
 water[-1] $Amplitude_Water,0
 {w},{h},1,3
 fill_color[-1] $R3,$V3,$B3
 to_rgb[-1]
 if $Opacite>=0
  blend[-1,-2] average,$Opacite,0
 else
  blend[-1,-2] edges,{1+$Opacite},1
 endif

#################################################
##                                             ##
##               FIN Texture 003               ##
##                                             ##
#################################################
#################################################
##                                             ##
##                Texture 002                  ##
##                                             ##
#################################################

#20161116
#20131214
#@gui Texture 002 : samj_gimp_texture_zero_zero_deux, samj_gimp_texture_zero_zero_deux(1)
#@gui : Détails = int(0,0,127)
#@gui : Résolution = float(10,4,20)
#@gui : Threshold = float(4,2,20)
#@gui : sep = separator()
#@gui : Edges = float(10,5,20)
#@gui : Blend Colors = float(0.5,0,1)
#@gui : Colors Boost = bool(1)
#@gui : Boost Intensity = float(1,0,1)
#@gui : sep = separator()
#@gui : Black Lines = bool(1)
#@gui : Blend Black Lines = float(0.3,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/11/16</i>.</small>")
samj_gimp_texture_zero_zero_deux :

Details_TA=$1
Polygonize_Resolution_TA=$2
Threshold_Thin_Edges_TA=$3
Edges_Threshold=$4
Blend_Colors_Opacity=$5
Colors_Boost=$6
Boost_Intensity=$7
Black_Lines=$8
Blend_Black_Lines_Opacity=$9

 +Je_passe_l_hiver_en_Floride[-1]
 if $Colors_Boost==1
  n[-1] 0,255
 endif
 samj_Toile_D_Araignee[-1] $Details_TA,$Polygonize_Resolution_TA,$Threshold_Thin_Edges_TA
 if $Black_Lines==1
  +Je_passe_l_hiver_en_Floride[-1]
  fx_edges[-1] 0,$Edges_Threshold,0
  fx_local_orientation[-1] 0,0,100,0,0,0
  blend[-1,-3] average,$Blend_Colors_Opacity,0
  blend[-1,-2] luminance,$Blend_Black_Lines_Opacity,0
 else
  fx_edges[-1] 0,$Edges_Threshold,0
  fx_local_orientation[-1] 0,0,100,0,0,0
  blend[-1,-2] average,$Blend_Colors_Opacity,0
 endif
 if $Colors_Boost==1
  +Je_passe_l_hiver_en_Floride[-1]
  n[-1,-2] 0,255
  blend[-1,-2] softlight,$Boost_Intensity,0
 endif

#################################################
##                                             ##
##               FIN Texture 002               ##
##                                             ##
#################################################
#################################################
##                                             ##
##              Toile_D_Araignee               ##
##                                             ##
#################################################

#20161116
#20131213
#@gui Toile Araignee : samj_Toile_D_Araignee, samj_Toile_D_Araignee(1)
#@gui : Détails = int(0,0,127)
#@gui : Résolution = float(10,4,20)
#@gui : Threshold = float(4,2,20)
#@gui :_=separator()
#@gui :_=note("<small>samj - Latest update : <i>2016/11/16</i>.</small>")

samj_Toile_D_Araignee :

Details=$1
Polygonize_Resolution=$2
Threshold_Thin_Edges=$3

 apply_curve[0] $Details,-1,128,-1,128,-1,128,-1,128,-1,128,255,1,0,0,0,0
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 fx_polygonize[-2] 300,100,0,$Polygonize_Resolution,$Polygonize_Resolution,0,0,0,255
 fx_thin_edges[-1] 0,$Threshold_Thin_Edges,0
 fx_blend[-2,-1] 36,1,1,,"0"
 fx_isophotes[-1] 8,0,1
 fx_blend_edges[-2,-1] 1,5,0
 to_rgb[-1]
 rgb2hsl8[-1]
 split[-1] c
 rm[-2,-3]
 fx_thin_edges[-1] 0,15,0,0

#################################################
##                                             ##
##             FIN Toile_D_Araignee            ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_CeKoaSa_007               ##
##                                             ##
#################################################

#@gui  CeKoaSa 007  : samj_CeKoaSa_007 , samj_CeKoaSa_007 (1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>samj_CeKoaSa_007</b></span>")
#@gui : Max Patch = int(8,1,32)
#@gui : Min Patch = int(8,1,32)
#@gui : Dilate = int(10,1,16)
#@gui : Pixelize = int(8,2,100)
#@gui : Blur = int(8,0,30)
#@gui :_=separator()
#@gui :_=note("<small>samj - Update : <i>2016/11/15</i>.</small>")

samj_CeKoaSa_007  :

Val_Max_Patch=$1
Val_Min_Patch=$2
Val_Dilate=$3
Val_Pixelize=$4
Flou=$5

 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 max_patch[-1] $Val_Max_Patch
 n[-1] 0,255
 min_patch[-2] $Val_Min_Patch
 n[-2] 0,255
 dilate[-1,-2] $Val_Dilate
 blend[-1,-2] edges
 blur[-1] $Flou
 pixelize[-1,-2,-3] $Val_Pixelize,$Val_Pixelize
 +luminance[-1]
 blend[-1,-2,-3] edges
 blend[-1,-2] grainmerge

#################################################
##                                             ##
##            FIN samj_CeKoaSa_007             ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_BoxFiter_Test             ##
##                                             ##
#################################################

#@gui BoxFiter Test  : samj_BoxFiter_Test, samj_BoxFiter_Test(1)
#@gui :_=note("samj_BoxFiter_Test")
#@gui : Blur = int(2,0,32)
#@gui : X = int(3,1,32)
#@gui : Y = int(3,1,32)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Sharpen</b></span>")
#@gui : Type = choice(1,"No","Decompose 2","Decompose 6")
#@gui : Itérations = int(2,0,3)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/12</i>.</small>")

samj_BoxFiter_Test :

Flou=$1
Valeur_X=$2
Valeur_Y=$3
samj_Wavelet_Sharpen=$4
Iterations_Wavelet_Sharpen=$5

 blur[-1] $Flou
 +Je_passe_l_hiver_en_Floride[-1]
 boxfilter[-1] y,$Valeur_Y,1
 n[-1] 0,255
 to_graya[-1]
 rv[-2,-1]
 boxfilter[-1] x,$Valeur_X,1
 n[-1] 0,255
 to_graya[-1]
 blend[-1,-2] alpha
 to_graya[-1]
 if $samj_Wavelet_Sharpen>0 samj_Wavelet_Sharpen_Test_en[-1] {$samj_Wavelet_Sharpen-1},$Iterations_Wavelet_Sharpen endif
 n[-1] 0,255

#################################################
##                                             ##
##             FIN samj_BoxFiter_Test          ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_BoxFiter_Map              ##
##                                             ##
#################################################

# 20161113 ajouts Transfer + Blend + Codage
#@gui BoxFiter Map  : samj_BoxFiter_Map, samj_BoxFiter_Map(1)
#@gui :_=note("samj_BoxFiter_Map")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>BoxFiter</b></span>")
#@gui : Blur = int(2,0,32)
#@gui : X = int(3,1,32)
#@gui : Y = int(3,1,32)
#@gui : Codage = choice(0,"Gray","Luminance")
#@gui : Blend = choice(0,"Alpha","Add")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Sharpen</b></span>")
#@gui : Type = choice(0,"No","Decompose 2","Decompose 6")
#@gui : Itérations = int(2,0,3)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Map</b></span>")
#@gui : Equalize = int(127,1,256)
#@gui : Colormap = int(16,2,256)
#@gui : Dithering = float(0,0,1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Transfer Color - Slow</b></span>")
#@gui : Transfer = bool(0)
#@gui : Luminosity Constraints = float(0.2,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/13</i>.</small>")

samj_BoxFiter_Map :

Flou=$1
Valeur_X=$2
Valeur_Y=$3
Codage=$4
Melange=$5
samj_Wavelet_Sharpen=$6
Iterations_Wavelet_Sharpen=$7
Valeur_Equalize=$8
Valeur_Colormap=$9
Valeur_Dithering=$10
Autorisation_Transfer=$11
Transfer_Luminosity_Constraints=$12

Transfer_Gamma=0.3
Transfer_Regularization=8
Transfer_RGB_Resolution=16
Transfer_Is_Constraints=0
Val_Max_Norm=255

 if $Melange==1 Val_Max_Norm=127 endif
 +Je_passe_l_hiver_en_Floride[-1]
 blur[-1] $Flou
 +Je_passe_l_hiver_en_Floride[-1]
 boxfilter[-1] y,$Valeur_Y,1
 n[-1] 0,$Val_Max_Norm
 to_graya[-1]
 rv[-2,-1]
 boxfilter[-1] x,$Valeur_X,1
 n[-1] 0,$Val_Max_Norm
 to_graya[-1]
 if $Codage==1 luminance[-1,-2] endif
 if $Melange==0 blend[-1,-2] alpha else blend[-1,-2] add endif
 to_rgb[-1]
 if $samj_Wavelet_Sharpen>0 samj_Wavelet_Sharpen_Test_en[-1] {$samj_Wavelet_Sharpen-1},$Iterations_Wavelet_Sharpen endif
 equalize[-1] $Valeur_Equalize,0,255
 n[-1] 0,255
 rv[-2,-1]
 to_rgb[-1]
 if $Autorisation_Transfer==1 Valeur_Colormap={round({{256*0.8}+{$Valeur_Colormap*0.2}})} endif
 colormap[-1] $Valeur_Colormap
 index[-2] [-1],$Valeur_Dithering,0
 if $Autorisation_Transfer==1 transfer_rgb[-2] [-1],$Transfer_Gamma,$Transfer_Regularization,$Transfer_Luminosity_Constraints,$Transfer_RGB_Resolution,$Transfer_Is_Constraints endif
 rm[-1]
 n[-1] 0,255

#################################################
##                                             ##
##             FIN samj_BoxFiter_Map           ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_test_Dither_Color            ##
##                                             ##
#################################################

#@gui Test Dither Color : samj_test_Dither_Color, samj_test_Dither_Color(1)
#@gui :_=note("samj_test_Dither_Color")
#@gui : Flou = int(2,0,10)
#@gui : Dilatation = int(0,0,10)
#@gui : Couleur Fond= color(230,230,150)
#@gui : Tolerance (%) = float(0,0,100)
#@gui : Smoothness (%) = float(0,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/08</i>.</small>")

samj_test_Dither_Color :

Flou_a=$1
Dilatation=$2
R_C=$3
V_C=$4
B_C=$5
Tolerance_C=$6
Smoothness_C=$7

 +Je_passe_l_hiver_en_Floride[-1]
 gradient_norm[-1]
 blur[-1] $Flou_a
 dilate_circ[-1] $Dilatation
 negative[-1]
 n[-1] 0,255
 ditheredbw[-1]
 #pixelize[-1] {w},{h},1
 to_rgb[-1]
 blend[-1,-2] add
 to_rgb[-1]
 n[-1] 0,255
 replace_color[-1] $Tolerance_C,$Smoothness_C,255,255,255,$R_C,$V_C,$B_C

#################################################
##                                             ##
##         FIN samj_test_Dither_Color          ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_CeKoaSa_011               ##
##                                             ##
#################################################

#@gui  CeKoaSa 011  : samj_CeKoaSa_011 , samj_CeKoaSa_011(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Masque</b></span>")
#@gui : Flou  = float(0.2,0,32)
#@gui : Ditheredbw = choice(0,"Non","A","B","C")
#@gui : Bump2Normal = bool(0)
#@gui : Orientation = choice(5,"A","B","C","D","E","F")
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Mélange Blend Image Origine</b></span>")
#@gui : Mélange = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Degrade</b></span>")
#@gui : Ajouter Degrade = bool(0)
#@gui : Type H / V = choice(0,"H","V")
#@gui : Swap Colors = bool(0)
#@gui : Starting Color A = color(240,40,160,255)
#@gui : Ending Color B = color(240,240,40,255)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><b>Niveaux Masque</b></span>")
#@gui : Valider Niveaux = bool(0)
#@gui : Valeur 1  = float(50,0,255)
#@gui : Valeur 2  = float(205,0,255)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2019/03/19</i>.</small>")

samj_CeKoaSa_011 :

 Larg={w}
 Haut={h}
 if $5==1
  +samj_Masque_CeKoaSa_011[-1] $1,$2,$3,$4
  blend[-1,-2] average,100,0
 else
  samj_Masque_CeKoaSa_011[-1] $1,$2,$3,$4
 endif
 if $17==1 c[-1] $18,$19 n[-1] 0,255 endif
 if $6==1
  to_rgba[-1]
  $Larg,$Haut,1,4
  samj_Linear_Gradient_CIE_Lab[-1] $7,$8,$9,$10,$11,$12,$13,$14,$15,$16
  blend[-1,-2] average,100,0
 endif

 samj_Masque_CeKoaSa_011 :

 gradient[-1]
 if $2==1 ditheredbw[-1] elif $2==2 ditheredbw[-2] elif $2==3 ditheredbw[-1,-2] endif
 append c
 blur $1
 if $4==0
  gradient_orientation 1
 elif $4==1
  gradient_orientation 2 rm[-1]
 elif $4==2
  gradient_orientation 3 rm[-1,-2]
 elif $4==3
  gradient_orientation 2 rm[-2]
 elif $4==4
  gradient_orientation 3 rm[-1,-2]
 elif $4==5
  orientation
 endif
 direction2rgb
 if $3==1 bump2normal endif
 n 0,255
 to_gray

#################################################
##                                             ##
##            FIN samj_CeKoaSa_011             ##
##                                             ##
#################################################
#################################################
##                                             ##
##              samj_CeKoaSa_010               ##
##                                             ##
#################################################

#@gui  CeKoaSa 010  : samj_CeKoaSa_010 , samj_CeKoaSa_010(1)
#@gui : Flou A = int(30,0,128)
#@gui : Flou B = int(10,0,128)
#@gui : Diff A = float(0.1,0.1,16)
#@gui : Diff B = float(2,0.1,16)
#@gui : Isop = int(10,2,16)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/11/18</i>.</small>")

samj_CeKoaSa_010  :

FlouA=$1
FlouB=$2
DiffA=$3
DiffB=$4
Isop=$5

 to_rgba[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 blur[-1] $FlouA
 blur[-2] $FlouB
 diffusiontensors[-1] 0,1,1,$DiffA,1
 diffusiontensors[-2] 0,1,1,$DiffB,1
 abs[-1,-2]
 n[-1,-2] 0,255
 transfer_colors[-1] [-3]
 transfer_colors[-2] [-3]
 blend[-1,-2] add
 c[-1] 0,255
 n[-1] 0,255
 isophotes[-1] $Isop
 blur[-2] {{{w}+{h}}/4}
 blend[-1,-2] alpha

#################################################
##                                             ##
##            FIN samj_CeKoaSa_010             ##
##                                             ##
#################################################
#################################################
##                                             ##
##                 CeKoaSa_005                 ##
##                                             ##
#################################################

## mélange avec une grille de couleurs aléatoires
# 20140423 blend
# 2014/07/03 modification gimp_blend
# 2015/05/31 Je_passe_l_hiver_en_Floride

#@gui CeKoaSa 005  : samj_CeKoaSa_005, samj_CeKoaSa_005(1)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Grille / Grid</small></span>")
#@gui : Grille / Grid X= int(16,2,100)
#@gui : Grille / Grid Y= int(16,2,100)
#@gui : Grille Carrée X = bool(0)
#@gui : Grille Carrée Y = bool(0)
#@gui :_=separator()
#@gui :_=note("<span foreground="orangered"><small>Couleurs / Colors</small></span>")
#@gui : Intensité = float(0.2,0,1)
#@gui : Mode = choice{1,"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacité / Opacity = float(1,0,1)
#@gui : Inverser calques / Revert layers = bool(0)
#@gui : Normaliser = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/11/24</i>.</small>")
samj_CeKoaSa_005 :

 Grille_X=$1
 Grille_Y=$2
 Grille_Carree_X=$3
 Grille_Carree_Y=$4
 Intensite=$5
 Mode_Melange=$6
 Opacity_Melange=$7
 Revert_layers_Melange=$8
 Normaliser=$9

 +Je_passe_l_hiver_en_Floride[-1]

 if $Grille_Carree_X==1
  Grille_Y=$Grille_X
 endif

 if $Grille_Carree_Y==1
  Grille_X=$Grille_Y
 endif

 rand[-1] 0,255
 imagegrid[-1,-2] $Grille_X,$Grille_Y
 +Je_passe_l_hiver_en_Floride[-1]
 blend[-1,-2] add,$Intensite,0 # hardmix
 gimp_blend_1651[-1,-2]  $Mode_Melange,0,$Opacity_Melange,$Revert_layers_Melange,1 # alpha

 if $Normaliser==1
  n[-1] 0,255
 endif

 to_colormode[-1] 4

#################################################
##                                             ##
##                FIN CeKoaSa_005              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  CeKoaSa_004                ##
##                                             ##
#################################################
## correspond à Noir_et_Blanc_004 + couleur avec effet
## version 2 modifications comparaisons >= à >
## 2015/05/31 Je_passe_l_hiver_en_Floride

#@gui CeKoaSa 004  : samj_CeKoaSa_004, samj_CeKoaSa_004(1)
#@gui : sep = separator()
#@gui : Modulo = int(30,0,130)
#@gui : Négatif = bool(0)
#@gui : Filtre B&W pencil = int(0,0,120)
#@gui : Opacité / Opacity = float(0.8,0.5,1)
#@gui : Filtre Denoise = int(0,0,20)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/11/24</i>.</small>")
samj_CeKoaSa_004 :

 Modulo=$1
 Negatif=$2
 B_W_pencil_amplitude=$3
 Opacity_blend_edges=$4
 Denoise_Image=$5

 to_rgb[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 mod[-1] {20+$Modulo}
 n[-1] 0,255
 fx_ditheredbw[-1] 0,1,0,0,0,0

 if $Negatif==1
  negate[-1]
 endif

 if $B_W_pencil_amplitude>0
   pencilbw[-1] 0.3,$B_W_pencil_amplitude
 endif

 fx_blend_edges[-1,-2] 1,$Opacity_blend_edges,0

 if $Denoise_Image>0
  denoise[-1] $Denoise_Image,$Denoise_Image,5,6,1,0
 endif

#################################################
##                                             ##
##               FIN CeKoaSa_004               ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  CeKoaSa_003                ##
##                                             ##
#################################################

## 2014/04/23 blend
## 2015/05/31 Je_passe_l_hiver_en_Floride

#@gui CeKoaSa 003  : samj_CeKoaSa_003, samj_CeKoaSa_003(1)
#@gui : sep = separator()
#@gui : Douceur / Smoothness = float(0,0,10)
#@gui : Seuil / Threshold = float(5,0,50)
#@gui : Déformation = float(1,0,6)
#@gui : Renforcer Couleurs / Boost = bool(1)
#@gui : Taille / Size = int(3,1,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/11/24</i>.</small>")
samj_CeKoaSa_003 :

 Smoothness_thin_edges=$1
 Threshold_thin_edges=$2
 Amplitude_ripple=$3
 Boost=$4
 Size_morpho=$5
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]

 fx_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
 +Je_passe_l_hiver_en_Floride[-1]

 ripple[-1] $Amplitude_ripple,20,2,0
 blend[-1,-2] average,1,1
 ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
 fx_edges[-2] 0,15,0,0
 blend[-1,-2] average,1,1
 if $Boost==1
  fx_balance_gamma[-1] 128,128,128,1
 endif
 ancien_gimp_morpho[-1] 0,$Size_morpho,0,2,0,1

 fx_normalize_local[-2] 2,6,5,20,1,3
 blend[-1,-2] softlight,1,0
 fx_LCE[-1] 80,0.5,1,1,3,0

 polygonize_GUI[-2] 10,10,10,10,10,0
 fx_gaussian_blur[-2] 20,0,0,1,0,0
 blend[-1,-2] average,0.5,1

#################################################
##                                             ##
##               FIN CeKoaSa_003               ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  CeKoaSa_002                ##
##                                             ##
#################################################

## origine 2013/12/29
## 2014/01/20  ajouts otsu et cadre noir et blanc pour supprimer mauvais effets de Polygonize
## 2014/04/23 blend
## 2015/05/31 Je_passe_l_hiver_en_Floride

#@gui CeKoaSa 002  : samj_CeKoaSa_002, samj_CeKoaSa_002(1)
#@gui : sep = separator()
#@gui : Douceur / Smoothness = float(0,0,10)
#@gui : Seuil / Threshold = float(15,0,50)
#@gui : Déformation = float(3,0,6)
#@gui : Renforcer Couleurs / Boost = bool(1)
#@gui : Taille / Size = int(3,1,10)
#@gui : Otsu = bool(1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/11/24</i>.</small>")
samj_CeKoaSa_002 :

 Smoothness_thin_edges=$1
 Threshold_thin_edges=$2
 Amplitude_ripple=$3
 Boost=$4
 Size_morpho=$5
 Valider_Otsu=$6

 to_rgba[-1]
 fx_frame[-1] 0,100,0,100,1,1,0,0,0,255,1,255,255,255,255

 if $Valider_Otsu==1
  otsu[-1] 4 n[-1] 0,255
 endif

 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]

 fx_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
 +Je_passe_l_hiver_en_Floride[-1]

 ripple[-1] $Amplitude_ripple,20,2,0
 blend[-1,-2] average,1,1
 ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
 fx_edges[-2] 0,15,0,0
 blend[-1,-2] average,1,1
 if $Boost==1
  fx_balance_gamma[-1] 128,128,128,1
 endif
 ancien_gimp_morpho[-1] 0,$Size_morpho,0,2,0,1

 fx_normalize_local[-2] 2,6,5,20,1,3
 blend[-1,-2] softlight,1,0
 polygonize_GUI[-1] 10,10,10,10,10,0
 fx_LCE[-1] 80,0.5,1,1,3,0

#################################################
##                                             ##
##               FIN CeKoaSa_002               ##
##                                             ##
#################################################
#################################################
##                                             ##
##                Polygonize                   ##
##                                             ##
#################################################

# origine 2013/12/04
# 2014/01/20 ajout test

#@gui Polygonize : polygonize_GUI, polygonize_GUI(0)
#@gui :_=separator()
#@gui :_=note("<small>Paramètres filtre Polygonize / Polygonize parameters</small>")
#@gui : Amplitude = int(300,0,2000)
#@gui : Douceur / Smoothness = float(10,0,100)
#@gui : Surface minimale / Minimal area = float(10,0,100)
#@gui : X-resolution = float(10,1,256)
#@gui : Y-resolution = float(10,1,256)
#@gui :_=separator()
#@gui :_=note("<small>Test</small>")
#@gui : Test Cadre et Otsu = int(0,0,256)
#@gui :_=separator()
#@gui :_=note("<small>Filtre créé par David Tschumperlé  Dernière mise à jour : <i>2020/11/24</i>.</small>")

polygonize_GUI :
 if $6>0 to_rgba fx_frame 0,100,0,100,1,1,0,0,0,255,1,255,255,255,255 otsu {$6+3} n 0,255 endif
 polygonize $1,$2,$3,$4,$5

#################################################
##                                             ##
##               FIN Polygonize                ##
##                                             ##
#################################################
#################################################
##                                             ##
##                  CeKoaSa_001                ##
##                                             ##
#################################################

# 2014/04/24 blend
# 2015/05/31 Je_passe_l_hiver_en_Floride

#@gui CeKoaSa 001  : samj_CeKoaSa_001, samj_CeKoaSa_001(1)
#@gui : sep = separator()
#@gui : Douceur / Smoothness = float(0,0,10)
#@gui : Seuil / Threshold = float(15,0,50)
#@gui : Déformation = float(3,0,6)
#@gui : Renforcer Couleurs / Boost = bool(1)
#@gui : Taille / Size = int(3,1,10)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2020/11/24</i>.</small>")
samj_CeKoaSa_001 :

 Smoothness_thin_edges=$1
 Threshold_thin_edges=$2
 Amplitude_ripple=$3
 Boost=$4
 Size_morpho=$5
 +Je_passe_l_hiver_en_Floride[-1]
 +Je_passe_l_hiver_en_Floride[-1]

 fx_thin_edges[-1] $Smoothness_thin_edges,$Threshold_thin_edges,0
 +Je_passe_l_hiver_en_Floride[-1]

 ripple[-1] $Amplitude_ripple,20,2,0
 blend[-1,-2] average,1,1
 ripple[-1] {1.2*{$Amplitude_ripple}},20,2,0
 fx_edges[-2] 0,15,0,0
 blend[-1,-2] average,1,1
 if $Boost==1
  fx_balance_gamma[-1] 128,128,128,1
 endif
 ancien_gimp_morpho[-1] 0,$Size_morpho,0,2,0,1

 fx_normalize_local[-2] 2,6,5,20,1,3
 blend[-1,-2] softlight,1,0
 fx_LCE[-1] 80,0.5,1,1,3,0

#################################################
##                                             ##
##               FIN CeKoaSa_001               ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_A               ##
##                                             ##
#################################################
#@gui Test A  : samj_test_A, samj_test_A(1)
#@gui :_=note("samj_test_A")
#@gui : A = int(64,0,255)
#@gui : B = int(192,0,255)
#@gui : C = int(500,0,10000)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/14</i>.</small>")

samj_test_A :

 or[-1] {$1} to_rgb[-1] and[-1] {$2} smooth[-1] $3 n[-1] 0,255 Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0

#################################################
##                                             ##
##                FIN samj_test_A              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_B               ##
##                                             ##
#################################################
#@gui Test B  : samj_test_B, gui_no_preview
#@gui :_=note("samj_test_B")
#@gui : A = int(100,10,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/15</i>.</small>")

samj_test_B :

 samj_Points_Aleatoires_001[-1] $1,255,255,0,255,3,1,1 +Je_passe_l_hiver_en_Floride[-1] fx_flower[-1] 30,6,100,0,50,50,1 to_rgb[-1] smooth[-1] 500 n[-1] 0,255 Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0 fx_boost_chroma[-1] 1,0,0

#################################################
##                                             ##
##                FIN samj_test_B              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_C               ##
##                                             ##
#################################################
#@gui Test C  : samj_test_C, gui_no_preview
#@gui :_=note("samj_test_C")
#@gui : A = int(100,10,200)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/16</i>.</small>")

samj_test_C :

 samj_Points_Aleatoires_001[-1] $1,255,255,0,255,3,1,1 +Je_passe_l_hiver_en_Floride[-1] fx_segment_watershed[-1] 8,0,0,0,0 fx_flower[-1] 10,20,0,360,50,50,1 Couleurs_Metalliques[-1] 0,0,22,0,0,0,0,6,5,20,1,0,0,0,0.3,60,1,1,0

#################################################
##                                             ##
##                FIN samj_test_C              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_D               ##
##                                             ##
#################################################

#@gui Test D  : samj_test_D, samj_test_D(1)
#@gui :_=note("samj_test_D")
#@gui : Var_sub = float(40,0,255)
#@gui : Var_n = float(255,0,255)
#@gui : Var_spread = float(10,0,60)
#@gui : Var_dilate = float(30,0,60)
#@gui : Var_blur = float(5,0,20)
#@gui : Déformation = float(0,0,5)
#@gui : sep = separator()
#@gui : Levels = int(8,1,256)
#@gui : Smoothness = float(0,0,5)
#@gui : Var_dilate_circ = float(4,0,60)
#@gui : sep = separator()
#@gui : Inner fading = float(0,0,100)
#@gui : Outer fading = float(25,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/19</i>.</small>")

samj_test_D :

 Var_sub=$1
 Var_n=$2
 Var_spread=$3
 Var_dilate=$4
 Var_blur=$5
 Deformation=$6

 Levels=$7
 Smoothness=$8
 Var_dilate_circ=$9

 Inner_fading=$10
 Outer_fading=$11

 +Je_passe_l_hiver_en_Floride[-1]
 if $Var_sub>0
  sub[-1] $Var_sub
  abs[-1]
 endif
 n[-1] 0,$Var_n
 if $Var_spread>0 spread[-1] $Var_spread endif
 if $Var_dilate>0 dilate[-1] $Var_dilate endif
 if $Var_blur>0 blur[-1] $Var_blur endif
 if $Deformation>0 deform[-1] $Deformation endif
 fx_isophotes[-2] $Levels,$Smoothness,0
 if $Var_dilate_circ>0 dilate_circ[-2] $Var_dilate_circ endif
 fx_blend_seamless[-2,-1] 0,$Inner_fading,$Outer_fading,0,0

#################################################
##                                             ##
##                FIN samj_test_D              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_E               ##
##                                             ##
#################################################
#@gui Test E  : samj_test_E, samj_test_E(1)
#@gui :_=note("samj_test_E")
#@gui :_=note("<span foreground="orangered"><small>Exemples</small></span>")
#@gui : Exemple = choice{"Non/No","A","B","C"}
#@gui :_=note("<span foreground="orangered"><small>diffusiontensors</small></span>")
#@gui : sharpness = float(0.7,0,2)
#@gui : anisotropy = float(0.3,0,1)
#@gui : alpha = float(0.6,0,10)
#@gui : sigma = float(1.1,0,10)
#@gui : is_sqrt = bool(0)
#@gui :_=note("<span foreground="orangered"><small>Blend</small></span>")
#@gui : Fond / Background Color = color(200,125,50)
#@gui : Mode = choice{"Add","Alpha","And","Average","Blue","Burn","Darken","Difference",
#@gui : "Divide","Dodge","Edges","Exclusion","Freeze","Grain extract","Grain merge","Green","Hard light",
#@gui : "Hard mix","Hue","Interpolation","Lighten","Lightness","Linear burn","Linear light","Luminance",
#@gui : "Multiply","Negation","Or","Overlay","Pin light","Red","Reflect","Saturation",
#@gui : "Shape Average","Shape Average0","Soft burn","Soft dodge","Soft light","Screen","Stamp","Subtract","Value",
#@gui : "Vivid light","Xor"}
#@gui : Opacity = float(1,0,1)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/19</i>.</small>")

samj_test_E :

 exemple=$1
 sharpness=$2
 anisotropy=$3
 alpha=$4
 sigma=$5
 is_sqrt=$6
 rf=$7
 vf=$8
 bf=$9
 Mode=$10
 Opacity=$11

 if $exemple==1
  anisotropy=0
  alpha=0
  sigma=0
 elif $exemple==2
  anisotropy=0
  alpha=4
  sigma=0
 elif $exemple==3
  sharpness=0.5
  anisotropy=0.3
  alpha=$4
  sigma={$sigma/10}
  is_sqrt=1
 endif

 diffusiontensors[-1] $sharpness,$anisotropy,$alpha,$sigma,$is_sqrt
 n[-1] 0,255
 equalize[-1]
 fx_decompose_channels[-1] 4,0,1,0
 remove[-1,-2]
 to_rgb[-1]
 fx_8bits[-1] 100,10000,256
 {w},{h},1,3
 fill_color[-1] $rf,$vf,$bf
 gimp_blend_1651[-1,-2] $Mode,0,$Opacity,0

#################################################
##                                             ##
##                FIN samj_test_E              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_F               ##
##                                             ##
#################################################
#@gui Test F  : samj_test_F, samj_test_F(1)
#@gui :_=note("samj_test_F")
#@gui :_=note("<span foreground="orangered"><small>Flou Effet Verre</small></span>")
#@gui : A = float(40,0.1,200)
#@gui : B = float(50,0.1,200)
#@gui : Itérations = int(1,1,8)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/04/20</i>.</small>")

samj_test_F :

 repeat $3
  fx_custom_deformation "cos(x*$1)*$2*sin(y)*(w+h)/10000","cos(y*$1)*$2*sin(x)*(w+h)/10000",1,1,1
 done

#################################################
##                                             ##
##                FIN samj_test_F              ##
##                                             ##
#################################################
#################################################
##                                             ##
##                   samj_test_G               ##
##                                             ##
#################################################

#### samj_test_G 3,7,0,30

#@gui Test G  : samj_test_G, samj_test_G(1)
#@gui :_=note("samj_test_G")
#@gui : A = int(0,0,20)
#@gui : B = float(0,0,10)
#@gui : C = float(0,0,1)
#@gui : D = int(30,0,100)
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2016/01/20</i>.</small>")

samj_test_G :

 fx_spread $1,$1,0,0,0
 fx_boost_fade[-1] $2,0
 +Je_passe_l_hiver_en_Floride[-1]
 fx_local_orientation[-1] $3,0,100,0,16,0
 fx_blend[-1,-2] 14,0,1,1,"0"
 fx_lightglow[-1] $4,0.5,8,0.8,0,0
#################################################
##                                             ##
##                FIN samj_test_G              ##
##                                             ##
#################################################
#################################################
##                                             ##
##           samj_test_tout_interactif         ##
##                                             ##
#################################################
#@gui Tout Interactif  : samj_test_tout_interactif, gui_no_preview
#@gui :_=note("Demo. Tout interactif")
#@gui :_=note("")
#@gui :_=note("2 filtres interactifs successifs : x_paint et threshold")
#@gui :_=note("x_paint : Choisir un pinceau, appliquer et fermer image")
#@gui :_=note("threshold : Appliquer la souris et fermer image")
#@gui :_=note("")
#@gui :_=note("2 successive interactive filters : x_paint et threshold")
#@gui :_=note("x_paint : Choose a brush, apply and close picture")
#@gui :_=note("threshold : Move the mouse and close picture")
#@gui :_=note("")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/03</i>.</small>")
samj_test_tout_interactif :

 x_paint[-1]
 threshold[-1]
 n[-1] 0,255

#################################################
##                                             ##
##         FIN samj_test_tout_interactif       ##
##                                             ##
#################################################


#################################################
##                                             ##
##            samj_test_x_color_curves         ##
##                                             ##
#################################################
#@gui Test Courbes  : samj_test_x_color_curves, samj_test_x_color_curves(0)
#@gui :_=note("Demo. samj_test_x_color_curves")
#@gui :_=note("")
#@gui : Utiliser = choice(1,"x_color_curves","gimp_curves_interactive")
#@gui : Appliquer courbes = choice("Aucun","Appliquer le Dernier","RGB","CMY","CMYK","HSI","HSL","HSV","Lab","Lch","YCbCr")
#@gui :_=separator()
#@gui :_=note("<small>samj - Dernière mise à jour : <i>2015/03/04</i>.</small>")
samj_test_x_color_curves :

 Utiliser=$1
 Appliquer_courbes=$2

 if $Utiliser==0
  # Fonctionne uniquement sur des copies d'images (pas sur des images jpg, tif, xcf, etc.)
  if $Appliquer_courbes==0
   blur[-1] 5
  elif $Appliquer_courbes==1 #last
   x_color_curves[-1] last
  elif $Appliquer_courbes==2 #rgb
   x_color_curves[-1] rgb
  elif $Appliquer_courbes==3 #cmy
   x_color_curves[-1] cmy
  elif $Appliquer_courbes==4 #cmyk
   x_color_curves[-1] cmyk
  elif $Appliquer_courbes==5 #hsi
   x_color_curves[-1] hsi
  elif $Appliquer_courbes==6 #hsl
   x_color_curves[-1] hsl
  elif $Appliquer_courbes==7 #hsv
   x_color_curves[-1] hsv
  elif $Appliquer_courbes==8 #lab
   x_color_curves[-1] lab
  elif $Appliquer_courbes==9 #lch
   x_color_curves[-1] lch
  elif $Appliquer_courbes==10 #ycbcr
   x_color_curves[-1] ycbcr
  endif
 else
  if $Appliquer_courbes==0
   blur[-1] 5
  elif $Appliquer_courbes==1 #last
   deform[-1] 20
  elif $Appliquer_courbes==2 #rgb
   fx_curves_interactive[-1] 0,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==3 #cmy
   fx_curves_interactive[-1] 1,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==4 #cmyk erreur
   fx_curves_interactive[-1] 2,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==5 #hsi
   fx_curves_interactive[-1] 3,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==6 #hsl
   fx_curves_interactive[-1] 4,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==7 #hsv
   fx_curves_interactive[-1] 5,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==8 #lab
   fx_curves_interactive[-1] 6,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==9 #lch
   fx_curves_interactive[-1] 7,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  elif $Appliquer_courbes==10 #ycbcr
   fx_curves_interactive[-1] 8,0,0,0,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100,-1,0,0,100,100
  endif
 endif
#################################################
##                                             ##
##         FIN samj_test_x_color_curves        ##
##                                             ##
#################################################
################################################################
##                                                            ##
##            Recolorize version 2013 01 15 modifiée          ##
##                                                            ##
################################################################

# Merci à David Tschumperlé pour ce superbe filtre :o)
# présentation du filtre http://www.flickr.com/groups/gmic/discuss/72157632525934815/
#
# modification texte de présentation, ajout nuances niveaux de gris et normalize, ajour dégoulinage, ajout commentaires
#@gui Recolorize 20130115 : gimp_recolorize_20130115_modifie, gimp_recolorize_20130115_modifie(1)
#@gui :_=link("http://www.flickr.com/groups/gmic/discuss/72157632525934815/","http://www.flickr.com/groups/gmic/discuss/72157632525934815/")
#@gui :_=link("http://www.gimpchat.com/viewtopic.php?f=28&t=6207&start=0","http://www.gimpchat.com/viewtopic.php?f=28&t=6207&start=0")
#@gui : Douceur / Smoothness = float(30,0,200)
#@gui : Nuances/decompose  = choice(0,"Origine","Canal Y de YUV","Canal L de HSL 8","Canal L de LCH","Canal K de CMYK")
#@gui : Étendue / Normalize A = int(0,0,255)
#@gui : Étendue / Normalize B = int(255,0,255)
#@gui : Dégoulinade A / Extension Colors A = int(0,0,20)
#@gui : Dégoulinade B / Extension Colors B = float(0,0,10)
#@gui : Précision = bool(1)
#@gui : sep = separator()
#@gui : note = note{"<b>Note :</b> This filter needs two layers to work properly. The bottom layer can be a B&W or a colored image, while the
#@gui : top layer contains color patches that will be extrapolated in a smart way (edge-directed) to fill the entire image. At the end,
#@gui : you get a completely recolored image."}
#@gui :_=separator()
#@gui :_=note("<small>Auteur / Author : <i>David Tschumperlé</i>.      Dernière mise à jour: <i>2013/01/18 samj</i>.</small>")
gimp_recolorize_20130115_modifie :

Smoothness=$1
Nuances=$2
Normalize_A=$3
Normalize_B=$4
Degoulinade_A=$5
Degoulinade_B=$6
Precision=$7

    rv[-2,-1] # inverser les calques

 dilate_circ[-1] $Degoulinade_A # agrandir

 if $Nuances==0
  channels[-2] 0 # Convert to pure gray.
 elif $Nuances==1
  fx_decompose_channels[-2] 4,0,1,0 remove[-2,-3] ## modif samj pour obtenir des nuances différentes à partir d'une image couleurs >> Canal Y de YUV
 elif $Nuances==2
  to_rgb[-2] rgb2hsl8[-2] split[-2] c rm[-3,-4]  ## idem >> Canal L de HSL
 elif $Nuances==3
  to_rgb[-2] rgb2lab8[-2] split[-2] c rm[-2,-3]  ## idem >> Canal L de LCH
 elif $Nuances==4
  to_rgb[-2] rgb2cmyk[-2] split[-2] c rm[-3,-4,-5] negate[-2]  ## idem >> Canal K inversé de CMYK
 endif

 to_rgb[-2] to_rgba[-1] # conversion modes

 n[-2] $Normalize_A,$Normalize_B

 split_opacity[-1] # création d'une nouvelle image où les couleurs deviennent blanches.

 neq[-1] 0  # Retrieve mask of color patchs. La 3 image est un masque de 2 couleurs où l'espace occupé par les couleurs d'origine est un peu plus grand.
 # il y a 3 images : -3=l'image grise  -2=les couleurs  -1=le masque

    srgb2rgb[-3,-2] # conversion modes
 rgb2lab8[-3,-2] # conversion modes
 channels[-3] 0  # on garde un seul canal, image -3 devient grise
 channels[-2] 1,2 # Now, list is [0]=lightness / [1]=chroma / [2]=mask.

    +[-2] 1 #  ? (dans Gimp, utiliser mode différence et courbes pour voir l'effet)

 *[-2] [-1] # mélange *

 +gradient_norm[-3] # création d'une 4 image qui est contours de image 3

 blur[-1] $Degoulinade_B # flou

 *[-1] -1 # image 4 négative

 watershed[-3] [-1] # image 2 (chroma) se remplit de couleurs (les couleurs s'étendent aux limites définies par l'image 4)

 rm[-1] # supprimer image 4 des contours

 --[-2] 1 # enlever les traits ? (dans Gimp, utiliser mode différence et courbes pour voir l'effet)
 # Get first estimate for the color interpolation.

 if $Precision==1
  ### permet de bien définir les contours
   +diffusiontensors[-3] 0,1,1,1 # création d'une image diffusion tensors 4 à partir de l'image grise 1

   eq[-2] 0 # masque = fond blanc, traits de couleurs noirs sur console

   *[-1] [-2] # mélange masque et diffusion tensors

   rm[-2] # supprimer masque

   smooth[-2] [-1],$Smoothness,0.8,45,2,0 # adoucir image 2 (chroma)
  ### FIN permet de bien définir les contours
 endif

 rm[-1] # supprimer diffusion tensors

    a[-2,-1] c # append c

 lab82rgb[-1] # conversion modes

 rgb2srgb[-1] # conversion modes
################################################################
##                                                            ##
##        FIN  Recolorize version 2013 01 15 modifiée         ##
##                                                            ##
################################################################
#################################################################################################################################################################################################
#
#                                                                                                                                                                               FIN Testing  Samj
#
#################################################################################################################################################################################################


#@gui _
#@gui _
#@gui _



#################################################################################################################################################################################################
#
#                                                                                                                                                                         DOSSIER Testing Lylejk
#
#################################################################################################################################################################################################
#@gmic
#@gui _<b>Testing</b>
#@gui <i>Lylejk</i>
#################################################
##                                             ##
##             Lylejk_Luma_Invert              ##
##                                             ##
#################################################

#@gui Lylejk Luma Invert  : Lylejk_Luma_Invert , Lylejk_Luma_Invert_preview(0)
#@gui :_=note("<span foreground="orangered"><b><u>Pow</u></b></span>")
#@gui : Value = float(1,0.5,4)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>samj</i>.      Latest update: <i>2018/05/03</i>.</small>")

Lylejk_Luma_Invert :

 fx_decompose_channels[-1] 5,0,1,0
 negate[-3]
 if $1==1
  fx_decompose_channels[-1,-2,-3] 5,1,1,0
 else
  pow[-3] $1
  n[-3] 0,255
  fx_decompose_channels[-1,-2,-3] 5,1,1,0
 endif

Lylejk_Luma_Invert_preview :
 gui_split_preview "Lylejk_Luma_Invert $*",$-1

#################################################
##                                             ##
##           FIN Lylejk_Luma_Invert            ##
##                                             ##
#################################################


#################################################
##                                             ##
##                Lylejk_Woven                 ##
##                                             ##
#################################################

#@gui Lylejk Woven  : Lylejk_Woven , Lylejk_Woven_preview(0)
#@gui :_=link("http://gimpchat.com/viewtopic.php?f=11&t=16384&start=10#p226895","http://gimpchat.com/viewtopic.php?f=11&t=16384&start=10#p226895")
#@gui :_=note("<span foreground="orangered"><b><u>Ripple 1</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui :_=note("<span foreground="orangered"><b><u>Ripple 2</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui :_=note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(12,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border opacity = float(1,0,1)
#@gui : Border color = color(0,0,0,255)
#@gui :_=note("<span foreground="orangered"><b><u>Ripple 3</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui :_=note("<span foreground="orangered"><b><u>Ripple 4</u></b></span>")
#@gui : Amplitude = float(19.6,-100,100)
#@gui : Bandwidth = float(32.4,1,300)
#@gui : Shape = choice(1,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.61,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.29,0,1.5)
#@gui : Min threshold = float(37.2,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui : sep = separator()
#@gui :_=note("<span foreground="orangered"><b><u>Options Start With ...</u></b></span>")
#@gui : Start With Blur = bool(0)
#@gui : Blur = float(2,0,20)
#@gui : Start With Quantize = bool(0)
#@gui : Quantize Levels = int(16,2,256)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>Lyle Kroll</i>.      Latest update: <i>2018/04/22</i>.</small>")

Lylejk_Woven :

 if $48==1 quantize $49,1,1 endif
 if $46 blur $47 endif

 ripple $1,$2,$3,$4,$5
 ripple $6,$7,$8,$9,$10
 fx_superpixels $11,$12,$13,$14,$15,$16,$17,$18,$19
 mirror x
 ripple $20,$21,$22,$23,$24
 mirror x
 mirror x
 ripple $25,$26,$27,$28,$29
 mirror x

 #Fake Smudge
 repeat $40
  smooth $30,$31,$32,$33,$34,$35,$36,$37,$38,$39
 done

 #Gradient Norm
 blur $41
 gradient_norm ^ $42
 cut $43%,$44%
 if $45
  negate
 endif
 normalize 0,255

Lylejk_Woven_preview :
 gui_split_preview "Lylejk_Woven $*",$-1

#################################################
##                                             ##
##              FIN Lylejk_Woven               ##
##                                             ##
#################################################
#################################################
##                                             ##
##                Lylejk_Ribbon                ##
##                                             ##
#################################################

#@gui Lylejk Ribbon : Lylejk_Ribbon, Lylejk_Ribbon_preview(0)
#@gui :_=link("http://gimpchat.com/viewtopic.php?f=11&t=16390","http://gimpchat.com/viewtopic.php?f=11&t=16390")
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(2,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Diffusion tensors</u></b></span>")
#@gui : Resolution (%) = float(16,0,20)
#@gui : Size = float(3.44,0,16)
#@gui : Color mode = choice(0,"Monochrome","Grayscale","Orientation","Color")
#@gui : Outline = int(3,0,16)
#@gui : Sharpness = float(0.79,0,1)
#@gui : Anisotropy = float(0.72,0,1)
#@gui : Gradient smoothness = float(4.97,0,10)
#@gui : Tensor smoothness = float(1.70,0,10)
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(2,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 3</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.32,0,1.5)
#@gui : Min threshold = float(43.1,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Upscale [dcci2x] by Garagecoder</u></b></span>")
#@gui : Upscale = choice(2,"No","Yes","Yes and No")
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(1)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i> Lylejk - samj</i>.      Latest update: <i>2020/10/24</i>.</small>")

Lylejk_Ribbon:

 Largeur_Origine={w}
 Hauteur_Origine={h}

 if $36==1||$36==2
  #Upscale [dcci2x] by Garagecoder
  split_opacity
  scale_dcci2x ${37-39}
  append c
  cut 0,255
 endif

 #Fake Smudge
 repeat $11
  smooth $1,$2,$3,$4,$5,$6,$7,$8,$9,$10
 done

 fx_diffusiontensors $12,$13,$14,$15,$16,$17,$18,$19

 #Fake Smudge
 repeat $30
  smooth $20,$21,$22,$23,$24,$25,$26,$27,$28,$29
 done

 #Gradient Norm 1
 blur $31
 gradient_norm ^ $32
 cut $33%,$34%
 if $35
  negate
 endif
 normalize 0,255

 if $36==2
  resize $Largeur_Origine,$Hauteur_Origine
  c 0,255
 endif

Lylejk_Ribbon_preview :
 gui_split_preview "Lylejk_Ribbon $*",$-1

#################################################
##                                             ##
##              FIN Lylejk_Ribbon              ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Lylejk_Ripple                 ##
##    GUI RIPPLE avec des valeurs négatives    ##
##                                             ##
#################################################

#@gui Lylejk Ripple : ripple, ripple(0)
#@gui : Amplitude = float(10,-100,100)
#@gui : Bandwidth = float(20,1,300)
#@gui : Shape = choice(2,"Bloc","Triangle","Sine","Sine+","Random")
#@gui : Angle = float(0,-360,360)
#@gui : Offset = float(0,-500,500)
#@gui :_=separator()
#@gui :_=note("<small>Author: <i><a href="https://goo.gl/Ryf7Cv">David Tschumperlé</a></i>.      Latest update: <i>2011/23/08</i>.</small>")


#################################################
##                                             ##
##               Lylejk_Wicker_2               ##
##                                             ##
#################################################

#@gui Lylejk_Wicker_2  : Lylejk_Wicker_2 , Lylejk_Wicker_2_preview(0)
#@gui :_=link("https://github.com/dtschump/gmic-community/blob/master/tutorial/wicker_tut.pdf","https://github.com/dtschump/gmic-community/blob/master/tutorial/wicker_tut.pdf")
#@gui :_=note("<small>Applying the tutorial from page 1 to 8</small>")
#@gui : sep = separator()
#@gui :_=note("<span foreground="orangered"><b><u>Offset</u></b></span>")
#@gui : X (%) = float(50,0,100)
#@gui : Y (%) = float(50,0,100)
#@gui : Offset = choice(1,"No","Yes")
#@gui :_=note("<span foreground="orangered"><b><u>Euclidean - Polar</u></b></span>")
#@gui : X-center (%) = float(50,0,100)
#@gui : Y-center (%) = float(50,0,100)
#@gui : Stretch factor = float(1,0.1,10)
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui :_=note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(12,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border opacity = float(1,0,1)
#@gui : Border color = color(0,0,0,255)
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.54,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(3,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.29,0,1.5)
#@gui : Min threshold = float(28.7,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui :_=note("<b><u>Improve Contrast</u></b>")
#@gui : Apply a contrast = choice(0,"No","Sharpen Deblur","Improve Contrast By Lyle Kroll")
#@gui : sep = separator()
#@gui :_=note("<span foreground="blue"><b><u>Sharpen Deblur</u></b></span>")
#@gui : Radius = float(1,0,20)
#@gui : Iterations = int(10,0,100)
#@gui : Time step = float(20,0,50)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Regularization = choice(1,"Tikhonov","Mean curvature","Total variation")
#@gui : sep = separator()
#@gui :_=note("<span foreground="blue"><b>Improve Contrast By Lyle Kroll</u></span>")
#@gui :_=note("<span foreground="orangered"><b><u>Smooth Bilateral Contrast</u></b></span>")
#@gui : Spatial variance = float(10,0,100)
#@gui : Value variance = float(12,0,100)
#@gui : Iterations = int(2,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge Contrast</u></b></span>")
#@gui : Amplitude = float(40,0,1000)
#@gui : Sharpness = float(0.7,0,2)
#@gui : Anisotropy = float(0.3,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(1.1,0,10)
#@gui : Spatial precision = float(0.8,0.1,2)
#@gui : Angular precision = float(30,1,180)
#@gui : Value precision = float(2,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(3,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Grain Merge Contrast</u></b></span>")
#@gui : Amplitude = float(1,0,1)
#@gui : sep = separator()
#@gui : sep = separator()
#@gui :_=note("<b><u>Option Start With Quantize</u></b>")
#@gui : Quantize = choice(0,"No","Yes")
#@gui : Levels = int(16,2,256)
#@gui :_=note("<b><u>Option Euclidian To Polar</u></b>")
#@gui : Euclidian To Polar = choice(1,"No","Yes")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>Lyle Kroll</i>.      Latest update: <i>2018/04/07</i>.</small>")

Lylejk_Wicker_2 :

 if $33==2 i [-1] i [-1] endif

 if $54==1 quantize[-1] $55,1,1 endif

 if $3==1
  shift[-1] $1%,$2%,0,0,2,1
  if $56==1 if !$7 to_a[-1] fi euclidean2polar[-1] $4%,$5%,$6,$7 endif
  fx_superpixels[-1] $8,$9,$10,$11,$12,$13,$14,$15,$16
 endif

 if $3==0
  if $56==1 if !$7 to_a[-1] fi euclidean2polar[-1] $4%,$5%,$6,$7 endif
  fx_superpixels[-1] $8,$9,$10,$11,$12,$13,$14,$15,$16
 endif

 if $56==1 if !$7 to_a[-1] fi polar2euclidean[-1] $4%,$5%,$6,$7 endif

 if $3==1 shift[-1] {-$1}%,{-$2}%,0,0,2,1 endif

 #Fake Smudge
 repeat $27
  smooth[-1] $17,$18,$19,$20,$21,$22,$23,$24,$25,$26
 done

 #Gradient Norm
 blur[-1] $28
 gradient_norm[-1] ^[-1] $29
 cut[-1] $30%,$31%
 if $32
  negate[-1]
 endif
 normalize[-1] 0,255

 if $33==1
  deblur[-1] ${34-38} c[-1] 0,255
 elif $33==2
  repeat $41 bilateral[-2] $39,$40 done
  blend[-2,-3] grainextract
  #Fake Smudge
  repeat $52
   smooth[-2] $42,$43,$44,$45,$46,$47,$48,$49,$50,$51
  done
  blend[-1,-2]  grainmerge,$53,1
 endif
Lylejk_Wicker_2_preview :
  gui_split_preview "Lylejk_Wicker_2 $*",$-1

#################################################
##                                             ##
##             END Lylejk_Wicker_2             ##
##                                             ##
#################################################
#################################################
##                                             ##
##           Lylejk_Quantize_Wicker            ##
##                                             ##
#################################################

#@gui Lylejk Quantize Wicker  : Lylejk_Quantize_Wicker , Lylejk_Quantize_Wicker_preview(0)
#@gui :_=note("<span foreground="orangered"><b><u>Quantize</u></b></span>")
#@gui : Levels = int(16,2,256)
#@gui :_=note("<span foreground="orangered"><b><u>Offset</u></b></span>")
#@gui : X (%) = float(50,0,100)
#@gui : Y (%) = float(50,0,100)
#@gui : Offset = choice(0,"No","Yes")
#@gui :_=note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(16,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border opacity = float(1,0,1)
#@gui : Border color = color(0,0,0,255)
#@gui :_=note("<span foreground="orangered"><b><u>Dilate</u></b></span>")
#@gui : Dilatation = int(1,1,16)
#@gui :_=note("<span foreground="orangered"><b><u>Lylejk_Wicker Rodilius</u></b></span>")
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(153,0,1000)
#@gui :_=note("<span foreground="orangered"><b><u>Sharpen Deblur</u></b></span>")
#@gui : Sharpen Deblur = bool(0)
#@gui : Radius = float(2,0,20)
#@gui : Iterations = int(10,0,100)
#@gui : Time step = float(20,0,50)
#@gui : Smoothness = float(0.1,0,10)
#@gui : Regularization = choice(1,"Tikhonov","Mean curvature","Total variation")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i> Lylejk - samj</i>.      Latest update: <i>2018/04/06</i>.</small>")

Lylejk_Quantize_Wicker :
 quantize $1,1,1

 if $4==1 shift $2%,$3%,0,0,2,1 endif

 fx_superpixels $5,$6,$7,$8,$9,$10,$11,$12,$13

 dilate $14

 if $4==1 shift {-$2}%,{-$3}%,0,0,2,1 endif

 resize {{w}/2},{{h}/2}
 c 0,255

 Lylejk_Wicker $15,$16,$17,150,0.42,0.85,0.6,7.83,0.68,19,2.64,0,1,1,0,0.5,10.5,100,0,0,0.5,10.5,100,0,1.15,5,1,0.68,0.5,10.5,100,0,1,1,10,1,0,0

 if $18==1 deblur ${19-23} c 0,255 endif

Lylejk_Quantize_Wicker_preview :
 gui_split_preview "Lylejk_Quantize_Wicker $*",$-1

#################################################
##                                             ##
##         FIN Lylejk_Quantize_Wicker          ##
##                                             ##
#################################################
#################################################
##                                             ##
##              lylejk_test_TRW                ##
##                                             ##
#################################################

#@gui Lylejk Test TRW  : lylejk_test_TRW , lylejk_test_TRW_preview(0)
#@gui :_=note("<span foreground="orangered"><b><u>Offset</u></b></span>")
#@gui : X (%) = float(50,0,100)
#@gui : Y (%) = float(50,0,100)
#@gui : Offset = choice(1,"A","B")
#@gui :_=note("<span foreground="orangered"><b><u>Superpixels</u></b></span>")
#@gui : Size = int(16,4,64)
#@gui : Regularity = float(10,0,128)
#@gui : Iterations = int(5,1,16)
#@gui : Colors = choice(1,"Random","Average")
#@gui : Border opacity = float(1,0,1)
#@gui : Border color = color(0,0,0,255)
#@gui :_=note("<span foreground="orangered"><b><u>Euclidean - Polar</u></b></span>")
#@gui : X-center (%) = float(50,0,100)
#@gui : Y-center (%) = float(50,0,100)
#@gui : Stretch factor = float(1,0.1,10)
#@gui : Boundary = choice(1,"Transparent","Nearest","Periodic","Mirror")
#@gui :_=note("<span foreground="blue"><b><u>Lylejk_Wicker</u></b></span>")
#@gui :_=note("<span foreground="orangered"><b><u>Rodilius</u></b></span>")
#@gui : Amplitude = float(1.8,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(153,0,1000)
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 1</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(10.5,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 2</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(10.5,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Upscale [dcci2x] by Garagecoder</u></b></span>")
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(1)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 3</u></b></span>")
#@gui : Smoothness = float(0.68,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(10.5,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Option Lylejk stencil</u></b></span>")
#@gui : Apply lylejk stencil = bool(0)
#@gui : Amplitude = int(1,1,10)
#@gui : Sharpness = float(10,0,100)
#@gui : Radius = float(1,0,10)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i>Lyle Kroll - samj</i>.      Latest update: <i>2018/04/06</i>.</small>")

lylejk_test_TRW :

 if $3==0 shift $1%,$2%,0,0,2,1 endif

 fx_superpixels $4,$5,$6,$7,$8,$9,$10,$11,$12

 if $3==1 shift $1%,$2%,0,0,2,1 endif

 if !$16 to_a fi
 euclidean2polar $13%,$14%,$15,$16

 fx_superpixels $4,$5,$6,$7,$8,$9,$10,$11,$12

 if !$16 to_a fi
 polar2euclidean $13%,$14%,$15,$16
 shift {-$1}%,{-$2}%,0,0,2,1

 resize {{w}/2},{{h}/2}
 c 0,255

 Lylejk_Wicker $17,$18,$19,$20,$21,$22,$23,$24,$25,$26,$27,$28,$29,$30,$31,$32,$33,$34,$35,$36,$37,$38,$39,$40,$41,$42,$43,$44,$45,$46,$47,$48,$49,$50,$51,$52,$53

lylejk_test_TRW_preview :
 gui_split_preview "lylejk_test_TRW $*",$-1

#################################################
##                                             ##
##           FIN lylejk_test_TRW               ##
##                                             ##
#################################################
#################################################
##                                             ##
##   garagecoder_lylejk_samj_points_outlines   ##
##                                             ##
#################################################

#@gui Point Star Outline  : garagecoder_lylejk_samj_points_outlines , garagecoder_lylejk_samj_points_outlines_preview(0)
#@gui :_=link("https://discuss.pixls.us/t/place-some-points-on-outlines-with-gmic/7006/5","https://discuss.pixls.us/t/place-some-points-on-outlines-with-gmic/7006/5")
#@gui :_=note("<span foreground="orangered"><b><u>Choice Filter</u></b></span>")
#@gui : Choice Filter = choice(0,"Garagecoder Staroutline","Garagecoder Pointoutline","samj")
#@gui :_=note("<span foreground="orangered"><b><u>Garagecoder Staroutline</u></b></span>")
#@gui : Less Than Staroutline = float(0.05,0,0.5)
#@gui : Shapecloud = int(10,3,20)
#@gui :_=note("<span foreground="orangered"><b><u>Garagecoder Pointoutline</u></b></span>")
#@gui : Less Than Pointoutline = float(0.12,0,0.5)
#@gui :_=note("<span foreground="orangered"><b><u>samj</u></b></span>")
#@gui : Determination_Contours = int(0,0,2)
#@gui : Type_Rendu = int(0,0,2)
#@gui : Dilatation = int(2,0,10)
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Authors: <i>Garagecoder - Lyle Kroll - samj</i>.      Latest update: <i>2018/04/04</i>.</small>")

garagecoder_lylejk_samj_points_outlines :
 Choice_Filter=$1
 Less_Than_Staroutline=$2
 Shapecloud_Staroutline=$3
 Less_Than_Pointoutline=$4
 Determination_Contours=$5
 Type_Rendu=$6
 Dilatation={2+$7}

if $Choice_Filter==0 # Staroutline By Garagecoder
 normalize[-1] 0,255
 blur[-1] 2
 isophotes[-1] 6
 100%,100%,1,1
 noise[-1] 0.5,1
 lt[-1] {$Less_Than_Staroutline-0.5}
 mul[-1,-2]
 shape_star ,
 garagecoder_example_shapecloud[-2] [-1],$Shapecloud_Staroutline
 rm[-1]
elif $Choice_Filter==1 # Pointoutline By Garagecoder
 normalize[-1] 0,255
 blur[-1] 2
 isophotes[-1] 6
 100%,100%,1,1
 noise[-1] 0.5,1
 lt. {$Less_Than_Pointoutline-0.5}
 mul[-1,-2]
 _circle 5
 dilate[-2] [-1]
 rm.
elif $Choice_Filter==2 # By samj
 if $Determination_Contours==0
  blur[-1] 2
  isophotes[-1] 6
 elif $Determination_Contours==1
  n[-1] 128,255
  to_pseudogray[-1] 5,1,8
  blur[-1] 2
  isophotes[-1] 6
 elif $Determination_Contours==2
  tones[-1] 3
  isophotes[-1,-2]  3
  blend[-1,-2] alpha
  blend[-1,-2] alpha
  mul[-1] 255
  isophotes[-1] 3
 endif

 {w},{h},1,4
 repeat (w+h)/1.5 # delete points
  line[-2] 50%,50%,{u(100)}%,{u(100)}%,1,0,0,0,0
 done
 repeat (w+h)/2  # points on outlines
  line[-1] {u(100)}%,{u(100)}%,{u(100)}%,{u(100)}%,1,255,255,255,255
 done
 repeat (w+h)/5  # points outside the outlines
  point {u(100)}%,{u(100)}%,0,1,255,255,255,255
 done
 and[-1,-2]
 if $Type_Rendu==0
  dilate_circ[-1] $Dilatation
 elif $Type_Rendu==1
  i [-1]
  i [-1]
  dilate_circ[-3] $Dilatation
  dilate[-2] 6,1
  dilate[-1] 1,6
  blend[-1,-2,-3] alpha
 elif $Type_Rendu==2
  dilate_circ[-1] $Dilatation
  sponge[-1] 5
 endif
endif

garagecoder_lylejk_samj_points_outlines_preview :
 gui_split_preview "garagecoder_lylejk_samj_points_outlines $*",$-1
# By Garagecoder
garagecoder_example_shapecloud : check ${"is_image_arg $1"}" && isnum(${2=9})"
  repeat $! pass$1 0 l[$>,-1]
    kw={$2+1-$2%2} r. $kw,$kw,1,1,5 n. 0,1
    +gt[0,1] 0 convolve[-2] [-1] rm.
    convolve[0] [1] rm[1] +eq. 0 +[-2,-1] /
  endl done
#################################################
##                                             ##
## END garagecoder_lylejk_samj_points_outlines ##
##                                             ##
#################################################
#################################################
##                                             ##
##               Lylejk_Wicker                 ##
##                                             ##
#################################################

#@gui Lylejk Wicker  : Lylejk_Wicker , Lylejk_Wicker_preview(0)
#@gui :_=link("https://github.com/dtschump/gmic-community/blob/master/tutorial/WickerTute.pdf","https://github.com/dtschump/gmic-community/blob/master/tutorial/WickerTute.pdf")
#@gui :_=note("<span foreground="orangered"><b><u>Rodilius</u></b></span>")
#@gui : Amplitude = float(10,0,30)
#@gui : Thickness = float(10,0,100)
#@gui : Sharpness = float(153,0,1000)
#@gui :_=note("<span foreground="orangered"><b><u>Fake Smudge</u></b></span>")
#@gui : Amplitude = float(150,0,1000)
#@gui : Sharpness = float(0.42,0,2)
#@gui : Anisotropy = float(0.85,0,1)
#@gui : Gradient smoothness = float(0.6,0,10)
#@gui : Tensor smoothness = float(7.83,0,10)
#@gui : Spatial precision = float(0.68,0.1,2)
#@gui : Angular precision = float(19,1,180)
#@gui : Value precision = float(2.64,0.1,5)
#@gui : Interpolation = choice(0,"Nearest neighbor","Linear","Runge-Kutta")
#@gui : Fast approximation = bool(1)
#@gui : Iterations = int(1,1,10)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 1</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(10.5,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 2</u></b></span>")
#@gui : Smoothness = float(0,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(10.5,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Upscale [dcci2x] by Garagecoder</u></b></span>")
#@gui : Threshold = float(1.15,1,2)
#@gui : Exponent = int(5,1,6)
#@gui : Extend 1px = _bool(1)
#@gui :_=note("<span foreground="orangered"><b><u>Gradient Norm 3</u></b></span>")
#@gui : Smoothness = float(0.68,0,10)
#@gui : Linearity = float(0.5,0,1.5)
#@gui : Min threshold = float(10.5,0,100)
#@gui : Max threshold = float(100,0,100)
#@gui : Negative colors = bool(0)
#@gui :_=note("<span foreground="orangered"><b><u>Option Lylejk stencil</u></b></span>")
#@gui : Apply Lylejk stencil = bool(0)
#@gui : Amplitude = int(1,1,10)
#@gui : Sharpness = float(10,0,100)
#@gui : Radius = float(1,0,10)
#@gui : Channel(s) = choice(0,"All","RGBA","RGB","Luminance","Blue/red chrominances","Blue chrominance","Red chrominance","Lightness","ab-components","a-component","b-component","Hue","Saturation","Value","Key","Alpha","ch-components","c-component","h-component","Red","Green","Blue","Alpha")
#@gui : sep = separator(), Preview type = choice("Full","Forward horizontal","Forward vertical","Backward horizontal","Backward vertical","Duplicate top","Duplicate left","Duplicate bottom","Duplicate right","Duplicate horizontal","Duplicate vertical","Checkered","Checkered inverse")
#@gui :_=separator()
#@gui :_=note("<small>Author: <i>Lyle Kroll</i>.      Latest update: <i>2018/04/03</i>.</small>")

Lylejk_Wicker : skip ${33=0},${34=1},${35=10},${36=1},${37=0}

 # Option Lylejk stencil
 if $33
  apply_channels "repeat $34 b $36 unsharp $36,$35 c 0,255 mv[-1] 0 done",$37,0
 endif

 #Rodilius
 rodilius $1,$2,$3,5,30,1
 smooth 10,0,1,1,1,0.8,45
 sharpen 30
 cut 0,255

 #Fake Smudge
 repeat $14
  smooth $4,$5,$6,$7,$8,$9,$10,$11,$12,$13
 done

 #Gradient Norm 1
 blur $15
 gradient_norm ^ $16
 cut $17%,$18%
 if $19
  negate
 endif
 normalize 0,255

 #Gradient Norm 2
 blur $20
 gradient_norm ^ $21
 cut $22%,$23%
 if $24
  negate
 endif
 normalize 0,255

 #Upscale [dcci2x] by Garagecode
 split_opacity
 scale_dcci2x ${25-27}
 append c
 cut 0,255

 #Gradient Norm 3
 blur $28
 gradient_norm ^ $29
 cut $30%,$31%
 if $32
  negate
 endif
 normalize 0,255

Lylejk_Wicker_preview : skip ${33=0},${34=1},${35=10},${36=1},${37=0}
 gui_split_preview "Lylejk_Wicker $*",$-1

#################################################
##                                             ##
##             FIN Lylejk_Wicker               ##
##                                             ##
#################################################


#@gui _
#@gui _
#@gui _
###################################
##### Aux amours de nos vies ######
###################################

                #
               ###
                #

############   ###   ####       ###
############   ###   #####      ###
###            ###   ######     ###
###            ###   ### ###    ###
######         ###   ###  ###   ###
######         ###   ###   ###  ###
###            ###   ###    ### ###
###            ###   ###     ######
###            ###   ###      #####
###            ###   ###       ####
###################################
###################################
###################################
# Local Variables:
# mode: sh
# End:
#
# (End of G'MIC custom commands)
